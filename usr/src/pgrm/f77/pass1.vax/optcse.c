begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)optcse.c	5.2 (Berkeley) 1/3/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * optcse.c  *  * Common subexpression elimination routines, F77 compiler pass 1.  *  * University of Utah CS Dept modification history:  *  * $Log:	optcse.c,v $  * Revision 2.4  84/10/29  04:40:48  donn  * Problem with conversions -- two expressions headed by a conversion may be  * identical in structure but different in type, thus type must be checked in  * findnode().  This was causing a subscript to become REAL*8 type...  *   * Revision 2.3  84/08/04  20:38:53  donn  * Added fix from Jerry Berkman for an earlier fix from Alastair Fyfe --  * samebase() should treat EQUIVALENCEd variables just as daintily as  * COMMON variables.  *   * Revision 2.2  84/08/01  16:04:33  donn  * Changed rmcommaop so that it does subscripts too.  *   * Revision 2.1  84/07/19  12:03:44  donn  * Changed comment headers for UofU.  *   * Revision 1.5  84/07/09  14:43:05  donn  * Added changes to make OPPLUSEQ and OPSTAREQ expressions ineligible for  * CSE, since I can't think of a simple way to handle them and they are broken  * in the previous version, where they were treated like OPASSIGN -- this  * fails because CSE would think that the value of the lhs and rhs were equal.  *   * Revision 1.4  84/06/08  11:43:35  donn  * Yet another way of handling the bug with COMMON -- this one is from Alastair  * Fyfe at Sun.  I backed out the old fix.  *   * Revision 1.3  84/03/07  19:25:14  donn  * Changed method of handling COMMON bug -- COMMON variables are now treated  * like array elements and hence are ineligible for CSE.  *   * Revision 1.2  84/02/26  03:30:47  donn  * Fixed bug in evaluation graph construction that caused two variables in  * common to be considered identical if they were merely in the same common,  * rather than in the same common at the same offset.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"optim.h"
end_include

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_decl_stmt
name|LOCAL
name|Bblockp
name|current_BB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|cse1count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of number of cse uses eliminated */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|cse2count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of number of cse def's eliminated */
end_comment

begin_function
name|LOCAL
name|dumpstacks
parameter_list|()
block|{
name|duplptr
name|dl
decl_stmt|;
name|valuen
name|p
decl_stmt|;
name|idlptr
name|idl
decl_stmt|;
name|idptr
name|idp
decl_stmt|;
name|nodelptr
name|nl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n *** IDblocks ***\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|idp
operator|=
name|current_BB
operator|->
name|headid
init|;
name|idp
condition|;
name|idp
operator|=
name|idp
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"idp= %d idaddr= %d initval= %d assgnval= %d \n"
argument_list|,
name|idp
argument_list|,
name|idp
operator|->
name|idaddr
argument_list|,
name|idp
operator|->
name|initval
argument_list|,
name|idp
operator|->
name|assgnval
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"nodes: "
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nl
operator|=
name|idp
operator|->
name|headnodelist
init|;
name|nl
condition|;
name|nl
operator|=
name|nl
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
literal|20
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" %d "
argument_list|,
name|nl
operator|->
name|nodep
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n *** VALUE NODES *** \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_BB
operator|->
name|headnode
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\np= %d opp= %d lc= %d rc= %d rs= %d is_dead= %d n_dups %d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|opp
argument_list|,
name|p
operator|->
name|lc
argument_list|,
name|p
operator|->
name|rc
argument_list|,
name|p
operator|->
name|rs
argument_list|,
name|p
operator|->
name|is_dead
argument_list|,
name|p
operator|->
name|n_dups
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rs
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"tag= %d "
argument_list|,
name|p
operator|->
name|opp
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"opco= %d "
argument_list|,
name|p
operator|->
name|opp
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"parent= %d dups:  "
argument_list|,
name|p
operator|->
name|parent
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|p
operator|->
name|headduplist
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
literal|20
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" %d "
argument_list|,
name|dl
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\ndeps IDs"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idl
operator|=
name|p
operator|->
name|headdeplist
init|;
name|idl
condition|;
name|idl
operator|=
name|idl
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
literal|20
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" %d "
argument_list|,
name|idl
operator|->
name|idp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|LOCAL
name|idlptr
name|mergedeps
parameter_list|(
name|lnode
parameter_list|,
name|rnode
parameter_list|)
name|valuen
name|lnode
decl_stmt|,
name|rnode
decl_stmt|;
comment|/* Given two value nodes, merge the lists of identifiers on which they ** depend to produce a new list incorporating both dependencies. Lists ** are assumed to be ordered by increasing idp address. No duplicate identifiers ** are generated in the output list. */
block|{
specifier|register
name|idlptr
name|lp
decl_stmt|,
name|lp1
decl_stmt|,
name|lp2
decl_stmt|;
name|idlptr
name|head
decl_stmt|;
name|lp
operator|=
name|lp1
operator|=
name|lp2
operator|=
name|head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lnode
condition|)
name|lp1
operator|=
name|lnode
operator|->
name|headdeplist
expr_stmt|;
if|if
condition|(
name|rnode
condition|)
name|lp2
operator|=
name|rnode
operator|->
name|headdeplist
expr_stmt|;
while|while
condition|(
name|lp1
operator|||
name|lp2
condition|)
block|{
if|if
condition|(
name|lp
condition|)
block|{
name|lp
operator|->
name|next
operator|=
name|ALLOC
argument_list|(
name|IDlist
argument_list|)
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
else|else
name|lp
operator|=
name|head
operator|=
name|ALLOC
argument_list|(
name|IDlist
argument_list|)
expr_stmt|;
name|lp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp1
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|idp
operator|=
name|lp2
operator|->
name|idp
expr_stmt|;
name|lp2
operator|=
name|lp2
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp2
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|idp
operator|=
name|lp1
operator|->
name|idp
expr_stmt|;
name|lp1
operator|=
name|lp1
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp1
operator|->
name|idp
operator|<
name|lp2
operator|->
name|idp
condition|)
block|{
name|lp
operator|->
name|idp
operator|=
name|lp1
operator|->
name|idp
expr_stmt|;
name|lp1
operator|=
name|lp1
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp1
operator|->
name|idp
operator|>
name|lp2
operator|->
name|idp
condition|)
block|{
name|lp
operator|->
name|idp
operator|=
name|lp2
operator|->
name|idp
expr_stmt|;
name|lp2
operator|=
name|lp2
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|->
name|idp
operator|=
name|lp1
operator|->
name|idp
expr_stmt|;
name|lp1
operator|=
name|lp1
operator|->
name|next
expr_stmt|;
name|lp2
operator|=
name|lp2
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|removenode
parameter_list|(
name|nodep
parameter_list|)
name|valuen
name|nodep
decl_stmt|;
comment|/*  Removes a value node from every IDblock on the node's list of identifiers. */
block|{
specifier|register
name|idlptr
name|idl
decl_stmt|;
specifier|register
name|nodelptr
name|nl
decl_stmt|;
specifier|register
name|nodelptr
modifier|*
name|addrnl
decl_stmt|;
if|if
condition|(
name|nodep
operator|==
name|NULL
condition|)
return|return ;
comment|/* loop through all identifiers */
for|for
control|(
name|idl
operator|=
name|nodep
operator|->
name|headdeplist
init|;
name|idl
condition|;
name|idl
operator|=
name|idl
operator|->
name|next
control|)
block|{
name|addrnl
operator|=
operator|&
operator|(
name|idl
operator|->
name|idp
operator|->
name|headnodelist
operator|)
expr_stmt|;
comment|/* for each identifier loop through all nodes until match is found */
for|for
control|(
name|nl
operator|=
operator|*
name|addrnl
init|;
name|nl
condition|;
name|nl
operator|=
operator|*
name|addrnl
control|)
block|{
if|if
condition|(
name|nl
operator|->
name|nodep
operator|==
name|nodep
condition|)
block|{
operator|*
name|addrnl
operator|=
name|nl
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|nl
argument_list|)
expr_stmt|;
break|break;
block|}
name|addrnl
operator|=
operator|&
name|nl
operator|->
name|next
expr_stmt|;
block|}
block|}
name|nodep
operator|->
name|is_dead
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|killid
parameter_list|(
name|idp
parameter_list|)
name|idptr
name|idp
decl_stmt|;
comment|/* Kill all nodes on one identifier's list of dependent nodes, i.e. remove ** all calculations that depend on this identifier from the available  ** values stack.  Free the list of records pointing at the dependent nodes. */
block|{
name|nodelptr
name|nl1
decl_stmt|,
name|nl2
decl_stmt|;
for|for
control|(
name|nl1
operator|=
name|idp
operator|->
name|headnodelist
init|;
name|nl1
condition|;
name|nl1
operator|=
name|nl2
control|)
block|{
name|nl2
operator|=
name|nl1
operator|->
name|next
expr_stmt|;
name|removenode
argument_list|(
name|nl1
operator|->
name|nodep
argument_list|)
expr_stmt|;
block|}
comment|/* the above call frees the node list record pointed at by nl1 since it frees 	** all the node list records that reference the value node being killed 	*/
name|idp
operator|->
name|headnodelist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|killdepnodes
parameter_list|(
name|idp
parameter_list|)
name|idptr
name|idp
decl_stmt|;
comment|/* Kill all value nodes that represent calculations which depend on ** this identifier. If the identifier is in COMMON or EQUIVALENCE storage, ** kill all values that depend on identifiers in COMMON or EQUIVALENCE */
block|{
name|int
name|thismemno
decl_stmt|;
if|if
condition|(
name|idp
operator|->
name|idaddr
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGCOMMON
condition|)
block|{
for|for
control|(
name|idp
operator|=
name|current_BB
operator|->
name|headid
init|;
name|idp
condition|;
name|idp
operator|=
name|idp
operator|->
name|next
control|)
if|if
condition|(
name|idp
operator|->
name|idaddr
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGCOMMON
condition|)
name|killid
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idp
operator|->
name|idaddr
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGEQUIV
condition|)
block|{
name|thismemno
operator|=
name|idp
operator|->
name|idaddr
operator|->
name|addrblock
operator|.
name|memno
expr_stmt|;
for|for
control|(
name|idp
operator|=
name|current_BB
operator|->
name|headid
init|;
name|idp
condition|;
name|idp
operator|=
name|idp
operator|->
name|next
control|)
if|if
condition|(
name|idp
operator|->
name|idaddr
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGEQUIV
operator|&&
name|idp
operator|->
name|idaddr
operator|->
name|addrblock
operator|.
name|memno
operator|==
name|thismemno
condition|)
name|killid
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
else|else
name|killid
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|appendnode
parameter_list|(
name|nodep
parameter_list|)
name|valuen
name|nodep
decl_stmt|;
comment|/* Append a value node to all the IDblocks on that node's list of ** dependent identifiers i.e., since this computation depends on ** all the identifiers on its list then each of those identifiers should ** include this node in their list of dependent nodes. */
block|{
specifier|register
name|idlptr
name|idl
decl_stmt|;
specifier|register
name|nodelptr
name|nl
decl_stmt|;
for|for
control|(
name|idl
operator|=
name|nodep
operator|->
name|headdeplist
init|;
name|idl
condition|;
name|idl
operator|=
name|idl
operator|->
name|next
control|)
if|if
condition|(
name|idl
operator|->
name|idp
operator|->
name|idaddr
operator|->
name|tag
operator|==
name|TADDR
operator|||
name|idl
operator|->
name|idp
operator|->
name|idaddr
operator|->
name|tag
operator|==
name|TTEMP
condition|)
block|{
name|nl
operator|=
name|ALLOC
argument_list|(
name|NODElist
argument_list|)
expr_stmt|;
name|nl
operator|->
name|nodep
operator|=
name|nodep
expr_stmt|;
name|nl
operator|->
name|next
operator|=
name|idl
operator|->
name|idp
operator|->
name|headnodelist
expr_stmt|;
name|idl
operator|->
name|idp
operator|->
name|headnodelist
operator|=
name|nl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|idlptr
name|addadep
parameter_list|(
name|idp
parameter_list|,
name|nodep
parameter_list|)
name|idptr
name|idp
decl_stmt|;
name|valuen
name|nodep
decl_stmt|;
comment|/* Add an identifier to the dependents list of a value node.  Dependents ** lists are ordered by increasing idp value */
block|{
specifier|register
name|idlptr
name|lp1
decl_stmt|,
name|lp2
decl_stmt|;
name|lp2
operator|=
name|ALLOC
argument_list|(
name|IDlist
argument_list|)
expr_stmt|;
name|lp2
operator|->
name|idp
operator|=
name|idp
expr_stmt|;
if|if
condition|(
name|nodep
operator|->
name|headdeplist
operator|==
literal|0
condition|)
block|{
name|lp2
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|nodep
operator|->
name|headdeplist
operator|=
name|lp2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idp
operator|<=
name|nodep
operator|->
name|headdeplist
operator|->
name|idp
condition|)
block|{
name|lp2
operator|->
name|next
operator|=
name|nodep
operator|->
name|headdeplist
expr_stmt|;
name|nodep
operator|->
name|headdeplist
operator|=
name|lp2
expr_stmt|;
block|}
else|else
for|for
control|(
name|lp1
operator|=
name|nodep
operator|->
name|headdeplist
init|;
name|lp1
condition|;
name|lp1
operator|=
name|lp1
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|lp1
operator|->
name|next
operator|==
literal|0
operator|)
operator|||
operator|(
name|idp
operator|<=
name|lp1
operator|->
name|next
operator|->
name|idp
operator|)
condition|)
block|{
name|lp2
operator|->
name|next
operator|=
name|lp1
operator|->
name|next
expr_stmt|;
name|lp1
operator|->
name|next
operator|=
name|lp2
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|lp2
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|valuen
name|newnode
parameter_list|(
name|expr
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|,
name|rslt
parameter_list|)
name|expptr
name|expr
decl_stmt|;
name|valuen
name|left
decl_stmt|,
name|right
decl_stmt|,
name|rslt
decl_stmt|;
comment|/* Build a new value node             */
block|{
specifier|register
name|valuen
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|VALUEnode
argument_list|)
expr_stmt|;
name|p
operator|->
name|opp
operator|=
name|expr
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|lc
operator|=
name|left
expr_stmt|;
name|p
operator|->
name|rc
operator|=
name|right
expr_stmt|;
name|p
operator|->
name|rs
operator|=
name|rslt
expr_stmt|;
name|p
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|is_dead
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|headdeplist
operator|=
name|mergedeps
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|p
operator|->
name|headduplist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|current_BB
operator|->
name|headnode
operator|==
literal|0
condition|)
name|current_BB
operator|->
name|headnode
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|current_BB
operator|->
name|tailnode
condition|)
name|current_BB
operator|->
name|tailnode
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|current_BB
operator|->
name|tailnode
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|newid
parameter_list|(
name|idaddr
parameter_list|,
name|addrof_idptr
parameter_list|)
name|expptr
name|idaddr
decl_stmt|;
name|idptr
modifier|*
name|addrof_idptr
decl_stmt|;
comment|/* Build a new IDblock and hook it on the current BB's ID list */
block|{
specifier|register
name|idptr
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|IDblock
argument_list|)
expr_stmt|;
comment|/* build a leaf value node for the identifier and put the ID on the leaf node's ** list of dependent identifiers */
name|p
operator|->
name|initval
operator|=
name|newnode
argument_list|(
name|idaddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|initval
operator|->
name|rs
operator|=
name|p
operator|->
name|initval
expr_stmt|;
name|addadep
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|initval
argument_list|)
expr_stmt|;
name|p
operator|->
name|idaddr
operator|=
name|idaddr
expr_stmt|;
operator|*
name|addrof_idptr
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|headnodelist
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|addadup
parameter_list|(
name|parent
parameter_list|,
name|nodep
parameter_list|)
name|expptr
modifier|*
name|parent
decl_stmt|;
name|valuen
name|nodep
decl_stmt|;
comment|/* A subtree has been found that duplicates the calculation represented ** by the value node referenced by nodep : add the root of the reduntant ** tree to the value node's list of duplicates. */
block|{
specifier|register
name|duplptr
name|dp
decl_stmt|;
name|valuen
name|child
decl_stmt|;
name|dp
operator|=
name|ALLOC
argument_list|(
name|DUPlist
argument_list|)
expr_stmt|;
name|dp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|dp
operator|->
name|next
operator|=
name|nodep
operator|->
name|headduplist
expr_stmt|;
name|nodep
operator|->
name|headduplist
operator|=
name|dp
expr_stmt|;
operator|++
name|nodep
operator|->
name|n_dups
expr_stmt|;
comment|/* Check whether either of nodep's children is also a duplicate calculation ** and if so peel off it's most recent dup record */
if|if
condition|(
operator|(
name|child
operator|=
name|nodep
operator|->
name|lc
operator|)
operator|&&
operator|(
name|child
operator|->
name|n_dups
operator|)
condition|)
block|{
name|dp
operator|=
name|child
operator|->
name|headduplist
expr_stmt|;
name|child
operator|->
name|headduplist
operator|=
name|dp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|dp
argument_list|)
expr_stmt|;
operator|--
name|child
operator|->
name|n_dups
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|child
operator|=
name|nodep
operator|->
name|rc
operator|)
operator|&&
operator|(
name|child
operator|->
name|n_dups
operator|)
condition|)
block|{
name|dp
operator|=
name|child
operator|->
name|headduplist
expr_stmt|;
name|child
operator|->
name|headduplist
operator|=
name|dp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|dp
argument_list|)
expr_stmt|;
operator|--
name|child
operator|->
name|n_dups
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|samebase
parameter_list|(
name|ep1
parameter_list|,
name|ep2
parameter_list|)
name|expptr
name|ep1
decl_stmt|,
name|ep2
decl_stmt|;
block|{
if|if
condition|(
name|ep1
operator|->
name|tag
operator|==
name|ep2
operator|->
name|tag
condition|)
switch|switch
condition|(
name|ep2
operator|->
name|tag
condition|)
block|{
case|case
name|TTEMP
case|:
if|if
condition|(
name|ep1
operator|->
name|tempblock
operator|.
name|memalloc
operator|==
name|ep2
operator|->
name|tempblock
operator|.
name|memalloc
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
break|break;
case|case
name|TADDR
case|:
if|if
condition|(
name|ep1
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|ep2
operator|->
name|addrblock
operator|.
name|vstg
condition|)
block|{
switch|switch
condition|(
name|ep1
operator|->
name|addrblock
operator|.
name|vstg
condition|)
block|{
case|case
name|STGEQUIV
case|:
case|case
name|STGCOMMON
case|:
if|if
condition|(
name|ep1
operator|->
name|addrblock
operator|.
name|memno
operator|==
name|ep2
operator|->
name|addrblock
operator|.
name|memno
operator|&&
name|ISCONST
argument_list|(
name|ep1
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|ep2
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
operator|&&
name|ep1
operator|->
name|addrblock
operator|.
name|memoffset
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
name|ep2
operator|->
name|addrblock
operator|.
name|memoffset
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|ep1
operator|->
name|addrblock
operator|.
name|memno
operator|==
name|ep2
operator|->
name|addrblock
operator|.
name|memno
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|TCONST
case|:
if|if
condition|(
operator|(
name|ep1
operator|->
name|constblock
operator|.
name|vtype
operator|)
operator|==
operator|(
name|ep2
operator|->
name|constblock
operator|.
name|vtype
operator|)
condition|)
block|{
name|union
name|Constant
modifier|*
name|ap
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|ap
operator|=
operator|&
name|ep1
operator|->
name|constblock
operator|.
name|constant
expr_stmt|;
name|bp
operator|=
operator|&
name|ep2
operator|->
name|constblock
operator|.
name|constant
expr_stmt|;
switch|switch
condition|(
name|ep1
operator|->
name|constblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
if|if
condition|(
name|ap
operator|->
name|ci
operator|==
name|bp
operator|->
name|ci
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|==
name|bp
operator|->
name|cd
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|ap
operator|->
name|cd
index|[
literal|0
index|]
operator|==
name|bp
operator|->
name|cd
index|[
literal|0
index|]
operator|&&
name|ap
operator|->
name|cd
index|[
literal|1
index|]
operator|==
name|bp
operator|->
name|cd
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
break|break;
block|}
block|}
break|break;
default|default :
name|badtag
argument_list|(
literal|"samebase"
argument_list|,
name|ep2
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|idptr
name|findid
parameter_list|(
name|idaddr
parameter_list|)
name|expptr
name|idaddr
decl_stmt|;
comment|/* Find an identifier's IDblock given its idaddr. If the identifier has no ** IBblock build one */
block|{
specifier|register
name|idptr
name|idp
decl_stmt|;
if|if
condition|(
name|current_BB
operator|->
name|headid
operator|==
literal|0
condition|)
name|newid
argument_list|(
name|idaddr
argument_list|,
operator|&
name|current_BB
operator|->
name|headid
argument_list|)
expr_stmt|;
name|idp
operator|=
name|current_BB
operator|->
name|headid
expr_stmt|;
do|do
block|{
if|if
condition|(
name|samebase
argument_list|(
name|idp
operator|->
name|idaddr
argument_list|,
name|idaddr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|idp
operator|->
name|next
operator|==
literal|0
condition|)
block|{
name|newid
argument_list|(
name|idaddr
argument_list|,
operator|&
name|idp
operator|->
name|next
argument_list|)
expr_stmt|;
name|idp
operator|=
name|idp
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|idp
operator|=
name|idp
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|TRUE
condition|)
do|;
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|valuen
name|findnode
parameter_list|(
name|ep
parameter_list|,
name|leftc
parameter_list|,
name|rightc
parameter_list|)
name|expptr
name|ep
decl_stmt|;
name|valuen
name|leftc
decl_stmt|,
name|rightc
decl_stmt|;
block|{
comment|/* Look for a matching value node in the available computations stack 	*/
specifier|register
name|valuen
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|current_BB
operator|->
name|headnode
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|p
operator|->
name|is_dead
operator|)
operator|&&
operator|(
name|p
operator|->
name|lc
operator|==
name|leftc
operator|)
operator|&&
operator|(
name|p
operator|->
name|rc
operator|==
name|rightc
operator|)
operator|&&
operator|(
operator|(
name|ep
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|opp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|opp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|ep
operator|->
name|exprblock
operator|.
name|opcode
operator|&&
name|p
operator|->
name|opp
operator|->
name|exprblock
operator|.
name|vtype
operator|==
name|ep
operator|->
name|exprblock
operator|.
name|vtype
operator|)
operator|||
operator|(
name|ep
operator|->
name|tag
operator|==
name|TADDR
operator|)
operator|||
operator|(
name|ep
operator|->
name|tag
operator|==
name|TTEMP
operator|)
operator|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|valuen
name|scanchain
parameter_list|(
name|listp
parameter_list|,
name|p_parent
parameter_list|)
name|expptr
name|listp
decl_stmt|;
name|chainp
modifier|*
name|p_parent
decl_stmt|;
comment|/* Make value nodes from the chain hanging off a LISTBLOCK */
block|{
name|valuen
name|lnode
decl_stmt|,
name|rnode
decl_stmt|,
name|new
decl_stmt|,
name|scantree
argument_list|()
decl_stmt|;
name|chainp
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|p_parent
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lnode
operator|=
name|scantree
argument_list|(
operator|&
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
name|rnode
operator|=
name|scanchain
argument_list|(
name|listp
argument_list|,
operator|&
name|p
operator|->
name|nextp
argument_list|)
expr_stmt|;
name|new
operator|=
name|newnode
argument_list|(
name|listp
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|valuen
name|scantree
parameter_list|(
name|p_parent
parameter_list|)
name|expptr
modifier|*
name|p_parent
decl_stmt|;
comment|/* build a value node and return its address. p must point to an ** exprblock an addrblock a listblock  or a constblock. */
block|{
name|valuen
name|lnode
decl_stmt|,
name|rnode
decl_stmt|,
name|rsltnode
decl_stmt|,
name|new
decl_stmt|;
name|expptr
name|opp
decl_stmt|,
name|p
decl_stmt|;
name|Exprp
name|ep1
decl_stmt|,
name|ep2
decl_stmt|;
name|idptr
name|idp
decl_stmt|;
name|p
operator|=
operator|*
name|p_parent
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|findid
argument_list|(
name|p
argument_list|)
operator|->
name|initval
operator|)
return|;
case|case
name|TTEMP
case|:
name|idp
operator|=
name|findid
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|assgnval
condition|)
return|return
operator|(
name|idp
operator|->
name|assgnval
operator|)
return|;
name|lnode
operator|=
name|idp
operator|->
name|initval
expr_stmt|;
name|rnode
operator|=
name|scantree
argument_list|(
operator|&
name|p
operator|->
name|tempblock
operator|.
name|memalloc
argument_list|)
expr_stmt|;
name|rsltnode
operator|=
name|findnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsltnode
condition|)
return|return
operator|(
name|rsltnode
operator|)
return|;
else|else
block|{
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|parent
operator|=
name|p_parent
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
case|case
name|TADDR
case|:
name|idp
operator|=
name|findid
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|assgnval
condition|)
return|return
operator|(
name|idp
operator|->
name|assgnval
operator|)
return|;
name|lnode
operator|=
name|idp
operator|->
name|initval
expr_stmt|;
name|rnode
operator|=
name|scantree
argument_list|(
operator|&
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|rsltnode
operator|=
name|findnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsltnode
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* 			 * This code is broken until OPINDIRECT is implemented. 			 */
if|if
condition|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|->
name|tag
operator|==
name|TEXPR
condition|)
name|addadup
argument_list|(
name|p_parent
argument_list|,
name|rsltnode
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
return|return
operator|(
name|rsltnode
operator|)
return|;
block|}
else|else
block|{
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|parent
operator|=
name|p_parent
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
case|case
name|TLIST
case|:
return|return
operator|(
name|scanchain
argument_list|(
name|p
operator|->
name|listblock
operator|.
name|listp
argument_list|,
operator|&
name|p
operator|->
name|listblock
operator|.
name|listp
argument_list|)
operator|)
return|;
default|default :
name|badtag
argument_list|(
literal|"scantree"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
case|case
name|TEXPR
case|:
name|lnode
operator|=
name|scantree
argument_list|(
operator|&
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|rnode
operator|=
name|scantree
argument_list|(
operator|&
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPASSIGN
case|:
block|{
name|Addrp
name|ap
decl_stmt|;
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|idp
operator|=
name|findid
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|killdepnodes
argument_list|(
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|isarray
condition|)
block|{
if|if
condition|(
name|rnode
operator|->
name|is_dead
condition|)
name|idp
operator|->
name|assgnval
operator|=
name|idp
operator|->
name|initval
expr_stmt|;
else|else
name|idp
operator|->
name|assgnval
operator|=
name|rnode
expr_stmt|;
block|}
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|idp
operator|->
name|initval
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|appendnode
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
comment|/* 			 * Don't optimize these...  they're a real hassle. 			 */
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
block|{
name|Addrp
name|ap
decl_stmt|;
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|idp
operator|=
name|findid
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|killdepnodes
argument_list|(
name|idp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|assgnval
operator|=
name|NULL
expr_stmt|;
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
case|case
name|OPCALL
case|:
block|{
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
comment|/* pretend that all variables on the arglist have just 	** been assigned to i.e. kill of calculations that  	** depend on them. Not necessary for CCALL(by value) 	*/
for|for
control|(
name|cp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|listblock
operator|.
name|listp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
if|if
condition|(
name|cp
operator|->
name|datap
operator|->
name|tag
operator|==
name|TADDR
operator|||
name|cp
operator|->
name|datap
operator|->
name|tag
operator|==
name|TTEMP
condition|)
block|{
name|idp
operator|=
name|findid
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
name|killdepnodes
argument_list|(
name|idp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|assgnval
operator|=
name|NULL
expr_stmt|;
block|}
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
case|case
name|OPCONCAT
case|:
case|case
name|OPADDR
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPINDIRECT
case|:
comment|/* 		 * For now, do not optimize LSHIFT until OPINDIRECT 		 * implemented. 		 */
case|case
name|OPLSHIFT
case|:
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
case|case
name|OPCOMMA
case|:
name|badop
argument_list|(
literal|"scantree"
argument_list|,
name|OPCOMMA
argument_list|)
expr_stmt|;
break|break;
default|default :
name|rsltnode
operator|=
name|findnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsltnode
condition|)
block|{
name|addadup
argument_list|(
name|p_parent
argument_list|,
name|rsltnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rsltnode
operator|)
return|;
block|}
else|else
block|{
name|new
operator|=
name|newnode
argument_list|(
name|p
argument_list|,
name|lnode
argument_list|,
name|rnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|rs
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|parent
operator|=
name|p_parent
expr_stmt|;
name|appendnode
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|->
name|rs
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|LOCAL
name|prunetrees
parameter_list|()
comment|/* The only optcse.c routine that does any real work: go through the available ** computations stack and eliminate redundant subtrees. */
block|{
name|Addrp
name|tempv
decl_stmt|;
specifier|register
name|duplptr
name|dl
decl_stmt|;
specifier|register
name|valuen
name|p
decl_stmt|;
name|expptr
name|t
decl_stmt|;
name|int
name|is_addrnode
decl_stmt|;
name|expptr
modifier|*
name|addr_tree1
init|=
name|NULL
decl_stmt|;
name|expptr
name|tree2
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|p
operator|=
name|current_BB
operator|->
name|headnode
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|rs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|addr_tree1
operator|&&
name|tree2
condition|)
operator|*
name|addr_tree1
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|tree2
argument_list|,
operator|*
name|addr_tree1
argument_list|)
argument_list|)
expr_stmt|;
name|addr_tree1
operator|=
operator|(
name|expptr
operator|*
operator|)
name|p
operator|->
name|opp
expr_stmt|;
name|tree2
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|n_dups
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|opp
operator|->
name|tag
operator|==
name|TTEMP
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"TTEMP in prunetrees - cbb\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opp
operator|->
name|tag
operator|==
name|TADDR
condition|)
name|is_addrnode
operator|=
name|TRUE
expr_stmt|;
else|else
name|is_addrnode
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|is_addrnode
condition|)
name|tempv
operator|=
name|mktemp
argument_list|(
name|TYADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|tempv
operator|=
name|mktemp
argument_list|(
name|p
operator|->
name|opp
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|p
operator|->
name|opp
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|cse2count
operator|++
expr_stmt|;
if|if
condition|(
name|tree2
condition|)
name|tree2
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|tree2
argument_list|,
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tempv
argument_list|)
argument_list|,
operator|(
name|is_addrnode
condition|?
name|addrof
argument_list|(
name|p
operator|->
name|opp
argument_list|)
else|:
name|p
operator|->
name|opp
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tree2
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tempv
argument_list|)
argument_list|,
operator|(
name|is_addrnode
condition|?
name|addrof
argument_list|(
name|p
operator|->
name|opp
argument_list|)
else|:
name|p
operator|->
name|opp
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_addrnode
condition|)
operator|*
operator|(
name|p
operator|->
name|parent
operator|)
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPINDIRECT
argument_list|,
name|cpexpr
argument_list|(
name|tempv
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|->
name|parent
operator|)
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|tempv
argument_list|)
expr_stmt|;
comment|/* then replaces all future instances of the calculation by references to    the temporary */
for|for
control|(
name|dl
operator|=
name|p
operator|->
name|headduplist
init|;
name|dl
operator|->
name|next
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|cse1count
operator|++
expr_stmt|;
name|frexpr
argument_list|(
operator|*
name|dl
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_addrnode
condition|)
operator|*
operator|(
name|dl
operator|->
name|parent
operator|)
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPINDIRECT
argument_list|,
name|cpexpr
argument_list|(
name|tempv
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|dl
operator|->
name|parent
operator|)
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|tempv
argument_list|)
expr_stmt|;
block|}
comment|/* the last reference does not use a copy since the temporary can    now be freed */
name|cse1count
operator|++
expr_stmt|;
name|frexpr
argument_list|(
operator|*
name|dl
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_addrnode
condition|)
operator|*
operator|(
name|dl
operator|->
name|parent
operator|)
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPINDIRECT
argument_list|,
name|tempv
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|dl
operator|->
name|parent
operator|)
operator|=
operator|(
name|expptr
operator|)
name|tempv
expr_stmt|;
name|frtemp
argument_list|(
name|tempv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addr_tree1
operator|&&
name|tree2
condition|)
operator|*
name|addr_tree1
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|tree2
argument_list|,
operator|*
name|addr_tree1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|rewritebb
parameter_list|(
name|bb
parameter_list|)
name|Bblockp
name|bb
decl_stmt|;
block|{
name|Slotp
name|sp
decl_stmt|;
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|NULL
condition|)
return|return;
else|else
name|current_BB
operator|=
name|bb
expr_stmt|;
name|sp
operator|=
name|current_BB
operator|->
name|first
expr_stmt|;
comment|/* loop trough all BB slots and scan candidate expr trees when found */
for|for
control|(
name|sp
operator|=
name|current_BB
operator|->
name|first
init|;
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|SKEQ
case|:
case|case
name|SKIFN
case|:
case|case
name|SKCMGOTO
case|:
case|case
name|SKCALL
case|:
name|newnode
argument_list|(
operator|(
name|expptr
operator|)
operator|&
name|sp
operator|->
name|expr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|scantree
argument_list|(
operator|&
name|sp
operator|->
name|expr
argument_list|)
expr_stmt|;
break|break;
default|default  :
break|break;
block|}
if|if
condition|(
name|sp
operator|==
name|current_BB
operator|->
name|last
condition|)
break|break;
block|}
comment|/* use the information built up by scantree to prune reduntant subtrees */
name|prunetrees
argument_list|()
expr_stmt|;
name|current_BB
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  removes all instances of OPCOMMA from the given subexpression of  *  the given buffer slot  */
end_comment

begin_function
name|expptr
name|rmcommaop
parameter_list|(
name|p
parameter_list|,
name|sl
parameter_list|)
name|expptr
name|p
decl_stmt|;
name|Slotp
name|sl
decl_stmt|;
block|{
name|expptr
name|leftp
decl_stmt|,
name|rightp
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|ENULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TEXPR
case|:
name|leftp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rightp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|leftp
operator|=
name|rmcommaop
argument_list|(
name|leftp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCOMMA
condition|)
block|{
name|optinsert
argument_list|(
name|SKEQ
argument_list|,
name|leftp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
condition|)
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|rmcommaop
argument_list|(
name|rightp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|leftp
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|rmcommaop
argument_list|(
name|rightp
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TLIST
case|:
for|for
control|(
name|cp
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|rmcommaop
argument_list|(
name|cp
operator|->
name|datap
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TADDR
case|:
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|rmcommaop
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
default|default:
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  scans the code buffer, performing common subexpression elimination  */
end_comment

begin_macro
name|optcse
argument_list|()
end_macro

begin_block
block|{
name|Slotp
name|sl
decl_stmt|;
name|Bblockp
name|bb
decl_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|13
index|]
condition|)
return|return;
name|cse1count
operator|=
literal|0
expr_stmt|;
name|cse2count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|firstslot
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|sl
operator|->
name|expr
operator|=
name|rmcommaop
argument_list|(
name|sl
operator|->
name|expr
argument_list|,
name|sl
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|firstblock
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|next
control|)
name|rewritebb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%d common subexpression use%s eliminated (%d definition%s)\n"
argument_list|,
name|cse1count
argument_list|,
operator|(
name|cse1count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|,
name|cse2count
argument_list|,
operator|(
name|cse2count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

