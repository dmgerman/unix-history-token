begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asexpr.c 4.5 6/30/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_comment
comment|/*  * Tables for combination of operands.  */
end_comment

begin_define
define|#
directive|define
name|XTXRN
value|5<<1
end_define

begin_comment
comment|/* indexes last row/column when right shifted */
end_comment

begin_comment
comment|/*  *	table for +  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|pltab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|XTEXT
block|,
name|XDATA
block|,
name|XBSS
block|,
name|XXTRN
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	table for -  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|mintab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *	table for other operators  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|othtab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|exp
modifier|*
name|combine
parameter_list|(
name|op
parameter_list|,
name|exp1
parameter_list|,
name|exp2
parameter_list|)
name|reg
name|struct
name|exp
modifier|*
name|exp1
decl_stmt|,
decl|*
name|exp2
decl_stmt|;
end_function

begin_block
block|{
name|reg
name|int
name|e1_type
decl_stmt|,
name|e2_type
decl_stmt|;
name|reg
name|int
name|back_type
decl_stmt|;
name|char
modifier|*
name|btype
init|=
literal|"The assembler can only do arithmetic on 1,2, or 4 byte integers"
decl_stmt|;
name|lastnam
operator|=
literal|0
expr_stmt|;
comment|/* kludge for jxxx instructions */
name|e1_type
operator|=
name|exp1
operator|->
name|e_xtype
operator|&
name|XTYPE
expr_stmt|;
name|e2_type
operator|=
name|exp2
operator|->
name|e_xtype
operator|&
name|XTYPE
expr_stmt|;
if|if
condition|(
name|exp1
operator|->
name|e_xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e1_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|exp2
operator|->
name|e_xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
if|if
condition|(
name|exp1
operator|->
name|e_xloc
operator|!=
name|exp2
operator|->
name|e_xloc
operator|&&
name|e1_type
operator|==
name|e2_type
condition|)
name|e1_type
operator|=
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
comment|/* error on != loc ctrs */
name|e1_type
operator|>>=
literal|1
expr_stmt|;
comment|/*dispose of the external (XXTRN) bit*/
name|e2_type
operator|>>=
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PLUS
case|:
name|exp1
operator|->
name|e_xvalue
operator|+=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
name|back_type
operator|=
name|pltab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|exp1
operator|->
name|e_xvalue
operator|-=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
name|back_type
operator|=
name|mintab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|exp1
operator|->
name|e_xvalue
operator||=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|XOR
case|:
name|exp1
operator|->
name|e_xvalue
operator|^=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|AND
case|:
name|exp1
operator|->
name|e_xvalue
operator|&=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|ORNOT
case|:
name|exp1
operator|->
name|e_xvalue
operator||=
operator|~
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|LSH
case|:
name|exp1
operator|->
name|e_xvalue
operator|<<=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|RSH
case|:
name|exp1
operator|->
name|e_xvalue
operator|>>=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|TILDE
case|:
name|exp1
operator|->
name|e_xvalue
operator||=
operator|~
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|MUL
case|:
name|exp1
operator|->
name|e_xvalue
operator|*=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|DIV
case|:
if|if
condition|(
name|exp2
operator|->
name|e_xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|e_xvalue
operator|/=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|REGOP
case|:
if|if
condition|(
name|exp2
operator|->
name|e_xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check (modulo)"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|e_xvalue
operator|%=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
name|comm
label|:
name|back_type
operator|=
name|othtab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Internal error: unknown operator"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e2_type
operator|==
operator|(
name|XTXRN
operator|>>
literal|1
operator|)
condition|)
name|exp1
operator|->
name|e_xname
operator|=
name|exp2
operator|->
name|e_xname
expr_stmt|;
name|exp1
operator|->
name|e_xtype
operator|=
name|back_type
operator||
operator|(
operator|(
name|exp1
operator|->
name|e_xtype
operator||
name|exp2
operator|->
name|e_xtype
operator|)
operator|&
operator|(
name|XFORW
operator||
name|XXTRN
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|back_type
operator|==
name|ERR
condition|)
name|yyerror
argument_list|(
literal|"Relocation error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp1
operator|)
return|;
block|}
end_block

begin_macro
name|buildtokensets
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|clobber
parameter_list|(
name|val
parameter_list|,
name|set
parameter_list|)
value|tokensets[(val)] |= (set)
name|clobber
argument_list|(
name|SEMI
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NL
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NAME
argument_list|,
name|YUKKYEXPRBEG
operator|+
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INSTn
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INST0
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REG
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|BFINT
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|BIGNUM
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|PLUS
argument_list|,
name|ADDOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MINUS
argument_list|,
name|ADDOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LP
argument_list|,
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|IOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|XOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|AND
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|ORNOT
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|TILDE
argument_list|,
name|MULOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|RSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MUL
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|DIV
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REGOP
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
comment|/* % */
block|}
end_block

begin_comment
comment|/*  *	We keep the current token class in this global variable, so   *	the recursive descent expression analyzers can talk amongst  *	themselves, and so that we may use the macros shift and shift over  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the value of the lexical value*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the next free expression slot*/
end_comment

begin_decl_stmt
specifier|static
name|inttoktype
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	return the value the read head is sitting on  */
end_comment

begin_function
name|inttoktype
name|exprparse
parameter_list|(
name|inval
parameter_list|,
name|backexpr
parameter_list|)
name|inttoktype
name|inval
decl_stmt|;
name|struct
name|exp
modifier|*
modifier|*
name|backexpr
decl_stmt|;
block|{
name|reg
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
name|val
operator|=
name|inval
expr_stmt|;
name|lexpr
operator|=
name|boolterm
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|ADDOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|boolterm
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|*
name|backexpr
operator|=
name|lexpr
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|boolterm
parameter_list|()
block|{
name|reg
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
name|lexpr
operator|=
name|term
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|BOOLOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|term
parameter_list|()
block|{
name|reg
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
name|lexpr
operator|=
name|factor
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|MULOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|factor
parameter_list|()
block|{
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
specifier|extern
name|int
name|droppedLP
decl_stmt|;
comment|/*called exprparse after consuming an LP*/
if|if
condition|(
name|val
operator|==
name|LP
operator|||
name|droppedLP
condition|)
block|{
if|if
condition|(
name|droppedLP
condition|)
name|droppedLP
operator|=
literal|0
expr_stmt|;
else|else
name|shift
expr_stmt|;
comment|/*the LP*/
name|val
operator|=
name|exprparse
argument_list|(
name|val
argument_list|,
operator|&
name|lexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|RP
condition|)
name|yyerror
argument_list|(
literal|"right parenthesis expected"
argument_list|)
expr_stmt|;
else|else
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
name|yukkyexpr
argument_list|(
name|val
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|==
name|TILDE
operator|)
operator|||
operator|(
name|val
operator|==
name|MINUS
operator|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyerror
argument_list|(
literal|"Bad expression syntax"
argument_list|)
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|yukkyexpr
parameter_list|(
name|val
parameter_list|,
name|np
parameter_list|)
name|int
name|val
decl_stmt|;
name|reg
name|int
name|np
decl_stmt|;
block|{
name|reg
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
specifier|extern
name|int
name|exprisname
decl_stmt|;
comment|/*last factor is a name*/
name|int
name|off
init|=
literal|0
decl_stmt|;
name|exprisname
operator|=
literal|0
expr_stmt|;
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|locxp
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|locxp
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|BFINT
case|:
name|yylval
operator|=
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|np
operator|)
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|yylval
operator|<
literal|0
condition|)
block|{
name|yylval
operator|=
operator|-
name|yylval
expr_stmt|;
name|yylval
operator|--
expr_stmt|;
name|off
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lgensym
index|[
name|yylval
index|]
operator|==
literal|1
condition|)
name|yyerror
argument_list|(
literal|"Reference to undefined local label %db"
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|--
expr_stmt|;
name|genref
index|[
name|yylval
index|]
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|yytext
argument_list|,
literal|"L%d\001%d"
argument_list|,
name|yylval
argument_list|,
name|lgensym
index|[
name|yylval
index|]
operator|+
name|off
argument_list|)
expr_stmt|;
name|yylval
operator|=
name|np
operator|=
operator|(
name|int
operator|)
operator|*
name|lookup
argument_list|(
name|passno
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lastnam
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|NAME
case|:
name|exprisname
operator|=
operator|(
name|int
operator|)
name|np
expr_stmt|;
name|locxp
operator|->
name|e_xtype
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_type
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
block|{
comment|/*forward*/
name|locxp
operator|->
name|e_xname
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
name|locxp
operator|->
name|e_xvalue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_type
operator||=
name|XFORW
expr_stmt|;
block|}
else|else
block|{
comment|/*otherwise, just get the value*/
name|locxp
operator|->
name|e_xvalue
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_value
expr_stmt|;
name|locxp
operator|->
name|e_xname
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Internal Error in yukkyexpr"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|INSTn
case|:
case|case
name|INST0
case|:
case|case
name|REG
case|:
name|locxp
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|e_xvalue
operator|=
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|locxp
operator|->
name|e_xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|e_xname
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|locxp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Print definitions for token kinds  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pdirect
index|[]
init|=
literal|"directive"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pinstr
index|[]
init|=
literal|"instruction"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|phunk
index|[]
init|=
literal|"lexeme"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|psmall
index|[]
init|=
literal|"small symbol"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pcntrl
index|[]
init|=
literal|"control token"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIRECT
value|pdirect
end_define

begin_define
define|#
directive|define
name|INSTR
value|pinstr
end_define

begin_define
define|#
directive|define
name|HUNK
value|phunk
end_define

begin_define
define|#
directive|define
name|SMALL
value|psmall
end_define

begin_define
define|#
directive|define
name|CNTRL
value|pcntrl
end_define

begin_struct
struct|struct
name|Tok_Desc
block|{
name|int
name|tok_which
decl_stmt|;
name|char
modifier|*
name|tok_kind
decl_stmt|;
name|char
modifier|*
name|tok_name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|Tok_Desc
modifier|*
name|tok_name
index|[
name|LASTTOKEN
operator|-
name|FIRSTTOKEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Tok_Desc
name|tok_desc
index|[]
init|=
block|{
name|FIRSTTOKEN
block|,
name|DIRECT
block|,
literal|"first token"
block|,
name|IBYTE
block|,
name|DIRECT
block|,
literal|".byte"
block|,
name|IWORD
block|,
name|DIRECT
block|,
literal|".word"
block|,
name|IINT
block|,
name|DIRECT
block|,
literal|".int"
block|,
name|ILONG
block|,
name|DIRECT
block|,
literal|".long"
block|,
name|IQUAD
block|,
name|DIRECT
block|,
literal|".quad"
block|,
name|IFFLOAT
block|,
name|DIRECT
block|,
literal|".ffloat"
block|,
name|IDFLOAT
block|,
name|DIRECT
block|,
literal|".dfloat"
block|,
name|IASCII
block|,
name|DIRECT
block|,
literal|".ascii"
block|,
name|IASCIZ
block|,
name|DIRECT
block|,
literal|".asciz"
block|,
name|IFILL
block|,
name|DIRECT
block|,
literal|".fill"
block|,
name|ISPACE
block|,
name|DIRECT
block|,
literal|".space"
block|,
name|IDATA
block|,
name|DIRECT
block|,
literal|".data"
block|,
name|ITEXT
block|,
name|DIRECT
block|,
literal|".text"
block|,
name|IGLOBAL
block|,
name|DIRECT
block|,
literal|".global"
block|,
name|IALIGN
block|,
name|DIRECT
block|,
literal|".align"
block|,
name|ISET
block|,
name|DIRECT
block|,
literal|".set"
block|,
name|ICOMM
block|,
name|DIRECT
block|,
literal|".comm"
block|,
name|ILCOMM
block|,
name|DIRECT
block|,
literal|".lcomm"
block|,
name|IORG
block|,
name|DIRECT
block|,
literal|".org"
block|,
name|ILSYM
block|,
name|DIRECT
block|,
literal|".lsym"
block|,
name|ISTAB
block|,
name|DIRECT
block|,
literal|".stab"
block|,
name|ISTABSTR
block|,
name|DIRECT
block|,
literal|".stabstr"
block|,
name|ISTABNONE
block|,
name|DIRECT
block|,
literal|".stabnone"
block|,
name|ISTABDOT
block|,
name|DIRECT
block|,
literal|".stabdot"
block|,
name|IFILE
block|,
name|DIRECT
block|,
literal|".file"
block|,
name|ILINENO
block|,
name|DIRECT
block|,
literal|".lineno"
block|,
name|IABORT
block|,
name|DIRECT
block|,
literal|".abort"
block|,
name|IJXXX
block|,
name|INSTR
block|,
literal|"jump pseudo"
block|,
name|INST0
block|,
name|INSTR
block|,
literal|"0 argument inst"
block|,
name|INSTn
block|,
name|INSTR
block|,
literal|"n argument inst"
block|,
name|PARSEEOF
block|,
name|CNTRL
block|,
literal|"parse end of file"
block|,
name|ILINESKIP
block|,
name|CNTRL
block|,
literal|"skip lines"
block|,
name|VOID
block|,
name|CNTRL
block|,
literal|"void"
block|,
name|SKIP
block|,
name|CNTRL
block|,
literal|"skip"
block|,
name|NL
block|,
name|CNTRL
block|,
literal|"new line"
block|,
name|SCANEOF
block|,
name|CNTRL
block|,
literal|"scanner end of file"
block|,
name|BADCHAR
block|,
name|CNTRL
block|,
literal|"bad character"
block|,
name|SH
block|,
name|CNTRL
block|,
literal|"comment, #"
block|,
name|INT
block|,
name|HUNK
block|,
literal|"int"
block|,
name|BFINT
block|,
name|HUNK
block|,
literal|"local label"
block|,
name|BIGNUM
block|,
name|HUNK
block|,
literal|"big number"
block|,
name|NAME
block|,
name|HUNK
block|,
literal|"name"
block|,
name|STRING
block|,
name|HUNK
block|,
literal|"string"
block|,
name|REG
block|,
name|HUNK
block|,
literal|"register specifier"
block|,
name|SIZESPEC
block|,
name|SMALL
block|,
literal|"size specifier, [BWLbwl]"
block|,
name|SIZEQUOTE
block|,
name|SMALL
block|,
literal|"sizequote, [^']"
block|,
name|LITOP
block|,
name|SMALL
block|,
literal|"litop"
block|,
name|MP
block|,
name|SMALL
block|,
literal|"minus parenthesis, -("
block|,
name|REGOP
block|,
name|SMALL
block|,
literal|"register operator, %"
block|,
name|SP
block|,
name|SMALL
block|,
literal|"space"
block|,
name|ALPH
block|,
name|SMALL
block|,
literal|"alphabetic character, [A-Za-z_]"
block|,
name|DIG
block|,
name|SMALL
block|,
literal|"digit character, [A-Fa-f0-9]"
block|,
name|SQ
block|,
name|SMALL
block|,
literal|"single quote, '"
block|,
name|DQ
block|,
name|SMALL
block|,
literal|"double quote, \""
block|,
name|LSH
block|,
name|SMALL
block|,
literal|"arithmetic left shift,<"
block|,
name|RSH
block|,
name|SMALL
block|,
literal|"arithmetic right shift,>"
block|,
name|XOR
block|,
name|SMALL
block|,
literal|"exclusive or, ^"
block|,
name|PLUS
block|,
name|SMALL
block|,
literal|"plus, +"
block|,
name|MINUS
block|,
name|SMALL
block|,
literal|"minus, -"
block|,
name|MUL
block|,
name|SMALL
block|,
literal|"multiply, *"
block|,
name|DIV
block|,
name|SMALL
block|,
literal|"divide, /"
block|,
name|SEMI
block|,
name|SMALL
block|,
literal|"semi colon, ;"
block|,
name|COLON
block|,
name|SMALL
block|,
literal|"colon, :"
block|,
name|IOR
block|,
name|SMALL
block|,
literal|"inclusive or, |"
block|,
name|AND
block|,
name|SMALL
block|,
literal|"and,&"
block|,
name|TILDE
block|,
name|SMALL
block|,
literal|"one's complement, ~"
block|,
name|ORNOT
block|,
name|SMALL
block|,
literal|"ornot, !"
block|,
name|CM
block|,
name|SMALL
block|,
literal|"comma"
block|,
name|LB
block|,
name|SMALL
block|,
literal|"left bracket, ["
block|,
name|RB
block|,
name|SMALL
block|,
literal|"right bracket, ]"
block|,
name|LP
block|,
name|SMALL
block|,
literal|"left parenthesis, ("
block|,
name|RP
block|,
name|SMALL
block|,
literal|"right parentheis, )"
block|,
name|LASTTOKEN
block|,
name|SMALL
block|,
literal|"last token"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	turn a token type into a string  */
end_comment

begin_function
name|char
modifier|*
name|tok_to_name
parameter_list|(
name|token
parameter_list|)
block|{
specifier|static
name|int
name|fixed
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
specifier|static
name|struct
name|Tok_Desc
name|NA
init|=
block|{
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"NOT ASSIGNED"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fixed
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRSTTOKEN
init|;
name|i
operator|<=
name|LASTTOKEN
condition|;
name|i
operator|++
control|)
name|tok_name
index|[
name|i
index|]
operator|=
operator|&
name|NA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|tok_desc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|Tok_Desc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tok_name
index|[
name|tok_desc
index|[
name|i
index|]
operator|.
name|tok_which
index|]
operator|=
operator|&
name|tok_desc
index|[
name|i
index|]
expr_stmt|;
block|}
name|fixed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FIRSTTOKEN
operator|<=
name|token
operator|&&
name|token
operator|<=
name|LASTTOKEN
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|tok_name
index|[
name|token
index|]
operator|->
name|tok_kind
argument_list|,
name|tok_name
index|[
name|token
index|]
operator|->
name|tok_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Unknown token number, %d\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_function

end_unit

