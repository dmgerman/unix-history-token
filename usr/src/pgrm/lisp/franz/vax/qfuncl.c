begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_expr_stmt
operator|.
name|asciz
literal|"$Header: qfuncl.c,v 1.10 84/02/29 16:44:30 sklower Exp $"
comment|/*					-[Mon Mar 21 17:04:58 1983 by jkf]-  * 	qfuncl.c				$Locker:  $  * lisp to C interface  *  * (c) copyright 1982, Regents of the University of California  */
comment|/*   * This is written in assembler but must be passed through the C preprocessor  * before being assembled.  */
include|#
directive|include
file|"ltypes.h"
include|#
directive|include
file|"config.h"
comment|/* important offsets within data types for atoms */
define|#
directive|define
name|Atomfnbnd
value|8
comment|/*  for arrays */
define|#
directive|define
name|Arrayaccfun
value|0
ifdef|#
directive|ifdef
name|PROF
operator|.
name|set
name|indx
operator|,
literal|0
define|#
directive|define
name|Profile
define|\
value|movab	prbuf+indx,r0 \ 	.set 	indx,indx+4 \ 	jsb 	mcount
define|#
directive|define
name|Profile2
define|\
value|movl   r0,r5 \ 	Profile	\ 	movl   r5,r0
else|#
directive|else
define|#
directive|define
name|Profile
define|#
directive|define
name|Profile2
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PORTABLE
define|#
directive|define
name|NIL
value|_nilatom
define|#
directive|define
name|NP
value|_np
define|#
directive|define
name|LBOT
value|_lbot
else|#
directive|else
define|#
directive|define
name|NIL
value|0
define|#
directive|define
name|NP
value|r6
define|#
directive|define
name|LBOT
value|r7
endif|#
directive|endif
comment|/*   transfer  table linkage routine  */
operator|.
name|globl
name|_qlinker
name|_qlinker
operator|:
operator|.
name|word
literal|0xfc0
operator|#
name|save
name|all
name|possible
name|registers
name|Profile
name|tstl
name|_exception
operator|#
name|any
name|pending
name|exceptions
name|jeql
name|noexc
name|tstl
name|_sigintcnt
operator|#
name|is
name|it
name|because
name|of
name|SIGINT
name|jeql
name|noexc
operator|#
end_expr_stmt

begin_if
if|if not
operator|,
name|just
name|leave
name|pushl
name|$2
operator|#
else|else
name|push
name|SIGINT
name|calls
name|$1
decl_stmt|,
name|_sigcall
name|noexc
range|:
name|movl
literal|16
operator|(
name|fp
operator|)
decl_stmt|,
name|r0
decl|#
name|get
decl|return
name|pc
name|addl2
decl|-4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|#
name|get
name|pointer
name|to
name|table
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r1
decl|#
name|get
name|atom
name|pointer
name|retry
range|:
operator|#
name|come
name|here
name|after
name|undef
name|func
name|error
name|movl
name|Atomfnbnd
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r2
decl|#
name|get
name|function
name|binding
name|jleq
name|nonex
decl|# if
name|none
decl_stmt|,
name|leave
name|tstl
name|_stattab
decl|+2
modifier|*
decl|4		#
name|see
decl|if
name|linking
name|possible
argument_list|(
name|Strans
argument_list|)
name|jeql
name|nolink
decl|#
name|no
decl_stmt|,
name|it
name|isn
decl|'t 	ashl	$-9,r2,r3		# check type of function 	cmpb	$/**/BCD,_typetable+1[r3]	 	jeql	linkin			# bcd, link it in! 	cmpb	$/**/ARRAY,_typetable+1[r3] # how about array? 	jeql	doarray			# yep   nolink: 	pushl	r1			# non, bcd, call interpreter 	calls	$1,_Ifuncal 	ret  /*  * handle arrays by pushing the array descriptor on the table and checking  * for a bcd array handler  */ doarray: 	ashl	$-9,Arrayaccfun(r2),r3	# get access function addr shifted 	cmpb	$/**/BCD,_typetable+1[r3]	# bcd?? 	jneq	nolink			# no, let funcal handle it #ifdef PORTABLE 	movl	NP,r4 	movl	r2,(r4)+		# store array header on stack 	movl	r4,NP #else 	movl	r2,(r6)+		# store array header on stack #endif 	movl	*(r2),r2		# get in func addr 	jmp	2(r2)			# jump in beyond calls header 	 	 linkin:	 	ashl	$-9,4(r2),r3		# check type of function discipline 	cmpb	$0,_typetable+1[r3]	# is it string? 	jeql	nolink			# yes, it is a c call, so dont link in 	movl	(r2),r2			# get function addr 	movl	r2,(r0)			# put fcn addr in table 	jmp	2(r2)			# enter fcn after mask  nonex:	pushl	r0			# preserve table address 	pushl	r1			# non existant fcn 	calls	$1,_Undeff		# call processor 	movl	r0,r1			# back in r1 	movl	(sp)+,r0		# restore table address 	jbr	retry			# for the retry.   	.globl	__erthrow		# errmessage for uncaught throws __erthrow:  	.asciz	"Uncaught throw from compiled code"  	.globl _tynames _tynames: 	.long	NIL				# nothing here 	.long	_lispsys+20*4			# str_name 	.long	_lispsys+21*4			# atom_name 	.long	_lispsys+19*4			# int_name 	.long	_lispsys+23*4			# dtpr_name 	.long	_lispsys+22*4			# doub_name 	.long	_lispsys+58*4			# funct_name 	.long	_lispsys+103*4			# port_name 	.long	_lispsys+47*4			# array_name 	.long	NIL				# nothing here 	.long	_lispsys+50*4			# sdot_name 	.long	_lispsys+53*4			# val_nam 	.long	NIL				# hunk2_nam 	.long	NIL				# hunk4_nam 	.long	NIL				# hunk8_nam 	.long	NIL				# hunk16_nam 	.long	NIL				# hunk32_nam 	.long	NIL				# hunk64_nam 	.long	NIL				# hunk128_nam 	.long	_lispsys+124*4			# vector_nam 	.long	_lispsys+125*4			# vectori_nam  /*	Quickly allocate small fixnums  */  	.globl	_qnewint _qnewint: 	Profile 	cmpl	r5,$1024 	jgeq	alloc 	cmpl	r5,$-1024 	jlss	alloc 	moval	_Fixzero[r5],r0 	rsb alloc: 	movl	_int_str,r0			# move next cell addr to r0 	jlss	callnewi			# if no space, allocate 	incl	*_lispsys+24*4			# inc count of ints 	movl	(r0),_int_str			# advance free list 	movl	r5,(r0)				# put baby to bed. 	rsb callnewi: 	pushl	r5 	calls	$0,_newint 	movl	(sp)+,(r0) 	rsb   /*  _qoneplus adds one to the boxed fixnum in r0  * and returns a boxed fixnum.  */  	.globl	_qoneplus _qoneplus: 	Profile2 	addl3	(r0),$1,r5 #ifdef PORTABLE 	movl	r6,NP 	movl	r6,LBOT #endif 	jmp	_qnewint  /* _qoneminus  subtracts one from the boxes fixnum in r0 and returns a  * boxed fixnum  */ 	.globl	_qoneminus _qoneminus: 	Profile2 	subl3	$1,(r0),r5 #ifdef PORTABLE 	movl	r6,NP 	movl	r6,LBOT #endif 	jmp	_qnewint  /*  *	_qnewdoub quick allocation of a initialized double (float) cell.  *	This entry point is required by the compiler for symmetry reasons.  *	Passed to _qnewdoub in r4,r5 is a double precision floating point  *	number.  This routine allocates a new cell, initializes it with  *	the given value and then returns the cell.  */  	.globl	_qnewdoub _qnewdoub: 	Profile 	movl	_doub_str,r0			# move next cell addr to r0 	jlss	callnewd			# if no space, allocate 	incl	*_lispsys+30*4			# inc count of doubs 	movl	(r0),_doub_str			# advance free list 	movq	r4,(r0)				# put baby to bed. 	rsb  callnewd: 	movq	r4,-(sp)			# stack initial value 	calls	$0,_newdoub 	movq	(sp)+,(r0)			# restore initial value 	rsb  	.globl	_qcons  /*  * quick cons call, the car and cdr are stacked on the namestack  * and this function is jsb'
name|ed
name|to
operator|.
modifier|*
decl|/
name|_qcons
range|:
name|Profile
name|movl
name|_dtpr_str
decl_stmt|,
name|r0
decl|#
name|move
name|next
name|cell
name|addr
name|to
name|r0
name|jlss
name|getnew
decl|# if
name|ran
name|out
name|of
name|space
name|jump
name|incl
modifier|*
name|_lispsys
decl|+28
modifier|*
decl|4			#
name|inc
name|count
name|of
name|dtprs
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|_dtpr_str
decl|#
name|advance
name|free
name|list
name|storit
range|:
name|movl
operator|-
operator|(
name|r6
operator|)
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|store
name|in
name|cdr
name|movl
decl|-
argument_list|(
name|r6
argument_list|)
decl_stmt|,4
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|store
name|in
name|car
name|rsb
name|getnew
range|:
ifdef|#
directive|ifdef
name|PORTABLE
name|movl
name|r6
decl_stmt|,
name|NP
name|movab
decl|-8
argument_list|(
name|r6
argument_list|)
decl_stmt|,
name|LBOT
endif|#
directive|endif
name|calls
name|$0
decl_stmt|,
name|_newdot
decl|#
name|must
name|gc
name|to
name|get
name|one
name|jbr
name|storit
decl|#
name|now
name|initialize
name|it
operator|.
comment|/*  * Fast equivalent of newdot, entered by jsb  */
decl|.
name|globl
name|_qnewdot
name|_qnewdot
range|:
name|Profile
name|movl
name|_dtpr_str
decl_stmt|,
name|r0
decl|#
name|mov
name|next
name|cell
name|addr
name|t0
name|r0
name|jlss
name|mustallo
decl|# if
name|ran
name|out
name|of
name|space
name|incl
modifier|*
name|_lispsys
decl|+28
modifier|*
decl|4			#
name|inc
name|count
name|of
name|dtprs
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|_dtpr_str
decl|#
name|advance
name|free
name|list
name|clrq
argument_list|(
name|r0
argument_list|)
name|rsb
name|mustallo
range|:
name|calls
name|$0
decl_stmt|,
name|_newdot
name|rsb
comment|/*  prunel  - return a list of dtpr cells to the free list  * this is called by the pruneb after it has discarded the top bignum   * the dtpr cells are linked through their cars not their cdrs.  * this returns with an rsb  *  * method of operation: the dtpr list we get is linked by car's so we  * go through the list and link it by cdr's, then have the last dtpr  * point to the free list and then make the free list begin at the  * first dtpr.  */
name|qprunel
range|:
name|movl
name|r0
decl_stmt|,
name|r2
decl|#
name|remember
name|first
name|dtpr
name|location
name|rep
range|:
name|decl
operator|*
name|_lispsys
operator|+
literal|28
operator|*
literal|4
operator|#
name|decrement
name|used
name|dtpr
name|count
name|movl
literal|4
operator|(
name|r0
operator|)
decl_stmt|,
name|r1
decl|#
name|put
name|link
name|value
name|into
name|r1
name|jeql
name|endoflist
decl|# if
name|nil
decl_stmt|,
name|then
name|end
name|of
name|list
name|movl
name|r1
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|repl
name|cdr
name|w
decl|/
name|save
name|val
name|as
name|car
name|movl
name|r1
decl_stmt|,
name|r0
decl|#
name|advance
name|to
name|next
name|dtpr
name|jbr
name|rep
decl|#
name|and
name|loop
name|around
name|endoflist
range|:
name|movl
name|_dtpr_str
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|make
name|last
decl|1
name|pnt
name|to
name|free
name|list
name|movl
name|r2
decl_stmt|,
name|_dtpr_str
decl|#
modifier|&
name|free
name|list
name|begin
name|at
decl|1st 1
name|rsb
comment|/*  * qpruneb - called by the arithmetic routines to free an sdot and the dtprs  * which hang on it.  * called by  *	pushl	sdotaddr  *	jsb	_qpruneb  */
operator|.
name|globl
name|_qpruneb
name|_qpruneb
range|:
name|Profile
name|movl
literal|4
operator|(
name|sp
operator|)
decl_stmt|,
name|r0
decl|#
name|get
name|address
name|decl
modifier|*
name|_lispsys
decl|+48
modifier|*
decl|4		#
name|decr
name|count
name|of
name|used
name|sdots
name|movl
name|_sdot_str
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|have
name|new
name|sdot
name|point
name|to
name|free
name|list
name|movl
name|r0
decl_stmt|,
name|_sdot_str
decl|#
name|start
name|free
name|list
name|at
name|new
name|sdot
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|#
name|get
name|address
name|of
name|first
name|dtpr
name|jneq
name|qprunel
decl|# if
name|exists
decl_stmt|,
name|prune
name|it
name|rsb
decl|# else return.
comment|/*  * _qprunei 	   *	called by the arithmetic routines to free a fixnum cell  * calling sequence  *	pushl	fixnumaddr  *	jsb	_qprunei  */
decl|.
name|globl
name|_qprunei
name|_qprunei
range|:
name|Profile
name|movl
literal|4
operator|(
name|sp
operator|)
decl_stmt|,
name|r0
decl|#
name|get
name|address
name|of
name|fixnum
name|cmpl
name|r0
decl_stmt|,
name|$_Lastfix
decl|#
name|is
name|it
name|a
name|small
name|fixnum
name|jleq
name|skipit
decl|# if
name|so
decl_stmt|,
name|leave
name|decl
modifier|*
name|_lispsys
decl|+24
modifier|*
decl|4		#
name|decr
name|count
name|of
name|used
name|ints
name|movl
name|_int_str
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|link
name|the
name|fixnum
name|into
name|the
name|free
name|list
name|movl
name|r0
decl_stmt|,
name|_int_str
name|skipit
range|:
name|rsb
operator|.
name|globl
name|_qpopnames
name|_qpopnames
operator|:
operator|#
name|equivalent
name|of
name|C
operator|-
name|code
name|popnames
decl_stmt|,
name|entered
name|by
name|jsb
operator|.
name|movl
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,
name|r0
decl|# return
name|address
name|movl
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,
name|r1
decl|#
name|Lower
name|limit
name|movl
name|_bnp
decl_stmt|,
name|r2
decl|#
name|pointer
name|to
name|bind
name|stack
name|entry
name|qploop
range|:
name|subl2
name|$8
decl_stmt|,
name|r2
decl|# for
argument_list|(;
end_if

begin_expr_stmt
operator|(
operator|--
name|r2
operator|)
operator|>
name|r1
expr_stmt|;
end_expr_stmt

begin_block
unit|)
block|{
name|cmpl
name|r2
decl_stmt|,
name|r1
decl|#
name|test
decl|for
name|done
name|jlss
name|qpdone
name|movl
argument_list|(
name|r2
argument_list|)
decl_stmt|,
modifier|*
decl_stmt|4
argument_list|(
name|r2
argument_list|)
decl_stmt|#
name|r2
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
init|=
name|r2
operator|->
name|val
decl_stmt|;
name|brb
name|qploop
operator|#
block|}
end_block

begin_label
name|qpdone
label|:
end_label

begin_decl_stmt
name|movl
name|r1
decl_stmt|,
name|_bnp
decl|#
name|restore
name|bnp
name|jmp
argument_list|(
name|r0
argument_list|)
decl|# return
comment|/*  * _qget : fast get subroutine  *  (get 'atom 'ind)  * called with -8(r6) equal to the atom  *	      -4(r6) equal to the indicator  * no assumption is made about LBOT  * unfortunately, the atom may not in fact be an atom, it may  * be a list or nil, which are special cases.  * For nil, we grab the nil property list (stored in a special place)  * and for lists we punt and call the C routine since it is  most likely  * and error and we havent put in error checks yet.  */
decl|.
name|globl
name|_qget
name|_qget
range|:
name|Profile
name|movl
operator|-
literal|4
operator|(
name|r6
operator|)
decl_stmt|,
name|r1
decl|#
name|put
name|indicator
name|in
name|r1
name|movl
decl|-8
argument_list|(
name|r6
argument_list|)
decl_stmt|,
name|r0
decl|#
name|and
name|atom
name|into
name|r0
name|jeql
name|nilpli
decl|#
name|jump
decl|if
name|atom
name|is
name|nil
name|ashl
name|$
decl|-9
decl_stmt|,
name|r0
decl_stmt|,
name|r2
decl|#
name|check
name|type
name|cmpb
name|_typetable
decl|+1[
name|r2
decl|]
decl_stmt|,
name|$1
decl|#
name|is
name|it
name|a
name|symbol
decl|??
name|jneq
name|notsymb
decl|#
name|nope
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|#
name|yes
decl_stmt|,
name|put
name|prop
name|list
name|in
name|r1
name|to
name|begin
name|scan
name|jeql
name|fail
decl|# if
name|no
name|prop
name|list
decl_stmt|,
name|we
name|lose
name|right
name|away
name|lp
range|:
name|cmpl
name|r1
decl_stmt|,4
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|is
name|car
name|of
name|list
name|eq
name|to
name|indicator
decl|?
name|jeql
name|good
decl|#
name|jump
decl|if
name|so
name|movl
modifier|*
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|# else
name|cddr
name|down
name|list
name|jneq
name|lp
decl|#
name|and
name|jump
decl|if
name|more
name|list
name|to
name|go
operator|.
name|fail
range|:
name|subl2
name|$8
decl_stmt|,
name|NP
decl|#
name|unstack
name|args
name|rsb
decl|# return
name|with
name|r0
name|eq
name|to
name|nil
name|good
range|:
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|# return
name|cadr
name|of
name|list
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
name|subl2
name|$8
decl_stmt|,
name|NP
decl|#
name|unstack
name|args
name|rsb
name|nilpli
range|:
name|movl
name|_lispsys
operator|+
literal|64
operator|*
literal|4
decl_stmt|,
name|r0
decl|#
name|want
name|nil
name|prop
name|list
decl_stmt|,
name|get
name|it
name|specially
name|jneq
name|lp
decl|#
name|and
name|process
decl|if
name|anything
name|there
name|subl2
name|$8
decl_stmt|,
name|NP
decl|#
name|unstack
name|args
name|rsb
decl|# else
name|fail
name|notsymb
range|:
ifdef|#
directive|ifdef
name|PORTABLE
name|movl
name|r6
decl_stmt|,
name|NP
name|movab
decl|-8
argument_list|(
name|r6
argument_list|)
decl_stmt|,
name|LBOT
decl|#
name|must
name|set
name|up
name|LBOT
name|before
name|calling
else|#
directive|else
name|movab
decl|-8
argument_list|(
name|r6
argument_list|)
decl_stmt|,
name|LBOT
decl|#
name|must
name|set
name|up
name|LBOT
name|before
name|calling
endif|#
directive|endif
name|calls
name|$0
decl_stmt|,
name|_Lget
decl|#
name|not
name|a
name|symbol
decl_stmt|,
name|call
name|C
name|routine
name|to
name|error
name|check
name|subl2
name|$8
decl_stmt|,
name|NP
decl|#
name|unstack
name|args
name|rsb
decl|#
name|and
decl|return
name|what
name|it
name|returned
operator|.
comment|/*  * _qexarith 	exact arithmetic  * calculates x=a*b+c  where a,b and c are 32 bit 2's complement integers  * whose top two bits must be the same (i.e. the are members of the set  * of valid fixnum values for Franz Lisp).  The result, x, will be 64 bits  * long but since each of a, b and c had only 31 bits of precision, the  * result x only has 62 bits of precision.  The lower 30 bits are returned  * in *plo and the high 32 bits are returned in *phi.  If *phi is 0 or -1 then  * x doesn't need any more than 31 bits plus sign to describe, so we  * place the sign in the high two bits of *plo and return 0 from this  * routine.  A non zero return indicates that x requires more than 31 bits  * to describe.  */
decl|.
name|globl
name|_qexarith
comment|/* qexarith(a,b,c,phi,plo)  * int *phi, *plo;  */
name|_qexarith
range|:
name|emul
literal|4
operator|(
name|sp
operator|)
decl_stmt|,8
argument_list|(
name|sp
argument_list|)
decl_stmt|,12
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|r2
decl|#
name|r2
init|=
name|a
operator|*
name|b
operator|+
name|c
name|to
literal|64
name|bits
name|extzv
name|$0
decl_stmt|,
name|$30
decl_stmt|,
name|r2
decl_stmt|,
modifier|*
decl_stmt|20
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|get
name|new
name|lo
name|extv
name|$30
decl_stmt|,
name|$32
decl_stmt|,
name|r2
decl_stmt|,
name|r0
decl|#
name|get
name|new
name|carry
name|beql
name|out
decl|#
name|hi
init|=
literal|0
decl_stmt|,
name|no
name|work
name|necessary
name|movl
name|r0
decl_stmt|,
modifier|*
decl_stmt|16
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|save
name|hi
name|mcoml
name|r0
decl_stmt|,
name|r0
decl|#
name|Is
name|hi
init|=
operator|-
literal|1
operator|(
name|it
literal|'ll fit in one word) 	bneq	out			# it doesn'
name|t
name|bisl2
name|$0xc0000000
expr|,
operator|*
literal|20
operator|(
name|sp
operator|)
operator|#
name|alter
name|low
name|so
name|that
name|it
name|is
name|ok
operator|.
name|out
operator|:
name|rsb
comment|/*  * pushframe : stack a frame   * When this is called, the optional arguments and class have already been  * pushed on the stack as well as the return address (by virtue of the jsb)  * , we push on the rest of the stuff (see h/frame.h)  * for a picture of the save frame  */
operator|.
name|globl
name|_qpushframe
name|_qpushframe
operator|:
name|Profile
name|movl
name|_errp
expr|,
operator|-
operator|(
name|sp
operator|)
name|movl
name|_bnp
expr|,
operator|-
operator|(
name|sp
operator|)
name|movl
name|NP
expr|,
operator|-
operator|(
name|sp
operator|)
name|movl
name|LBOT
expr|,
operator|-
operator|(
name|sp
operator|)
name|pushr
name|$0x3f00
operator|#
name|save
name|r13
argument_list|(
name|fp
argument_list|)
expr|,
name|r12
argument_list|(
name|ap
argument_list|)
expr|,
name|r11
expr|,
name|r10
expr|,
name|r9
expr|,
name|r8
name|movab
literal|6
operator|*
literal|4
operator|(
name|sp
operator|)
expr|,
name|r0
operator|#
return|return
name|addr
name|of
name|lbot
name|on
name|stack
name|clrl
name|_retval
operator|#
name|set
name|retval
name|to
name|C_INITIAL
ifndef|#
directive|ifndef
name|SPISFP
name|jmp
operator|*
literal|40
operator|(
name|sp
operator|)
operator|#
end_decl_stmt

begin_return
return|return
name|through
end_return

begin_return
return|return
name|address
else|#
directive|else
name|movab
operator|-
literal|4
operator|(
name|sp
operator|)
operator|,
name|sp
name|movl
name|sp
operator|,
operator|(
name|sp
operator|)
name|movl
name|_xsp
operator|,
operator|-
operator|(
name|sp
operator|)
name|jmp
operator|*
literal|48
operator|(
name|sp
operator|)
endif|#
directive|endif
comment|/*  * Ipushf : stack a frame, where space is preallocated on the stack.   * this is like pushframe, except that it doesn't alter the stack pointer  * and will save more registers.  * This might be written a little more quickly by having a bigger register  * save mask, but this is only supposed to be an example for the  * IBM and RIDGE people.  */
ifdef|#
directive|ifdef
name|SPISFP
operator|.
name|globl
name|_Ipushf
name|_Ipushf
operator|:
operator|.
name|word
literal|0
name|addl3
name|$96
operator|,
literal|16
operator|(
name|ap
operator|)
operator|,
name|r1
name|movl
literal|12
operator|(
name|ap
operator|)
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
literal|8
operator|(
name|ap
operator|)
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
literal|16
operator|(
name|fp
operator|)
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
name|_errp
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
name|_bnp
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
name|NP
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
name|LBOT
operator|,
operator|-
operator|(
name|r1
operator|)
name|movl
name|r1
operator|,
name|r0
name|movq
literal|8
operator|(
name|fp
operator|)
operator|,
operator|-
operator|(
name|r1
operator|)
comment|/* save stuff in the same order unix saves them 			 (r13,r12,r11,r10,r9,r8) and then add extra 			 for vms (sp,r7,r6,r5,r4,r3,r2) */
name|movq
name|r10
operator|,
operator|-
operator|(
name|r1
operator|)
name|movq
name|r8
operator|,
operator|-
operator|(
name|r1
operator|)
name|movab
literal|20
operator|(
name|ap
operator|)
operator|,
operator|-
operator|(
name|r1
operator|)
comment|/* assumes Ipushf allways called by calls, with 				the stack alligned */
name|movl
name|_xsp
operator|,
operator|-
operator|(
name|r1
operator|)
name|movq
name|r6
operator|,
operator|-
operator|(
name|r1
operator|)
name|movq
name|r4
operator|,
operator|-
operator|(
name|r1
operator|)
name|movq
name|r2
operator|,
operator|-
operator|(
name|r1
operator|)
name|clrl
name|_retval
name|ret
endif|#
directive|endif
comment|/*  * qretfromfr  * called with frame to ret to in r11.  The popnames has already been done.  * we must restore all registers, and jump to the ret addr. the popping  * must be done without reducing the stack pointer since an interrupt  * could come in at any time and this frame must remain on the stack.  * thus we can't use popr.  */
operator|.
name|globl
name|_qretfromfr
name|_qretfromfr
operator|:
name|Profile
name|movl
name|r11
operator|,
name|r0
operator|#
end_return

begin_return
return|return
name|error
name|frame
name|location
name|subl3
name|$24
operator|,
name|r11
operator|,
name|sp
operator|#
name|set
name|up
name|sp
name|at
name|bottom
name|of
name|frame
name|movl
name|sp
operator|,
name|r1
operator|#
name|prepare
name|to
name|pop
name|off
name|movq
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r8
operator|#
name|r8
operator|,
name|r9
name|movq
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r10
operator|#
name|r10
operator|,
name|r11
name|movq
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r12
operator|#
name|r12
operator|,
name|r13
name|movl
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|LBOT
operator|#
name|LBOT
argument_list|(
argument|lbot
argument_list|)
name|movl
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|NP
operator|#
name|NP
argument_list|(
argument|np
argument_list|)
name|jmp
operator|*
literal|40
operator|(
name|sp
operator|)
operator|#
name|jump
name|out
name|of
name|frame
ifdef|#
directive|ifdef
name|SPISFP
comment|/*  * this is equivalent to qretfro for a native VMS system  *  */
operator|.
name|globl
name|_Iretfrm
name|_Iretfrm
operator|:
operator|.
name|word
literal|0
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
name|r0
operator|#
end_return

begin_return
return|return
name|error
name|frame
name|location
name|movl
name|r0
operator|,
name|r1
name|movq
operator|-
operator|(
name|r1
operator|)
operator|,
name|ap
name|movq
operator|-
operator|(
name|r1
operator|)
operator|,
name|r10
name|movq
operator|-
operator|(
name|r1
operator|)
operator|,
name|r8
name|movl
operator|-
operator|(
name|r1
operator|)
operator|,
name|sp
name|movl
operator|-
operator|(
name|r1
operator|)
operator|,
name|_xsp
name|movq
operator|-
operator|(
name|r1
operator|)
operator|,
name|r6
name|movq
operator|-
operator|(
name|r1
operator|)
operator|,
name|r4
name|movq
operator|-
operator|(
name|r1
operator|)
operator|,
name|r2
name|movl
name|r0
operator|,
name|r1
name|movl
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|LBOT
name|movl
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|NP
name|jmp
operator|*
literal|16
operator|(
name|r0
operator|)
endif|#
directive|endif
comment|/*  * this routine finishes setting things up for dothunk  * it is code shared to keep the size of c-callable thunks  * for lisp functions, small.  */
operator|.
name|globl
name|_thcpy
name|_thcpy
operator|:
name|movl
argument_list|(
name|sp
argument_list|)
operator|,
name|r0
name|pushl
name|ap
name|pushl
argument_list|(
name|r0
argument_list|)
operator|+
name|pushl
argument_list|(
name|r0
argument_list|)
operator|+
name|calls
name|$4
operator|,
name|_dothunk
name|ret
comment|/*  * This routine gets the name of the inital entry point  * It is here so it can be under ifdef control.  */
operator|.
name|globl
name|_gstart
name|_gstart
operator|:
operator|.
name|word
literal|0
if|#
directive|if
name|os_vms
name|moval
name|_$$$start
operator|,
name|r0
else|#
directive|else
name|moval
name|start
operator|,
name|r0
endif|#
directive|endif
name|ret
operator|.
name|globl
name|_proflush
name|_proflush
operator|:
operator|.
name|word
literal|0
name|ret
comment|/*  * The definition of mcount must be present even when the C code  * isn't being profiled, since lisp code may reference it.  */
ifndef|#
directive|ifndef
name|os_vms
operator|.
name|globl
name|mcount
name|mcount
operator|:
endif|#
directive|endif
operator|.
name|globl
name|_mcount
name|_mcount
operator|:
ifdef|#
directive|ifdef
name|PROF
name|movl
argument_list|(
name|r0
argument_list|)
operator|,
name|r1
name|bneq
name|incr
name|movl
name|_countbase
operator|,
name|r1
name|beql
end_return

begin_return
return|return
name|addl2
name|$8
operator|,
name|_countbase
name|movl
argument_list|(
name|sp
argument_list|)
operator|,
operator|(
name|r1
operator|)
operator|+
name|movl
name|r1
operator|,
operator|(
name|r0
operator|)
name|incr
operator|:
name|incl
argument_list|(
argument|r1
argument_list|)
end_return

begin_return
return|return
operator|:
endif|#
directive|endif
name|rsb
comment|/* This must be at the end of the file.  If we are profiling, allocate  * space for the profile buffer  */
ifdef|#
directive|ifdef
name|PROF
operator|.
name|data
operator|.
name|comm
name|_countbase
operator|,
literal|4
operator|.
name|lcomm
name|prbuf
operator|,
name|indx
operator|+
literal|4
operator|.
name|text
end_return

begin_endif
endif|#
directive|endif
end_endif

end_unit

