begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: sysat.c,v 1.20 85/03/13 17:19:21 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Thu Sep 29 14:05:32 1983 by jkf]-  * 	sysat.c				$Locker:  $  * startup data structure creation  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"lfuncs.h"
end_include

begin_define
define|#
directive|define
name|FIDDLE
parameter_list|(
name|z
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|y
parameter_list|)
value|z->a.clb=newdot(); (z->a.clb->d.car=newint())->i=b->i; \ 	z->a.clb->d.cdr=newdot(); (z->a.clb->d.cdr->d.car=newint())->i=c->i; \ 	z->a.clb->d.cdr->d.cdr=newdot(); (z->a.clb->d.cdr->d.cdr->d.car=newint())->i=y; \ 	b = z->a.clb->d.car; c = z->a.clb->d.cdr->d.car; \ 	copval(z,z->a.clb); z->a.clb = nil;
end_define

begin_define
define|#
directive|define
name|cforget
parameter_list|(
name|x
parameter_list|)
value|protect(x); Lforget(); unprot();
end_define

begin_comment
comment|/*  The following array serves as the temporary counters of the items	*/
end_comment

begin_comment
comment|/*  and pages used in each space.					*/
end_comment

begin_decl_stmt
name|long
name|int
name|tint
index|[
literal|2
operator|*
name|NUMSPACES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tgcthresh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  starts off TRUE to indicate unsafe to gc  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|beginsweep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for garbage collector to begin sweeping */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|page_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* begin warning messages about running out of space */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|purepage
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which pages should not be swept by gc */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ttsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need to know how much of pagetable to set to other */
end_comment

begin_decl_stmt
specifier|extern
name|lispval
name|Iaddstat
argument_list|()
decl_stmt|,
name|Isstatus
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|lispval
name|inewatom
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|makevals
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|lispval
name|temp
decl_stmt|;
comment|/*  system list structure and atoms are initialized.  */
comment|/*  Before any lisp data can be created, the space usage */
comment|/*  counters must be set up, temporarily in array tint.  */
name|atom_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|0
index|]
expr_stmt|;
name|atom_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|1
index|]
expr_stmt|;
name|str_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|2
index|]
expr_stmt|;
name|str_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|3
index|]
expr_stmt|;
name|int_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|4
index|]
expr_stmt|;
name|int_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|5
index|]
expr_stmt|;
name|dtpr_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|6
index|]
expr_stmt|;
name|dtpr_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|7
index|]
expr_stmt|;
name|doub_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|8
index|]
expr_stmt|;
name|doub_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|9
index|]
expr_stmt|;
name|sdot_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|10
index|]
expr_stmt|;
name|sdot_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|11
index|]
expr_stmt|;
name|array_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|12
index|]
expr_stmt|;
name|array_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|13
index|]
expr_stmt|;
name|val_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|14
index|]
expr_stmt|;
name|val_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|15
index|]
expr_stmt|;
name|funct_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|16
index|]
expr_stmt|;
name|funct_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|17
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|hunk_pages
index|[
name|i
index|]
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|18
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|hunk_items
index|[
name|i
index|]
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|19
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
name|vect_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|34
index|]
expr_stmt|;
name|vecti_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|35
index|]
expr_stmt|;
name|vect_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|36
index|]
expr_stmt|;
name|vecti_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|37
index|]
expr_stmt|;
name|other_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|38
index|]
expr_stmt|;
name|other_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|39
index|]
expr_stmt|;
comment|/*  This also applies to the garbage collection threshhold  */
name|gcthresh
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tgcthresh
expr_stmt|;
comment|/*  Now we commence constructing system lisp structures.  */
comment|/*  nil is a special case, constructed especially at location zero  */
name|hasht
index|[
name|hashfcn
argument_list|(
literal|"nil"
argument_list|)
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|nil
expr_stmt|;
comment|/* allocate space for namestack and bindstack first 	 * then set up beginsweep variable so that the sweeper will 	 * ignore these `always in use' pages 	 */
name|lbot
operator|=
name|orgnp
operator|=
name|np
operator|=
operator|(
operator|(
expr|struct
name|argent
operator|*
operator|)
name|csegment
argument_list|(
name|VALUE
argument_list|,
name|NAMESIZE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
name|orgbnp
operator|=
name|bnp
operator|=
operator|(
operator|(
expr|struct
name|nament
operator|*
operator|)
name|csegment
argument_list|(
name|DTPR
argument_list|,
name|NAMESIZE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
comment|/* since these dtpr pages will not be swept, we don't want them 	 * to show up in count of dtpr pages allocated or it will confuse 	 * gcafter when it tries to determine how much space is free 	 */
name|dtpr_pages
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|beginsweep
operator|=
operator|(
name|int
operator|*
operator|)
name|xsbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  patching up info in type and pure tables 	 */
if|#
directive|if
name|unisys3botch
comment|/* 	 * This code is in here because Schriebman made Romberger tend 	 * more important things for too long for Apple and Fateman to 	 * wait 	 */
block|{
specifier|extern
name|int
name|dmpmode
decl_stmt|;
name|int
name|jj
init|=
name|ATOX
argument_list|(
name|beginsweep
argument_list|)
decl_stmt|;
name|dmpmode
operator|=
literal|407
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|19
init|;
name|i
operator|<
name|jj
condition|;
name|i
operator|++
control|)
name|typetable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|ATOX
argument_list|(
name|beginsweep
argument_list|)
init|;
name|i
operator|<
name|ttsize
condition|;
name|i
operator|++
control|)
operator|(
name|typetable
operator|+
literal|1
operator|)
index|[
name|i
index|]
operator|=
name|OTHER
expr_stmt|;
name|purepage
index|[
name|ATOX
argument_list|(
name|np
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Mark these as non-gc'd arrays */
name|purepage
index|[
name|ATOX
argument_list|(
name|bnp
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Names of various spaces and things 	 */
name|atom_name
operator|=
name|inewatom
argument_list|(
literal|"symbol"
argument_list|)
expr_stmt|;
name|str_name
operator|=
name|inewatom
argument_list|(
literal|"string"
argument_list|)
expr_stmt|;
name|int_name
operator|=
name|inewatom
argument_list|(
literal|"fixnum"
argument_list|)
expr_stmt|;
name|dtpr_name
operator|=
name|inewatom
argument_list|(
literal|"list"
argument_list|)
expr_stmt|;
name|doub_name
operator|=
name|inewatom
argument_list|(
literal|"flonum"
argument_list|)
expr_stmt|;
name|sdot_name
operator|=
name|inewatom
argument_list|(
literal|"bignum"
argument_list|)
expr_stmt|;
name|array_name
operator|=
name|inewatom
argument_list|(
literal|"array"
argument_list|)
expr_stmt|;
name|val_name
operator|=
name|inewatom
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|funct_name
operator|=
name|inewatom
argument_list|(
literal|"binary"
argument_list|)
expr_stmt|;
name|port_name
operator|=
name|inewatom
argument_list|(
literal|"port"
argument_list|)
expr_stmt|;
comment|/* not really a space */
name|vect_name
operator|=
name|inewatom
argument_list|(
literal|"vector"
argument_list|)
expr_stmt|;
name|vecti_name
operator|=
name|inewatom
argument_list|(
literal|"vectori"
argument_list|)
expr_stmt|;
name|other_name
operator|=
name|inewatom
argument_list|(
literal|"other"
argument_list|)
expr_stmt|;
block|{
name|char
name|name
index|[
literal|6
index|]
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"hunk0"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|hunk_name
index|[
name|i
index|]
operator|=
name|matom
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
index|[
literal|4
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/*  set up the name stack as an array of pointers */
name|nplim
operator|=
name|orgnp
operator|+
name|NAMESIZE
operator|-
literal|6
operator|*
name|NAMINC
expr_stmt|;
name|temp
operator|=
name|inewatom
argument_list|(
literal|"namestack"
argument_list|)
expr_stmt|;
name|nstack
operator|=
name|temp
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newarray
argument_list|()
expr_stmt|;
name|nstack
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|np
operator|)
expr_stmt|;
operator|(
name|nstack
operator|->
name|ar
operator|.
name|length
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|NAMESIZE
expr_stmt|;
operator|(
name|nstack
operator|->
name|ar
operator|.
name|delta
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|argent
argument_list|)
expr_stmt|;
name|Vnogbar
operator|=
name|inewatom
argument_list|(
literal|"unmarked_array"
argument_list|)
expr_stmt|;
comment|/* marking of the namestack will be done explicitly in gc1 */
operator|(
name|nstack
operator|->
name|ar
operator|.
name|aux
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|Vnogbar
expr_stmt|;
comment|/* set up the binding stack as an array of dotted pairs */
name|bnplim
operator|=
name|orgbnp
operator|+
name|NAMESIZE
operator|-
literal|5
expr_stmt|;
name|temp
operator|=
name|inewatom
argument_list|(
literal|"bindstack"
argument_list|)
expr_stmt|;
name|bstack
operator|=
name|temp
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newarray
argument_list|()
expr_stmt|;
name|bstack
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|bnp
operator|)
expr_stmt|;
operator|(
name|bstack
operator|->
name|ar
operator|.
name|length
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|NAMESIZE
expr_stmt|;
operator|(
name|bstack
operator|->
name|ar
operator|.
name|delta
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nament
argument_list|)
expr_stmt|;
comment|/* marking of the bindstack will be done explicitly in gc1 */
operator|(
name|bstack
operator|->
name|ar
operator|.
name|aux
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|Vnogbar
expr_stmt|;
comment|/* more atoms */
name|tatom
operator|=
name|inewatom
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
name|tatom
operator|->
name|a
operator|.
name|clb
operator|=
name|tatom
expr_stmt|;
name|lambda
operator|=
name|inewatom
argument_list|(
literal|"lambda"
argument_list|)
expr_stmt|;
name|nlambda
operator|=
name|inewatom
argument_list|(
literal|"nlambda"
argument_list|)
expr_stmt|;
name|cara
operator|=
name|inewatom
argument_list|(
literal|"car"
argument_list|)
expr_stmt|;
name|cdra
operator|=
name|inewatom
argument_list|(
literal|"cdr"
argument_list|)
expr_stmt|;
name|Veval
operator|=
name|inewatom
argument_list|(
literal|"eval"
argument_list|)
expr_stmt|;
name|quota
operator|=
name|inewatom
argument_list|(
literal|"quote"
argument_list|)
expr_stmt|;
name|reseta
operator|=
name|inewatom
argument_list|(
literal|"reset"
argument_list|)
expr_stmt|;
name|gcafter
operator|=
name|inewatom
argument_list|(
literal|"gcafter"
argument_list|)
expr_stmt|;
comment|/* garbage collection wind-up */
name|macro
operator|=
name|inewatom
argument_list|(
literal|"macro"
argument_list|)
expr_stmt|;
name|ibase
operator|=
name|inewatom
argument_list|(
literal|"ibase"
argument_list|)
expr_stmt|;
comment|/* base for input conversion */
name|ibase
operator|->
name|a
operator|.
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|(
name|inewatom
argument_list|(
literal|"base"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|ibase
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|fclosure
operator|=
name|inewatom
argument_list|(
literal|"fclosure"
argument_list|)
expr_stmt|;
name|clos_marker
operator|=
name|inewatom
argument_list|(
literal|"int:closure-marker"
argument_list|)
expr_stmt|;
name|Vpbv
operator|=
name|inewatom
argument_list|(
literal|"value-structure-argument"
argument_list|)
expr_stmt|;
name|rsetatom
operator|=
name|inewatom
argument_list|(
literal|"*rset"
argument_list|)
expr_stmt|;
name|rsetatom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|Vsubrou
operator|=
name|inewatom
argument_list|(
literal|"subroutine"
argument_list|)
expr_stmt|;
name|Vpiport
operator|=
name|inewatom
argument_list|(
literal|"piport"
argument_list|)
expr_stmt|;
name|Vpiport
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|piport
operator|=
name|stdin
argument_list|)
expr_stmt|;
comment|/* standard input */
name|Vpoport
operator|=
name|inewatom
argument_list|(
literal|"poport"
argument_list|)
expr_stmt|;
name|Vpoport
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|poport
operator|=
name|stdout
argument_list|)
expr_stmt|;
comment|/* stand. output */
name|inewatom
argument_list|(
literal|"errport"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|P
argument_list|(
name|errport
operator|=
name|stderr
argument_list|)
operator|)
expr_stmt|;
comment|/* stand. err. */
name|ioname
index|[
name|PN
argument_list|(
name|stdin
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"$stdin"
argument_list|)
expr_stmt|;
name|ioname
index|[
name|PN
argument_list|(
name|stdout
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"$stdout"
argument_list|)
expr_stmt|;
name|ioname
index|[
name|PN
argument_list|(
name|stderr
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"$stderr"
argument_list|)
expr_stmt|;
name|inewatom
argument_list|(
literal|"Standard-Input"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|Vpiport
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|inewatom
argument_list|(
literal|"Standard-Output"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|Vpoport
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|inewatom
argument_list|(
literal|"Standard-Error"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|errport
argument_list|)
expr_stmt|;
operator|(
name|Vreadtable
operator|=
name|inewatom
argument_list|(
literal|"readtable"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|Imkrtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|Imkrtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Vptport
operator|=
name|inewatom
argument_list|(
literal|"ptport"
argument_list|)
expr_stmt|;
name|Vptport
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* protocal port */
name|Vcntlw
operator|=
name|inewatom
argument_list|(
literal|"^w"
argument_list|)
expr_stmt|;
comment|/* when non nil, inhibits output to term */
name|Vcntlw
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|Vldprt
operator|=
name|inewatom
argument_list|(
literal|"$ldprint"
argument_list|)
expr_stmt|;
comment|/* when nil, inhibits printing of fasl/autoload   */
comment|/* cfasl messages to term */
name|Vldprt
operator|->
name|a
operator|.
name|clb
operator|=
name|tatom
expr_stmt|;
name|Vprinlevel
operator|=
name|inewatom
argument_list|(
literal|"prinlevel"
argument_list|)
expr_stmt|;
comment|/* printer recursion count */
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* infinite recursion */
name|Vprinlength
operator|=
name|inewatom
argument_list|(
literal|"prinlength"
argument_list|)
expr_stmt|;
comment|/* printer element count */
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* infinite elements */
name|Vfloatformat
operator|=
name|inewatom
argument_list|(
literal|"float-format"
argument_list|)
expr_stmt|;
name|Vfloatformat
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"%.16g"
argument_list|)
expr_stmt|;
name|Verdepth
operator|=
name|inewatom
argument_list|(
literal|"Error-Depth"
argument_list|)
expr_stmt|;
name|Verdepth
operator|->
name|a
operator|.
name|clb
operator|=
name|inewint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* depth of error */
name|Vpurcopylits
operator|=
name|inewatom
argument_list|(
literal|"$purcopylits"
argument_list|)
expr_stmt|;
name|Vpurcopylits
operator|->
name|a
operator|.
name|clb
operator|=
name|tatom
expr_stmt|;
comment|/* tells fasl to purcopy 						 *  literals it reads 						 */
name|Vdisplacemacros
operator|=
name|inewatom
argument_list|(
literal|"displace-macros"
argument_list|)
expr_stmt|;
name|Vdisplacemacros
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* replace macros calls 						 * with their expanded forms 						 */
name|Vprintsym
operator|=
name|inewatom
argument_list|(
literal|"print"
argument_list|)
expr_stmt|;
name|atom_buffer
operator|=
operator|(
name|lispval
operator|)
name|strbuf
expr_stmt|;
name|Vlibdir
operator|=
name|inewatom
argument_list|(
literal|"lisp-library-directory"
argument_list|)
expr_stmt|;
name|Vlibdir
operator|->
name|a
operator|.
name|clb
operator|=
name|inewatom
argument_list|(
literal|"/usr/lib/lisp"
argument_list|)
expr_stmt|;
comment|/*  The following atoms are used as tokens by the reader  */
name|perda
operator|=
name|inewatom
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|lpara
operator|=
name|inewatom
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|rpara
operator|=
name|inewatom
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|lbkta
operator|=
name|inewatom
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|rbkta
operator|=
name|inewatom
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|snqta
operator|=
name|inewatom
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|exclpa
operator|=
name|inewatom
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
operator|(
name|Eofa
operator|=
name|inewatom
argument_list|(
literal|"eof"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|eofa
expr_stmt|;
comment|/*  The following few atoms have values the reader tokens.  */
comment|/*  Perhaps this is a kludge which should be abandoned.  */
comment|/*  On the other hand, perhaps it is an inspiration.	*/
name|inewatom
argument_list|(
literal|"perd"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|perda
expr_stmt|;
name|inewatom
argument_list|(
literal|"lpar"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|lpara
expr_stmt|;
name|inewatom
argument_list|(
literal|"rpar"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|rpara
expr_stmt|;
name|inewatom
argument_list|(
literal|"lbkt"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|lbkta
expr_stmt|;
name|inewatom
argument_list|(
literal|"rbkt"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|rbkta
expr_stmt|;
name|noptop
operator|=
name|inewatom
argument_list|(
literal|"noptop"
argument_list|)
expr_stmt|;
comment|/*  atoms used in connection with comments.  */
name|commta
operator|=
name|inewatom
argument_list|(
literal|"comment"
argument_list|)
expr_stmt|;
name|rcomms
operator|=
name|inewatom
argument_list|(
literal|"readcomments"
argument_list|)
expr_stmt|;
comment|/*  the following atoms are used for lexprs */
name|lexpr_atom
operator|=
name|inewatom
argument_list|(
literal|"last lexpr binding\7"
argument_list|)
expr_stmt|;
name|lexpr
operator|=
name|inewatom
argument_list|(
literal|"lexpr"
argument_list|)
expr_stmt|;
comment|/* the following atom is used to reference the bind stack for eval */
name|bptr_atom
operator|=
name|inewatom
argument_list|(
literal|"eval1 binding pointer\7"
argument_list|)
expr_stmt|;
name|bptr_atom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* the following atoms are used for evalhook hackery */
name|evalhatom
operator|=
name|inewatom
argument_list|(
literal|"evalhook"
argument_list|)
expr_stmt|;
name|evalhatom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|evalhcallsw
operator|=
name|FALSE
expr_stmt|;
name|funhatom
operator|=
name|inewatom
argument_list|(
literal|"funcallhook"
argument_list|)
expr_stmt|;
name|funhatom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|funhcallsw
operator|=
name|FALSE
expr_stmt|;
name|Vevalframe
operator|=
name|inewatom
argument_list|(
literal|"evalframe"
argument_list|)
expr_stmt|;
name|sysa
operator|=
name|inewatom
argument_list|(
literal|"sys"
argument_list|)
expr_stmt|;
name|plima
operator|=
name|inewatom
argument_list|(
literal|"pagelimit"
argument_list|)
expr_stmt|;
comment|/*  max number of pages  */
name|startup
operator|=
name|inewatom
argument_list|(
literal|"startup"
argument_list|)
expr_stmt|;
comment|/*  used by save and restore  */
name|sysa
operator|=
name|inewatom
argument_list|(
literal|"sys"
argument_list|)
expr_stmt|;
comment|/*  sys indicator for system variables  */
name|splice
operator|=
name|inewatom
argument_list|(
literal|"splicing"
argument_list|)
expr_stmt|;
comment|/* vector stuff */
name|odform
operator|=
name|inewatom
argument_list|(
literal|"odformat"
argument_list|)
expr_stmt|;
comment|/* format for printf's used in od */
name|rdrsdot
operator|=
name|newsdot
argument_list|()
expr_stmt|;
comment|/* used in io conversions of bignums */
name|rdrsdot2
operator|=
name|newsdot
argument_list|()
expr_stmt|;
comment|/* used in io conversions of bignums */
name|rdrint
operator|=
name|newint
argument_list|()
expr_stmt|;
comment|/* used as a temporary integer */
operator|(
name|nilplist
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
comment|/* used as property list for nil, 					   since nil will eventually be put at 					   0 (consequently in text and not 					   writable) */
comment|/* error variables */
operator|(
name|Vererr
operator|=
name|inewatom
argument_list|(
literal|"ER%err"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Vertpl
operator|=
name|inewatom
argument_list|(
literal|"ER%tpl"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verall
operator|=
name|inewatom
argument_list|(
literal|"ER%all"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Vermisc
operator|=
name|inewatom
argument_list|(
literal|"ER%misc"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verbrk
operator|=
name|inewatom
argument_list|(
literal|"ER%brk"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verundef
operator|=
name|inewatom
argument_list|(
literal|"ER%undef"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Vlerall
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|Verall
expr_stmt|;
comment|/* list (ER%all) */
operator|(
name|Veruwpt
operator|=
name|inewatom
argument_list|(
literal|"ER%unwind-protect"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verrset
operator|=
name|inewatom
argument_list|(
literal|"errset"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* set up the initial status list */
name|stlist
operator|=
name|nil
expr_stmt|;
comment|/* initially nil */
block|{
name|lispval
name|feature
decl_stmt|,
name|dom
decl_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"features"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|feature
operator|=
name|inewatom
argument_list|(
literal|"feature"
argument_list|)
argument_list|,
name|ST_FEATR
argument_list|,
name|ST_FEATW
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"franz"
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"Franz"
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
name|OS
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"string"
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|dom
operator|=
name|inewatom
argument_list|(
name|DOMAIN
argument_list|)
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"domain"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_NO
argument_list|,
name|dom
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
name|MACHINE
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTABLE
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"portable"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|unisoft
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"unisoft"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"sun"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|os_masscomp
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"mc500"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|os_4_1c
operator||
name|os_4_2
operator||
name|os_4_3
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|inewatom
argument_list|(
literal|"long-filenames"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"nofeature"
argument_list|)
argument_list|,
name|ST_NFETR
argument_list|,
name|ST_NFETW
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"syntax"
argument_list|)
argument_list|,
name|ST_SYNT
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"uctolc"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_TOLC
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_CORE
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|inewatom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/*set up signals*/
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"chainatom"
argument_list|)
argument_list|,
name|ST_RINTB
argument_list|,
name|ST_INTB
argument_list|,
name|inewint
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"dumpmode"
argument_list|)
argument_list|,
name|ST_DMPR
argument_list|,
name|ST_DMPW
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"appendmap"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* used by fasl */
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"debugging"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"evalhook"
argument_list|)
argument_list|,
name|ST_RINTB
argument_list|,
name|ST_INTB
argument_list|,
name|inewint
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|inewatom
argument_list|(
literal|"evalhook"
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/*evalhook switch off */
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"bcdtrace"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_BCDTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"ctime"
argument_list|)
argument_list|,
name|ST_CTIM
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"localtime"
argument_list|)
argument_list|,
name|ST_LOCT
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"isatty"
argument_list|)
argument_list|,
name|ST_ISTTY
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"ignoreeof"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"version"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_NO
argument_list|,
name|mstr
argument_list|(
literal|"Franz Lisp, Opus 38"
argument_list|)
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"automatic-reset"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_AUTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"translink"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_TRAN
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|inewatom
argument_list|(
literal|"translink"
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* turn off tran links */
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"undeffunc"
argument_list|)
argument_list|,
name|ST_UNDEF
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* list undef funcs */
name|Iaddstat
argument_list|(
name|inewatom
argument_list|(
literal|"gcstrings"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_GCSTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* gc strings */
comment|/* garbage collector things */
name|gcport
operator|=
name|inewatom
argument_list|(
literal|"gcport"
argument_list|)
expr_stmt|;
comment|/* port for gc dumping */
name|gccheck
operator|=
name|inewatom
argument_list|(
literal|"gccheck"
argument_list|)
expr_stmt|;
comment|/* flag for checking during gc */
name|gcdis
operator|=
name|inewatom
argument_list|(
literal|"gcdisable"
argument_list|)
expr_stmt|;
comment|/* variable for disabling the gc */
name|gcdis
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|gcload
operator|=
name|inewatom
argument_list|(
literal|"gcload"
argument_list|)
expr_stmt|;
comment|/* option for gc while loading */
name|loading
operator|=
name|inewatom
argument_list|(
literal|"loading"
argument_list|)
expr_stmt|;
comment|/* flag--in loader if = t  */
name|noautot
operator|=
name|inewatom
argument_list|(
literal|"noautotrace"
argument_list|)
expr_stmt|;
comment|/* option to inhibit auto-trace */
name|Vgcprint
operator|=
name|inewatom
argument_list|(
literal|"$gcprint"
argument_list|)
expr_stmt|;
comment|/* if t then pring gc messages */
name|Vgcprint
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|gcthresh
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|tgcthresh
expr_stmt|;
name|gccall1
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|gccall2
operator|=
name|newdot
argument_list|()
expr_stmt|;
comment|/* used to call gcafter */
name|gccall1
operator|->
name|d
operator|.
name|car
operator|=
name|gcafter
expr_stmt|;
comment|/* start constructing a form for eval */
name|arrayst
operator|=
name|mstr
argument_list|(
literal|"ARRAY"
argument_list|)
expr_stmt|;
comment|/* array marker in name stack */
name|bcdst
operator|=
name|mstr
argument_list|(
literal|"BINARY"
argument_list|)
expr_stmt|;
comment|/* binary function marker */
name|listst
operator|=
name|mstr
argument_list|(
literal|"INTERPRETED"
argument_list|)
expr_stmt|;
comment|/* interpreted function marker */
name|macrost
operator|=
name|mstr
argument_list|(
literal|"MACRO"
argument_list|)
expr_stmt|;
comment|/* macro marker */
name|protst
operator|=
name|mstr
argument_list|(
literal|"PROTECTED"
argument_list|)
expr_stmt|;
comment|/* protection marker */
name|badst
operator|=
name|mstr
argument_list|(
literal|"BADPTR"
argument_list|)
expr_stmt|;
comment|/* bad pointer marker */
name|argst
operator|=
name|mstr
argument_list|(
literal|"ARGST"
argument_list|)
expr_stmt|;
comment|/* argument marker */
name|hunkfree
operator|=
name|mstr
argument_list|(
literal|"EMPTY"
argument_list|)
expr_stmt|;
comment|/* empty hunk cell value */
comment|/* type names */
name|FIDDLE
argument_list|(
name|atom_name
argument_list|,
name|atom_items
argument_list|,
name|atom_pages
argument_list|,
name|ATOMSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|str_name
argument_list|,
name|str_items
argument_list|,
name|str_pages
argument_list|,
name|STRSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|other_name
argument_list|,
name|other_items
argument_list|,
name|other_pages
argument_list|,
name|STRSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|int_name
argument_list|,
name|int_items
argument_list|,
name|int_pages
argument_list|,
name|INTSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|dtpr_name
argument_list|,
name|dtpr_items
argument_list|,
name|dtpr_pages
argument_list|,
name|DTPRSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|doub_name
argument_list|,
name|doub_items
argument_list|,
name|doub_pages
argument_list|,
name|DOUBSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|sdot_name
argument_list|,
name|sdot_items
argument_list|,
name|sdot_pages
argument_list|,
name|SDOTSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|array_name
argument_list|,
name|array_items
argument_list|,
name|array_pages
argument_list|,
name|ARRAYSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|val_name
argument_list|,
name|val_items
argument_list|,
name|val_pages
argument_list|,
name|VALSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|funct_name
argument_list|,
name|funct_items
argument_list|,
name|funct_pages
argument_list|,
name|BCDSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|0
index|]
argument_list|,
name|hunk_items
index|[
literal|0
index|]
argument_list|,
name|hunk_pages
index|[
literal|0
index|]
argument_list|,
name|HUNK2SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|1
index|]
argument_list|,
name|hunk_items
index|[
literal|1
index|]
argument_list|,
name|hunk_pages
index|[
literal|1
index|]
argument_list|,
name|HUNK4SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|2
index|]
argument_list|,
name|hunk_items
index|[
literal|2
index|]
argument_list|,
name|hunk_pages
index|[
literal|2
index|]
argument_list|,
name|HUNK8SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|3
index|]
argument_list|,
name|hunk_items
index|[
literal|3
index|]
argument_list|,
name|hunk_pages
index|[
literal|3
index|]
argument_list|,
name|HUNK16SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|4
index|]
argument_list|,
name|hunk_items
index|[
literal|4
index|]
argument_list|,
name|hunk_pages
index|[
literal|4
index|]
argument_list|,
name|HUNK32SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|5
index|]
argument_list|,
name|hunk_items
index|[
literal|5
index|]
argument_list|,
name|hunk_pages
index|[
literal|5
index|]
argument_list|,
name|HUNK64SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|6
index|]
argument_list|,
name|hunk_items
index|[
literal|6
index|]
argument_list|,
name|hunk_pages
index|[
literal|6
index|]
argument_list|,
name|HUNK128SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
argument|vect_name
argument_list|,
argument|vect_items
argument_list|,
argument|vect_pages
argument_list|,
argument|VECTORSPP
argument_list|)
name|FIDDLE
argument_list|(
name|vecti_name
argument_list|,
name|vecti_items
argument_list|,
name|vecti_pages
argument_list|,
name|VECTORSPP
argument_list|)
argument_list|(
name|plimit
operator|=
name|newint
argument_list|()
argument_list|)
operator|->
name|i
operator|=
name|page_limit
expr_stmt|;
name|copval
argument_list|(
name|plima
argument_list|,
name|plimit
argument_list|)
expr_stmt|;
comment|/*  default value  */
comment|/* the following atom is used when reading caar, cdar, etc. */
name|xatom
operator|=
name|inewatom
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
name|dofuns
argument_list|()
expr_stmt|;
if|#
directive|if
name|sun_4_1c
operator|||
name|sun_4_2
operator|||
name|sun_4_2beta
name|hookupcore
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*  now it is OK to collect garbage  */
name|initflag
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  matom("name")  ******************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  simulates an atom being read in from the reader and returns a	*/
end_comment

begin_comment
comment|/*  pointer to it.							*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  BEWARE:  if an atom becomes "truly worthless" and is collected,	*/
end_comment

begin_comment
comment|/*  the pointer becomes obsolete.					*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_function
name|lispval
name|matom
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|strbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strncat
argument_list|(
name|strbuf
argument_list|,
name|string
argument_list|,
name|STRBLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* strcpyn always pads to n */
name|strbuf
index|[
name|STRBLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  mstr  ***************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Makes a string.  Uses matom.					*/
end_comment

begin_comment
comment|/*  Not the most efficient but will do until the string from the code	*/
end_comment

begin_comment
comment|/*  itself can be used as a lispval.					*/
end_comment

begin_function
name|lispval
name|mstr
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|pinewstr
argument_list|(
name|string
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  mfun("name",start)  *************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Same as matom, but entry point to c code is associated with		*/
end_comment

begin_comment
comment|/*  "name" as function binding.						*/
end_comment

begin_comment
comment|/*  A pointer to the atom is returned.					*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_decl_stmt
name|lispval
name|mfun
argument_list|(
name|string
argument_list|,
name|start
argument_list|,
name|discip
argument_list|)
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
argument_list|(
operator|*
name|start
argument_list|)
argument_list|()
decl_stmt|,
name|discip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lispval
name|v
decl_stmt|;
name|v
operator|=
name|inewatom
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|->
name|bcd
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|discip
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ftab
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|lispval
function_decl|(
modifier|*
name|start
function_decl|)
parameter_list|()
function_decl|;
name|lispval
modifier|*
name|discip
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|lispval
name|mftab
parameter_list|(
name|table
parameter_list|)
specifier|register
name|struct
name|ftab
modifier|*
name|table
decl_stmt|;
block|{
specifier|register
name|lispval
name|v
decl_stmt|;
for|for
control|(
init|;
name|table
operator|->
name|string
condition|;
name|table
operator|++
control|)
block|{
name|v
operator|=
name|inewatom
argument_list|(
name|table
operator|->
name|string
argument_list|)
expr_stmt|;
name|v
operator|=
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|v
operator|->
name|bcd
operator|.
name|start
operator|=
name|table
operator|->
name|start
expr_stmt|;
name|v
operator|->
name|bcd
operator|.
name|discipline
operator|=
operator|*
name|table
operator|->
name|discip
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ftab
name|cfuns
index|[]
init|=
block|{
block|{
literal|"car"
block|,
name|Lcar
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cdr"
block|,
name|Lcdr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"eval"
block|,
name|Leval1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"asin"
block|,
name|Lasin
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"acos"
block|,
name|Lacos
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"atan"
block|,
name|Latan
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cos"
block|,
name|Lcos
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"sin"
block|,
name|Lsin
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"sqrt"
block|,
name|Lsqrt
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"exp"
block|,
name|Lexp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"log"
block|,
name|Llog
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"lsh"
block|,
name|Llsh
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"bignum-leftshift"
block|,
name|Lbiglsh
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"sticky-bignum-leftshift"
block|,
name|Lsbiglsh
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"frexp"
block|,
name|Lfrexp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"rot"
block|,
name|Lrot
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"random"
block|,
name|Lrandom
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"atom"
block|,
name|Latom
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"apply"
block|,
name|Lapply
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"funcall"
block|,
name|Lfuncal
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"lexpr-funcall"
block|,
name|Llexfun
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"return"
block|,
name|Lreturn
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* 	MK("cont",Lreturn,lambda),  */
block|{
literal|"cons"
block|,
name|Lcons
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"scons"
block|,
name|Lscons
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"bignum-to-list"
block|,
name|Lbigtol
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cadr"
block|,
name|Lcadr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"caar"
block|,
name|Lcaar
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cddr"
block|,
name|Lc02r
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"caddr"
block|,
name|Lc12r
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cdddr"
block|,
name|Lc03r
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cadddr"
block|,
name|Lc13r
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cddddr"
block|,
name|Lc04r
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"caddddr"
block|,
name|Lc14r
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"nthelem"
block|,
name|Lnthelem
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"eq"
block|,
name|Leq
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"equal"
block|,
name|Lequal
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/**	MK("zqual",Zequal,lambda), 	*/
block|{
literal|"numberp"
block|,
name|Lnumberp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"dtpr"
block|,
name|Ldtpr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"bcdp"
block|,
name|Lbcdp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"portp"
block|,
name|Lportp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"arrayp"
block|,
name|Larrayp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"valuep"
block|,
name|Lvaluep
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"get_pname"
block|,
name|Lpname
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"ptr"
block|,
name|Lptr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"arrayref"
block|,
name|Larayref
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"marray"
block|,
name|Lmarray
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getlength"
block|,
name|Lgetl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putlength"
block|,
name|Lputl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getaccess"
block|,
name|Lgeta
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putaccess"
block|,
name|Lputa
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getdelta"
block|,
name|Lgetdel
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putdelta"
block|,
name|Lputdel
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getaux"
block|,
name|Lgetaux
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putaux"
block|,
name|Lputaux
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getdata"
block|,
name|Lgetdata
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putdata"
block|,
name|Lputdata
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"mfunction"
block|,
name|Lmfunction
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getentry"
block|,
name|Lgtentry
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getdisc"
block|,
name|Lgetdisc
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putdisc"
block|,
name|Lputdisc
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"segment"
block|,
name|Lsegment
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"rplaca"
block|,
name|Lrplca
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"rplacd"
block|,
name|Lrplcd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"set"
block|,
name|Lset
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"replace"
block|,
name|Lreplace
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"infile"
block|,
name|Linfile
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"outfile"
block|,
name|Loutfile
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"terpr"
block|,
name|Lterpr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"print"
block|,
name|Lprint
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"close"
block|,
name|Lclose
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"patom"
block|,
name|Lpatom
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"pntlen"
block|,
name|Lpntlen
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"read"
block|,
name|Lread
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"ratom"
block|,
name|Lratom
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"readc"
block|,
name|Lreadc
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"truename"
block|,
name|Ltruename
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"implode"
block|,
name|Limplode
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"maknam"
block|,
name|Lmaknam
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"deref"
block|,
name|Lderef
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"concat"
block|,
name|Lconcat
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"uconcat"
block|,
name|Luconcat
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putprop"
block|,
name|Lputprop
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"monitor"
block|,
name|Lmonitor
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"get"
block|,
name|Lget
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"getd"
block|,
name|Lgetd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"putd"
block|,
name|Lputd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"prog"
block|,
name|Nprog
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"quote"
block|,
name|Nquote
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"function"
block|,
name|Nfunction
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"go"
block|,
name|Ngo
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"*catch"
block|,
name|Ncatch
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"errset"
block|,
name|Nerrset
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"status"
block|,
name|Nstatus
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"sstatus"
block|,
name|Nsstatus
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"err-with-message"
block|,
name|Lerr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"*throw"
block|,
name|Nthrow
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* this is a lambda now !! */
block|{
literal|"reset"
block|,
name|Nreset
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"break"
block|,
name|Nbreak
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"exit"
block|,
name|Lexit
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"def"
block|,
name|Ndef
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"null"
block|,
name|Lnull
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*{"framedump", Lframedump,&(lambda)},*/
block|{
literal|"and"
block|,
name|Nand
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"or"
block|,
name|Nor
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"setq"
block|,
name|Nsetq
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"cond"
block|,
name|Ncond
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"list"
block|,
name|Llist
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"load"
block|,
name|Lload
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"nwritn"
block|,
name|Lnwritn
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"*process"
block|,
name|Lprocess
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*  execute a shell command  */
block|{
literal|"allocate"
block|,
name|Lalloc
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*  allocate a page  */
block|{
literal|"sizeof"
block|,
name|Lsizeof
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*  size of one item of a data type  */
block|{
literal|"dumplisp"
block|,
name|Ndumplisp
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
comment|/*  NEW save the world  */
block|{
literal|"top-level"
block|,
name|Ntpl
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
comment|/*  top level eval-print read loop  */
block|{
literal|"mapcar"
block|,
name|Lmpcar
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"maplist"
block|,
name|Lmaplist
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"mapcan"
block|,
name|Lmapcan
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"mapcon"
block|,
name|Lmapcon
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"assq"
block|,
name|Lassq
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"mapc"
block|,
name|Lmapc
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"map"
block|,
name|Lmap
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"flatc"
block|,
name|Lflatsi
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"alphalessp"
block|,
name|Lalfalp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"drain"
block|,
name|Ldrain
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"killcopy"
block|,
name|Lkilcopy
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*  forks aand aborts for adb */
block|{
literal|"opval"
block|,
name|Lopval
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*  sets and retrieves system variables  */
block|{
literal|"ncons"
block|,
name|Lncons
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"remob"
block|,
name|Lforget
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*  function to take atom out of hash table  */
block|{
literal|"not"
block|,
name|Lnull
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"plus"
block|,
name|Ladd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"add"
block|,
name|Ladd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"times"
block|,
name|Ltimes
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"difference"
block|,
name|Lsub
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"quotient"
block|,
name|Lquo
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"+"
block|,
name|Lfp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"-"
block|,
name|Lfm
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"*"
block|,
name|Lft
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"/"
block|,
name|Lfd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"1+"
block|,
name|Lfadd1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"1-"
block|,
name|Lfsub1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"^"
block|,
name|Lfexpt
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"double-to-float"
block|,
name|Ldbtofl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"float-to-double"
block|,
name|Lfltodb
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"<"
block|,
name|Lflessp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"mod"
block|,
name|Lmod
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"minus"
block|,
name|Lminus
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"absval"
block|,
name|Labsval
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"add1"
block|,
name|Ladd1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"sub1"
block|,
name|Lsub1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"greaterp"
block|,
name|Lgreaterp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"lessp"
block|,
name|Llessp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"any-zerop"
block|,
name|Lzerop
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* used when bignum arg possible */
block|{
literal|"zerop"
block|,
name|Lzerop
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"minusp"
block|,
name|Lnegp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"onep"
block|,
name|Lonep
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"sum"
block|,
name|Ladd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"product"
block|,
name|Ltimes
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"do"
block|,
name|Ndo
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"progv"
block|,
name|Nprogv
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"progn"
block|,
name|Nprogn
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"prog2"
block|,
name|Nprog2
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"oblist"
block|,
name|Loblist
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"baktrace"
block|,
name|Lbaktrace
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"tyi"
block|,
name|Ltyi
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"tyipeek"
block|,
name|Ltyipeek
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"untyi"
block|,
name|Luntyi
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"tyo"
block|,
name|Ltyo
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"termcapinit"
block|,
name|Ltci
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"termcapexe"
block|,
name|Ltcx
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:setsyntax"
block|,
name|Lsetsyn
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* an internal function */
block|{
literal|"int:getsyntax"
block|,
name|Lgetsyntax
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:showstack"
block|,
name|LIshowstack
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:franz-call"
block|,
name|LIfranzcall
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"makereadtable"
block|,
name|Lmakertbl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"zapline"
block|,
name|Lzapline
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"aexplode"
block|,
name|Lxplda
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"aexplodec"
block|,
name|Lxpldc
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"aexploden"
block|,
name|Lxpldn
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"hashtabstat"
block|,
name|Lhashst
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
ifdef|#
directive|ifdef
name|METER
block|{
literal|"gcstat"
block|,
name|Lgcstat
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
endif|#
directive|endif
block|{
literal|"argv"
block|,
name|Largv
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"arg"
block|,
name|Larg
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"setarg"
block|,
name|Lsetarg
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"showstack"
block|,
name|Lshostk
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"freturn"
block|,
name|Lfretn
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"*rset"
block|,
name|Lrset
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"eval1"
block|,
name|Leval1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"evalframe"
block|,
name|Levalf
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"evalhook"
block|,
name|Levalhook
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"funcallhook"
block|,
name|Lfunhook
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:fclosure-stack-stuff"
block|,
name|LIfss
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"resetio"
block|,
name|Nioreset
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"chdir"
block|,
name|Lchdir
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"ascii"
block|,
name|Lascii
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"boole"
block|,
name|Lboole
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"type"
block|,
name|Ltype
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* returns type-name of argument */
block|{
literal|"fix"
block|,
name|Lfix
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"float"
block|,
name|Lfloat
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"fact"
block|,
name|Lfact
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"cpy1"
block|,
name|Lcpy1
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"Divide"
block|,
name|LDivide
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"Emuldiv"
block|,
name|LEmuldiv
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"readlist"
block|,
name|Lreadli
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"plist"
block|,
name|Lplist
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* gives the plist of an atom */
block|{
literal|"setplist"
block|,
name|Lsetpli
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* get plist of an atom  */
block|{
literal|"eval-when"
block|,
name|Nevwhen
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"syscall"
block|,
name|Lsyscall
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"intern"
block|,
name|Lntern
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"ptime"
block|,
name|Lptime
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* return process user time */
block|{
literal|"fork"
block|,
name|Lfork
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* turn on fork and wait */
block|{
literal|"wait"
block|,
name|Lwait
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/*	MK("pipe",Lpipe,lambda),	*/
comment|/*	MK("fdopen",Lfdopen,lambda), */
block|{
literal|"exece"
block|,
name|Lexece
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"gensym"
block|,
name|Lgensym
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"remprop"
block|,
name|Lremprop
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"bcdad"
block|,
name|Lbcdad
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"symbolp"
block|,
name|Lsymbolp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"stringp"
block|,
name|Lstringp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"rematom"
block|,
name|Lrematom
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/**	MK("prname",Lprname,lambda),	*/
block|{
literal|"getenv"
block|,
name|Lgetenv
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"I-throw-err"
block|,
name|Lctcherr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* directly force a throw or error */
block|{
literal|"makunbound"
block|,
name|Lmakunb
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"haipart"
block|,
name|Lhaipar
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"haulong"
block|,
name|Lhau
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"signal"
block|,
name|Lsignal
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"fasl"
block|,
name|Lfasl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* NEW - new fasl loader */
block|{
literal|"cfasl"
block|,
name|Lcfasl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* read in compiled C file */
block|{
literal|"getaddress"
block|,
name|Lgetaddress
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"removeaddress"
block|,
name|Lrmadd
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* unbind symbols    */
block|{
literal|"make-c-thunk"
block|,
name|Lmkcth
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* make wrappers    */
block|{
literal|"boundp"
block|,
name|Lboundp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* tells if an atom is bound */
block|{
literal|"fake"
block|,
name|Lfake
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* makes a fake lisp pointer */
comment|/***	MK("od",Lod,lambda),		/* dumps info */
block|{
literal|"maknum"
block|,
name|Lmaknum
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* converts a pointer to an integer */
block|{
literal|"*mod"
block|,
name|LstarMod
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* return fixnum modulus */
block|{
literal|"*invmod"
block|,
name|Lstarinvmod
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* return fixnum modulus ^-1 */
block|{
literal|"fseek"
block|,
name|Lfseek
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* seek to a specific byte in a file */
block|{
literal|"fileopen"
block|,
name|Lfileopen
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"pv%"
block|,
name|Lpolyev
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* polynomial evaluation instruction*/
block|{
literal|"cprintf"
block|,
name|Lcprintf
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* formatted print 		    */
block|{
literal|"sprintf"
block|,
name|Lsprintf
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* formatted print to string	    */
block|{
literal|"copyint*"
block|,
name|Lcopyint
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* copyint*  */
block|{
literal|"purcopy"
block|,
name|Lpurcopy
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* pure copy */
block|{
literal|"purep"
block|,
name|Lpurep
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* check if pure */
block|{
literal|"int:memreport"
block|,
name|LImemory
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* dump memory stats */
comment|/*  * Hunk stuff  */
block|{
literal|"*makhunk"
block|,
name|LMakhunk
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* special hunk creater */
block|{
literal|"hunkp"
block|,
name|Lhunkp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* test a hunk */
block|{
literal|"cxr"
block|,
name|Lcxr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* cxr of a hunk */
block|{
literal|"rplacx"
block|,
name|Lrplcx
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* replace element of a hunk */
block|{
literal|"*rplacx"
block|,
name|Lstarrpx
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* rplacx used by hunk */
block|{
literal|"hunksize"
block|,
name|Lhunksize
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* size of a hunk */
block|{
literal|"hunk-to-list"
block|,
name|Lhtol
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* hunk to list */
block|{
literal|"new-vector"
block|,
name|Lnvec
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"new-vectori-byte"
block|,
name|Lnvecb
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"new-vectori-word"
block|,
name|Lnvecw
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"new-vectori-long"
block|,
name|Lnvecl
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"vectorp"
block|,
name|Lvectorp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"vectorip"
block|,
name|Lpvp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:vref"
block|,
name|LIvref
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:vset"
block|,
name|LIvset
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"int:vsize"
block|,
name|LIvsize
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"vsetprop"
block|,
name|Lvsp
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"vprop"
block|,
name|Lvprop
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"probef"
block|,
name|Lprobef
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* test file existance */
block|{
literal|"substring"
block|,
name|Lsubstring
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"substringn"
block|,
name|Lsstrn
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"character-index"
block|,
name|Lcharindex
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
comment|/* index of char in string */
block|{
literal|"time-string"
block|,
name|Ltymestr
block|,
operator|&
operator|(
name|lambda
operator|)
block|}
block|,
block|{
literal|"gc"
block|,
name|Ngc
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
block|{
literal|"gcafter"
block|,
name|Ngcafter
block|,
operator|&
operator|(
name|nlambda
operator|)
block|}
block|,
comment|/* garbage collection wind-up */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|dofuns
argument_list|()
block|{
name|mftab
argument_list|(
name|cfuns
argument_list|)
block|;}
end_expr_stmt

end_unit

