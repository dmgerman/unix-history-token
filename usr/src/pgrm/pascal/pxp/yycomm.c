begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)yycomm.c	5.2 (Berkeley) 3/17/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * pxp - Pascal execution profiler  *  * Bill Joy UCB  * Version 1.2 January 1979  */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_comment
comment|/*  * COMMENT PROCESSING CLUSTER  *  * The global organization of this cluster is as follows.  * While parsing the program information is saved in the tree which  * tells the source text coordinates (sequence numbers and columns)  * bounding each production.  The comments from the source program  * are also saved, with information about their source text position  * and a classification as to their kind.  *  * When printing the reformatted program we flush out the comments  * at various points using the information in the comments and the parse  * tree to "resynchronize".  A number of special cases are recognized to  * deal with the vagarities of producing a true "fixed point" so that  * a prettyprinted program will re-prettyprint to itself.  */
end_comment

begin_comment
comment|/*  * Save sequence id's and column markers bounding a production  * for later use in placing comments.  We save the sequence id  * and column of the leftmost token and the following token, and  * the sequence id of the last token in this reduction.  * See putcm, putcml, and putcmp below for motivation.  */
end_comment

begin_macro
name|line2of
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|lineNof
argument_list|(
name|l
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|lineof
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|lineNof
argument_list|(
name|l
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|lineNof
argument_list|(
argument|l
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|,
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|tree
argument_list|(
literal|6
argument_list|,
name|l
argument_list|,
name|yypw
index|[
name|i
index|]
operator|.
name|Wseqid
argument_list|,
name|yypw
index|[
name|i
index|]
operator|.
name|Wcol
argument_list|,
name|yyseqid
argument_list|,
name|yycol
argument_list|,
name|yypw
index|[
name|N
index|]
operator|.
name|Wseqid
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * After a call to setline, Seqid is set to the sequence id  * of the symbol which followed the reduction in which the  * lineof call was embedded, Col to the associated column,  * and LSeqid to the sequence id of the last symbol in the reduction  * (Note that this is exact only if the last symbol was a terminal  * this is always true when it matters.)  */
end_comment

begin_decl_stmt
name|int
name|Seqid
decl_stmt|,
name|Col
decl_stmt|,
name|LSeqid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Retrieve the information from a call to lineof before beginning the  * output of a tree from a reduction.  First flush to the left margin  * of the production, and then set so that later calls to putcm, putcml  * and putcmp will deal with the right margin of this comment.  *  * The routine setinfo is called when the lineof has no embedded line  * number to avoid trashing the current "line".  *  * The routine setinfo is often called after completing the output of  * the text of a tree to restore Seqid, Col, and LSeqid which may have  * been destroyed by the nested processing calls to setline.  * In this case the only effect of the call to setinfo is to  * modify the above three variables as a side effect.  *  * We return a word giving information about the comments which were  * actually put out.  See putcm for details.  */
end_comment

begin_macro
name|setline
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line
operator|=
name|ip
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|setinfo
argument_list|(
name|ip
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setinfo
argument_list|(
name|ip
argument_list|)
specifier|register
name|int
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|ip
operator|++
expr_stmt|;
name|Seqid
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|Col
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|i
operator|=
name|putcm
argument_list|()
expr_stmt|;
name|Seqid
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|Col
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|LSeqid
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|cmeof
decl_stmt|,
name|incomm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get the text of a comment from the input stream,  * recording its type and linking it into the linked  * list of comments headed by cmhp.  */
end_comment

begin_macro
name|getcm
argument_list|(
argument|cmdelim
argument_list|)
end_macro

begin_decl_stmt
name|char
name|cmdelim
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cmjust
decl_stmt|,
name|col
decl_stmt|;
specifier|register
name|struct
name|comment
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|commline
modifier|*
name|kp
decl_stmt|;
name|incomm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cmdelim
operator|==
literal|'*'
operator|&&
name|yycol
operator|==
literal|10
operator|||
name|cmdelim
operator|==
literal|'{'
operator|&&
name|yycol
operator|==
literal|9
condition|)
name|cmjust
operator|=
name|CLMARG
expr_stmt|;
elseif|else
if|if
condition|(
name|yytokcnt
operator|<=
literal|1
condition|)
name|cmjust
operator|=
name|CALIGN
expr_stmt|;
elseif|else
if|if
condition|(
name|yywhcnt
operator|<
literal|2
condition|)
name|cmjust
operator|=
name|CTRAIL
expr_stmt|;
else|else
name|cmjust
operator|=
name|CRMARG
expr_stmt|;
name|col
operator|=
name|yycol
operator|-
operator|(
name|cmdelim
operator|==
literal|'{'
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|cp
operator|=
name|tree5
argument_list|(
name|NIL
argument_list|,
name|cmdelim
argument_list|,
name|NIL
argument_list|,
name|cmjust
argument_list|,
name|yyseqid
argument_list|)
expr_stmt|;
name|cmeof
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|kp
operator|=
name|getcmline
argument_list|(
name|cmdelim
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cml
operator|==
name|NIL
condition|)
block|{
name|kp
operator|->
name|cml
operator|=
name|kp
expr_stmt|;
name|kp
operator|->
name|cmcol
operator|=
name|col
expr_stmt|;
block|}
else|else
block|{
name|kp
operator|->
name|cml
operator|=
name|cp
operator|->
name|cml
operator|->
name|cml
expr_stmt|;
name|cp
operator|->
name|cml
operator|->
name|cml
operator|=
name|kp
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|cmjust
condition|)
block|{
case|case
name|CTRAIL
case|:
case|case
name|CRMARG
case|:
name|cp
operator|->
name|cmjust
operator|=
name|CALIGN
expr_stmt|;
block|}
block|}
name|cp
operator|->
name|cml
operator|=
name|kp
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|cmeof
condition|)
do|;
name|newcomm
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|incomm
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Chain the new comment at "cp" onto the linked list of comments.  */
end_comment

begin_expr_stmt
name|newcomm
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|comment
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cmhp
operator|==
name|NIL
condition|)
name|cp
operator|->
name|cmnext
operator|=
name|cp
expr_stmt|;
else|else
block|{
name|cp
operator|->
name|cmnext
operator|=
name|cmhp
operator|->
name|cmnext
expr_stmt|;
name|cmhp
operator|->
name|cmnext
operator|=
name|cp
expr_stmt|;
block|}
name|cmhp
operator|=
name|cp
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|nilcml
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|quickcomm
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|incomm
condition|)
return|return;
name|newcomm
argument_list|(
name|tree5
argument_list|(
name|nilcml
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|t
argument_list|,
name|yyseqid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|commincl
argument_list|(
argument|cp
argument_list|,
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|newcomm
argument_list|(
name|tree5
argument_list|(
name|nilcml
argument_list|,
name|savestr
argument_list|(
name|cp
argument_list|)
argument_list|,
name|ch
argument_list|,
name|CINCLUD
argument_list|,
name|yyseqid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getcmline
argument_list|(
argument|cmdelim
argument_list|)
end_macro

begin_decl_stmt
name|char
name|cmdelim
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|lastc
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|CHAR
name|c
decl_stmt|;
specifier|register
name|struct
name|commline
modifier|*
name|kp
decl_stmt|;
name|c
operator|=
name|readch
argument_list|()
expr_stmt|;
name|kp
operator|=
name|tree3
argument_list|(
name|NIL
argument_list|,
name|yycol
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|token
expr_stmt|;
name|lastc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'}'
case|:
if|if
condition|(
name|cmdelim
operator|==
literal|'{'
condition|)
goto|goto
name|endcm
goto|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|cmdelim
operator|==
literal|'*'
operator|&&
name|lastc
operator|==
literal|'*'
condition|)
block|{
operator|--
name|tp
expr_stmt|;
goto|goto
name|endcm
goto|;
block|}
break|break;
case|case
literal|'\n'
case|:
goto|goto
name|done
goto|;
case|case
operator|-
literal|1
case|:
name|yerror
argument_list|(
literal|"Comment does not terminate - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|ERRS
argument_list|)
expr_stmt|;
block|}
name|lastc
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|readch
argument_list|()
expr_stmt|;
block|}
name|endcm
label|:
name|cmeof
operator|++
expr_stmt|;
name|done
label|:
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|kp
operator|->
name|cmtext
operator|=
name|copystr
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
operator|(
name|kp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Flush through the line this token is on.  * Ignore if next token on same line as this one.  */
end_comment

begin_macro
name|putcml
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|SSeqid
decl_stmt|,
name|SCol
decl_stmt|;
if|if
condition|(
name|Seqid
operator|==
name|LSeqid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|SSeqid
operator|=
name|Seqid
operator|,
name|SCol
operator|=
name|Col
expr_stmt|;
name|Seqid
operator|=
name|LSeqid
operator|,
name|Col
operator|=
literal|32767
expr_stmt|;
name|i
operator|=
name|putcm
argument_list|()
expr_stmt|;
name|Seqid
operator|=
name|SSeqid
operator|,
name|Col
operator|=
name|SCol
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Flush to the beginning of the line this token is on.  * Ignore if this token is on the same line as the previous one  * (effectively since all such already then flushed.)  */
end_comment

begin_macro
name|putcmp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|SSeqid
decl_stmt|,
name|SCol
decl_stmt|;
name|SSeqid
operator|=
name|Seqid
operator|,
name|SCol
operator|=
name|Col
expr_stmt|;
name|Seqid
operator|=
name|LSeqid
operator|,
name|Col
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|putcm
argument_list|()
expr_stmt|;
name|Seqid
operator|=
name|SSeqid
operator|,
name|Col
operator|=
name|SCol
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Put out the comments to the border indicated by Seqid and Col  */
end_comment

begin_macro
name|putcm
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|comment
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|cmhp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|cp
operator|->
name|cmnext
expr_stmt|;
while|while
condition|(
name|cp
operator|->
name|cmseqid
operator|<
name|Seqid
operator|||
name|cp
operator|->
name|cmseqid
operator|==
name|Seqid
operator|&&
name|cp
operator|->
name|cml
operator|->
name|cmcol
operator|<
name|Col
condition|)
block|{
name|putone
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|i
operator||=
literal|1
operator|<<
name|cp
operator|->
name|cmjust
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cmnext
operator|==
name|cp
condition|)
block|{
name|cmhp
operator|=
name|NIL
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|cp
operator|->
name|cmnext
expr_stmt|;
name|cmhp
operator|->
name|cmnext
operator|=
name|cp
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Put out one comment.  * Note that empty lines, form feeds and #include statements  * are treated as comments are regurgitated here.  */
end_comment

begin_expr_stmt
name|putone
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|comment
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|commline
modifier|*
name|cml
decl_stmt|,
modifier|*
name|cmf
decl_stmt|;
name|align
argument_list|(
name|cp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|cmjust
condition|)
block|{
case|case
name|CINCLUD
case|:
comment|/* ppflush() */
if|if
condition|(
name|noinclude
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"#include %c%s%c"
argument_list|,
name|cp
operator|->
name|cml
argument_list|,
name|cp
operator|->
name|cmdelim
argument_list|,
name|cp
operator|->
name|cml
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stripcomm
condition|)
return|return;
switch|switch
condition|(
name|cp
operator|->
name|cmjust
condition|)
block|{
case|case
name|CFORM
case|:
name|ppop
argument_list|(
literal|"\f"
argument_list|)
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
case|case
name|CNL
case|:
case|case
name|CNLBL
case|:
return|return;
block|}
name|ppbra
argument_list|(
name|cp
operator|->
name|cmdelim
operator|==
literal|'{'
condition|?
literal|"{"
else|:
literal|"(*"
argument_list|)
expr_stmt|;
name|cmf
operator|=
name|cp
operator|->
name|cml
operator|->
name|cml
expr_stmt|;
name|ppid
argument_list|(
name|cmf
operator|->
name|cmtext
argument_list|)
expr_stmt|;
for|for
control|(
name|cml
operator|=
name|cmf
operator|->
name|cml
init|;
name|cml
operator|!=
name|cmf
condition|;
name|cml
operator|=
name|cml
operator|->
name|cml
control|)
block|{
name|align
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|oneline
argument_list|(
name|cmf
operator|->
name|cmcol
argument_list|,
name|cml
argument_list|)
expr_stmt|;
block|}
name|ppket
argument_list|(
name|cp
operator|->
name|cmdelim
operator|==
literal|'{'
condition|?
literal|"}"
else|:
literal|"*)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do the preliminary horizontal and vertical  * motions necessary before beginning a comment,  * or between lines of a mult-line comment.  */
end_comment

begin_expr_stmt
name|align
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|comment
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|cp
operator|->
name|cmjust
condition|)
block|{
case|case
name|CNL
case|:
name|ppsnl
argument_list|()
expr_stmt|;
break|break;
case|case
name|CNLBL
case|:
name|ppsnlb
argument_list|()
expr_stmt|;
break|break;
case|case
name|CFORM
case|:
case|case
name|CINCLUD
case|:
name|ppnl
argument_list|()
expr_stmt|;
break|break;
case|case
name|CLMARG
case|:
name|ppnl
argument_list|()
expr_stmt|;
if|if
condition|(
name|profile
condition|)
name|ppid
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALIGN
case|:
name|ppnl
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
break|break;
case|case
name|CTRAIL
case|:
name|ppspac
argument_list|()
expr_stmt|;
break|break;
case|case
name|CRMARG
case|:
case|case
name|CSRMARG
case|:
name|pptab
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * One line of a multi-line comment  * Deal with alignment and initial white space trimming.  * The "margin" indicates where the first line of the  * comment began... don't print stuff in this comment  * which came before this.  */
end_comment

begin_macro
name|oneline
argument_list|(
argument|margin
argument_list|,
argument|cml
argument_list|)
end_macro

begin_decl_stmt
name|int
name|margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|commline
modifier|*
name|cml
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|8
operator|,
name|tp
operator|=
name|cml
operator|->
name|cmtext
init|;
name|i
operator|<
name|margin
operator|&&
operator|*
name|tp
condition|;
name|tp
operator|++
control|)
switch|switch
condition|(
operator|*
name|tp
condition|)
block|{
case|case
literal|' '
case|:
name|i
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
name|i
operator|+=
literal|8
expr_stmt|;
name|i
operator|&=
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|margin
condition|)
continue|continue;
name|ppop
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|ppid
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Flush all comments  */
end_comment

begin_macro
name|flushcm
argument_list|()
end_macro

begin_block
block|{
name|Seqid
operator|=
literal|32767
expr_stmt|;
return|return
operator|(
name|putcm
argument_list|()
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|BLANKS
value|((1<< CNL) | (1<< CNLBL) | (1<< CFORM))
end_define

begin_macro
name|noblank
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|i
operator|&
name|BLANKS
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|needform
decl_stmt|,
name|neednlbl
decl_stmt|,
name|neednl
decl_stmt|,
name|needseqid
decl_stmt|;
end_decl_stmt

begin_macro
name|needtree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|comment
modifier|*
name|cp
decl_stmt|;
name|needform
operator|=
name|neednlbl
operator|=
name|neednl
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|cmhp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
switch|switch
condition|(
name|cp
operator|->
name|cmjust
condition|)
block|{
case|case
name|CNL
case|:
name|neednl
operator|++
expr_stmt|;
goto|goto
name|seq
goto|;
case|case
name|CNLBL
case|:
name|neednlbl
operator|++
expr_stmt|;
goto|goto
name|seq
goto|;
case|case
name|CFORM
case|:
name|needform
operator|++
expr_stmt|;
name|seq
label|:
name|needseqid
operator|=
name|cp
operator|->
name|cmseqid
expr_stmt|;
break|break;
default|default:
name|neednl
operator|=
name|neednlbl
operator|=
name|needform
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|=
name|cp
operator|->
name|cmnext
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|!=
name|cmhp
condition|)
do|;
name|cmhp
operator|=
name|NIL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|packtree
argument_list|()
end_macro

begin_block
block|{
name|int
name|save
decl_stmt|;
name|save
operator|=
name|yyseqid
expr_stmt|;
name|yyseqid
operator|=
name|needseqid
expr_stmt|;
for|for
control|(
init|;
name|needform
operator|>
literal|0
condition|;
name|needform
operator|--
control|)
name|commform
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|neednl
operator|>
literal|0
condition|;
name|neednl
operator|--
control|)
name|commnl
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|neednlbl
operator|>
literal|0
condition|;
name|neednlbl
operator|--
control|)
name|commnlbl
argument_list|()
expr_stmt|;
name|yyseqid
operator|=
name|save
expr_stmt|;
block|}
end_block

end_unit

