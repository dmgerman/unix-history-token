begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)r1.c	1.3 (Berkeley) 8/11/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"r.h"
end_include

begin_define
define|#
directive|define
name|wasbreak
value|brkused[brkptr]==1 || brkused[brkptr]==3
end_define

begin_define
define|#
directive|define
name|wasnext
value|brkused[brkptr]==2 || brkused[brkptr]==3
end_define

begin_decl_stmt
name|int
name|transfer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if just finished retrun, break, next */
end_comment

begin_decl_stmt
name|char
name|fcname
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|scrat
index|[
literal|500
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brkptr
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brkstk
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* break label */
end_comment

begin_decl_stmt
name|int
name|typestk
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of loop construct */
end_comment

begin_decl_stmt
name|int
name|brkused
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loop contains BREAK or NEXT */
end_comment

begin_decl_stmt
name|int
name|forptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|forstk
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|repcode
argument_list|()
end_macro

begin_block
block|{
name|transfer
operator|=
literal|0
expr_stmt|;
name|outcont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putcom
argument_list|(
literal|"repeat"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|genlab
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|indent
operator|++
expr_stmt|;
name|outcont
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
operator|+
literal|1
expr_stmt|;
name|typestk
index|[
name|brkptr
index|]
operator|=
name|REPEAT
expr_stmt|;
name|brkused
index|[
name|brkptr
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|untils
argument_list|(
argument|p1
argument_list|,
argument|un
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|,
name|un
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outnum
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|un
operator|>
literal|0
condition|)
block|{
name|outcode
argument_list|(
literal|"if(.not."
argument_list|)
expr_stmt|;
name|balpar
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|transfer
operator|=
literal|0
expr_stmt|;
name|outgoto
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
if|if
condition|(
name|wasbreak
condition|)
name|outcont
argument_list|(
name|p1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|ifcode
argument_list|()
end_macro

begin_block
block|{
name|transfer
operator|=
literal|0
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|"if(.not."
argument_list|)
expr_stmt|;
name|balpar
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|yyval
operator|=
name|genlab
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|indent
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|elsecode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_block
block|{
name|outgoto
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
name|putcom
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent
operator|++
expr_stmt|;
name|outcont
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|whilecode
argument_list|()
end_macro

begin_block
block|{
name|transfer
operator|=
literal|0
expr_stmt|;
name|outcont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putcom
argument_list|(
literal|"while"
argument_list|)
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
operator|=
name|genlab
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|typestk
index|[
name|brkptr
index|]
operator|=
name|WHILE
expr_stmt|;
name|brkused
index|[
name|brkptr
index|]
operator|=
literal|0
expr_stmt|;
name|outnum
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|"if(.not."
argument_list|)
expr_stmt|;
name|balpar
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|yyval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|whilestat
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outgoto
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
name|putcom
argument_list|(
literal|"endwhile"
argument_list|)
expr_stmt|;
name|outcont
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|balpar
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
operator|,
name|lpar
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
block|{
name|error
argument_list|(
literal|"missing left paren"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|lpar
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|c
operator|=
name|gtok
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|lpar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|lpar
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|gtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
operator|&&
name|scrat
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"assigment inside conditional"
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lpar
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|lpar
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"missing parenthesis"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|labval
init|=
literal|23000
decl_stmt|;
end_decl_stmt

begin_macro
name|genlab
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|labval
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|labval
operator|-
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|gokcode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_block
block|{
name|transfer
operator|=
literal|0
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|eatup
argument_list|()
expr_stmt|;
name|outdon
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|eatup
argument_list|()
end_macro

begin_block
block|{
name|int
name|t
decl_stmt|,
name|lpar
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|lpar
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|gtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|==
literal|';'
operator|||
name|t
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|t
operator|==
literal|'{'
operator|||
name|t
operator|==
literal|'}'
operator|||
name|t
operator|==
name|EOF
condition|)
block|{
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|==
literal|','
operator|||
name|t
operator|==
literal|'+'
operator|||
name|t
operator|==
literal|'-'
operator|||
name|t
operator|==
literal|'*'
operator|||
name|t
operator|==
literal|'('
operator|||
name|t
operator|==
literal|'&'
operator|||
name|t
operator|==
literal|'|'
operator|||
name|t
operator|==
literal|'='
condition|)
block|{
while|while
condition|(
name|gtok
argument_list|(
name|temp
argument_list|)
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|pbstr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|'('
condition|)
name|lpar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|')'
condition|)
block|{
name|lpar
operator|--
expr_stmt|;
if|if
condition|(
name|lpar
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"missing left paren"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lpar
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|lpar
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"missing right paren"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|forcode
argument_list|()
end_macro

begin_block
block|{
name|int
name|lpar
decl_stmt|,
name|t
decl_stmt|;
name|char
modifier|*
name|ps
decl_stmt|,
modifier|*
name|qs
decl_stmt|;
name|transfer
operator|=
literal|0
expr_stmt|;
name|outcont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putcom
argument_list|(
literal|"for"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|genlab
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
operator|+
literal|1
expr_stmt|;
name|typestk
index|[
name|brkptr
index|]
operator|=
name|FOR
expr_stmt|;
name|brkused
index|[
name|brkptr
index|]
operator|=
literal|0
expr_stmt|;
name|forstk
index|[
name|forptr
operator|++
index|]
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|!=
literal|'('
condition|)
block|{
name|error
argument_list|(
literal|"missing left paren in FOR"
argument_list|)
expr_stmt|;
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|!=
literal|';'
condition|)
block|{
comment|/* real init clause */
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|eatup
argument_list|()
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"illegal FOR clause"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outdon
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|==
literal|';'
condition|)
comment|/* empty condition */
name|outcont
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* non-empty condition */
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outnum
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|"if(.not.("
argument_list|)
expr_stmt|;
for|for
control|(
name|lpar
operator|=
literal|0
init|;
name|lpar
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|==
literal|';'
condition|)
break|break;
if|if
condition|(
name|t
operator|==
literal|'('
condition|)
name|lpar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|')'
condition|)
block|{
name|lpar
operator|--
expr_stmt|;
if|if
condition|(
name|lpar
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"missing left paren in FOR clause"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|t
operator|!=
literal|'\n'
condition|)
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
block|}
name|outcode
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|yyval
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpar
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"invalid FOR clause"
argument_list|)
expr_stmt|;
block|}
name|ps
operator|=
name|scrat
expr_stmt|;
for|for
control|(
name|lpar
operator|=
literal|0
init|;
name|lpar
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|gtok
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
literal|'('
condition|)
name|lpar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|')'
condition|)
name|lpar
operator|--
expr_stmt|;
if|if
condition|(
name|lpar
operator|>=
literal|0
operator|&&
name|t
operator|!=
literal|'\n'
condition|)
while|while
condition|(
operator|*
name|ps
condition|)
name|ps
operator|++
expr_stmt|;
block|}
operator|*
name|ps
operator|=
literal|'\0'
expr_stmt|;
name|qs
operator|=
name|forstk
index|[
name|forptr
operator|-
literal|1
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|ps
operator|-
name|scrat
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|=
name|scrat
expr_stmt|;
while|while
condition|(
operator|*
name|qs
operator|++
operator|=
operator|*
name|ps
operator|++
condition|)
empty_stmt|;
name|indent
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|forstat
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|bp
operator|=
name|forstk
index|[
operator|--
name|forptr
index|]
expr_stmt|;
if|if
condition|(
name|wasnext
condition|)
block|{
name|outnum
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|transfer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nonblank
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|outdon
argument_list|()
expr_stmt|;
block|}
name|outgoto
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
name|putcom
argument_list|(
literal|"endfor"
argument_list|)
expr_stmt|;
name|outcont
argument_list|(
name|p1
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|bp
init|;
operator|*
name|q
operator|++
condition|;
control|)
empty_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|retcode
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'}'
condition|)
block|{
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
name|fcname
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|eatup
argument_list|()
expr_stmt|;
name|outdon
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|"return"
argument_list|)
expr_stmt|;
name|outdon
argument_list|()
expr_stmt|;
name|transfer
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|docode
argument_list|()
end_macro

begin_block
block|{
name|transfer
operator|=
literal|0
expr_stmt|;
name|outtab
argument_list|()
expr_stmt|;
name|outcode
argument_list|(
literal|"do "
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|genlab
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
expr_stmt|;
name|typestk
index|[
name|brkptr
index|]
operator|=
name|DO
expr_stmt|;
name|brkused
index|[
name|brkptr
index|]
operator|=
literal|0
expr_stmt|;
name|outnum
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|eatup
argument_list|()
expr_stmt|;
name|outdon
argument_list|()
expr_stmt|;
name|indent
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|dostat
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outcont
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
if|if
condition|(
name|wasbreak
condition|)
name|outcont
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|gcos
end_ifdef

begin_define
define|#
directive|define
name|atoi
parameter_list|(
name|s
parameter_list|)
value|(*s-'0')
end_define

begin_comment
comment|/* crude!!! */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|breakcode
argument_list|()
end_macro

begin_block
block|{
name|int
name|level
decl_stmt|,
name|t
decl_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|==
name|DIG
condition|)
name|level
operator|=
name|atoi
argument_list|(
name|scrat
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|!=
literal|';'
condition|)
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
if|if
condition|(
name|brkptr
operator|-
name|level
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"illegal BREAK"
argument_list|)
expr_stmt|;
else|else
block|{
name|outgoto
argument_list|(
name|brkstk
index|[
name|brkptr
operator|-
name|level
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|brkused
index|[
name|brkptr
operator|-
name|level
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|transfer
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|nextcode
argument_list|()
end_macro

begin_block
block|{
name|int
name|level
decl_stmt|,
name|t
decl_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|gnbtok
argument_list|(
name|scrat
argument_list|)
operator|)
operator|==
name|DIG
condition|)
name|level
operator|=
name|atoi
argument_list|(
name|scrat
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|!=
literal|';'
condition|)
name|pbstr
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
if|if
condition|(
name|brkptr
operator|-
name|level
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"illegal NEXT"
argument_list|)
expr_stmt|;
else|else
block|{
name|outgoto
argument_list|(
name|brkstk
index|[
name|brkptr
operator|-
name|level
index|]
argument_list|)
expr_stmt|;
name|brkused
index|[
name|brkptr
operator|-
name|level
index|]
operator||=
literal|2
expr_stmt|;
block|}
name|transfer
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|nonblank
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|errorflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|error
argument_list|(
argument|s1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|errorflag
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratfor:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error at line %d, file %s: "
argument_list|,
name|linect
index|[
name|infptr
index|]
argument_list|,
name|curfile
index|[
name|infptr
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errorflag
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|errcode
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|errorflag
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"******\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*****F ratfor:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"syntax error, line %d, file %s\n"
argument_list|,
name|linect
index|[
name|infptr
index|]
argument_list|,
name|curfile
index|[
name|infptr
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchr
argument_list|()
operator|)
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\0'
condition|)
name|putbak
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|errorflag
operator|=
literal|1
expr_stmt|;
block|}
end_block

end_unit

