begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *   * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)gen.c	5.2 (Berkeley) 6/18/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* gen - actual generation (writing) of flex scanners */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|gen_next_state
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|genecs
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|indent_put2s
name|PROTO
argument_list|(
operator|(
name|char
index|[]
operator|,
name|char
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|indent_puts
name|PROTO
argument_list|(
operator|(
name|char
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indent_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* each level is 4 spaces */
end_comment

begin_define
define|#
directive|define
name|indent_up
parameter_list|()
value|(++indent_level)
end_define

begin_define
define|#
directive|define
name|indent_down
parameter_list|()
value|(--indent_level)
end_define

begin_define
define|#
directive|define
name|set_indent
parameter_list|(
name|indent_val
parameter_list|)
value|indent_level = indent_val
end_define

begin_comment
comment|/* *everything* is done in terms of arrays starting at 1, so provide  * a null entry for the zero element of all C arrays  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|C_short_decl
index|[]
init|=
literal|"static const short int %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|C_long_decl
index|[]
init|=
literal|"static const long int %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|C_state_decl
index|[]
init|=
literal|"static const yy_state_type %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indent to the current level */
end_comment

begin_function
name|void
name|do_indent
parameter_list|()
block|{
specifier|register
name|int
name|i
init|=
name|indent_level
operator|*
literal|4
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|8
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* generate the code to keep backtracking information */
end_comment

begin_function
name|void
name|gen_backtracking
parameter_list|()
block|{
if|if
condition|(
name|reject
operator|||
name|num_backtracking
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fullspd
condition|)
name|indent_puts
argument_list|(
literal|"if ( yy_current_state[-1].yy_nxt )"
argument_list|)
expr_stmt|;
else|else
name|indent_puts
argument_list|(
literal|"if ( yy_accept[yy_current_state] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_last_accepting_state = yy_current_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_last_accepting_cpos = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate the code to perform the backtrack */
end_comment

begin_function
name|void
name|gen_bt_action
parameter_list|()
block|{
if|if
condition|(
name|reject
operator|||
name|num_backtracking
operator|==
literal|0
condition|)
return|return;
name|set_indent
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"case 0: /* must backtrack */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"/* undo the effects of YY_DO_BEFORE_ACTION */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*yy_cp = yy_hold_char;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos + 1;"
argument_list|)
expr_stmt|;
else|else
comment|/* backtracking info for compressed tables is taken \after/ 	 * yy_cp has been incremented for the next state 	 */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"goto yy_find_action;"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* genctbl - generates full speed compressed transition table  *  * synopsis  *     genctbl();  */
end_comment

begin_function
name|void
name|genctbl
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
comment|/* table of verify for transition and offset to next state */
name|printf
argument_list|(
literal|"static const struct yy_trans_info yy_transition[%d] =\n"
argument_list|,
name|tblend
operator|+
name|numecs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
comment|/* We want the transition to be represented as the offset to the      * next state, not the actual state number, which is what it currently is.      * The offset is base[nxt[i]] - base[chk[i]].  That's just the      * difference between the starting points of the two involved states      * (to - from).      *      * first, though, we need to find some way to put in our end-of-buffer      * flags and states.  We do this by making a state with absolutely no      * transitions.  We put it at the end of the table.      */
comment|/* at this point, we're guaranteed that there's enough room in nxt[]      * and chk[] to hold tblend + numecs entries.  We need just two slots.      * One for the action and one for the end-of-buffer transition.  We      * now *assume* that we're guaranteed the only character we'll try to      * index this nxt/chk pair with is EOB, i.e., 0, so we don't have to      * make sure there's room for jam entries for other characters.      */
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|=
name|tblend
operator|+
literal|2
expr_stmt|;
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|numecs
operator|+
literal|1
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* anything but EOB */
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* so that "make test" won't show arb. differences */
comment|/* make sure every state has a end-of-buffer transition and an action # */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|chk
index|[
name|base
index|[
name|i
index|]
index|]
operator|=
name|EOB_POSITION
expr_stmt|;
name|chk
index|[
name|base
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
name|ACTION_POSITION
expr_stmt|;
name|nxt
index|[
name|base
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
name|anum
expr_stmt|;
comment|/* action number */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|EOB_POSITION
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|-
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|ACTION_POSITION
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
name|nxt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|>
name|numecs
operator|||
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unused slot */
else|else
comment|/* verify, transition */
name|transition_struct_out
argument_list|(
name|chk
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|nxt
index|[
name|i
index|]
index|]
operator|-
operator|(
name|i
operator|-
name|chk
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* here's the final, end-of-buffer state */
name|transition_struct_out
argument_list|(
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
argument_list|,
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|transition_struct_out
argument_list|(
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
argument_list|,
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* table of pointers to start states */
name|printf
argument_list|(
literal|"static const struct yy_trans_info *yy_start_state_list[%d] =\n"
argument_list|,
name|lastsc
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastsc
operator|*
literal|2
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|"&yy_transition[%d],\n"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate equivalence-class tables */
end_comment

begin_function
name|void
name|genecs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
name|C_char_decl
index|[]
init|=
literal|"static const %s %s[%d] =\n    {   0,\n"
decl_stmt|;
name|int
name|numrows
decl_stmt|;
name|Char
name|clower
parameter_list|()
function_decl|;
if|if
condition|(
name|numecs
operator|<
name|csize
condition|)
name|printf
argument_list|(
name|C_char_decl
argument_list|,
literal|"YY_CHAR"
argument_list|,
literal|"yy_ec"
argument_list|,
name|csize
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|C_char_decl
argument_list|,
literal|"short"
argument_list|,
literal|"yy_ec"
argument_list|,
name|csize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|csize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|caseins
operator|&&
operator|(
name|i
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|i
operator|<=
literal|'Z'
operator|)
condition|)
name|ecgroup
index|[
name|i
index|]
operator|=
name|ecgroup
index|[
name|clower
argument_list|(
name|i
argument_list|)
index|]
expr_stmt|;
name|ecgroup
index|[
name|i
index|]
operator|=
name|abs
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mkdata
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|char
modifier|*
name|readable_form
parameter_list|()
function_decl|;
name|fputs
argument_list|(
literal|"\n\nEquivalence Classes:\n\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|numrows
operator|=
name|csize
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numrows
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|csize
condition|;
name|i
operator|=
name|i
operator|+
name|numrows
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%4s = %-2d"
argument_list|,
name|readable_form
argument_list|(
name|i
argument_list|)
argument_list|,
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* generate the code to find the action number */
end_comment

begin_function
name|void
name|gen_find_action
parameter_list|()
block|{
if|if
condition|(
name|fullspd
condition|)
name|indent_puts
argument_list|(
literal|"yy_act = yy_current_state[-1].yy_nxt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reject
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = *--yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_lp = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"find_rule: /* we branch to this label when backtracking */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"for ( ; ; ) /* until we find what rule we matched */"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_lp&& yy_lp< yy_accept[yy_current_state + 1] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act = yy_acclist[yy_lp];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_act& YY_TRAILING_HEAD_MASK ||"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"     yy_looking_for_trail_begin )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act == yy_looking_for_trail_begin )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_looking_for_trail_begin = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act&= ~YY_TRAILING_HEAD_MASK;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else if ( yy_act& YY_TRAILING_MASK )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_looking_for_trail_begin = yy_act& ~YY_TRAILING_MASK;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_reject
condition|)
block|{
comment|/* remember matched text in case we back up due to REJECT */
name|indent_puts
argument_list|(
literal|"yy_full_match = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_state = yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_lp = yy_lp;"
argument_list|)
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_match = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_state = yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_lp = yy_lp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yy_lp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"goto find_rule;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remember matched text in case we back up due to trailing context 	     * plus REJECT 	     */
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_match = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"--yy_cp;"
argument_list|)
expr_stmt|;
comment|/* we could consolidate the following two lines with those at 	 * the beginning, but at the cost of complaints that we're 	 * branching inside a loop 	 */
name|indent_puts
argument_list|(
literal|"yy_current_state = *--yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_lp = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* compressed */
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* genftbl - generates full transition table  *  * synopsis  *     genftbl();  */
end_comment

begin_function
name|void
name|genftbl
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|printf
argument_list|(
name|C_short_decl
argument_list|,
literal|"yy_accept"
argument_list|,
name|lastdfa
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|mkdata
argument_list|(
name|anum
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|&&
name|anum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state # %d accepts: [%d]\n"
argument_list|,
name|i
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
comment|/* don't have to dump the actual full table entries - they were created      * on-the-fly      */
block|}
end_function

begin_comment
comment|/* generate the code to find the next compressed-table state */
end_comment

begin_function
name|void
name|gen_next_compressed_state
parameter_list|(
name|char_map
parameter_list|)
name|char
modifier|*
name|char_map
decl_stmt|;
block|{
name|indent_put2s
argument_list|(
literal|"register YY_CHAR yy_c = %s;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
comment|/* save the backtracking info \before/ computing the next state      * because we always compute one more state than needed - we      * always proceed until we reach a jam state      */
name|gen_backtracking
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_def[yy_current_state];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* we've arrange it so that templates are never chained 	 * to one another.  This means we can afford make a 	 * very simple test to see if we need to convert to 	 * yy_c's meta-equivalence class without worrying 	 * about erroneously looking up the meta-equivalence 	 * class twice 	 */
name|do_indent
argument_list|()
expr_stmt|;
comment|/* lastdfa + 2 is the beginning of the templates */
name|printf
argument_list|(
literal|"if ( yy_current_state>= %d )\n"
argument_list|,
name|lastdfa
operator|+
literal|2
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_c = yy_meta[yy_c];"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate the code to find the next match */
end_comment

begin_function
name|void
name|gen_next_match
parameter_list|()
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_state() and      * gen_NUL_trans()      */
name|char
modifier|*
name|char_map
init|=
name|useecs
condition|?
literal|"yy_ec[*yy_cp]"
else|:
literal|"*yy_cp"
decl_stmt|;
name|char
modifier|*
name|char_map_2
init|=
name|useecs
condition|?
literal|"yy_ec[*++yy_cp]"
else|:
literal|"*++yy_cp"
decl_stmt|;
if|if
condition|(
name|fulltbl
condition|)
block|{
name|indent_put2s
argument_list|(
literal|"while ( (yy_current_state = yy_nxt[yy_current_state][%s])> 0 )"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backtracking
operator|>
literal|0
condition|)
block|{
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_backtracking
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"++yy_cp;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backtracking
operator|>
literal|0
condition|)
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = -yy_current_state;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
block|{
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"register const struct yy_trans_info *yy_trans_info;\n"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"register YY_CHAR yy_c;\n"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"for ( yy_c = %s;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"      (yy_trans_info =&yy_current_state[yy_c])->yy_verify == yy_c;"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"      yy_c = %s )"
argument_list|,
name|char_map_2
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backtracking
operator|>
literal|0
condition|)
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state += yy_trans_info->yy_nxt;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backtracking
operator|>
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|gen_backtracking
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* compressed */
name|indent_puts
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_next_state
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|printf
argument_list|(
literal|"while ( yy_base[yy_current_state] != %d );\n"
argument_list|,
name|jambase
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"while ( yy_current_state != %d );\n"
argument_list|,
name|jamstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reject
operator|&&
operator|!
name|interactive
condition|)
block|{
comment|/* do the guaranteed-needed backtrack to figure out the match */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* generate the code to find the next state */
end_comment

begin_function
name|void
name|gen_next_state
parameter_list|(
name|worry_about_NULs
parameter_list|)
name|int
name|worry_about_NULs
decl_stmt|;
block|{
comment|/* NOTE - changes in here should be reflected in get_next_match() */
name|char
name|char_map
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
operator|!
name|nultrans
condition|)
block|{
if|if
condition|(
name|useecs
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|char_map
argument_list|,
literal|"(*yy_cp ? yy_ec[*yy_cp] : %d)"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|char_map
argument_list|,
literal|"(*yy_cp ? *yy_cp : %d)"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|char_map
argument_list|,
name|useecs
condition|?
literal|"yy_ec[*yy_cp]"
else|:
literal|"*yy_cp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
name|nultrans
condition|)
block|{
if|if
condition|(
operator|!
name|fulltbl
operator|&&
operator|!
name|fullspd
condition|)
comment|/* compressed tables backtrack *before* they match */
name|gen_backtracking
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( *yy_cp )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fulltbl
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state][%s];"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state += yy_current_state[%s].yy_nxt;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
else|else
name|gen_next_compressed_state
argument_list|(
name|char_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
name|nultrans
condition|)
block|{
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_NUL_trans[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|gen_backtracking
argument_list|()
expr_stmt|;
if|if
condition|(
name|reject
condition|)
name|indent_puts
argument_list|(
literal|"*yy_state_ptr++ = yy_current_state;"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate the code to make a NUL transition */
end_comment

begin_function
name|void
name|gen_NUL_trans
parameter_list|()
block|{
comment|/* NOTE - changes in here should be reflected in get_next_match() */
name|int
name|need_backtracking
init|=
operator|(
name|num_backtracking
operator|>
literal|0
operator|&&
operator|!
name|reject
operator|)
decl_stmt|;
if|if
condition|(
name|need_backtracking
condition|)
comment|/* we'll need yy_cp lying around for the gen_backtracking() */
name|indent_puts
argument_list|(
literal|"register YY_CHAR *yy_cp = yy_c_buf_p;"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nultrans
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_NUL_trans[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_current_state == 0);"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fulltbl
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state][%d];\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_current_state<= 0);"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"register int yy_c = %d;\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"register const struct yy_trans_info *yy_trans_info;\n"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_trans_info =&yy_current_state[yy_c];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state += yy_trans_info->yy_nxt;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_trans_info->yy_verify != yy_c);"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|NUL_ec_str
index|[
literal|20
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|NUL_ec_str
argument_list|,
literal|"%d"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|gen_next_compressed_state
argument_list|(
name|NUL_ec_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
name|indent_puts
argument_list|(
literal|"*yy_state_ptr++ = yy_current_state;"
argument_list|)
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|printf
argument_list|(
literal|"yy_is_jam = (yy_base[yy_current_state] == %d);\n"
argument_list|,
name|jambase
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"yy_is_jam = (yy_current_state == %d);\n"
argument_list|,
name|jamstate
argument_list|)
expr_stmt|;
block|}
comment|/* if we've entered an accepting state, backtrack; note that      * compressed tables have *already* done such backtracking, so      * we needn't bother with it again      */
if|if
condition|(
name|need_backtracking
operator|&&
operator|(
name|fullspd
operator|||
name|fulltbl
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( ! yy_is_jam )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_backtracking
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* generate the code to find the start state */
end_comment

begin_function
name|void
name|gen_start_state
parameter_list|()
block|{
if|if
condition|(
name|fullspd
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state = yy_start_state_list[yy_start%s];"
argument_list|,
name|bol_needed
condition|?
literal|" + (yy_bp[-1] == '\\n' ? 1 : 0)"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_start;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_bp[-1] == '\\n' )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yy_current_state;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* set up for storing up states */
name|indent_puts
argument_list|(
literal|"yy_state_ptr = yy_state_buf;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*yy_state_ptr++ = yy_current_state;"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* gentabs - generate data statements for the transition tables  *  * synopsis  *    gentabs();  */
end_comment

begin_function
name|void
name|gentabs
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
modifier|*
name|accset
decl_stmt|,
name|nacc
decl_stmt|,
modifier|*
name|acc_array
decl_stmt|,
name|total_states
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
comment|/* *everything* is done in terms of arrays starting at 1, so provide      * a null entry for the zero element of all C arrays      */
specifier|static
name|char
name|C_char_decl
index|[]
init|=
literal|"static const YY_CHAR %s[%d] =\n    {   0,\n"
decl_stmt|;
name|acc_array
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|nummt
operator|=
literal|0
expr_stmt|;
comment|/* the compressed table format jams by entering the "jam state",      * losing information about the previous state in the process.      * In order to recover the previous state, we effectively need      * to keep backtracking information.      */
operator|++
name|num_backtracking
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* write out accepting list and pointer list 	 * 	 * first we generate the "yy_acclist" array.  In the process, we compute 	 * the indices that will go into the "yy_accept" array, and save the 	 * indices in the dfaacc array 	 */
name|int
name|EOB_accepting_list
index|[
literal|2
index|]
decl_stmt|;
comment|/* set up accepting structures for the End Of Buffer state */
name|EOB_accepting_list
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|EOB_accepting_list
index|[
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|accsiz
index|[
name|end_of_buffer_state
index|]
operator|=
literal|1
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_set
operator|=
name|EOB_accepting_list
expr_stmt|;
name|printf
argument_list|(
name|C_short_decl
argument_list|,
literal|"yy_acclist"
argument_list|,
name|max
argument_list|(
name|numas
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
comment|/* index into "yy_acclist" array */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|acc_array
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|accsiz
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|accset
operator|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_set
expr_stmt|;
name|nacc
operator|=
name|accsiz
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state # %d accepts: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|nacc
condition|;
operator|++
name|k
control|)
block|{
name|int
name|accnum
init|=
name|accset
index|[
name|k
index|]
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
operator|&&
operator|!
operator|(
name|accnum
operator|&
name|YY_TRAILING_HEAD_MASK
operator|)
operator|&&
name|accnum
operator|>
literal|0
operator|&&
name|rule_type
index|[
name|accnum
index|]
operator|==
name|RULE_VARIABLE
condition|)
block|{
comment|/* special hack to flag accepting number as part 			 * of trailing context rule 			 */
name|accnum
operator||=
name|YY_TRAILING_MASK
expr_stmt|;
block|}
name|mkdata
argument_list|(
name|accnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d]"
argument_list|,
name|accset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|nacc
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* add accepting number for the "jam" state */
name|acc_array
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
name|acc_array
index|[
name|i
index|]
operator|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
expr_stmt|;
comment|/* add accepting number for jam state */
name|acc_array
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* spit out "yy_accept" array.  If we're doing "reject", it'll be pointers      * into the "yy_acclist" array.  Otherwise it's actual accepting numbers.      * In either case, we just dump the numbers.      */
comment|/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays      * beginning at 0 and for "jam" state      */
name|k
operator|=
name|lastdfa
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|reject
condition|)
comment|/* we put a "cap" on the table associating lists of accepting 	 * numbers with state numbers.  This is needed because we tell 	 * where the end of an accepting list is by looking at where 	 * the list for the next state starts. 	 */
operator|++
name|k
expr_stmt|;
name|printf
argument_list|(
name|C_short_decl
argument_list|,
literal|"yy_accept"
argument_list|,
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reject
operator|&&
name|trace
operator|&&
name|acc_array
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state # %d accepts: [%d]\n"
argument_list|,
name|i
argument_list|,
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* add entry for "jam" state */
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
comment|/* add "cap" for the list */
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* write out meta-equivalence classes (used to index templates with) */
if|if
condition|(
name|trace
condition|)
name|fputs
argument_list|(
literal|"\n\nMeta-Equivalence Classes:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|C_char_decl
argument_list|,
literal|"yy_meta"
argument_list|,
name|numecs
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d = %d\n"
argument_list|,
name|i
argument_list|,
name|abs
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mkdata
argument_list|(
name|abs
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
block|}
name|total_states
operator|=
name|lastdfa
operator|+
name|numtemps
expr_stmt|;
name|printf
argument_list|(
name|tblend
operator|>
name|MAX_SHORT
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_base"
argument_list|,
name|total_states
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|int
name|d
init|=
name|def
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|base
index|[
name|i
index|]
operator|==
name|JAMSTATE
condition|)
name|base
index|[
name|i
index|]
operator|=
name|jambase
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|JAMSTATE
condition|)
name|def
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
comment|/* template reference */
operator|++
name|tmpuses
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|lastdfa
operator|-
name|d
operator|+
literal|1
expr_stmt|;
block|}
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* generate jam state's base index */
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
operator|++
name|i
comment|/* skip jam state */
init|;
name|i
operator|<=
name|total_states
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|tblend
operator|>
name|MAX_SHORT
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_def"
argument_list|,
name|total_states
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|total_states
condition|;
operator|++
name|i
control|)
name|mkdata
argument_list|(
name|def
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|lastdfa
operator|>
name|MAX_SHORT
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_nxt"
argument_list|,
name|tblend
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|nxt
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|nxt
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
comment|/* new state is the JAM state */
name|mkdata
argument_list|(
name|nxt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|lastdfa
operator|>
name|MAX_SHORT
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_chk"
argument_list|,
name|tblend
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
operator|++
name|nummt
expr_stmt|;
name|mkdata
argument_list|(
name|chk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write out a formatted string (with a secondary string argument) at the  * current indentation level, adding a final newline  */
end_comment

begin_decl_stmt
name|void
name|indent_put2s
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
name|char
name|fmt
index|[]
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* write out a string at the current indentation level, adding a final  * newline  */
end_comment

begin_function
name|void
name|indent_puts
parameter_list|(
name|str
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|puts
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make_tables - generate transition tables  *  * synopsis  *     make_tables();  *  * Generates transition tables and finishes generating output file  */
end_comment

begin_function
name|void
name|make_tables
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|did_eof_rule
init|=
name|false
decl_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* first, take care of YY_DO_BEFORE_ACTION depending on yymore being used */
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yytext -= yy_more_len; \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng = yy_cp - yytext; \\"
argument_list|)
expr_stmt|;
block|}
else|else
name|indent_puts
argument_list|(
literal|"yyleng = yy_cp - yy_bp; \\"
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"#define YY_END_OF_BUFFER %d\n"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
block|{
comment|/* need to define the transet type as a size large 	   * enough to hold the biggest offset 	   */
name|int
name|total_table_size
init|=
name|tblend
operator|+
name|numecs
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|trans_offset_type
init|=
name|total_table_size
operator|>
name|MAX_SHORT
condition|?
literal|"long"
else|:
literal|"short"
decl_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"struct yy_trans_info"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"short yy_verify;"
argument_list|)
expr_stmt|;
comment|/* in cases where its sister yy_verify *is* a "yes, there is a 	 * transition", yy_nxt is the offset (in records) to the next state. 	 * In most cases where there is no transition, the value of yy_nxt 	 * is irrelevant.  If yy_nxt is the -1th  record of a state, though, 	 * then yy_nxt is the action number for that state          */
name|indent_put2s
argument_list|(
literal|"%s yy_nxt;"
argument_list|,
name|trans_offset_type
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"typedef const struct yy_trans_info *yy_state_type;"
argument_list|)
expr_stmt|;
block|}
else|else
name|indent_puts
argument_list|(
literal|"typedef int yy_state_type;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
name|genctbl
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|fulltbl
condition|)
name|genftbl
argument_list|()
expr_stmt|;
else|else
name|gentabs
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backtracking
operator|>
literal|0
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static yy_state_type yy_last_accepting_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static YY_CHAR *yy_last_accepting_cpos;\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nultrans
condition|)
block|{
name|printf
argument_list|(
name|C_state_decl
argument_list|,
literal|"yy_NUL_trans"
argument_list|,
name|lastdfa
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fullspd
condition|)
block|{
if|if
condition|(
name|nultrans
condition|)
name|printf
argument_list|(
literal|"&yy_transition[%d],\n"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|mkdata
argument_list|(
name|nultrans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ddebug
condition|)
block|{
comment|/* spit out table mapping rules to line numbers */
name|indent_puts
argument_list|(
literal|"extern int yy_flex_debug;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"int yy_flex_debug = 1;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|C_short_decl
argument_list|,
literal|"yy_rule_linenum"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_rules
condition|;
operator|++
name|i
control|)
name|mkdata
argument_list|(
name|rule_linenum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* declare state buffer variables */
name|puts
argument_list|(
literal|"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"static YY_CHAR *yy_full_match;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"static int yy_lp;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|puts
argument_list|(
literal|"static int yy_looking_for_trail_begin = 0;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"static int yy_full_lp;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"static int *yy_full_state;"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define YY_TRAILING_MASK 0x%x\n"
argument_list|,
name|YY_TRAILING_MASK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define YY_TRAILING_HEAD_MASK 0x%x\n"
argument_list|,
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"#define REJECT \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"{ \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|puts
argument_list|(
literal|"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"yy_state_ptr = yy_full_state; /* restore orig. state */ \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"++yy_lp; \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"goto find_rule; \\"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|puts
argument_list|(
literal|"/* the intent behind this definition is that it'll catch"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|" * any uses of REJECT which flex missed"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|" */"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define REJECT reject_used_but_not_detected"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yymore_used
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static int yy_more_flag = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static int yy_doing_yy_more = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static int yy_more_len = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define yymore() { yy_more_flag = 1; }"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ (yy_doing_yy_more ? yy_more_len : 0)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() yymore_used_but_not_detected"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ 0"
argument_list|)
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|temp_action_file
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when writing temporary action file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|temp_action_file
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when closing temporary action file"
argument_list|)
expr_stmt|;
name|temp_action_file
operator|=
name|fopen
argument_list|(
name|action_file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_action_file
operator|==
name|NULL
condition|)
name|flexfatal
argument_list|(
literal|"could not re-open temporary action file"
argument_list|)
expr_stmt|;
comment|/* copy prolog from action_file to output file */
name|action_out
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_doing_yy_more = yy_more_flag;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_doing_yy_more )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_more_len = yyleng;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_more_flag = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
name|gen_start_state
argument_list|()
expr_stmt|;
comment|/* note, don't use any indentation */
name|puts
argument_list|(
literal|"yy_match:"
argument_list|)
expr_stmt|;
name|gen_next_match
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|gen_find_action
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_flex_debug )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act == 0 )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--scanner backtracking\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"else if ( yy_act< %d )\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\","
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         yy_rule_linenum[yy_act], yytext );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"else if ( yy_act == %d )\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\","
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         yytext );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"else if ( yy_act == %d )\n"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"else\n"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--EOF\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
comment|/* copy actions from action_file to output file */
name|skelout
argument_list|()
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|gen_bt_action
argument_list|()
expr_stmt|;
name|action_out
argument_list|()
expr_stmt|;
comment|/* generate cases for any missing EOF rules */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sceof
index|[
name|i
index|]
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"case YY_STATE_EOF(%s):\n"
argument_list|,
name|scname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|did_eof_rule
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|did_eof_rule
condition|)
block|{
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyterminate();"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
comment|/* generate code for handling NUL's, if needed */
comment|/* first, deal with backtracking and setting up yy_cp if the scanner      * finds that it should JAM on the NUL      */
name|skelout
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_cp = yy_c_buf_p;"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* compressed table */
if|if
condition|(
operator|!
name|reject
operator|&&
operator|!
name|interactive
condition|)
block|{
comment|/* do the guaranteed-needed backtrack to figure out the match */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* generate code for yy_get_previous_state() */
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
name|indent_puts
argument_list|(
literal|"register YY_CHAR *yy_bp = yytext;\n"
argument_list|)
expr_stmt|;
name|gen_start_state
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|gen_next_state
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|gen_NUL_trans
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* copy remainder of input to output */
name|line_directive_out
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|flexscan
argument_list|()
expr_stmt|;
comment|/* copy remainder of input to output */
block|}
end_function

end_unit

