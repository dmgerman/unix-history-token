begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *   * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)nfa.c	5.2 (Berkeley) 6/18/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* nfa - NFA construction routines */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|int
name|dupmachine
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|mkxtion
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add_accept - add an accepting state to a machine  *  * synopsis  *  *   add_accept( mach, accepting_number );  *  * accepting_number becomes mach's accepting number.  */
end_comment

begin_function
name|void
name|add_accept
parameter_list|(
name|mach
parameter_list|,
name|accepting_number
parameter_list|)
name|int
name|mach
decl_stmt|,
name|accepting_number
decl_stmt|;
block|{
comment|/* hang the accepting number off an epsilon state.  if it is associated      * with a state that has a non-epsilon out-transition, then the state      * will accept BEFORE it makes that transition, i.e., one character      * too soon      */
if|if
condition|(
name|transchar
index|[
name|finalst
index|[
name|mach
index|]
index|]
operator|==
name|SYM_EPSILON
condition|)
name|accptnum
index|[
name|finalst
index|[
name|mach
index|]
index|]
operator|=
name|accepting_number
expr_stmt|;
else|else
block|{
name|int
name|astate
init|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
decl_stmt|;
name|accptnum
index|[
name|astate
index|]
operator|=
name|accepting_number
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|astate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copysingl - make a given number of copies of a singleton machine  *  * synopsis  *  *   newsng = copysingl( singl, num );  *  *     newsng - a new singleton composed of num copies of singl  *     singl  - a singleton machine  *     num    - the number of copies of singl to be present in newsng  */
end_comment

begin_function
name|int
name|copysingl
parameter_list|(
name|singl
parameter_list|,
name|num
parameter_list|)
name|int
name|singl
decl_stmt|,
name|num
decl_stmt|;
block|{
name|int
name|copy
decl_stmt|,
name|i
decl_stmt|;
name|copy
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num
condition|;
operator|++
name|i
control|)
name|copy
operator|=
name|link_machines
argument_list|(
name|copy
argument_list|,
name|dupmachine
argument_list|(
name|singl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* dumpnfa - debugging routine to write out an nfa  *  * synopsis  *    int state1;  *    dumpnfa( state1 );  */
end_comment

begin_function
name|void
name|dumpnfa
parameter_list|(
name|state1
parameter_list|)
name|int
name|state1
decl_stmt|;
block|{
name|int
name|sym
decl_stmt|,
name|tsp1
decl_stmt|,
name|tsp2
decl_stmt|,
name|anum
decl_stmt|,
name|ns
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n********** beginning dump of nfa with start state %d\n"
argument_list|,
name|state1
argument_list|)
expr_stmt|;
comment|/* we probably should loop starting at firstst[state1] and going to      * lastst[state1], but they're not maintained properly when we "or"      * all of the rules together.  So we use our knowledge that the machine      * starts at state 1 and ends at lastnfa.      */
comment|/* for ( ns = firstst[state1]; ns<= lastst[state1]; ++ns ) */
for|for
control|(
name|ns
operator|=
literal|1
init|;
name|ns
operator|<=
name|lastnfa
condition|;
operator|++
name|ns
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state # %4d\t"
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|sym
operator|=
name|transchar
index|[
name|ns
index|]
expr_stmt|;
name|tsp1
operator|=
name|trans1
index|[
name|ns
index|]
expr_stmt|;
name|tsp2
operator|=
name|trans2
index|[
name|ns
index|]
expr_stmt|;
name|anum
operator|=
name|accptnum
index|[
name|ns
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d:  %4d, %4d"
argument_list|,
name|sym
argument_list|,
name|tsp1
argument_list|,
name|tsp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  [%d]"
argument_list|,
name|anum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"********** end of dump\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dupmachine - make a duplicate of a given machine  *  * synopsis  *  *   copy = dupmachine( mach );  *  *     copy - holds duplicate of mach  *     mach - machine to be duplicated  *  * note that the copy of mach is NOT an exact duplicate; rather, all the  * transition states values are adjusted so that the copy is self-contained,  * as the original should have been.  *  * also note that the original MUST be contiguous, with its low and high  * states accessible by the arrays firstst and lastst  */
end_comment

begin_function
name|int
name|dupmachine
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|init
decl_stmt|,
name|state_offset
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
name|lastst
index|[
name|mach
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|firstst
index|[
name|mach
index|]
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
block|{
name|state
operator|=
name|mkstate
argument_list|(
name|transchar
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans1
index|[
name|i
index|]
operator|!=
name|NO_TRANSITION
condition|)
block|{
name|mkxtion
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|,
name|trans1
index|[
name|i
index|]
operator|+
name|state
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|transchar
index|[
name|i
index|]
operator|==
name|SYM_EPSILON
operator|&&
name|trans2
index|[
name|i
index|]
operator|!=
name|NO_TRANSITION
condition|)
name|mkxtion
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|,
name|trans2
index|[
name|i
index|]
operator|+
name|state
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
name|accptnum
index|[
name|state
index|]
operator|=
name|accptnum
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
literal|0
condition|)
name|flexfatal
argument_list|(
literal|"empty machine in dupmachine()"
argument_list|)
expr_stmt|;
name|state_offset
operator|=
name|state
operator|-
name|i
operator|+
literal|1
expr_stmt|;
name|init
operator|=
name|mach
operator|+
name|state_offset
expr_stmt|;
name|firstst
index|[
name|init
index|]
operator|=
name|firstst
index|[
name|mach
index|]
operator|+
name|state_offset
expr_stmt|;
name|finalst
index|[
name|init
index|]
operator|=
name|finalst
index|[
name|mach
index|]
operator|+
name|state_offset
expr_stmt|;
name|lastst
index|[
name|init
index|]
operator|=
name|lastst
index|[
name|mach
index|]
operator|+
name|state_offset
expr_stmt|;
return|return
operator|(
name|init
operator|)
return|;
block|}
end_function

begin_comment
comment|/* finish_rule - finish up the processing for a rule  *  * synopsis  *  *   finish_rule( mach, variable_trail_rule, headcnt, trailcnt );  *  * An accepting number is added to the given machine.  If variable_trail_rule  * is true then the rule has trailing context and both the head and trail  * are variable size.  Otherwise if headcnt or trailcnt is non-zero then  * the machine recognizes a pattern with trailing context and headcnt is  * the number of characters in the matched part of the pattern, or zero  * if the matched part has variable length.  trailcnt is the number of  * trailing context characters in the pattern, or zero if the trailing  * context has variable length.  */
end_comment

begin_function
name|void
name|finish_rule
parameter_list|(
name|mach
parameter_list|,
name|variable_trail_rule
parameter_list|,
name|headcnt
parameter_list|,
name|trailcnt
parameter_list|)
name|int
name|mach
decl_stmt|,
name|variable_trail_rule
decl_stmt|,
name|headcnt
decl_stmt|,
name|trailcnt
decl_stmt|;
block|{
name|add_accept
argument_list|(
name|mach
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
comment|/* we did this in new_rule(), but it often gets the wrong      * number because we do it before we start parsing the current rule      */
name|rule_linenum
index|[
name|num_rules
index|]
operator|=
name|linenum
expr_stmt|;
comment|/* if this is a continued action, then the line-number has      * already been updated, giving us the wrong number      */
if|if
condition|(
name|continued_action
condition|)
operator|--
name|rule_linenum
index|[
name|num_rules
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|temp_action_file
argument_list|,
literal|"case %d:\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trail_rule
condition|)
block|{
name|rule_type
index|[
name|num_rules
index|]
operator|=
name|RULE_VARIABLE
expr_stmt|;
if|if
condition|(
name|performance_report
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable trailing context rule at line %d\n"
argument_list|,
name|rule_linenum
index|[
name|num_rules
index|]
argument_list|)
expr_stmt|;
name|variable_trailing_context_rules
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|rule_type
index|[
name|num_rules
index|]
operator|=
name|RULE_NORMAL
expr_stmt|;
if|if
condition|(
name|headcnt
operator|>
literal|0
operator|||
name|trailcnt
operator|>
literal|0
condition|)
block|{
comment|/* do trailing context magic to not match the trailing characters */
name|char
modifier|*
name|scanner_cp
init|=
literal|"yy_c_buf_p = yy_cp"
decl_stmt|;
name|char
modifier|*
name|scanner_bp
init|=
literal|"yy_bp"
decl_stmt|;
name|fprintf
argument_list|(
name|temp_action_file
argument_list|,
literal|"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|headcnt
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|temp_action_file
argument_list|,
literal|"%s = %s + %d;\n"
argument_list|,
name|scanner_cp
argument_list|,
name|scanner_bp
argument_list|,
name|headcnt
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|temp_action_file
argument_list|,
literal|"%s -= %d;\n"
argument_list|,
name|scanner_cp
argument_list|,
name|trailcnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|temp_action_file
argument_list|,
literal|"YY_DO_BEFORE_ACTION; /* set up yytext again */\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|line_directive_out
argument_list|(
name|temp_action_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* link_machines - connect two machines together  *  * synopsis  *  *   new = link_machines( first, last );  *  *     new    - a machine constructed by connecting first to last  *     first  - the machine whose successor is to be last  *     last   - the machine whose predecessor is to be first  *  * note: this routine concatenates the machine first with the machine  *  last to produce a machine new which will pattern-match first first  *  and then last, and will fail if either of the sub-patterns fails.  *  FIRST is set to new by the operation.  last is unmolested.  */
end_comment

begin_function
name|int
name|link_machines
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
if|if
condition|(
name|first
operator|==
name|NIL
condition|)
return|return
operator|(
name|last
operator|)
return|;
elseif|else
if|if
condition|(
name|last
operator|==
name|NIL
condition|)
return|return
operator|(
name|first
operator|)
return|;
else|else
block|{
name|mkxtion
argument_list|(
name|finalst
index|[
name|first
index|]
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|finalst
index|[
name|first
index|]
operator|=
name|finalst
index|[
name|last
index|]
expr_stmt|;
name|lastst
index|[
name|first
index|]
operator|=
name|max
argument_list|(
name|lastst
index|[
name|first
index|]
argument_list|,
name|lastst
index|[
name|last
index|]
argument_list|)
expr_stmt|;
name|firstst
index|[
name|first
index|]
operator|=
name|min
argument_list|(
name|firstst
index|[
name|first
index|]
argument_list|,
name|firstst
index|[
name|last
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* mark_beginning_as_normal - mark each "beginning" state in a machine  *                            as being a "normal" (i.e., not trailing context-  *                            associated) states  *  * synopsis  *  *   mark_beginning_as_normal( mach )  *  *     mach - machine to mark  *  * The "beginning" states are the epsilon closure of the first state  */
end_comment

begin_function
name|void
name|mark_beginning_as_normal
parameter_list|(
name|mach
parameter_list|)
specifier|register
name|int
name|mach
decl_stmt|;
block|{
switch|switch
condition|(
name|state_type
index|[
name|mach
index|]
condition|)
block|{
case|case
name|STATE_NORMAL
case|:
comment|/* oh, we've already visited here */
return|return;
case|case
name|STATE_TRAILING_CONTEXT
case|:
name|state_type
index|[
name|mach
index|]
operator|=
name|STATE_NORMAL
expr_stmt|;
if|if
condition|(
name|transchar
index|[
name|mach
index|]
operator|==
name|SYM_EPSILON
condition|)
block|{
if|if
condition|(
name|trans1
index|[
name|mach
index|]
operator|!=
name|NO_TRANSITION
condition|)
name|mark_beginning_as_normal
argument_list|(
name|trans1
index|[
name|mach
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans2
index|[
name|mach
index|]
operator|!=
name|NO_TRANSITION
condition|)
name|mark_beginning_as_normal
argument_list|(
name|trans2
index|[
name|mach
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|flexerror
argument_list|(
literal|"bad state type in mark_beginning_as_normal()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* mkbranch - make a machine that branches to two machines  *  * synopsis  *  *   branch = mkbranch( first, second );  *  *     branch - a machine which matches either first's pattern or second's  *     first, second - machines whose patterns are to be or'ed (the | operator)  *  * note that first and second are NEITHER destroyed by the operation.  Also,  * the resulting machine CANNOT be used with any other "mk" operation except  * more mkbranch's.  Compare with mkor()  */
end_comment

begin_function
name|int
name|mkbranch
parameter_list|(
name|first
parameter_list|,
name|second
parameter_list|)
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|NO_TRANSITION
condition|)
return|return
operator|(
name|second
operator|)
return|;
elseif|else
if|if
condition|(
name|second
operator|==
name|NO_TRANSITION
condition|)
return|return
operator|(
name|first
operator|)
return|;
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|eps
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|eps
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
operator|(
name|eps
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkclos - convert a machine into a closure  *  * synopsis  *   new = mkclos( state );  *  *     new - a new state which matches the closure of "state"  */
end_comment

begin_function
name|int
name|mkclos
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
return|return
operator|(
name|mkopt
argument_list|(
name|mkposcl
argument_list|(
name|state
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkopt - make a machine optional  *  * synopsis  *  *   new = mkopt( mach );  *  *     new  - a machine which optionally matches whatever mach matched  *     mach - the machine to make optional  *  * notes:  *     1. mach must be the last machine created  *     2. mach is destroyed by the call  */
end_comment

begin_function
name|int
name|mkopt
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|;
if|if
condition|(
operator|!
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|mach
index|]
argument_list|)
condition|)
block|{
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|eps
argument_list|)
expr_stmt|;
block|}
comment|/* can't skimp on the following if FREE_EPSILON(mach) is true because      * some state interior to "mach" might point back to the beginning      * for a closure      */
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|eps
argument_list|,
name|mach
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|mach
argument_list|,
name|finalst
index|[
name|mach
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|mach
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkor - make a machine that matches either one of two machines  *  * synopsis  *  *   new = mkor( first, second );  *  *     new - a machine which matches either first's pattern or second's  *     first, second - machines whose patterns are to be or'ed (the | operator)  *  * note that first and second are both destroyed by the operation  * the code is rather convoluted because an attempt is made to minimize  * the number of epsilon states needed  */
end_comment

begin_function
name|int
name|mkor
parameter_list|(
name|first
parameter_list|,
name|second
parameter_list|)
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|,
name|orend
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|NIL
condition|)
return|return
operator|(
name|second
operator|)
return|;
elseif|else
if|if
condition|(
name|second
operator|==
name|NIL
condition|)
return|return
operator|(
name|first
operator|)
return|;
else|else
block|{
comment|/* see comment in mkopt() about why we can't use the first state 	 * of "first" or "second" if they satisfy "FREE_EPSILON" 	 */
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|first
operator|=
name|link_machines
argument_list|(
name|eps
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|first
index|]
argument_list|)
operator|&&
name|accptnum
index|[
name|finalst
index|[
name|first
index|]
index|]
operator|==
name|NIL
condition|)
block|{
name|orend
operator|=
name|finalst
index|[
name|first
index|]
expr_stmt|;
name|mkxtion
argument_list|(
name|finalst
index|[
name|second
index|]
argument_list|,
name|orend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|second
index|]
argument_list|)
operator|&&
name|accptnum
index|[
name|finalst
index|[
name|second
index|]
index|]
operator|==
name|NIL
condition|)
block|{
name|orend
operator|=
name|finalst
index|[
name|second
index|]
expr_stmt|;
name|mkxtion
argument_list|(
name|finalst
index|[
name|first
index|]
argument_list|,
name|orend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|first
operator|=
name|link_machines
argument_list|(
name|first
argument_list|,
name|eps
argument_list|)
expr_stmt|;
name|orend
operator|=
name|finalst
index|[
name|first
index|]
expr_stmt|;
name|mkxtion
argument_list|(
name|finalst
index|[
name|second
index|]
argument_list|,
name|orend
argument_list|)
expr_stmt|;
block|}
block|}
name|finalst
index|[
name|first
index|]
operator|=
name|orend
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkposcl - convert a machine into a positive closure  *  * synopsis  *   new = mkposcl( state );  *  *    new - a machine matching the positive closure of "state"  */
end_comment

begin_function
name|int
name|mkposcl
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|;
if|if
condition|(
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|)
condition|)
block|{
name|mkxtion
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
else|else
block|{
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|eps
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|link_machines
argument_list|(
name|state
argument_list|,
name|eps
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* mkrep - make a replicated machine  *  * synopsis  *   new = mkrep( mach, lb, ub );  *  *    new - a machine that matches whatever "mach" matched from "lb"  *          number of times to "ub" number of times  *  * note  *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"  */
end_comment

begin_function
name|int
name|mkrep
parameter_list|(
name|mach
parameter_list|,
name|lb
parameter_list|,
name|ub
parameter_list|)
name|int
name|mach
decl_stmt|,
name|lb
decl_stmt|,
name|ub
decl_stmt|;
block|{
name|int
name|base_mach
decl_stmt|,
name|tail
decl_stmt|,
name|copy
decl_stmt|,
name|i
decl_stmt|;
name|base_mach
operator|=
name|copysingl
argument_list|(
name|mach
argument_list|,
name|lb
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ub
operator|==
name|INFINITY
condition|)
block|{
name|copy
operator|=
name|dupmachine
argument_list|(
name|mach
argument_list|)
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|link_machines
argument_list|(
name|base_mach
argument_list|,
name|mkclos
argument_list|(
name|copy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lb
init|;
name|i
operator|<
name|ub
condition|;
operator|++
name|i
control|)
block|{
name|copy
operator|=
name|dupmachine
argument_list|(
name|mach
argument_list|)
expr_stmt|;
name|tail
operator|=
name|mkopt
argument_list|(
name|link_machines
argument_list|(
name|copy
argument_list|,
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|link_machines
argument_list|(
name|base_mach
argument_list|,
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mach
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkstate - create a state with a transition on a given symbol  *  * synopsis  *  *   state = mkstate( sym );  *  *     state - a new state matching sym  *     sym   - the symbol the new state is to have an out-transition on  *  * note that this routine makes new states in ascending order through the  * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE  * relies on machines being made in ascending order and that they are  * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge  * that it admittedly is)  */
end_comment

begin_function
name|int
name|mkstate
parameter_list|(
name|sym
parameter_list|)
name|int
name|sym
decl_stmt|;
block|{
if|if
condition|(
operator|++
name|lastnfa
operator|>=
name|current_mns
condition|)
block|{
if|if
condition|(
operator|(
name|current_mns
operator|+=
name|MNS_INCREMENT
operator|)
operator|>=
name|MAXIMUM_MNS
condition|)
name|lerrif
argument_list|(
literal|"input rules are too complicated (>= %d NFA states)"
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
operator|++
name|num_reallocs
expr_stmt|;
name|firstst
operator|=
name|reallocate_integer_array
argument_list|(
name|firstst
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|lastst
operator|=
name|reallocate_integer_array
argument_list|(
name|lastst
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|finalst
operator|=
name|reallocate_integer_array
argument_list|(
name|finalst
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|transchar
operator|=
name|reallocate_integer_array
argument_list|(
name|transchar
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|trans1
operator|=
name|reallocate_integer_array
argument_list|(
name|trans1
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|trans2
operator|=
name|reallocate_integer_array
argument_list|(
name|trans2
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|accptnum
operator|=
name|reallocate_integer_array
argument_list|(
name|accptnum
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|assoc_rule
operator|=
name|reallocate_integer_array
argument_list|(
name|assoc_rule
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|state_type
operator|=
name|reallocate_integer_array
argument_list|(
name|state_type
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
block|}
name|firstst
index|[
name|lastnfa
index|]
operator|=
name|lastnfa
expr_stmt|;
name|finalst
index|[
name|lastnfa
index|]
operator|=
name|lastnfa
expr_stmt|;
name|lastst
index|[
name|lastnfa
index|]
operator|=
name|lastnfa
expr_stmt|;
name|transchar
index|[
name|lastnfa
index|]
operator|=
name|sym
expr_stmt|;
name|trans1
index|[
name|lastnfa
index|]
operator|=
name|NO_TRANSITION
expr_stmt|;
name|trans2
index|[
name|lastnfa
index|]
operator|=
name|NO_TRANSITION
expr_stmt|;
name|accptnum
index|[
name|lastnfa
index|]
operator|=
name|NIL
expr_stmt|;
name|assoc_rule
index|[
name|lastnfa
index|]
operator|=
name|num_rules
expr_stmt|;
name|state_type
index|[
name|lastnfa
index|]
operator|=
name|current_state_type
expr_stmt|;
comment|/* fix up equivalence classes base on this transition.  Note that any      * character which has its own transition gets its own equivalence class.      * Thus only characters which are only in character classes have a chance      * at being in the same equivalence class.  E.g. "a|b" puts 'a' and 'b'      * into two different equivalence classes.  "[ab]" puts them in the same      * equivalence class (barring other differences elsewhere in the input).      */
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
comment|/* we don't have to update the equivalence classes since that was 	 * already done when the ccl was created for the first time 	 */
block|}
elseif|else
if|if
condition|(
name|sym
operator|==
name|SYM_EPSILON
condition|)
operator|++
name|numeps
expr_stmt|;
else|else
block|{
if|if
condition|(
name|useecs
condition|)
comment|/* map NUL's to csize */
name|mkechar
argument_list|(
name|sym
condition|?
name|sym
else|:
name|csize
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lastnfa
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkxtion - make a transition from one state to another  *  * synopsis  *  *   mkxtion( statefrom, stateto );  *  *     statefrom - the state from which the transition is to be made  *     stateto   - the state to which the transition is to be made  */
end_comment

begin_function
name|void
name|mkxtion
parameter_list|(
name|statefrom
parameter_list|,
name|stateto
parameter_list|)
name|int
name|statefrom
decl_stmt|,
name|stateto
decl_stmt|;
block|{
if|if
condition|(
name|trans1
index|[
name|statefrom
index|]
operator|==
name|NO_TRANSITION
condition|)
name|trans1
index|[
name|statefrom
index|]
operator|=
name|stateto
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|transchar
index|[
name|statefrom
index|]
operator|!=
name|SYM_EPSILON
operator|)
operator|||
operator|(
name|trans2
index|[
name|statefrom
index|]
operator|!=
name|NO_TRANSITION
operator|)
condition|)
name|flexfatal
argument_list|(
literal|"found too many transitions in mkxtion()"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* second out-transition for an epsilon state */
operator|++
name|eps2
expr_stmt|;
name|trans2
index|[
name|statefrom
index|]
operator|=
name|stateto
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* new_rule - initialize for a new rule  *  * synopsis  *  *   new_rule();  *  * the global num_rules is incremented and the any corresponding dynamic  * arrays (such as rule_type[]) are grown as needed.  */
end_comment

begin_function
name|void
name|new_rule
parameter_list|()
block|{
if|if
condition|(
operator|++
name|num_rules
operator|>=
name|current_max_rules
condition|)
block|{
operator|++
name|num_reallocs
expr_stmt|;
name|current_max_rules
operator|+=
name|MAX_RULES_INCREMENT
expr_stmt|;
name|rule_type
operator|=
name|reallocate_integer_array
argument_list|(
name|rule_type
argument_list|,
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_linenum
operator|=
name|reallocate_integer_array
argument_list|(
name|rule_linenum
argument_list|,
name|current_max_rules
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_rules
operator|>
name|MAX_RULE
condition|)
name|lerrif
argument_list|(
literal|"too many rules (> %d)!"
argument_list|,
name|MAX_RULE
argument_list|)
expr_stmt|;
name|rule_linenum
index|[
name|num_rules
index|]
operator|=
name|linenum
expr_stmt|;
block|}
end_function

end_unit

