begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Source: /usr/src/kerberosIV/krb/RCS/rd_req.c,v $  * $Author: sklower $  *  * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_rd_req_c
init|=
literal|"$Header: /usr/src/kerberosIV/krb/RCS/rd_req.c,v 4.18 1995/02/25 03:57:21 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|<mit-copyright.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|krb_ap_req_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|t_local
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keep the following information around for subsequent calls  * to this routine by the same server using the same key.  */
end_comment

begin_decl_stmt
specifier|static
name|Key_schedule
name|serv_key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Key sched to decrypt ticket */
end_comment

begin_decl_stmt
specifier|static
name|C_Block
name|ky
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization vector */
end_comment

begin_decl_stmt
specifier|static
name|int
name|st_kvno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version number for this key */
end_comment

begin_decl_stmt
specifier|static
name|char
name|st_rlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server's realm */
end_comment

begin_decl_stmt
specifier|static
name|char
name|st_nam
index|[
name|ANAME_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* service name */
end_comment

begin_decl_stmt
specifier|static
name|char
name|st_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server's instance */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_multihome
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This file contains two functions.  krb_set_key() takes a DES  * key or password string and returns a DES key (either the original  * key, or the password converted into a DES key) and a key schedule  * for it.  *  * krb_rd_req() reads an authentication request and returns information  * about the identity of the requestor, or an indication that the  * identity information was not authentic.  */
end_comment

begin_comment
comment|/*  * krb_set_key() takes as its first argument either a DES key or a  * password string.  The "cvt" argument indicates how the first  * argument "key" is to be interpreted: if "cvt" is null, "key" is  * taken to be a DES key; if "cvt" is non-null, "key" is taken to  * be a password string, and is converted into a DES key using  * string_to_key().  In either case, the resulting key is returned  * in the external static variable "ky".  A key schedule is  * generated for "ky" and returned in the external static variable  * "serv_key".  *  * This routine returns the return value of des_key_sched.  *  * krb_set_key() needs to be in the same .o file as krb_rd_req() so that  * the key set by krb_set_key() is available in private storage for  * krb_rd_req().  */
end_comment

begin_function
name|int
name|krb_set_key
parameter_list|(
name|key
parameter_list|,
name|cvt
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|cvt
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|bzero
argument_list|(
name|ky
argument_list|,
sizeof|sizeof
argument_list|(
name|ky
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|KSUCCESS
return|;
else|#
directive|else
comment|/* Encrypt */
if|if
condition|(
name|cvt
condition|)
name|string_to_key
argument_list|(
name|key
argument_list|,
name|ky
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ky
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|des_key_sched
argument_list|(
name|ky
argument_list|,
name|serv_key
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOENCRYPTION */
block|}
end_function

begin_comment
comment|/*  * check_multihome() takes as arguments the network address of the  * originating host and the network address extracted from the ticket.  * It uses the first address to get a list of all possible addresses for  * the originating host, and then compares the tkt_addr to each in hope  * of finding a match.  *  * This routine returns 0 if a match was found, -1 otherwise.  *  */
end_comment

begin_function
specifier|static
name|int
name|check_multihome
parameter_list|(
name|from_addr
parameter_list|,
name|tkt_addr
parameter_list|)
name|u_int32_t
name|from_addr
decl_stmt|;
comment|/* Net address of originating host */
name|u_int32_t
name|tkt_addr
decl_stmt|;
comment|/* Address extracted from ticket */
block|{
name|struct
name|hostent
modifier|*
name|hent
decl_stmt|;
name|char
modifier|*
modifier|*
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hent
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|from_addr
argument_list|,
literal|4
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hent
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hent
operator|=
name|gethostbyname
argument_list|(
name|hent
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hent
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|addr
operator|=
name|hent
operator|->
name|h_addr_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|addr
operator|&&
name|addr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Checking address %08x"
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkt_addr
operator|==
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * krb_rd_req() takes an AUTH_MSG_APPL_REQUEST or  * AUTH_MSG_APPL_REQUEST_MUTUAL message created by krb_mk_req(),  * checks its integrity and returns a judgement as to the requestor's  * identity.  *  * The "authent" argument is a pointer to the received message.  * The "service" and "instance" arguments name the receiving server,  * and are used to get the service's ticket to decrypt the ticket  * in the message, and to compare against the server name inside the  * ticket.  "from_addr" is the network address of the host from which  * the message was received; this is checked against the network  * address in the ticket.  If "from_addr" is zero, the check is not  * performed.  "ad" is an AUTH_DAT structure which is  * filled in with information about the sender's identity according  * to the authenticator and ticket sent in the message.  Finally,  * "fn" contains the name of the file containing the server's key.  * (If "fn" is NULL, the server's key is assumed to have been set  * by krb_set_key().  If "fn" is the null string ("") the default  * file KEYFILE, defined in "krb.h", is used.)  *  * krb_rd_req() returns RD_AP_OK if the authentication information  * was genuine, or one of the following error codes (defined in  * "krb.h"):  *  *	RD_AP_VERSION		- wrong protocol version number  *	RD_AP_MSG_TYPE		- wrong message type  *	RD_AP_UNDEC		- couldn't decipher the message  *	RD_AP_INCON		- inconsistencies found  *	RD_AP_BADD		- wrong network address  *	RD_AP_TIME		- client time (in authenticator)  *				  too far off server time  *	RD_AP_NYV		- Kerberos time (in ticket) too  *				  far off server time  *	RD_AP_EXP		- ticket expired  *  * For the message format, see krb_mk_req().  *  * Mutual authentication is not implemented.  */
end_comment

begin_expr_stmt
name|krb_rd_req
argument_list|(
name|authent
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
name|from_addr
argument_list|,
name|ad
argument_list|,
name|fn
argument_list|)
specifier|register
name|KTEXT
name|authent
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The received message */
end_comment

begin_decl_stmt
name|char
modifier|*
name|service
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Service name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|instance
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Service instance */
end_comment

begin_decl_stmt
name|long
name|from_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Net address of originating host */
end_comment

begin_decl_stmt
name|AUTH_DAT
modifier|*
name|ad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to be filled in */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename to get keys from */
end_comment

begin_block
block|{
specifier|static
name|KTEXT_ST
name|ticket
decl_stmt|;
comment|/* Temp storage for ticket */
specifier|static
name|KTEXT
name|tkt
init|=
operator|&
name|ticket
decl_stmt|;
specifier|static
name|KTEXT_ST
name|req_id_st
decl_stmt|;
comment|/* Temp storage for authenticator */
specifier|register
name|KTEXT
name|req_id
init|=
operator|&
name|req_id_st
decl_stmt|;
name|char
name|realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
comment|/* Realm of issuing kerberos */
specifier|static
name|Key_schedule
name|seskey_sched
decl_stmt|;
comment|/* Key sched for session key */
name|unsigned
name|char
name|skey
index|[
name|KKEY_SZ
index|]
decl_stmt|;
comment|/* Session key from ticket */
name|char
name|sname
index|[
name|SNAME_SZ
index|]
decl_stmt|;
comment|/* Service name from ticket */
name|char
name|iname
index|[
name|INST_SZ
index|]
decl_stmt|;
comment|/* Instance name from ticket */
name|char
name|r_aname
index|[
name|ANAME_SZ
index|]
decl_stmt|;
comment|/* Client name from authenticator */
name|char
name|r_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
comment|/* Client instance from authenticator */
name|char
name|r_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
comment|/* Client realm from authenticator */
name|unsigned
name|int
name|r_time_ms
decl_stmt|;
comment|/* Fine time from authenticator */
name|unsigned
name|long
name|r_time_sec
decl_stmt|;
comment|/* Coarse time from authenticator */
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* For stepping through */
name|unsigned
name|long
name|delta_t
decl_stmt|;
comment|/* Time in authenticator - local time */
name|long
name|tkt_age
decl_stmt|;
comment|/* Age of ticket */
specifier|static
name|int
name|swap_bytes
decl_stmt|;
comment|/* Need to swap bytes? */
specifier|static
name|int
name|mutual
decl_stmt|;
comment|/* Mutual authentication requested? */
specifier|static
name|unsigned
name|char
name|s_kvno
decl_stmt|;
comment|/* Version number of the server's key 				 * Kerberos used to encrypt ticket */
name|int
name|status
decl_stmt|;
if|if
condition|(
name|authent
operator|->
name|length
operator|<=
literal|0
condition|)
return|return
operator|(
name|RD_AP_MODIFIED
operator|)
return|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|authent
operator|->
name|dat
expr_stmt|;
comment|/* get msg version, type and byte order, and server key version */
comment|/* check version */
if|if
condition|(
name|KRB_PROT_VERSION
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|*
name|ptr
operator|++
condition|)
return|return
operator|(
name|RD_AP_VERSION
operator|)
return|;
comment|/* byte order */
name|swap_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|&
literal|1
operator|)
operator|!=
name|HOST_BYTE_ORDER
condition|)
name|swap_bytes
operator|++
expr_stmt|;
comment|/* check msg type */
name|mutual
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|ptr
operator|++
operator|&
operator|~
literal|1
condition|)
block|{
case|case
name|AUTH_MSG_APPL_REQUEST
case|:
break|break;
case|case
name|AUTH_MSG_APPL_REQUEST_MUTUAL
case|:
name|mutual
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|RD_AP_MSG_TYPE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|lint
comment|/* XXX mutual is set but not used; why??? */
comment|/* this is a crock to get lint to shut up */
if|if
condition|(
name|mutual
condition|)
name|mutual
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
name|s_kvno
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
comment|/* get server key version */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|realm
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* And the realm of the issuing KDC */
name|ptr
operator|+=
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip the realm "hint" */
comment|/*      * If "fn" is NULL, key info should already be set; don't      * bother with ticket file.  Otherwise, check to see if we      * already have key info for the given server and key version      * (saved in the static st_* variables).  If not, go get it      * from the ticket file.  If "fn" is the null string, use the      * default ticket file.      */
if|if
condition|(
name|fn
operator|&&
operator|(
name|strcmp
argument_list|(
name|st_nam
argument_list|,
name|service
argument_list|)
operator|||
name|strcmp
argument_list|(
name|st_inst
argument_list|,
name|instance
argument_list|)
operator|||
name|strcmp
argument_list|(
name|st_rlm
argument_list|,
name|realm
argument_list|)
operator|||
operator|(
name|st_kvno
operator|!=
name|s_kvno
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|fn
operator|==
literal|0
condition|)
name|fn
operator|=
name|KEYFILE
expr_stmt|;
name|st_kvno
operator|=
name|s_kvno
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
if|if
condition|(
name|read_service_key
argument_list|(
name|service
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
operator|(
name|int
operator|)
name|s_kvno
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|skey
argument_list|)
condition|)
return|return
operator|(
name|RD_AP_UNDEC
operator|)
return|;
if|if
condition|(
name|status
operator|=
name|krb_set_key
argument_list|(
operator|(
name|char
operator|*
operator|)
name|skey
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|status
operator|)
return|;
endif|#
directive|endif
comment|/* !NOENCRYPTION */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|st_rlm
argument_list|,
name|realm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|st_nam
argument_list|,
name|service
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|st_inst
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
comment|/* Get ticket from authenticator */
name|tkt
operator|->
name|length
operator|=
operator|(
name|int
operator|)
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tkt
operator|->
name|length
operator|+
operator|(
name|ptr
operator|+
literal|1
operator|-
operator|(
name|char
operator|*
operator|)
name|authent
operator|->
name|dat
operator|)
operator|)
operator|>
name|authent
operator|->
name|length
condition|)
return|return
operator|(
name|RD_AP_MODIFIED
operator|)
return|;
name|bcopy
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tkt
operator|->
name|dat
operator|)
argument_list|,
name|tkt
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"ticket->length: %d"
argument_list|,
name|tkt
operator|->
name|length
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
comment|/* Decrypt and take apart ticket */
endif|#
directive|endif
if|if
condition|(
name|decomp_ticket
argument_list|(
name|tkt
argument_list|,
operator|&
name|ad
operator|->
name|k_flags
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|pinst
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
operator|&
operator|(
name|ad
operator|->
name|address
operator|)
argument_list|,
name|ad
operator|->
name|session
argument_list|,
operator|&
operator|(
name|ad
operator|->
name|life
operator|)
argument_list|,
operator|&
operator|(
name|ad
operator|->
name|time_sec
operator|)
argument_list|,
name|sname
argument_list|,
name|iname
argument_list|,
name|ky
argument_list|,
name|serv_key
argument_list|)
condition|)
return|return
operator|(
name|RD_AP_UNDEC
operator|)
return|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
block|{
name|log
argument_list|(
literal|"Ticket Contents."
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|" Aname:   %s.%s"
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|ad
operator|->
name|prealm
operator|)
condition|?
name|ad
operator|->
name|prealm
else|:
literal|"Athena"
operator|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|" Service: %s%s%s"
argument_list|,
name|sname
argument_list|,
operator|(
operator|(
name|int
operator|)
operator|*
name|iname
condition|?
literal|"."
else|:
literal|""
operator|)
argument_list|,
name|iname
argument_list|)
expr_stmt|;
block|}
comment|/* Extract the authenticator */
name|req_id
operator|->
name|length
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|ptr
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|req_id
operator|->
name|length
operator|+
operator|(
name|ptr
operator|+
name|tkt
operator|->
name|length
operator|-
operator|(
name|char
operator|*
operator|)
name|authent
operator|->
name|dat
operator|)
operator|)
operator|>
name|authent
operator|->
name|length
condition|)
return|return
operator|(
name|RD_AP_MODIFIED
operator|)
return|;
name|bcopy
argument_list|(
name|ptr
operator|+
name|tkt
operator|->
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|req_id
operator|->
name|dat
operator|)
argument_list|,
name|req_id
operator|->
name|length
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
comment|/* And decrypt it with the session key from the ticket */
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"About to decrypt authenticator"
argument_list|)
expr_stmt|;
name|key_sched
argument_list|(
name|ad
operator|->
name|session
argument_list|,
name|seskey_sched
argument_list|)
expr_stmt|;
name|pcbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|req_id
operator|->
name|dat
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|req_id
operator|->
name|dat
argument_list|,
operator|(
name|long
operator|)
name|req_id
operator|->
name|length
argument_list|,
name|seskey_sched
argument_list|,
name|ad
operator|->
name|session
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Done."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOENCRYPTION */
define|#
directive|define
name|check_ptr
parameter_list|()
value|if ((ptr - (char *) req_id->dat)> req_id->length) return(RD_AP_MODIFIED);
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|req_id
operator|->
name|dat
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|r_aname
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Authentication name */
name|ptr
operator|+=
name|strlen
argument_list|(
name|r_aname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|check_ptr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|r_inst
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Authentication instance */
name|ptr
operator|+=
name|strlen
argument_list|(
name|r_inst
argument_list|)
operator|+
literal|1
expr_stmt|;
name|check_ptr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|r_realm
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Authentication name */
name|ptr
operator|+=
name|strlen
argument_list|(
name|r_realm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|check_ptr
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ad
operator|->
name|checksum
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Checksum */
name|ptr
operator|+=
literal|4
expr_stmt|;
name|check_ptr
argument_list|()
expr_stmt|;
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|ad
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|r_time_ms
operator|=
operator|*
operator|(
name|ptr
operator|++
operator|)
expr_stmt|;
comment|/* Time (fine) */
ifdef|#
directive|ifdef
name|lint
comment|/* XXX r_time_ms is set but not used.  why??? */
comment|/* this is a crock to get lint to shut up */
if|if
condition|(
name|r_time_ms
condition|)
name|r_time_ms
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
name|check_ptr
argument_list|()
expr_stmt|;
comment|/* assume sizeof(r_time_sec) == 4 ?? */
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|r_time_sec
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Time (coarse) */
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|r_time_sec
argument_list|)
expr_stmt|;
comment|/* Check for authenticity of the request */
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Pname:   %s %s"
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|r_aname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ad
operator|->
name|pname
argument_list|,
name|r_aname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|RD_AP_INCON
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ad
operator|->
name|pinst
argument_list|,
name|r_inst
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|RD_AP_INCON
operator|)
return|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Realm:   %s %s"
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
name|r_realm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|ad
operator|->
name|prealm
argument_list|,
name|r_realm
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|RD_AP_INCON
operator|)
return|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Address: %d %d"
argument_list|,
name|ad
operator|->
name|address
argument_list|,
name|from_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_addr
operator|&&
operator|(
name|ad
operator|->
name|address
operator|!=
name|from_addr
operator|)
operator|&&
name|check_multihome
argument_list|(
name|from_addr
argument_list|,
name|ad
operator|->
name|address
argument_list|)
condition|)
return|return
operator|(
name|RD_AP_BADD
operator|)
return|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t_local
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|delta_t
operator|=
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|t_local
operator|.
name|tv_sec
operator|-
name|r_time_sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta_t
operator|>
name|CLOCK_SKEW
condition|)
block|{
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Time out of range: %d - %d = %d"
argument_list|,
name|t_local
operator|.
name|tv_sec
argument_list|,
name|r_time_sec
argument_list|,
name|delta_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|RD_AP_TIME
operator|)
return|;
block|}
comment|/* Now check for expiration of ticket */
name|tkt_age
operator|=
name|t_local
operator|.
name|tv_sec
operator|-
name|ad
operator|->
name|time_sec
expr_stmt|;
if|if
condition|(
name|krb_ap_req_debug
condition|)
name|log
argument_list|(
literal|"Time: %d Issue Date: %d Diff: %d Life %x"
argument_list|,
name|t_local
operator|.
name|tv_sec
argument_list|,
name|ad
operator|->
name|time_sec
argument_list|,
name|tkt_age
argument_list|,
name|ad
operator|->
name|life
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_local
operator|.
name|tv_sec
operator|<
name|ad
operator|->
name|time_sec
condition|)
block|{
if|if
condition|(
operator|(
name|ad
operator|->
name|time_sec
operator|-
name|t_local
operator|.
name|tv_sec
operator|)
operator|>
name|CLOCK_SKEW
condition|)
return|return
operator|(
name|RD_AP_NYV
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|t_local
operator|.
name|tv_sec
operator|-
name|ad
operator|->
name|time_sec
operator|)
operator|>
literal|5
operator|*
literal|60
operator|*
name|ad
operator|->
name|life
condition|)
return|return
operator|(
name|RD_AP_EXP
operator|)
return|;
comment|/* All seems OK */
name|ad
operator|->
name|reply
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|RD_AP_OK
operator|)
return|;
block|}
end_block

end_unit

