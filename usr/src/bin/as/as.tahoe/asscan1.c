begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asscan1.c 4.6 7/6/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"asscanl.h"
end_include

begin_macro
name|inittokfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|bufstart
operator|=
operator|&
name|tokbuf
index|[
literal|0
index|]
expr_stmt|;
name|buftail
operator|=
operator|&
name|tokbuf
index|[
literal|1
index|]
expr_stmt|;
name|bufstart
operator|->
name|tok_next
operator|=
name|buftail
expr_stmt|;
name|buftail
operator|->
name|tok_next
operator|=
literal|0
expr_stmt|;
block|}
name|tokbuf
index|[
literal|0
index|]
operator|.
name|tok_count
operator|=
operator|-
literal|1
expr_stmt|;
name|tokbuf
index|[
literal|1
index|]
operator|.
name|tok_count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|tok_temp
operator|=
literal|0
expr_stmt|;
name|tok_free
operator|=
literal|0
expr_stmt|;
name|bufno
operator|=
literal|0
expr_stmt|;
name|emptybuf
operator|=
operator|&
name|tokbuf
index|[
name|bufno
index|]
expr_stmt|;
name|tokptr
operator|=
literal|0
expr_stmt|;
name|tokub
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|closetokfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|emptybuf
operator|->
name|toks
index|[
name|emptybuf
operator|->
name|tok_count
operator|++
index|]
operator|=
name|PARSEEOF
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	Clean up the buffers that haven't been 			 *	written out yet 			 */
if|if
condition|(
name|tokbuf
index|[
name|bufno
operator|^
literal|1
index|]
operator|.
name|tok_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|writeTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tokbuf
index|[
name|bufno
operator|^
literal|1
index|]
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tokfile
argument_list|)
condition|)
block|{
name|badwrite
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file writing the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 *	Ensure that we will read an End of file, 			 *	if there are more than one file names 			 *	in the argument list 			 */
name|tokbuf
index|[
name|bufno
index|]
operator|.
name|toks
index|[
name|tokbuf
index|[
name|bufno
index|]
operator|.
name|tok_count
operator|++
index|]
operator|=
name|PARSEEOF
expr_stmt|;
if|if
condition|(
name|writeTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tokbuf
index|[
name|bufno
index|]
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tokfile
argument_list|)
condition|)
goto|goto
name|badwrite
goto|;
block|}
block|}
comment|/*end of being pass 1*/
block|}
end_block

begin_function
name|inttoktype
name|yylex
parameter_list|()
block|{
specifier|register
name|ptrall
name|bufptr
decl_stmt|;
specifier|register
name|inttoktype
name|val
decl_stmt|;
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
comment|/* 	 *	No local variables to be allocated; this saves 	 *	one piddling instruction.. 	 */
specifier|static
name|int
name|Lastjxxx
decl_stmt|;
name|bufptr
operator|=
name|tokptr
expr_stmt|;
comment|/*copy in the global value*/
name|top
label|:
if|if
condition|(
name|bufptr
operator|<
name|tokub
condition|)
block|{
name|gtoken
argument_list|(
name|val
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yylval
operator|=
name|val
condition|)
block|{
case|case
name|PARSEEOF
case|:
name|yylval
operator|=
name|val
operator|=
name|PARSEEOF
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
case|case
name|INT
case|:
if|if
condition|(
name|xp
operator|>=
operator|&
name|explist
index|[
name|NEXP
index|]
condition|)
name|yyerror
argument_list|(
literal|"Too many expressions; try simplyfing"
argument_list|)
expr_stmt|;
else|else
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|locxp
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|locxp
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
name|glong
argument_list|(
name|locxp
operator|->
name|e_xvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|makevalue
label|:
name|locxp
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|e_xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|e_xname
operator|=
name|NULL
expr_stmt|;
name|yylval
operator|=
operator|(
name|int
operator|)
name|locxp
expr_stmt|;
break|break;
case|case
name|BIGNUM
case|:
if|if
condition|(
name|xp
operator|>=
operator|&
name|explist
index|[
name|NEXP
index|]
condition|)
name|yyerror
argument_list|(
literal|"Too many expressions; try simplyfing"
argument_list|)
expr_stmt|;
else|else
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|gnumber
argument_list|(
name|locxp
operator|->
name|e_number
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
goto|goto
name|makevalue
goto|;
case|case
name|NAME
case|:
name|gptr
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lastnam
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
case|case
name|REG
case|:
name|gchar
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSTn
case|:
case|case
name|INST0
case|:
name|gopcode
argument_list|(
name|yyopcode
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|gopcode
argument_list|(
name|yyopcode
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
comment|/* We can't cast Lastjxxx into (int *) here.. */
name|gptr
argument_list|(
name|Lastjxxx
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lastjxxx
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|Lastjxxx
expr_stmt|;
break|break;
case|case
name|ILINESKIP
case|:
name|gint
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lineno
operator|+=
name|yylval
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|SKIP
case|:
name|eatskiplg
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|VOID
case|:
goto|goto
name|top
goto|;
case|case
name|STRING
case|:
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|gptr
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|toktrace
condition|)
block|{
name|char
modifier|*
name|tok_to_name
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"P: %d T#: %4d, %s "
argument_list|,
name|passno
argument_list|,
name|bufptr
operator|-
name|firsttoken
argument_list|,
name|tok_to_name
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|INT
case|:
name|printf
argument_list|(
literal|"val %d"
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
name|printf
argument_list|(
literal|"val %d"
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIGNUM
case|:
name|bignumprint
argument_list|(
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|printf
argument_list|(
literal|"\"%.8s\""
argument_list|,
name|FETCHNAME
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|" r%d"
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|FETCHNAME
argument_list|(
name|ITABFETCH
argument_list|(
name|yyopcode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|printf
argument_list|(
literal|"length %d, seekoffset %d, place 0%o "
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|sd_strlen
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|sd_stroff
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|sd_place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|sd_place
operator|&
name|STR_CORE
condition|)
name|printf
argument_list|(
literal|"value\"%*s\""
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|sd_strlen
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|sd_string
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of the debug switch*/
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
else|else
block|{
comment|/* start a new buffer */
if|if
condition|(
name|useVM
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
name|tok_temp
operator|=
name|emptybuf
operator|->
name|tok_next
expr_stmt|;
name|emptybuf
operator|->
name|tok_next
operator|=
name|tok_free
expr_stmt|;
name|tok_free
operator|=
name|emptybuf
expr_stmt|;
name|emptybuf
operator|=
name|tok_temp
expr_stmt|;
block|}
else|else
block|{
name|emptybuf
operator|=
name|emptybuf
operator|->
name|tok_next
expr_stmt|;
block|}
name|bufno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|emptybuf
operator|==
literal|0
condition|)
block|{
name|struct
name|tokbufdesc
modifier|*
name|newdallop
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
goto|goto
name|badread
goto|;
name|emptybuf
operator|=
name|newdallop
operator|=
operator|(
expr|struct
name|tokbufdesc
operator|*
operator|)
name|Calloc
argument_list|(
name|TOKDALLOP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tokbufdesc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKDALLOP
condition|;
name|i
operator|++
control|)
block|{
name|buftail
operator|->
name|tok_next
operator|=
name|newdallop
expr_stmt|;
name|buftail
operator|=
name|newdallop
expr_stmt|;
name|newdallop
operator|+=
literal|1
expr_stmt|;
block|}
name|buftail
operator|->
name|tok_next
operator|=
literal|0
expr_stmt|;
block|}
comment|/*end of need to get more buffers*/
operator|(
name|bytetoktype
operator|*
operator|)
name|bufptr
operator|=
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
name|scan_dot_s
argument_list|(
name|emptybuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*don't use VM*/
name|bufno
operator|^=
literal|1
expr_stmt|;
name|emptybuf
operator|=
operator|&
name|tokbuf
index|[
name|bufno
index|]
expr_stmt|;
operator|(
operator|(
name|bytetoktype
operator|*
operator|)
name|bufptr
operator|)
operator|=
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
comment|/* 			 *	First check if there are things to write 			 *	out at all 			 */
if|if
condition|(
name|emptybuf
operator|->
name|tok_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|writeTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
name|emptybuf
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tokfile
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Unexpected end of file writing the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|scan_dot_s
argument_list|(
name|emptybuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*pass 2*/
if|if
condition|(
name|readTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
name|emptybuf
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tokfile
argument_list|)
condition|)
block|{
name|badread
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file while reading the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*end of using a real live file*/
operator|(
name|char
operator|*
operator|)
name|tokub
operator|=
operator|(
name|char
operator|*
operator|)
name|bufptr
operator|+
name|emptybuf
operator|->
name|tok_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|firsttoken
operator|=
name|bufptr
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"created buffernumber %d with %d tokens\n"
argument_list|,
name|bufno
argument_list|,
name|emptybuf
operator|->
name|tok_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
goto|goto
name|top
goto|;
block|}
comment|/*end of reading/creating a new buffer*/
name|tokptr
operator|=
name|bufptr
expr_stmt|;
comment|/*copy back the global value*/
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*end of yylex*/
end_comment

begin_expr_stmt
name|buildskip
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|ptrall
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|diff
decl_stmt|;
specifier|register
name|struct
name|tokbufdesc
modifier|*
name|middlebuf
decl_stmt|;
comment|/* 	 *	check if from and to are in the same buffer 	 *	from and to DIFFER BY AT MOST 1 buffer and to is 	 *	always ahead of from, with to being in the buffer emptybuf 	 *	points to. 	 *	The hard part here is accounting for the case where the 	 *	skip is to cross a buffer boundary; we must construct 	 *	two skips. 	 * 	 *	Figure out where the buffer boundary between from and to is 	 *	It's easy in VM, as buffers increase to high memory, but 	 *	w/o VM, we alternate between two buffers, and want 	 *	to look at the exact middle of the contiguous buffer region. 	 */
name|middlebuf
operator|=
name|useVM
condition|?
name|emptybuf
else|:
operator|&
name|tokbuf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bytetoktype
operator|*
operator|)
name|from
operator|>
operator|(
name|bytetoktype
operator|*
operator|)
name|middlebuf
operator|)
operator|^
operator|(
operator|(
name|bytetoktype
operator|*
operator|)
name|to
operator|>
operator|(
name|bytetoktype
operator|*
operator|)
name|middlebuf
operator|)
condition|)
block|{
comment|/*split across a buffer boundary*/
name|ptoken
argument_list|(
name|from
argument_list|,
name|SKIP
argument_list|)
expr_stmt|;
comment|/* 		 *	Set the skip so it lands someplace beyond 		 *	the end of this buffer. 		 *	When we pull this skip out in the second pass, 		 *	we will temporarily move the current pointer 		 *	out beyond the end of the buffer, but immediately 		 *	do a compare and fail the compare, and then reset 		 *	all the pointers correctly to point into the next buffer. 		 */
name|bskiplg
argument_list|(
name|from
argument_list|,
name|TOKBUFLG
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *	Now, force from to be in the same buffer as to 		 */
operator|(
name|bytetoktype
operator|*
operator|)
name|from
operator|=
operator|(
name|bytetoktype
operator|*
operator|)
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|/* 	 *	Now, to and from are in the same buffer 	 */
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|yyerror
argument_list|(
literal|"Internal error: bad skip construction"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|diff
operator|=
operator|(
name|bytetoktype
operator|*
operator|)
name|to
operator|-
operator|(
name|bytetoktype
operator|*
operator|)
name|from
operator|)
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|bytetoktype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
operator|+
literal|1
operator|)
condition|)
block|{
name|ptoken
argument_list|(
name|from
argument_list|,
name|SKIP
argument_list|)
expr_stmt|;
name|bskipfromto
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|diff
operator|>
literal|0
condition|;
operator|--
name|diff
control|)
name|ptoken
argument_list|(
name|from
argument_list|,
name|VOID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|movestr
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|lg
argument_list|)
specifier|register
name|char
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|lg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lg
operator|<=
literal|0
condition|)
return|return;
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|lg
condition|)
do|;
block|}
end_block

begin_macro
name|new_dot_s
argument_list|(
argument|namep
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|newfflag
operator|=
literal|1
expr_stmt|;
name|newfname
operator|=
name|namep
expr_stmt|;
name|dotsname
operator|=
name|namep
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|scanlineno
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|min
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_block

end_unit

