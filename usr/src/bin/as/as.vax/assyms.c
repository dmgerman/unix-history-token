begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)assyms.c	5.2 (Berkeley) 10/22/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_comment
comment|/*  *	Managers for chunks of symbols allocated from calloc()  *	We maintain a linked list of such chunks.  *  */
end_comment

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|allochead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*head of chunk list*/
end_comment

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|alloctail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*tail*/
end_comment

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|newbox
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*for creating a new chunk*/
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|nextsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next symbol free*/
end_comment

begin_decl_stmt
name|int
name|symsleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*slots left in current chunk*/
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|symptrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|symdelim
index|[
name|NLOC
operator|+
name|NLOC
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|symptrub
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Managers for the dynamically extendable hash table  */
end_comment

begin_decl_stmt
name|struct
name|hashdallop
modifier|*
name|htab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Iptr
modifier|*
name|itab
index|[
name|NINST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*maps opcodes to instructions*/
end_comment

begin_comment
comment|/*  *	Counts what went into the symbol table, so that the  *	size of the symbol table can be computed.  */
end_comment

begin_decl_stmt
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number in the symbol table */
end_comment

begin_decl_stmt
name|int
name|njxxx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of jxxx entrys */
end_comment

begin_decl_stmt
name|int
name|nforgotten
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols erroneously entered */
end_comment

begin_decl_stmt
name|int
name|nlabels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of label entries */
end_comment

begin_comment
comment|/*  *	Managers of the symbol literal storage.  */
end_comment

begin_decl_stmt
name|struct
name|strpool
modifier|*
name|strplhead
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|symtabinit
argument_list|()
end_macro

begin_block
block|{
name|allochead
operator|=
literal|0
expr_stmt|;
name|alloctail
operator|=
literal|0
expr_stmt|;
name|nextsym
operator|=
literal|0
expr_stmt|;
name|symsleft
operator|=
literal|0
expr_stmt|;
name|strpoolalloc
argument_list|()
expr_stmt|;
comment|/* get the first strpool storage area */
name|htab
operator|=
literal|0
expr_stmt|;
name|htaballoc
argument_list|()
expr_stmt|;
comment|/* get the first part of the hash table */
block|}
end_block

begin_comment
comment|/*  *	Install all known instructions in the symbol table  */
end_comment

begin_macro
name|syminstall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Iptr
name|ip
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINST
condition|;
name|i
operator|++
control|)
name|itab
index|[
name|i
index|]
operator|=
operator|(
name|Iptr
operator|*
operator|)
name|BADPOINT
expr_stmt|;
for|for
control|(
name|ip
operator|=
operator|(
name|Iptr
operator|)
name|instab
init|;
name|FETCHNAME
argument_list|(
name|ip
argument_list|)
index|[
literal|0
index|]
condition|;
name|ip
operator|++
control|)
block|{
name|p1
operator|=
name|FETCHNAME
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|p2
operator|=
name|yytext
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
name|hp
operator|=
name|lookup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 => don't install this*/
if|if
condition|(
operator|*
name|hp
operator|==
name|NULL
condition|)
block|{
operator|*
name|hp
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|s_tag
operator|!=
name|INSTn
operator|)
operator|&&
operator|(
name|ip
operator|->
name|s_tag
operator|!=
name|INST0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|s_tag
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* was pseudo-op */
if|if
condition|(
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
operator|==
operator|(
name|Iptr
operator|*
operator|)
name|BADPOINT
condition|)
block|{
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
operator|=
operator|(
name|Iptr
operator|*
operator|)
name|ClearCalloc
argument_list|(
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|Iptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
index|[
name|i
index|]
operator|=
operator|(
name|Iptr
operator|)
name|BADPOINT
expr_stmt|;
block|}
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
index|[
name|ip
operator|->
name|i_popcode
index|]
operator|=
name|ip
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*end of syminstall*/
end_comment

begin_define
define|#
directive|define
name|ISLABEL
parameter_list|(
name|sp
parameter_list|)
define|\
value|(   (!savelabels) \&& (sp->s_tag == LABELID) \&& (STRPLACE(sp)& STR_CORE) \&& (FETCHNAME(sp)[0] == 'L'))
end_define

begin_comment
comment|/*  *	Assign final values to symbols,  *	and overwrite the index field with its relative position in  *	the symbol table we give to the loader.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exec
name|hdr
decl_stmt|;
end_decl_stmt

begin_macro
name|freezesymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
name|long
name|bs
decl_stmt|;
specifier|register
name|int
name|relpos
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|ubsp
decl_stmt|;
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ubsp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
comment|/*totally ignore jxxx entries */
comment|/* 		 *	Ignore stabs, but give them a symbol table index 		 */
if|if
condition|(
name|sp
operator|->
name|s_type
operator|&
name|STABFLAG
condition|)
goto|goto
name|assignindex
goto|;
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
name|sp
operator|->
name|s_type
operator|=
name|XXTRN
operator|+
name|XUNDEF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XDATA
condition|)
name|sp
operator|->
name|s_value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|s_index
index|]
operator|.
name|e_xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XTEXT
condition|)
name|sp
operator|->
name|s_value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|s_index
index|]
operator|.
name|e_xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XBSS
condition|)
block|{
name|bs
operator|=
name|sp
operator|->
name|s_value
expr_stmt|;
name|sp
operator|->
name|s_value
operator|=
name|hdr
operator|.
name|a_bss
operator|+
name|datbase
expr_stmt|;
name|hdr
operator|.
name|a_bss
operator|+=
name|bs
expr_stmt|;
block|}
name|assignindex
label|:
if|if
condition|(
operator|!
name|ISLABEL
argument_list|(
name|sp
argument_list|)
condition|)
name|sp
operator|->
name|s_index
operator|=
name|relpos
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	For all of the stabs that had their final value undefined during pass 1  *	and during pass 2 assign a final value.  *	We have already given stab entrys a initial approximation  *	when we constsructed the sorted symbol table.  *	Iteration order doesn't matter.  */
end_comment

begin_macro
name|stabfix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|cosp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|SYMITERATE
argument_list|(
argument|cosp
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_ptype
operator|&&
operator|(
name|sp
operator|->
name|s_type
operator|&
name|STABFLAG
operator|)
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|s_dest
expr_stmt|;
comment|/*   * STABFLOATING indicates that the offset has been saved in s_desc, s_other  */
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|==
name|STABFLOATING
condition|)
block|{
name|sp
operator|->
name|s_value
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
name|sp
operator|->
name|s_other
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|unsigned
name|short
operator|)
name|sp
operator|->
name|s_desc
operator|)
operator|)
expr_stmt|;
name|sp
operator|->
name|s_value
operator|=
name|sp
operator|->
name|s_value
operator|+
name|p
operator|->
name|s_value
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|s_value
operator|=
name|p
operator|->
name|s_value
expr_stmt|;
name|sp
operator|->
name|s_index
operator|=
name|p
operator|->
name|s_index
expr_stmt|;
name|sp
operator|->
name|s_type
operator|=
name|p
operator|->
name|s_type
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|Calloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newstuff
decl_stmt|;
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
name|newstuff
operator|=
name|sbrk
argument_list|(
name|number
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|newstuff
operator|==
operator|-
literal|1
condition|)
block|{
name|yyerror
argument_list|(
literal|"Ran out of Memory"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|newstuff
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ClearCalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newstuff
decl_stmt|;
comment|/* r11 */
specifier|register
name|int
name|length
init|=
name|number
operator|*
name|size
decl_stmt|;
comment|/* r10 */
ifdef|#
directive|ifdef
name|lint
name|length
operator|=
name|length
expr_stmt|;
endif|#
directive|endif
endif|length
name|newstuff
operator|=
name|Calloc
argument_list|(
name|number
argument_list|,
name|size
argument_list|)
expr_stmt|;
asm|asm("movc5 $0, (r0), $0, r10, (r11)");
return|return
operator|(
name|newstuff
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symtab
modifier|*
name|symalloc
parameter_list|()
block|{
if|if
condition|(
name|symsleft
operator|==
literal|0
condition|)
block|{
name|newbox
operator|=
operator|(
expr|struct
name|allocbox
operator|*
operator|)
name|ClearCalloc
argument_list|(
literal|1
argument_list|,
name|ALLOCQTY
argument_list|)
expr_stmt|;
name|symsleft
operator|=
name|SYMDALLOP
expr_stmt|;
name|nextsym
operator|=
operator|&
name|newbox
operator|->
name|symslots
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|alloctail
operator|==
literal|0
condition|)
block|{
name|allochead
operator|=
name|alloctail
operator|=
name|newbox
expr_stmt|;
block|}
else|else
block|{
name|alloctail
operator|->
name|nextalloc
operator|=
name|newbox
expr_stmt|;
name|alloctail
operator|=
name|newbox
expr_stmt|;
block|}
block|}
operator|--
name|symsleft
expr_stmt|;
operator|++
name|nsyms
expr_stmt|;
return|return
operator|(
name|nextsym
operator|++
operator|)
return|;
block|}
end_function

begin_macro
name|strpoolalloc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|strpool
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|strpool
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strpool
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|str_nalloc
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|str_next
operator|=
name|strplhead
expr_stmt|;
name|strplhead
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_macro
name|symcmp
argument_list|(
argument|Pptr
argument_list|,
argument|Qptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|Pptr
decl_stmt|,
modifier|*
modifier|*
name|Qptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|p
init|=
operator|*
name|Pptr
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|q
init|=
operator|*
name|Qptr
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|s_index
operator|<
name|q
operator|->
name|s_index
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|s_index
operator|>
name|q
operator|->
name|s_index
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|s_value
operator|<
name|q
operator|->
name|s_value
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|s_value
operator|>
name|q
operator|->
name|s_value
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *	Force jxxx entries to virtually preceed labels defined 	 *	to follow the jxxxx instruction, so that bumping the 	 *	jxxx instruction correctly fixes up the following labels 	 */
if|if
condition|(
name|p
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
comment|/*p points to a jxxx*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *	both are now just plain labels; the relative order doesn't 	 *	matter.  Both can't be jxxxes, as they would have different 	 *	values. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*end of symcmp*/
end_comment

begin_comment
comment|/*  *	We construct the auxiliary table of pointers, symptrs and  *	symdelim  *	We also assign preliminary values to stab entries that did not yet  *	have an absolute value (because they initially referred to  *	forward references). We don't worry about .stabds, as they  *	already have an estimated final value  */
end_comment

begin_macro
name|sortsymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|cowalk
decl_stmt|;
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|struct
name|symtab
modifier|*
name|ubsp
decl_stmt|;
name|int
name|segno
decl_stmt|;
name|int
name|slotno
decl_stmt|;
name|int
name|symsin
decl_stmt|;
comment|/*number put into symptrs*/
name|symptrs
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|Calloc
argument_list|(
name|nsyms
operator|+
literal|2
argument_list|,
sizeof|sizeof
expr|*
name|symptrs
argument_list|)
expr_stmt|;
comment|/* 	 *	Allocate one word at the beginning of the symptr array 	 *	so that backwards scans through the symptr array will 	 *	work correctly while scanning through the zeroth segment 	 */
operator|*
name|symptrs
operator|++
operator|=
literal|0
expr_stmt|;
name|cowalk
operator|=
name|symptrs
expr_stmt|;
name|symsin
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ubsp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_ptype
operator|&&
operator|(
name|sp
operator|->
name|s_type
operator|&
name|STABFLAG
operator|)
condition|)
block|{
name|sp
operator|->
name|s_value
operator|=
name|sp
operator|->
name|s_dest
operator|->
name|s_value
expr_stmt|;
name|sp
operator|->
name|s_index
operator|=
name|sp
operator|->
name|s_dest
operator|->
name|s_index
expr_stmt|;
block|}
if|if
condition|(
name|symsin
operator|>=
name|nsyms
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: overfilled symbol table indirection table"
argument_list|)
expr_stmt|;
operator|*
name|cowalk
operator|++
operator|=
name|sp
expr_stmt|;
name|symsin
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|symsin
operator|!=
name|nsyms
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: installed %d syms, should have installed %d"
argument_list|,
name|symsin
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|symptrub
operator|=
operator|&
name|symptrs
index|[
name|nsyms
index|]
expr_stmt|;
name|qsort
argument_list|(
name|symptrs
argument_list|,
name|nsyms
argument_list|,
sizeof|sizeof
expr|*
name|symptrs
argument_list|,
name|symcmp
argument_list|)
expr_stmt|;
name|symdelim
index|[
literal|0
index|]
operator|=
name|symptrs
expr_stmt|;
for|for
control|(
name|cowalk
operator|=
name|symptrs
operator|,
name|sp
operator|=
operator|*
name|cowalk
operator|,
name|segno
operator|=
literal|0
operator|,
name|slotno
operator|=
literal|1
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
operator|,
name|slotno
operator|++
control|)
block|{
for|for
control|(
init|;
name|sp
operator|&&
name|sp
operator|->
name|s_index
operator|==
name|segno
condition|;
name|sp
operator|=
operator|*
operator|++
name|cowalk
control|)
empty_stmt|;
name|symdelim
index|[
name|slotno
index|]
operator|=
name|cowalk
expr_stmt|;
comment|/*forms the ub delimeter*/
block|}
block|}
end_block

begin_comment
comment|/*end of sortsymtab*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|dumpsymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|segno
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|cosp
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
name|char
modifier|*
name|tagstring
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"Symbol Table dump:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|segno
operator|=
literal|0
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"Segment number: %d\n"
argument_list|,
name|segno
argument_list|)
expr_stmt|;
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|cosp
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|,
argument|++
argument_list|)
block|{
name|printf
argument_list|(
literal|"\tSeg: %d \"%s\" value: %d index: %d tag %s\n"
argument_list|,
name|segno
argument_list|,
name|FETCHNAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|s_value
argument_list|,
name|sp
operator|->
name|s_index
argument_list|,
name|tagstring
argument_list|(
name|sp
operator|->
name|s_tag
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\ttype: %d jxbump %d jxfear: %d\n"
argument_list|,
name|sp
operator|->
name|s_type
argument_list|,
name|sp
operator|->
name|s_jxbump
argument_list|,
name|sp
operator|->
name|s_jxfear
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|tagbuff
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|tagstring
parameter_list|(
name|tag
parameter_list|)
name|unsigned
name|char
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|JXACTIVE
case|:
return|return
operator|(
literal|"active"
operator|)
return|;
case|case
name|JXNOTYET
case|:
return|return
operator|(
literal|"notyet"
operator|)
return|;
case|case
name|JXALIGN
case|:
return|return
operator|(
literal|"align"
operator|)
return|;
case|case
name|JXQUESTIONABLE
case|:
return|return
operator|(
literal|"jxquestionable"
operator|)
return|;
case|case
name|JXINACTIVE
case|:
return|return
operator|(
literal|"inactive"
operator|)
return|;
case|case
name|JXTUNNEL
case|:
return|return
operator|(
literal|"tunnel"
operator|)
return|;
case|case
name|OBSOLETE
case|:
return|return
operator|(
literal|"obsolete"
operator|)
return|;
case|case
name|IGNOREBOUND
case|:
return|return
operator|(
literal|"ignorebound"
operator|)
return|;
case|case
name|STABFLOATING
case|:
return|return
operator|(
literal|"stabfloating"
operator|)
return|;
case|case
name|STABFIXED
case|:
return|return
operator|(
literal|"stabfixed"
operator|)
return|;
case|case
name|LABELID
case|:
return|return
operator|(
literal|"labelid"
operator|)
return|;
case|case
name|OKTOBUMP
case|:
return|return
operator|(
literal|"oktobump"
operator|)
return|;
case|case
name|ISET
case|:
return|return
operator|(
literal|"iset"
operator|)
return|;
case|case
name|ILSYM
case|:
return|return
operator|(
literal|"ilsym"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tagbuff
argument_list|,
literal|"%d"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|tagbuff
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_macro
name|htaballoc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hashdallop
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|hashdallop
operator|*
operator|)
name|ClearCalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hashdallop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
literal|0
condition|)
name|htab
operator|=
name|new
expr_stmt|;
else|else
block|{
comment|/* add AFTER the 1st slot */
name|new
operator|->
name|h_next
operator|=
name|htab
operator|->
name|h_next
expr_stmt|;
name|htab
operator|->
name|h_next
operator|=
name|new
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|HASHCLOGGED
value|(NHASH / 2)
end_define

begin_comment
comment|/*  *	Lookup a symbol stored in extern yytext.  *	All strings passed in via extern yytext had better have  *	a trailing null.  Strings are placed in yytext for hashing by  *	syminstall() and by yylex();  *  *	We take pains to avoid function calls; this functdion  *	is called quite frequently, and the calls overhead  *	in the vax contributes significantly to the overall  *	execution speed of as.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
modifier|*
name|lookup
parameter_list|(
name|instflg
parameter_list|)
name|int
name|instflg
decl_stmt|;
comment|/* 0: don't install */
block|{
specifier|static
name|int
name|initialprobe
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|nprobes
decl_stmt|;
specifier|static
name|struct
name|hashdallop
modifier|*
name|hdallop
decl_stmt|;
specifier|static
name|struct
name|symtab
modifier|*
modifier|*
name|emptyslot
decl_stmt|;
specifier|static
name|struct
name|hashdallop
modifier|*
name|emptyhd
decl_stmt|;
specifier|static
name|struct
name|symtab
modifier|*
modifier|*
name|hp_ub
decl_stmt|;
name|emptyslot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nprobes
operator|=
literal|0
operator|,
name|from
operator|=
name|yytext
init|;
operator|*
name|from
condition|;
name|nprobes
operator|<<=
literal|2
operator|,
name|nprobes
operator|+=
operator|*
name|from
operator|++
control|)
continue|continue;
name|nprobes
operator|+=
name|from
index|[
operator|-
literal|1
index|]
operator|<<
literal|5
expr_stmt|;
name|nprobes
operator|%=
name|NHASH
expr_stmt|;
if|if
condition|(
name|nprobes
operator|<
literal|0
condition|)
name|nprobes
operator|+=
name|NHASH
expr_stmt|;
name|initialprobe
operator|=
name|nprobes
expr_stmt|;
for|for
control|(
name|hdallop
operator|=
name|htab
init|;
name|hdallop
operator|!=
literal|0
condition|;
name|hdallop
operator|=
name|hdallop
operator|->
name|h_next
control|)
block|{
for|for
control|(
name|hp
operator|=
operator|&
operator|(
name|hdallop
operator|->
name|h_htab
index|[
name|initialprobe
index|]
operator|)
operator|,
name|nprobes
operator|=
literal|1
operator|,
name|hp_ub
operator|=
operator|&
operator|(
name|hdallop
operator|->
name|h_htab
index|[
name|NHASH
index|]
operator|)
init|;
operator|(
operator|*
name|hp
operator|)
operator|&&
operator|(
name|nprobes
operator|<
name|NHASH
operator|)
condition|;
name|hp
operator|+=
name|nprobes
operator|,
name|hp
operator|-=
operator|(
name|hp
operator|>=
name|hp_ub
operator|)
condition|?
name|NHASH
else|:
literal|0
operator|,
name|nprobes
operator|+=
literal|2
control|)
block|{
name|from
operator|=
name|yytext
expr_stmt|;
name|to
operator|=
name|FETCHNAME
argument_list|(
operator|*
name|hp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|from
operator|&&
operator|*
name|to
condition|)
if|if
condition|(
operator|*
name|from
operator|++
operator|!=
operator|*
name|to
operator|++
condition|)
goto|goto
name|nextprobe
goto|;
if|if
condition|(
operator|*
name|to
operator|==
operator|*
name|from
condition|)
comment|/*assert both are == 0*/
return|return
operator|(
name|hp
operator|)
return|;
name|nextprobe
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
operator|&&
name|emptyslot
operator|==
literal|0
operator|&&
name|hdallop
operator|->
name|h_nused
operator|<
name|HASHCLOGGED
condition|)
block|{
name|emptyslot
operator|=
name|hp
expr_stmt|;
name|emptyhd
operator|=
name|hdallop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|emptyslot
operator|==
literal|0
condition|)
block|{
name|htaballoc
argument_list|()
expr_stmt|;
name|hdallop
operator|=
name|htab
operator|->
name|h_next
expr_stmt|;
comment|/* aren't we smart! */
name|hp
operator|=
operator|&
name|hdallop
operator|->
name|h_htab
index|[
name|initialprobe
index|]
expr_stmt|;
block|}
else|else
block|{
name|hdallop
operator|=
name|emptyhd
expr_stmt|;
name|hp
operator|=
name|emptyslot
expr_stmt|;
block|}
if|if
condition|(
name|instflg
condition|)
block|{
operator|*
name|hp
operator|=
name|symalloc
argument_list|()
expr_stmt|;
name|hdallop
operator|->
name|h_nused
operator|++
expr_stmt|;
for|for
control|(
name|from
operator|=
name|yytext
operator|,
name|len
operator|=
literal|0
init|;
operator|*
name|from
operator|++
condition|;
name|len
operator|++
control|)
continue|continue;
operator|(
operator|*
name|hp
operator|)
operator|->
name|s_name
operator|=
operator|(
name|char
operator|*
operator|)
name|savestr
argument_list|(
name|yytext
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|STR_BOTH
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*end of lookup*/
end_comment

begin_comment
comment|/*  *	save a string str with len in the places indicated by place  */
end_comment

begin_function
name|struct
name|strdesc
modifier|*
name|savestr
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|place
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|place
decl_stmt|;
block|{
name|reg
name|struct
name|strdesc
modifier|*
name|res
decl_stmt|;
name|int
name|tlen
decl_stmt|;
comment|/* 	 *	Compute the total length of the record to live in core 	 */
name|tlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|strdesc
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|res
operator|->
name|sd_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|&
name|STR_CORE
condition|)
name|tlen
operator|+=
name|len
expr_stmt|;
comment|/* 	 *	See if there is enough space for the record, 	 *	and allocate the record. 	 */
if|if
condition|(
name|tlen
operator|>=
operator|(
name|STRPOOLDALLOP
operator|-
name|strplhead
operator|->
name|str_nalloc
operator|)
condition|)
name|strpoolalloc
argument_list|()
expr_stmt|;
name|res
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
operator|(
name|strplhead
operator|->
name|str_names
operator|+
name|strplhead
operator|->
name|str_nalloc
operator|)
expr_stmt|;
comment|/* 	 *	Save the string information that is always present 	 */
name|res
operator|->
name|sd_stroff
operator|=
name|strfilepos
expr_stmt|;
name|res
operator|->
name|sd_strlen
operator|=
name|len
expr_stmt|;
name|res
operator|->
name|sd_place
operator|=
name|place
expr_stmt|;
comment|/* 	 *	Now, save the string itself.  If str is null, then 	 *	the characters have already been dumped to the file 	 */
if|if
condition|(
operator|(
name|place
operator|&
name|STR_CORE
operator|)
operator|&&
name|str
condition|)
name|movestr
argument_list|(
name|res
index|[
literal|0
index|]
operator|.
name|sd_string
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|&
name|STR_FILE
condition|)
block|{
if|if
condition|(
name|str
condition|)
block|{
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
block|}
name|strfilepos
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 *	Adjust the in core string pool size 	 */
name|strplhead
operator|->
name|str_nalloc
operator|+=
name|tlen
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	The relocation information is saved internally in an array of  *	lists of relocation buffers.  The relocation buffers are  *	exactly the same size as a token buffer; if we use VM for the  *	temporary file we reclaim this storage, otherwise we create  *	them by mallocing.  */
end_comment

begin_define
define|#
directive|define
name|RELBUFLG
value|TOKBUFLG
end_define

begin_define
define|#
directive|define
name|NRELOC
value|((TOKBUFLG - \ 			  (sizeof (int) + sizeof (struct relbufdesc *)) \ 			) / (sizeof (struct relocation_info)))
end_define

begin_struct
struct|struct
name|relbufdesc
block|{
name|int
name|rel_count
decl_stmt|;
name|struct
name|relbufdesc
modifier|*
name|rel_next
decl_stmt|;
name|struct
name|relocation_info
name|rel_reloc
index|[
name|NRELOC
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|relbufdesc
modifier|*
name|tok_free
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rel_free
value|tok_free
end_define

begin_decl_stmt
specifier|static
name|struct
name|relbufdesc
modifier|*
name|rel_temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|relocation_info
name|r_can_1PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|relocation_info
name|r_can_0PC
decl_stmt|;
end_decl_stmt

begin_macro
name|initoutrel
argument_list|()
end_macro

begin_block
block|{
name|r_can_0PC
operator|.
name|r_address
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_symbolnum
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_pcrel
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_length
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_can_1PC
operator|=
name|r_can_0PC
expr_stmt|;
name|r_can_1PC
operator|.
name|r_pcrel
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|outrel
argument_list|(
name|xp
argument_list|,
name|reloc_how
argument_list|)
specifier|register
expr|struct
name|exp
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|reloc_how
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TYPB..TYPH + (possibly)RELOC_PCREL */
end_comment

begin_block
block|{
name|struct
name|relocation_info
name|reloc
decl_stmt|;
specifier|register
name|int
name|x_type_mask
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|x_type_mask
operator|=
name|xp
operator|->
name|e_xtype
operator|&
operator|~
name|XFORW
expr_stmt|;
name|pcrel
operator|=
name|reloc_how
operator|&
name|RELOC_PCREL
expr_stmt|;
name|reloc_how
operator|&=
operator|~
name|RELOC_PCREL
expr_stmt|;
if|if
condition|(
name|bitoff
operator|&
literal|07
condition|)
name|yyerror
argument_list|(
literal|"Padding error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_type_mask
operator|==
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Undefined reference"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x_type_mask
operator|!=
name|XABS
operator|)
operator|||
name|pcrel
condition|)
block|{
if|if
condition|(
name|ty_NORELOC
index|[
name|reloc_how
index|]
condition|)
name|yyerror
argument_list|(
literal|"Illegal Relocation of floating or large int number."
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|pcrel
condition|?
name|r_can_1PC
else|:
name|r_can_0PC
expr_stmt|;
name|reloc
operator|.
name|r_address
operator|=
name|dotp
operator|->
name|e_xvalue
operator|-
operator|(
operator|(
name|dotp
operator|<
operator|&
name|usedot
index|[
name|NLOC
index|]
operator|||
name|readonlydata
operator|)
condition|?
literal|0
else|:
name|datbase
operator|)
expr_stmt|;
name|reloc
operator|.
name|r_length
operator|=
name|ty_nlg
index|[
name|reloc_how
index|]
expr_stmt|;
switch|switch
condition|(
name|x_type_mask
condition|)
block|{
case|case
name|XXTRN
operator||
name|XUNDEF
case|:
name|reloc
operator|.
name|r_symbolnum
operator|=
name|xp
operator|->
name|e_xname
operator|->
name|s_index
expr_stmt|;
name|reloc
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|readonlydata
operator|&&
operator|(
name|x_type_mask
operator|&
operator|~
name|XXTRN
operator|)
operator|==
name|XDATA
condition|)
name|x_type_mask
operator|=
name|XTEXT
operator||
operator|(
name|x_type_mask
operator|&
name|XXTRN
operator|)
expr_stmt|;
name|reloc
operator|.
name|r_symbolnum
operator|=
name|x_type_mask
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|relfil
operator|==
literal|0
operator|)
operator|||
operator|(
name|relfil
operator|->
name|rel_count
operator|>=
name|NRELOC
operator|)
condition|)
block|{
if|if
condition|(
name|rel_free
condition|)
block|{
name|rel_temp
operator|=
name|rel_free
expr_stmt|;
name|rel_free
operator|=
name|rel_temp
operator|->
name|rel_next
expr_stmt|;
block|}
else|else
block|{
name|rel_temp
operator|=
operator|(
expr|struct
name|relbufdesc
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relbufdesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rel_temp
operator|->
name|rel_count
operator|=
literal|0
expr_stmt|;
name|rel_temp
operator|->
name|rel_next
operator|=
name|relfil
expr_stmt|;
name|relfil
operator|=
name|rusefile
index|[
name|dotp
operator|-
operator|&
name|usedot
index|[
literal|0
index|]
index|]
operator|=
name|rel_temp
expr_stmt|;
block|}
name|relfil
operator|->
name|rel_reloc
index|[
name|relfil
operator|->
name|rel_count
operator|++
index|]
operator|=
name|reloc
expr_stmt|;
block|}
comment|/* 	 *	write the unrelocated value to the text file 	 */
name|dotp
operator|->
name|e_xvalue
operator|+=
name|ty_nbyte
index|[
name|reloc_how
index|]
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
name|xp
operator|->
name|e_xvalue
operator|-=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
switch|switch
condition|(
name|reloc_how
condition|)
block|{
case|case
name|TYPO
case|:
case|case
name|TYPQ
case|:
case|case
name|TYPF
case|:
case|case
name|TYPD
case|:
case|case
name|TYPG
case|:
case|case
name|TYPH
case|:
name|bignumwrite
argument_list|(
name|xp
operator|->
name|e_number
argument_list|,
name|reloc_how
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|xp
operator|->
name|e_xvalue
operator|)
argument_list|,
name|ty_nbyte
index|[
name|reloc_how
index|]
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  *	Flush out all of the relocation information.  *	Note that the individual lists of buffers are in  *	reverse order, so we must reverse them  */
end_comment

begin_function
name|off_t
name|closeoutrel
parameter_list|(
name|relocfile
parameter_list|)
name|BFILE
modifier|*
name|relocfile
decl_stmt|;
block|{
name|int
name|locindex
decl_stmt|;
name|u_long
name|Closeoutrel
parameter_list|()
function_decl|;
name|trsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|trsize
operator|+=
name|Closeoutrel
argument_list|(
name|rusefile
index|[
name|locindex
index|]
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
block|}
name|drsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|drsize
operator|+=
name|Closeoutrel
argument_list|(
name|rusefile
index|[
name|NLOC
operator|+
name|locindex
index|]
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|trsize
operator|+
name|drsize
operator|)
return|;
block|}
end_function

begin_function
name|u_long
name|Closeoutrel
parameter_list|(
name|relfil
parameter_list|,
name|relocfile
parameter_list|)
name|struct
name|relbufdesc
modifier|*
name|relfil
decl_stmt|;
name|BFILE
modifier|*
name|relocfile
decl_stmt|;
block|{
name|u_long
name|tail
decl_stmt|;
if|if
condition|(
name|relfil
operator|==
literal|0
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
name|tail
operator|=
name|Closeoutrel
argument_list|(
name|relfil
operator|->
name|rel_next
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|relfil
operator|->
name|rel_reloc
index|[
literal|0
index|]
argument_list|,
name|relfil
operator|->
name|rel_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|tail
operator|+
name|relfil
operator|->
name|rel_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NOUTSYMS
value|(nsyms - njxxx - nforgotten - (savelabels ? 0 : nlabels))
end_define

begin_function
name|int
name|sizesymtab
parameter_list|()
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
name|NOUTSYMS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Write out n symbols to file f, beginning at p  *	ignoring symbols that are obsolete, jxxx instructions, and  *	possibly, labels  */
end_comment

begin_function
name|int
name|symwrite
parameter_list|(
name|symfile
parameter_list|)
name|BFILE
modifier|*
name|symfile
decl_stmt|;
block|{
name|int
name|symsout
decl_stmt|;
comment|/*those actually written*/
name|int
name|symsdesired
init|=
name|NOUTSYMS
decl_stmt|;
name|reg
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* temp to save the name */
name|int
name|totalstr
decl_stmt|;
comment|/* 	 *	We use sp->s_index to hold the length of the 	 *	name; it isn't used for anything else 	 */
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|symsout
operator|=
literal|0
expr_stmt|;
name|totalstr
operator|=
sizeof|sizeof
argument_list|(
name|totalstr
argument_list|)
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
if|if
condition|(
name|ISLABEL
argument_list|(
name|sp
argument_list|)
condition|)
continue|continue;
name|symsout
operator|++
expr_stmt|;
name|name
operator|=
name|sp
operator|->
name|s_name
expr_stmt|;
comment|/* save pointer */
comment|/* 		 *	the length of the symbol table string 		 *	always includes the trailing null; 		 *	blast the pointer to its a.out value. 		 */
if|if
condition|(
name|sp
operator|->
name|s_name
operator|&&
operator|(
name|sp
operator|->
name|s_index
operator|=
name|STRLEN
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|sp
operator|->
name|s_nmx
operator|=
name|totalstr
expr_stmt|;
name|totalstr
operator|+=
name|sp
operator|->
name|s_index
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_nmx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|s_ptype
operator|!=
literal|0
condition|)
name|sp
operator|->
name|s_type
operator|=
name|sp
operator|->
name|s_ptype
expr_stmt|;
else|else
name|sp
operator|->
name|s_type
operator|=
operator|(
name|sp
operator|->
name|s_type
operator|&
operator|(
operator|~
name|XFORW
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|readonlydata
operator|&&
operator|(
name|sp
operator|->
name|s_type
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_DATA
condition|)
name|sp
operator|->
name|s_type
operator|=
name|N_TEXT
operator||
operator|(
name|sp
operator|->
name|s_type
operator|&
name|N_EXT
operator|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sp
operator|->
name|s_nm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_name
operator|=
name|name
expr_stmt|;
comment|/* restore pointer */
block|}
if|if
condition|(
name|symsout
operator|!=
name|symsdesired
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: Wrote %d symbols, wanted to write %d symbols\n"
argument_list|,
name|symsout
argument_list|,
name|symsdesired
argument_list|)
expr_stmt|;
comment|/* 	 *	Construct the string pool from the symbols that were written, 	 *	possibly fetching from the string file if the string 	 *	is not core resident. 	 */
name|bwrite
argument_list|(
operator|&
name|totalstr
argument_list|,
sizeof|sizeof
argument_list|(
name|totalstr
argument_list|)
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|symsout
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
if|if
condition|(
name|ISLABEL
argument_list|(
name|sp
argument_list|)
condition|)
continue|continue;
name|symsout
operator|++
expr_stmt|;
if|if
condition|(
name|STRLEN
argument_list|(
name|sp
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|STRPLACE
argument_list|(
name|sp
argument_list|)
operator|&
name|STR_CORE
condition|)
block|{
name|bwrite
argument_list|(
name|FETCHNAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|STRLEN
argument_list|(
name|sp
argument_list|)
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRPLACE
argument_list|(
name|sp
argument_list|)
operator|&
name|STR_FILE
condition|)
block|{
name|char
name|rbuf
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|left
decl_stmt|,
name|nread
decl_stmt|;
name|fseek
argument_list|(
name|strfile
argument_list|,
name|STROFF
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|left
operator|=
name|STRLEN
argument_list|(
name|sp
argument_list|)
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|nread
control|)
block|{
name|nread
operator|=
name|fread
argument_list|(
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|,
name|left
argument_list|)
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
name|bwrite
argument_list|(
name|rbuf
argument_list|,
name|nread
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|symsout
operator|!=
name|symsdesired
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: Wrote %d strings, wanted %d\n"
argument_list|,
name|symsout
argument_list|,
name|symsdesired
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

