begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)stty.c	5.7 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * set teletype modes  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp(s1, s2) == 0)
end_define

begin_define
define|#
directive|define
name|WRAPCOL
value|65
end_define

begin_define
define|#
directive|define
name|COMPAT_43
end_define

begin_macro
name|STATIC
end_macro

begin_struct
struct|struct
name|modes
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|set
decl_stmt|;
name|long
name|unset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|STATIC
name|struct
name|modes
name|imodes
index|[]
init|=
block|{
literal|"ignbrk"
block|,
name|IGNBRK
block|,
literal|0
block|,
literal|"-ignbrk"
block|,
literal|0
block|,
name|IGNBRK
block|,
literal|"brkint"
block|,
name|BRKINT
block|,
literal|0
block|,
literal|"-brkint"
block|,
literal|0
block|,
name|BRKINT
block|,
literal|"ignpar"
block|,
name|IGNPAR
block|,
literal|0
block|,
literal|"-ignpar"
block|,
literal|0
block|,
name|IGNPAR
block|,
literal|"parmrk"
block|,
name|PARMRK
block|,
literal|0
block|,
literal|"-parmrk"
block|,
literal|0
block|,
name|PARMRK
block|,
literal|"inpck"
block|,
name|INPCK
block|,
literal|0
block|,
literal|"-inpck"
block|,
literal|0
block|,
name|INPCK
block|,
literal|"istrip"
block|,
name|ISTRIP
block|,
literal|0
block|,
literal|"-istrip"
block|,
literal|0
block|,
name|ISTRIP
block|,
literal|"inlcr"
block|,
name|INLCR
block|,
literal|0
block|,
literal|"-inlcr"
block|,
literal|0
block|,
name|INLCR
block|,
literal|"igncr"
block|,
name|IGNCR
block|,
literal|0
block|,
literal|"-igncr"
block|,
literal|0
block|,
name|IGNCR
block|,
literal|"icrnl"
block|,
name|ICRNL
block|,
literal|0
block|,
literal|"-icrnl"
block|,
literal|0
block|,
name|ICRNL
block|,
literal|"ixon"
block|,
name|IXON
block|,
literal|0
block|,
literal|"-ixon"
block|,
literal|0
block|,
name|IXON
block|,
literal|"flow"
block|,
name|IXON
block|,
literal|0
block|,
literal|"-flow"
block|,
literal|0
block|,
name|IXON
block|,
literal|"ixoff"
block|,
name|IXOFF
block|,
literal|0
block|,
literal|"-ixoff"
block|,
literal|0
block|,
name|IXOFF
block|,
literal|"tandem"
block|,
name|IXOFF
block|,
literal|0
block|,
literal|"-tandem"
block|,
literal|0
block|,
name|IXOFF
block|,
literal|"ixany"
block|,
name|IXANY
block|,
literal|0
block|,
literal|"-ixany"
block|,
literal|0
block|,
name|IXANY
block|,
literal|"decctlq"
block|,
literal|0
block|,
name|IXANY
block|,
literal|"-decctlq"
block|,
name|IXANY
block|,
literal|0
block|,
literal|"imaxbel"
block|,
name|IMAXBEL
block|,
literal|0
block|,
literal|"-imaxbel"
block|,
literal|0
block|,
name|IMAXBEL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|modes
name|omodes
index|[]
init|=
block|{
literal|"opost"
block|,
name|OPOST
block|,
literal|0
block|,
literal|"-opost"
block|,
literal|0
block|,
name|OPOST
block|,
literal|"-litout"
block|,
name|OPOST
block|,
literal|0
block|,
literal|"litout"
block|,
literal|0
block|,
name|OPOST
block|,
literal|"onlcr"
block|,
name|ONLCR
block|,
literal|0
block|,
literal|"-onlcr"
block|,
literal|0
block|,
name|ONLCR
block|,
literal|"tabs"
block|,
literal|0
block|,
name|OXTABS
block|,
comment|/* "preserve" tabs */
literal|"-tabs"
block|,
name|OXTABS
block|,
literal|0
block|,
literal|"xtabs"
block|,
name|OXTABS
block|,
literal|0
block|,
literal|"-xtabs"
block|,
literal|0
block|,
name|OXTABS
block|,
literal|"oxtabs"
block|,
name|OXTABS
block|,
literal|0
block|,
literal|"-oxtabs"
block|,
literal|0
block|,
name|OXTABS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|modes
name|cmodes
index|[]
init|=
block|{
literal|"cs5"
block|,
name|CS5
block|,
name|CSIZE
block|,
literal|"cs6"
block|,
name|CS6
block|,
name|CSIZE
block|,
literal|"cs7"
block|,
name|CS7
block|,
name|CSIZE
block|,
literal|"cs8"
block|,
name|CS8
block|,
name|CSIZE
block|,
literal|"cstopb"
block|,
name|CSTOPB
block|,
literal|0
block|,
literal|"-cstopb"
block|,
literal|0
block|,
name|CSTOPB
block|,
literal|"cread"
block|,
name|CREAD
block|,
literal|0
block|,
literal|"-cread"
block|,
literal|0
block|,
name|CREAD
block|,
literal|"parenb"
block|,
name|PARENB
block|,
literal|0
block|,
literal|"-parenb"
block|,
literal|0
block|,
name|PARENB
block|,
literal|"parodd"
block|,
name|PARODD
block|,
literal|0
block|,
literal|"-parodd"
block|,
literal|0
block|,
name|PARODD
block|,
literal|"parity"
block|,
name|PARENB
operator||
name|CS7
block|,
name|PARODD
operator||
name|CSIZE
block|,
literal|"evenp"
block|,
name|PARENB
operator||
name|CS7
block|,
name|PARODD
operator||
name|CSIZE
block|,
literal|"oddp"
block|,
name|PARENB
operator||
name|CS7
operator||
name|PARODD
block|,
name|CSIZE
block|,
literal|"-parity"
block|,
name|CS8
block|,
name|PARODD
operator||
name|PARENB
operator||
name|CSIZE
block|,
literal|"-evenp"
block|,
name|CS8
block|,
name|PARODD
operator||
name|PARENB
operator||
name|CSIZE
block|,
literal|"-oddp"
block|,
name|CS8
block|,
name|PARODD
operator||
name|PARENB
operator||
name|CSIZE
block|,
literal|"hupcl"
block|,
name|HUPCL
block|,
literal|0
block|,
literal|"-hupcl"
block|,
literal|0
block|,
name|HUPCL
block|,
literal|"hup"
block|,
name|HUPCL
block|,
literal|0
block|,
literal|"-hup"
block|,
literal|0
block|,
name|HUPCL
block|,
literal|"clocal"
block|,
name|CLOCAL
block|,
literal|0
block|,
literal|"-clocal"
block|,
literal|0
block|,
name|CLOCAL
block|,
literal|"crtscts"
block|,
name|CRTSCTS
block|,
literal|0
block|,
literal|"-crtscts"
block|,
literal|0
block|,
name|CRTSCTS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|modes
name|lmodes
index|[]
init|=
block|{
literal|"echo"
block|,
name|ECHO
block|,
literal|0
block|,
literal|"-echo"
block|,
literal|0
block|,
name|ECHO
block|,
literal|"echoe"
block|,
name|ECHOE
block|,
literal|0
block|,
literal|"-echoe"
block|,
literal|0
block|,
name|ECHOE
block|,
literal|"crterase"
block|,
name|ECHOE
block|,
literal|0
block|,
literal|"-crterase"
block|,
literal|0
block|,
name|ECHOE
block|,
literal|"crtbs"
block|,
name|ECHOE
block|,
literal|0
block|,
comment|/* crtbs not supported, close enough */
literal|"-crtbs"
block|,
literal|0
block|,
name|ECHOE
block|,
literal|"echok"
block|,
name|ECHOK
block|,
literal|0
block|,
literal|"-echok"
block|,
literal|0
block|,
name|ECHOK
block|,
literal|"echoke"
block|,
name|ECHOKE
block|,
literal|0
block|,
literal|"-echoke"
block|,
literal|0
block|,
name|ECHOKE
block|,
literal|"crtkill"
block|,
name|ECHOKE
block|,
literal|0
block|,
literal|"-crtkill"
block|,
literal|0
block|,
name|ECHOKE
block|,
literal|"altwerase"
block|,
name|ALTWERASE
block|,
literal|0
block|,
literal|"-altwerase"
block|,
literal|0
block|,
name|ALTWERASE
block|,
literal|"iexten"
block|,
name|IEXTEN
block|,
literal|0
block|,
literal|"-iexten"
block|,
literal|0
block|,
name|IEXTEN
block|,
literal|"echonl"
block|,
name|ECHONL
block|,
literal|0
block|,
literal|"-echonl"
block|,
literal|0
block|,
name|ECHONL
block|,
literal|"echoctl"
block|,
name|ECHOCTL
block|,
literal|0
block|,
literal|"-echoctl"
block|,
literal|0
block|,
name|ECHOCTL
block|,
literal|"ctlecho"
block|,
name|ECHOCTL
block|,
literal|0
block|,
literal|"-ctlecho"
block|,
literal|0
block|,
name|ECHOCTL
block|,
literal|"echoprt"
block|,
name|ECHOPRT
block|,
literal|0
block|,
literal|"-echoprt"
block|,
literal|0
block|,
name|ECHOPRT
block|,
literal|"prterase"
block|,
name|ECHOPRT
block|,
literal|0
block|,
literal|"-prterase"
block|,
literal|0
block|,
name|ECHOPRT
block|,
literal|"isig"
block|,
name|ISIG
block|,
literal|0
block|,
literal|"-isig"
block|,
literal|0
block|,
name|ISIG
block|,
literal|"icanon"
block|,
name|ICANON
block|,
literal|0
block|,
literal|"-icanon"
block|,
literal|0
block|,
name|ICANON
block|,
literal|"noflsh"
block|,
name|NOFLSH
block|,
literal|0
block|,
literal|"-noflsh"
block|,
literal|0
block|,
name|NOFLSH
block|,
literal|"tostop"
block|,
name|TOSTOP
block|,
literal|0
block|,
literal|"-tostop"
block|,
literal|0
block|,
name|TOSTOP
block|,
literal|"mdmbuf"
block|,
name|MDMBUF
block|,
literal|0
block|,
literal|"-mdmbuf"
block|,
literal|0
block|,
name|MDMBUF
block|,
literal|"nohang"
block|,
name|NOHANG
block|,
literal|0
block|,
literal|"-nohang"
block|,
literal|0
block|,
name|NOHANG
block|,
literal|"flusho"
block|,
name|FLUSHO
block|,
literal|0
block|,
literal|"-flusho"
block|,
literal|0
block|,
name|FLUSHO
block|,
literal|"pendin"
block|,
name|PENDIN
block|,
literal|0
block|,
literal|"-pendin"
block|,
literal|0
block|,
name|PENDIN
block|,
literal|"crt"
block|,
name|ECHOE
operator||
name|ECHOKE
operator||
name|ECHOCTL
block|,
name|ECHOK
operator||
name|ECHOPRT
block|,
literal|"-crt"
block|,
name|ECHOK
block|,
name|ECHOE
operator||
name|ECHOKE
operator||
name|ECHOCTL
block|,
literal|"newcrt"
block|,
name|ECHOE
operator||
name|ECHOKE
operator||
name|ECHOCTL
block|,
name|ECHOK
operator||
name|ECHOPRT
block|,
literal|"-newcrt"
block|,
name|ECHOK
block|,
name|ECHOE
operator||
name|ECHOKE
operator||
name|ECHOCTL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special control characters.  *  * Each entry has a list of names.  The first is the primary name  * and is used when printing the control character in the "name = val;"  * form.  The second is an abbreviation which is guaranteed to be less  * than or equal to four characters in length and is primarily used  * when printing the values in columunar form (guarantees all will  * fit within 80 cols).  The rest are optional aliases.  * All names are recognized on the command line.  */
end_comment

begin_define
define|#
directive|define
name|MAXNAMES
value|5
end_define

begin_macro
name|STATIC
end_macro

begin_struct
struct|struct
block|{
name|char
modifier|*
name|names
index|[
name|MAXNAMES
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|sub
decl_stmt|;
name|u_char
name|def
decl_stmt|;
block|}
name|cchars
index|[]
init|=
block|{
block|{
literal|"erase"
block|,
literal|"era"
block|}
block|,
name|VERASE
block|,
name|CERASE
block|,
block|{
literal|"werase"
block|,
literal|"wera"
block|}
block|,
name|VWERASE
block|,
name|CWERASE
block|,
block|{
literal|"kill"
block|,
literal|"kill"
block|}
block|,
name|VKILL
block|,
name|CKILL
block|,
block|{
literal|"intr"
block|,
literal|"int"
block|}
block|,
name|VINTR
block|,
name|CINTR
block|,
block|{
literal|"quit"
block|,
literal|"quit"
block|}
block|,
name|VQUIT
block|,
name|CQUIT
block|,
block|{
literal|"susp"
block|,
literal|"susp"
block|}
block|,
name|VSUSP
block|,
name|CSUSP
block|,
block|{
literal|"dsusp"
block|,
literal|"dsus"
block|}
block|,
name|VDSUSP
block|,
name|CDSUSP
block|,
block|{
literal|"eof"
block|,
literal|"eof"
block|}
block|,
name|VEOF
block|,
name|CEOF
block|,
block|{
literal|"eol"
block|,
literal|"eol"
block|,
literal|"brk"
block|}
block|,
name|VEOL
block|,
name|CEOL
block|,
block|{
literal|"eol2"
block|,
literal|"eol2"
block|}
block|,
name|VEOL2
block|,
name|CEOL
block|,
block|{
literal|"stop"
block|,
literal|"stop"
block|,
literal|"xoff"
block|}
block|,
name|VSTOP
block|,
name|CSTOP
block|,
block|{
literal|"start"
block|,
literal|"star"
block|,
literal|"xon"
block|}
block|,
name|VSTART
block|,
name|CSTART
block|,
block|{
literal|"lnext"
block|,
literal|"lnxt"
block|}
block|,
name|VLNEXT
block|,
name|CLNEXT
block|,
block|{
literal|"flusho"
block|,
literal|"fls"
block|,
literal|"flush"
block|}
block|,
name|VFLUSHO
block|,
name|CFLUSHO
block|,
block|{
literal|"reprint"
block|,
literal|"rpnt"
block|,
literal|"rprnt"
block|}
block|,
name|VREPRINT
block|,
name|CREPRINT
block|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|STATIC
name|struct
name|winsize
name|win
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ldisc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|dodisc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|trace
decl_stmt|,
name|dotrace
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OUT
value|stdout
end_define

begin_comment
comment|/* informational output stream */
end_comment

begin_define
define|#
directive|define
name|ERR
value|stderr
end_define

begin_comment
comment|/* error message stream */
end_comment

begin_define
define|#
directive|define
name|CTL
value|0
end_define

begin_comment
comment|/* default control descriptor */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|ctl
init|=
name|CTL
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern errno;
end_extern

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NORMAL
value|0
end_define

begin_comment
comment|/* only print modes differing from defaults */
end_comment

begin_define
define|#
directive|define
name|ALL
value|1
end_define

begin_comment
comment|/* print all modes - POSIX standard format */
end_comment

begin_define
define|#
directive|define
name|ALL_BSD
value|2
end_define

begin_comment
comment|/* print all modes - using BSD shorthand for cc's */
end_comment

begin_define
define|#
directive|define
name|GFMT
value|3
end_define

begin_comment
comment|/* print modes in a form that can be re-input to stty */
end_comment

begin_function
name|STATIC
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|termios
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fmt
init|=
name|NORMAL
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|eq
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-a"
argument_list|)
condition|)
block|{
name|fmt
operator|=
name|ALL
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|eq
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-f"
argument_list|)
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|=
name|open
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserrexit
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:ga"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
name|ctl
operator|=
name|open
argument_list|(
operator|*
name|optarg
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserrexit
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|fmt
operator|=
name|ALL
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fmt
operator|=
name|GFMT
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|ctl
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
name|syserrexit
argument_list|(
literal|"TIOCGETD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|ctl
argument_list|,
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
name|syserrexit
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|ctl
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"TIOCGWINSZ: %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_43
name|checkredirect
argument_list|()
expr_stmt|;
comment|/* conversion aid */
endif|#
directive|endif
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
name|fmt
condition|)
block|{
name|prmode
argument_list|(
operator|&
name|t
argument_list|,
name|ldisc
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|>
literal|2
operator|&&
operator|*
operator|(
name|argv
index|[
literal|0
index|]
operator|+
literal|2
operator|)
operator|==
literal|':'
condition|)
block|{
name|gfmtset
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|setit
goto|;
block|}
while|while
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
literal|"everything"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|prmode
argument_list|(
operator|&
name|t
argument_list|,
name|ldisc
argument_list|,
name|ALL_BSD
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"all"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|prmode
argument_list|(
operator|&
name|t
argument_list|,
name|ldisc
argument_list|,
name|ALL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"old"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"new"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"nl"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
name|t
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"-nl"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|t
operator|.
name|c_oflag
operator||=
name|ONLCR
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"dec"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0177
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
name|CTRL
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|CTRL
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|t
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHOPRT
expr_stmt|;
name|t
operator|.
name|c_lflag
operator||=
name|ECHOE
operator||
name|ECHOKE
operator||
name|ECHOCTL
expr_stmt|;
name|t
operator|.
name|c_iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"rows"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|argv
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|setit
goto|;
name|win
operator|.
name|ws_row
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"ispeed"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|argv
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"missing ispeed"
argument_list|)
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|t
argument_list|,
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"ospeed"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|argv
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"missing ospeed"
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|t
argument_list|,
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"cols"
argument_list|,
operator|*
name|argv
argument_list|)
operator|||
name|eq
argument_list|(
literal|"columns"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|argv
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|setit
goto|;
name|win
operator|.
name|ws_col
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"size"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|put
argument_list|(
literal|"%d %d\n"
argument_list|,
name|win
operator|.
name|ws_row
argument_list|,
name|win
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eq
argument_list|(
literal|"speed"
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|put
argument_list|(
literal|"%d\n"
argument_list|,
name|cfgetospeed
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|imodes
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eq
argument_list|(
name|imodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_iflag
operator|&=
operator|~
name|imodes
index|[
name|i
index|]
operator|.
name|unset
expr_stmt|;
name|t
operator|.
name|c_iflag
operator||=
name|imodes
index|[
name|i
index|]
operator|.
name|set
expr_stmt|;
goto|goto
name|next
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|omodes
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eq
argument_list|(
name|omodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_oflag
operator|&=
operator|~
name|omodes
index|[
name|i
index|]
operator|.
name|unset
expr_stmt|;
name|t
operator|.
name|c_oflag
operator||=
name|omodes
index|[
name|i
index|]
operator|.
name|set
expr_stmt|;
goto|goto
name|next
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cmodes
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eq
argument_list|(
name|cmodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_cflag
operator|&=
operator|~
name|cmodes
index|[
name|i
index|]
operator|.
name|unset
expr_stmt|;
name|t
operator|.
name|c_cflag
operator||=
name|cmodes
index|[
name|i
index|]
operator|.
name|set
expr_stmt|;
goto|goto
name|next
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lmodes
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eq
argument_list|(
name|lmodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|t
operator|.
name|c_lflag
operator|&=
operator|~
name|lmodes
index|[
name|i
index|]
operator|.
name|unset
expr_stmt|;
name|t
operator|.
name|c_lflag
operator||=
name|lmodes
index|[
name|i
index|]
operator|.
name|set
expr_stmt|;
goto|goto
name|next
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cchars
index|[
name|i
index|]
operator|.
name|names
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|cp
init|=
name|cchars
index|[
name|i
index|]
operator|.
name|names
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
operator|*
name|cp
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
literal|0
condition|)
goto|goto
name|setit
goto|;
if|if
condition|(
name|eq
argument_list|(
operator|*
name|argv
argument_list|,
literal|"undef"
argument_list|)
operator|||
name|eq
argument_list|(
operator|*
name|argv
argument_list|,
literal|"disable"
argument_list|)
condition|)
name|t
operator|.
name|c_cc
index|[
name|cchars
index|[
name|i
index|]
operator|.
name|sub
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'^'
condition|)
name|t
operator|.
name|c_cc
index|[
name|cchars
index|[
name|i
index|]
operator|.
name|sub
index|]
operator|=
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|?
literal|0177
else|:
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|?
name|_POSIX_VDISABLE
else|:
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
operator|&
literal|037
expr_stmt|;
else|else
name|t
operator|.
name|c_cc
index|[
name|cchars
index|[
name|i
index|]
operator|.
name|sub
index|]
operator|=
operator|*
operator|*
name|argv
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
condition|)
block|{
name|cfsetospeed
argument_list|(
operator|&
name|t
argument_list|,
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|t
argument_list|,
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* didn't match anything */
name|errexit
argument_list|(
literal|"unknown option: %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|next
label|:
name|argv
operator|++
expr_stmt|;
block|}
name|setit
label|:
if|if
condition|(
name|tcsetattr
argument_list|(
name|ctl
argument_list|,
literal|0
argument_list|,
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
name|syserrexit
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|ctl
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"can't set window size"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|gfmtset
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|prmode
argument_list|(
argument|tp
argument_list|,
argument|ldisc
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|termios
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|i
init|=
name|tp
operator|->
name|c_iflag
decl_stmt|,
name|o
init|=
name|tp
operator|->
name|c_oflag
decl_stmt|,
name|c
init|=
name|tp
operator|->
name|c_cflag
decl_stmt|,
name|l
init|=
name|tp
operator|->
name|c_lflag
decl_stmt|;
name|u_char
modifier|*
name|cc
init|=
name|tp
operator|->
name|c_cc
decl_stmt|;
name|int
name|ispeed
init|=
name|cfgetispeed
argument_list|(
name|tp
argument_list|)
decl_stmt|,
name|ospeed
init|=
name|cfgetospeed
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|char
name|unknown
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|ld
decl_stmt|;
name|char
modifier|*
name|ccval
parameter_list|()
function_decl|;
comment|/* 	 * line discipline 	 */
if|if
condition|(
name|ldisc
operator|!=
name|TTYDISC
condition|)
block|{
switch|switch
condition|(
name|ldisc
condition|)
block|{
case|case
name|TABLDISC
case|:
name|ld
operator|=
literal|"tablet"
expr_stmt|;
break|break;
case|case
name|SLIPDISC
case|:
name|ld
operator|=
literal|"slip(ed)"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|unknown
argument_list|,
literal|"#%d"
argument_list|,
name|ldisc
argument_list|)
expr_stmt|;
name|ld
operator|=
name|unknown
expr_stmt|;
block|}
name|put
argument_list|(
literal|"%s disc; "
argument_list|,
name|ld
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * line speed 	 */
if|if
condition|(
name|ispeed
operator|!=
name|ospeed
condition|)
name|put
argument_list|(
literal|"ispeed %d baud; ospeed %d baud;"
argument_list|,
name|ispeed
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
else|else
name|put
argument_list|(
literal|"speed %d baud;"
argument_list|,
name|ispeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
name|put
argument_list|(
literal|" %d rows; %d columns;"
argument_list|,
name|win
operator|.
name|ws_row
argument_list|,
name|win
operator|.
name|ws_col
argument_list|)
expr_stmt|;
name|put
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|lput
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|d
parameter_list|)
value|if (fmt || on(f) != d) mdput(n+on(f))
comment|/* 	 * "local" flags 	 */
define|#
directive|define
name|on
parameter_list|(
name|f
parameter_list|)
value|((l&f) != 0)
if|if
condition|(
name|debug
condition|)
name|mdput
argument_list|(
literal|"LFLAG: "
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-icanon "
argument_list|,
name|ICANON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-isig "
argument_list|,
name|ISIG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-iexten "
argument_list|,
name|IEXTEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echo "
argument_list|,
name|ECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echoe "
argument_list|,
name|ECHOE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echok "
argument_list|,
name|ECHOK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echoke "
argument_list|,
name|ECHOKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echonl "
argument_list|,
name|ECHONL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echoctl "
argument_list|,
name|ECHOCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-echoprt "
argument_list|,
name|ECHOPRT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-altwerase "
argument_list|,
name|ALTWERASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-noflsh "
argument_list|,
name|NOFLSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-tostop "
argument_list|,
name|TOSTOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-mdmbuf "
argument_list|,
name|MDMBUF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-nohang "
argument_list|,
name|NOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-flusho "
argument_list|,
name|FLUSHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-pendin "
argument_list|,
name|PENDIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * input flags 	 */
undef|#
directive|undef
name|on
define|#
directive|define
name|on
parameter_list|(
name|f
parameter_list|)
value|((i&f) != 0)
name|mdput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|mdput
argument_list|(
literal|"IFLAG: "
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-istrip "
argument_list|,
name|ISTRIP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-icrnl "
argument_list|,
name|ICRNL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-inlcr "
argument_list|,
name|INLCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-igncr "
argument_list|,
name|IGNCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-ixon "
argument_list|,
name|IXON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-ixoff "
argument_list|,
name|IXOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-ixany "
argument_list|,
name|IXANY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-imaxbel "
argument_list|,
name|IMAXBEL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-ignbrk "
argument_list|,
name|IGNBRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-brkint "
argument_list|,
name|BRKINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-inpck "
argument_list|,
name|INPCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-ignpar "
argument_list|,
name|IGNPAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-parmrk "
argument_list|,
name|PARMRK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|on
comment|/* 	 * output flags 	 */
define|#
directive|define
name|on
parameter_list|(
name|f
parameter_list|)
value|((o&f) != 0)
name|mdput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|mdput
argument_list|(
literal|"OFLAG: "
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-opost "
argument_list|,
name|OPOST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-onlcr "
argument_list|,
name|ONLCR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-oxtabs "
argument_list|,
name|OXTABS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|on
comment|/* 	 * control flags (hardware state) 	 */
define|#
directive|define
name|on
parameter_list|(
name|f
parameter_list|)
value|((c&f) != 0)
name|mdput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|mdput
argument_list|(
literal|"CFLAG: "
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-cread "
argument_list|,
name|CREAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|mdput
argument_list|(
literal|"cs5 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|mdput
argument_list|(
literal|"cs6 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|mdput
argument_list|(
literal|"cs7 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS8
case|:
name|mdput
argument_list|(
literal|"cs8 "
argument_list|)
expr_stmt|;
break|break;
block|}
name|mdput
argument_list|(
literal|"-parenb "
operator|+
name|on
argument_list|(
name|PARENB
argument_list|)
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-parodd "
argument_list|,
name|PARODD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-hupcl "
argument_list|,
name|HUPCL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-clocal "
argument_list|,
name|CLOCAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-cstopb "
argument_list|,
name|CSTOPB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lput
argument_list|(
literal|"-crtscts "
argument_list|,
name|CRTSCTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mdput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|on
comment|/* 	 * special control characters 	 */
if|if
condition|(
name|debug
condition|)
name|mdput
argument_list|(
literal|"CCHARS: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cchars
index|[
name|i
index|]
operator|.
name|names
condition|;
name|i
operator|++
control|)
block|{
name|char
name|temp
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|fmt
operator|||
name|cc
index|[
name|cchars
index|[
name|i
index|]
operator|.
name|sub
index|]
operator|!=
name|cchars
index|[
name|i
index|]
operator|.
name|def
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s = %s; "
argument_list|,
operator|*
name|cchars
index|[
name|i
index|]
operator|.
name|names
argument_list|,
name|ccval
argument_list|(
name|cc
index|[
name|cchars
index|[
name|i
index|]
operator|.
name|sub
index|]
argument_list|)
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|mdput
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|mdput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cchars
index|[
name|i
index|]
operator|.
name|names
condition|;
name|i
operator|++
control|)
name|put
argument_list|(
literal|"%*s"
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
name|cchars
index|[
name|i
index|]
operator|.
name|names
operator|+
literal|1
operator|)
argument_list|)
operator|+
operator|(
name|i
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|*
operator|(
name|cchars
index|[
name|i
index|]
operator|.
name|names
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cchars
index|[
name|i
index|]
operator|.
name|names
condition|;
name|i
operator|++
control|)
name|put
argument_list|(
literal|"%*s"
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
name|cchars
index|[
name|i
index|]
operator|.
name|names
operator|+
literal|1
operator|)
argument_list|)
operator|+
operator|(
name|i
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|ccval
argument_list|(
name|cc
index|[
name|cchars
index|[
name|i
index|]
operator|.
name|sub
index|]
argument_list|,
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43
end_ifdef

begin_comment
comment|/*  * gross, but since we're changing the control descriptor  * from 1 to 0, most users will be probably be doing  * "stty> /dev/sometty" by accident. If 1 and 2 are both ttys,   * but not the same, assume that 1 was incorrectly redirected.  */
end_comment

begin_macro
name|checkredirect
argument_list|()
end_macro

begin_block
block|{
name|struct
name|stat
name|st1
decl_stmt|,
name|st2
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|2
argument_list|)
operator|&&
name|fstat
argument_list|(
literal|1
argument_list|,
operator|&
name|st1
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|fstat
argument_list|(
literal|2
argument_list|,
operator|&
name|st2
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|st1
operator|.
name|st_rdev
operator|!=
name|st2
operator|.
name|st_rdev
operator|)
condition|)
name|warning
argument_list|(
literal|"stdout appears redirected, but stdin is the control descriptor"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|char
modifier|*
name|ccval
parameter_list|(
name|c
parameter_list|,
name|fmt
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
operator|*
name|buf
operator|=
literal|0
operator|,
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|_POSIX_VDISABLE
condition|)
if|if
condition|(
name|fmt
operator|==
literal|2
condition|)
return|return
operator|(
literal|"<u>"
operator|)
return|;
else|else
return|return
operator|(
literal|"<undef>"
operator|)
return|;
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|&=
literal|0177
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|040
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|c
operator|+
literal|'@'
expr_stmt|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|mdput
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|col
condition|)
block|{
name|put
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|col
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|>
name|WRAPCOL
condition|)
block|{
name|put
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|col
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|put
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|put
parameter_list|(
name|f
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|_doprnt
argument_list|(
name|f
argument_list|,
operator|&
name|a
argument_list|,
name|OUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|warning
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|ERR
argument_list|,
literal|"stty: warning: "
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|s
argument_list|,
operator|&
name|a
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ERR
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|errexit
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|ERR
argument_list|,
literal|"stty: "
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|s
argument_list|,
operator|&
name|a
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ERR
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|syserrexit
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|ERR
argument_list|,
literal|"stty: "
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|s
argument_list|,
operator|&
name|a
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ERR
argument_list|,
literal|": %s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

