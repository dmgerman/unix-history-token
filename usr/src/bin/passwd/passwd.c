begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)passwd.c	4.32 (Berkeley) 1/21/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Modify a field in the password file (either password, login shell, or  * gecos field).  This program should be suid with an owner with write  * permission on /etc/passwd.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ndbm.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * This should be the first thing returned from a getloginshells()  * but too many programs know that it is /bin/sh.  */
end_comment

begin_define
define|#
directive|define
name|DEFSHELL
value|"/bin/sh"
end_define

begin_define
define|#
directive|define
name|DICT
value|"/usr/dict/words"
end_define

begin_define
define|#
directive|define
name|PASSWD
value|"/etc/passwd"
end_define

begin_define
define|#
directive|define
name|PTEMP
value|"/etc/ptmp"
end_define

begin_define
define|#
directive|define
name|EOS
value|'\0';
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|,
name|optind
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|FILE
modifier|*
name|tf
decl_stmt|;
name|DBM
modifier|*
name|dp
decl_stmt|;
name|uid_t
name|uid
decl_stmt|,
name|getuid
argument_list|()
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|fd
decl_stmt|,
name|dochfn
decl_stmt|,
name|dochsh
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|uname
decl_stmt|,
modifier|*
name|progname
decl_stmt|,
modifier|*
name|umsg
decl_stmt|,
modifier|*
name|getfingerinfo
argument_list|()
decl_stmt|,
modifier|*
name|getloginshell
argument_list|()
decl_stmt|,
modifier|*
name|getnewpasswd
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
name|progname
operator|=
operator|(
name|cp
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|?
name|cp
operator|+
literal|1
else|:
operator|*
name|argv
expr_stmt|;
name|dochfn
operator|=
name|dochsh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"chfn"
argument_list|)
condition|)
block|{
name|dochfn
operator|=
literal|1
expr_stmt|;
name|umsg
operator|=
literal|"usage: chfn [username]\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"chsh"
argument_list|)
condition|)
block|{
name|dochsh
operator|=
literal|1
expr_stmt|;
name|umsg
operator|=
literal|"usage: chsh [username]\n"
expr_stmt|;
block|}
else|else
name|umsg
operator|=
literal|"usage: passwd [-fs] [username]\n"
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fs"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|dochsh
condition|)
goto|goto
name|usage
goto|;
name|dochfn
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|dochfn
condition|)
goto|goto
name|usage
goto|;
name|dochsh
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
label|:
name|fputs
argument_list|(
name|umsg
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|-
name|optind
operator|<
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %u: unknown user uid.\n"
argument_list|,
name|progname
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|uname
operator|=
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of space.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|uname
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uname
operator|=
operator|*
operator|(
name|argv
operator|+
name|optind
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|uname
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: unknown user.\n"
argument_list|,
name|progname
argument_list|,
name|uname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uid
operator|&&
name|uid
operator|!=
name|pwd
operator|->
name|pw_uid
condition|)
block|{
name|fputs
argument_list|(
literal|"Permission denied.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Changing %s for %s.\n"
argument_list|,
name|dochfn
condition|?
literal|"finger information"
else|:
name|dochsh
condition|?
literal|"login shell"
else|:
literal|"password"
argument_list|,
name|uname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dochfn
condition|)
name|cp
operator|=
name|getfingerinfo
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dochsh
condition|)
name|cp
operator|=
name|getloginshell
argument_list|(
name|pwd
argument_list|,
name|uid
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|getnewpasswd
argument_list|(
name|pwd
argument_list|,
name|uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|PTEMP
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: password file busy - try again.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: "
argument_list|,
name|progname
argument_list|,
name|PTEMP
argument_list|)
expr_stmt|;
name|perror
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tf
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: fdopen failed.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|dbm_open
argument_list|(
name|PASSWD
argument_list|,
name|O_RDWR
argument_list|,
literal|0644
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: dbm_open failed: %s: "
argument_list|,
name|PASSWD
argument_list|)
expr_stmt|;
name|perror
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flock
argument_list|(
name|dp
operator|->
name|dbm_dirf
argument_list|,
name|LOCK_EX
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Warning: lock failed"
argument_list|)
expr_stmt|;
name|dbm_close
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|unlimit
argument_list|(
name|RLIMIT_CPU
argument_list|)
expr_stmt|;
name|unlimit
argument_list|(
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Copy passwd to temp, replacing matching lines 	 * with new password. 	 */
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|uname
argument_list|)
condition|)
block|{
if|if
condition|(
name|uid
operator|&&
name|uid
operator|!=
name|pwd
operator|->
name|pw_uid
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: permission denied.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dochfn
condition|)
name|pwd
operator|->
name|pw_gecos
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
name|dochsh
condition|)
name|pwd
operator|->
name|pw_shell
operator|=
name|cp
expr_stmt|;
else|else
name|pwd
operator|->
name|pw_passwd
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_gecos
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
comment|/* ??? */
name|pwd
operator|->
name|pw_gecos
operator|++
expr_stmt|;
name|replace
argument_list|(
name|dp
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%s:%s:%d:%d:%s:%s:%s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
block|}
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|&&
name|dbm_error
argument_list|(
name|dp
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"Warning: dbm_store failed.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|tf
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: %s write error, %s not updated.\n"
argument_list|,
name|PTEMP
argument_list|,
name|PASSWD
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|dbm_close
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|PTEMP
argument_list|,
name|PASSWD
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|out
label|:
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|PTEMP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|unlimit
argument_list|(
argument|lim
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lim
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
operator|=
name|RLIM_INFINITY
expr_stmt|;
operator|(
name|void
operator|)
name|setrlimit
argument_list|(
name|lim
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Replace the password entry in the dbm data base with pwd.  */
end_comment

begin_macro
name|replace
argument_list|(
argument|dp
argument_list|,
argument|pwd
argument_list|)
end_macro

begin_decl_stmt
name|DBM
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|datum
name|key
decl_stmt|,
name|content
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
name|cp
operator|=
name|buf
expr_stmt|;
define|#
directive|define
name|COMPACT
parameter_list|(
name|e
parameter_list|)
value|tp = pwd->e; while (*cp++ = *tp++);
name|COMPACT
argument_list|(
name|pw_name
argument_list|)
expr_stmt|;
name|COMPACT
argument_list|(
name|pw_passwd
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pwd
operator|->
name|pw_uid
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pwd
operator|->
name|pw_gid
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pwd
operator|->
name|pw_quota
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|COMPACT
argument_list|(
name|pw_comment
argument_list|)
expr_stmt|;
name|COMPACT
argument_list|(
name|pw_gecos
argument_list|)
expr_stmt|;
name|COMPACT
argument_list|(
name|pw_dir
argument_list|)
expr_stmt|;
name|COMPACT
argument_list|(
name|pw_shell
argument_list|)
expr_stmt|;
name|content
operator|.
name|dptr
operator|=
name|buf
expr_stmt|;
name|content
operator|.
name|dsize
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
name|key
operator|.
name|dptr
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|dbm_store
argument_list|(
name|dp
argument_list|,
name|key
argument_list|,
name|content
argument_list|,
name|DBM_REPLACE
argument_list|)
expr_stmt|;
name|key
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|dbm_store
argument_list|(
name|dp
argument_list|,
name|key
argument_list|,
name|content
argument_list|,
name|DBM_REPLACE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|getnewpasswd
parameter_list|(
name|pwd
parameter_list|,
name|u
parameter_list|)
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|uid_t
name|u
decl_stmt|;
block|{
name|time_t
name|salt
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|insist
decl_stmt|;
name|char
modifier|*
name|pw
decl_stmt|,
name|pwbuf
index|[
literal|10
index|]
decl_stmt|,
name|pwcopy
index|[
literal|10
index|]
decl_stmt|,
name|saltc
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|crypt
argument_list|()
decl_stmt|,
modifier|*
name|getpass
argument_list|()
decl_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|&&
name|u
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pwbuf
argument_list|,
name|getpass
argument_list|(
literal|"Old password:"
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|=
name|crypt
argument_list|(
name|pwbuf
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pw
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"Sorry."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pwbuf
argument_list|,
name|getpass
argument_list|(
literal|"New password:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pwbuf
condition|)
block|{
name|puts
argument_list|(
literal|"Password unchanged."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|pwbuf
argument_list|,
name|pwcopy
argument_list|)
condition|)
block|{
name|insist
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pwcopy
argument_list|,
name|pwbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|insist
operator|==
literal|4
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|pwbuf
argument_list|)
operator|<=
literal|4
condition|)
name|puts
argument_list|(
literal|"Please enter a longer password."
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|pw
operator|=
name|pwbuf
init|;
operator|*
name|pw
operator|&&
name|islower
argument_list|(
operator|*
name|pw
argument_list|)
condition|;
operator|++
name|pw
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|pw
condition|)
break|break;
name|puts
argument_list|(
literal|"Please don't use an all-lower case password.\nUnusual capitalization, control characters or digits are suggested."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|pwbuf
argument_list|,
name|getpass
argument_list|(
literal|"Retype new password:"
argument_list|)
argument_list|)
condition|)
block|{
name|puts
argument_list|(
literal|"Mismatch - password unchanged."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|salt
argument_list|)
expr_stmt|;
name|salt
operator|=
literal|9
operator|*
name|getpid
argument_list|()
expr_stmt|;
name|saltc
index|[
literal|0
index|]
operator|=
name|salt
operator|&
literal|077
expr_stmt|;
name|saltc
index|[
literal|1
index|]
operator|=
operator|(
name|salt
operator|>>
literal|6
operator|)
operator|&
literal|077
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|saltc
index|[
name|i
index|]
operator|+
literal|'.'
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'9'
condition|)
name|c
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'Z'
condition|)
name|c
operator|+=
literal|6
expr_stmt|;
name|saltc
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|crypt
argument_list|(
name|pwbuf
argument_list|,
name|saltc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getloginshell
parameter_list|(
name|pwd
parameter_list|,
name|u
parameter_list|)
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|uid_t
name|u
decl_stmt|;
block|{
specifier|static
name|char
name|newshell
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|valid
decl_stmt|,
modifier|*
name|getusershell
argument_list|()
decl_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_shell
operator|==
literal|0
operator|||
operator|*
name|pwd
operator|->
name|pw_shell
operator|==
literal|'\0'
condition|)
name|pwd
operator|->
name|pw_shell
operator|=
name|DEFSHELL
expr_stmt|;
if|if
condition|(
name|u
operator|!=
literal|0
condition|)
block|{
do|do
block|{
name|valid
operator|=
name|getusershell
argument_list|()
expr_stmt|;
if|if
condition|(
name|valid
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot change from restricted shell %s\n"
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
name|valid
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
name|printf
argument_list|(
literal|"Old shell: %s\nNew shell: "
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|newshell
argument_list|,
sizeof|sizeof
argument_list|(
name|newshell
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|newshell
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|newshell
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"Login shell unchanged."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allow user to give shell name w/o preceding pathname. 	 */
if|if
condition|(
name|u
operator|!=
literal|0
operator|||
name|newshell
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|endusershell
argument_list|()
expr_stmt|;
do|do
block|{
name|valid
operator|=
name|getusershell
argument_list|()
expr_stmt|;
if|if
condition|(
name|valid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|u
operator|==
literal|0
condition|)
block|{
name|valid
operator|=
name|newshell
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s is unacceptable as a new shell.\n"
argument_list|,
name|newshell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newshell
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|cp
operator|=
name|valid
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|rindex
argument_list|(
name|valid
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
name|valid
expr_stmt|;
else|else
name|cp
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|newshell
argument_list|,
name|cp
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
else|else
name|valid
operator|=
name|newshell
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|valid
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"Login shell unchanged."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
name|valid
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s is unavailable.\n"
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|valid
argument_list|,
name|DEFSHELL
argument_list|)
operator|==
literal|0
condition|)
name|valid
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|valid
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|default_values
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|office_num
decl_stmt|;
name|char
modifier|*
name|office_phone
decl_stmt|;
name|char
modifier|*
name|home_phone
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Get name, room number, school phone, and home phone.  */
end_comment

begin_function
name|char
modifier|*
name|getfingerinfo
parameter_list|(
name|pwd
parameter_list|)
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
block|{
name|char
name|in_str
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|default_values
modifier|*
name|defaults
decl_stmt|,
modifier|*
name|get_defaults
argument_list|()
decl_stmt|;
specifier|static
name|char
name|answer
index|[
literal|4
operator|*
name|BUFSIZ
index|]
decl_stmt|;
name|answer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|defaults
operator|=
name|get_defaults
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Default values are printed inside of '[]'."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"To accept the default, type<return>."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"To have a blank entry, type the word 'none'."
argument_list|)
expr_stmt|;
comment|/* 	 * Get name. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"\nName [%s]: "
argument_list|,
name|defaults
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|name
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|answer
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
comment|/* 	 * Get room number. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"Room number (Exs: 597E or 197C) [%s]: "
argument_list|,
name|defaults
operator|->
name|office_num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|office_num
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
operator|||
name|illegal_building
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|answer
argument_list|,
literal|","
argument_list|)
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
comment|/* 	 * Get office phone number. 	 * Remove hyphens. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"Office Phone (Ex: 6426000) [%s]: "
argument_list|,
name|defaults
operator|->
name|office_phone
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|office_phone
argument_list|)
condition|)
break|break;
name|remove_hyphens
argument_list|(
name|in_str
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
operator|||
name|not_all_digits
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|answer
argument_list|,
literal|","
argument_list|)
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
comment|/* 	 * Get home phone number. 	 * Remove hyphens if present. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"Home Phone (Ex: 9875432) [%s]: "
argument_list|,
name|defaults
operator|->
name|home_phone
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|home_phone
argument_list|)
condition|)
break|break;
name|remove_hyphens
argument_list|(
name|in_str
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
operator|||
name|not_all_digits
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|answer
argument_list|,
literal|","
argument_list|)
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|)
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"Finger information unchanged."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prints an error message if a ':', ',' or a newline is found in the string.  * A message is also printed if the input string is too long.  The password  * file uses :'s as separators, and are not allowed in the "gcos" field;  * commas are used as separators in the gcos field, so are disallowed.  * Newlines serve as delimiters between users in the password file, and so,  * those too, are checked for.  (I don't think that it is possible to  * type them in, but better safe than sorry)  *  * Returns '1' if a colon, comma or newline is found or the input line is  * too long.  */
end_comment

begin_macro
name|illegal_input
argument_list|(
argument|input_str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|input_str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|input_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|strpbrk
argument_list|(
name|input_str
argument_list|,
literal|",:"
argument_list|)
condition|)
block|{
name|puts
argument_list|(
literal|"':' and ',' are not allowed."
argument_list|)
expr_stmt|;
name|error_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|input_str
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* the newline and the '\0' eat up two characters */
name|printf
argument_list|(
literal|"Maximum number of characters allowed is %d\n"
argument_list|,
name|BUFSIZ
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* flush the rest of the input line */
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
comment|/* void */
empty_stmt|;
name|error_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Delete newline by shortening string by 1. 	 */
name|input_str
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Don't allow control characters, etc in input string. 	 */
for|for
control|(
name|ptr
operator|=
name|input_str
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
name|puts
argument_list|(
literal|"Control characters are not allowed."
argument_list|)
expr_stmt|;
name|error_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error_flag
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Removes '-'s from the input string.  */
end_comment

begin_macro
name|remove_hyphens
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|hyphen
decl_stmt|;
while|while
condition|(
operator|(
name|hyphen
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hyphen
argument_list|,
name|hyphen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Checks to see if 'str' contains only digits (0-9).  If not, then  *  an error message is printed and '1' is returned.  */
end_comment

begin_expr_stmt
name|not_all_digits
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|str
condition|;
operator|++
name|str
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|puts
argument_list|(
literal|"Phone numbers may only contain digits."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Deal with Berkeley buildings.  Abbreviating Cory to C and Evans to E.  * Correction changes "str".  *  * Returns 1 if incorrect room format.  *   * Note: this function assumes that the newline has been removed from str.  */
end_comment

begin_expr_stmt
name|illegal_building
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * If the string is [Ee]vans or [Cc]ory or ends in 	 * [ \t0-9][Ee]vans or [ \t0-9M][Cc]ory, then contract the name 	 * into 'E' or 'C', as the case may be, and delete leading blanks. 	 */
if|if
condition|(
name|length
operator|>=
literal|5
operator|&&
name|strcmp
argument_list|(
name|ptr
operator|=
name|str
operator|+
name|length
operator|-
literal|4
argument_list|,
literal|"vans"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
operator|--
name|ptr
operator|==
literal|'e'
operator|||
operator|*
name|ptr
operator|==
literal|'E'
operator|)
operator|&&
operator|(
operator|--
name|ptr
operator|<
name|str
operator|||
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
init|;
name|ptr
operator|>
name|str
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
name|ptr
operator|--
control|)
empty_stmt|;
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>=
literal|4
operator|&&
name|strcmp
argument_list|(
name|ptr
operator|=
name|str
operator|+
name|length
operator|-
literal|3
argument_list|,
literal|"ory"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
operator|--
name|ptr
operator|==
literal|'c'
operator|||
operator|*
name|ptr
operator|==
literal|'C'
operator|)
operator|&&
operator|(
operator|--
name|ptr
operator|<
name|str
operator|||
operator|*
name|ptr
operator|==
literal|'M'
operator|||
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
init|;
name|ptr
operator|>
name|str
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
name|ptr
operator|--
control|)
empty_stmt|;
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * get_defaults picks apart "str" and returns a structure points.  * "str" contains up to 4 fields separated by commas.  * Any field that is missing is set to blank.  */
end_comment

begin_function
name|struct
name|default_values
modifier|*
name|get_defaults
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|default_values
modifier|*
name|answer
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|answer
operator|=
operator|(
expr|struct
name|default_values
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|default_values
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
operator|(
expr|struct
name|default_values
operator|*
operator|)
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"\nUnable to allocate storage in get_defaults!\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Values if no corresponding string in "str". 	 */
name|answer
operator|->
name|name
operator|=
name|str
expr_stmt|;
name|answer
operator|->
name|office_num
operator|=
literal|""
expr_stmt|;
name|answer
operator|->
name|office_phone
operator|=
literal|""
expr_stmt|;
name|answer
operator|->
name|home_phone
operator|=
literal|""
expr_stmt|;
name|str
operator|=
name|index
argument_list|(
name|answer
operator|->
name|name
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|answer
operator|)
return|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|->
name|office_num
operator|=
name|str
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|index
argument_list|(
name|answer
operator|->
name|office_num
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|answer
operator|)
return|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|->
name|office_phone
operator|=
name|str
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|index
argument_list|(
name|answer
operator|->
name|office_phone
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|answer
operator|)
return|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|->
name|home_phone
operator|=
name|str
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  special_case returns true when either the default is accepted  *  (str = '\n'), or when 'none' is typed.  'none' is accepted in  *  either upper or lower case (or any combination).  'str' is modified  *  in these two cases.  */
end_comment

begin_macro
name|special_case
argument_list|(
argument|str
argument_list|,
argument|default_str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|default_str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|word
index|[]
init|=
literal|"none\n"
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|wordptr
decl_stmt|;
comment|/* 	 *  If the default is accepted, then change the old string do the  	 *  default string. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|default_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 *  Check to see if str is 'none'.  (It is questionable if case 	 *  insensitivity is worth the hair). 	 */
name|wordptr
operator|=
name|word
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|str
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
operator|++
name|ptr
control|)
block|{
operator|++
name|wordptr
expr_stmt|;
if|if
condition|(
operator|*
name|wordptr
operator|==
literal|'\0'
condition|)
comment|/* then words are different sizes */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
operator|*
name|wordptr
condition|)
continue|continue;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
name|ptr
argument_list|)
operator|==
operator|*
name|wordptr
operator|)
condition|)
continue|continue;
comment|/* 		 * At this point we have a mismatch, so we return 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make sure that words are the same length. 	 */
if|if
condition|(
operator|*
operator|(
name|wordptr
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Change 'str' to be the null string 	 */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

