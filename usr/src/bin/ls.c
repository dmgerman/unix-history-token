begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ls.c	5.9 (Berkeley) 10/22/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * ls  *  * 4.2bsd version for symbolic links, variable length  * directory entries, block size in the inode, etc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|kbytes
parameter_list|(
name|size
parameter_list|)
value|(((size) + 1023) / 1024)
end_define

begin_struct
struct|struct
name|afile
block|{
name|char
name|ftype
decl_stmt|;
comment|/* file type, e.g. 'd', 'c', 'f' */
name|ino_t
name|fnum
decl_stmt|;
comment|/* inode number of file */
name|short
name|fflags
decl_stmt|;
comment|/* mode&~S_IFMT, perhaps ISARG */
name|short
name|fnl
decl_stmt|;
comment|/* number of links */
name|uid_t
name|fuid
decl_stmt|;
comment|/* owner id */
name|gid_t
name|fgid
decl_stmt|;
comment|/* group id */
name|off_t
name|fsize
decl_stmt|;
comment|/* file size */
name|long
name|fblks
decl_stmt|;
comment|/* number of blocks used */
name|time_t
name|fmtime
decl_stmt|;
comment|/* time (modify or access or create) */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* file name */
name|char
modifier|*
name|flinkto
decl_stmt|;
comment|/* symbolic link value */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ISARG
value|0x8000
end_define

begin_comment
comment|/* extra ``mode'' */
end_comment

begin_struct
struct|struct
name|subdirs
block|{
name|char
modifier|*
name|sd_name
decl_stmt|;
name|struct
name|subdirs
modifier|*
name|sd_next
decl_stmt|;
block|}
modifier|*
name|subdirs
struct|;
end_struct

begin_decl_stmt
name|int
name|aflg
decl_stmt|,
name|dflg
decl_stmt|,
name|gflg
decl_stmt|,
name|lflg
decl_stmt|,
name|sflg
decl_stmt|,
name|tflg
decl_stmt|,
name|uflg
decl_stmt|,
name|iflg
decl_stmt|,
name|fflg
decl_stmt|,
name|cflg
decl_stmt|,
name|rflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qflg
decl_stmt|,
name|Aflg
decl_stmt|,
name|Cflg
decl_stmt|,
name|Fflg
decl_stmt|,
name|Lflg
decl_stmt|,
name|Rflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usetabs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|now
decl_stmt|,
name|sixmonthsago
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dotp
init|=
literal|"."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|winsize
name|win
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|twidth
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|afile
modifier|*
name|gstat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fcmp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|cat
argument_list|()
decl_stmt|,
modifier|*
name|savestr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|fmtentry
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|getname
argument_list|()
decl_stmt|,
modifier|*
name|getgroup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|int
name|optind
decl_stmt|;
name|struct
name|afile
modifier|*
name|fp0
decl_stmt|,
modifier|*
name|fplast
decl_stmt|;
specifier|register
name|struct
name|afile
modifier|*
name|fp
decl_stmt|;
name|struct
name|sgttyb
name|sgbuf
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
name|time_t
name|time
parameter_list|()
function_decl|;
name|Aflg
operator|=
operator|!
name|getuid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|sixmonthsago
operator|=
name|now
operator|-
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
expr_stmt|;
name|now
operator|+=
literal|60
expr_stmt|;
name|twidth
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|qflg
operator|=
name|Cflg
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|sgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|twidth
operator|=
operator|(
name|win
operator|.
name|ws_col
operator|==
literal|0
condition|?
literal|80
else|:
name|win
operator|.
name|ws_col
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgbuf
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
operator|!=
name|XTABS
condition|)
name|usetabs
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|usetabs
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"1ACLFRacdfgilqrstu"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'1'
case|:
name|Cflg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|Aflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|Cflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|Lflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|Fflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|Rflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|aflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|gflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|iflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|qflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rflg
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fputs
argument_list|(
literal|"usage: ls [ -1ACLFRacdfgilqrstu ] [ file ]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflg
condition|)
block|{
name|aflg
operator|++
expr_stmt|;
name|lflg
operator|=
literal|0
expr_stmt|;
name|sflg
operator|=
literal|0
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lflg
condition|)
name|Cflg
operator|=
literal|0
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argc
operator|++
expr_stmt|;
name|argv
operator|=
operator|&
name|dotp
expr_stmt|;
block|}
name|fp
operator|=
operator|(
expr|struct
name|afile
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|u_int
operator|)
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|afile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"ls: out of memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fp0
operator|=
name|fp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gstat
argument_list|(
name|fp
argument_list|,
operator|*
name|argv
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fname
operator|=
operator|*
name|argv
expr_stmt|;
name|fp
operator|->
name|fflags
operator||=
name|ISARG
expr_stmt|;
name|fp
operator|++
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
name|fplast
operator|=
name|fp
expr_stmt|;
name|qsort
argument_list|(
name|fp0
argument_list|,
name|fplast
operator|-
name|fp0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|afile
argument_list|)
argument_list|,
name|fcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflg
condition|)
block|{
name|formatf
argument_list|(
name|fp0
argument_list|,
name|fplast
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflg
condition|)
name|fp
operator|=
name|fp0
expr_stmt|;
else|else
block|{
for|for
control|(
name|fp
operator|=
name|fp0
init|;
name|fp
operator|<
name|fplast
operator|&&
name|fp
operator|->
name|ftype
operator|!=
literal|'d'
condition|;
name|fp
operator|++
control|)
continue|continue;
name|formatf
argument_list|(
name|fp0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|<
name|fplast
condition|)
block|{
if|if
condition|(
name|fp
operator|>
name|fp0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|formatd
argument_list|(
name|fp
operator|->
name|fname
argument_list|,
name|argc
operator|>
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|subdirs
condition|)
block|{
name|struct
name|subdirs
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|subdirs
expr_stmt|;
name|subdirs
operator|=
name|t
operator|->
name|sd_next
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|formatd
argument_list|(
name|t
operator|->
name|sd_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|t
operator|->
name|sd_name
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|fp
operator|==
name|fplast
condition|)
break|break;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|formatd
argument_list|(
argument|name
argument_list|,
argument|title
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|title
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|afile
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|subdirs
modifier|*
name|dp
decl_stmt|;
name|struct
name|afile
modifier|*
name|dfp0
decl_stmt|,
modifier|*
name|dfplast
decl_stmt|;
name|int
name|nkb
decl_stmt|;
name|nkb
operator|=
name|getdir
argument_list|(
name|name
argument_list|,
operator|&
name|dfp0
argument_list|,
operator|&
name|dfplast
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfp0
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fflg
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|dfp0
argument_list|,
name|dfplast
operator|-
name|dfp0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|afile
argument_list|)
argument_list|,
name|fcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|title
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflg
operator|||
name|sflg
condition|)
name|printf
argument_list|(
literal|"total %d\n"
argument_list|,
name|nkb
argument_list|)
expr_stmt|;
name|formatf
argument_list|(
name|dfp0
argument_list|,
name|dfplast
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rflg
condition|)
for|for
control|(
name|fp
operator|=
name|dfplast
operator|-
literal|1
init|;
name|fp
operator|>=
name|dfp0
condition|;
name|fp
operator|--
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftype
operator|!=
literal|'d'
operator|||
operator|!
name|strcmp
argument_list|(
name|fp
operator|->
name|fname
argument_list|,
literal|"."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|fp
operator|->
name|fname
argument_list|,
literal|".."
argument_list|)
condition|)
continue|continue;
name|dp
operator|=
operator|(
expr|struct
name|subdirs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subdirs
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|sd_name
operator|=
name|savestr
argument_list|(
name|cat
argument_list|(
name|name
argument_list|,
name|fp
operator|->
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|sd_next
operator|=
name|subdirs
expr_stmt|;
name|subdirs
operator|=
name|dp
expr_stmt|;
block|}
for|for
control|(
name|fp
operator|=
name|dfp0
init|;
name|fp
operator|<
name|dfplast
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fflags
operator|&
name|ISARG
operator|)
operator|==
literal|0
operator|&&
name|fp
operator|->
name|fname
condition|)
name|cfree
argument_list|(
name|fp
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|flinkto
condition|)
name|cfree
argument_list|(
name|fp
operator|->
name|flinkto
argument_list|)
expr_stmt|;
block|}
name|cfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dfp0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getdir
argument_list|(
argument|dir
argument_list|,
argument|pfp0
argument_list|,
argument|pfplast
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|afile
modifier|*
modifier|*
name|pfp0
decl_stmt|,
modifier|*
modifier|*
name|pfplast
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|afile
modifier|*
name|fp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|int
name|nb
decl_stmt|,
name|nent
init|=
literal|20
decl_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
operator|*
name|pfp0
operator|=
operator|*
name|pfplast
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"%s unreadable\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* not stderr! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fp
operator|=
operator|*
name|pfp0
operator|=
operator|(
expr|struct
name|afile
operator|*
operator|)
name|calloc
argument_list|(
name|nent
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|afile
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pfplast
operator|=
operator|*
name|pfp0
operator|+
name|nent
expr_stmt|;
name|nb
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|aflg
operator|==
literal|0
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|Aflg
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|gstat
argument_list|(
name|fp
argument_list|,
name|cat
argument_list|(
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
argument_list|,
name|Fflg
operator|+
name|Rflg
argument_list|,
operator|&
name|nb
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|fp
operator|->
name|fnum
operator|=
name|dp
operator|->
name|d_ino
expr_stmt|;
name|fp
operator|->
name|fname
operator|=
name|savestr
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|fp
operator|==
operator|*
name|pfplast
condition|)
block|{
operator|*
name|pfp0
operator|=
operator|(
expr|struct
name|afile
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|pfp0
argument_list|,
literal|2
operator|*
name|nent
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|afile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pfp0
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"ls: out of memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
operator|*
name|pfp0
operator|+
name|nent
expr_stmt|;
operator|*
name|pfplast
operator|=
name|fp
operator|+
name|nent
expr_stmt|;
name|nent
operator|*=
literal|2
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
operator|*
name|pfplast
operator|=
name|fp
expr_stmt|;
return|return
operator|(
name|kbytes
argument_list|(
name|dbtob
argument_list|(
name|nb
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|stat
argument_list|()
decl_stmt|,
name|lstat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|afile
modifier|*
name|gstat
parameter_list|(
name|fp
parameter_list|,
name|file
parameter_list|,
name|statarg
parameter_list|,
name|pnb
parameter_list|)
specifier|register
name|struct
name|afile
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|statarg
decl_stmt|,
decl|*
name|pnb
decl_stmt|;
end_function

begin_block
block|{
name|int
function_decl|(
modifier|*
name|statf
function_decl|)
parameter_list|()
init|=
name|Lflg
condition|?
name|stat
operator|:
name|lstat
function_decl|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|cc
decl_stmt|;
specifier|static
name|struct
name|afile
name|azerofile
decl_stmt|;
operator|*
name|fp
operator|=
name|azerofile
expr_stmt|;
name|fp
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fnum
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|ftype
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|statarg
operator|||
name|sflg
operator|||
name|lflg
operator|||
name|tflg
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|,
name|stb1
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|statf
call|)
argument_list|(
name|file
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|statf
operator|==
name|lstat
operator|||
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s not found\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|fp
operator|->
name|fblks
operator|=
name|stb
operator|.
name|st_blocks
expr_stmt|;
name|fp
operator|->
name|fsize
operator|=
name|stb
operator|.
name|st_size
expr_stmt|;
switch|switch
condition|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|fp
operator|->
name|ftype
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|fp
operator|->
name|ftype
operator|=
literal|'b'
expr_stmt|;
name|fp
operator|->
name|fsize
operator|=
name|stb
operator|.
name|st_rdev
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|fp
operator|->
name|ftype
operator|=
literal|'c'
expr_stmt|;
name|fp
operator|->
name|fsize
operator|=
name|stb
operator|.
name|st_rdev
expr_stmt|;
break|break;
case|case
name|S_IFSOCK
case|:
name|fp
operator|->
name|ftype
operator|=
literal|'s'
expr_stmt|;
name|fp
operator|->
name|fsize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
name|fp
operator|->
name|ftype
operator|=
literal|'l'
expr_stmt|;
if|if
condition|(
name|lflg
condition|)
block|{
name|cc
operator|=
name|readlink
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|>=
literal|0
condition|)
block|{
name|buf
index|[
name|cc
index|]
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|flinkto
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stb1
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|stb1
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|stb
operator|=
name|stb1
expr_stmt|;
name|fp
operator|->
name|ftype
operator|=
literal|'d'
expr_stmt|;
name|fp
operator|->
name|fsize
operator|=
name|stb
operator|.
name|st_size
expr_stmt|;
name|fp
operator|->
name|fblks
operator|=
name|stb
operator|.
name|st_blocks
expr_stmt|;
block|}
break|break;
block|}
name|fp
operator|->
name|fnum
operator|=
name|stb
operator|.
name|st_ino
expr_stmt|;
name|fp
operator|->
name|fflags
operator|=
name|stb
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
name|fp
operator|->
name|fnl
operator|=
name|stb
operator|.
name|st_nlink
expr_stmt|;
name|fp
operator|->
name|fuid
operator|=
name|stb
operator|.
name|st_uid
expr_stmt|;
name|fp
operator|->
name|fgid
operator|=
name|stb
operator|.
name|st_gid
expr_stmt|;
if|if
condition|(
name|uflg
condition|)
name|fp
operator|->
name|fmtime
operator|=
name|stb
operator|.
name|st_atime
expr_stmt|;
elseif|else
if|if
condition|(
name|cflg
condition|)
name|fp
operator|->
name|fmtime
operator|=
name|stb
operator|.
name|st_ctime
expr_stmt|;
else|else
name|fp
operator|->
name|fmtime
operator|=
name|stb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|pnb
condition|)
operator|*
name|pnb
operator|+=
name|stb
operator|.
name|st_blocks
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_block

begin_macro
name|formatf
argument_list|(
argument|fp0
argument_list|,
argument|fplast
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|afile
modifier|*
name|fp0
decl_stmt|,
modifier|*
name|fplast
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|afile
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|w
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|,
name|nentry
init|=
name|fplast
operator|-
name|fp0
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|lines
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|fp0
operator|==
name|fplast
condition|)
return|return;
if|if
condition|(
name|lflg
operator|||
name|Cflg
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|fp
operator|=
name|fp0
init|;
name|fp
operator|<
name|fplast
condition|;
name|fp
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|fmtentry
argument_list|(
name|fp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|width
condition|)
name|width
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|usetabs
condition|)
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|else
name|width
operator|+=
literal|2
expr_stmt|;
name|columns
operator|=
name|twidth
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
block|}
name|lines
operator|=
operator|(
name|nentry
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|fp
operator|=
name|fp0
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
name|cp
operator|=
name|fmtentry
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|+
name|lines
operator|>=
name|fplast
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|w
operator|<
name|width
condition|)
if|if
condition|(
name|usetabs
condition|)
block|{
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|w
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
name|fcmp
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
specifier|register
expr|struct
name|afile
operator|*
name|f1
operator|,
operator|*
name|f2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|dflg
operator|==
literal|0
operator|&&
name|fflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|f1
operator|->
name|fflags
operator|&
name|ISARG
operator|)
operator|&&
name|f1
operator|->
name|ftype
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
operator|(
name|f2
operator|->
name|fflags
operator|&
name|ISARG
operator|)
operator|==
literal|0
operator|||
name|f2
operator|->
name|ftype
operator|!=
literal|'d'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|f2
operator|->
name|fflags
operator|&
name|ISARG
operator|)
operator|&&
name|f2
operator|->
name|ftype
operator|==
literal|'d'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tflg
condition|)
block|{
if|if
condition|(
name|f2
operator|->
name|fmtime
operator|==
name|f1
operator|->
name|fmtime
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|f2
operator|->
name|fmtime
operator|>
name|f1
operator|->
name|fmtime
condition|)
return|return
operator|(
name|rflg
operator|)
return|;
return|return
operator|(
operator|-
name|rflg
operator|)
return|;
block|}
return|return
operator|(
name|rflg
operator|*
name|strcmp
argument_list|(
name|f1
operator|->
name|fname
argument_list|,
name|f2
operator|->
name|fname
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|cat
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|dfile
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|dlen
decl_stmt|;
if|if
condition|(
operator|(
name|dlen
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
operator|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
operator|>
name|BUFSIZ
condition|)
block|{
name|fputs
argument_list|(
literal|"ls: filename too long\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dir
index|[
literal|0
index|]
operator|||
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|dir
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|strcpy
argument_list|(
name|dfile
argument_list|,
name|file
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
name|dlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
operator|*
name|file
operator|!=
literal|'/'
condition|)
name|dfile
index|[
name|dlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dfile
operator|+
name|dlen
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|dfile
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|cp
init|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"ls: out of memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strcpy
argument_list|(
name|cp
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|fmtinum
argument_list|()
decl_stmt|,
modifier|*
name|fmtsize
argument_list|()
decl_stmt|,
modifier|*
name|fmtlstuff
argument_list|()
decl_stmt|,
modifier|*
name|fmtmode
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|fmtentry
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|struct
name|afile
modifier|*
name|fp
decl_stmt|;
block|{
specifier|static
name|char
name|fmtres
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fmtres
argument_list|,
literal|"%s%s%s"
argument_list|,
name|iflg
condition|?
name|fmtinum
argument_list|(
name|fp
argument_list|)
else|:
literal|""
argument_list|,
name|sflg
condition|?
name|fmtsize
argument_list|(
name|fp
argument_list|)
else|:
literal|""
argument_list|,
name|lflg
condition|?
name|fmtlstuff
argument_list|(
name|fp
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|&
name|fmtres
index|[
name|strlen
argument_list|(
name|fmtres
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|fp
operator|->
name|fname
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|qflg
operator|&&
operator|(
operator|*
name|cp
operator|<
literal|' '
operator|||
operator|*
name|cp
operator|>=
literal|0177
operator|)
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|Fflg
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftype
operator|==
literal|'d'
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|ftype
operator|==
literal|'l'
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'@'
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|ftype
operator|==
literal|'s'
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'='
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|fflags
operator|&
literal|0111
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
if|if
condition|(
name|lflg
operator|&&
name|fp
operator|->
name|flinkto
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
literal|" -> "
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|fp
operator|->
name|flinkto
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|qflg
operator|&&
operator|(
operator|*
name|cp
operator|<
literal|' '
operator|||
operator|*
name|cp
operator|>=
literal|0177
operator|)
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|fmtres
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fmtinum
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|afile
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|inumbuf
index|[
literal|8
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|inumbuf
argument_list|,
literal|"%6ld "
argument_list|,
name|p
operator|->
name|fnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|inumbuf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fmtsize
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|afile
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|sizebuf
index|[
literal|32
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sizebuf
argument_list|,
literal|"%4ld "
argument_list|,
name|kbytes
argument_list|(
name|dbtob
argument_list|(
name|p
operator|->
name|fblks
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sizebuf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fmtlstuff
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|afile
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|lstuffbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|gname
index|[
literal|32
index|]
decl_stmt|,
name|uname
index|[
literal|32
index|]
decl_stmt|,
name|fsize
index|[
literal|32
index|]
decl_stmt|,
name|ftime
index|[
literal|32
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
init|=
name|lstuffbuf
decl_stmt|;
comment|/* type mode uname gname fsize ftime */
comment|/* get uname */
block|{
name|char
modifier|*
name|cp
init|=
name|getname
argument_list|(
name|p
operator|->
name|fuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|uname
argument_list|,
literal|"%-9.9s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|uname
argument_list|,
literal|"%-9u"
argument_list|,
name|p
operator|->
name|fuid
argument_list|)
expr_stmt|;
block|}
comment|/* get gname */
if|if
condition|(
name|gflg
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|getgroup
argument_list|(
name|p
operator|->
name|fgid
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|gname
argument_list|,
literal|"%-9.9s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|gname
argument_list|,
literal|"%-9u"
argument_list|,
name|p
operator|->
name|fgid
argument_list|)
expr_stmt|;
block|}
comment|/* get fsize */
if|if
condition|(
name|p
operator|->
name|ftype
operator|==
literal|'b'
operator|||
name|p
operator|->
name|ftype
operator|==
literal|'c'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fsize
argument_list|,
literal|"%3d,%4d"
argument_list|,
name|major
argument_list|(
name|p
operator|->
name|fsize
argument_list|)
argument_list|,
name|minor
argument_list|(
name|p
operator|->
name|fsize
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|ftype
operator|==
literal|'s'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fsize
argument_list|,
literal|"%8ld"
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fsize
argument_list|,
literal|"%8ld"
argument_list|,
name|p
operator|->
name|fsize
argument_list|)
expr_stmt|;
comment|/* get ftime */
block|{
name|char
modifier|*
name|cp
init|=
name|ctime
argument_list|(
operator|&
name|p
operator|->
name|fmtime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|fmtime
operator|<
name|sixmonthsago
operator|)
operator|||
operator|(
name|p
operator|->
name|fmtime
operator|>
name|now
operator|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftime
argument_list|,
literal|" %-7.7s %-4.4s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftime
argument_list|,
literal|" %-12.12s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* splat */
operator|*
name|lp
operator|++
operator|=
name|p
operator|->
name|ftype
expr_stmt|;
name|lp
operator|=
name|fmtmode
argument_list|(
name|lp
argument_list|,
name|p
operator|->
name|fflags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|"%3d %s%s%s%s"
argument_list|,
name|p
operator|->
name|fnl
argument_list|,
name|uname
argument_list|,
name|gflg
condition|?
name|gname
else|:
literal|""
argument_list|,
name|fsize
argument_list|,
name|ftime
argument_list|)
expr_stmt|;
return|return
operator|(
name|lstuffbuf
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|m1
index|[]
init|=
block|{
literal|1
block|,
name|S_IREAD
operator|>>
literal|0
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m2
index|[]
init|=
block|{
literal|1
block|,
name|S_IWRITE
operator|>>
literal|0
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m3
index|[]
init|=
block|{
literal|3
block|,
name|S_ISUID
operator||
operator|(
name|S_IEXEC
operator|>>
literal|0
operator|)
block|,
literal|'s'
block|,
name|S_ISUID
block|,
literal|'S'
block|,
name|S_IEXEC
operator|>>
literal|0
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m4
index|[]
init|=
block|{
literal|1
block|,
name|S_IREAD
operator|>>
literal|3
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m5
index|[]
init|=
block|{
literal|1
block|,
name|S_IWRITE
operator|>>
literal|3
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m6
index|[]
init|=
block|{
literal|3
block|,
name|S_ISGID
operator||
operator|(
name|S_IEXEC
operator|>>
literal|3
operator|)
block|,
literal|'s'
block|,
name|S_ISGID
block|,
literal|'S'
block|,
name|S_IEXEC
operator|>>
literal|3
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m7
index|[]
init|=
block|{
literal|1
block|,
name|S_IREAD
operator|>>
literal|6
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m8
index|[]
init|=
block|{
literal|1
block|,
name|S_IWRITE
operator|>>
literal|6
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m9
index|[]
init|=
block|{
literal|3
block|,
name|S_ISVTX
operator||
operator|(
name|S_IEXEC
operator|>>
literal|6
operator|)
block|,
literal|'t'
block|,
name|S_ISVTX
block|,
literal|'T'
block|,
name|S_IEXEC
operator|>>
literal|6
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|m
index|[]
init|=
block|{
name|m1
block|,
name|m2
block|,
name|m3
block|,
name|m4
block|,
name|m5
block|,
name|m6
block|,
name|m7
block|,
name|m8
block|,
name|m9
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|fmtmode
parameter_list|(
name|lp
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|flags
decl_stmt|;
block|{
name|int
modifier|*
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|m
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|m
index|[
sizeof|sizeof
argument_list|(
name|m
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
index|]
condition|;
control|)
block|{
specifier|register
name|int
modifier|*
name|pairp
init|=
operator|*
name|mp
operator|++
decl_stmt|;
specifier|register
name|int
name|n
init|=
operator|*
name|pairp
operator|++
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|(
name|flags
operator|&
operator|*
name|pairp
operator|)
operator|!=
operator|*
name|pairp
condition|)
name|pairp
operator|+=
literal|2
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|pairp
index|[
name|n
operator|>=
literal|0
index|]
expr_stmt|;
block|}
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* rest should be done with nameserver or database */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMAX
value|(sizeof (utmp.ut_name))
end_define

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncpy(a, b, NMAX)
end_define

begin_define
define|#
directive|define
name|NCACHE
value|64
end_define

begin_comment
comment|/* power of 2 */
end_comment

begin_define
define|#
directive|define
name|CAMASK
value|NCACHE - 1
end_define

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|uid
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
block|{
specifier|extern
name|int
name|_pw_stayopen
decl_stmt|;
specifier|static
struct|struct
name|ncache
block|{
name|uid_t
name|uid
decl_stmt|;
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|c_uid
index|[
name|NCACHE
index|]
struct|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|struct
name|ncache
modifier|*
name|cp
decl_stmt|;
name|_pw_stayopen
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|c_uid
operator|+
operator|(
name|uid
operator|&
name|CAMASK
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|uid
operator|==
name|uid
operator|&&
operator|*
name|cp
operator|->
name|name
condition|)
return|return
operator|(
name|cp
operator|->
name|name
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
name|cp
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|SCPYN
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getgroup
parameter_list|(
name|gid
parameter_list|)
name|gid_t
name|gid
decl_stmt|;
block|{
specifier|static
struct|struct
name|ncache
block|{
name|gid_t
name|gid
decl_stmt|;
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|c_gid
index|[
name|NCACHE
index|]
struct|;
specifier|register
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
specifier|register
name|struct
name|ncache
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|c_gid
operator|+
operator|(
name|gid
operator|&
name|CAMASK
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|gid
operator|==
name|gid
operator|&&
operator|*
name|cp
operator|->
name|name
condition|)
return|return
operator|(
name|cp
operator|->
name|name
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|gr
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
name|cp
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
name|SCPYN
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|->
name|name
operator|)
return|;
block|}
end_function

end_unit

