begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)print.c	5.3 (Berkeley) 4/9/89"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - printing routines  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|LONGFIL
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|NOTOPEN
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|BADMOD
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* general printing routines ($) */
end_comment

begin_macro
name|printtrace
argument_list|(
argument|modif
argument_list|)
end_macro

begin_decl_stmt
name|int
name|modif
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|stack
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|ecount
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|readchar
argument_list|()
operator|!=
literal|'\n'
condition|)
comment|/* void */
empty_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rdc
argument_list|()
operator|==
literal|'<'
condition|)
name|stack
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|stack
operator|=
literal|0
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'>'
case|:
block|{
name|char
name|file
index|[
literal|64
index|]
decl_stmt|;
name|char
name|Ifile
index|[
literal|128
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Ipath
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdc
argument_list|()
operator|!=
literal|'\n'
condition|)
block|{
do|do
block|{
name|file
index|[
name|index
operator|++
index|]
operator|=
name|lastc
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|63
condition|)
name|error
argument_list|(
name|LONGFIL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|readchar
argument_list|()
operator|!=
literal|'\n'
condition|)
do|;
name|file
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|modif
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|Ipath
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Ifile
argument_list|,
name|Ipath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|Ifile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|Ifile
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|iclose
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|infile
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|<
literal|0
condition|)
name|infile
operator|=
name|open
argument_list|(
name|Ifile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|infile
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|<
literal|0
condition|)
block|{
name|infile
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|NOTOPEN
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|var
index|[
literal|9
index|]
operator|=
name|ecount
expr_stmt|;
block|}
else|else
block|{
name|oclose
argument_list|()
expr_stmt|;
name|outfile
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|outfile
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|modif
operator|==
literal|'<'
condition|)
name|iclose
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|oclose
argument_list|()
expr_stmt|;
block|}
name|unreadc
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|kernel
condition|)
name|prints
argument_list|(
literal|"not debugging kernel\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gavedot
condition|)
name|setpcb
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|getpcb
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|gavedot
condition|)
block|{
name|i
operator|=
name|edot
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|>=
literal|2
operator|&&
name|i
operator|<=
literal|16
operator|||
name|i
operator|<=
operator|-
literal|2
operator|&&
name|i
operator|>=
operator|-
literal|16
operator|)
condition|)
block|{
name|adbprintf
argument_list|(
literal|"illegal radix %d base ten"
argument_list|,
operator|(
name|expr_t
operator|)
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|radix
operator|=
name|i
expr_stmt|;
block|}
name|adbprintf
argument_list|(
literal|"radix=%D base ten"
argument_list|,
operator|(
name|expr_t
operator|)
name|radix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'%'
case|:
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|maxcol
operator|=
name|gavedot
condition|?
name|edot
else|:
name|MAXCOL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|maxoff
operator|=
name|gavedot
condition|?
name|edot
else|:
name|MAXOFF
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|prints
argument_list|(
literal|"variables\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|35
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|var
index|[
name|i
index|]
condition|)
name|adbprintf
argument_list|(
literal|"%c = %R\n"
argument_list|,
name|i
operator|>
literal|9
condition|?
name|i
operator|+
literal|'a'
operator|-
literal|10
else|:
name|i
operator|+
literal|'0'
argument_list|,
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|printmap
argument_list|(
literal|"? map"
argument_list|,
operator|&
name|txtmap
argument_list|)
expr_stmt|;
name|printmap
argument_list|(
literal|"/ map"
argument_list|,
operator|&
name|datmap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|pid
condition|)
name|adbprintf
argument_list|(
literal|"pcs id = %D\n"
argument_list|,
operator|(
name|expr_t
operator|)
name|pid
argument_list|)
expr_stmt|;
else|else
name|prints
argument_list|(
literal|"no process\n"
argument_list|)
expr_stmt|;
name|sigprint
argument_list|()
expr_stmt|;
name|flushbuf
argument_list|()
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|printregs
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|printstack
argument_list|(
name|modif
operator|==
literal|'C'
argument_list|,
name|gavecount
condition|?
operator|(
name|int
operator|)
name|ecount
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
comment|/* print externals */
name|printsyms
argument_list|(
name|modif
operator|==
literal|'E'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
comment|/* print breakpoints */
name|printbkpts
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|BADMOD
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|printmap
argument_list|(
argument|s
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|map
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|adbprintf
argument_list|(
literal|"%s%12t`%s'\n"
argument_list|,
name|s
argument_list|,
name|m
operator|->
name|ufd
operator|<
literal|0
condition|?
literal|"-"
else|:
name|m
operator|->
name|ufd
operator|==
name|corefile
operator|.
name|fd
condition|?
name|corefile
operator|.
name|name
else|:
name|symfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|"b1 = %-16Re1 = %-16Rf1 = %-16R\n"
argument_list|,
name|m
operator|->
name|m1
operator|.
name|b
argument_list|,
name|m
operator|->
name|m1
operator|.
name|e
argument_list|,
name|m
operator|->
name|m1
operator|.
name|f
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|"b2 = %-16Re2 = %-16Rf2 = %-16R\n"
argument_list|,
name|m
operator|->
name|m2
operator|.
name|b
argument_list|,
name|m
operator|->
name|m2
operator|.
name|e
argument_list|,
name|m
operator|->
name|m2
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print global data and bss symbols, and if texttoo, text symbols too.  */
end_comment

begin_macro
name|printsyms
argument_list|(
argument|texttoo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|texttoo
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|esymtab
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|n_type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|sp
operator|->
name|n_type
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
if|if
condition|(
name|texttoo
condition|)
name|adbprintf
argument_list|(
literal|"%s:%12t@ %R\n"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
operator|(
name|expr_t
operator|)
name|sp
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|adbprintf
argument_list|(
literal|"%s:%12t"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|prfrom
argument_list|(
operator|(
name|addr_t
operator|)
name|sp
operator|->
name|n_value
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Print the value stored in some location, or `?' if it cannot be read,  * then the character c (usually '\n' or ',').  */
end_comment

begin_macro
name|prfrom
argument_list|(
argument|a
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|addr_t
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|expr_t
name|v
decl_stmt|;
name|errflag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|adbread
argument_list|(
name|SP_DATA
argument_list|,
name|a
argument_list|,
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|v
argument_list|)
operator|&&
name|errflag
operator|==
name|NULL
condition|)
name|adbprintf
argument_list|(
literal|"%R\%c"
argument_list|,
name|v
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|errflag
operator|=
name|NULL
expr_stmt|;
name|adbprintf
argument_list|(
literal|"?%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|busted
end_ifdef

begin_comment
comment|/*  * Print a local symbol (called from printstack()).  * Local symbols end with ':', so cannot use %s format.  */
end_comment

begin_expr_stmt
name|printlsym
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|)
name|printc
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|printregs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|reglist
modifier|*
name|p
decl_stmt|;
name|expr_t
name|v
decl_stmt|;
specifier|extern
name|struct
name|reglist
name|reglist
index|[]
decl_stmt|;
for|for
control|(
name|p
operator|=
name|reglist
init|;
name|p
operator|->
name|r_name
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|v
operator|=
name|getreg
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|"%s%6t%R\%16t"
argument_list|,
name|p
operator|->
name|r_name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|valpr
argument_list|(
name|v
argument_list|,
name|ispace_reg
argument_list|(
name|p
argument_list|)
condition|?
name|SP_INSTR
else|:
name|SP_DATA
argument_list|)
expr_stmt|;
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|printpc
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|printpc
argument_list|()
end_macro

begin_block
block|{
name|dot
operator|=
name|getpc
argument_list|()
expr_stmt|;
name|pdot
argument_list|()
expr_stmt|;
name|printins
argument_list|(
name|SP_INSTR
argument_list|)
expr_stmt|;
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

