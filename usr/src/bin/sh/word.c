begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)word.c	4.7 4/24/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_comment
comment|/* ========	character handling for command lines	========*/
end_comment

begin_macro
name|word
argument_list|()
end_macro

begin_block
block|{
name|REG
name|CHAR
name|c
decl_stmt|,
name|d
decl_stmt|;
name|REG
name|CHAR
modifier|*
name|argp
init|=
name|locstak
argument_list|()
operator|+
name|BYTESPERWORD
decl_stmt|;
name|REG
name|ARGPTR
name|ap
decl_stmt|;
name|INT
name|alpha
init|=
literal|1
decl_stmt|;
name|wdnum
operator|=
literal|0
expr_stmt|;
name|wdset
operator|=
literal|0
expr_stmt|;
name|WHILE
argument_list|(
argument|c=nextc(
literal|0
argument|)
argument_list|,
argument|space(c)
argument_list|)
name|DONE
name|IF
name|c
operator|==
literal|'#'
name|ANDF
argument_list|(
argument|(flags&prompt)==
literal|0
argument|ORF ((flags&ttyflg) ANDF 	    standin->fstak!=
literal|0
argument|)
argument_list|)
name|THEN
name|WHILE
argument_list|(
argument|c=readc()
argument_list|)
name|ANDF
name|c
operator|!=
name|NL
name|DONE
name|FI
name|IF
operator|!
name|eofmeta
argument_list|(
argument|c
argument_list|)
name|THEN
name|REP
name|IF
name|c
operator|==
name|LITERAL
name|THEN
operator|*
name|argp
operator|++
operator|=
operator|(
name|DQUOTE
operator|)
expr_stmt|;
name|WHILE
argument_list|(
argument|c=readc()
argument_list|)
name|ANDF
name|c
operator|!=
name|LITERAL
name|DO
operator|*
name|argp
operator|++
operator|=
operator|(
name|c
operator||
name|QUOTE
operator|)
expr_stmt|;
name|chkpr
argument_list|(
argument|c
argument_list|)
name|OD
operator|*
name|argp
operator|++
operator|=
operator|(
name|DQUOTE
operator|)
expr_stmt|;
name|ELSE
operator|*
name|argp
operator|++
operator|=
operator|(
name|c
operator|)
expr_stmt|;
name|IF
name|c
operator|==
literal|'='
name|THEN
name|wdset
operator||=
name|alpha
name|FI
name|IF
operator|!
name|alphanum
argument_list|(
argument|c
argument_list|)
name|THEN
name|alpha
operator|=
literal|0
name|FI
name|IF
name|qotchar
argument_list|(
argument|c
argument_list|)
name|THEN
name|d
operator|=
name|c
expr_stmt|;
name|WHILE
argument_list|(
argument|*argp++=(c=nextc(d))
argument_list|)
name|ANDF
name|c
operator|!=
name|d
name|DO
name|chkpr
argument_list|(
argument|c
argument_list|)
name|OD
name|FI
name|FI
name|PER
argument_list|(
argument|c=nextc(
literal|0
argument|)
argument_list|,
argument|!eofmeta(c)
argument_list|)
name|DONE
name|ap
operator|=
operator|(
name|ARGPTR
operator|)
name|endstak
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|IF
operator|!
name|letter
argument_list|(
argument|ap->argval[
literal|0
argument|]
argument_list|)
name|THEN
name|wdset
operator|=
literal|0
name|FI
name|peekc
operator|=
name|c
operator||
name|MARK
expr_stmt|;
name|IF
name|ap
operator|->
name|argval
index|[
literal|1
index|]
operator|==
literal|0
name|ANDF
argument_list|(
argument|d=ap->argval[
literal|0
argument|]
argument_list|,
argument|digit(d)
argument_list|)
name|ANDF
argument_list|(
argument|c==
literal|'>'
argument|ORF c==
literal|'<'
argument_list|)
name|THEN
name|word
argument_list|()
expr_stmt|;
name|wdnum
operator|=
name|d
operator|-
literal|'0'
expr_stmt|;
name|ELSE
comment|/*check for reserved words*/
name|IF
name|reserv
operator|==
name|FALSE
name|ORF
argument_list|(
name|wdval
operator|=
name|syslook
argument_list|(
name|ap
operator|->
name|argval
argument_list|,
name|reserved
argument_list|)
argument_list|)
operator|==
literal|0
name|THEN
name|wdarg
operator|=
name|ap
expr_stmt|;
name|wdval
operator|=
literal|0
expr_stmt|;
name|FI
name|FI
name|ELIF
name|dipchar
argument_list|(
name|c
argument_list|)
name|THEN
name|IF
argument_list|(
name|d
operator|=
name|nextc
argument_list|(
literal|0
argument_list|)
argument_list|)
decl|==
name|c
name|THEN
name|wdval
init|=
name|c
operator||
name|SYMREP
decl_stmt|;
name|ELSE
name|peekc
init|=
name|d
operator||
name|MARK
decl_stmt|;
name|wdval
operator|=
name|c
expr_stmt|;
name|FI
name|ELSE
name|IF
argument_list|(
name|wdval
operator|=
name|c
argument_list|)
decl|==
name|EOF
name|THEN
name|wdval
init|=
name|EOFSYM
decl_stmt|;
name|FI
name|IF
name|iopend
name|ANDF
name|eolchar
argument_list|(
name|c
argument_list|)
name|THEN
name|copy
argument_list|(
name|iopend
argument_list|)
decl_stmt|;
name|iopend
operator|=
literal|0
expr_stmt|;
name|FI
name|FI
name|reserv
init|=
name|FALSE
decl_stmt|;
return|return
operator|(
name|wdval
operator|)
return|;
block|}
end_block

begin_macro
name|nextc
argument_list|(
argument|quote
argument_list|)
end_macro

begin_decl_stmt
name|CHAR
name|quote
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|CHAR
name|c
decl_stmt|,
name|d
decl_stmt|;
name|IF
argument_list|(
name|d
operator|=
name|readc
argument_list|()
argument_list|)
operator|==
name|ESCAPE
name|THEN
name|IF
argument_list|(
name|c
operator|=
name|readc
argument_list|()
argument_list|)
operator|==
name|NL
name|THEN
name|chkpr
argument_list|(
name|NL
argument_list|)
expr_stmt|;
name|d
operator|=
name|nextc
argument_list|(
name|quote
argument_list|)
expr_stmt|;
name|ELIF
name|quote
name|ANDF
name|c
operator|!=
name|quote
name|ANDF
operator|!
name|escchar
argument_list|(
argument|c
argument_list|)
name|THEN
name|peekc
operator|=
name|c
operator||
name|MARK
expr_stmt|;
name|ELSE
name|d
init|=
name|c
operator||
name|QUOTE
decl_stmt|;
name|FI
name|FI
return|return
operator|(
name|d
operator|)
return|;
block|}
end_block

begin_macro
name|readc
argument_list|()
end_macro

begin_block
block|{
name|REG
name|CHAR
name|c
decl_stmt|;
name|REG
name|INT
name|len
decl_stmt|;
name|REG
name|FILE
name|f
decl_stmt|;
name|retry
label|:
name|IF
name|peekc
name|THEN
name|c
init|=
name|peekc
decl_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|ELIF
argument_list|(
argument|f=standin
argument_list|,
argument|f->fnxt!=f->fend
argument_list|)
name|THEN
name|IF
argument_list|(
name|c
operator|=
operator|*
name|f
operator|->
name|fnxt
operator|++
argument_list|)
decl|==0
name|THEN
name|IF
name|f
operator|->
name|feval
name|THEN
name|IF
name|estabf
argument_list|(
operator|*
name|f
operator|->
name|feval
operator|++
argument_list|)
name|THEN
name|c
init|=
name|EOF
decl_stmt|;
name|ELSE
name|c
init|=
name|SP
decl_stmt|;
name|FI
name|ELSE
goto|goto
name|retry
goto|;
comment|/* = c=readc(); */
name|FI
name|FI
name|IF
name|flags
operator|&
name|readpr
name|ANDF
name|standin
operator|->
name|fstak
operator|==
literal|0
name|THEN
name|prc
argument_list|(
argument|c
argument_list|)
name|FI
name|IF
name|c
operator|==
name|NL
name|THEN
name|f
operator|->
name|flin
operator|++
name|FI
name|ELIF
name|f
operator|->
name|feof
name|ORF
name|f
operator|->
name|fdes
operator|<
literal|0
name|THEN
name|c
operator|=
name|EOF
expr_stmt|;
name|f
operator|->
name|feof
operator|++
expr_stmt|;
name|ELIF
argument_list|(
name|len
operator|=
name|readb
argument_list|()
argument_list|)
operator|<=
literal|0
name|THEN
name|close
argument_list|(
name|f
operator|->
name|fdes
argument_list|)
expr_stmt|;
name|f
operator|->
name|fdes
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|EOF
expr_stmt|;
name|f
operator|->
name|feof
operator|++
expr_stmt|;
name|ELSE
name|f
operator|->
name|fend
init|=
operator|(
name|f
operator|->
name|fnxt
operator|=
name|f
operator|->
name|fbuf
operator|)
operator|+
name|len
decl_stmt|;
goto|goto
name|retry
goto|;
name|FI
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_function
name|LOCAL
name|readb
parameter_list|()
block|{
name|REG
name|FILE
name|f
init|=
name|standin
decl_stmt|;
name|REG
name|INT
name|len
decl_stmt|;
name|IF
name|setjmp
argument_list|(
name|INTbuf
argument_list|)
decl|== 0
name|THEN
name|trapjmp
index|[
name|INTR
index|]
init|=
literal|1
decl_stmt|;
name|FI
name|REP
name|IF
name|trapnote
modifier|&
name|SIGSET
name|THEN
name|newline
parameter_list|()
function_decl|;
name|sigchk
argument_list|()
name|FI
name|PER
argument_list|(
name|len
operator|=
name|read
argument_list|(
name|f
operator|->
name|fdes
argument_list|,
name|f
operator|->
name|fbuf
argument_list|,
name|f
operator|->
name|fsiz
argument_list|)
argument_list|)
decl|<0
name|ANDF
name|trapnote
name|DONE
name|trapjmp
index|[
name|INTR
index|]
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

end_unit

