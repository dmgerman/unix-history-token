begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)args.c	4.5 4/24/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_function_decl
name|PROC
name|DOLPTR
name|copyargs
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|LOCAL
name|DOLPTR
name|dolh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|flagadr
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|flagchar
index|[]
init|=
block|{
literal|'x'
block|,
literal|'n'
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'s'
block|,
literal|'i'
block|,
literal|'e'
block|,
literal|'r'
block|,
literal|'k'
block|,
literal|'u'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|flagval
index|[]
init|=
block|{
name|execpr
block|,
name|noexec
block|,
name|readpr
block|,
name|oneflg
block|,
name|stdflg
block|,
name|intflg
block|,
name|errflg
block|,
name|rshflg
block|,
name|keyflg
block|,
name|setflg
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========	option handling	======== */
end_comment

begin_function
name|INT
name|options
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|STRING
modifier|*
name|argv
decl_stmt|;
name|INT
name|argc
decl_stmt|;
block|{
name|REG
name|STRING
name|cp
decl_stmt|;
name|REG
name|STRING
modifier|*
name|argp
init|=
name|argv
decl_stmt|;
name|REG
name|STRING
name|flagc
decl_stmt|;
name|STRING
name|flagp
decl_stmt|;
name|IF
name|argc
operator|>
literal|1
name|ANDF
operator|*
name|argp
index|[
literal|1
index|]
operator|==
literal|'-'
name|THEN
name|cp
operator|=
name|argp
index|[
literal|1
index|]
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|execpr
operator||
name|readpr
operator|)
expr_stmt|;
name|WHILE
operator|*
operator|++
name|cp
name|DO
name|flagc
operator|=
name|flagchar
expr_stmt|;
name|WHILE
operator|*
name|flagc
name|ANDF
operator|*
name|flagc
operator|!=
operator|*
name|cp
name|DO
name|flagc
operator|++
name|OD
name|IF
operator|*
name|cp
operator|==
operator|*
name|flagc
name|THEN
name|flags
operator||=
name|flagval
index|[
name|flagc
operator|-
name|flagchar
index|]
expr_stmt|;
name|ELIF
operator|*
name|cp
operator|==
literal|'c'
name|ANDF
name|argc
operator|>
literal|2
name|ANDF
name|comdiv
operator|==
literal|0
name|THEN
name|comdiv
operator|=
name|argp
index|[
literal|2
index|]
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|=
name|argp
index|[
literal|0
index|]
expr_stmt|;
name|argp
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|ELSE
name|failed
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|badopt
argument_list|)
decl_stmt|;
name|FI
name|OD
name|argp
index|[
literal|1
index|]
init|=
name|argp
index|[
literal|0
index|]
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|FI
comment|/* set up $- */
name|flagc
init|=
name|flagchar
decl_stmt|;
name|flagp
operator|=
name|flagadr
expr_stmt|;
name|WHILE
operator|*
name|flagc
name|DO
name|IF
name|flags
operator|&
name|flagval
index|[
name|flagc
operator|-
name|flagchar
index|]
name|THEN
operator|*
name|flagp
operator|++
operator|=
operator|*
name|flagc
expr_stmt|;
name|FI
name|flagc
operator|++
expr_stmt|;
name|OD
operator|*
name|flagp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|argc
operator|)
return|;
block|}
end_function

begin_function
name|VOID
name|setargs
parameter_list|(
name|argi
parameter_list|)
name|STRING
name|argi
index|[]
decl_stmt|;
block|{
comment|/* count args */
name|REG
name|STRING
modifier|*
name|argp
init|=
name|argi
decl_stmt|;
name|REG
name|INT
name|argn
init|=
literal|0
decl_stmt|;
name|WHILE
name|Rcheat
argument_list|(
operator|*
name|argp
operator|++
argument_list|)
decl|!=
name|ENDARGS
name|DO
name|argn
decl|++
name|OD
comment|/* free old ones unless on for loop chain */
name|freeargs
argument_list|(
name|dolh
argument_list|)
decl_stmt|;
name|dolh
operator|=
name|copyargs
argument_list|(
name|argi
argument_list|,
name|argn
argument_list|)
expr_stmt|;
comment|/* sets dolv */
name|assnum
argument_list|(
operator|&
name|dolladr
argument_list|,
name|dolc
operator|=
name|argn
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|freeargs
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|DOLPTR
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|STRING
modifier|*
name|argp
decl_stmt|;
name|REG
name|DOLPTR
name|argr
init|=
literal|0
decl_stmt|;
name|REG
name|DOLPTR
name|argblk
decl_stmt|;
name|IF
name|argblk
init|=
name|blk
name|THEN
name|argr
operator|=
name|argblk
operator|->
name|dolnxt
decl_stmt|;
name|IF
argument_list|(
operator|--
name|argblk
operator|->
name|doluse
argument_list|)
operator|==
literal|0
name|THEN
name|FOR
name|argp
operator|=
name|argblk
operator|->
name|dolarg
expr_stmt|;
name|Rcheat
argument_list|(
operator|*
name|argp
argument_list|)
operator|!=
name|ENDARGS
expr_stmt|;
name|argp
operator|++
name|DO
name|free
argument_list|(
argument|*argp
argument_list|)
name|OD
name|free
argument_list|(
name|argblk
argument_list|)
expr_stmt|;
name|FI
name|FI
return|return
operator|(
name|argr
operator|)
return|;
block|}
end_block

begin_function
name|LOCAL
name|DOLPTR
name|copyargs
parameter_list|(
name|from
parameter_list|,
name|n
parameter_list|)
name|STRING
name|from
index|[]
decl_stmt|;
block|{
name|REG
name|DOLPTR
name|dp
init|=
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|STRING
operator|*
argument_list|)
operator|*
name|n
operator|+
literal|3
operator|*
name|BYTESPERWORD
argument_list|)
decl_stmt|;
name|REG
name|STRING
modifier|*
name|np
decl_stmt|;
name|REG
name|STRING
modifier|*
name|fp
init|=
name|from
decl_stmt|;
name|dp
operator|->
name|doluse
operator|=
literal|1
expr_stmt|;
comment|/* use count */
name|np
operator|=
name|dp
operator|->
name|dolarg
expr_stmt|;
name|dolv
operator|=
name|np
expr_stmt|;
name|WHILE
name|n
operator|--
name|DO
operator|*
name|np
operator|++
operator|=
name|make
argument_list|(
argument|*fp++
argument_list|)
name|OD
operator|*
name|np
operator|++
operator|=
name|ENDARGS
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_macro
name|clearup
argument_list|()
end_macro

begin_block
block|{
comment|/* force `for' $* lists to go away */
name|WHILE
name|argfor
init|=
name|freeargs
argument_list|(
argument|argfor
argument_list|)
name|DONE
comment|/* clean up io files */
name|WHILE
name|pop
argument_list|()
name|DONE
block|}
end_block

begin_function
name|DOLPTR
name|useargs
parameter_list|()
block|{
name|IF
name|dolh
name|THEN
name|dolh
operator|->
name|doluse
operator|++
expr_stmt|;
name|dolh
operator|->
name|dolnxt
operator|=
name|argfor
expr_stmt|;
return|return
operator|(
name|argfor
operator|=
name|dolh
operator|)
return|;
name|ELSE
return|return
operator|(
literal|0
operator|)
return|;
name|FI
block|}
end_function

end_unit

