begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)macro.c	4.4 4/24/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_decl_stmt
name|LOCAL
name|CHAR
name|quote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used locally */
end_comment

begin_decl_stmt
name|LOCAL
name|CHAR
name|quoted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used locally */
end_comment

begin_function
name|LOCAL
name|STRING
name|copyto
parameter_list|(
name|endch
parameter_list|)
name|REG
name|CHAR
name|endch
decl_stmt|;
block|{
name|REG
name|CHAR
name|c
decl_stmt|;
name|WHILE
argument_list|(
name|c
operator|=
name|getch
argument_list|(
name|endch
argument_list|)
argument_list|)
operator|!=
name|endch
name|ANDF
name|c
name|DO
name|pushstak
argument_list|(
argument|c|quote
argument_list|)
name|OD
name|zerostak
argument_list|()
expr_stmt|;
name|IF
name|c
operator|!=
name|endch
name|THEN
name|error
argument_list|(
argument|badsub
argument_list|)
name|FI
block|}
end_function

begin_function
name|LOCAL
name|skipto
parameter_list|(
name|endch
parameter_list|)
name|REG
name|CHAR
name|endch
decl_stmt|;
block|{
comment|/* skip chars up to } */
name|REG
name|CHAR
name|c
decl_stmt|;
name|WHILE
argument_list|(
argument|c=readc()
argument_list|)
name|ANDF
name|c
operator|!=
name|endch
name|DO
name|SWITCH
name|c
name|IN
case|case
name|SQUOTE
case|:
name|skipto
argument_list|(
name|SQUOTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DQUOTE
case|:
name|skipto
argument_list|(
name|DQUOTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOLLAR
case|:
name|IF
name|readc
argument_list|()
operator|==
name|BRACE
name|THEN
name|skipto
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|FI
name|ENDSW
name|OD
name|IF
name|c
operator|!=
name|endch
name|THEN
name|error
argument_list|(
argument|badsub
argument_list|)
name|FI
block|}
end_function

begin_function
name|LOCAL
name|getch
parameter_list|(
name|endch
parameter_list|)
name|CHAR
name|endch
decl_stmt|;
block|{
name|REG
name|CHAR
name|d
decl_stmt|;
name|retry
label|:
name|d
operator|=
name|readc
argument_list|()
expr_stmt|;
name|IF
operator|!
name|subchar
argument_list|(
argument|d
argument_list|)
name|THEN
return|return
operator|(
name|d
operator|)
return|;
name|FI
name|IF
name|d
operator|==
name|DOLLAR
name|THEN
name|REG
name|INT
name|c
expr_stmt|;
name|IF
argument_list|(
argument|c=readc()
argument_list|,
argument|dolchar(c)
argument_list|)
name|THEN
name|NAMPTR
name|n
init|=
name|NIL
decl_stmt|;
name|INT
name|dolg
init|=
literal|0
decl_stmt|;
name|BOOL
name|bra
decl_stmt|;
name|REG
name|STRING
name|argp
decl_stmt|,
name|v
decl_stmt|;
name|CHAR
name|idb
index|[
literal|2
index|]
decl_stmt|;
name|STRING
name|id
init|=
name|idb
decl_stmt|;
name|IF
name|bra
init|=
operator|(
name|c
operator|==
name|BRACE
operator|)
name|THEN
name|c
operator|=
name|readc
argument_list|()
name|FI
name|IF
name|letter
argument_list|(
argument|c
argument_list|)
name|THEN
name|argp
operator|=
name|relstak
argument_list|()
decl_stmt|;
name|WHILE
name|alphanum
argument_list|(
name|c
argument_list|)
name|DO
name|pushstak
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|c
operator|=
name|readc
argument_list|()
name|OD
name|zerostak
argument_list|()
expr_stmt|;
name|n
operator|=
name|lookup
argument_list|(
name|absstak
argument_list|(
name|argp
argument_list|)
argument_list|)
expr_stmt|;
name|setstak
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|v
operator|=
name|n
operator|->
name|namval
expr_stmt|;
name|id
operator|=
name|n
operator|->
name|namid
expr_stmt|;
name|peekc
operator|=
name|c
operator||
name|MARK
expr_stmt|;
empty_stmt|;
name|ELIF
name|digchar
argument_list|(
name|c
argument_list|)
name|THEN
modifier|*
name|id
init|=
name|c
decl_stmt|;
name|idb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IF
name|astchar
argument_list|(
name|c
argument_list|)
name|THEN
name|dolg
init|=
literal|1
decl_stmt|;
name|c
operator|=
literal|'1'
expr_stmt|;
name|FI
name|c
operator|-=
literal|'0'
expr_stmt|;
name|v
operator|=
operator|(
operator|(
name|c
operator|==
literal|0
operator|)
condition|?
name|cmdadr
else|:
operator|(
name|c
operator|<=
name|dolc
operator|)
condition|?
name|dolv
index|[
name|c
index|]
else|:
call|(
name|STRING
call|)
argument_list|(
name|dolg
operator|=
literal|0
argument_list|)
operator|)
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'$'
name|THEN
name|v
operator|=
name|pidadr
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'!'
name|THEN
name|v
operator|=
name|pcsadr
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'#'
name|THEN
name|v
operator|=
name|dolladr
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'?'
name|THEN
name|v
operator|=
name|exitadr
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'-'
name|THEN
name|v
operator|=
name|flagadr
expr_stmt|;
name|ELIF
name|bra
name|THEN
name|error
argument_list|(
name|badsub
argument_list|)
decl_stmt|;
name|ELSE
goto|goto
name|retry
goto|;
name|FI
name|c
init|=
name|readc
argument_list|()
decl_stmt|;
name|IF
operator|!
name|defchar
argument_list|(
argument|c
argument_list|)
name|ANDF
name|bra
name|THEN
name|error
argument_list|(
name|badsub
argument_list|)
expr_stmt|;
name|FI
name|argp
init|=
literal|0
decl_stmt|;
name|IF
name|bra
name|THEN
name|IF
name|c
operator|!=
literal|'}'
name|THEN
name|argp
operator|=
name|relstak
argument_list|()
expr_stmt|;
name|IF
argument_list|(
argument|v==
literal|0
argument_list|)
name|NEQ
argument_list|(
argument|setchar(c)
argument_list|)
name|THEN
name|copyto
argument_list|(
literal|'}'
argument_list|)
decl_stmt|;
name|ELSE
name|skipto
argument_list|(
literal|'}'
argument_list|)
decl_stmt|;
name|FI
name|argp
init|=
name|absstak
argument_list|(
name|argp
argument_list|)
decl_stmt|;
name|FI
name|ELSE
name|peekc
init|=
name|c
operator||
name|MARK
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|FI
name|IF
name|v
name|THEN
name|IF
name|c
operator|!=
literal|'+'
name|THEN
name|LOOP
name|WHILE
name|c
operator|=
operator|*
name|v
operator|++
name|DO
name|pushstak
argument_list|(
name|c
operator||
name|quote
argument_list|)
expr_stmt|;
name|OD
name|IF
name|dolg
operator|==
literal|0
name|ORF
argument_list|(
argument|++dolg>dolc
argument_list|)
name|THEN
break|break;
name|ELSE
name|v
init|=
name|dolv
index|[
name|dolg
index|]
decl_stmt|;
name|pushstak
argument_list|(
name|SP
operator||
operator|(
operator|*
name|id
operator|==
literal|'*'
condition|?
name|quote
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|FI
name|POOL
name|FI
name|ELIF
name|argp
name|THEN
name|IF
name|c
operator|==
literal|'?'
name|THEN
name|failed
argument_list|(
name|id
argument_list|,
operator|*
name|argp
condition|?
name|argp
else|:
name|badparam
argument_list|)
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'='
name|THEN
name|IF
name|n
name|THEN
name|assign
argument_list|(
name|n
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|ELSE
name|error
argument_list|(
name|badsub
argument_list|)
decl_stmt|;
name|FI
name|FI
name|ELIF
name|flags
modifier|&
name|setflg
name|THEN
name|failed
argument_list|(
name|id
argument_list|,
name|badparam
argument_list|)
decl_stmt|;
name|FI
goto|goto
name|retry
goto|;
name|ELSE
name|peekc
init|=
name|c
operator||
name|MARK
decl_stmt|;
name|FI
name|ELIF
name|d
operator|==
name|endch
name|THEN
return|return
operator|(
name|d
operator|)
return|;
name|ELIF
name|d
operator|==
name|SQUOTE
name|THEN
name|comsubst
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
name|ELIF
name|d
operator|==
name|DQUOTE
name|THEN
name|quoted
operator|++
expr_stmt|;
name|quote
operator|^=
name|QUOTE
expr_stmt|;
goto|goto
name|retry
goto|;
name|FI
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_function
name|STRING
name|macro
parameter_list|(
name|as
parameter_list|)
name|STRING
name|as
decl_stmt|;
block|{
comment|/* Strip "" and do $ substitution 	 * Leaves result on top of stack 	 */
name|REG
name|BOOL
name|savqu
init|=
name|quoted
decl_stmt|;
name|REG
name|CHAR
name|savq
init|=
name|quote
decl_stmt|;
name|FILEHDR
name|fb
decl_stmt|;
name|push
argument_list|(
operator|&
name|fb
argument_list|)
expr_stmt|;
name|estabf
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|usestak
argument_list|()
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|copyto
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|IF
name|quoted
name|ANDF
argument_list|(
name|stakbot
operator|==
name|staktop
argument_list|)
name|THEN
name|pushstak
argument_list|(
name|QUOTE
argument_list|)
name|FI
name|quote
init|=
name|savq
decl_stmt|;
name|quoted
operator|=
name|savqu
expr_stmt|;
return|return
operator|(
name|fixstak
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|comsubst
parameter_list|()
block|{
comment|/* command substn */
name|FILEBLK
name|cb
decl_stmt|;
name|REG
name|CHAR
name|d
decl_stmt|;
name|REG
name|STKPTR
name|savptr
init|=
name|fixstak
argument_list|()
decl_stmt|;
name|usestak
argument_list|()
expr_stmt|;
name|WHILE
argument_list|(
name|d
operator|=
name|readc
argument_list|()
argument_list|)
operator|!=
name|SQUOTE
name|ANDF
name|d
name|DO
name|pushstak
argument_list|(
argument|d
argument_list|)
name|OD
name|BEGIN
name|REG
name|STRING
name|argc
expr_stmt|;
name|trim
argument_list|(
name|argc
operator|=
name|fixstak
argument_list|()
argument_list|)
expr_stmt|;
name|push
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
name|estabf
argument_list|(
name|argc
argument_list|)
expr_stmt|;
name|END
name|BEGIN
name|REG
name|TREPTR
name|t
init|=
name|makefork
argument_list|(
name|FPOU
argument_list|,
name|cmd
argument_list|(
name|EOFSYM
argument_list|,
name|MTFLG
operator||
name|NLFLG
argument_list|)
argument_list|)
decl_stmt|;
name|INT
name|pv
index|[
literal|2
index|]
decl_stmt|;
comment|/* this is done like this so that the pipe 	    * is open only when needed 	    */
name|chkpipe
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|pv
index|[
name|INPIPE
index|]
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pv
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
name|END
name|tdystak
argument_list|(
name|savptr
argument_list|)
decl_stmt|;
name|staktop
operator|=
name|movstr
argument_list|(
name|savptr
argument_list|,
name|stakbot
argument_list|)
expr_stmt|;
name|WHILE
name|d
init|=
name|readc
argument_list|()
name|DO
name|locstak
argument_list|()
decl_stmt|;
name|pushstak
argument_list|(
argument|d|quote
argument_list|)
name|OD
name|await
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|WHILE
name|stakbot
operator|!=
name|staktop
name|DO
name|IF
argument_list|(
operator|*
operator|--
name|staktop
operator|&
name|STRIP
argument_list|)
operator|!=
name|NL
name|THEN
operator|++
name|staktop
expr_stmt|;
break|break;
name|FI
name|OD
name|pop
parameter_list|()
function_decl|;
block|}
end_function

begin_define
define|#
directive|define
name|CPYSIZ
value|512
end_define

begin_macro
name|subst
argument_list|(
argument|in
argument_list|,
argument|ot
argument_list|)
end_macro

begin_decl_stmt
name|INT
name|in
decl_stmt|,
name|ot
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|CHAR
name|c
decl_stmt|;
name|FILEBLK
name|fb
decl_stmt|;
name|REG
name|INT
name|count
init|=
name|CPYSIZ
decl_stmt|;
name|push
argument_list|(
operator|&
name|fb
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* DQUOTE used to stop it from quoting */
name|WHILE
name|c
init|=
operator|(
name|getch
argument_list|(
name|DQUOTE
argument_list|)
operator|&
name|STRIP
operator|)
name|DO
name|pushstak
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|IF
operator|--
name|count
operator|==
literal|0
name|THEN
name|flush
argument_list|(
name|ot
argument_list|)
expr_stmt|;
name|count
operator|=
name|CPYSIZ
expr_stmt|;
name|FI
name|OD
name|flush
parameter_list|(
name|ot
parameter_list|)
function_decl|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|flush
parameter_list|(
name|ot
parameter_list|)
block|{
name|write
argument_list|(
name|ot
argument_list|,
name|stakbot
argument_list|,
name|staktop
operator|-
name|stakbot
argument_list|)
expr_stmt|;
name|IF
name|flags
modifier|&
name|execpr
name|THEN
name|write
argument_list|(
name|output
argument_list|,
name|stakbot
argument_list|,
name|staktop
operator|-
name|stakbot
argument_list|)
name|FI
name|staktop
init|=
name|stakbot
decl_stmt|;
block|}
end_function

end_unit

