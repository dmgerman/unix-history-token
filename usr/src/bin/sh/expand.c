begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)expand.c	4.5 8/11/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	UNIX shell  *  *	S. R. Bourne  *	Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_comment
comment|/* globals (file name generation)  *  * "*" in params matches r.e ".*"  * "?" in params matches r.e. "."  * "[...]" in params matches character class  * "[...a-z...]" in params matches a through z.  *  */
end_comment

begin_function_decl
name|PROC
name|VOID
name|addg
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|INT
name|expand
parameter_list|(
name|as
parameter_list|,
name|rflg
parameter_list|)
name|STRING
name|as
decl_stmt|;
block|{
name|INT
name|count
decl_stmt|;
name|DIR
modifier|*
name|dirf
decl_stmt|;
name|BOOL
name|dir
init|=
literal|0
decl_stmt|;
name|STRING
name|rescan
init|=
literal|0
decl_stmt|;
name|REG
name|STRING
name|s
decl_stmt|,
name|cs
decl_stmt|;
name|ARGPTR
name|schain
init|=
name|gchain
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|STATBUF
name|statb
decl_stmt|;
name|IF
name|trapnote
operator|&
name|SIGSET
name|THEN
return|return
operator|(
literal|0
operator|)
return|;
name|FI
name|s
init|=
name|cs
operator|=
name|as
decl_stmt|;
comment|/* check for meta chars */
name|BEGIN
name|REG
name|BOOL
name|slash
decl_stmt|;
name|slash
operator|=
literal|0
expr_stmt|;
name|WHILE
operator|!
name|fngchar
argument_list|(
argument|*cs
argument_list|)
name|DO
name|IF
operator|*
name|cs
operator|++
operator|==
literal|0
name|THEN
name|IF
name|rflg
name|ANDF
name|slash
name|THEN
break|break;
name|ELSE
return|return
operator|(
literal|0
operator|)
name|FI
name|ELIF
operator|*
name|cs
operator|==
literal|'/'
name|THEN
name|slash
operator|++
return|;
name|FI
name|OD
name|END
name|LOOP
name|IF
name|cs
operator|==
name|s
name|THEN
name|s
operator|=
name|nullstr
expr_stmt|;
break|break;
name|ELIF
operator|*
operator|--
name|cs
operator|==
literal|'/'
name|THEN
operator|*
name|cs
operator|=
literal|0
expr_stmt|;
name|IF
name|s
operator|==
name|cs
name|THEN
name|s
operator|=
literal|"/"
name|FI
break|break;
name|FI
name|POOL
name|IF
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|statb
argument_list|)
decl|>=0
name|ANDF
argument_list|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
argument_list|)
decl|==
name|S_IFDIR
name|ANDF
argument_list|(
name|dirf
operator|=
name|opendir
argument_list|(
name|s
argument_list|)
argument_list|)
decl|!=
name|NULL
name|THEN
name|dir
decl|++
decl_stmt|;
name|FI
name|count
init|=
literal|0
decl_stmt|;
name|IF
operator|*
name|cs
operator|==
literal|0
name|THEN
operator|*
name|cs
operator|++
operator|=
literal|0200
name|FI
name|IF
name|dir
name|THEN
comment|/* check for rescan */
name|REG
name|STRING
name|rs
expr_stmt|;
name|rs
operator|=
name|cs
expr_stmt|;
name|REP
name|IF
operator|*
name|rs
operator|==
literal|'/'
name|THEN
name|rescan
operator|=
name|rs
expr_stmt|;
operator|*
name|rs
operator|=
literal|0
expr_stmt|;
name|gchain
operator|=
literal|0
name|FI
name|PER
operator|*
name|rs
operator|++
name|DONE
name|IF
name|setjmp
argument_list|(
name|INTbuf
argument_list|)
operator|==
literal|0
name|THEN
name|trapjmp
index|[
name|INTR
index|]
operator|=
literal|1
expr_stmt|;
name|FI
name|WHILE
argument_list|(
name|trapnote
operator|&
name|SIGSET
argument_list|)
decl|== 0
name|ANDF
argument_list|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirf
argument_list|)
argument_list|)
decl|!=
name|NULL
name|DO
name|IF
argument_list|(
operator|*
name|dp
operator|->
name|d_name
operator|==
literal|'.'
name|ANDF
operator|*
name|cs
operator|!=
literal|'.'
argument_list|)
name|THEN
decl|continue
decl_stmt|;
name|FI
name|IF
name|gmatch
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|cs
argument_list|)
name|THEN
name|addg
argument_list|(
name|s
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|rescan
argument_list|)
decl_stmt|;
name|count
operator|++
expr_stmt|;
name|FI
name|OD
name|closedir
argument_list|(
name|dirf
argument_list|)
decl_stmt|;
name|trapjmp
index|[
name|INTR
index|]
operator|=
literal|0
expr_stmt|;
name|IF
name|rescan
name|THEN
name|REG
name|ARGPTR
name|rchain
decl_stmt|;
name|rchain
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|schain
expr_stmt|;
name|IF
name|count
name|THEN
name|count
init|=
literal|0
decl_stmt|;
name|WHILE
name|rchain
name|DO
name|count
operator|+=
name|expand
argument_list|(
name|rchain
operator|->
name|argval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rchain
operator|=
name|rchain
operator|->
name|argnxt
expr_stmt|;
name|OD
name|FI
modifier|*
name|rescan
init|=
literal|'/'
decl_stmt|;
name|FI
name|FI
name|BEGIN
name|REG
name|CHAR
name|c
decl_stmt|;
name|s
operator|=
name|as
expr_stmt|;
name|WHILE
name|c
init|=
operator|*
name|s
name|DO
operator|*
name|s
operator|++
operator|=
operator|(
name|c
operator|&
name|STRIP
condition|?
name|c
else|:
literal|'/'
operator|)
name|OD
name|END
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_macro
name|gmatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|STRING
name|s
decl_stmt|,
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|INT
name|scc
decl_stmt|;
name|CHAR
name|c
decl_stmt|;
name|IF
name|scc
init|=
operator|*
name|s
operator|++
name|THEN
name|IF
argument_list|(
name|scc
operator|&=
name|STRIP
argument_list|)
operator|==
literal|0
name|THEN
name|scc
operator|=
literal|0200
decl_stmt|;
name|FI
name|FI
name|SWITCH
name|c
init|=
operator|*
name|p
operator|++
name|IN
case|case
literal|'['
case|:
block|{
name|BOOL
name|ok
decl_stmt|;
name|INT
name|lc
decl_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
name|WHILE
name|c
init|=
operator|*
name|p
operator|++
name|DO
name|IF
name|c
operator|==
literal|']'
name|THEN
return|return
operator|(
name|ok
condition|?
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
else|:
literal|0
operator|)
return|;
name|ELIF
name|c
operator|==
name|MINUS
name|THEN
name|IF
name|lc
operator|<=
name|scc
name|ANDF
name|scc
operator|<=
operator|(
operator|*
name|p
operator|++
operator|)
name|THEN
name|ok
operator|++
name|FI
name|ELSE
name|IF
name|scc
operator|==
operator|(
name|lc
operator|=
operator|(
name|c
operator|&
name|STRIP
operator|)
operator|)
name|THEN
name|ok
operator|++
name|FI
name|FI
name|OD
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
name|IF
argument_list|(
name|c
operator|&
name|STRIP
argument_list|)
operator|!=
name|scc
name|THEN
return|return
operator|(
literal|0
operator|)
name|FI
case|case
literal|'?'
case|:
return|return
operator|(
name|scc
condition|?
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
else|:
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
name|IF
operator|*
name|p
operator|==
literal|0
name|THEN
return|return
operator|(
literal|1
operator|)
name|FI
operator|--
name|s
return|;
name|WHILE
modifier|*
name|s
name|DO
name|IF
name|gmatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
name|THEN
decl|return
argument_list|(
literal|1
argument_list|)
name|FI
name|OD
decl|return
argument_list|(
literal|0
argument_list|)
decl_stmt|;
case|case
literal|0
case|:
return|return
operator|(
name|scc
operator|==
literal|0
operator|)
return|;
name|ENDSW
block|}
end_block

begin_function
name|LOCAL
name|VOID
name|addg
parameter_list|(
name|as1
parameter_list|,
name|as2
parameter_list|,
name|as3
parameter_list|)
name|STRING
name|as1
decl_stmt|,
name|as2
decl_stmt|,
name|as3
decl_stmt|;
block|{
name|REG
name|STRING
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|REG
name|INT
name|c
decl_stmt|;
name|s2
operator|=
name|locstak
argument_list|()
operator|+
name|BYTESPERWORD
expr_stmt|;
name|s1
operator|=
name|as1
expr_stmt|;
name|WHILE
name|c
init|=
operator|*
name|s1
operator|++
name|DO
name|IF
argument_list|(
name|c
operator|&=
name|STRIP
argument_list|)
operator|==
literal|0
name|THEN
operator|*
name|s2
operator|++
operator|=
literal|'/'
decl_stmt|;
break|break;
name|FI
operator|*
name|s2
operator|++
operator|=
name|c
expr_stmt|;
name|OD
name|s1
init|=
name|as2
decl_stmt|;
name|WHILE
modifier|*
name|s2
init|=
operator|*
name|s1
operator|++
name|DO
name|s2
operator|++
name|OD
name|IF
name|s1
operator|=
name|as3
name|THEN
operator|*
name|s2
operator|++
operator|=
literal|'/'
decl_stmt|;
name|WHILE
operator|*
name|s2
operator|++
operator|=
operator|*
operator|++
name|s1
name|DONE
name|FI
name|makearg
argument_list|(
name|endstak
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|makearg
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|STRING
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|args
operator|->
name|argnxt
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|args
expr_stmt|;
block|}
end_block

end_unit

