begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley Software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)proc.c	5.11 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_include
include|#
directive|include
file|"sh.dir.h"
end_include

begin_include
include|#
directive|include
file|"sh.proc.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/*  * C Shell - functions that manage processes, handling hanging, termination  */
end_comment

begin_define
define|#
directive|define
name|BIGINDEX
value|9
end_define

begin_comment
comment|/* largest desirable job index */
end_comment

begin_comment
comment|/*  * pchild - called at interrupt level by the SIGCHLD signal  *	indicating that at least one child has terminated or stopped  *	thus at least one wait system call will definitely return a  *	childs status.  Top level routines (like pwait) must be sure  *	to mask interrupts when playing with the proclist data structures!  */
end_comment

begin_macro
name|pchild
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
name|union
name|wait
name|w
decl_stmt|;
name|int
name|jobflags
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
specifier|extern
name|int
name|insource
decl_stmt|;
name|loop
label|:
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
operator|(
name|setintr
operator|&&
operator|(
name|intty
operator|||
name|insource
operator|)
condition|?
name|WNOHANG
operator||
name|WUNTRACED
else|:
name|WNOHANG
operator|)
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|pnoprocesses
operator|=
name|pid
operator|==
operator|-
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
operator|!=
name|PNULL
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pid
operator|==
name|pp
operator|->
name|p_pid
condition|)
goto|goto
name|found
goto|;
goto|goto
name|loop
goto|;
name|found
label|:
if|if
condition|(
name|pid
operator|==
name|atoi
argument_list|(
name|value
argument_list|(
literal|"child"
argument_list|)
argument_list|)
condition|)
name|unsetv
argument_list|(
literal|"child"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_flags
operator|&=
operator|~
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator||
name|PREPORTED
operator|)
expr_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|pp
operator|->
name|p_flags
operator||=
name|PSTOPPED
expr_stmt|;
name|pp
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_stopsig
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
operator|(
name|PTIME
operator||
name|PPTIME
operator|)
operator|||
name|adrof
argument_list|(
literal|"time"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|pp
operator|->
name|p_etime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_rusage
operator|=
name|ru
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
block|{
if|if
condition|(
name|w
operator|.
name|w_termsig
operator|==
name|SIGINT
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PINTERRUPTED
expr_stmt|;
else|else
name|pp
operator|->
name|p_flags
operator||=
name|PSIGNALED
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|w_coredump
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PDUMPED
expr_stmt|;
name|pp
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_termsig
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_retcode
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_reason
operator|!=
literal|0
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PAEXITED
expr_stmt|;
else|else
name|pp
operator|->
name|p_flags
operator||=
name|PNEXITED
expr_stmt|;
block|}
block|}
name|jobflags
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|p_flags
operator|&
operator|(
name|PPTIME
operator||
name|PRUNNING
operator||
name|PSTOPPED
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|child
operator|&&
name|adrof
argument_list|(
literal|"time"
argument_list|)
operator|&&
name|fp
operator|->
name|p_rusage
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|fp
operator|->
name|p_rusage
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|>=
name|atoi
argument_list|(
name|value
argument_list|(
literal|"time"
argument_list|)
argument_list|)
condition|)
name|fp
operator|->
name|p_flags
operator||=
name|PTIME
expr_stmt|;
name|jobflags
operator||=
name|fp
operator|->
name|p_flags
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PFOREGND
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|pp
operator|->
name|p_friends
operator|&&
operator|(
name|pp
operator|->
name|p_flags
operator|&
name|PPTIME
operator|)
condition|)
block|{
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PPTIME
expr_stmt|;
name|pp
operator|->
name|p_flags
operator||=
name|PTIME
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|jobflags
operator|&
operator|(
name|PRUNNING
operator||
name|PREPORTED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|p_flags
operator|&
name|PSTOPPED
condition|)
name|fp
operator|->
name|p_flags
operator||=
name|PREPORTED
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
while|while
condition|(
name|fp
operator|->
name|p_pid
operator|!=
name|fp
operator|->
name|p_jobid
condition|)
name|fp
operator|=
name|fp
operator|->
name|p_friends
expr_stmt|;
if|if
condition|(
name|jobflags
operator|&
name|PSTOPPED
condition|)
block|{
if|if
condition|(
name|pcurrent
operator|&&
name|pcurrent
operator|!=
name|fp
condition|)
name|pprevious
operator|=
name|pcurrent
expr_stmt|;
name|pcurrent
operator|=
name|fp
expr_stmt|;
block|}
else|else
name|pclrcurr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobflags
operator|&
name|PFOREGND
condition|)
block|{
if|if
condition|(
name|jobflags
operator|&
operator|(
name|PSIGNALED
operator||
name|PSTOPPED
operator||
name|PPTIME
operator|)
operator|||
operator|!
name|eq
argument_list|(
name|dcwd
operator|->
name|di_name
argument_list|,
name|fp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* print in pjwait */
block|}
comment|/* 		else if ((jobflags& (PTIME|PSTOPPED)) == PTIME) 				ptprint(fp); */
block|}
else|else
block|{
if|if
condition|(
name|jobflags
operator|&
name|PNOTIFY
operator|||
name|adrof
argument_list|(
literal|"notify"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\215\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|NUMBER
operator||
name|NAME
operator||
name|REASON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PSTOPPED
operator|)
operator|==
literal|0
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|p_flags
operator||=
name|PNEEDNOTE
expr_stmt|;
name|neednote
operator|++
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_block

begin_macro
name|pnote
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|long
name|omask
decl_stmt|;
name|neednote
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
operator|!=
name|PNULL
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PNEEDNOTE
condition|)
block|{
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PNEEDNOTE
expr_stmt|;
name|flags
operator|=
name|pprint
argument_list|(
name|pp
argument_list|,
name|NUMBER
operator||
name|NAME
operator||
name|REASON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator|)
operator|)
operator|==
literal|0
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * pwait - wait for current job to terminate, maintaining integrity  *	of current and previous job indicators.  */
end_comment

begin_macro
name|pwait
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|fp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|long
name|omask
decl_stmt|;
comment|/* 	 * Here's where dead procs get flushed. 	 */
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|(
name|fp
operator|=
operator|&
name|proclist
operator|)
operator|->
name|p_next
init|;
name|pp
operator|!=
name|PNULL
condition|;
name|pp
operator|=
operator|(
name|fp
operator|=
name|pp
operator|)
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|p_next
operator|=
name|pp
operator|->
name|p_next
expr_stmt|;
name|xfree
argument_list|(
name|pp
operator|->
name|p_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_cwd
operator|&&
operator|--
name|pp
operator|->
name|p_cwd
operator|->
name|di_count
operator|==
literal|0
condition|)
if|if
condition|(
name|pp
operator|->
name|p_cwd
operator|->
name|di_next
operator|==
literal|0
condition|)
name|dfree
argument_list|(
name|pp
operator|->
name|p_cwd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|=
name|fp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|pjwait
argument_list|(
name|pcurrjob
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pjwait - wait for a job to finish or become stopped  *	It is assumed to be in the foreground state (PFOREGND)  */
end_comment

begin_expr_stmt
name|pjwait
argument_list|(
name|pp
argument_list|)
specifier|register
expr|struct
name|process
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|fp
decl_stmt|;
name|int
name|jobflags
decl_stmt|,
name|reason
decl_stmt|;
name|long
name|omask
decl_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|p_flags
operator|&
operator|(
name|PFOREGND
operator||
name|PRUNNING
operator|)
operator|)
operator|==
name|PRUNNING
condition|)
name|printf
argument_list|(
literal|"BUG: waiting for background job!\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
comment|/* 	 * Now keep pausing as long as we are not interrupted (SIGINT), 	 * and the target process, or any of its friends, are running 	 */
name|fp
operator|=
name|pp
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|jobflags
operator|=
literal|0
expr_stmt|;
do|do
name|jobflags
operator||=
name|fp
operator|->
name|p_flags
expr_stmt|;
do|while
condition|(
operator|(
name|fp
operator|=
operator|(
name|fp
operator|->
name|p_friends
operator|)
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PRUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|sigpause
argument_list|(
name|sigblock
argument_list|(
literal|0L
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpgrp
operator|>
literal|0
condition|)
comment|/* get tty back */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tpgrp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jobflags
operator|&
operator|(
name|PSIGNALED
operator||
name|PSTOPPED
operator||
name|PTIME
operator|)
operator|)
operator|||
operator|!
name|eq
argument_list|(
name|dcwd
operator|->
name|di_name
argument_list|,
name|fp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|jobflags
operator|&
name|PSTOPPED
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|AREASON
operator||
name|SHELLDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|jobflags
operator|&
operator|(
name|PINTERRUPTED
operator||
name|PSTOPPED
operator|)
operator|)
operator|&&
name|setintr
operator|&&
operator|(
operator|!
name|gointr
operator|||
operator|!
name|eq
argument_list|(
name|gointr
argument_list|,
literal|"-"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PSTOPPED
operator|)
operator|==
literal|0
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pintr1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|reason
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|p_reason
condition|)
name|reason
operator|=
name|fp
operator|->
name|p_flags
operator|&
operator|(
name|PSIGNALED
operator||
name|PINTERRUPTED
operator|)
condition|?
name|fp
operator|->
name|p_reason
operator||
name|QUOTE
else|:
name|fp
operator|->
name|p_reason
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
name|set
argument_list|(
literal|"status"
argument_list|,
name|putn
argument_list|(
name|reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|&&
name|exiterr
condition|)
name|exitstat
argument_list|()
expr_stmt|;
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dowait - wait for all processes to finish  */
end_comment

begin_macro
name|dowait
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|long
name|omask
decl_stmt|;
name|pjobs
operator|++
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|&&
comment|/* pp->p_pid == pp->p_jobid&& */
name|pp
operator|->
name|p_flags
operator|&
name|PRUNNING
condition|)
block|{
name|sigpause
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|pjobs
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pflushall - flush all jobs from list (e.g. at fork())  */
end_comment

begin_macro
name|pflushall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
operator|!=
name|PNULL
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pflush - flag all process structures in the same job as the  *	the argument process for deletion.  The actual free of the  *	space is not done here since pflush is called at interrupt level.  */
end_comment

begin_expr_stmt
name|pflush
argument_list|(
name|pp
argument_list|)
specifier|register
expr|struct
name|process
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"BUG: process flushed twice"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
name|pclrcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|pcurrjob
condition|)
name|pcurrjob
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|pp
operator|->
name|p_index
expr_stmt|;
name|np
operator|=
name|pp
expr_stmt|;
do|do
block|{
name|np
operator|->
name|p_index
operator|=
name|np
operator|->
name|p_pid
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PNEEDNOTE
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
name|index
operator|==
name|pmaxindex
condition|)
block|{
for|for
control|(
name|np
operator|=
name|proclist
operator|.
name|p_next
operator|,
name|index
operator|=
literal|0
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|p_next
control|)
if|if
condition|(
name|np
operator|->
name|p_index
operator|>
name|index
condition|)
name|index
operator|=
name|np
operator|->
name|p_index
expr_stmt|;
name|pmaxindex
operator|=
name|index
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * pclrcurr - make sure the given job is not the current or previous job;  *	pp MUST be the job leader  */
end_comment

begin_expr_stmt
name|pclrcurr
argument_list|(
name|pp
argument_list|)
specifier|register
expr|struct
name|process
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|pp
operator|==
name|pcurrent
condition|)
if|if
condition|(
name|pprevious
operator|!=
name|PNULL
condition|)
block|{
name|pcurrent
operator|=
name|pprevious
expr_stmt|;
name|pprevious
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcurrent
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pprevious
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|==
name|pprevious
condition|)
name|pprevious
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* +4 here is 1 for '\0', 1 ea for<<>&>> */
end_comment

begin_decl_stmt
name|char
name|command
index|[
name|PMAXLEN
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmdlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmdp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * palloc - allocate a process structure and fill it up.  *	an important assumption is made that the process is running.  */
end_comment

begin_macro
name|palloc
argument_list|(
argument|pid
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|command
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|process
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|process
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_pid
operator|=
name|pid
expr_stmt|;
name|pp
operator|->
name|p_flags
operator|=
name|t
operator|->
name|t_dflg
operator|&
name|FAND
condition|?
name|PRUNNING
else|:
name|PRUNNING
operator||
name|PFOREGND
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FTIME
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PPTIME
expr_stmt|;
name|cmdp
operator|=
name|command
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|padd
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|cmdp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FPOU
condition|)
block|{
name|pp
operator|->
name|p_flags
operator||=
name|PPOU
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FDIAG
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PDIAG
expr_stmt|;
block|}
name|pp
operator|->
name|p_command
operator|=
name|savestr
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcurrjob
condition|)
block|{
name|struct
name|process
modifier|*
name|fp
decl_stmt|;
comment|/* careful here with interrupt level */
name|pp
operator|->
name|p_cwd
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|p_index
operator|=
name|pcurrjob
operator|->
name|p_index
expr_stmt|;
name|pp
operator|->
name|p_friends
operator|=
name|pcurrjob
expr_stmt|;
name|pp
operator|->
name|p_jobid
operator|=
name|pcurrjob
operator|->
name|p_pid
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|pcurrjob
init|;
name|fp
operator|->
name|p_friends
operator|!=
name|pcurrjob
condition|;
name|fp
operator|=
name|fp
operator|->
name|p_friends
control|)
empty_stmt|;
name|fp
operator|->
name|p_friends
operator|=
name|pp
expr_stmt|;
block|}
else|else
block|{
name|pcurrjob
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|p_jobid
operator|=
name|pid
expr_stmt|;
name|pp
operator|->
name|p_friends
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|p_cwd
operator|=
name|dcwd
expr_stmt|;
name|dcwd
operator|->
name|di_count
operator|++
expr_stmt|;
if|if
condition|(
name|pmaxindex
operator|<
name|BIGINDEX
condition|)
name|pp
operator|->
name|p_index
operator|=
operator|++
name|pmaxindex
expr_stmt|;
else|else
block|{
name|struct
name|process
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|np
operator|=
name|proclist
operator|.
name|p_next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|p_next
control|)
if|if
condition|(
name|np
operator|->
name|p_index
operator|==
name|i
condition|)
goto|goto
name|tryagain
goto|;
name|pp
operator|->
name|p_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|pmaxindex
condition|)
name|pmaxindex
operator|=
name|i
expr_stmt|;
break|break;
name|tryagain
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|pcurrent
operator|==
name|PNULL
condition|)
name|pcurrent
operator|=
name|pp
expr_stmt|;
elseif|else
if|if
condition|(
name|pprevious
operator|==
name|PNULL
condition|)
name|pprevious
operator|=
name|pp
expr_stmt|;
block|}
name|pp
operator|->
name|p_next
operator|=
name|proclist
operator|.
name|p_next
expr_stmt|;
name|proclist
operator|.
name|p_next
operator|=
name|pp
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|pp
operator|->
name|p_btime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|padd
argument_list|(
name|t
argument_list|)
specifier|register
expr|struct
name|command
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|t
operator|->
name|t_dtyp
condition|)
block|{
case|case
name|TPAR
case|:
name|pads
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
name|padd
argument_list|(
name|t
operator|->
name|t_dspr
argument_list|)
expr_stmt|;
name|pads
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCOM
case|:
for|for
control|(
name|argp
operator|=
name|t
operator|->
name|t_dcom
init|;
operator|*
name|argp
condition|;
name|argp
operator|++
control|)
block|{
name|pads
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
index|[
literal|1
index|]
condition|)
name|pads
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TOR
case|:
case|case
name|TAND
case|:
case|case
name|TFIL
case|:
case|case
name|TLST
case|:
name|padd
argument_list|(
name|t
operator|->
name|t_dcar
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|t_dtyp
condition|)
block|{
case|case
name|TOR
case|:
name|pads
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAND
case|:
name|pads
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFIL
case|:
name|pads
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLST
case|:
name|pads
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
break|break;
block|}
name|padd
argument_list|(
name|t
operator|->
name|t_dcdr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|FPIN
operator|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_dlef
condition|)
block|{
name|pads
argument_list|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|FHERE
operator|)
condition|?
literal|"<< "
else|:
literal|"< "
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|t
operator|->
name|t_dlef
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|FPOU
operator|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_drit
condition|)
block|{
name|pads
argument_list|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|FCAT
operator|)
condition|?
literal|">>"
else|:
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FDIAG
condition|)
name|pads
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
name|pads
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|t
operator|->
name|t_drit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pads
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|strlen
argument_list|(
name|cp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmdlen
operator|>=
name|PMAXLEN
condition|)
return|return;
if|if
condition|(
name|cmdlen
operator|+
name|i
operator|>=
name|PMAXLEN
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cmdp
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
name|cmdlen
operator|=
name|PMAXLEN
expr_stmt|;
name|cmdp
operator|+=
literal|4
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cmdp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cmdp
operator|+=
name|i
expr_stmt|;
name|cmdlen
operator|+=
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * psavejob - temporarily save the current job on a one level stack  *	so another job can be created.  Used for { } in exp6  *	and `` in globbing.  */
end_comment

begin_macro
name|psavejob
argument_list|()
end_macro

begin_block
block|{
name|pholdjob
operator|=
name|pcurrjob
expr_stmt|;
name|pcurrjob
operator|=
name|PNULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * prestjob - opposite of psavejob.  This may be missed if we are interrupted  *	somewhere, but pendjob cleans up anyway.  */
end_comment

begin_macro
name|prestjob
argument_list|()
end_macro

begin_block
block|{
name|pcurrjob
operator|=
name|pholdjob
expr_stmt|;
name|pholdjob
operator|=
name|PNULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pendjob - indicate that a job (set of commands) has been completed  *	or is about to begin.  */
end_comment

begin_macro
name|pendjob
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|pcurrjob
operator|&&
operator|(
name|pcurrjob
operator|->
name|p_flags
operator|&
operator|(
name|PFOREGND
operator||
name|PSTOPPED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pp
operator|=
name|pcurrjob
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
name|printf
argument_list|(
literal|"[%d]"
argument_list|,
name|pp
operator|->
name|p_index
argument_list|)
expr_stmt|;
name|tp
operator|=
name|pp
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|pp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
block|}
do|while
condition|(
name|pp
operator|!=
name|tp
condition|)
do|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|pholdjob
operator|=
name|pcurrjob
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pprint - print a job  */
end_comment

begin_expr_stmt
name|pprint
argument_list|(
name|pp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|process
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|status
operator|,
name|reason
expr_stmt|;
name|struct
name|process
modifier|*
name|tp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|linp
decl_stmt|,
name|linbuf
index|[]
decl_stmt|;
name|int
name|jobflags
decl_stmt|,
name|pstatus
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|pp
operator|->
name|p_friends
operator|&&
operator|(
name|pp
operator|->
name|p_flags
operator|&
name|PPTIME
operator|)
condition|)
block|{
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PPTIME
expr_stmt|;
name|pp
operator|->
name|p_flags
operator||=
name|PTIME
expr_stmt|;
block|}
name|tp
operator|=
name|pp
expr_stmt|;
name|status
operator|=
name|reason
operator|=
operator|-
literal|1
expr_stmt|;
name|jobflags
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|jobflags
operator||=
name|pp
operator|->
name|p_flags
expr_stmt|;
name|pstatus
operator|=
name|pp
operator|->
name|p_flags
operator|&
name|PALLSTATES
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|pp
operator|&&
name|linp
operator|!=
name|linbuf
operator|&&
operator|!
operator|(
name|flag
operator|&
name|FANCY
operator|)
operator|&&
operator|(
name|pstatus
operator|==
name|status
operator|&&
name|pp
operator|->
name|p_reason
operator|==
name|reason
operator|||
operator|!
operator|(
name|flag
operator|&
name|REASON
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tp
operator|!=
name|pp
operator|&&
name|linp
operator|!=
name|linbuf
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|NUMBER
condition|)
if|if
condition|(
name|pp
operator|==
name|tp
condition|)
name|printf
argument_list|(
literal|"[%d]%s %c "
argument_list|,
name|pp
operator|->
name|p_index
argument_list|,
name|pp
operator|->
name|p_index
operator|<
literal|10
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|pp
operator|==
name|pcurrent
condition|?
literal|'+'
else|:
operator|(
name|pp
operator|==
name|pprevious
condition|?
literal|'-'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"       "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FANCY
condition|)
name|printf
argument_list|(
literal|"%5d "
argument_list|,
name|pp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
operator|(
name|REASON
operator||
name|AREASON
operator|)
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|NAME
condition|)
name|format
operator|=
literal|"%-23s"
expr_stmt|;
else|else
name|format
operator|=
literal|"%s"
expr_stmt|;
if|if
condition|(
name|pstatus
operator|==
name|status
condition|)
if|if
condition|(
name|pp
operator|->
name|p_reason
operator|==
name|reason
condition|)
block|{
name|printf
argument_list|(
name|format
argument_list|,
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|prcomd
goto|;
block|}
else|else
name|reason
operator|=
name|pp
operator|->
name|p_reason
expr_stmt|;
else|else
block|{
name|status
operator|=
name|pstatus
expr_stmt|;
name|reason
operator|=
name|pp
operator|->
name|p_reason
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|PRUNNING
case|:
name|printf
argument_list|(
name|format
argument_list|,
literal|"Running "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PINTERRUPTED
case|:
case|case
name|PSTOPPED
case|:
case|case
name|PSIGNALED
case|:
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|REASON
operator||
name|AREASON
operator|)
operator|)
operator|&&
name|reason
operator|!=
name|SIGINT
operator|&&
name|reason
operator|!=
name|SIGPIPE
condition|)
name|printf
argument_list|(
name|format
argument_list|,
name|mesg
index|[
name|pp
operator|->
name|p_reason
index|]
operator|.
name|pname
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNEXITED
case|:
case|case
name|PAEXITED
case|:
if|if
condition|(
name|flag
operator|&
name|REASON
condition|)
if|if
condition|(
name|pp
operator|->
name|p_reason
condition|)
name|printf
argument_list|(
literal|"Exit %-16d"
argument_list|,
name|pp
operator|->
name|p_reason
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|format
argument_list|,
literal|"Done"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"BUG: status=%-9o"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|prcomd
label|:
if|if
condition|(
name|flag
operator|&
name|NAME
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|pp
operator|->
name|p_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PPOU
condition|)
name|printf
argument_list|(
literal|" |"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PDIAG
condition|)
name|printf
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
operator|(
name|REASON
operator||
name|AREASON
operator|)
operator|&&
name|pp
operator|->
name|p_flags
operator|&
name|PDUMPED
condition|)
name|printf
argument_list|(
literal|" (core dumped)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|pp
operator|->
name|p_friends
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|AMPERSAND
condition|)
name|printf
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|JOBDIR
operator|&&
operator|!
name|eq
argument_list|(
name|tp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|,
name|dcwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" (wd: "
argument_list|)
expr_stmt|;
name|dtildepr
argument_list|(
name|value
argument_list|(
literal|"home"
argument_list|)
argument_list|,
name|tp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PPTIME
operator|&&
operator|!
operator|(
name|status
operator|&
operator|(
name|PSTOPPED
operator||
name|PRUNNING
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|linp
operator|!=
name|linbuf
condition|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|{
specifier|static
name|struct
name|rusage
name|zru
decl_stmt|;
name|prusage
argument_list|(
operator|&
name|zru
argument_list|,
operator|&
name|pp
operator|->
name|p_rusage
argument_list|,
operator|&
name|pp
operator|->
name|p_etime
argument_list|,
operator|&
name|pp
operator|->
name|p_btime
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|==
name|pp
operator|->
name|p_friends
condition|)
block|{
if|if
condition|(
name|linp
operator|!=
name|linbuf
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SHELLDIR
operator|&&
operator|!
name|eq
argument_list|(
name|tp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|,
name|dcwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"(wd now: "
argument_list|)
expr_stmt|;
name|dtildepr
argument_list|(
name|value
argument_list|(
literal|"home"
argument_list|)
argument_list|,
name|dcwd
operator|->
name|di_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|pp
operator|=
name|pp
operator|->
name|p_friends
operator|)
operator|!=
name|tp
condition|)
do|;
if|if
condition|(
name|jobflags
operator|&
name|PTIME
operator|&&
operator|(
name|jobflags
operator|&
operator|(
name|PSTOPPED
operator||
name|PRUNNING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|jobflags
operator|&
name|NUMBER
condition|)
name|printf
argument_list|(
literal|"       "
argument_list|)
expr_stmt|;
name|ptprint
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|jobflags
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ptprint
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|process
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|timeval
name|tetime
decl_stmt|,
name|diff
decl_stmt|;
specifier|static
name|struct
name|timeval
name|ztime
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
specifier|static
name|struct
name|rusage
name|zru
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|pp
init|=
name|tp
decl_stmt|;
name|ru
operator|=
name|zru
expr_stmt|;
name|tetime
operator|=
name|ztime
expr_stmt|;
do|do
block|{
name|ruadd
argument_list|(
operator|&
name|ru
argument_list|,
operator|&
name|pp
operator|->
name|p_rusage
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|pp
operator|->
name|p_etime
argument_list|,
operator|&
name|pp
operator|->
name|p_btime
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|tetime
argument_list|,
operator|>
argument_list|)
condition|)
name|tetime
operator|=
name|diff
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pp
operator|=
name|pp
operator|->
name|p_friends
operator|)
operator|!=
name|tp
condition|)
do|;
name|prusage
argument_list|(
operator|&
name|zru
argument_list|,
operator|&
name|ru
argument_list|,
operator|&
name|tetime
argument_list|,
operator|&
name|ztime
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dojobs - print all jobs  */
end_comment

begin_macro
name|dojobs
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|flag
init|=
name|NUMBER
operator||
name|NAME
operator||
name|REASON
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chkstop
condition|)
name|chkstop
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|v
condition|)
block|{
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|||
operator|!
name|eq
argument_list|(
operator|*
name|v
argument_list|,
literal|"-l"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Usage: jobs [ -l ]"
argument_list|)
expr_stmt|;
name|flag
operator||=
name|FANCY
operator||
name|JOBDIR
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|pmaxindex
condition|;
name|i
operator|++
control|)
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_index
operator|==
name|i
operator|&&
name|pp
operator|->
name|p_pid
operator|==
name|pp
operator|->
name|p_jobid
condition|)
block|{
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PNEEDNOTE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pprint
argument_list|(
name|pp
argument_list|,
name|flag
argument_list|)
operator|&
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator|)
operator|)
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * dofg - builtin - put the job into the foreground  */
end_comment

begin_macro
name|dofg
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|okpcntl
argument_list|()
expr_stmt|;
operator|++
name|v
expr_stmt|;
do|do
block|{
name|pp
operator|=
name|pfind
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pjwait
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|v
operator|&&
operator|*
operator|++
name|v
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * %... - builtin - put the job into the foreground  */
end_comment

begin_macro
name|dofg1
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|okpcntl
argument_list|()
expr_stmt|;
name|pp
operator|=
name|pfind
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pjwait
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dobg - builtin - put the job into the background  */
end_comment

begin_macro
name|dobg
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|okpcntl
argument_list|()
expr_stmt|;
operator|++
name|v
expr_stmt|;
do|do
block|{
name|pp
operator|=
name|pfind
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|v
operator|&&
operator|*
operator|++
name|v
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * %...& - builtin - put the job into the background  */
end_comment

begin_macro
name|dobg1
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|pfind
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dostop - builtin - stop the job  */
end_comment

begin_macro
name|dostop
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pkill
argument_list|(
operator|++
name|v
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dokill - builtin - superset of kill (1)  */
end_comment

begin_macro
name|dokill
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|signum
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|0
index|]
operator|&&
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
for|for
control|(
name|signum
operator|=
literal|1
init|;
name|signum
operator|<=
name|NSIG
condition|;
name|signum
operator|++
control|)
block|{
if|if
condition|(
name|name
operator|=
name|mesg
index|[
name|signum
index|]
operator|.
name|iname
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|==
literal|16
condition|)
name|cshputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|cshputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|digit
argument_list|(
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|signum
operator|=
name|atoi
argument_list|(
name|v
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|<
literal|0
operator|||
name|signum
operator|>
name|NSIG
condition|)
name|bferr
argument_list|(
literal|"Bad signal number"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|&
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|signum
operator|=
literal|1
init|;
name|signum
operator|<=
name|NSIG
condition|;
name|signum
operator|++
control|)
if|if
condition|(
name|mesg
index|[
name|signum
index|]
operator|.
name|iname
operator|&&
name|eq
argument_list|(
name|name
argument_list|,
name|mesg
index|[
name|signum
index|]
operator|.
name|iname
argument_list|)
condition|)
goto|goto
name|gotsig
goto|;
name|setname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bferr
argument_list|(
literal|"Unknown signal; kill -l lists signals"
argument_list|)
expr_stmt|;
block|}
name|gotsig
label|:
name|v
operator|++
expr_stmt|;
block|}
else|else
name|signum
operator|=
name|SIGTERM
expr_stmt|;
name|pkill
argument_list|(
name|v
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pkill
argument_list|(
argument|v
argument_list|,
argument|signum
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|signum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|jobflags
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|long
name|omask
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|omask
operator|=
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|omask
operator||=
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|omask
argument_list|)
operator|&
operator|~
name|omask
expr_stmt|;
while|while
condition|(
operator|*
name|v
condition|)
block|{
name|cp
operator|=
name|globone
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
name|np
operator|=
name|pp
operator|=
name|pfind
argument_list|(
name|cp
argument_list|)
expr_stmt|;
do|do
name|jobflags
operator||=
name|np
operator|->
name|p_flags
expr_stmt|;
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
switch|switch
condition|(
name|signum
condition|)
block|{
case|case
name|SIGSTOP
case|:
case|case
name|SIGTSTP
case|:
case|case
name|SIGTTIN
case|:
case|case
name|SIGTTOU
case|:
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PRUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Already suspended\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
block|}
if|if
condition|(
name|killpg
argument_list|(
name|pp
operator|->
name|p_jobid
argument_list|,
name|signum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|signum
operator|==
name|SIGTERM
operator|||
name|signum
operator|==
name|SIGHUP
condition|)
operator|(
name|void
operator|)
name|killpg
argument_list|(
name|pp
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|digit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|bferr
argument_list|(
literal|"Arguments should be jobs or process id's"
argument_list|)
expr_stmt|;
else|else
block|{
name|pid
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill
argument_list|(
name|pid
argument_list|,
name|signum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
if|if
condition|(
name|signum
operator|==
name|SIGTERM
operator|||
name|signum
operator|==
name|SIGHUP
condition|)
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
name|cont
label|:
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pstart - start the job in foreground/background  */
end_comment

begin_expr_stmt
name|pstart
argument_list|(
name|pp
argument_list|,
name|foregnd
argument_list|)
specifier|register
expr|struct
name|process
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|foregnd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|np
decl_stmt|;
name|int
name|jobflags
init|=
literal|0
decl_stmt|;
name|long
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
name|pp
expr_stmt|;
do|do
block|{
name|jobflags
operator||=
name|np
operator|->
name|p_flags
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|p_flags
operator|&
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator|)
condition|)
block|{
name|np
operator|->
name|p_flags
operator||=
name|PRUNNING
expr_stmt|;
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PSTOPPED
expr_stmt|;
if|if
condition|(
name|foregnd
condition|)
name|np
operator|->
name|p_flags
operator||=
name|PFOREGND
expr_stmt|;
else|else
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PFOREGND
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
operator|!
name|foregnd
condition|)
name|pclrcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|foregnd
condition|?
name|NAME
operator||
name|JOBDIR
else|:
name|NUMBER
operator||
name|NAME
operator||
name|AMPERSAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|foregnd
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|p_jobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobflags
operator|&
name|PSTOPPED
condition|)
operator|(
name|void
operator|)
name|killpg
argument_list|(
name|pp
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|panystop
argument_list|(
argument|neednl
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|chkstop
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PSTOPPED
condition|)
name|error
argument_list|(
literal|"\nThere are suspended jobs"
operator|+
literal|1
operator|-
name|neednl
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|process
modifier|*
name|pfind
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|eq
argument_list|(
name|cp
argument_list|,
literal|"%%"
argument_list|)
operator|||
name|eq
argument_list|(
name|cp
argument_list|,
literal|"%+"
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcurrent
operator|==
name|PNULL
condition|)
name|bferr
argument_list|(
literal|"No current job"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcurrent
operator|)
return|;
block|}
if|if
condition|(
name|eq
argument_list|(
name|cp
argument_list|,
literal|"%-"
argument_list|)
operator|||
name|eq
argument_list|(
name|cp
argument_list|,
literal|"%#"
argument_list|)
condition|)
block|{
if|if
condition|(
name|pprevious
operator|==
name|PNULL
condition|)
name|bferr
argument_list|(
literal|"No previous job"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pprevious
operator|)
return|;
block|}
if|if
condition|(
name|digit
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|index
init|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_index
operator|==
name|index
operator|&&
name|pp
operator|->
name|p_pid
operator|==
name|pp
operator|->
name|p_jobid
condition|)
return|return
operator|(
name|pp
operator|)
return|;
name|bferr
argument_list|(
literal|"No such job"
argument_list|)
expr_stmt|;
block|}
name|np
operator|=
name|PNULL
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|==
name|pp
operator|->
name|p_jobid
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|pp
operator|->
name|p_command
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|dp
operator|!=
name|cp
index|[
literal|2
index|]
condition|)
continue|continue;
if|if
condition|(
name|prefix
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
name|dp
argument_list|)
condition|)
goto|goto
name|match
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|prefix
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|pp
operator|->
name|p_command
argument_list|)
condition|)
block|{
name|match
label|:
if|if
condition|(
name|np
condition|)
name|bferr
argument_list|(
literal|"Ambiguous"
argument_list|)
expr_stmt|;
name|np
operator|=
name|pp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
condition|)
return|return
operator|(
name|np
operator|)
return|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
name|bferr
argument_list|(
literal|"No job matches pattern"
argument_list|)
expr_stmt|;
else|else
name|bferr
argument_list|(
literal|"No such job"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * pgetcurr - find most recent job that is not pp, preferably stopped  */
end_comment

begin_function
name|struct
name|process
modifier|*
name|pgetcurr
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|xp
init|=
name|PNULL
decl_stmt|;
for|for
control|(
name|np
operator|=
name|proclist
operator|.
name|p_next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|p_next
control|)
if|if
condition|(
name|np
operator|!=
name|pcurrent
operator|&&
name|np
operator|!=
name|pp
operator|&&
name|np
operator|->
name|p_pid
operator|&&
name|np
operator|->
name|p_pid
operator|==
name|np
operator|->
name|p_jobid
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|p_flags
operator|&
name|PSTOPPED
condition|)
return|return
operator|(
name|np
operator|)
return|;
if|if
condition|(
name|xp
operator|==
name|PNULL
condition|)
name|xp
operator|=
name|np
expr_stmt|;
block|}
return|return
operator|(
name|xp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * donotify - flag the job so as to report termination asynchronously  */
end_comment

begin_macro
name|donotify
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|pfind
argument_list|(
operator|*
operator|++
name|v
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_flags
operator||=
name|PNOTIFY
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do the fork and whatever should be done in the child side that  * should not be done if we are not forking at all (like for simple builtin's)  * Also do everything that needs any signals fiddled with in the parent side  *  * Wanttty tells whether process and/or tty pgrps are to be manipulated:  *	-1:	leave tty alone; inherit pgrp from parent  *	 0:	already have tty; manipulate process pgrps only  *	 1:	want to claim tty; manipulate process and tty pgrps  * It is usually just the value of tpgrp.  */
end_comment

begin_macro
name|pfork
argument_list|(
argument|t
argument_list|,
argument|wanttty
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|command
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command we are forking for */
end_comment

begin_decl_stmt
name|int
name|wanttty
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|bool
name|ignint
init|=
literal|0
decl_stmt|;
name|int
name|pgrp
decl_stmt|;
name|long
name|omask
decl_stmt|;
comment|/* 	 * A child will be uninterruptible only under very special 	 * conditions. Remember that the semantics of '&' is 	 * implemented by disconnecting the process from the tty so 	 * signals do not need to ignored just for '&'. 	 * Thus signals are set to default action for children unless: 	 *	we have had an "onintr -" (then specifically ignored) 	 *	we are not playing with signals (inherit action) 	 */
if|if
condition|(
name|setintr
condition|)
name|ignint
operator|=
operator|(
name|tpgrp
operator|==
operator|-
literal|1
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|FINT
operator|)
operator|)
operator|||
operator|(
name|gointr
operator|&&
name|eq
argument_list|(
name|gointr
argument_list|,
literal|"-"
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Hold SIGCHLD until we have the process installed in our table. 	 */
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
if|if
condition|(
name|setintr
operator|==
literal|0
condition|)
name|sleep
argument_list|(
name|FORKSLEEP
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No more processes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|settimes
argument_list|()
expr_stmt|;
name|pgrp
operator|=
name|pcurrjob
condition|?
name|pcurrjob
operator|->
name|p_jobid
else|:
name|getpid
argument_list|()
expr_stmt|;
name|pflushall
argument_list|()
expr_stmt|;
name|pcurrjob
operator|=
name|PNULL
expr_stmt|;
name|child
operator|++
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
name|setintr
operator|=
literal|0
expr_stmt|;
comment|/* until I think otherwise */
comment|/* 			 * Children just get blown away on SIGINT, SIGQUIT 			 * unless "onintr -" seen. 			 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ignint
condition|?
name|SIG_IGN
else|:
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|ignint
condition|?
name|SIG_IGN
else|:
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|wanttty
operator|>=
literal|0
condition|)
block|{
comment|/* make stoppable */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|parterm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|FINT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wanttty
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wanttty
operator|>=
literal|0
operator|&&
name|tpgrp
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpgrp
operator|>
literal|0
condition|)
name|tpgrp
operator|=
literal|0
expr_stmt|;
comment|/* gave tty away */
comment|/* 		 * Nohup and nice apply only to TCOM's but it would be 		 * nice (?!?) if you could say "nohup (foo;bar)" 		 * Then the parser would have to know about nice/nohup/time 		 */
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FNOHUP
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FNICE
condition|)
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|t_nice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wanttty
operator|>=
literal|0
operator|&&
name|tpgrp
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pcurrjob
condition|?
name|pcurrjob
operator|->
name|p_jobid
else|:
name|pid
argument_list|)
expr_stmt|;
name|palloc
argument_list|(
name|pid
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_block

begin_macro
name|okpcntl
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"No job control in this shell"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpgrp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No job control in subshells"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

