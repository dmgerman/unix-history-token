begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)func.c 4.11 84/07/03"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/*  * C shell  */
end_comment

begin_function
name|struct
name|biltins
modifier|*
name|isbfunc
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|biltins
modifier|*
name|bp
decl_stmt|;
name|int
name|dolabel
argument_list|()
decl_stmt|,
name|dofg1
argument_list|()
decl_stmt|,
name|dobg1
argument_list|()
decl_stmt|;
specifier|static
name|struct
name|biltins
name|label
init|=
block|{
literal|""
block|,
name|dolabel
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|biltins
name|foregnd
init|=
block|{
literal|"%job"
block|,
name|dofg1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|biltins
name|backgnd
init|=
block|{
literal|"%job&"
block|,
name|dobg1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|lastchr
argument_list|(
name|cp
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|label
operator|.
name|bname
operator|=
name|cp
expr_stmt|;
return|return
operator|(
operator|&
name|label
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|FAND
condition|)
block|{
name|t
operator|->
name|t_dflg
operator|&=
operator|~
name|FAND
expr_stmt|;
name|backgnd
operator|.
name|bname
operator|=
name|cp
expr_stmt|;
return|return
operator|(
operator|&
name|backgnd
operator|)
return|;
block|}
name|foregnd
operator|.
name|bname
operator|=
name|cp
expr_stmt|;
return|return
operator|(
operator|&
name|foregnd
operator|)
return|;
block|}
for|for
control|(
name|bp
operator|=
name|bfunc
init|;
name|dp
operator|=
name|bp
operator|->
name|bname
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
name|cp
index|[
literal|0
index|]
operator|&&
name|eq
argument_list|(
name|dp
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
name|bp
operator|)
return|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|>
name|cp
index|[
literal|0
index|]
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|func
argument_list|(
name|t
argument_list|,
name|bp
argument_list|)
specifier|register
expr|struct
name|command
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|biltins
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|xechoit
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|)
expr_stmt|;
name|setname
argument_list|(
name|bp
operator|->
name|bname
argument_list|)
expr_stmt|;
name|i
operator|=
name|blklen
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|bp
operator|->
name|minargs
condition|)
name|bferr
argument_list|(
literal|"Too few arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bp
operator|->
name|maxargs
condition|)
name|bferr
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bp
operator|->
name|bfunct
call|)
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dolabel
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|doonintr
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|vv
init|=
name|v
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|parintr
operator|==
name|SIG_IGN
condition|)
return|return;
if|if
condition|(
name|setintr
operator|&&
name|intty
condition|)
name|bferr
argument_list|(
literal|"Can't from terminal"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|gointr
operator|,
name|gointr
operator|=
literal|0
operator|,
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vv
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|setintr
condition|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
else|else
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|gointr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|(
name|vv
operator|=
name|strip
argument_list|(
name|vv
argument_list|)
operator|)
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|gointr
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
block|{
name|gointr
operator|=
name|savestr
argument_list|(
name|vv
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|pintr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|donohup
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|intty
condition|)
name|bferr
argument_list|(
literal|"Can't from terminal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CC
name|submit
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|dozip
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|prvars
argument_list|()
end_macro

begin_block
block|{
name|plist
argument_list|(
operator|&
name|shvhed
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doalias
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|varent
modifier|*
name|vp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|v
operator|++
expr_stmt|;
name|p
operator|=
operator|*
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|plist
argument_list|(
operator|&
name|aliases
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
block|{
name|vp
operator|=
name|adrof1
argument_list|(
name|strip
argument_list|(
name|p
argument_list|)
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|blkpr
argument_list|(
name|vp
operator|->
name|vec
argument_list|)
operator|,
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|eq
argument_list|(
name|p
argument_list|,
literal|"alias"
argument_list|)
operator|||
name|eq
argument_list|(
name|p
argument_list|,
literal|"unalias"
argument_list|)
condition|)
block|{
name|setname
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bferr
argument_list|(
literal|"Too dangerous to alias that"
argument_list|)
expr_stmt|;
block|}
name|set1
argument_list|(
name|strip
argument_list|(
name|p
argument_list|)
argument_list|,
name|saveblk
argument_list|(
name|v
argument_list|)
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|unalias
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unset1
argument_list|(
name|v
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dologout
argument_list|()
end_macro

begin_block
block|{
name|islogin
argument_list|()
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|dologin
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|islogin
argument_list|()
expr_stmt|;
name|rechist
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|parterm
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/login"
argument_list|,
literal|"login"
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|untty
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NEWGRP
end_ifdef

begin_macro
name|donewgrp
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|chkstop
operator|==
literal|0
operator|&&
name|setintr
condition|)
name|panystop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|parterm
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/newgrp"
argument_list|,
literal|"newgrp"
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/newgrp"
argument_list|,
literal|"newgrp"
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|untty
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|islogin
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|chkstop
operator|==
literal|0
operator|&&
name|setintr
condition|)
name|panystop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
return|return;
name|error
argument_list|(
literal|"Not login shell"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doif
argument_list|(
argument|v
argument_list|,
argument|kp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command
modifier|*
name|kp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vv
decl_stmt|;
name|v
operator|++
expr_stmt|;
name|i
operator|=
name|exp
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|vv
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|*
name|vv
operator|==
name|NOSTR
condition|)
name|bferr
argument_list|(
literal|"Empty if"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
operator|*
name|vv
argument_list|,
literal|"then"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|vv
condition|)
name|bferr
argument_list|(
literal|"Improper then"
argument_list|)
expr_stmt|;
name|setname
argument_list|(
literal|"then"
argument_list|)
expr_stmt|;
comment|/* 		 * If expression was zero, then scan to else, 		 * otherwise just fall into following code. 		 */
if|if
condition|(
operator|!
name|i
condition|)
name|search
argument_list|(
name|ZIF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Simple command attached to this if. 	 * Left shift the node in this tree, munging it 	 * so we can reexecute it. 	 */
if|if
condition|(
name|i
condition|)
block|{
name|lshift
argument_list|(
name|kp
operator|->
name|t_dcom
argument_list|,
name|vv
operator|-
name|kp
operator|->
name|t_dcom
argument_list|)
expr_stmt|;
name|reexecute
argument_list|(
name|kp
argument_list|)
expr_stmt|;
name|donefds
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Reexecute a command, being careful not  * to redo i/o redirection, which is already set up.  */
end_comment

begin_expr_stmt
name|reexecute
argument_list|(
name|kp
argument_list|)
specifier|register
expr|struct
name|command
operator|*
name|kp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|kp
operator|->
name|t_dflg
operator|&=
name|FSAVE
expr_stmt|;
name|kp
operator|->
name|t_dflg
operator||=
name|FREDO
expr_stmt|;
comment|/* 	 * If tty is still ours to arbitrate, arbitrate it; 	 * otherwise dont even set pgrp's as the jobs would 	 * then have no way to get the tty (we can't give it 	 * to them, and our parent wouldn't know their pgrp, etc. 	 */
name|execute
argument_list|(
name|kp
argument_list|,
name|tpgrp
operator|>
literal|0
condition|?
name|tpgrp
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doelse
argument_list|()
end_macro

begin_block
block|{
name|search
argument_list|(
name|ZELSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dogoto
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|whyle
modifier|*
name|wp
decl_stmt|;
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* 	 * While we still can, locate any unknown ends of existing loops. 	 * This obscure code is the WORST result of the fact that we 	 * don't really parse. 	 */
for|for
control|(
name|wp
operator|=
name|whyles
init|;
name|wp
condition|;
name|wp
operator|=
name|wp
operator|->
name|w_next
control|)
if|if
condition|(
name|wp
operator|->
name|w_end
operator|==
literal|0
condition|)
block|{
name|search
argument_list|(
name|ZBREAK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp
operator|->
name|w_end
operator|=
name|btell
argument_list|()
expr_stmt|;
block|}
else|else
name|bseek
argument_list|(
name|wp
operator|->
name|w_end
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|ZGOTO
argument_list|,
literal|0
argument_list|,
name|lp
operator|=
name|globone
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* 	 * Eliminate loops which were exited. 	 */
name|wfree
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doswitch
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|v
operator|||
operator|*
operator|(
operator|*
name|v
operator|++
operator|)
operator|!=
literal|'('
condition|)
goto|goto
name|syntax
goto|;
name|cp
operator|=
operator|*
operator|*
name|v
operator|==
literal|')'
condition|?
literal|""
else|:
operator|*
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|v
operator|++
operator|)
operator|!=
literal|')'
condition|)
name|v
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|v
condition|)
name|syntax
label|:
name|error
argument_list|(
literal|"Syntax error"
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|ZSWITCH
argument_list|,
literal|0
argument_list|,
name|lp
operator|=
name|globone
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dobreak
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|whyles
condition|)
name|toend
argument_list|()
expr_stmt|;
else|else
name|bferr
argument_list|(
literal|"Not in while/foreach"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doexit
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|chkstop
operator|==
literal|0
condition|)
name|panystop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Don't DEMAND parentheses here either. 	 */
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
condition|)
block|{
name|set
argument_list|(
literal|"status"
argument_list|,
name|putn
argument_list|(
name|exp
argument_list|(
operator|&
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
condition|)
name|bferr
argument_list|(
literal|"Expression syntax"
argument_list|)
expr_stmt|;
block|}
name|btoeof
argument_list|()
expr_stmt|;
if|if
condition|(
name|intty
condition|)
name|close
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doforeach
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|whyle
modifier|*
name|nwp
decl_stmt|;
name|v
operator|++
expr_stmt|;
name|cp
operator|=
name|strip
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|letter
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|||
name|strlen
argument_list|(
operator|*
name|v
argument_list|)
operator|>=
literal|20
condition|)
name|bferr
argument_list|(
literal|"Invalid variable"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|*
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'('
operator|||
name|v
index|[
name|blklen
argument_list|(
name|v
argument_list|)
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|')'
condition|)
name|bferr
argument_list|(
literal|"Words not ()'ed"
argument_list|)
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|gflag
operator|=
literal|0
operator|,
name|rscan
argument_list|(
name|v
argument_list|,
name|tglob
argument_list|)
expr_stmt|;
name|v
operator|=
name|glob
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|bferr
argument_list|(
literal|"No match"
argument_list|)
expr_stmt|;
name|nwp
operator|=
operator|(
expr|struct
name|whyle
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|nwp
argument_list|)
expr_stmt|;
name|nwp
operator|->
name|w_fe
operator|=
name|nwp
operator|->
name|w_fe0
operator|=
name|v
expr_stmt|;
name|gargv
operator|=
literal|0
expr_stmt|;
name|nwp
operator|->
name|w_start
operator|=
name|btell
argument_list|()
expr_stmt|;
name|nwp
operator|->
name|w_fename
operator|=
name|savestr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|nwp
operator|->
name|w_next
operator|=
name|whyles
expr_stmt|;
name|whyles
operator|=
name|nwp
expr_stmt|;
comment|/* 	 * Pre-read the loop so as to be more 	 * comprehensible to a terminal user. 	 */
if|if
condition|(
name|intty
condition|)
name|preread
argument_list|()
expr_stmt|;
name|doagain
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|dowhile
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|bool
name|again
init|=
name|whyles
operator|!=
literal|0
operator|&&
name|whyles
operator|->
name|w_start
operator|==
name|lineloc
operator|&&
name|whyles
operator|->
name|w_fename
operator|==
literal|0
decl_stmt|;
name|v
operator|++
expr_stmt|;
comment|/* 	 * Implement prereading here also, taking care not to 	 * evaluate the expression before the loop has been read up 	 * from a terminal. 	 */
if|if
condition|(
name|intty
operator|&&
operator|!
name|again
condition|)
name|status
operator|=
operator|!
name|exp0
argument_list|(
operator|&
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
operator|!
name|exp
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
condition|)
name|bferr
argument_list|(
literal|"Expression syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|again
condition|)
block|{
specifier|register
name|struct
name|whyle
modifier|*
name|nwp
init|=
operator|(
expr|struct
name|whyle
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nwp
argument_list|)
argument_list|)
decl_stmt|;
name|nwp
operator|->
name|w_start
operator|=
name|lineloc
expr_stmt|;
name|nwp
operator|->
name|w_end
operator|=
literal|0
expr_stmt|;
name|nwp
operator|->
name|w_next
operator|=
name|whyles
expr_stmt|;
name|whyles
operator|=
name|nwp
expr_stmt|;
if|if
condition|(
name|intty
condition|)
block|{
comment|/* 			 * The tty preread 			 */
name|preread
argument_list|()
expr_stmt|;
name|doagain
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|status
condition|)
comment|/* We ain't gonna loop no more, no more! */
name|toend
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|preread
argument_list|()
end_macro

begin_block
block|{
name|whyles
operator|->
name|w_end
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|ZBREAK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|whyles
operator|->
name|w_end
operator|=
name|btell
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|doend
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|whyles
condition|)
name|bferr
argument_list|(
literal|"Not in while/foreach"
argument_list|)
expr_stmt|;
name|whyles
operator|->
name|w_end
operator|=
name|btell
argument_list|()
expr_stmt|;
name|doagain
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|docontin
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|whyles
condition|)
name|bferr
argument_list|(
literal|"Not in while/foreach"
argument_list|)
expr_stmt|;
name|doagain
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|doagain
argument_list|()
end_macro

begin_block
block|{
comment|/* Repeating a while is simple */
if|if
condition|(
name|whyles
operator|->
name|w_fename
operator|==
literal|0
condition|)
block|{
name|bseek
argument_list|(
name|whyles
operator|->
name|w_start
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The foreach variable list actually has a spurious word 	 * ")" at the end of the w_fe list.  Thus we are at the 	 * of the list if one word beyond this is 0. 	 */
if|if
condition|(
operator|!
name|whyles
operator|->
name|w_fe
index|[
literal|1
index|]
condition|)
block|{
name|dobreak
argument_list|()
expr_stmt|;
return|return;
block|}
name|set
argument_list|(
name|whyles
operator|->
name|w_fename
argument_list|,
name|savestr
argument_list|(
operator|*
name|whyles
operator|->
name|w_fe
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bseek
argument_list|(
name|whyles
operator|->
name|w_start
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dorepeat
argument_list|(
argument|v
argument_list|,
argument|kp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command
modifier|*
name|kp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|getn
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|lshift
argument_list|(
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|setintr
condition|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|reexecute
argument_list|(
name|kp
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
name|donefds
argument_list|()
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doswbrk
argument_list|()
end_macro

begin_block
block|{
name|search
argument_list|(
name|ZBRKSW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|srchx
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|srch
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|srchn
init|;
name|sp
operator|->
name|s_name
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|eq
argument_list|(
name|cp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
condition|)
return|return
operator|(
name|sp
operator|->
name|s_value
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|Stype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Sgoal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|search
argument_list|(
argument|type
argument_list|,
argument|level
argument_list|,
argument|goal
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|goal
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|wordbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|aword
init|=
name|wordbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|Stype
operator|=
name|type
expr_stmt|;
name|Sgoal
operator|=
name|goal
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZGOTO
condition|)
name|bseek
argument_list|(
literal|0l
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|intty
operator|&&
name|fseekp
operator|==
name|feobp
condition|)
name|printf
argument_list|(
literal|"? "
argument_list|)
operator|,
name|flush
argument_list|()
expr_stmt|;
name|aword
index|[
literal|0
index|]
operator|=
literal|0
operator|,
name|getword
argument_list|(
name|aword
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srchx
argument_list|(
name|aword
argument_list|)
condition|)
block|{
case|case
name|ZELSE
case|:
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
name|type
operator|==
name|ZIF
condition|)
return|return;
break|break;
case|case
name|ZIF
case|:
while|while
condition|(
name|getword
argument_list|(
name|aword
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|type
operator|==
name|ZIF
operator|||
name|type
operator|==
name|ZELSE
operator|)
operator|&&
name|eq
argument_list|(
name|aword
argument_list|,
literal|"then"
argument_list|)
condition|)
name|level
operator|++
expr_stmt|;
break|break;
case|case
name|ZENDIF
case|:
if|if
condition|(
name|type
operator|==
name|ZIF
operator|||
name|type
operator|==
name|ZELSE
condition|)
name|level
operator|--
expr_stmt|;
break|break;
case|case
name|ZFOREACH
case|:
case|case
name|ZWHILE
case|:
if|if
condition|(
name|type
operator|==
name|ZBREAK
condition|)
name|level
operator|++
expr_stmt|;
break|break;
case|case
name|ZEND
case|:
if|if
condition|(
name|type
operator|==
name|ZBREAK
condition|)
name|level
operator|--
expr_stmt|;
break|break;
case|case
name|ZSWITCH
case|:
if|if
condition|(
name|type
operator|==
name|ZSWITCH
operator|||
name|type
operator|==
name|ZBRKSW
condition|)
name|level
operator|++
expr_stmt|;
break|break;
case|case
name|ZENDSW
case|:
if|if
condition|(
name|type
operator|==
name|ZSWITCH
operator|||
name|type
operator|==
name|ZBRKSW
condition|)
name|level
operator|--
expr_stmt|;
break|break;
case|case
name|ZLABEL
case|:
if|if
condition|(
name|type
operator|==
name|ZGOTO
operator|&&
name|getword
argument_list|(
name|aword
argument_list|)
operator|&&
name|eq
argument_list|(
name|aword
argument_list|,
name|goal
argument_list|)
condition|)
name|level
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|type
operator|!=
name|ZGOTO
operator|&&
operator|(
name|type
operator|!=
name|ZSWITCH
operator|||
name|level
operator|!=
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|lastchr
argument_list|(
name|aword
argument_list|)
operator|!=
literal|':'
condition|)
break|break;
name|aword
index|[
name|strlen
argument_list|(
name|aword
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZGOTO
operator|&&
name|eq
argument_list|(
name|aword
argument_list|,
name|goal
argument_list|)
operator|||
name|type
operator|==
name|ZSWITCH
operator|&&
name|eq
argument_list|(
name|aword
argument_list|,
literal|"default"
argument_list|)
condition|)
name|level
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ZCASE
case|:
if|if
condition|(
name|type
operator|!=
name|ZSWITCH
operator|||
name|level
operator|!=
literal|0
condition|)
break|break;
name|getword
argument_list|(
name|aword
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastchr
argument_list|(
name|aword
argument_list|)
operator|==
literal|':'
condition|)
name|aword
index|[
name|strlen
argument_list|(
name|aword
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|strip
argument_list|(
name|Dfix1
argument_list|(
name|aword
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gmatch
argument_list|(
name|goal
argument_list|,
name|cp
argument_list|)
condition|)
name|level
operator|=
operator|-
literal|1
expr_stmt|;
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZDEFAULT
case|:
if|if
condition|(
name|type
operator|==
name|ZSWITCH
operator|&&
name|level
operator|==
literal|0
condition|)
name|level
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|getword
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|level
operator|>=
literal|0
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|getword
argument_list|(
name|wp
argument_list|)
specifier|register
name|char
operator|*
name|wp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|found
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
name|c
operator|=
name|readc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
do|do
block|{
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|readc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
name|c
operator|=
name|readc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|>=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
goto|goto
name|past
goto|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|wp
condition|)
break|break;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|unreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|c
operator|=
name|readc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|c
operator|=
name|readc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
literal|"'\""
argument_list|)
condition|)
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|d
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
name|c
condition|)
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
goto|goto
name|past
goto|;
if|if
condition|(
name|wp
condition|)
operator|*
name|wp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|d
operator|||
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
name|wp
operator|==
literal|0
condition|)
do|;
name|unreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
operator|*
operator|--
name|wp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
name|past
label|:
switch|switch
condition|(
name|Stype
condition|)
block|{
case|case
name|ZIF
case|:
name|bferr
argument_list|(
literal|"then/endif not found"
argument_list|)
expr_stmt|;
case|case
name|ZELSE
case|:
name|bferr
argument_list|(
literal|"endif not found"
argument_list|)
expr_stmt|;
case|case
name|ZBRKSW
case|:
case|case
name|ZSWITCH
case|:
name|bferr
argument_list|(
literal|"endsw not found"
argument_list|)
expr_stmt|;
case|case
name|ZBREAK
case|:
name|bferr
argument_list|(
literal|"end not found"
argument_list|)
expr_stmt|;
case|case
name|ZGOTO
case|:
name|setname
argument_list|(
name|Sgoal
argument_list|)
expr_stmt|;
name|bferr
argument_list|(
literal|"label not found"
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_macro
name|toend
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|whyles
operator|->
name|w_end
operator|==
literal|0
condition|)
block|{
name|search
argument_list|(
name|ZBREAK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|whyles
operator|->
name|w_end
operator|=
name|btell
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|bseek
argument_list|(
name|whyles
operator|->
name|w_end
argument_list|)
expr_stmt|;
name|wfree
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|wfree
argument_list|()
end_macro

begin_block
block|{
name|long
name|o
init|=
name|btell
argument_list|()
decl_stmt|;
while|while
condition|(
name|whyles
condition|)
block|{
specifier|register
name|struct
name|whyle
modifier|*
name|wp
init|=
name|whyles
decl_stmt|;
specifier|register
name|struct
name|whyle
modifier|*
name|nwp
init|=
name|wp
operator|->
name|w_next
decl_stmt|;
if|if
condition|(
name|o
operator|>=
name|wp
operator|->
name|w_start
operator|&&
operator|(
name|wp
operator|->
name|w_end
operator|==
literal|0
operator|||
name|o
operator|<
name|wp
operator|->
name|w_end
operator|)
condition|)
break|break;
if|if
condition|(
name|wp
operator|->
name|w_fe0
condition|)
name|blkfree
argument_list|(
name|wp
operator|->
name|w_fe0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|w_fename
condition|)
name|xfree
argument_list|(
name|wp
operator|->
name|w_fename
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
name|whyles
operator|=
name|nwp
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|doecho
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|echo
argument_list|(
literal|' '
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doglob
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|echo
argument_list|(
literal|0
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|echo
argument_list|(
argument|sep
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
name|sep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|nonl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|setintr
condition|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
return|return;
name|gflag
operator|=
literal|0
expr_stmt|;
name|rscan
argument_list|(
name|v
argument_list|,
name|tglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
block|{
name|v
operator|=
name|glob
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|bferr
argument_list|(
literal|"No match"
argument_list|)
expr_stmt|;
block|}
else|else
name|scan
argument_list|(
name|v
argument_list|,
name|trim
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|' '
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|v
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|nonl
operator|++
operator|,
name|v
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|v
operator|++
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
name|putchar
argument_list|(
name|c
operator||
name|QUOTE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
condition|)
name|putchar
argument_list|(
name|sep
operator||
name|QUOTE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|&&
name|nonl
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gargv
condition|)
name|blkfree
argument_list|(
name|gargv
argument_list|)
operator|,
name|gargv
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dosetenv
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|lp
init|=
name|globone
argument_list|(
name|v
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|setenv
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"PATH"
argument_list|)
condition|)
block|{
name|importpath
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|dohash
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dounsetenv
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|v
operator|++
expr_stmt|;
do|do
name|unsetenv
argument_list|(
operator|*
name|v
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|v
condition|)
do|;
block|}
end_block

begin_macro
name|setenv
argument_list|(
argument|name
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ep
init|=
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|blk
index|[
literal|2
index|]
decl_stmt|,
modifier|*
modifier|*
name|oep
init|=
name|ep
decl_stmt|;
for|for
control|(
init|;
operator|*
name|ep
condition|;
name|ep
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|name
operator|,
name|dp
operator|=
operator|*
name|ep
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
operator|*
name|dp
condition|;
name|cp
operator|++
operator|,
name|dp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
operator|||
operator|*
name|dp
operator|!=
literal|'='
condition|)
continue|continue;
name|cp
operator|=
name|strspl
argument_list|(
literal|"="
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
name|strspl
argument_list|(
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|ep
argument_list|,
name|trim
argument_list|)
expr_stmt|;
return|return;
block|}
name|blk
index|[
literal|0
index|]
operator|=
name|strspl
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|blk
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|blkspl
argument_list|(
name|environ
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oep
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|unsetenv
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ep
init|=
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
modifier|*
name|oep
init|=
name|ep
decl_stmt|;
for|for
control|(
init|;
operator|*
name|ep
condition|;
name|ep
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|name
operator|,
name|dp
operator|=
operator|*
name|ep
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
operator|*
name|dp
condition|;
name|cp
operator|++
operator|,
name|dp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
operator|||
operator|*
name|dp
operator|!=
literal|'='
condition|)
continue|continue;
name|cp
operator|=
operator|*
name|ep
expr_stmt|;
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|blkspl
argument_list|(
name|environ
argument_list|,
name|ep
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|=
name|cp
expr_stmt|;
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oep
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|doumask
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|v
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%o\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|digit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'8'
operator|&&
operator|*
name|cp
operator|!=
literal|'9'
condition|)
name|i
operator|=
name|i
operator|*
literal|8
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|0777
condition|)
name|bferr
argument_list|(
literal|"Improper mask"
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|limits
block|{
name|int
name|limconst
decl_stmt|;
name|char
modifier|*
name|limname
decl_stmt|;
name|int
name|limdiv
decl_stmt|;
name|char
modifier|*
name|limscale
decl_stmt|;
block|}
name|limits
index|[]
init|=
block|{
name|RLIMIT_CPU
block|,
literal|"cputime"
block|,
literal|1
block|,
literal|"seconds"
block|,
name|RLIMIT_FSIZE
block|,
literal|"filesize"
block|,
literal|1024
block|,
literal|"kbytes"
block|,
name|RLIMIT_DATA
block|,
literal|"datasize"
block|,
literal|1024
block|,
literal|"kbytes"
block|,
name|RLIMIT_STACK
block|,
literal|"stacksize"
block|,
literal|1024
block|,
literal|"kbytes"
block|,
name|RLIMIT_CORE
block|,
literal|"coredumpsize"
block|,
literal|1024
block|,
literal|"kbytes"
block|,
name|RLIMIT_RSS
block|,
literal|"memoryuse"
block|,
literal|1024
block|,
literal|"kbytes"
block|,
operator|-
literal|1
block|,
literal|0
block|, }
struct|;
end_struct

begin_function
name|struct
name|limits
modifier|*
name|findlim
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|struct
name|limits
modifier|*
name|lp
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|limits
init|;
name|lp
operator|->
name|limconst
operator|>=
literal|0
condition|;
name|lp
operator|++
control|)
if|if
condition|(
name|prefix
argument_list|(
name|cp
argument_list|,
name|lp
operator|->
name|limname
argument_list|)
condition|)
block|{
if|if
condition|(
name|res
condition|)
name|bferr
argument_list|(
literal|"Ambiguous"
argument_list|)
expr_stmt|;
name|res
operator|=
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
return|return
operator|(
name|res
operator|)
return|;
name|bferr
argument_list|(
literal|"No such limit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|dolimit
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|limits
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|limit
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|lp
operator|=
name|limits
operator|+
literal|1
init|;
name|lp
operator|->
name|limconst
operator|>=
literal|0
condition|;
name|lp
operator|++
control|)
name|plim
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
name|lp
operator|=
name|findlim
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|plim
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
name|limit
operator|=
name|getval
argument_list|(
name|lp
argument_list|,
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setlim
argument_list|(
name|lp
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getval
argument_list|(
name|lp
argument_list|,
name|v
argument_list|)
specifier|register
expr|struct
name|limits
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|float
name|f
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
name|char
modifier|*
name|cp
init|=
operator|*
name|v
operator|++
decl_stmt|;
name|f
operator|=
name|atof
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|digit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|||
operator|*
name|cp
operator|==
literal|'e'
operator|||
operator|*
name|cp
operator|==
literal|'E'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|f
operator|+
literal|0.5
argument_list|)
operator|*
name|lp
operator|->
name|limdiv
operator|)
return|;
name|cp
operator|=
operator|*
name|v
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|':'
case|:
if|if
condition|(
name|lp
operator|->
name|limconst
operator|!=
name|RLIMIT_CPU
condition|)
goto|goto
name|badscal
goto|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|f
operator|*
literal|60.0
operator|+
name|atof
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'h'
case|:
if|if
condition|(
name|lp
operator|->
name|limconst
operator|!=
name|RLIMIT_CPU
condition|)
goto|goto
name|badscal
goto|;
name|limtail
argument_list|(
name|cp
argument_list|,
literal|"hours"
argument_list|)
expr_stmt|;
name|f
operator|*=
literal|3600.
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|lp
operator|->
name|limconst
operator|==
name|RLIMIT_CPU
condition|)
block|{
name|limtail
argument_list|(
name|cp
argument_list|,
literal|"minutes"
argument_list|)
expr_stmt|;
name|f
operator|*=
literal|60.
expr_stmt|;
break|break;
block|}
case|case
literal|'M'
case|:
if|if
condition|(
name|lp
operator|->
name|limconst
operator|==
name|RLIMIT_CPU
condition|)
goto|goto
name|badscal
goto|;
operator|*
name|cp
operator|=
literal|'m'
expr_stmt|;
name|limtail
argument_list|(
name|cp
argument_list|,
literal|"megabytes"
argument_list|)
expr_stmt|;
name|f
operator|*=
literal|1024.
operator|*
literal|1024.
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|lp
operator|->
name|limconst
operator|!=
name|RLIMIT_CPU
condition|)
goto|goto
name|badscal
goto|;
name|limtail
argument_list|(
name|cp
argument_list|,
literal|"seconds"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|lp
operator|->
name|limconst
operator|==
name|RLIMIT_CPU
condition|)
goto|goto
name|badscal
goto|;
name|limtail
argument_list|(
name|cp
argument_list|,
literal|"kbytes"
argument_list|)
expr_stmt|;
name|f
operator|*=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|limtail
argument_list|(
name|cp
argument_list|,
literal|"unlimited"
argument_list|)
expr_stmt|;
return|return
operator|(
name|RLIM_INFINITY
operator|)
return|;
default|default:
name|badscal
label|:
name|bferr
argument_list|(
literal|"Improper or unknown scale factor"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|f
operator|+
literal|0.5
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|limtail
argument_list|(
argument|cp
argument_list|,
argument|str0
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|str0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|str
init|=
name|str0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
operator|*
name|str
condition|)
name|cp
operator|++
operator|,
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|error
argument_list|(
literal|"Bad scaling; did you mean ``%s''?"
argument_list|,
name|str0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|plim
argument_list|(
name|lp
argument_list|)
specifier|register
expr|struct
name|limits
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|printf
argument_list|(
literal|"%s \t"
argument_list|,
name|lp
operator|->
name|limname
argument_list|)
expr_stmt|;
name|getrlimit
argument_list|(
name|lp
operator|->
name|limconst
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|RLIM_INFINITY
condition|)
name|printf
argument_list|(
literal|"unlimited"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|limconst
operator|==
name|RLIMIT_CPU
condition|)
name|psecs
argument_list|(
operator|(
name|long
operator|)
name|rlim
operator|.
name|rlim_cur
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d %s"
argument_list|,
name|rlim
operator|.
name|rlim_cur
operator|/
name|lp
operator|->
name|limdiv
argument_list|,
name|lp
operator|->
name|limscale
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dounlimit
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|limits
modifier|*
name|lp
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|lp
operator|=
name|limits
operator|+
literal|1
init|;
name|lp
operator|->
name|limconst
operator|>=
literal|0
condition|;
name|lp
operator|++
control|)
name|setlim
argument_list|(
name|lp
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|v
condition|)
block|{
name|lp
operator|=
name|findlim
argument_list|(
operator|*
name|v
operator|++
argument_list|)
expr_stmt|;
name|setlim
argument_list|(
name|lp
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|setlim
argument_list|(
name|lp
argument_list|,
name|limit
argument_list|)
specifier|register
expr|struct
name|limits
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|getrlimit
argument_list|(
name|lp
operator|->
name|limconst
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|==
name|RLIM_INFINITY
operator|&&
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
else|else
name|rlim
operator|.
name|rlim_cur
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|lp
operator|->
name|limconst
argument_list|,
operator|&
name|rlim
argument_list|)
operator|<
literal|0
condition|)
name|Perror
argument_list|(
name|bname
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dosuspend
argument_list|()
end_macro

begin_block
block|{
name|int
argument_list|(
operator|*
name|old
argument_list|)
argument_list|()
decl_stmt|,
name|ldisc
decl_stmt|;
name|int
name|ctpgrp
decl_stmt|;
if|if
condition|(
name|loginsh
condition|)
name|error
argument_list|(
literal|"Can't suspend a login shell (yet)"
argument_list|)
expr_stmt|;
name|untty
argument_list|()
expr_stmt|;
name|old
operator|=
name|sigsys
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* the shell stops here */
name|sigsys
argument_list|(
name|SIGTSTP
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpgrp
operator|!=
operator|-
literal|1
condition|)
block|{
name|retry
label|:
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|ctpgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctpgrp
operator|!=
name|opgrp
condition|)
block|{
name|old
operator|=
name|sigsys
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
name|sigsys
argument_list|(
name|SIGTTIN
argument_list|,
name|old
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|shpgrp
argument_list|)
expr_stmt|;
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
block|}
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|oldisc
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldisc
operator|!=
name|NTTYDISC
condition|)
block|{
name|printf
argument_list|(
literal|"Switching to new tty driver...\n"
argument_list|)
expr_stmt|;
name|ldisc
operator|=
name|NTTYDISC
expr_stmt|;
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|doeval
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|oevalvec
init|=
name|evalvec
decl_stmt|;
name|char
modifier|*
name|oevalp
init|=
name|evalp
decl_stmt|;
name|jmp_buf
name|osetexit
decl_stmt|;
name|int
name|reenter
decl_stmt|;
name|char
modifier|*
modifier|*
name|gv
init|=
literal|0
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
return|return;
name|gflag
operator|=
literal|0
expr_stmt|;
name|rscan
argument_list|(
name|v
argument_list|,
name|tglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
block|{
name|gv
operator|=
name|v
operator|=
name|glob
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|gargv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No match"
argument_list|)
expr_stmt|;
name|v
operator|=
name|copyblk
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|scan
argument_list|(
name|v
argument_list|,
name|trim
argument_list|)
expr_stmt|;
name|getexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|reenter
operator|=
literal|0
expr_stmt|;
name|setexit
argument_list|()
expr_stmt|;
name|reenter
operator|++
expr_stmt|;
if|if
condition|(
name|reenter
operator|==
literal|1
condition|)
block|{
name|evalvec
operator|=
name|v
expr_stmt|;
name|evalp
operator|=
literal|0
expr_stmt|;
name|process
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|evalvec
operator|=
name|oevalvec
expr_stmt|;
name|evalp
operator|=
name|oevalp
expr_stmt|;
name|doneinp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gv
condition|)
name|blkfree
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|reenter
operator|>=
literal|2
condition|)
name|error
argument_list|(
name|NOSTR
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

