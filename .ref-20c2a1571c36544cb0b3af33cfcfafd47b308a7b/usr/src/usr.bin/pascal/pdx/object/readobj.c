begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)readobj.c 1.3 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read in the namelist from the obj file.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"mappings/filetab.h"
end_include

begin_include
include|#
directive|include
file|"mappings/linetab.h"
end_include

begin_define
define|#
directive|define
name|MAXSYMNO
value|2000
end_define

begin_decl_stmt
name|char
modifier|*
name|objname
init|=
literal|"obj"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|SYM
modifier|*
name|sym
index|[
name|MAXSYMNO
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|readobj
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|pxhdr
name|hdr
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|get
argument_list|(
name|fp
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|magicnum
operator|!=
name|MAGICNUM
condition|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
call|(
name|long
call|)
argument_list|(
name|HEADER_BYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pxhdr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get
argument_list|(
name|fp
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|magicnum
operator|!=
name|MAGICNUM
condition|)
block|{
name|fatal
argument_list|(
literal|"%s is not a Pascal object file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|.
name|symtabsize
operator|==
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"%s doesn't have symbolic information"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|objsize
operator|=
name|hdr
operator|.
name|objsize
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
operator|(
name|long
operator|)
name|objsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|get
argument_list|(
name|fp
argument_list|,
name|nlhdr
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"can't read nlhdr"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|option
argument_list|(
literal|'h'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nHeader information:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tobject size %d\n"
argument_list|,
name|objsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsymtab size %d\n"
argument_list|,
name|hdr
operator|.
name|symtabsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tstringsize  %d\n"
argument_list|,
name|nlhdr
operator|.
name|stringsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnsyms       %d\n"
argument_list|,
name|nlhdr
operator|.
name|nsyms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnfiles      %d\n"
argument_list|,
name|nlhdr
operator|.
name|nfiles
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnlines      %d\n"
argument_list|,
name|nlhdr
operator|.
name|nlines
argument_list|)
expr_stmt|;
block|}
name|stringtab
operator|=
name|alloc
argument_list|(
name|nlhdr
operator|.
name|stringsize
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|stringtab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|nlhdr
operator|.
name|stringsize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|readsyms
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|readfiles
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|readlines
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * allocate and read in file name information table  */
end_comment

begin_function
name|LOCAL
name|readfiles
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|FILETAB
modifier|*
name|ftp
decl_stmt|;
name|FILETAB
name|temp
decl_stmt|;
name|ADDRESS
name|prevaddr
decl_stmt|;
name|filetab
operator|=
name|alloc
argument_list|(
name|nlhdr
operator|.
name|nfiles
argument_list|,
name|FILETAB
argument_list|)
expr_stmt|;
name|ftp
operator|=
operator|&
name|filetab
index|[
literal|0
index|]
expr_stmt|;
name|prevaddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlhdr
operator|.
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|fread
argument_list|(
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|FILETAB
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|addr
operator|!=
name|prevaddr
condition|)
block|{
name|ftp
operator|++
expr_stmt|;
block|}
operator|*
name|ftp
operator|=
name|temp
expr_stmt|;
name|ftp
operator|->
name|filename
operator|+=
operator|(
name|int
operator|)
name|stringtab
expr_stmt|;
name|prevaddr
operator|=
name|ftp
operator|->
name|addr
expr_stmt|;
block|}
name|nlhdr
operator|.
name|nfiles
operator|=
operator|(
name|ftp
operator|-
operator|&
name|filetab
index|[
literal|0
index|]
operator|)
operator|+
literal|1
expr_stmt|;
name|skimsource
argument_list|(
name|filetab
index|[
literal|0
index|]
operator|.
name|filename
argument_list|)
expr_stmt|;
name|dotpfile
operator|=
name|filetab
index|[
literal|0
index|]
operator|.
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allocate and read in line number information table  */
end_comment

begin_function
name|LOCAL
name|readlines
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|LINENO
name|oline
decl_stmt|;
specifier|register
name|ADDRESS
name|oaddr
decl_stmt|;
specifier|register
name|LINETAB
modifier|*
name|lp
decl_stmt|;
name|FILETAB
modifier|*
name|ftp
decl_stmt|;
name|short
name|lineincr
decl_stmt|;
if|if
condition|(
name|nlhdr
operator|.
name|nlines
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|linetab
operator|=
name|alloc
argument_list|(
name|nlhdr
operator|.
name|nlines
argument_list|,
name|LINETAB
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
operator|&
name|linetab
index|[
literal|0
index|]
init|;
name|lp
operator|<
operator|&
name|linetab
index|[
name|nlhdr
operator|.
name|nlines
index|]
condition|;
name|lp
operator|++
control|)
block|{
name|lp
operator|->
name|line
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|ftp
operator|=
operator|&
name|filetab
index|[
literal|0
index|]
init|;
name|ftp
operator|<
operator|&
name|filetab
index|[
name|nlhdr
operator|.
name|nfiles
index|]
condition|;
name|ftp
operator|++
control|)
block|{
name|linetab
index|[
name|ftp
operator|->
name|lineindex
index|]
operator|.
name|line
operator|=
name|ftp
operator|->
name|line
expr_stmt|;
block|}
name|oline
operator|=
literal|0
expr_stmt|;
name|oaddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
operator|&
name|linetab
index|[
literal|0
index|]
init|;
name|lp
operator|<
operator|&
name|linetab
index|[
name|nlhdr
operator|.
name|nlines
index|]
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|line
operator|!=
literal|0
condition|)
block|{
name|oline
operator|=
name|lp
operator|->
name|line
expr_stmt|;
block|}
name|lineincr
operator|=
operator|(
name|unsigned
operator|)
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineincr
operator|>
literal|127
condition|)
block|{
name|lineincr
operator|-=
literal|256
expr_stmt|;
block|}
name|oline
operator|+=
name|lineincr
expr_stmt|;
name|oaddr
operator|+=
operator|(
name|unsigned
operator|)
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|lp
operator|->
name|line
operator|=
name|oline
expr_stmt|;
name|lp
operator|->
name|addr
operator|=
name|oaddr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * read in the symbols  */
end_comment

begin_macro
name|readsyms
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|symno
decl_stmt|;
name|symtab
operator|=
name|st_creat
argument_list|(
name|nlhdr
operator|.
name|nsyms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlhdr
operator|.
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|symno
operator|=
name|getw
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symno
operator|>=
name|MAXSYMNO
condition|)
block|{
name|panic
argument_list|(
literal|"symbol number too large"
argument_list|)
expr_stmt|;
block|}
name|sym
index|[
name|symno
index|]
operator|=
name|readsym
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backpatch
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"patchlist not empty after reading namelist"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|program
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"no program"
argument_list|)
expr_stmt|;
block|}
name|maketypes
argument_list|()
expr_stmt|;
block|}
end_block

begin_typedef
typedef|typedef
struct|struct
name|patchinfo
block|{
name|SYM
modifier|*
modifier|*
name|patchsym
decl_stmt|;
name|struct
name|patchinfo
modifier|*
name|next_patch
decl_stmt|;
block|}
name|PATCH
typedef|;
end_typedef

begin_decl_stmt
name|LOCAL
name|PATCH
modifier|*
name|phead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Go through patchlist looking for symbol numbers for which the  * sym array now has a non-NIL entry.  *  * Afterwards, zap the sym array.  */
end_comment

begin_function
name|int
name|backpatch
parameter_list|()
block|{
specifier|register
name|PATCH
modifier|*
name|p
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|t
decl_stmt|;
name|int
name|count
decl_stmt|;
name|last
operator|=
name|NIL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|phead
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_patch
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|patchsym
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|sym
index|[
operator|(
name|int
operator|)
operator|*
name|t
index|]
operator|)
operator|!=
name|NIL
condition|)
block|{
operator|*
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NIL
condition|)
block|{
name|phead
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|last
operator|->
name|next_patch
operator|=
name|next
expr_stmt|;
block|}
name|dispose
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|p
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
operator|&
name|sym
index|[
literal|0
index|]
init|;
name|t
operator|<
operator|&
name|sym
index|[
name|MAXSYMNO
index|]
condition|;
name|t
operator|++
control|)
block|{
operator|*
name|t
operator|=
name|NIL
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the given pointer (really symbol number) should  * be added to the patch list.  The argument is double indirect  * to do call by reference passing.  */
end_comment

begin_macro
name|chkpatch
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|SYM
modifier|*
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|PATCH
modifier|*
name|patch
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|*
name|p
operator|)
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|sym
index|[
operator|(
name|int
operator|)
name|s
index|]
operator|)
operator|!=
name|NIL
condition|)
block|{
operator|*
name|p
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|patch
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|PATCH
argument_list|)
expr_stmt|;
name|patch
operator|->
name|patchsym
operator|=
name|p
expr_stmt|;
name|patch
operator|->
name|next_patch
operator|=
name|phead
expr_stmt|;
name|phead
operator|=
name|patch
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Free all the object information.  */
end_comment

begin_macro
name|objfree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|st_destroy
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|dispose
argument_list|(
name|stringtab
argument_list|)
expr_stmt|;
name|dispose
argument_list|(
name|filetab
argument_list|)
expr_stmt|;
name|dispose
argument_list|(
name|linetab
argument_list|)
expr_stmt|;
name|clrfunctab
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSYMNO
condition|;
name|i
operator|++
control|)
block|{
name|sym
index|[
name|i
index|]
operator|=
name|NIL
expr_stmt|;
block|}
block|}
end_block

end_unit

