begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)predicates.c 1.2 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The basic tests on a symbol.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"btypes.h"
end_include

begin_include
include|#
directive|include
file|"classes.h"
end_include

begin_include
include|#
directive|include
file|"sym.rep"
end_include

begin_comment
comment|/*  * Test if a symbol is a parameter.  This is true if there  * is a cycle from s->func to s via chain pointers.  */
end_comment

begin_function
name|BOOLEAN
name|isparam
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|SYM
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|->
name|func
init|;
name|t
operator|!=
name|NIL
condition|;
name|t
operator|=
name|t
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|t
operator|==
name|s
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a var parameter, i.e. has class REF.  */
end_comment

begin_function
name|BOOLEAN
name|isvarparam
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|BOOLEAN
operator|)
name|s
operator|->
name|class
operator|==
name|REF
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a block, e.g. function, procedure, or the  * main program.  */
end_comment

begin_function
name|BOOLEAN
name|isblock
parameter_list|(
name|s
parameter_list|)
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|s
operator|->
name|class
operator|==
name|FUNC
operator|||
name|s
operator|->
name|class
operator|==
name|PROC
operator|||
name|s
operator|->
name|class
operator|==
name|PROG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is builtin, that is, a predefined type or  * reserved word.  */
end_comment

begin_function
name|BOOLEAN
name|isbuiltin
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|s
operator|->
name|blkno
operator|==
literal|0
operator|&&
name|s
operator|->
name|class
operator|!=
name|PROG
operator|&&
name|s
operator|->
name|class
operator|!=
name|VAR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compatible tests if two types are compatible.  The issue  * is complicated a bit by ranges.  *  * Integers and reals are not compatible since they cannot always be mixed.  */
end_comment

begin_function
name|BOOLEAN
name|compatible
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|SYM
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|t1
operator|=
name|rtype
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|rtype
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|type
operator|==
name|t2
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|t1
operator|->
name|class
operator|==
name|RANGE
operator|&&
name|t2
operator|->
name|class
operator|==
name|RANGE
condition|)
block|{
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|t1
operator|->
name|class
operator|==
name|SCAL
operator|||
name|t1
operator|->
name|class
operator|==
name|CONST
operator|)
operator|&&
operator|(
name|t2
operator|->
name|class
operator|==
name|SCAL
operator|||
name|t2
operator|->
name|class
operator|==
name|CONST
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|t1
operator|->
name|type
operator|==
name|t_char
operator|&&
name|t1
operator|->
name|class
operator|==
name|ARRAY
operator|&&
name|t2
operator|->
name|class
operator|==
name|ARRAY
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
comment|/*  * A kludge here for "nil".  Should be handled better.  * Opens a pandora's box for integer/pointer compatibility.  */
if|if
condition|(
name|t1
operator|->
name|class
operator|==
name|RANGE
operator|&&
name|t2
operator|->
name|class
operator|==
name|PTR
condition|)
block|{
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|t2
operator|->
name|class
operator|==
name|RANGE
operator|&&
name|t1
operator|->
name|class
operator|==
name|PTR
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Predicate to test if a symbol should be printed.  We don't print  * files, for example, simply because there's no good way to do it.  * The symbol must be within the given function.  */
end_comment

begin_function
name|BOOLEAN
name|should_print
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
name|SYM
modifier|*
name|f
decl_stmt|;
block|{
name|SYM
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|func
operator|!=
name|f
operator|||
operator|(
name|s
operator|->
name|class
operator|!=
name|VAR
operator|&&
name|s
operator|->
name|class
operator|!=
name|FVAR
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|chain
operator|!=
name|NIL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
name|t
operator|=
name|rtype
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NIL
operator|||
name|t
operator|->
name|class
operator|==
name|FILET
operator|||
name|t
operator|->
name|class
operator|==
name|SET
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Test if the name of a symbol is uniquely defined or not.  */
end_comment

begin_function
name|BOOLEAN
name|isambiguous
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
name|SYM
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|st_lookup
argument_list|(
name|symtab
argument_list|,
name|s
operator|->
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"symbol name vanished"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|t
operator|!=
name|NIL
operator|&&
operator|(
name|s
operator|==
name|t
operator|||
operator|!
name|streq
argument_list|(
name|t
operator|->
name|symbol
argument_list|,
name|s
operator|->
name|symbol
argument_list|)
operator|)
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|next_sym
expr_stmt|;
block|}
return|return
name|t
operator|!=
name|NIL
return|;
block|}
end_function

end_unit

