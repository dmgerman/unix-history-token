begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)attributes.c 1.1 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Functions to return the attributes of a symbol.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"btypes.h"
end_include

begin_include
include|#
directive|include
file|"classes.h"
end_include

begin_include
include|#
directive|include
file|"sym.rep"
end_include

begin_function
name|char
modifier|*
name|name
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|symbol
return|;
block|}
end_function

begin_function
name|int
name|toknum
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|symvalue
operator|.
name|token
operator|.
name|toknum
return|;
block|}
end_function

begin_function
name|int
name|tokval
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|symvalue
operator|.
name|token
operator|.
name|tokval
return|;
block|}
end_function

begin_function
name|ADDRESS
name|codeloc
parameter_list|(
name|f
parameter_list|)
name|SYM
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"codeloc: nil symbol"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isblock
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"codeloc: %s is not a block"
argument_list|,
name|f
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
return|return
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|codeloc
return|;
block|}
end_function

begin_comment
comment|/*  * Rtype returns the "reduced type" given a variable.  * The idea is to remove type names so we can check the class.  */
end_comment

begin_function
name|SYM
modifier|*
name|rtype
parameter_list|(
name|t
parameter_list|)
specifier|register
name|SYM
modifier|*
name|t
decl_stmt|;
block|{
while|while
condition|(
name|t
operator|->
name|class
operator|==
name|TYPE
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*  * Return the SYM that contains the given SYM.  */
end_comment

begin_function
name|SYM
modifier|*
name|container
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|func
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the string for the name of the class that  * the given symbol belongs to.  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|clname
index|[]
init|=
block|{
literal|"bad use"
block|,
literal|"constant"
block|,
literal|"type"
block|,
literal|"variable"
block|,
literal|"array"
block|,
literal|"fileptr"
block|,
literal|"record"
block|,
literal|"field"
block|,
literal|"procedure"
block|,
literal|"function"
block|,
literal|"funcvar"
block|,
literal|"ref"
block|,
literal|"pointer"
block|,
literal|"file"
block|,
literal|"set"
block|,
literal|"range"
block|,
literal|"label"
block|,
literal|"withptr"
block|,
literal|"scalar"
block|,
literal|"string"
block|,
literal|"program"
block|,
literal|"improper"
block|,
literal|"variant"
block|,
literal|"procparam"
block|,
literal|"funcparam"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|classname
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|clname
index|[
name|s
operator|->
name|class
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * size finds the size in bytes of the given type  */
end_comment

begin_define
define|#
directive|define
name|MINCHAR
value|-128
end_define

begin_define
define|#
directive|define
name|MAXCHAR
value|127
end_define

begin_define
define|#
directive|define
name|MINSHORT
value|-32768
end_define

begin_define
define|#
directive|define
name|MAXSHORT
value|32767
end_define

begin_function
name|int
name|size
parameter_list|(
name|t
parameter_list|)
specifier|register
name|SYM
modifier|*
name|t
decl_stmt|;
block|{
name|long
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|t_real
condition|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|double
argument_list|)
return|;
block|}
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
name|lower
operator|=
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|upper
operator|=
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
if|if
condition|(
name|lower
operator|>=
name|MINCHAR
operator|&&
name|upper
operator|<=
name|MAXCHAR
condition|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|char
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|lower
operator|>=
name|MINSHORT
operator|&&
name|upper
operator|<=
name|MAXSHORT
condition|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|short
argument_list|)
return|;
block|}
else|else
block|{
return|return
sizeof|sizeof
argument_list|(
name|long
argument_list|)
return|;
block|}
comment|/* NOTREACHED */
case|case
name|ARRAY
case|:
block|{
specifier|register
name|int
name|nel
decl_stmt|,
name|elsize
decl_stmt|;
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|;
name|elsize
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|nel
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|t
operator|->
name|chain
init|;
name|t
operator|!=
name|NIL
condition|;
name|t
operator|=
name|t
operator|->
name|chain
control|)
block|{
name|s
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|lower
operator|=
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|upper
operator|=
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
name|nel
operator|*=
operator|(
name|upper
operator|-
name|lower
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|nel
operator|*
name|elsize
return|;
block|}
case|case
name|CONST
case|:
case|case
name|VAR
case|:
case|case
name|FVAR
case|:
case|case
name|FIELD
case|:
return|return
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
return|;
case|case
name|RECORD
case|:
return|return
name|t
operator|->
name|symvalue
operator|.
name|offset
return|;
case|case
name|PTR
case|:
case|case
name|REF
case|:
case|case
name|FILET
case|:
return|return
sizeof|sizeof
argument_list|(
name|int
argument_list|)
return|;
case|case
name|SCAL
case|:
if|if
condition|(
name|t
operator|->
name|symvalue
operator|.
name|iconval
operator|>
literal|255
condition|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|short
argument_list|)
return|;
block|}
else|else
block|{
return|return
sizeof|sizeof
argument_list|(
name|char
argument_list|)
return|;
block|}
comment|/* NOTREACHED */
case|case
name|FPROC
case|:
case|case
name|FFUNC
case|:
return|return
sizeof|sizeof
argument_list|(
name|ADDRESS
operator|*
argument_list|)
return|;
default|default:
if|if
condition|(
name|t
operator|->
name|class
operator|<
name|BADUSE
operator|||
name|t
operator|->
name|class
operator|>
name|FFUNC
condition|)
block|{
name|panic
argument_list|(
literal|"size: bad class (%d)"
argument_list|,
name|t
operator|->
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"improper operation on a %s"
argument_list|,
name|classname
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
block|}
end_function

end_unit

