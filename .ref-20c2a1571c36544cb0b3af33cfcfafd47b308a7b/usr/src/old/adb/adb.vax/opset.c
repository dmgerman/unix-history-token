begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)opset.c 4.1 %G%"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|dotinc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|var
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* instruction printing */
end_comment

begin_comment
comment|/*  * Argument access types  */
end_comment

begin_define
define|#
directive|define
name|ACCA
value|(8<<3)
end_define

begin_comment
comment|/* address only */
end_comment

begin_define
define|#
directive|define
name|ACCR
value|(1<<3)
end_define

begin_comment
comment|/* read */
end_comment

begin_define
define|#
directive|define
name|ACCW
value|(2<<3)
end_define

begin_comment
comment|/* write */
end_comment

begin_define
define|#
directive|define
name|ACCM
value|(3<<3)
end_define

begin_comment
comment|/* modify */
end_comment

begin_define
define|#
directive|define
name|ACCB
value|(4<<3)
end_define

begin_comment
comment|/* branch displacement */
end_comment

begin_define
define|#
directive|define
name|ACCI
value|(5<<3)
end_define

begin_comment
comment|/* XFC code */
end_comment

begin_comment
comment|/*  * Argument data types  */
end_comment

begin_define
define|#
directive|define
name|TYPB
value|0
end_define

begin_comment
comment|/* byte */
end_comment

begin_define
define|#
directive|define
name|TYPW
value|1
end_define

begin_comment
comment|/* word */
end_comment

begin_define
define|#
directive|define
name|TYPL
value|2
end_define

begin_comment
comment|/* long */
end_comment

begin_define
define|#
directive|define
name|TYPQ
value|3
end_define

begin_comment
comment|/* quad */
end_comment

begin_define
define|#
directive|define
name|TYPF
value|4
end_define

begin_comment
comment|/* floating */
end_comment

begin_define
define|#
directive|define
name|TYPD
value|5
end_define

begin_comment
comment|/* double floating */
end_comment

begin_decl_stmt
name|TYPE
name|struct
name|optab
modifier|*
name|OPTAB
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|optab
block|{
name|char
modifier|*
name|iname
decl_stmt|;
name|char
name|val
decl_stmt|;
name|char
name|nargs
decl_stmt|;
name|char
name|argtype
index|[
literal|6
index|]
decl_stmt|;
block|}
name|optab
index|[]
struct|;
end_struct

begin_define
define|#
directive|define
name|SYSTAB
value|struct systab
end_define

begin_macro
name|SYSTAB
end_macro

begin_block
block|{
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
block|}
end_block

begin_expr_stmt
name|systab
index|[]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STRING
name|regname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|fltimm
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|POS
name|type
decl_stmt|,
name|space
decl_stmt|,
name|incp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ioptab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index by opcode to optab */
end_comment

begin_macro
name|mkioptab
argument_list|()
end_macro

begin_block
block|{
comment|/* set up ioptab */
name|REG
name|OPTAB
name|p
init|=
name|optab
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|iname
condition|)
block|{
name|ioptab
index|[
name|p
operator|->
name|val
operator|&
name|LOBYTE
index|]
operator|=
name|p
operator|-
name|optab
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fmtr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fmtR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used */
end_comment

begin_macro
name|printins
argument_list|(
argument|f
argument_list|,
argument|idsp
argument_list|,
argument|ins
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|vax
end_ifndef

begin_decl_stmt
name|REG
name|INT
name|ins
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|REG
name|L_INT
name|ins
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|short
name|argno
decl_stmt|;
comment|/* argument index */
name|short
name|mode
decl_stmt|;
comment|/* mode */
name|char
modifier|*
modifier|*
name|r
decl_stmt|;
comment|/* register name */
name|long
name|d
decl_stmt|;
comment|/* assembled byte, word, long or float */
name|long
name|snarf
parameter_list|()
function_decl|;
name|REG
name|char
modifier|*
name|ap
decl_stmt|;
name|REG
name|OPTAB
name|ip
decl_stmt|;
name|type
operator|=
name|DSYM
expr_stmt|;
name|space
operator|=
name|idsp
expr_stmt|;
name|ins
operator|&=
name|LOBYTE
expr_stmt|;
name|ip
operator|=
name|optab
operator|+
name|ioptab
index|[
name|ins
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s%8t"
argument_list|,
name|ip
operator|->
name|iname
argument_list|)
expr_stmt|;
name|incp
operator|=
literal|1
expr_stmt|;
name|ap
operator|=
name|ip
operator|->
name|argtype
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|ip
operator|->
name|nargs
condition|;
name|argno
operator|++
operator|,
name|ap
operator|++
control|)
block|{
name|var
index|[
name|argno
index|]
operator|=
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|argno
operator|!=
literal|0
condition|)
name|printc
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|top
label|:
if|if
condition|(
operator|*
name|ap
operator|&
name|ACCB
condition|)
name|mode
operator|=
literal|0xAF
operator|+
operator|(
operator|(
operator|*
name|ap
operator|&
literal|7
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* branch displacement */
else|else
block|{
name|mode
operator|=
name|bchkget
argument_list|(
name|inkdot
argument_list|(
name|incp
argument_list|)
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
operator|++
name|incp
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
literal|0300
condition|)
block|{
comment|/* not short literal */
name|r
operator|=
operator|&
name|regname
index|[
name|mode
operator|&
literal|0xF
index|]
expr_stmt|;
name|mode
operator|>>=
literal|4
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|mode
condition|)
block|{
case|case
literal|4
case|:
comment|/* [r] */
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|5
case|:
comment|/* r */
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* (r) */
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* -(r) */
name|printf
argument_list|(
literal|"-(%s)"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* *(r)+ */
name|printc
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
case|case
literal|8
case|:
comment|/* (r)+ */
if|if
condition|(
name|r
operator|==
operator|(
name|regname
operator|+
literal|0xF
operator|)
condition|)
block|{
name|printc
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|9
condition|)
block|{
comment|/* PC absolute, always 4 bytes*/
name|d
operator|=
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
block|}
switch|switch
condition|(
operator|*
name|ap
operator|&
literal|7
condition|)
block|{
case|case
name|TYPB
case|:
name|d
operator|=
name|snarf
argument_list|(
literal|1
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
case|case
name|TYPW
case|:
name|d
operator|=
name|snarf
argument_list|(
literal|2
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
case|case
name|TYPL
case|:
name|d
operator|=
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
case|case
name|TYPQ
case|:
name|d
operator|=
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
name|printquad
argument_list|(
name|d
argument_list|,
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPF
case|:
name|printfloating
argument_list|(
name|TYPF
argument_list|,
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPD
case|:
name|d
operator|=
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
name|printfloating
argument_list|(
name|TYPQ
argument_list|,
name|d
argument_list|,
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of type switch */
comment|/* 					 *	here only for TYPQ, TYPf, TYPD 					 *	others went to disp 					 */
block|}
else|else
block|{
comment|/*it's not PC immediate or abs*/
name|printf
argument_list|(
literal|"(%s)+"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0xB
case|:
comment|/* byte displacement defferred*/
name|printc
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
case|case
literal|0xA
case|:
comment|/* byte displacement */
name|d
operator|=
name|snarf
argument_list|(
literal|1
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
case|case
literal|0xD
case|:
comment|/* word displacement deferred */
name|printc
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
case|case
literal|0xC
case|:
comment|/* word displacement */
name|d
operator|=
name|snarf
argument_list|(
literal|2
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
case|case
literal|0xF
case|:
comment|/* long displacement deferred */
name|printc
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
case|case
literal|0xE
case|:
comment|/* long displacement */
name|d
operator|=
name|snarf
argument_list|(
literal|4
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
goto|goto
name|disp
goto|;
name|disp
label|:
name|var
index|[
name|argno
index|]
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|(
name|regname
operator|+
literal|0xF
operator|)
operator|&&
name|mode
operator|>=
literal|0xA
condition|)
block|{
comment|/* PC offset addressing */
name|var
index|[
name|argno
index|]
operator|+=
name|dot
operator|+
name|incp
expr_stmt|;
block|}
name|psymoff
argument_list|(
name|var
index|[
name|argno
index|]
argument_list|,
name|type
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|regname
operator|+
literal|0xF
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of the mode switch */
block|}
else|else
block|{
comment|/* short literal */
name|var
index|[
name|argno
index|]
operator|=
name|mode
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ap
operator|&
literal|7
operator|)
operator|==
name|TYPF
operator|||
operator|(
operator|*
name|ap
operator|&
literal|7
operator|)
operator|==
name|TYPD
condition|)
name|printf
argument_list|(
literal|"$%s"
argument_list|,
name|fltimm
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"$%r"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ins
operator|==
literal|0xCF
operator|||
name|ins
operator|==
literal|0xAF
operator|||
name|ins
operator|==
literal|0x8F
condition|)
block|{
comment|/* CASEx instr */
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<=
name|var
index|[
literal|2
index|]
condition|;
operator|++
name|argno
control|)
block|{
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %R:  "
argument_list|,
name|argno
operator|+
name|var
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|get
argument_list|(
name|inkdot
argument_list|(
name|incp
operator|+
name|argno
operator|+
name|argno
argument_list|)
argument_list|,
name|idsp
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|d
operator|&
literal|0x8000
condition|)
name|d
operator|-=
literal|0x10000
expr_stmt|;
name|psymoff
argument_list|(
name|inkdot
argument_list|(
name|incp
argument_list|)
operator|+
name|d
argument_list|,
name|type
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|incp
operator|+=
name|var
index|[
literal|2
index|]
operator|+
name|var
index|[
literal|2
index|]
operator|+
literal|2
expr_stmt|;
block|}
name|dotinc
operator|=
name|incp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	magic values to mung an offset to a register into  *	something that psymoff can understand.. all magic  */
end_comment

begin_comment
comment|/* 0	1	2	3	4 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|magic_masks
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|0x80
block|,
literal|0x8000
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|magic_compl
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|0x100
block|,
literal|0x10000
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	The following code is NO LONGER portable from the PDP 11 to the VAX  */
end_comment

begin_function
name|long
name|snarf
parameter_list|(
name|nbytes
parameter_list|,
name|idsp
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|int
name|byteindex
decl_stmt|;
union|union
name|Long
block|{
name|char
name|long_bytes
index|[
literal|4
index|]
decl_stmt|;
name|long
name|long_value
decl_stmt|;
block|}
name|d
union|;
name|d
operator|.
name|long_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|byteindex
operator|=
literal|0
init|;
name|byteindex
operator|<
name|nbytes
condition|;
name|byteindex
operator|++
control|)
block|{
name|d
operator|.
name|long_bytes
index|[
name|byteindex
index|]
operator|=
name|bchkget
argument_list|(
name|inkdot
argument_list|(
name|incp
argument_list|)
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
operator|++
name|incp
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|.
name|long_value
operator|&
name|magic_masks
index|[
name|nbytes
index|]
condition|)
name|d
operator|.
name|long_value
operator|-=
name|magic_compl
index|[
name|nbytes
index|]
expr_stmt|;
return|return
operator|(
name|d
operator|.
name|long_value
operator|)
return|;
block|}
end_function

begin_macro
name|printfloating
argument_list|(
argument|type
argument_list|,
argument|word_first
argument_list|,
argument|word_last
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|word_first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|word_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
name|Double
block|{
struct|struct
block|{
name|long
name|word_first
decl_stmt|;
name|long
name|word_last
decl_stmt|;
block|}
name|composite
struct|;
name|double
name|dvalue
decl_stmt|;
block|}
name|reconstructed
union|;
name|reconstructed
operator|.
name|composite
operator|.
name|word_first
operator|=
name|word_first
expr_stmt|;
name|reconstructed
operator|.
name|composite
operator|.
name|word_last
operator|=
name|word_last
expr_stmt|;
name|printf
argument_list|(
literal|"%f"
argument_list|,
name|reconstructed
operator|.
name|dvalue
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|printquad
argument_list|(
argument|word_first
argument_list|,
argument|word_last
argument_list|)
end_macro

begin_decl_stmt
name|long
name|word_first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|word_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
name|Quad
block|{
name|char
name|quad_bytes
index|[
literal|8
index|]
decl_stmt|;
name|long
name|quad_long
index|[
literal|2
index|]
decl_stmt|;
block|}
name|reconstructed
union|;
name|int
name|leading_zero
init|=
literal|1
decl_stmt|;
name|int
name|byteindex
decl_stmt|;
name|int
name|nibbleindex
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
name|reconstructed
operator|.
name|quad_long
index|[
literal|0
index|]
operator|=
name|word_first
expr_stmt|;
name|reconstructed
operator|.
name|quad_long
index|[
literal|1
index|]
operator|=
name|word_last
expr_stmt|;
for|for
control|(
name|byteindex
operator|=
literal|7
init|;
name|byteindex
operator|>=
literal|0
condition|;
operator|--
name|byteindex
control|)
block|{
for|for
control|(
name|nibbleindex
operator|=
literal|4
init|;
name|nibbleindex
operator|>=
literal|0
condition|;
name|nibbleindex
operator|-=
literal|4
control|)
block|{
name|ch
operator|=
operator|(
name|reconstructed
operator|.
name|quad_bytes
index|[
name|byteindex
index|]
operator|>>
name|nibbleindex
operator|)
operator|&
literal|0x0F
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|leading_zero
operator|&=
operator|(
name|ch
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|<=
literal|0x09
condition|)
name|printc
argument_list|(
name|ch
operator|+
literal|'0'
argument_list|)
expr_stmt|;
else|else
name|printc
argument_list|(
name|ch
operator|-
literal|0x0A
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

end_unit

