begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"../hdr/had.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|admin
operator|.
name|c
literal|4.1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Program to create new SCCS files and change parameters 	of existing ones. Arguments to the program may appear in 	any order and consist of keyletters, which begin with '-', 	and named files. Named files which do not exist are created 	and their parameters are initialized according to the given 	keyletter arguments, or are given default values if the 	corresponding keyletters were not supplied. Named files which 	do exist have those parameters corresponding to given key-letter 	arguments changed and other parameters are left as is.  	If a directory is given as an argument, each SCCS file within 	the directory is processed as if it had been specifically named. 	If a name of '-' is given, the standard input is read for a list 	of names of SCCS files to be processed. 	Non-SCCS files are ignored.  	Files created are given mode 444. */
end_comment

begin_define
define|#
directive|define
name|MINR
value|1
end_define

begin_comment
comment|/* minimum release number */
end_comment

begin_define
define|#
directive|define
name|MAXR
value|9999
end_define

begin_comment
comment|/* maximum release number */
end_comment

begin_define
define|#
directive|define
name|MAXNAMES
value|9
end_define

begin_define
define|#
directive|define
name|COPY
value|0
end_define

begin_define
define|#
directive|define
name|NOCOPY
value|1
end_define

begin_decl_stmt
name|char
modifier|*
name|ifile
decl_stmt|,
modifier|*
name|tfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|z
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for validation program name */
end_comment

begin_decl_stmt
name|char
name|had
index|[
literal|26
index|]
decl_stmt|,
name|had_flag
index|[
literal|26
index|]
decl_stmt|,
name|rm_flag
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Comments
decl_stmt|,
modifier|*
name|Mrs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|char
name|Valpgm
index|[]
literal|"/usr/local/val"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|irel
decl_stmt|,
name|fexists
decl_stmt|,
name|num_files
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|VFLAG
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Domrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Sflags
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|anames
index|[
name|MAXNAMES
index|]
decl_stmt|,
modifier|*
name|enames
index|[
name|MAXNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flag_p
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asub
decl_stmt|,
name|esub
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Did_id
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|,
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|testklt
decl_stmt|;
extern|extern admin(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|int
name|Fcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sid
name|sid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Set flags for 'fatal' to issue message, call clean-up 	routine and terminate processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|testklt
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	The following loop processes keyletters and arguments. 	Note that these are processed only once for each 	invocation of 'main'. 	*/
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|c
operator|=
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|p
operator|=
operator|&
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* name of file of body */
name|ifile
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* name of file of descriptive text */
name|tfile
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* mr flag */
name|Mrs
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* comments flag for entry */
name|Comments
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* flags to be deleted */
name|testklt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
literal|"d has no argument (ad1)"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|argv
index|[
name|j
index|]
index|[
literal|3
index|]
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|IDFLAG
case|:
comment|/* see 'f' keyletter */
case|case
name|BRCHFLAG
case|:
comment|/* for meanings of flags */
case|case
name|VALFLAG
case|:
case|case
name|TYPEFLAG
case|:
case|case
name|MODFLAG
case|:
case|case
name|NULLFLAG
case|:
case|case
name|FLORFLAG
case|:
case|case
name|CEILFLAG
case|:
case|case
name|DEFTFLAG
case|:
if|if
condition|(
operator|*
name|p
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"value after %c flag (ad12)"
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown flag (ad3)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rm_flag
index|[
name|f
operator|-
literal|'a'
index|]
operator|++
condition|)
name|fatal
argument_list|(
literal|"flag twice (ad4)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* flags to be added */
name|testklt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
literal|"f has no argument (ad5)"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|argv
index|[
name|j
index|]
index|[
literal|3
index|]
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|IDFLAG
case|:
comment|/* id-kwd message (err/warn) */
case|case
name|BRCHFLAG
case|:
comment|/* branch */
case|case
name|NULLFLAG
case|:
comment|/* null deltas */
if|if
condition|(
operator|*
name|p
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"value after %c flag (ad13)"
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALFLAG
case|:
comment|/* mr validation */
name|VFLAG
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|z
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|FLORFLAG
case|:
comment|/* floor */
if|if
condition|(
operator|(
name|i
operator|=
name|patoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"floor not numeric (ad22)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
argument_list|(
name|p
argument_list|)
operator|>
literal|5
operator|)
operator|||
operator|(
name|i
operator|<
name|MINR
operator|)
operator|||
operator|(
name|i
operator|>
name|MAXR
operator|)
condition|)
name|fatal
argument_list|(
literal|"floor out of range (ad23)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEILFLAG
case|:
comment|/* ceiling */
if|if
condition|(
operator|(
name|i
operator|=
name|patoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"ceiling not numeric (ad24)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
argument_list|(
name|p
argument_list|)
operator|>
literal|5
operator|)
operator|||
operator|(
name|i
operator|<
name|MINR
operator|)
operator|||
operator|(
name|i
operator|>
name|MAXR
operator|)
condition|)
name|fatal
argument_list|(
literal|"ceiling out of range (ad25)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFTFLAG
case|:
comment|/* default sid */
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
literal|"no default sid (ad14)"
argument_list|)
expr_stmt|;
name|chksid
argument_list|(
name|sid_ab
argument_list|(
name|p
argument_list|,
operator|&
name|sid
argument_list|)
argument_list|,
operator|&
name|sid
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPEFLAG
case|:
comment|/* type */
case|case
name|MODFLAG
case|:
comment|/* module name */
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"flag %c has no value (ad2)"
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown flag (ad3)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had_flag
index|[
name|f
operator|-
literal|'a'
index|]
operator|++
condition|)
name|fatal
argument_list|(
literal|"flag twice (ad4)"
argument_list|)
expr_stmt|;
name|flag_p
index|[
name|f
operator|-
literal|'a'
index|]
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* initial release number supplied */
if|if
condition|(
operator|(
name|irel
operator|=
name|patoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"r arg not numeric (ad6)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
argument_list|(
name|p
argument_list|)
operator|>
literal|5
operator|)
operator|||
operator|(
name|irel
operator|<
name|MINR
operator|)
operator|||
operator|(
name|irel
operator|>
name|MAXR
operator|)
condition|)
name|fatal
argument_list|(
literal|"r out of range (ad7)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* creating new SCCS file */
case|case
literal|'h'
case|:
comment|/* only check hash of file */
case|case
literal|'z'
case|:
comment|/* zero the input hash */
break|break;
case|case
literal|'a'
case|:
comment|/* user-name allowed to make deltas */
name|testklt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
literal|"bad a argument (ad8)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asub
operator|>
name|MAXNAMES
condition|)
name|fatal
argument_list|(
literal|"too many 'a' keyletters (ad9)"
argument_list|)
expr_stmt|;
name|anames
index|[
name|asub
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* user-name to be removed */
name|testklt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
literal|"bad e argument (ad10)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|esub
operator|>
name|MAXNAMES
condition|)
name|fatal
argument_list|(
literal|"too many 'e' keyletters (ad11)"
argument_list|)
expr_stmt|;
name|enames
index|[
name|esub
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown key letter (cm1)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had
index|[
name|c
operator|-
literal|'a'
index|]
operator|++
operator|&&
name|testklt
operator|++
condition|)
name|fatal
argument_list|(
literal|"key letter twice (cm2)"
argument_list|)
expr_stmt|;
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|num_files
operator|++
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|num_files
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"missing file arg (cm3)"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|HADI
operator|&&
name|num_files
operator|>
literal|1
condition|)
comment|/* only one file allowed with `i' */
name|fatal
argument_list|(
literal|"more than one file (ad15)"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|setsig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Change flags for 'fatal' so that it will return to this 	routine (main) instead of terminating processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
operator|&
operator|~
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fflags
operator|=
operator||
name|FTLJMP
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Call 'admin' routine for each file argument. 	*/
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|argv
index|[
name|j
index|]
condition|)
name|do_file
argument_list|(
name|p
argument_list|,
name|admin
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* 	Routine that actually does admin's work on SCCS files. 	Existing s-files are copied, with changes being made, to a 	temporary file (x-file). The name of the x-file is the same as the 	name of the s-file, with the 's.' replaced by 'x.'. 	s-files which are to be created are processed in a similar 	manner, except that a dummy s-file is first created with 	mode 444. 	At end of processing, the x-file is renamed with the name of s-file 	and the old s-file is removed. */
end_comment

begin_decl_stmt
unit|struct
name|packet
name|gpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see file defines.h */
end_comment

begin_decl_stmt
name|char
name|Zhold
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary z-file name */
end_comment

begin_expr_stmt
name|USXALLOC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* defines alloc() and free() */
end_comment

begin_macro
name|admin
argument_list|(
argument|afile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|afile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|deltab
name|dt
decl_stmt|;
comment|/* see file defines.h */
name|struct
name|stats
name|stats
decl_stmt|;
comment|/* see file defines.h */
name|FILE
modifier|*
name|iptr
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|command
index|[
literal|80
index|]
decl_stmt|;
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* used in forking procedure */
name|int
name|status
decl_stmt|;
extern|extern nfiles;
extern|extern had_dir;
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
comment|/* set up to return here from 'fatal' */
return|return;
comment|/* and return to caller of admin */
if|if
condition|(
name|HADI
operator|&&
name|had_dir
condition|)
comment|/* directory not allowed with `i' keyletter */
name|fatal
argument_list|(
literal|"directory named with `i' keyletter (ad26)"
argument_list|)
expr_stmt|;
name|fexists
operator|=
name|exists
argument_list|(
name|afile
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADI
condition|)
name|HADN
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HADI
operator|||
name|HADN
condition|)
block|{
if|if
condition|(
name|HADM
operator|&&
operator|!
name|VFLAG
condition|)
name|fatal
argument_list|(
literal|"MRs not allowed (de8)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VFLAG
operator|&&
operator|!
name|HADM
condition|)
name|fatal
argument_list|(
literal|"MRs required (de10)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HADI
operator|&&
name|HADR
condition|)
name|fatal
argument_list|(
literal|"r only allowed with i (ad16)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADN
operator|&&
name|HADT
operator|&&
operator|!
operator|(
operator|*
name|tfile
operator|)
condition|)
name|fatal
argument_list|(
literal|"t has no argument (ad17)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADN
operator|&&
name|HADD
condition|)
name|fatal
argument_list|(
literal|"d not allowed with n (ad18)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADN
operator|&&
name|fexists
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"file %s exists (ad19)"
argument_list|,
name|afile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HADN
operator|&&
operator|!
name|fexists
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"file %s does not exist (ad20)"
argument_list|,
name|afile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   Check for '-h' flag.  If set, create child process and 	   invoke 'get' to examine format of SCCS file. 	*/
if|if
condition|(
name|HADH
condition|)
block|{
comment|/* 		   fork here so 'admin' can execute 'val' to 		   check for a corrupted file. 		*/
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot fork, try again"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* child */
comment|/* 			   perform 'val' with appropriate keyletters 			*/
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"/bin/sh"
argument_list|,
literal|"-c"
argument_list|,
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"/usr/local/val -s %s"
argument_list|,
name|afile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"cannot execute '%s'"
argument_list|,
name|Valpgm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* wait on status from 'execl' */
if|if
condition|(
name|status
condition|)
name|fatal
argument_list|(
literal|"corrupted file (co6)"
argument_list|)
expr_stmt|;
return|return;
comment|/* return to caller of 'admin' */
block|}
block|}
comment|/* 	Lock out any other user who may be trying to process 	the same file. 	*/
if|if
condition|(
operator|!
name|HADH
operator|&&
name|lockit
argument_list|(
name|copy
argument_list|(
name|auxf
argument_list|(
name|afile
argument_list|,
literal|'z'
argument_list|)
argument_list|,
name|Zhold
argument_list|)
argument_list|,
literal|2
argument_list|,
name|getpid
argument_list|()
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"cannot create lock file (cm4)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fexists
condition|)
name|sinit
argument_list|(
operator|&
name|gpkt
argument_list|,
name|afile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* init pkt& open s-file */
else|else
block|{
name|xfcreat
argument_list|(
name|afile
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
comment|/* create dummy s-file */
name|sinit
argument_list|(
operator|&
name|gpkt
argument_list|,
name|afile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* and init pkt */
block|}
if|if
condition|(
operator|!
name|HADH
condition|)
comment|/* 		   set the flag for 'putline' routine to open 		   the 'x-file' and allow writing on it. 		*/
name|gpkt
operator|.
name|p_upd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HADZ
condition|)
block|{
name|gpkt
operator|.
name|do_chksum
operator|=
literal|0
expr_stmt|;
comment|/* ignore checksum processing */
name|gpkt
operator|.
name|p_ihash
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	Get statistics of latest delta in old file. 	*/
if|if
condition|(
operator|!
name|HADN
condition|)
block|{
name|stats_ab
argument_list|(
operator|&
name|gpkt
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|gpkt
operator|.
name|p_wrttn
operator|++
expr_stmt|;
name|newstats
argument_list|(
operator|&
name|gpkt
argument_list|,
name|line
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HADN
condition|)
block|{
comment|/*   N E W   F I L E   */
comment|/* 		Beginning of SCCS file. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c%s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|HEAD
argument_list|,
literal|"00000"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		Statistics. 		*/
name|newstats
argument_list|(
operator|&
name|gpkt
argument_list|,
name|line
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d_type
operator|=
literal|'D'
expr_stmt|;
comment|/* type of delta */
comment|/* 		Set initial release, level, branch and 		sequence values. 		*/
if|if
condition|(
name|HADR
condition|)
name|dt
operator|.
name|d_sid
operator|.
name|s_rel
operator|=
name|irel
expr_stmt|;
else|else
name|dt
operator|.
name|d_sid
operator|.
name|s_rel
operator|=
literal|1
expr_stmt|;
name|dt
operator|.
name|d_sid
operator|.
name|s_lev
operator|=
literal|1
expr_stmt|;
name|dt
operator|.
name|d_sid
operator|.
name|s_br
operator|=
name|dt
operator|.
name|d_sid
operator|.
name|s_seq
operator|=
literal|0
expr_stmt|;
name|time
argument_list|(
operator|&
name|dt
operator|.
name|d_datetime
argument_list|)
expr_stmt|;
comment|/* get time and date */
name|copy
argument_list|(
name|logname
argument_list|()
argument_list|,
name|dt
operator|.
name|d_pgmr
argument_list|)
expr_stmt|;
comment|/* get user's name */
name|dt
operator|.
name|d_serial
operator|=
literal|1
expr_stmt|;
name|dt
operator|.
name|d_pred
operator|=
literal|0
expr_stmt|;
name|del_ba
argument_list|(
operator|&
name|dt
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* form and write */
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* delta-table entry */
comment|/* 		If -m flag, enter MR numbers 		*/
if|if
condition|(
name|Mrs
condition|)
block|{
name|mrfixup
argument_list|()
expr_stmt|;
if|if
condition|(
name|z
operator|&&
name|valmrs
argument_list|(
operator|&
name|gpkt
argument_list|,
name|z
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"invalid MRs (de9)"
argument_list|)
expr_stmt|;
name|putmrs
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
block|}
comment|/* 		Enter comment line for `chghist' 		*/
if|if
condition|(
name|HADY
condition|)
block|{
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c "
argument_list|,
name|CTLCHAR
argument_list|,
name|COMMENTS
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|Comments
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			insert date/time and pgmr into comment line 			*/
name|cmt_ba
argument_list|(
operator|&
name|dt
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* 		End of delta-table. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EDELTAB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		Beginning of user-name section. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|BUSERNAM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 		For old file, copy to x-file until user-name section 		is found. 		*/
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|BUSERNAM
argument_list|,
name|COPY
argument_list|)
expr_stmt|;
comment|/* 	Write user-names to be added to list of those 	allowed to make deltas. 	*/
if|if
condition|(
name|HADA
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|asub
condition|;
name|k
operator|++
control|)
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s\n"
argument_list|,
name|anames
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	Do not copy those user-names which are to be erased. 	*/
if|if
condition|(
name|HADE
operator|&&
operator|!
name|HADN
condition|)
while|while
condition|(
operator|(
name|cp
operator|=
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
operator|)
operator|&&
operator|!
operator|(
operator|*
name|cp
operator|++
operator|==
name|CTLCHAR
operator|&&
operator|*
name|cp
operator|==
name|EUSERNAM
operator|)
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|esub
condition|;
name|k
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|gpkt
operator|.
name|p_line
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
comment|/* find and */
name|cp
operator|++
expr_stmt|;
comment|/* zero newline */
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* character */
if|if
condition|(
name|equal
argument_list|(
name|enames
index|[
name|k
index|]
argument_list|,
operator|&
name|gpkt
operator|.
name|p_line
argument_list|)
condition|)
block|{
comment|/* 					Tell getline not to output 					previously read line. 					*/
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|cp
operator|=
literal|'\n'
expr_stmt|;
comment|/* restore newline */
block|}
block|}
if|if
condition|(
name|HADN
condition|)
block|{
comment|/*   N E W  F I L E   */
comment|/* 		End of user-name section. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EUSERNAM
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* 		For old file, copy to x-file until end of 		user-names section is found. 		*/
if|if
condition|(
operator|!
name|HADE
condition|)
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|EUSERNAM
argument_list|,
name|COPY
argument_list|)
expr_stmt|;
comment|/* 	For old file, read flags and their values (if any), and 	store them. Check to see if the flag read is one that 	should be deleted. 	*/
if|if
condition|(
operator|!
name|HADN
condition|)
while|while
condition|(
operator|(
name|cp
operator|=
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|++
operator|==
name|CTLCHAR
operator|&&
operator|*
name|cp
operator|==
name|FLAG
operator|)
condition|)
block|{
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|1
expr_stmt|;
comment|/* don't write previous line */
name|cp
operator|=
operator|+
literal|2
expr_stmt|;
comment|/* point to flag character */
name|k
operator|=
operator|*
name|cp
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
operator|!
name|had_flag
index|[
name|k
index|]
operator|&&
operator|!
name|rm_flag
index|[
name|k
index|]
condition|)
block|{
name|had_flag
index|[
name|k
index|]
operator|=
literal|2
expr_stmt|;
comment|/* indicate flag is */
comment|/* from file, not */
comment|/* from arg list */
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
literal|'\n'
condition|)
block|{
comment|/* get flag value */
name|q
operator|=
name|alloc
argument_list|(
name|size
argument_list|(
name|gpkt
operator|.
name|p_line
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|++
name|cp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|flag_p
index|[
name|k
index|]
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
comment|/* find and */
name|q
operator|++
expr_stmt|;
comment|/* zero newline */
operator|*
operator|--
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* character */
block|}
block|}
elseif|else
if|if
condition|(
name|rm_flag
index|[
name|k
index|]
condition|)
name|had_flag
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	Write out flags. 	*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|26
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|had_flag
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
name|flag_p
index|[
name|k
index|]
condition|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c %s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
literal|'a'
operator|+
name|k
argument_list|,
name|flag_p
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
literal|'a'
operator|+
name|k
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_flag
index|[
name|k
index|]
operator|==
literal|2
condition|)
block|{
comment|/* flag was taken from file */
name|had_flag
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_p
index|[
name|k
index|]
condition|)
block|{
name|free
argument_list|(
name|flag_p
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|flag_p
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|HADN
condition|)
comment|/* 		Beginning of descriptive (user) text. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|BUSERTXT
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* 		Write out BUSERTXT record which was read in 		above loop that processes flags. 		*/
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|0
expr_stmt|;
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	Get user description, copy to x-file. 	*/
if|if
condition|(
name|HADT
condition|)
block|{
if|if
condition|(
operator|*
name|tfile
condition|)
block|{
name|iptr
operator|=
name|xfopen
argument_list|(
name|tfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fgetchk
argument_list|(
name|line
argument_list|,
literal|512
argument_list|,
name|iptr
argument_list|,
name|tfile
argument_list|,
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|iptr
argument_list|)
expr_stmt|;
block|}
comment|/* 		If old file, ignore any previously supplied 		commentary. (i.e., don't copy it to x-file.) 		*/
if|if
condition|(
operator|!
name|HADN
condition|)
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|EUSERTXT
argument_list|,
name|NOCOPY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HADN
condition|)
block|{
comment|/*   N E W  F I L E   */
comment|/* 		End of user description. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EUSERTXT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		Beginning of body (text) of first delta. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %u\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|INS
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADI
condition|)
block|{
comment|/* get body */
comment|/* 			Set indicator to check lines of body of file for 			keyword definitions. 			If no keywords are found, a warning 			will be produced. 			*/
name|check_id
operator|=
literal|1
expr_stmt|;
comment|/* 			Set indicator that tells whether there 			were any keywords to 'no'. 			*/
name|Did_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|ifile
condition|)
name|iptr
operator|=
name|xfopen
argument_list|(
name|ifile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* from a file */
else|else
name|iptr
operator|=
name|stdin
expr_stmt|;
comment|/* from standard input */
comment|/* 			Read and copy to x-file, while checking 			first character of each line to see that it 			is not the control character (octal 1). 			Also, count lines read, and set statistics' 			structure appropriately. 			The 'fgetchk' routine will check for keywords. 			*/
name|stats
operator|.
name|s_ins
operator|=
name|fgetchk
argument_list|(
name|line
argument_list|,
literal|512
argument_list|,
name|iptr
argument_list|,
name|ifile
argument_list|,
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|stats
operator|.
name|s_del
operator|=
name|stats
operator|.
name|s_unc
operator|=
literal|0
expr_stmt|;
comment|/* 			If no keywords were found, issue warning. 			*/
if|if
condition|(
operator|!
name|Did_id
condition|)
block|{
if|if
condition|(
name|had_flag
index|[
name|IDFLAG
operator|-
literal|'a'
index|]
condition|)
name|fatal
argument_list|(
literal|"no id keywords (cm6)"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
literal|"No id keywords (cm7)"
argument_list|)
expr_stmt|;
block|}
name|check_id
operator|=
literal|0
expr_stmt|;
name|Did_id
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		End of body of first delta. 		*/
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %u\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|END
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		Indicate that EOF at this point is ok, and 		flush rest of (old) s-file to x-file. 		*/
name|gpkt
operator|.
name|p_chkeof
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
condition|)
empty_stmt|;
block|}
comment|/* 	Flush the buffer, take care of rewinding to insert 	checksum and statistics in file, and close. 	*/
name|flushline
argument_list|(
operator|&
name|gpkt
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
comment|/* 	Change x-file name to s-file, and delete old file. 	Unlock file before returning. 	*/
if|if
condition|(
operator|!
name|HADH
condition|)
block|{
name|rename
argument_list|(
name|auxf
argument_list|(
operator|&
name|gpkt
argument_list|,
literal|'x'
argument_list|)
argument_list|,
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|xrm
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|unlockit
argument_list|(
name|auxf
argument_list|(
name|afile
argument_list|,
literal|'z'
argument_list|)
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|fgetchk
argument_list|(
name|strp
argument_list|,
name|len
argument_list|,
name|inptr
argument_list|,
name|file
argument_list|,
name|pkt
argument_list|)
specifier|register
name|char
operator|*
name|strp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|strp
argument_list|,
name|len
argument_list|,
name|inptr
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|strp
operator|==
name|CTLCHAR
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"%s illegal data on line %d (ad21)"
argument_list|,
name|file
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_id
condition|)
name|chkid
argument_list|(
name|strp
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|strp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|k
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|clean_up
argument_list|()
end_macro

begin_block
block|{
name|xrm
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HADH
condition|)
name|unlockit
argument_list|(
name|Zhold
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|HADN
condition|)
name|unlink
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cmt_ba
argument_list|(
name|dt
argument_list|,
name|str
argument_list|)
specifier|register
expr|struct
name|deltab
operator|*
name|dt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|CTLCHAR
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|COMMENTS
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|copy
argument_list|(
literal|"date and time created"
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|date_ba
argument_list|(
operator|&
name|dt
operator|->
name|d_datetime
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|copy
argument_list|(
literal|"by"
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|copy
argument_list|(
name|dt
operator|->
name|d_pgmr
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_block

begin_macro
name|putmrs
argument_list|(
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
name|str
index|[
literal|64
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Varg
index|[]
decl_stmt|;
for|for
control|(
name|argv
operator|=
operator|&
name|Varg
index|[
name|VSTART
index|]
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%c%c %s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|MRNUM
argument_list|,
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

