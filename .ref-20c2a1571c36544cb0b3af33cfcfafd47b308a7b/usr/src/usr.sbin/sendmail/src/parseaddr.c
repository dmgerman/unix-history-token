begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|parseaddr
operator|.
name|c
literal|3.37
operator|%
name|G
operator|%
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  PARSE -- Parse an address ** **	Parses an address and breaks it up into three parts: a **	net to transmit the message on, the host to transmit it **	to, and a user on that host.  These are loaded into an **	ADDRESS header with the values squirreled away if necessary. **	The "user" part may not be a real user; the process may **	just reoccur on that machine.  For example, on a machine **	with an arpanet connection, the address **		csvax.bill@berkeley **	will break up to a "user" of 'csvax.bill' and a host **	of 'berkeley' -- to be transmitted over the arpanet. ** **	Parameters: **		addr -- the address to parse. **		a -- a pointer to the address descriptor buffer. **			If NULL, a header will be created. **		copyf -- determines what shall be copied: **			-1 -- don't copy anything.  The printname **				(q_paddr) is just addr, and the **				user& host are allocated internally **				to parse. **			0 -- copy out the parsed user& host, but **				don't copy the printname. **			+1 -- copy everything. ** **	Returns: **		A pointer to the address descriptor header (`a' if **			`a' is non-NULL). **		NULL on error. ** **	Side Effects: **		none */
end_comment

begin_define
define|#
directive|define
name|DELIMCHARS
value|"$()<>,;\\\"\r\n"
end_define

begin_comment
comment|/* word delimiters */
end_comment

begin_function
name|ADDRESS
modifier|*
name|parse
parameter_list|(
name|addr
parameter_list|,
name|a
parameter_list|,
name|copyf
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|copyf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|()
function_decl|;
comment|/* 	**  Initialize and prescan address. 	*/
name|To
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n--parse(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|pvp
operator|=
name|prescan
argument_list|(
name|addr
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	**  Apply rewriting rules. 	*/
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**  See if we resolved to a real mailer. 	*/
if|if
condition|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
name|CANONNET
condition|)
block|{
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"cannot resolve name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Build canonical address from pvp. 	*/
name|a
operator|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
comment|/* 	**  Make local copies of the host& user and then 	**  transport them out. 	*/
if|if
condition|(
name|copyf
operator|>
literal|0
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|newstr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|q_paddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|copyf
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_host
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_host
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|q_host
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do UPPER->lower case mapping unless inhibited. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_HST_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_USR_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
comment|/* 	**  Compute return value. 	*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"parse-->"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRESCAN -- Prescan name and make it canonical ** **	Scans a name and turns it into canonical form.  This involves **	deleting blanks, comments (in parentheses), and turning the **	word "at" into an at-sign ("@").  The name is copied as this **	is done; it is legal to copy a name onto itself, since this **	process can only make things smaller. ** **	This routine knows about quoted strings and angle brackets. ** **	There are certain subtleties to this routine.  The one that **	comes to mind now is that backslashes on the ends of names **	are silently stripped off; this is intentional.  The problem **	is that some versions of sndmsg (like at LBL) set the kill **	character to something other than @ when reading addresses; **	so people type "csvax.eric\@berkeley" -- which screws up the **	berknet mailer. ** **	Parameters: **		addr -- the name to chomp. **		delim -- the delimiter for the address, normally **			'\0' or ','; \0 is accepted in any case. **			are moving in place; set buflim to high core. ** **	Returns: **		A pointer to a vector of tokens. **		NULL on error. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|OPER
value|1
end_define

begin_define
define|#
directive|define
name|ATOM
value|2
end_define

begin_define
define|#
directive|define
name|EOTOK
value|3
end_define

begin_define
define|#
directive|define
name|QSTRING
value|4
end_define

begin_define
define|#
directive|define
name|SPACE
value|5
end_define

begin_define
define|#
directive|define
name|DOLLAR
value|6
end_define

begin_define
define|#
directive|define
name|GETONE
value|7
end_define

begin_define
define|#
directive|define
name|MACRO
value|8
end_define

begin_function
name|char
modifier|*
modifier|*
name|prescan
parameter_list|(
name|addr
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|delim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
operator|+
name|MAXATOM
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|av
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
name|bool
name|bslashmode
decl_stmt|;
name|int
name|cmntcnt
decl_stmt|;
name|int
name|brccnt
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
name|int
name|nstate
decl_stmt|;
specifier|extern
name|char
name|lower
parameter_list|()
function_decl|;
name|q
operator|=
name|buf
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
name|cmntcnt
operator|=
name|brccnt
operator|=
literal|0
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
name|state
operator|=
name|OPER
expr_stmt|;
for|for
control|(
name|p
operator|=
name|addr
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|delim
condition|;
control|)
block|{
comment|/* read a token */
name|tok
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
block|{
comment|/* chew up special characters */
name|c
operator|&=
operator|~
literal|0200
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bslashmode
condition|)
block|{
name|c
operator||=
literal|0200
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|bslashmode
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|QSTRING
condition|)
name|state
operator|=
name|OPER
expr_stmt|;
else|else
name|state
operator|=
name|QSTRING
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
name|delim
operator|==
literal|'\t'
condition|)
name|nstate
operator|=
name|DOLLAR
expr_stmt|;
else|else
name|nstate
operator|=
name|toktype
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QSTRING
case|:
comment|/* in quoted string */
break|break;
case|case
name|ATOM
case|:
comment|/* regular atom */
if|if
condition|(
name|nstate
operator|!=
name|ATOM
condition|)
block|{
name|state
operator|=
name|EOTOK
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|GETONE
case|:
comment|/* grab one character */
name|state
operator|=
name|OPER
expr_stmt|;
break|break;
case|case
name|EOTOK
case|:
comment|/* after atom or q-string */
name|state
operator|=
name|nstate
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SPACE
condition|)
continue|continue;
break|break;
case|case
name|SPACE
case|:
comment|/* linear white space */
name|state
operator|=
name|nstate
expr_stmt|;
break|break;
case|case
name|OPER
case|:
comment|/* operator */
if|if
condition|(
name|nstate
operator|==
name|SPACE
condition|)
continue|continue;
name|state
operator|=
name|nstate
expr_stmt|;
break|break;
case|case
name|DOLLAR
case|:
comment|/* $- etc. */
name|state
operator|=
name|OPER
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* replacement */
name|c
operator|=
name|MATCHREPL
expr_stmt|;
name|state
operator|=
name|GETONE
expr_stmt|;
name|p
operator|--
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* literal $ */
break|break;
case|case
literal|'+'
case|:
comment|/* match anything */
name|c
operator|=
name|MATCHANY
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* match one token */
name|c
operator|=
name|MATCHONE
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* match one token of class */
name|c
operator|=
name|MATCHCLASS
expr_stmt|;
name|state
operator|=
name|GETONE
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* canonical net name */
name|c
operator|=
name|CANONNET
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* canonical host name */
name|c
operator|=
name|CANONHOST
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* canonical user name */
name|c
operator|=
name|CANONUSER
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|MACRO
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"prescan: unknown state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|EOTOK
operator|||
name|state
operator|==
name|SPACE
condition|)
break|break;
if|if
condition|(
name|state
operator|==
name|DOLLAR
condition|)
continue|continue;
comment|/* squirrel it away */
if|if
condition|(
name|q
operator|>=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|5
index|]
condition|)
block|{
name|usrerr
argument_list|(
literal|"Address too long"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|==
name|MACRO
condition|)
block|{
name|char
name|mbuf
index|[
literal|3
index|]
decl_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|mbuf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|mbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|expand
argument_list|(
name|mbuf
argument_list|,
name|q
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|5
index|]
argument_list|)
expr_stmt|;
name|q
operator|+=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|state
operator|=
name|EOTOK
expr_stmt|;
break|break;
block|}
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
comment|/* decide whether this represents end of token */
if|if
condition|(
name|state
operator|==
name|OPER
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
name|delim
condition|)
name|p
operator|--
expr_stmt|;
comment|/* new token */
if|if
condition|(
name|tok
operator|==
name|q
condition|)
continue|continue;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|cmntcnt
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced ')'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|cmntcnt
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
continue|continue;
comment|/* we prefer<> specs */
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|brccnt
operator|<
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"multiple< spec"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|brccnt
operator|++
expr_stmt|;
if|if
condition|(
name|brccnt
operator|==
literal|1
condition|)
block|{
comment|/* we prefer using machine readable name */
name|q
operator|=
name|buf
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|brccnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced `>'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
name|brccnt
operator|--
expr_stmt|;
if|if
condition|(
name|brccnt
operator|<=
literal|0
condition|)
block|{
name|brccnt
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|avp
operator|>=
operator|&
name|av
index|[
name|MAXATOM
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"prescan: too many tokens"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|avp
operator|++
operator|=
name|tok
expr_stmt|;
block|}
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '('"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|brccnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '<'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|QSTRING
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '\"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|av
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TOKTYPE -- return token type ** **	Parameters: **		c -- the character in question. ** **	Returns: **		Its type. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|toktype
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|bool
name|firstime
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|firstime
condition|)
block|{
name|firstime
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|expand
argument_list|(
literal|"$o"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|DELIMCHARS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|ATOM
operator|)
return|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|SPACE
operator|)
return|;
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
operator|||
name|index
argument_list|(
name|buf
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|OPER
operator|)
return|;
return|return
operator|(
name|ATOM
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  REWRITE -- apply rewrite rules to token vector. ** **	This routine is an ordered production system.  Each rewrite **	rule has a LHS (called the pattern) and a RHS (called the **	rewrite); 'rwr' points the the current rewrite rule. ** **	For each rewrite rule, 'avp' points the address vector we **	are trying to match against, and 'pvp' points to the pattern. **	If pvp points to a special match value (MATCHANY, MATCHONE, **	MATCHCLASS) then the address in avp matched is saved away **	in the match vector (pointed to by 'mvp'). ** **	When a match between avp& pvp does not match, we try to **	back out.  If we back up over a MATCHONE or a MATCHCLASS **	we must also back out the match in mvp.  If we reach a **	MATCHANY we just extend the match and start over again. ** **	When we finally match, we rewrite the address vector **	and try over again. ** **	Parameters: **		pvp -- pointer to token vector. ** **	Returns: **		none. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_struct
struct|struct
name|match
block|{
name|char
modifier|*
modifier|*
name|first
decl_stmt|;
comment|/* first token matched */
name|char
modifier|*
modifier|*
name|last
decl_stmt|;
comment|/* last token matched */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXMATCH
value|9
end_define

begin_comment
comment|/* max params per rewrite */
end_comment

begin_macro
name|rewrite
argument_list|(
argument|pvp
argument_list|,
argument|ruleset
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ruleset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* address pointer */
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* rewrite pointer */
specifier|register
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
comment|/* address vector pointer */
specifier|register
name|char
modifier|*
modifier|*
name|rvp
decl_stmt|;
comment|/* rewrite vector pointer */
name|struct
name|rewrite
modifier|*
name|rwr
decl_stmt|;
comment|/* pointer to current rewrite rule */
name|struct
name|match
name|mlist
index|[
name|MAXMATCH
index|]
decl_stmt|;
comment|/* stores match on LHS */
name|struct
name|match
modifier|*
name|mlp
decl_stmt|;
comment|/* cur ptr into mlist */
name|char
modifier|*
name|npvp
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
comment|/* temporary space for rebuild */
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|9
condition|)
block|{
name|printf
argument_list|(
literal|"rewrite: original pvp:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Run through the list of rewrite rules, applying 	**	any that match. 	*/
for|for
control|(
name|rwr
operator|=
name|RewriteRules
index|[
name|ruleset
index|]
init|;
name|rwr
operator|!=
name|NULL
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"-----trying rule:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rwr
operator|->
name|r_lhs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* try to match on this rule */
name|mlp
operator|=
name|mlist
expr_stmt|;
for|for
control|(
name|rvp
operator|=
name|rwr
operator|->
name|r_lhs
operator|,
name|avp
operator|=
name|pvp
init|;
operator|*
name|avp
operator|!=
name|NULL
condition|;
control|)
block|{
name|ap
operator|=
operator|*
name|avp
expr_stmt|;
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
comment|/* end-of-pattern before end-of-address */
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
operator|*
name|rp
condition|)
block|{
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|class
decl_stmt|;
case|case
name|MATCHCLASS
case|:
comment|/* match any token in a class */
name|class
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|class
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|isupper
argument_list|(
name|class
argument_list|)
condition|)
name|class
operator|-=
literal|'A'
expr_stmt|;
else|else
name|class
operator|-=
literal|'a'
expr_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|ap
argument_list|,
name|ST_CLASS
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
name|s
operator|->
name|s_class
operator|&
operator|(
literal|1
operator|<<
name|class
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* explicit fall-through */
case|case
name|MATCHONE
case|:
case|case
name|MATCHANY
case|:
comment|/* match exactly one token */
name|mlp
operator|->
name|first
operator|=
name|mlp
operator|->
name|last
operator|=
name|avp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* must have exact match */
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|rp
argument_list|,
name|ap
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|avp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* successful match on this token */
name|rvp
operator|++
expr_stmt|;
continue|continue;
name|fail
label|:
comment|/* match failed -- back up */
while|while
condition|(
operator|--
name|rvp
operator|>=
name|rwr
operator|->
name|r_lhs
condition|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHANY
condition|)
block|{
comment|/* extend binding and continue */
name|mlp
index|[
operator|-
literal|1
index|]
operator|.
name|last
operator|=
name|avp
operator|++
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
break|break;
block|}
name|avp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHONE
operator|||
operator|*
name|rp
operator|==
name|MATCHCLASS
condition|)
block|{
comment|/* back out binding */
name|mlp
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rvp
operator|<
name|rwr
operator|->
name|r_lhs
condition|)
block|{
comment|/* total failure to match */
break|break;
block|}
block|}
comment|/* 		**  See if we successfully matched 		*/
if|if
condition|(
name|rvp
operator|>=
name|rwr
operator|->
name|r_lhs
operator|&&
operator|*
name|rvp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"-----rule matches:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rwr
operator|->
name|r_rhs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* substitute */
for|for
control|(
name|rvp
operator|=
name|rwr
operator|->
name|r_rhs
operator|,
name|avp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHREPL
condition|)
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|m
operator|=
operator|&
name|mlist
index|[
name|rp
index|[
literal|1
index|]
operator|-
literal|'1'
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|13
condition|)
block|{
name|printf
argument_list|(
literal|"$%c:"
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pp
operator|=
name|m
operator|->
name|first
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|" %x=\""
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\""
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pp
operator|++
operator|!=
name|m
operator|->
name|last
condition|)
do|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
name|pp
operator|=
name|m
operator|->
name|first
expr_stmt|;
do|do
block|{
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"rewrite: expansion too long"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|avp
operator|++
operator|=
operator|*
name|pp
expr_stmt|;
block|}
do|while
condition|(
name|pp
operator|++
operator|!=
name|m
operator|->
name|last
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"rewrite: expansion too long"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|avp
operator|++
operator|=
name|rp
expr_stmt|;
block|}
block|}
operator|*
name|avp
operator|++
operator|=
name|NULL
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|npvp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pvp
argument_list|,
operator|(
name|avp
operator|-
name|npvp
operator|)
operator|*
sizeof|sizeof
expr|*
name|avp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|3
condition|)
block|{
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|printf
argument_list|(
literal|"rewritten as `"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|pvp
init|;
operator|*
name|vp
operator|!=
name|NULL
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
name|vp
operator|!=
name|pvp
condition|)
name|printf
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
operator|*
name|vp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
name|CANONNET
condition|)
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
name|printf
argument_list|(
literal|"----- rule fails\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUILDADDR -- build address from token vector. ** **	Parameters: **		tv -- token vector. **		a -- pointer to address descriptor to fill. **			If NULL, one will be allocated. ** **	Returns: **		NULL if there was an error. **		'a' otherwise. ** **	Side Effects: **		fills in 'a' */
end_comment

begin_function
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|(
name|tv
parameter_list|,
name|a
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|tv
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|struct
name|mailer
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
comment|/* figure out what net/mailer to use */
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONNET
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: no net"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tv
operator|++
expr_stmt|;
if|if
condition|(
name|sameword
argument_list|(
operator|*
name|tv
argument_list|,
literal|"error"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|*
operator|++
name|tv
operator|!=
name|CANONUSER
condition|)
name|syserr
argument_list|(
literal|"buildaddr: error: no user"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|tv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
block|}
name|usrerr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|mp
operator|=
name|Mailer
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
operator|*
name|tv
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: unknown net %s"
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|a
operator|->
name|q_mailer
operator|=
name|m
expr_stmt|;
comment|/* figure out what host (if any) */
name|tv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_LOCAL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONHOST
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: no host"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tv
operator|++
expr_stmt|;
name|a
operator|->
name|q_host
operator|=
operator|*
name|tv
expr_stmt|;
name|tv
operator|++
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
comment|/* figure out the user */
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: no user"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cataddr
argument_list|(
operator|++
name|tv
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CATADDR -- concatenate pieces of addresses (putting in<LWSP> subs) ** **	Parameters: **		pvp -- parameter vector to rebuild. **		buf -- buffer to build the string into. **		sz -- size of buf. ** **	Returns: **		none. ** **	Side Effects: **		Destroys buf. */
end_comment

begin_macro
name|cataddr
argument_list|(
argument|pvp
argument_list|,
argument|buf
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|sz
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bool
name|oatomtok
init|=
name|FALSE
decl_stmt|;
name|bool
name|natomtok
init|=
name|FALSE
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|sz
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|*
name|pvp
argument_list|)
operator|)
operator|<
name|sz
condition|)
block|{
name|natomtok
operator|=
operator|(
name|toktype
argument_list|(
operator|*
operator|*
name|pvp
argument_list|)
operator|==
name|ATOM
operator|)
expr_stmt|;
if|if
condition|(
name|oatomtok
operator|&&
name|natomtok
condition|)
operator|*
name|p
operator|++
operator|=
name|SPACESUB
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|pvp
argument_list|)
expr_stmt|;
name|oatomtok
operator|=
name|natomtok
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|sz
operator|-=
name|i
expr_stmt|;
name|pvp
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SAMEADDR -- Determine if two addresses are the same ** **	This is not just a straight comparison -- if the mailer doesn't **	care about the host we just ignore it, etc. ** **	Parameters: **		a, b -- pointers to the internal forms to compare. **		wildflg -- if TRUE, 'a' may have no user specified, **			in which case it is to match anything. ** **	Returns: **		TRUE -- they represent the same mailbox. **		FALSE -- they don't. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|sameaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|wildflg
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|b
decl_stmt|;
name|bool
name|wildflg
decl_stmt|;
block|{
comment|/* if they don't have the same mailer, forget it */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|b
operator|->
name|q_mailer
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the user isn't the same, we can drop out */
if|if
condition|(
operator|(
operator|!
name|wildflg
operator|||
name|a
operator|->
name|q_user
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|b
operator|->
name|q_user
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the mailer ignores hosts, we have succeeded! */
if|if
condition|(
name|bitset
argument_list|(
name|M_LOCAL
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* otherwise compare hosts (but be careful for NULL ptrs) */
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
operator|||
name|b
operator|->
name|q_host
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_host
argument_list|,
name|b
operator|->
name|q_host
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTADDR -- print address (for debugging) ** **	Parameters: **		a -- the address to print **		follow -- follow the q_next chain. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|printaddr
argument_list|(
name|a
argument_list|,
name|follow
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
specifier|static
name|int
name|indent
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x="
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: mailer %d (%s), host `%s', user `%s'\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_mno
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|->
name|q_host
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnext=%x, flags=%o, rmailer %d, alias=%x, sibling=%x, child=%x\n"
argument_list|,
name|a
operator|->
name|q_next
argument_list|,
name|a
operator|->
name|q_flags
argument_list|,
name|a
operator|->
name|q_rmailer
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
name|a
operator|->
name|q_sibling
argument_list|,
name|a
operator|->
name|q_child
argument_list|)
expr_stmt|;
comment|/* follow the chain if appropriate */
if|if
condition|(
operator|!
name|follow
condition|)
return|return;
name|indent
operator|++
expr_stmt|;
name|printaddr
argument_list|(
name|a
operator|->
name|q_child
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|q_sibling
expr_stmt|;
block|}
if|if
condition|(
name|first
condition|)
name|printf
argument_list|(
literal|"[NULL]\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

end_unit

