begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|sym
operator|.
name|c
literal|2.4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"a.out.h"
end_include

begin_decl_stmt
name|MSG
name|BADFIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMTAB
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
name|localok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|lastframe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMSLAVE
modifier|*
name|symvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|maxoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|maxstor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol management */
end_comment

begin_decl_stmt
name|L_INT
name|symbas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|symcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|symnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|localval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|symrqd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMTAB
name|symbuf
index|[
name|SYMSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMPTR
name|symnxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMPTR
name|symend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|POS
name|findsym
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* symbol table and file handling service routines */
end_comment

begin_macro
name|longseek
argument_list|(
argument|f
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|L_INT
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|EDDT
return|return
operator|(
name|lseek
argument_list|(
name|f
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|valpr
argument_list|(
argument|v
argument_list|,
argument|idsp
argument_list|)
end_macro

begin_block
block|{
name|POS
name|d
decl_stmt|;
name|d
operator|=
name|findsym
argument_list|(
name|v
argument_list|,
name|idsp
argument_list|)
expr_stmt|;
name|IF
name|d
operator|<
name|maxoff
name|THEN
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|symbol
operator|.
name|symc
argument_list|)
expr_stmt|;
name|IF
name|d
name|THEN
name|printf
parameter_list|(
name|OFFMODE
parameter_list|,
name|d
parameter_list|)
function_decl|;
name|FI
name|FI
block|}
end_block

begin_macro
name|localsym
argument_list|(
argument|cframe
argument_list|,
argument|cargp
argument_list|)
end_macro

begin_decl_stmt
name|ADDR
name|cframe
decl_stmt|,
name|cargp
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|EDDT
name|INT
name|symflg
decl_stmt|;
name|WHILE
name|nextsym
argument_list|()
name|ANDF
name|symbol
operator|.
name|symc
index|[
literal|0
index|]
operator|!=
literal|'_'
name|ANDF
argument_list|(
name|symflg
operator|=
name|symbol
operator|.
name|symf
argument_list|)
operator|!=
name|N_FN
name|DO
name|IF
name|symflg
operator|>=
name|N_TEXT
name|ANDF
name|symflg
operator|<=
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
name|THEN
name|localval
operator|=
name|symbol
operator|.
name|symv
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
name|ELIF
name|symflg
operator|==
name|N_ABS
name|THEN
name|localval
operator|=
operator|(
name|symbol
operator|.
name|symv
operator|<
literal|0
condition|?
name|cframe
else|:
name|cargp
operator|)
operator|+
name|symbol
operator|.
name|symv
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
name|FI
name|OD
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_macro
name|psymoff
argument_list|(
argument|v
argument_list|,
argument|type
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|L_INT
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|POS
name|w
decl_stmt|;
name|IF
argument_list|(
argument|v!=
literal|0
argument_list|)
name|THEN
name|w
init|=
name|findsym
argument_list|(
name|v
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|FI
name|IF
name|v
operator|==
literal|0
name|ORF
name|w
operator|>=
name|maxoff
name|ORF
argument_list|(
argument|(v&~
literal|0x80000000
argument|)<maxoff ANDF w!=
literal|0
argument_list|)
name|THEN
name|printf
argument_list|(
name|LPRMODE
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|ELSE
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|symbol
operator|.
name|symc
argument_list|)
decl_stmt|;
name|IF
name|w
name|THEN
name|printf
parameter_list|(
name|OFFMODE
parameter_list|,
name|w
parameter_list|)
function_decl|;
name|FI
name|FI
name|printf
parameter_list|(
name|s
parameter_list|)
function_decl|;
block|}
end_block

begin_function
name|POS
name|findsym
parameter_list|(
name|svalue
parameter_list|,
name|type
parameter_list|)
name|L_INT
name|svalue
decl_stmt|;
name|INT
name|type
decl_stmt|;
block|{
name|L_INT
name|diff
decl_stmt|,
name|value
decl_stmt|,
name|symval
decl_stmt|,
name|offset
decl_stmt|;
name|INT
name|symtyp
decl_stmt|;
ifndef|#
directive|ifndef
name|EDDT
name|REG
name|SYMSLAVE
modifier|*
name|symptr
decl_stmt|;
name|SYMSLAVE
modifier|*
name|symsav
decl_stmt|;
else|#
directive|else
name|REG
name|SYMPTR
modifier|*
name|symptr
decl_stmt|;
name|SYMPTR
modifier|*
name|symsav
decl_stmt|;
endif|#
directive|endif
name|value
operator|=
name|svalue
expr_stmt|;
name|diff
operator|=
literal|0x7fffffffL
expr_stmt|;
name|symsav
operator|=
literal|0
expr_stmt|;
name|IF
name|type
operator|!=
name|NSYM
name|ANDF
argument_list|(
argument|symptr=symvec
argument_list|)
ifndef|#
directive|ifndef
name|EDDT
name|THEN
name|WHILE
name|diff
name|ANDF
argument_list|(
name|symtyp
operator|=
name|symptr
operator|->
name|typslave
argument_list|)
operator|!=
name|ESYM
name|DO
name|IF
argument_list|(
argument|type==
literal|0
argument|ORF symtyp==type
argument_list|)
name|ANDF
name|symptr
operator|->
name|typslave
operator|!=
name|XSYM
name|THEN
name|symval
operator|=
name|symptr
operator|->
name|valslave
expr_stmt|;
name|IF
name|value
operator|-
name|symval
operator|<
name|diff
name|ANDF
name|value
operator|>=
name|symval
name|THEN
name|diff
operator|=
name|value
operator|-
name|symval
expr_stmt|;
name|symsav
operator|=
name|symptr
expr_stmt|;
name|FI
name|FI
name|symptr
operator|++
expr_stmt|;
name|OD
name|IF
name|symsav
name|THEN
name|offset
init|=
name|leng
argument_list|(
name|symsav
operator|-
name|symvec
argument_list|)
decl_stmt|;
name|symcnt
operator|=
name|symnum
operator|-
name|offset
expr_stmt|;
name|longseek
argument_list|(
name|fsym
argument_list|,
name|symbas
operator|+
name|offset
operator|*
name|SYMTABSIZ
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fsym
argument_list|,
operator|&
name|symbol
argument_list|,
name|SYMTABSIZ
argument_list|)
expr_stmt|;
name|FI
name|FI
else|#
directive|else
name|THEN
name|WHILE
name|diff
name|ANDF
name|symptr
operator|<
name|symend
name|DO
name|IF
name|value
operator|-
name|symptr
operator|->
name|symv
operator|<
name|diff
name|ANDF
name|value
operator|>=
name|symptr
operator|->
name|symv
name|THEN
name|diff
operator|=
name|value
operator|-
name|symptr
operator|->
name|symv
expr_stmt|;
name|symsav
operator|=
name|symptr
expr_stmt|;
name|FI
name|symptr
operator|++
expr_stmt|;
name|OD
name|IF
name|symsav
name|THEN
name|cpsym
argument_list|(
name|symsav
argument_list|,
operator|&
name|symbol
argument_list|)
decl_stmt|;
name|FI
name|FI
endif|#
directive|endif
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EDDT
end_ifdef

begin_expr_stmt
name|cpsym
argument_list|(
name|fm
argument_list|,
name|to
argument_list|)
specifier|register
name|char
operator|*
name|fm
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|12
decl_stmt|;
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|fm
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|nextsym
argument_list|()
end_macro

begin_block
block|{
name|IF
argument_list|(
operator|--
name|symcnt
argument_list|)
operator|<
literal|0
name|THEN
return|return
operator|(
name|FALSE
operator|)
return|;
ifndef|#
directive|ifndef
name|EDDT
name|ELSE
return|return
operator|(
name|longseek
argument_list|(
name|fsym
argument_list|,
name|symbas
operator|+
operator|(
name|symnum
operator|-
name|symcnt
operator|)
operator|*
name|SYMTABSIZ
argument_list|)
operator|!=
literal|0
name|ANDF
name|read
argument_list|(
name|fsym
argument_list|,
operator|&
name|symbol
argument_list|,
name|SYMTABSIZ
argument_list|)
operator|==
name|SYMTABSIZ
operator|)
return|;
endif|#
directive|endif
name|FI
block|}
end_block

begin_comment
comment|/* sequential search through file */
end_comment

begin_macro
name|symset
argument_list|()
end_macro

begin_block
block|{
name|symcnt
operator|=
name|symnum
expr_stmt|;
ifndef|#
directive|ifndef
name|EDDT
name|symnxt
operator|=
name|symbuf
expr_stmt|;
name|IF
name|symrqd
name|THEN
name|longseek
parameter_list|(
name|fsym
parameter_list|,
name|symbas
parameter_list|)
function_decl|;
name|symread
argument_list|()
expr_stmt|;
name|symrqd
operator|=
name|FALSE
expr_stmt|;
name|ELSE
name|longseek
argument_list|(
name|fsym
argument_list|,
name|symbas
operator|+
sizeof|sizeof
name|symbuf
argument_list|)
decl_stmt|;
name|FI
else|#
directive|else
name|symnxt
init|=
name|symvec
decl_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|SYMPTR
name|symget
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|EDDT
name|REG
name|INT
name|rc
decl_stmt|;
name|IF
name|symnxt
operator|>=
name|symend
name|THEN
name|rc
operator|=
name|symread
argument_list|()
expr_stmt|;
name|symrqd
operator|=
name|TRUE
expr_stmt|;
name|ELSE
name|rc
init|=
name|TRUE
decl_stmt|;
name|FI
name|IF
operator|--
name|symcnt
operator|>
literal|0
name|ANDF
name|rc
operator|==
literal|0
name|THEN
name|errflg
operator|=
name|BADFIL
expr_stmt|;
name|FI
return|return
operator|(
operator|(
name|symcnt
operator|>=
literal|0
operator|&&
name|rc
operator|)
condition|?
name|symnxt
operator|++
else|:
literal|0
operator|)
return|;
else|#
directive|else
name|IF
operator|--
name|symcnt
operator|>=
literal|0
name|THEN
return|return
operator|(
name|symnxt
operator|++
operator|)
return|;
name|ELSE
return|return
operator|(
literal|0
operator|)
return|;
name|FI
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EDDT
end_ifndef

begin_macro
name|symread
argument_list|()
end_macro

begin_block
block|{
name|INT
name|symlen
decl_stmt|;
ifndef|#
directive|ifndef
name|vax
name|short
name|t
decl_stmt|;
name|SYMTAB
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|symlen
operator|=
name|read
argument_list|(
name|fsym
argument_list|,
name|symbuf
argument_list|,
sizeof|sizeof
name|symbuf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax
name|p
operator|=
name|symbuf
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|p
operator|<
operator|(
name|char
operator|*
operator|)
name|symbuf
operator|+
name|symlen
condition|)
block|{
name|t
operator|=
name|p
operator|->
name|symv
operator|.
name|hiword
expr_stmt|;
name|p
operator|->
name|symv
operator|.
name|hiword
operator|=
name|p
operator|->
name|symv
operator|.
name|loword
expr_stmt|;
name|p
operator|->
name|symv
operator|.
name|loword
operator|=
name|t
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|IF
name|symlen
operator|>=
name|SYMTABSIZ
name|THEN
name|symnxt
operator|=
name|symbuf
expr_stmt|;
name|symend
operator|=
operator|&
name|symbuf
index|[
name|symlen
operator|/
name|SYMTABSIZ
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
name|ELSE
return|return
operator|(
name|FALSE
operator|)
return|;
name|FI
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

