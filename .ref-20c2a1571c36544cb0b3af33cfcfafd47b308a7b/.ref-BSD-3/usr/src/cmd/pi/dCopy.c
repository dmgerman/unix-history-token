begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      *	dCopy.c      *      *	functions to copy pi declarations to pTrees      *	these should be all the functions      *	that mark the inTree field of the namelist      */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PTREE
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*      *	copy a T_PROG, T_PDEC, or T_FDEC into a PorFNode      *	porf	[0]	T_PROG T_PDEC or T_FDEC      *		[1]	lineof "program" or trailing ";"      *		[2]	program, procedure, or function name      *		[3]	file or formal parameter list      *		[4]	function return type or pNIL      */
end_comment

begin_function
name|pPointer
name|PorFCopy
parameter_list|(
name|porf
parameter_list|)
name|int
modifier|*
name|porf
decl_stmt|;
block|{
name|pPointer
name|PorF
decl_stmt|;
name|union
name|pNodeBodies
modifier|*
name|PorFp
decl_stmt|;
name|struct
name|nl
modifier|*
name|nlporf
decl_stmt|;
specifier|extern
name|struct
name|nl
modifier|*
name|program
decl_stmt|;
comment|/* 	     *	programs are defnl'ed but not entered, but extern program works 	     */
if|if
condition|(
name|porf
index|[
literal|0
index|]
operator|==
name|T_PROG
condition|)
name|nlporf
operator|=
name|program
expr_stmt|;
else|else
name|nlporf
operator|=
name|nllook
argument_list|(
name|porf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlporf
operator|->
name|inTree
operator|!=
name|pNIL
condition|)
block|{
name|pDEF
argument_list|(
name|nlporf
operator|->
name|inTree
argument_list|)
operator|.
name|PorFForward
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|PorF
operator|=
name|pNewNode
argument_list|(
name|PorFTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|PorFNode
argument_list|)
argument_list|)
expr_stmt|;
name|pSeize
argument_list|(
name|PorF
argument_list|)
expr_stmt|;
name|PorFp
operator|=
operator|&
operator|(
name|pDEF
argument_list|(
name|PorF
argument_list|)
operator|)
expr_stmt|;
name|PorFp
operator|->
name|PorFName
operator|=
name|sCopy
argument_list|(
name|porf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|PorFHeader
index|[
operator|++
name|nesting
index|]
operator|=
name|PorF
expr_stmt|;
if|if
condition|(
name|porf
index|[
literal|0
index|]
operator|!=
name|T_PROG
condition|)
name|PorFp
operator|->
name|PorFParams
operator|=
name|tCopy
argument_list|(
name|porf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|PorFp
operator|->
name|PorFParams
operator|=
name|FileCopy
argument_list|(
name|porf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|nesting
operator|--
expr_stmt|;
name|PorFp
operator|->
name|PorFLabels
operator|=
name|pNIL
expr_stmt|;
name|PorFp
operator|->
name|PorFConsts
operator|=
name|pNIL
expr_stmt|;
name|PorFp
operator|->
name|PorFTypes
operator|=
name|pNIL
expr_stmt|;
name|PorFp
operator|->
name|PorFVars
operator|=
name|pNIL
expr_stmt|;
name|PorFp
operator|->
name|PorFPFs
operator|=
name|pNIL
expr_stmt|;
name|PorFp
operator|->
name|PorFBody
operator|=
name|pNIL
expr_stmt|;
name|PorFp
operator|->
name|PorFReturns
operator|=
name|tCopy
argument_list|(
name|porf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|PorFp
operator|->
name|PorFForward
operator|=
name|FALSE
expr_stmt|;
name|pRelease
argument_list|(
name|PorF
argument_list|)
expr_stmt|;
name|nlporf
operator|->
name|inTree
operator|=
name|PorF
expr_stmt|;
return|return
name|PorF
return|;
block|}
end_function

begin_comment
comment|/*      *	looks for defined (but not entered) symbols      *	(either files or formal parameters)      *	which hang down the chain field of      *	program, procedure or function namelist entry.      */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|chainlookup
parameter_list|(
name|porf
parameter_list|,
name|symb
parameter_list|)
name|struct
name|nl
modifier|*
name|porf
decl_stmt|;
name|char
modifier|*
name|symb
decl_stmt|;
block|{
name|struct
name|nl
modifier|*
name|paramp
decl_stmt|;
for|for
control|(
name|paramp
operator|=
name|porf
operator|->
name|chain
init|;
name|paramp
operator|!=
name|NIL
condition|;
name|paramp
operator|=
name|paramp
operator|->
name|chain
control|)
if|if
condition|(
name|paramp
operator|->
name|symbol
operator|==
name|symb
condition|)
break|break;
return|return
name|paramp
return|;
block|}
end_function

begin_comment
comment|/*      *	copy a list of file names to a list of threads to VarDNodes      *	(or threads to the BVarNodes for input or output)      *	for later inclusion in the variable declaration list.      *	as a special case, the files are found chained to the program nl entry.      */
end_comment

begin_function
name|pPointer
name|FileCopy
parameter_list|(
name|files
parameter_list|)
name|int
modifier|*
name|files
decl_stmt|;
block|{
name|int
modifier|*
name|filep
decl_stmt|;
name|pPointer
name|Thread
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|First
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
specifier|extern
name|struct
name|nl
modifier|*
name|program
decl_stmt|;
specifier|extern
name|struct
name|nl
modifier|*
name|input
decl_stmt|;
specifier|extern
name|struct
name|nl
modifier|*
name|output
decl_stmt|;
name|First
operator|=
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|filep
operator|=
name|files
init|;
name|filep
operator|!=
name|NIL
condition|;
name|filep
operator|=
operator|(
name|int
operator|*
operator|)
name|filep
index|[
literal|2
index|]
control|)
block|{
name|struct
name|nl
modifier|*
name|file
init|=
name|chainlookup
argument_list|(
name|program
argument_list|,
name|filep
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|filep
index|[
literal|1
index|]
operator|==
name|input
operator|->
name|symbol
condition|)
block|{
name|file
operator|->
name|inTree
operator|=
name|input
operator|->
name|inTree
expr_stmt|;
name|Thread
operator|=
name|ThreadName
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filep
index|[
literal|1
index|]
operator|==
name|output
operator|->
name|symbol
condition|)
block|{
name|file
operator|->
name|inTree
operator|=
name|output
operator|->
name|inTree
expr_stmt|;
name|Thread
operator|=
name|ThreadName
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pPointer
name|File
init|=
name|pNewNode
argument_list|(
name|VarDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|VarDNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
name|filep
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|File
argument_list|)
operator|.
name|VarDName
operator|=
name|Name
expr_stmt|;
name|pDEF
argument_list|(
name|File
argument_list|)
operator|.
name|VarDType
operator|=
name|pNIL
expr_stmt|;
name|file
operator|->
name|inTree
operator|=
name|File
expr_stmt|;
name|Thread
operator|=
name|ThreadName
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|Thread
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
if|if
condition|(
name|After
operator|==
name|pNIL
condition|)
name|First
operator|=
name|List
expr_stmt|;
else|else
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
block|}
return|return
name|First
return|;
block|}
end_function

begin_comment
comment|/*      *	copy a formal parameter declaration to a TypedNode      *	and a list of ValPNodes or VarPNodes.      *	param	[0]	T_PVAL or T_PVAR      *		[1]	id_list      *		[2]	type      */
end_comment

begin_function
name|pPointer
name|ParamCopy
parameter_list|(
name|param
parameter_list|)
name|int
modifier|*
name|param
decl_stmt|;
block|{
name|int
modifier|*
name|idl
decl_stmt|;
name|pPointer
name|Param
decl_stmt|;
name|pPointer
name|Name
decl_stmt|;
name|pPointer
name|Typed
init|=
name|pNewNode
argument_list|(
name|TypedTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|TypedNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Type
init|=
name|tCopy
argument_list|(
name|param
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|nl
modifier|*
name|porf
decl_stmt|;
name|Name
operator|=
name|pUSE
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
operator|.
name|PorFName
expr_stmt|;
name|name
operator|=
operator|*
name|hash
argument_list|(
name|pUSE
argument_list|(
name|Name
argument_list|)
operator|.
name|StringValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|porf
operator|=
name|nllook
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|porf
operator|==
name|NIL
condition|)
name|panic
argument_list|(
literal|"ParamCopy:nllook"
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedType
operator|=
name|Type
expr_stmt|;
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|idl
operator|=
operator|(
name|int
operator|*
operator|)
name|param
index|[
literal|1
index|]
init|;
name|idl
operator|!=
name|NIL
condition|;
name|idl
operator|=
operator|(
name|int
operator|*
operator|)
name|idl
index|[
literal|2
index|]
control|)
block|{
switch|switch
condition|(
name|param
index|[
literal|0
index|]
condition|)
block|{
case|case
name|T_PVAL
case|:
name|Param
operator|=
name|pNewNode
argument_list|(
name|ValPTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ValPNode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PVAR
case|:
name|Param
operator|=
name|pNewNode
argument_list|(
name|VarPTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|VarPNode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ParamCopy:param[0]"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|Name
operator|=
name|sCopy
argument_list|(
name|idl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|Param
argument_list|)
operator|.
name|ParamDName
operator|=
name|Name
expr_stmt|;
name|pDEF
argument_list|(
name|Param
argument_list|)
operator|.
name|ParamDType
operator|=
name|Type
expr_stmt|;
name|chainlookup
argument_list|(
name|porf
argument_list|,
name|idl
index|[
literal|1
index|]
argument_list|)
operator|->
name|inTree
operator|=
name|Param
expr_stmt|;
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|Param
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
if|if
condition|(
name|After
operator|==
name|pNIL
condition|)
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedNames
operator|=
name|List
expr_stmt|;
else|else
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
block|}
return|return
name|Typed
return|;
block|}
end_function

begin_comment
comment|/*      *	construct a list of LabelDNodes from a list of YINTs      */
end_comment

begin_function
name|pPointer
name|LabelDCopy
parameter_list|(
name|labels
parameter_list|)
name|int
modifier|*
name|labels
decl_stmt|;
block|{
name|int
modifier|*
name|labelp
decl_stmt|;
name|pPointer
name|Label
decl_stmt|;
name|pPointer
name|Name
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|First
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|labelp
operator|=
name|labels
init|;
name|labelp
operator|!=
name|NIL
condition|;
name|labelp
operator|=
operator|(
name|int
operator|*
operator|)
name|labelp
index|[
literal|2
index|]
control|)
block|{
name|Label
operator|=
name|pNewNode
argument_list|(
name|LabelDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|LabelDNode
argument_list|)
argument_list|)
expr_stmt|;
name|Name
operator|=
name|sCopy
argument_list|(
name|labelp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|Label
argument_list|)
operator|.
name|LabelDName
operator|=
name|Name
expr_stmt|;
name|nllook
argument_list|(
name|labelp
index|[
literal|1
index|]
argument_list|)
operator|->
name|inTree
operator|=
name|Label
expr_stmt|;
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|Label
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
if|if
condition|(
name|After
operator|==
name|pNIL
condition|)
name|First
operator|=
name|List
expr_stmt|;
else|else
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
block|}
return|return
name|First
return|;
block|}
end_function

begin_comment
comment|/*      *	copy a constant declaration to a ConstDNode      */
end_comment

begin_function
name|pPointer
name|ConstDecl
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
modifier|*
name|decl
decl_stmt|;
block|{
name|pPointer
name|Const
init|=
name|pNewNode
argument_list|(
name|ConstDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ConstDNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|pPointer
name|ConstValue
init|=
name|tCopy
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|Const
argument_list|)
operator|.
name|ConstDName
operator|=
name|Name
expr_stmt|;
name|pDEF
argument_list|(
name|Const
argument_list|)
operator|.
name|ConstDValue
operator|=
name|ConstValue
expr_stmt|;
name|nllook
argument_list|(
name|id
argument_list|)
operator|->
name|inTree
operator|=
name|Const
expr_stmt|;
return|return
name|Const
return|;
block|}
end_function

begin_comment
comment|/*      *	copy a type declaration to a TypeDNode.      *	note that pointers' types are filled in later.      */
end_comment

begin_function
name|pPointer
name|TypeDecl
parameter_list|(
name|id
parameter_list|,
name|decl
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
modifier|*
name|decl
decl_stmt|;
block|{
name|pPointer
name|Type
init|=
name|pNewNode
argument_list|(
name|TypeDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|TypeDNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|pPointer
name|TypeType
init|=
name|tCopy
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|struct
name|nl
modifier|*
name|np
init|=
name|nllook
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|Type
argument_list|)
operator|.
name|TypeDName
operator|=
name|Name
expr_stmt|;
name|pDEF
argument_list|(
name|Type
argument_list|)
operator|.
name|TypeDType
operator|=
name|TypeType
expr_stmt|;
name|np
operator|->
name|inTree
operator|=
name|Type
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|type
operator|)
operator|->
name|class
operator|==
name|PTR
condition|)
block|{
operator|(
name|np
operator|->
name|type
operator|)
operator|->
name|inTree
operator|=
name|TypeType
expr_stmt|;
block|}
return|return
name|Type
return|;
block|}
end_function

begin_comment
comment|/*      *	copies a T_RFIELD node to a TypedNode      *	with a type and a list of FieldDNodes      *	rfield[0]	T_RFIELD      *	      [1]	lineof ":"      *	      [2]	id_list      *	      [3]	type      *	uses the extern inrecord to know which record its in.      */
end_comment

begin_function
name|pPointer
name|FieldCopy
parameter_list|(
name|rfield
parameter_list|)
name|int
modifier|*
name|rfield
decl_stmt|;
block|{
specifier|extern
name|struct
name|nl
modifier|*
name|inrecord
decl_stmt|;
name|pPointer
name|Typed
init|=
name|pNewNode
argument_list|(
name|TypedTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|TypedNode
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|idlp
decl_stmt|;
name|pPointer
name|Type
init|=
name|tCopy
argument_list|(
name|rfield
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedNames
operator|=
name|pNIL
expr_stmt|;
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedType
operator|=
name|Type
expr_stmt|;
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|idlp
operator|=
operator|(
name|int
operator|*
operator|)
name|rfield
index|[
literal|2
index|]
init|;
name|idlp
operator|!=
name|NIL
condition|;
name|idlp
operator|=
operator|(
name|int
operator|*
operator|)
name|idlp
index|[
literal|2
index|]
control|)
block|{
name|pPointer
name|FieldD
init|=
name|pNewNode
argument_list|(
name|FieldDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|FieldDNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
name|idlp
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|struct
name|nl
modifier|*
name|field
decl_stmt|;
if|if
condition|(
name|inrecord
operator|==
name|NIL
condition|)
name|panic
argument_list|(
literal|"FieldCopy:inrecord"
argument_list|)
expr_stmt|;
name|field
operator|=
name|reclook
argument_list|(
name|inrecord
argument_list|,
name|idlp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|NIL
condition|)
name|panic
argument_list|(
literal|"FieldCopy:reclook"
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|FieldD
argument_list|)
operator|.
name|FieldDName
operator|=
name|Name
expr_stmt|;
name|pDEF
argument_list|(
name|FieldD
argument_list|)
operator|.
name|FieldDType
operator|=
name|Type
expr_stmt|;
name|field
operator|->
name|inTree
operator|=
name|FieldD
expr_stmt|;
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|FieldD
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
if|if
condition|(
name|After
operator|==
name|pNIL
condition|)
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedNames
operator|=
name|List
expr_stmt|;
else|else
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
block|}
return|return
name|Typed
return|;
block|}
end_function

begin_comment
comment|/*      *	copies a T_VARPT node to a VarntNode and a FieldDNode      *	varpt	[0]	T_TYVARPT      *		[1]	lineof "case"      *		[2]	tag id (or nil)      *		[3]	tag type      *		[4]	list of variant cases      *	uses the extern inrecord to know which record its in.      */
end_comment

begin_function
name|pPointer
name|VarntCopy
parameter_list|(
name|tyvarpt
parameter_list|)
name|int
modifier|*
name|tyvarpt
decl_stmt|;
block|{
specifier|extern
name|struct
name|nl
modifier|*
name|inrecord
decl_stmt|;
name|pPointer
name|Varnt
init|=
name|pNewNode
argument_list|(
name|VarntTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|VarntNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Tag
init|=
name|pNewNode
argument_list|(
name|FieldDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|FieldDNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
name|tyvarpt
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|pPointer
name|Type
init|=
name|tCopy
argument_list|(
name|tyvarpt
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|pPointer
name|Cases
init|=
name|tCopy
argument_list|(
name|tyvarpt
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|Tag
argument_list|)
operator|.
name|FieldDName
operator|=
name|Name
expr_stmt|;
name|pDEF
argument_list|(
name|Tag
argument_list|)
operator|.
name|FieldDType
operator|=
name|Type
expr_stmt|;
if|if
condition|(
name|tyvarpt
index|[
literal|2
index|]
operator|!=
name|NIL
condition|)
name|reclook
argument_list|(
name|inrecord
argument_list|,
name|tyvarpt
index|[
literal|2
index|]
argument_list|)
operator|->
name|inTree
operator|=
name|Tag
expr_stmt|;
name|pDEF
argument_list|(
name|Varnt
argument_list|)
operator|.
name|VarntTag
operator|=
name|Tag
expr_stmt|;
name|pDEF
argument_list|(
name|Varnt
argument_list|)
operator|.
name|VarntCases
operator|=
name|Cases
expr_stmt|;
return|return
name|Varnt
return|;
block|}
end_function

begin_comment
comment|/*      *	copies a T_TYSCAL node to an EnumTNode and a list of ScalDNodes      *	tyscal	[0]	T_TYSCAL      *		[1]	lineof "("      *		[2]	id_list      */
end_comment

begin_function
name|pPointer
name|EnumTCopy
parameter_list|(
name|tyscal
parameter_list|)
name|int
modifier|*
name|tyscal
decl_stmt|;
block|{
name|pPointer
name|EnumT
init|=
name|pNewNode
argument_list|(
name|EnumTTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|EnumTNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|ScalD
decl_stmt|;
name|pPointer
name|Name
decl_stmt|;
name|int
modifier|*
name|idp
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|idp
operator|=
operator|(
name|int
operator|*
operator|)
name|tyscal
index|[
literal|2
index|]
init|;
name|idp
operator|!=
name|NIL
condition|;
name|idp
operator|=
operator|(
name|int
operator|*
operator|)
name|idp
index|[
literal|2
index|]
control|)
block|{
name|ScalD
operator|=
name|pNewNode
argument_list|(
name|ScalDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ScalDNode
argument_list|)
argument_list|)
expr_stmt|;
name|Name
operator|=
name|sCopy
argument_list|(
name|idp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|ScalD
argument_list|)
operator|.
name|ScalDName
operator|=
name|Name
expr_stmt|;
name|nllook
argument_list|(
name|idp
index|[
literal|1
index|]
argument_list|)
operator|->
name|inTree
operator|=
name|ScalD
expr_stmt|;
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|ScalD
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
if|if
condition|(
name|After
operator|==
name|pNIL
condition|)
name|pDEF
argument_list|(
name|EnumT
argument_list|)
operator|.
name|EnumTScalars
operator|=
name|List
expr_stmt|;
else|else
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
block|}
return|return
name|EnumT
return|;
block|}
end_function

begin_comment
comment|/*      *	copies a variable declaration to a TypedNode      *	with a type and a list of VarDNodes      *	also, deals with previously declared (e.g. program files) variables.      */
end_comment

begin_function
name|pPointer
name|VarDecl
parameter_list|(
name|idl
parameter_list|,
name|type
parameter_list|)
name|int
modifier|*
name|idl
decl_stmt|;
name|int
modifier|*
name|type
decl_stmt|;
block|{
name|pPointer
name|Typed
init|=
name|pNewNode
argument_list|(
name|TypedTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|TypedNode
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|idlp
decl_stmt|;
name|struct
name|nl
modifier|*
name|var
decl_stmt|;
name|pPointer
name|VarD
decl_stmt|;
name|pPointer
name|Name
decl_stmt|;
name|pPointer
name|Type
init|=
name|tCopy
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedNames
operator|=
name|pNIL
expr_stmt|;
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedType
operator|=
name|Type
expr_stmt|;
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|idlp
operator|=
operator|(
name|int
operator|*
operator|)
name|idl
init|;
name|idlp
operator|!=
name|NIL
condition|;
name|idlp
operator|=
operator|(
name|int
operator|*
operator|)
name|idlp
index|[
literal|2
index|]
control|)
block|{
if|if
condition|(
operator|(
name|var
operator|=
name|nllook
argument_list|(
name|idlp
index|[
literal|1
index|]
argument_list|)
operator|)
operator|->
name|inTree
operator|==
name|pNIL
condition|)
block|{
comment|/* 		     *	usual case, a new variable 		     */
name|VarD
operator|=
name|pNewNode
argument_list|(
name|VarDTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|VarDNode
argument_list|)
argument_list|)
expr_stmt|;
name|Name
operator|=
name|sCopy
argument_list|(
name|idlp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|VarD
argument_list|)
operator|.
name|VarDName
operator|=
name|Name
expr_stmt|;
name|var
operator|->
name|inTree
operator|=
name|VarD
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     *	previously declared (file) variable, already in tree 		     *	gets hung on list of variables, in addition 		     */
name|VarD
operator|=
name|var
operator|->
name|inTree
expr_stmt|;
block|}
name|pDEF
argument_list|(
name|VarD
argument_list|)
operator|.
name|VarDType
operator|=
name|Type
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|->
name|type
operator|)
operator|->
name|class
operator|==
name|PTR
condition|)
block|{
operator|(
name|var
operator|->
name|type
operator|)
operator|->
name|inTree
operator|=
name|Type
expr_stmt|;
block|}
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|VarD
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
if|if
condition|(
name|After
operator|==
name|pNIL
condition|)
name|pDEF
argument_list|(
name|Typed
argument_list|)
operator|.
name|TypedNames
operator|=
name|List
expr_stmt|;
else|else
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
block|}
return|return
name|Typed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      *	initialize the pTree      *	including cheapo versions of all the builtins (eech!)      */
end_comment

begin_macro
name|pTreeInit
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|in_consts
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|in_types
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|in_ctypes
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|in_vars
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|in_funcs
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|in_procs
index|[]
decl_stmt|;
name|union
name|pNodeBodies
modifier|*
name|Glob
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|nesting
operator|=
literal|0
expr_stmt|;
name|PorFHeader
index|[
name|nesting
index|]
operator|=
name|pNewNode
argument_list|(
name|GlobTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|GlobNode
argument_list|)
argument_list|)
expr_stmt|;
name|pWorld
operator|=
name|PorFHeader
index|[
name|nesting
index|]
expr_stmt|;
name|pSeize
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
expr_stmt|;
name|Glob
operator|=
operator|&
operator|(
name|pDEF
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
operator|)
expr_stmt|;
comment|/* 	     *	built in constants 	     */
name|dumpnl
argument_list|(
name|NIL
argument_list|,
literal|"pTreeInit"
argument_list|)
expr_stmt|;
name|List
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|in_consts
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|pPointer
name|BCon
init|=
name|pNewNode
argument_list|(
name|BConstTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BConstNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|BCon
argument_list|)
operator|.
name|BConstName
operator|=
name|Name
expr_stmt|;
name|List
operator|=
name|ListAppend
argument_list|(
name|List
argument_list|,
name|BCon
argument_list|)
expr_stmt|;
name|nllook
argument_list|(
operator|*
name|cp
argument_list|)
operator|->
name|inTree
operator|=
name|BCon
expr_stmt|;
block|}
name|Glob
operator|->
name|GlobConsts
operator|=
name|List
expr_stmt|;
comment|/* 	     *	built in simple and constructed types 	     */
name|List
operator|=
name|pNIL
expr_stmt|;
comment|/* 	     *	simple types 	     */
for|for
control|(
name|cp
operator|=
name|in_types
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|pPointer
name|BType
init|=
name|pNewNode
argument_list|(
name|BTypeTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BTypeNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|BType
argument_list|)
operator|.
name|BTypeName
operator|=
name|Name
expr_stmt|;
name|List
operator|=
name|ListAppend
argument_list|(
name|List
argument_list|,
name|BType
argument_list|)
expr_stmt|;
name|nllook
argument_list|(
operator|*
name|cp
argument_list|)
operator|->
name|inTree
operator|=
name|BType
expr_stmt|;
block|}
comment|/* 	     *	constructed types (aren't any more difficult) 	     */
for|for
control|(
name|cp
operator|=
name|in_ctypes
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|pPointer
name|BType
init|=
name|pNewNode
argument_list|(
name|BTypeTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BTypeNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|BType
argument_list|)
operator|.
name|BTypeName
operator|=
name|Name
expr_stmt|;
name|List
operator|=
name|ListAppend
argument_list|(
name|List
argument_list|,
name|BType
argument_list|)
expr_stmt|;
name|nllook
argument_list|(
operator|*
name|cp
argument_list|)
operator|->
name|inTree
operator|=
name|BType
expr_stmt|;
block|}
name|Glob
operator|->
name|GlobType
operator|=
name|List
expr_stmt|;
comment|/* 	     *	built in variables 	     */
name|List
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|in_vars
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|pPointer
name|BVar
init|=
name|pNewNode
argument_list|(
name|BVarTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BVarNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|BVar
argument_list|)
operator|.
name|BVarName
operator|=
name|Name
expr_stmt|;
name|List
operator|=
name|ListAppend
argument_list|(
name|List
argument_list|,
name|BVar
argument_list|)
expr_stmt|;
name|nllook
argument_list|(
operator|*
name|cp
argument_list|)
operator|->
name|inTree
operator|=
name|BVar
expr_stmt|;
block|}
name|Glob
operator|->
name|GlobVars
operator|=
name|List
expr_stmt|;
comment|/* 	     *	built in functions and procedures 	     */
name|List
operator|=
name|pNIL
expr_stmt|;
comment|/* 	     *	built in functions 	     */
for|for
control|(
name|cp
operator|=
name|in_funcs
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|pPointer
name|BFunc
init|=
name|pNewNode
argument_list|(
name|BFuncTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BFuncNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|BFunc
argument_list|)
operator|.
name|BFuncName
operator|=
name|Name
expr_stmt|;
name|List
operator|=
name|ListAppend
argument_list|(
name|List
argument_list|,
name|BFunc
argument_list|)
expr_stmt|;
name|nllook
argument_list|(
operator|*
name|cp
argument_list|)
operator|->
name|inTree
operator|=
name|BFunc
expr_stmt|;
block|}
comment|/* 	     *	built in procedures 	     */
for|for
control|(
name|cp
operator|=
name|in_procs
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|pPointer
name|BProc
init|=
name|pNewNode
argument_list|(
name|BProcTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BProcNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|Name
init|=
name|sCopy
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|BProc
argument_list|)
operator|.
name|BProcName
operator|=
name|Name
expr_stmt|;
name|List
operator|=
name|ListAppend
argument_list|(
name|List
argument_list|,
name|BProc
argument_list|)
expr_stmt|;
name|nllook
argument_list|(
operator|*
name|cp
argument_list|)
operator|->
name|inTree
operator|=
name|BProc
expr_stmt|;
block|}
name|Glob
operator|->
name|GlobPFs
operator|=
name|List
expr_stmt|;
name|pRelease
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	find a symbol in the      *	block structure symbol      *	table and returns a pointer to      *	its namelist entry.      *	[this is a copy of lookup, except it calls nllook1      *	whose only variation from lookup1 is that it doesn't set NUSED]      */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|nllook
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|udinfo
modifier|*
name|udp
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NIL
condition|)
block|{
name|nocascade
argument_list|()
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|p
operator|=
name|nllook1
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
block|{
name|derror
argument_list|(
literal|"%s is undefined"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|FVAR
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|chain
expr_stmt|;
name|bn
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * an internal nllook.  * It is not an error to call nllook1 if the symbol is not defined.  * Also nllook1 will return FVARs while nllook never will.  * [this is a copy of lookup1, except that it doesn't set NUSED]  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|nllook1
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|PI0
specifier|register
name|struct
name|nl
modifier|*
name|q
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|bn
operator|=
name|cbn
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
comment|/* 	 * We first check the field names 	 * of the currently active with 	 * statements (expensive since they 	 * are not hashed). 	 */
for|for
control|(
name|p
operator|=
name|withlist
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|nl_next
control|)
block|{
name|q
operator|=
name|p
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NIL
condition|)
continue|continue;
if|if
condition|(
name|reclook
argument_list|(
name|q
argument_list|,
name|s
argument_list|)
operator|!=
name|NIL
condition|)
comment|/* 			 * Return the WITHPTR, lvalue understands. 			 */
return|return
operator|(
name|p
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Symbol table is a 64 way hash 	 * on the low bits of the character 	 * pointer value. (Simple, but effective) 	 */
name|i
operator|=
operator|(
name|int
operator|)
name|s
operator|&
literal|077
expr_stmt|;
for|for
control|(
name|p
operator|=
name|disptab
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|nl_next
control|)
if|if
condition|(
name|p
operator|->
name|symbol
operator|==
name|s
operator|&&
name|p
operator|->
name|class
operator|!=
name|FIELD
operator|&&
name|p
operator|->
name|class
operator|!=
name|BADUSE
condition|)
block|{
name|bn
operator|=
operator|(
name|p
operator|->
name|nl_block
operator|&
literal|037
operator|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|PTREE
end_endif

end_unit

