begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-usbnx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon usbnx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_USBNX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_USBNX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_BIST_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_BIST_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800680007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_BIST_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800680007F8ull) + ((block_id)& 1) * 0x10000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_CLK_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_CLK_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180068000010ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_CLK_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180068000010ull) + ((block_id)& 1) * 0x10000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_CTL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_CTL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000800ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_CTL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000800ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000818ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000818ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000820ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000820ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000828ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000828ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000830ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000830ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN4
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN4(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000838ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN4
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000838ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN5
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN5(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000840ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN5
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000840ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN6
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN6(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000848ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN6
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000848ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_INB_CHN7
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_INB_CHN7(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000850ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_INB_CHN7
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000850ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000858ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000858ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000860ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000860ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000868ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000868ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000870ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000870ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN4
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN4(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000878ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN4
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000878ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN5
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN5(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000880ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN5
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000880ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN6
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN6(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000888ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN6
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000888ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA0_OUTB_CHN7
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA0_OUTB_CHN7(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000890ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA0_OUTB_CHN7
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000890ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_DMA_TEST
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_DMA_TEST(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0000000808ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_DMA_TEST
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0000000808ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_INT_ENB
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_INT_ENB(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180068000008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_INT_ENB
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((block_id)& 1) * 0x10000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_INT_SUM
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_INT_SUM(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180068000000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_INT_SUM
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((block_id)& 1) * 0x10000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBNX_USBP_CTL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBNX_USBP_CTL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180068000018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBNX_USBP_CTL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180068000018ull) + ((block_id)& 1) * 0x10000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_usbn#_bist_status  *  * USBN_BIST_STATUS = USBN's Control and Status  *  * Contain general control bits and status information for the USBN.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_bist_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|u2nc_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status U2N CTL FIFO Memory. */
name|uint64_t
name|u2nf_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status U2N FIFO Memory. */
name|uint64_t
name|e2hc_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status E2H CTL FIFO Memory. */
name|uint64_t
name|n2uf_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status N2U  FIFO Memory. */
name|uint64_t
name|usbc_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status USBC FIFO Memory. */
name|uint64_t
name|nif_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status for Inbound Memory. */
name|uint64_t
name|nof_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status for Outbound Memory. */
else|#
directive|else
name|uint64_t
name|nof_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nif_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbc_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2uf_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2hc_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2nf_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2nc_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_usbnx_bist_status_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|usbc_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status USBC FIFO Memory. */
name|uint64_t
name|nif_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status for Inbound Memory. */
name|uint64_t
name|nof_bis
range|:
literal|1
decl_stmt|;
comment|/**< Bist status for Outbound Memory. */
else|#
directive|else
name|uint64_t
name|nof_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nif_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbc_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_usbnx_bist_status_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_bist_status_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_bist_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_bist_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_bist_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_bist_status_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_bist_status
name|cvmx_usbnx_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_clk_ctl  *  * USBN_CLK_CTL = USBN's Clock Control  *  * This register is used to control the frequency of the hclk and the hreset and phy_rst signals.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_clk_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_clk_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|divide2
range|:
literal|2
decl_stmt|;
comment|/**< The 'hclk' used by the USB subsystem is derived                                                          from the eclk.                                                          Also see the field DIVIDE. DIVIDE2<1> must currently                                                          be zero because it is not implemented, so the maximum                                                          ratio of eclk/hclk is currently 16.                                                          The actual divide number for hclk is:                                                          (DIVIDE2 + 1) * (DIVIDE + 1) */
name|uint64_t
name|hclk_rst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the HCLK-DIVIDER used to                                                          generate the hclk in the USB Subsystem is held                                                          in reset. This bit must be set to '0' before                                                          changing the value os DIVIDE in this register.                                                          The reset to the HCLK_DIVIDERis also asserted                                                          when core reset is asserted. */
name|uint64_t
name|p_x_on
range|:
literal|1
decl_stmt|;
comment|/**< Force USB-PHY on during suspend.                                                          '1' USB-PHY XO block is powered-down during                                                              suspend.                                                          '0' USB-PHY XO block is powered-up during                                                              suspend.                                                          The value of this field must be set while POR is                                                          active. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
comment|/**< '0' Force USB-PHY XO Bias, Bandgap and PLL to                                                              remain powered in Suspend Mode.                                                          '1' The USB-PHY XO Bias, Bandgap and PLL are                                                              powered down in suspend mode.                                                          The value of this field must be set while POR is                                                          active. */
name|uint64_t
name|p_c_sel
range|:
literal|2
decl_stmt|;
comment|/**< Phy clock speed select.                                                          Selects the reference clock / crystal frequency.                                                          '11': Reserved                                                          '10': 48 MHz (reserved when a crystal is used)                                                          '01': 24 MHz (reserved when a crystal is used)                                                          '00': 12 MHz                                                          The value of this field must be set while POR is                                                          active.                                                          NOTE: if a crystal is used as a reference clock,                                                          this field must be set to 12 MHz. */
name|uint64_t
name|cdiv_byp
range|:
literal|1
decl_stmt|;
comment|/**< Used to enable the bypass input to the USB_CLK_DIV. */
name|uint64_t
name|sd_mode
range|:
literal|2
decl_stmt|;
comment|/**< Scaledown mode for the USBC. Control timing events                                                          in the USBC, for normal operation this must be '0'. */
name|uint64_t
name|s_bist
range|:
literal|1
decl_stmt|;
comment|/**< Starts bist on the hclk memories, during the '0'                                                          to '1' transition. */
name|uint64_t
name|por
range|:
literal|1
decl_stmt|;
comment|/**< Power On Reset for the PHY.                                                          Resets all the PHYS registers and state machines. */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< When '1' allows the generation of the hclk. When                                                          '0' the hclk will not be generated. SEE DIVIDE                                                          field of this register. */
name|uint64_t
name|prst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the reset associated with                                                          the phy_clk functionality in the USB Subsystem is                                                          help in reset. This bit should not be set to '1'                                                          until the time it takes 6 clocks (hclk or phy_clk,                                                          whichever is slower) has passed. Under normal                                                          operation once this bit is set to '1' it should not                                                          be set to '0'. */
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the reset associated with                                                          the hclk functioanlity in the USB Subsystem is                                                          held in reset.This bit should not be set to '1'                                                          until 12ms after phy_clk is stable. Under normal                                                          operation, once this bit is set to '1' it should                                                          not be set to '0'. */
name|uint64_t
name|divide
range|:
literal|3
decl_stmt|;
comment|/**< The frequency of 'hclk' used by the USB subsystem                                                          is the eclk frequency divided by the value of                                                          (DIVIDE2 + 1) * (DIVIDE + 1), also see the field                                                          DIVIDE2 of this register.                                                          The hclk frequency should be less than 125Mhz.                                                          After writing a value to this field the SW should                                                          read the field for the value written.                                                          The ENABLE field of this register should not be set                                                          until AFTER this field is set and then read. */
else|#
directive|else
name|uint64_t
name|divide
range|:
literal|3
decl_stmt|;
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|por
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sd_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cdiv_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_c_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p_x_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hclk_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|divide2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_usbnx_clk_ctl_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|hclk_rst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the HCLK-DIVIDER used to                                                          generate the hclk in the USB Subsystem is held                                                          in reset. This bit must be set to '0' before                                                          changing the value os DIVIDE in this register.                                                          The reset to the HCLK_DIVIDERis also asserted                                                          when core reset is asserted. */
name|uint64_t
name|p_x_on
range|:
literal|1
decl_stmt|;
comment|/**< Force USB-PHY on during suspend.                                                          '1' USB-PHY XO block is powered-down during                                                              suspend.                                                          '0' USB-PHY XO block is powered-up during                                                              suspend.                                                          The value of this field must be set while POR is                                                          active. */
name|uint64_t
name|p_rclk
range|:
literal|1
decl_stmt|;
comment|/**< Phy refrence clock enable.                                                          '1' The PHY PLL uses the XO block output as a                                                          reference.                                                          '0' Reserved. */
name|uint64_t
name|p_xenbn
range|:
literal|1
decl_stmt|;
comment|/**< Phy external clock enable.                                                          '1' The XO block uses the clock from a crystal.                                                          '0' The XO block uses an external clock supplied                                                              on the XO pin. USB_XI should be tied to                                                              ground for this usage. */
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
comment|/**< '0' Force USB-PHY XO Bias, Bandgap and PLL to                                                              remain powered in Suspend Mode.                                                          '1' The USB-PHY XO Bias, Bandgap and PLL are                                                              powered down in suspend mode.                                                          The value of this field must be set while POR is                                                          active. */
name|uint64_t
name|p_c_sel
range|:
literal|2
decl_stmt|;
comment|/**< Phy clock speed select.                                                          Selects the reference clock / crystal frequency.                                                          '11': Reserved                                                          '10': 48 MHz                                                          '01': 24 MHz                                                          '00': 12 MHz                                                          The value of this field must be set while POR is                                                          active. */
name|uint64_t
name|cdiv_byp
range|:
literal|1
decl_stmt|;
comment|/**< Used to enable the bypass input to the USB_CLK_DIV. */
name|uint64_t
name|sd_mode
range|:
literal|2
decl_stmt|;
comment|/**< Scaledown mode for the USBC. Control timing events                                                          in the USBC, for normal operation this must be '0'. */
name|uint64_t
name|s_bist
range|:
literal|1
decl_stmt|;
comment|/**< Starts bist on the hclk memories, during the '0'                                                          to '1' transition. */
name|uint64_t
name|por
range|:
literal|1
decl_stmt|;
comment|/**< Power On Reset for the PHY.                                                          Resets all the PHYS registers and state machines. */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< When '1' allows the generation of the hclk. When                                                          '0' the hclk will not be generated. */
name|uint64_t
name|prst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the reset associated with                                                          the phy_clk functionality in the USB Subsystem is                                                          help in reset. This bit should not be set to '1'                                                          until the time it takes 6 clocks (hclk or phy_clk,                                                          whichever is slower) has passed. Under normal                                                          operation once this bit is set to '1' it should not                                                          be set to '0'. */
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the reset associated with                                                          the hclk functioanlity in the USB Subsystem is                                                          held in reset.This bit should not be set to '1'                                                          until 12ms after phy_clk is stable. Under normal                                                          operation, once this bit is set to '1' it should                                                          not be set to '0'. */
name|uint64_t
name|divide
range|:
literal|3
decl_stmt|;
comment|/**< The 'hclk' used by the USB subsystem is derived                                                          from the eclk. The eclk will be divided by the                                                          value of this field +1 to determine the hclk                                                          frequency. (Also see HRST of this register).                                                          The hclk frequency must be less than 125 MHz. */
else|#
directive|else
name|uint64_t
name|divide
range|:
literal|3
decl_stmt|;
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|por
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sd_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cdiv_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_c_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_xenbn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_rclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_x_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hclk_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_usbnx_clk_ctl_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_usbnx_clk_ctl_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|divide2
range|:
literal|2
decl_stmt|;
comment|/**< The 'hclk' used by the USB subsystem is derived                                                          from the eclk.                                                          Also see the field DIVIDE. DIVIDE2<1> must currently                                                          be zero because it is not implemented, so the maximum                                                          ratio of eclk/hclk is currently 16.                                                          The actual divide number for hclk is:                                                          (DIVIDE2 + 1) * (DIVIDE + 1) */
name|uint64_t
name|hclk_rst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the HCLK-DIVIDER used to                                                          generate the hclk in the USB Subsystem is held                                                          in reset. This bit must be set to '0' before                                                          changing the value os DIVIDE in this register.                                                          The reset to the HCLK_DIVIDERis also asserted                                                          when core reset is asserted. */
name|uint64_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_rtype
range|:
literal|2
decl_stmt|;
comment|/**< PHY reference clock type                                                          '0' The USB-PHY uses a 12MHz crystal as a clock                                                              source at the USB_XO and USB_XI pins                                                          '1' Reserved                                                          '2' The USB_PHY uses 12/24/48MHz 2.5V board clock                                                              at the USB_XO pin. USB_XI should be tied to                                                              ground in this case.                                                          '3' Reserved                                                          (bit 14 was P_XENBN on 3xxx)                                                          (bit 15 was P_RCLK on 3xxx) */
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
comment|/**< '0' Force USB-PHY XO Bias, Bandgap and PLL to                                                              remain powered in Suspend Mode.                                                          '1' The USB-PHY XO Bias, Bandgap and PLL are                                                              powered down in suspend mode.                                                          The value of this field must be set while POR is                                                          active. */
name|uint64_t
name|p_c_sel
range|:
literal|2
decl_stmt|;
comment|/**< Phy clock speed select.                                                          Selects the reference clock / crystal frequency.                                                          '11': Reserved                                                          '10': 48 MHz (reserved when a crystal is used)                                                          '01': 24 MHz (reserved when a crystal is used)                                                          '00': 12 MHz                                                          The value of this field must be set while POR is                                                          active.                                                          NOTE: if a crystal is used as a reference clock,                                                          this field must be set to 12 MHz. */
name|uint64_t
name|cdiv_byp
range|:
literal|1
decl_stmt|;
comment|/**< Used to enable the bypass input to the USB_CLK_DIV. */
name|uint64_t
name|sd_mode
range|:
literal|2
decl_stmt|;
comment|/**< Scaledown mode for the USBC. Control timing events                                                          in the USBC, for normal operation this must be '0'. */
name|uint64_t
name|s_bist
range|:
literal|1
decl_stmt|;
comment|/**< Starts bist on the hclk memories, during the '0'                                                          to '1' transition. */
name|uint64_t
name|por
range|:
literal|1
decl_stmt|;
comment|/**< Power On Reset for the PHY.                                                          Resets all the PHYS registers and state machines. */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< When '1' allows the generation of the hclk. When                                                          '0' the hclk will not be generated. SEE DIVIDE                                                          field of this register. */
name|uint64_t
name|prst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the reset associated with                                                          the phy_clk functionality in the USB Subsystem is                                                          help in reset. This bit should not be set to '1'                                                          until the time it takes 6 clocks (hclk or phy_clk,                                                          whichever is slower) has passed. Under normal                                                          operation once this bit is set to '1' it should not                                                          be set to '0'. */
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
comment|/**< When this field is '0' the reset associated with                                                          the hclk functioanlity in the USB Subsystem is                                                          held in reset.This bit should not be set to '1'                                                          until 12ms after phy_clk is stable. Under normal                                                          operation, once this bit is set to '1' it should                                                          not be set to '0'. */
name|uint64_t
name|divide
range|:
literal|3
decl_stmt|;
comment|/**< The frequency of 'hclk' used by the USB subsystem                                                          is the eclk frequency divided by the value of                                                          (DIVIDE2 + 1) * (DIVIDE + 1), also see the field                                                          DIVIDE2 of this register.                                                          The hclk frequency should be less than 125Mhz.                                                          After writing a value to this field the SW should                                                          read the field for the value written.                                                          The ENABLE field of this register should not be set                                                          until AFTER this field is set and then read. */
else|#
directive|else
name|uint64_t
name|divide
range|:
literal|3
decl_stmt|;
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|por
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sd_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cdiv_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_c_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_rtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hclk_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|divide2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_usbnx_clk_ctl_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_clk_ctl_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_clk_ctl_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_clk_ctl_cn50xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_clk_ctl
name|cvmx_usbnx_clk_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_ctl_status  *  * USBN_CTL_STATUS = USBN's Control And Status Register  *  * Contains general control and status information for the USBN block.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|dma_0pag
range|:
literal|1
decl_stmt|;
comment|/**< When '1' sets the DMA engine will set the zero-Page                                                          bit in the L2C store operation to the IOB. */
name|uint64_t
name|dma_stt
range|:
literal|1
decl_stmt|;
comment|/**< When '1' sets the DMA engine to use STT operations. */
name|uint64_t
name|dma_test
range|:
literal|1
decl_stmt|;
comment|/**< When '1' sets the DMA engine into Test-Mode.                                                          For normal operation this bit should be '0'. */
name|uint64_t
name|inv_a2
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the address[2] driven on the AHB                                                          for USB-CORE FIFO access to be inverted. Also data                                                          writen to and read from the AHB will have it byte                                                          order swapped. If the orginal order was A-B-C-D the                                                          new byte order will be D-C-B-A. */
name|uint64_t
name|l2c_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for data from/to the L2C.                                                          IN:   A-B-C-D-E-F-G-H                                                          OUT0: A-B-C-D-E-F-G-H                                                          OUT1: H-G-F-E-D-C-B-A                                                          OUT2: D-C-B-A-H-G-F-E                                                          OUT3: E-F-G-H-A-B-C-D */
else|#
directive|else
name|uint64_t
name|l2c_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inv_a2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_test
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_stt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_0pag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_ctl_status_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_ctl_status
name|cvmx_usbnx_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn0  *  * USBN_DMA0_INB_CHN0 = USBN's Inbound DMA for USB0 Channel0  *  * Contains the starting address for use when USB0 writes to L2C via Channel0.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn0
name|cvmx_usbnx_dma0_inb_chn0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn1  *  * USBN_DMA0_INB_CHN1 = USBN's Inbound DMA for USB0 Channel1  *  * Contains the starting address for use when USB0 writes to L2C via Channel1.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn1
name|cvmx_usbnx_dma0_inb_chn1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn2  *  * USBN_DMA0_INB_CHN2 = USBN's Inbound DMA for USB0 Channel2  *  * Contains the starting address for use when USB0 writes to L2C via Channel2.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn2
name|cvmx_usbnx_dma0_inb_chn2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn3  *  * USBN_DMA0_INB_CHN3 = USBN's Inbound DMA for USB0 Channel3  *  * Contains the starting address for use when USB0 writes to L2C via Channel3.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn3
name|cvmx_usbnx_dma0_inb_chn3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn4  *  * USBN_DMA0_INB_CHN4 = USBN's Inbound DMA for USB0 Channel4  *  * Contains the starting address for use when USB0 writes to L2C via Channel4.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn4_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn4_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn4
name|cvmx_usbnx_dma0_inb_chn4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn5  *  * USBN_DMA0_INB_CHN5 = USBN's Inbound DMA for USB0 Channel5  *  * Contains the starting address for use when USB0 writes to L2C via Channel5.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn5_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn5_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn5
name|cvmx_usbnx_dma0_inb_chn5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn6  *  * USBN_DMA0_INB_CHN6 = USBN's Inbound DMA for USB0 Channel6  *  * Contains the starting address for use when USB0 writes to L2C via Channel6.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn6_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn6_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn6
name|cvmx_usbnx_dma0_inb_chn6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_inb_chn7  *  * USBN_DMA0_INB_CHN7 = USBN's Inbound DMA for USB0 Channel7  *  * Contains the starting address for use when USB0 writes to L2C via Channel7.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_inb_chn7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_inb_chn7_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Write to L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_inb_chn7_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_inb_chn7
name|cvmx_usbnx_dma0_inb_chn7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn0  *  * USBN_DMA0_OUTB_CHN0 = USBN's Outbound DMA for USB0 Channel0  *  * Contains the starting address for use when USB0 reads from L2C via Channel0.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn0
name|cvmx_usbnx_dma0_outb_chn0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn1  *  * USBN_DMA0_OUTB_CHN1 = USBN's Outbound DMA for USB0 Channel1  *  * Contains the starting address for use when USB0 reads from L2C via Channel1.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn1
name|cvmx_usbnx_dma0_outb_chn1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn2  *  * USBN_DMA0_OUTB_CHN2 = USBN's Outbound DMA for USB0 Channel2  *  * Contains the starting address for use when USB0 reads from L2C via Channel2.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn2
name|cvmx_usbnx_dma0_outb_chn2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn3  *  * USBN_DMA0_OUTB_CHN3 = USBN's Outbound DMA for USB0 Channel3  *  * Contains the starting address for use when USB0 reads from L2C via Channel3.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn3
name|cvmx_usbnx_dma0_outb_chn3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn4  *  * USBN_DMA0_OUTB_CHN4 = USBN's Outbound DMA for USB0 Channel4  *  * Contains the starting address for use when USB0 reads from L2C via Channel4.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn4_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn4_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn4
name|cvmx_usbnx_dma0_outb_chn4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn5  *  * USBN_DMA0_OUTB_CHN5 = USBN's Outbound DMA for USB0 Channel5  *  * Contains the starting address for use when USB0 reads from L2C via Channel5.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn5_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn5_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn5
name|cvmx_usbnx_dma0_outb_chn5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn6  *  * USBN_DMA0_OUTB_CHN6 = USBN's Outbound DMA for USB0 Channel6  *  * Contains the starting address for use when USB0 reads from L2C via Channel6.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn6_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn6_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn6
name|cvmx_usbnx_dma0_outb_chn6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma0_outb_chn7  *  * USBN_DMA0_OUTB_CHN7 = USBN's Outbound DMA for USB0 Channel7  *  * Contains the starting address for use when USB0 reads from L2C via Channel7.  * Writing of this register sets the base address.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma0_outb_chn7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma0_outb_chn7_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Base address for DMA Read from L2C. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma0_outb_chn7_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma0_outb_chn7
name|cvmx_usbnx_dma0_outb_chn7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_dma_test  *  * USBN_DMA_TEST = USBN's DMA TestRegister  *  * This register can cause the external DMA engine to the USB-Core to make transfers from/to L2C/USB-FIFOs  */
end_comment

begin_union
union|union
name|cvmx_usbnx_dma_test
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_dma_test_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
comment|/**< This field is set when a DMA completes. Writing a                                                          '1' to this field clears this bit. */
name|uint64_t
name|req
range|:
literal|1
decl_stmt|;
comment|/**< DMA Request. Writing a 1 to this register                                                          will cause a DMA request as specified in the other                                                          fields of this register to take place. This field                                                          will always read as '0'. */
name|uint64_t
name|f_addr
range|:
literal|18
decl_stmt|;
comment|/**< The address to read from in the Data-Fifo. */
name|uint64_t
name|count
range|:
literal|11
decl_stmt|;
comment|/**< DMA Request Count. */
name|uint64_t
name|channel
range|:
literal|5
decl_stmt|;
comment|/**< DMA Channel/Enpoint. */
name|uint64_t
name|burst
range|:
literal|4
decl_stmt|;
comment|/**< DMA Burst Size. */
else|#
directive|else
name|uint64_t
name|burst
range|:
literal|4
decl_stmt|;
name|uint64_t
name|channel
range|:
literal|5
decl_stmt|;
name|uint64_t
name|count
range|:
literal|11
decl_stmt|;
name|uint64_t
name|f_addr
range|:
literal|18
decl_stmt|;
name|uint64_t
name|req
range|:
literal|1
decl_stmt|;
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_dma_test_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_dma_test
name|cvmx_usbnx_dma_test_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_int_enb  *  * USBN_INT_ENB = USBN's Interrupt Enable  *  * The USBN's interrupt enable register.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_int_enb_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 37 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 36 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 35 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 34 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 33 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 32 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|u2n_c_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 31 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|u2n_c_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 30 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|u2n_d_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 29 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|u2n_d_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 28 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|n2u_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 27 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|n2u_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 26 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2u_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2u_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_d_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_d_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_c_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_c_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_int_enb_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_int_enb_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_usbnx_int_enb_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 37 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 36 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 35 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 34 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 33 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 32 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the USBN_INT_SUM                                                          register is asserted the USBN will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_usbnx_int_enb_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_int_enb_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_int_enb_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_int_enb_cn50xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_int_enb
name|cvmx_usbnx_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_int_sum  *  * USBN_INT_SUM = USBN's Interrupt Summary Register  *  * Contains the diffrent interrupt summary bits of the USBN.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_int_sum_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Data Fifo Push Full. */
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Data Fifo Pop Empty. */
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Request Fifo Push Full. */
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Request Fifo Pop Empty. */
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
comment|/**< L2C Transfer Length Fifo Push Full. */
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
comment|/**< L2C Transfer Length Fifo Pop Empty. */
name|uint64_t
name|u2n_c_pe
range|:
literal|1
decl_stmt|;
comment|/**< U2N Control Fifo Pop Empty. */
name|uint64_t
name|u2n_c_pf
range|:
literal|1
decl_stmt|;
comment|/**< U2N Control Fifo Push Full. */
name|uint64_t
name|u2n_d_pf
range|:
literal|1
decl_stmt|;
comment|/**< U2N Data Fifo Push Full. */
name|uint64_t
name|u2n_d_pe
range|:
literal|1
decl_stmt|;
comment|/**< U2N Data Fifo Pop Empty. */
name|uint64_t
name|n2u_pe
range|:
literal|1
decl_stmt|;
comment|/**< N2U Fifo Pop Empty. */
name|uint64_t
name|n2u_pf
range|:
literal|1
decl_stmt|;
comment|/**< N2U Fifo Push Full. */
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
comment|/**< UOD Fifo Push Full. */
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
comment|/**< UOD Fifo Pop Empty. */
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-3 Fifo Pushed When Full. */
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-3 Fifo Pushed When Full. */
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-2 Fifo Pushed When Full. */
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-2 Fifo Pushed When Full. */
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< Register Request Fifo Pushed When Full. */
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< Register Request Fifo Pushed When Full. */
name|uint64_t
name|lt_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Pushed When Full. */
name|uint64_t
name|lt_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Pushed When Full. */
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Credit Count Added When Full. */
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Credit Count Subtracted When Empty. */
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
comment|/**< Data CreditFifo Pushed When Full. */
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
comment|/**< Data Credit Fifo Pushed When Full. */
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Trasaction Fifo Pushed When Full. */
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Trasaction Fifo Popped When Full. */
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< NPI Trasaction Fifo Pushed When Full. */
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< NPI Trasaction Fifo Popped When Full. */
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< PP  Trasaction Fifo Pushed When Full. */
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< PP  Trasaction Fifo Popped When Full. */
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Pushed When Full. */
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Popped When Empty. */
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< NPI Request Fifo Pushed When Full. */
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< NPI Request Fifo Popped When Empty. */
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< PP  Request Fifo Pushed When Full. */
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< PP  Request Fifo Popped When Empty. */
else|#
directive|else
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2u_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2u_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_d_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_d_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_c_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|u2n_c_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbnx_int_sum_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbnx_int_sum_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_usbnx_int_sum_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Data Fifo Push Full. */
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Data Fifo Pop Empty. */
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Request Fifo Push Full. */
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
comment|/**< NCB DMA Out Request Fifo Pop Empty. */
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
comment|/**< L2C Transfer Length Fifo Push Full. */
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
comment|/**< L2C Transfer Length Fifo Pop Empty. */
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
comment|/**< UOD Fifo Push Full. */
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
comment|/**< UOD Fifo Pop Empty. */
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-3 Fifo Pushed When Full. */
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-3 Fifo Pushed When Full. */
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-2 Fifo Pushed When Full. */
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
comment|/**< Request Queue-2 Fifo Pushed When Full. */
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< Register Request Fifo Pushed When Full. */
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< Register Request Fifo Pushed When Full. */
name|uint64_t
name|lt_fi_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Pushed When Full. */
name|uint64_t
name|lt_fi_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Pushed When Full. */
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Credit Count Added When Full. */
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Credit Count Subtracted When Empty. */
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
comment|/**< Data CreditFifo Pushed When Full. */
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
comment|/**< Data Credit Fifo Pushed When Full. */
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Trasaction Fifo Pushed When Full. */
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Trasaction Fifo Popped When Full. */
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< NPI Trasaction Fifo Pushed When Full. */
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< NPI Trasaction Fifo Popped When Full. */
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< PP  Trasaction Fifo Pushed When Full. */
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
comment|/**< PP  Trasaction Fifo Popped When Full. */
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Pushed When Full. */
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< L2C Request Fifo Popped When Empty. */
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< NPI Request Fifo Pushed When Full. */
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< NPI Request Fifo Popped When Empty. */
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
comment|/**< PP  Request Fifo Pushed When Full. */
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
comment|/**< PP  Request Fifo Popped When Empty. */
else|#
directive|else
name|uint64_t
name|pr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lr_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_po_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_pu_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcred_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lt_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rg_fi_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q2_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rq_q3_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uod_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ltl_f_pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ltl_f_pf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_rpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nd4o_dpf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_usbnx_int_sum_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbnx_int_sum_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_int_sum_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_int_sum_cn50xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_int_sum
name|cvmx_usbnx_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbn#_usbp_ctl_status  *  * USBN_USBP_CTL_STATUS = USBP Control And Status Register  *  * Contains general control and status information for the USBN block.  */
end_comment

begin_union
union|union
name|cvmx_usbnx_usbp_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_usbnx_usbp_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Rise/Fall Time Adjustment */
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
comment|/**< HS DC Voltage Level Adjustment */
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
comment|/**< FS/LS Source Impedence Adjustment */
name|uint64_t
name|txhsxvtune
range|:
literal|2
decl_stmt|;
comment|/**< Transmitter High-Speed Crossover Adjustment */
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
comment|/**< Squelch Threshold Adjustment */
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
comment|/**< Disconnect Threshold Adjustment */
name|uint64_t
name|otgtune
range|:
literal|3
decl_stmt|;
comment|/**< VBUS Valid Threshold Adjustment */
name|uint64_t
name|otgdisable
range|:
literal|1
decl_stmt|;
comment|/**< OTG Block Disable */
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
comment|/**< Per_Port Reset */
name|uint64_t
name|drvvbus
range|:
literal|1
decl_stmt|;
comment|/**< Drive VBUS */
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
comment|/**< Low-Speed BIST Enable. */
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
comment|/**< Full-Speed BIST Enable. */
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
comment|/**< High-Speed BIST Enable. */
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Done.                                                          Asserted at the end of the PHY BIST sequence. */
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Error.                                                          Indicates an internal error was detected during                                                          the BIST sequence. */
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
comment|/**< PHY Test Data Out.                                                          Presents either internaly generated signals or                                                          test register contents, based upon the value of                                                          test_data_out_sel. */
name|uint64_t
name|siddq
range|:
literal|1
decl_stmt|;
comment|/**< Drives the USBP (USB-PHY) SIDDQ input.                                                          Normally should be set to zero.                                                          When customers have no intent to use USB PHY                                                          interface, they should:                                                            - still provide 3.3V to USB_VDD33, and                                                            - tie USB_REXT to 3.3V supply, and                                                            - set USBN*_USBP_CTL_STATUS[SIDDQ]=1 */
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Pre-Emphasis Enable */
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1 the L2C DMA address will be updated                                                          with byte-counts between packets. When set to 0                                                          the L2C DMA address is incremented to the next                                                          4-byte aligned address after adding byte-count. */
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
comment|/**< Bigendian input to the USB Core. This should be                                                          set to '0' for operation. */
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
comment|/**< PHY, This is cleared '0' to run BIST on the USBP. */
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
comment|/**< PHY Test Clock, used to load TDATA_IN to the USBP. */
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DP_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D+ line. '1' pull down-resistance is connected                                                          to D+/ '0' pull down resistance is not connected                                                          to D+. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DM_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D- line. '1' pull down-resistance is connected                                                          to D-. '0' pull down resistance is not connected                                                          to D-. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
comment|/**< When '0' the USB is acting as HOST, when '1'                                                          USB is acting as device. This field needs to be                                                          set while the USB is in reset. */
name|uint64_t
name|tuning
range|:
literal|4
decl_stmt|;
comment|/**< Transmitter Tuning for High-Speed Operation.                                                          Tunes the current supply and rise/fall output                                                          times for high-speed operation.                                                          [20:19] == 11: Current supply increased                                                          approximately 9%                                                          [20:19] == 10: Current supply increased                                                          approximately 4.5%                                                          [20:19] == 01: Design default.                                                          [20:19] == 00: Current supply decreased                                                          approximately 4.5%                                                          [22:21] == 11: Rise and fall times are increased.                                                          [22:21] == 10: Design default.                                                          [22:21] == 01: Rise and fall times are decreased.                                                          [22:21] == 00: Rise and fall times are decreased                                                          further as compared to the 01 setting. */
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [15:8].                                                          Enables or disables bit stuffing on data[15:8]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [7:0].                                                          Enables or disables bit stuffing on data[7:0]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
comment|/**< PHY Loopback Test Enable.                                                          '1': During data transmission the receive is                                                          enabled.                                                          '0': During data transmission the receive is                                                          disabled.                                                          Must be '0' for normal operation. */
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
comment|/**< Analog Test Pin Enable.                                                          '1' The PHY's analog_test pin is enabled for the                                                          input and output of applicable analog test signals.                                                          '0' THe analog_test pin is disabled. */
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
comment|/**< Built-In Self Test Enable.                                                          Used to activate BIST in the PHY. */
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
comment|/**< Test Data Out Select.                                                          '1' test_data_out[3:0] (PHY) register contents                                                          are output. '0' internaly generated signals are                                                          output. */
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
comment|/**< Mode Address for Test Interface.                                                          Specifies the register address for writing to or                                                          reading from the PHY test interface register. */
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
comment|/**< Internal Testing Register Input Data and Select                                                          This is a test bus. Data is present on [3:0],                                                          and its corresponding select (enable) is present                                                          on bits [7:4]. */
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset input from automatic test equipment.                                                          This is a test signal. When the USB Core is                                                          powered up (not in Susned Mode), an automatic                                                          tester can use this to disable phy_clock and                                                          free_clk, then re-eanable them with an aligned                                                          phase.                                                          '1': The phy_clk and free_clk outputs are                                                          disabled. "0": The phy_clock and free_clk outputs                                                          are available within a specific period after the                                                          de-assertion. */
else|#
directive|else
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tuning
range|:
literal|4
decl_stmt|;
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
name|uint64_t
name|siddq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drvvbus
range|:
literal|1
decl_stmt|;
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|otgdisable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|otgtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txhsxvtune
range|:
literal|2
decl_stmt|;
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_usbnx_usbp_ctl_status_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Done.                                                          Asserted at the end of the PHY BIST sequence. */
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Error.                                                          Indicates an internal error was detected during                                                          the BIST sequence. */
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
comment|/**< PHY Test Data Out.                                                          Presents either internaly generated signals or                                                          test register contents, based upon the value of                                                          test_data_out_sel. */
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1 the L2C DMA address will be updated                                                          with byte-counts between packets. When set to 0                                                          the L2C DMA address is incremented to the next                                                          4-byte aligned address after adding byte-count. */
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
comment|/**< Bigendian input to the USB Core. This should be                                                          set to '0' for operation. */
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
comment|/**< PHY, This is cleared '0' to run BIST on the USBP. */
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
comment|/**< PHY Test Clock, used to load TDATA_IN to the USBP. */
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DP_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D+ line. '1' pull down-resistance is connected                                                          to D+/ '0' pull down resistance is not connected                                                          to D+. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DM_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D- line. '1' pull down-resistance is connected                                                          to D-. '0' pull down resistance is not connected                                                          to D-. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
comment|/**< When '0' the USB is acting as HOST, when '1'                                                          USB is acting as device. This field needs to be                                                          set while the USB is in reset. */
name|uint64_t
name|tuning
range|:
literal|4
decl_stmt|;
comment|/**< Transmitter Tuning for High-Speed Operation.                                                          Tunes the current supply and rise/fall output                                                          times for high-speed operation.                                                          [20:19] == 11: Current supply increased                                                          approximately 9%                                                          [20:19] == 10: Current supply increased                                                          approximately 4.5%                                                          [20:19] == 01: Design default.                                                          [20:19] == 00: Current supply decreased                                                          approximately 4.5%                                                          [22:21] == 11: Rise and fall times are increased.                                                          [22:21] == 10: Design default.                                                          [22:21] == 01: Rise and fall times are decreased.                                                          [22:21] == 00: Rise and fall times are decreased                                                          further as compared to the 01 setting. */
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [15:8].                                                          Enables or disables bit stuffing on data[15:8]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [7:0].                                                          Enables or disables bit stuffing on data[7:0]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
comment|/**< PHY Loopback Test Enable.                                                          '1': During data transmission the receive is                                                          enabled.                                                          '0': During data transmission the receive is                                                          disabled.                                                          Must be '0' for normal operation. */
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
comment|/**< Analog Test Pin Enable.                                                          '1' The PHY's analog_test pin is enabled for the                                                          input and output of applicable analog test signals.                                                          '0' THe analog_test pin is disabled. */
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
comment|/**< Built-In Self Test Enable.                                                          Used to activate BIST in the PHY. */
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
comment|/**< Test Data Out Select.                                                          '1' test_data_out[3:0] (PHY) register contents                                                          are output. '0' internaly generated signals are                                                          output. */
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
comment|/**< Mode Address for Test Interface.                                                          Specifies the register address for writing to or                                                          reading from the PHY test interface register. */
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
comment|/**< Internal Testing Register Input Data and Select                                                          This is a test bus. Data is present on [3:0],                                                          and its corresponding select (enable) is present                                                          on bits [7:4]. */
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset input from automatic test equipment.                                                          This is a test signal. When the USB Core is                                                          powered up (not in Susned Mode), an automatic                                                          tester can use this to disable phy_clock and                                                          free_clk, then re-eanable them with an aligned                                                          phase.                                                          '1': The phy_clk and free_clk outputs are                                                          disabled. "0": The phy_clock and free_clk outputs                                                          are available within a specific period after the                                                          de-assertion. */
else|#
directive|else
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tuning
range|:
literal|4
decl_stmt|;
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_usbnx_usbp_ctl_status_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_usbnx_usbp_ctl_status_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Rise/Fall Time Adjustment */
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
comment|/**< HS DC Voltage Level Adjustment */
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
comment|/**< FS/LS Source Impedence Adjustment */
name|uint64_t
name|txhsxvtune
range|:
literal|2
decl_stmt|;
comment|/**< Transmitter High-Speed Crossover Adjustment */
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
comment|/**< Squelch Threshold Adjustment */
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
comment|/**< Disconnect Threshold Adjustment */
name|uint64_t
name|otgtune
range|:
literal|3
decl_stmt|;
comment|/**< VBUS Valid Threshold Adjustment */
name|uint64_t
name|otgdisable
range|:
literal|1
decl_stmt|;
comment|/**< OTG Block Disable */
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
comment|/**< Per_Port Reset */
name|uint64_t
name|drvvbus
range|:
literal|1
decl_stmt|;
comment|/**< Drive VBUS */
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
comment|/**< Low-Speed BIST Enable. */
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
comment|/**< Full-Speed BIST Enable. */
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
comment|/**< High-Speed BIST Enable. */
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Done.                                                          Asserted at the end of the PHY BIST sequence. */
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Error.                                                          Indicates an internal error was detected during                                                          the BIST sequence. */
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
comment|/**< PHY Test Data Out.                                                          Presents either internaly generated signals or                                                          test register contents, based upon the value of                                                          test_data_out_sel. */
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Pre-Emphasis Enable */
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1 the L2C DMA address will be updated                                                          with byte-counts between packets. When set to 0                                                          the L2C DMA address is incremented to the next                                                          4-byte aligned address after adding byte-count. */
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
comment|/**< Bigendian input to the USB Core. This should be                                                          set to '0' for operation. */
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
comment|/**< PHY, This is cleared '0' to run BIST on the USBP. */
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
comment|/**< PHY Test Clock, used to load TDATA_IN to the USBP. */
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DP_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D+ line. '1' pull down-resistance is connected                                                          to D+/ '0' pull down resistance is not connected                                                          to D+. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DM_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D- line. '1' pull down-resistance is connected                                                          to D-. '0' pull down resistance is not connected                                                          to D-. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
comment|/**< When '0' the USB is acting as HOST, when '1'                                                          USB is acting as device. This field needs to be                                                          set while the USB is in reset. */
name|uint64_t
name|reserved_19_22
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [15:8].                                                          Enables or disables bit stuffing on data[15:8]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [7:0].                                                          Enables or disables bit stuffing on data[7:0]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
comment|/**< PHY Loopback Test Enable.                                                          '1': During data transmission the receive is                                                          enabled.                                                          '0': During data transmission the receive is                                                          disabled.                                                          Must be '0' for normal operation. */
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
comment|/**< Analog Test Pin Enable.                                                          '1' The PHY's analog_test pin is enabled for the                                                          input and output of applicable analog test signals.                                                          '0' THe analog_test pin is disabled. */
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
comment|/**< Built-In Self Test Enable.                                                          Used to activate BIST in the PHY. */
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
comment|/**< Test Data Out Select.                                                          '1' test_data_out[3:0] (PHY) register contents                                                          are output. '0' internaly generated signals are                                                          output. */
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
comment|/**< Mode Address for Test Interface.                                                          Specifies the register address for writing to or                                                          reading from the PHY test interface register. */
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
comment|/**< Internal Testing Register Input Data and Select                                                          This is a test bus. Data is present on [3:0],                                                          and its corresponding select (enable) is present                                                          on bits [7:4]. */
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset input from automatic test equipment.                                                          This is a test signal. When the USB Core is                                                          powered up (not in Susned Mode), an automatic                                                          tester can use this to disable phy_clock and                                                          free_clk, then re-eanable them with an aligned                                                          phase.                                                          '1': The phy_clk and free_clk outputs are                                                          disabled. "0": The phy_clock and free_clk outputs                                                          are available within a specific period after the                                                          de-assertion. */
else|#
directive|else
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_22
range|:
literal|4
decl_stmt|;
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drvvbus
range|:
literal|1
decl_stmt|;
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|otgdisable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|otgtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txhsxvtune
range|:
literal|2
decl_stmt|;
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_usbnx_usbp_ctl_status_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Rise/Fall Time Adjustment */
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
comment|/**< HS DC Voltage Level Adjustment */
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
comment|/**< FS/LS Source Impedence Adjustment */
name|uint64_t
name|txhsxvtune
range|:
literal|2
decl_stmt|;
comment|/**< Transmitter High-Speed Crossover Adjustment */
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
comment|/**< Squelch Threshold Adjustment */
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
comment|/**< Disconnect Threshold Adjustment */
name|uint64_t
name|otgtune
range|:
literal|3
decl_stmt|;
comment|/**< VBUS Valid Threshold Adjustment */
name|uint64_t
name|otgdisable
range|:
literal|1
decl_stmt|;
comment|/**< OTG Block Disable */
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
comment|/**< Per_Port Reset */
name|uint64_t
name|drvvbus
range|:
literal|1
decl_stmt|;
comment|/**< Drive VBUS */
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
comment|/**< Low-Speed BIST Enable. */
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
comment|/**< Full-Speed BIST Enable. */
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
comment|/**< High-Speed BIST Enable. */
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Done.                                                          Asserted at the end of the PHY BIST sequence. */
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
comment|/**< PHY Bist Error.                                                          Indicates an internal error was detected during                                                          the BIST sequence. */
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
comment|/**< PHY Test Data Out.                                                          Presents either internaly generated signals or                                                          test register contents, based upon the value of                                                          test_data_out_sel. */
name|uint64_t
name|siddq
range|:
literal|1
decl_stmt|;
comment|/**< Drives the USBP (USB-PHY) SIDDQ input.                                                          Normally should be set to zero.                                                          When customers have no intent to use USB PHY                                                          interface, they should:                                                            - still provide 3.3V to USB_VDD33, and                                                            - tie USB_REXT to 3.3V supply, and                                                            - set USBN*_USBP_CTL_STATUS[SIDDQ]=1 */
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Pre-Emphasis Enable */
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1 the L2C DMA address will be updated                                                          with byte-counts between packets. When set to 0                                                          the L2C DMA address is incremented to the next                                                          4-byte aligned address after adding byte-count. */
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
comment|/**< Bigendian input to the USB Core. This should be                                                          set to '0' for operation. */
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
comment|/**< PHY, This is cleared '0' to run BIST on the USBP. */
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
comment|/**< PHY Test Clock, used to load TDATA_IN to the USBP. */
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DP_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D+ line. '1' pull down-resistance is connected                                                          to D+/ '0' pull down resistance is not connected                                                          to D+. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
comment|/**< PHY DM_PULLDOWN input to the USB-PHY.                                                          This signal enables the pull-down resistance on                                                          the D- line. '1' pull down-resistance is connected                                                          to D-. '0' pull down resistance is not connected                                                          to D-. When an A/B device is acting as a host                                                          (downstream-facing port), dp_pulldown and                                                          dm_pulldown are enabled. This must not toggle                                                          during normal opeartion. */
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
comment|/**< When '0' the USB is acting as HOST, when '1'                                                          USB is acting as device. This field needs to be                                                          set while the USB is in reset. */
name|uint64_t
name|reserved_19_22
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [15:8].                                                          Enables or disables bit stuffing on data[15:8]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Bit Stuffing on [7:0].                                                          Enables or disables bit stuffing on data[7:0]                                                          when bit-stuffing is enabled. */
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
comment|/**< PHY Loopback Test Enable.                                                          '1': During data transmission the receive is                                                          enabled.                                                          '0': During data transmission the receive is                                                          disabled.                                                          Must be '0' for normal operation. */
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
comment|/**< Analog Test Pin Enable.                                                          '1' The PHY's analog_test pin is enabled for the                                                          input and output of applicable analog test signals.                                                          '0' THe analog_test pin is disabled. */
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
comment|/**< Built-In Self Test Enable.                                                          Used to activate BIST in the PHY. */
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
comment|/**< Test Data Out Select.                                                          '1' test_data_out[3:0] (PHY) register contents                                                          are output. '0' internaly generated signals are                                                          output. */
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
comment|/**< Mode Address for Test Interface.                                                          Specifies the register address for writing to or                                                          reading from the PHY test interface register. */
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
comment|/**< Internal Testing Register Input Data and Select                                                          This is a test bus. Data is present on [3:0],                                                          and its corresponding select (enable) is present                                                          on bits [7:4]. */
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset input from automatic test equipment.                                                          This is a test signal. When the USB Core is                                                          powered up (not in Susned Mode), an automatic                                                          tester can use this to disable phy_clock and                                                          free_clk, then re-eanable them with an aligned                                                          phase.                                                          '1': The phy_clk and free_clk outputs are                                                          disabled. "0": The phy_clock and free_clk outputs                                                          are available within a specific period after the                                                          de-assertion. */
else|#
directive|else
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vtest_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bs_enh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_22
range|:
literal|4
decl_stmt|;
name|uint64_t
name|hst_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dm_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dp_pulld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbp_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usbc_end
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
name|uint64_t
name|siddq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drvvbus
range|:
literal|1
decl_stmt|;
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|otgdisable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|otgtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txhsxvtune
range|:
literal|2
decl_stmt|;
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_usbnx_usbp_ctl_status_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbnx_usbp_ctl_status_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbnx_usbp_ctl_status_cn50xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbnx_usbp_ctl_status
name|cvmx_usbnx_usbp_ctl_status_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

