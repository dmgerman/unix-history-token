begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"tunala.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BUFFER
end_ifndef

begin_function
name|void
name|buffer_init
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|total_in
operator|=
name|buf
operator|->
name|total_out
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffer_close
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* Our data is static - nothing needs "release", just reset it */
name|buf
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Code these simple ones in compact form */
end_comment

begin_function
name|unsigned
name|int
name|buffer_used
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|buf
operator|->
name|used
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|buffer_unused
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|MAX_DATA_SIZE
operator|-
name|buf
operator|->
name|used
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buffer_full
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|used
operator|==
name|MAX_DATA_SIZE
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buffer_notfull
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|used
operator|<
name|MAX_DATA_SIZE
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buffer_empty
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|used
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buffer_notempty
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|used
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|buffer_total_in
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|buf
operator|->
name|total_in
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|buffer_total_out
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|buf
operator|->
name|total_out
return|;
block|}
end_function

begin_comment
comment|/* These 3 static (internal) functions don't adjust the "total" variables as  * it's not sure when they're called how it should be interpreted. Only the  * higher-level "buffer_[to|from]_[fd|SSL|BIO]" functions should alter these  * values. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* To avoid "unused" warnings */
end_comment

begin_endif
unit|static unsigned int buffer_adddata(buffer_t *buf, const unsigned char *ptr, 		unsigned int size) { 	unsigned int added = MAX_DATA_SIZE - buf->used; 	if(added> size) 		added = size; 	if(added == 0) 		return 0; 	memcpy(buf->data + buf->used, ptr, added); 	buf->used += added; 	buf->total_in += added; 	return added; }  static unsigned int buffer_tobuffer(buffer_t *to, buffer_t *from, int cap) { 	unsigned int moved, tomove = from->used; 	if((int)tomove> cap) 		tomove = cap; 	if(tomove == 0) 		return 0; 	moved = buffer_adddata(to, from->data, tomove); 	if(moved == 0) 		return 0; 	buffer_takedata(from, NULL, moved); 	return moved; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|int
name|buffer_takedata
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|int
name|taken
init|=
name|buf
operator|->
name|used
decl_stmt|;
if|if
condition|(
name|taken
operator|>
name|size
condition|)
name|taken
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|taken
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptr
condition|)
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|taken
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|-=
name|taken
expr_stmt|;
comment|/* Do we have to scroll? */
if|if
condition|(
name|buf
operator|->
name|used
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|data
operator|+
name|taken
argument_list|,
name|buf
operator|->
name|used
argument_list|)
expr_stmt|;
return|return
name|taken
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_IP
end_ifndef

begin_function
name|int
name|buffer_from_fd
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|int
name|toread
init|=
name|buffer_unused
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|toread
operator|==
literal|0
condition|)
comment|/* Shouldn't be called in this case! */
name|abort
argument_list|()
expr_stmt|;
name|toread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|used
argument_list|,
name|toread
argument_list|)
expr_stmt|;
if|if
condition|(
name|toread
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|used
operator|+=
name|toread
expr_stmt|;
name|buf
operator|->
name|total_in
operator|+=
name|toread
expr_stmt|;
block|}
return|return
name|toread
return|;
block|}
end_function

begin_function
name|int
name|buffer_to_fd
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|int
name|towrite
init|=
name|buffer_used
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|towrite
operator|==
literal|0
condition|)
comment|/* Shouldn't be called in this case! */
name|abort
argument_list|()
expr_stmt|;
name|towrite
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|towrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|towrite
operator|>
literal|0
condition|)
block|{
name|buffer_takedata
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|towrite
argument_list|)
expr_stmt|;
name|buf
operator|->
name|total_out
operator|+=
name|towrite
expr_stmt|;
block|}
return|return
name|towrite
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NO_IP) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENSSL
end_ifndef

begin_function
specifier|static
name|void
name|int_ssl_check
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
name|int
name|e
init|=
name|SSL_get_error
argument_list|(
name|s
argument_list|,
name|ret
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
comment|/* These seem to be harmless and already "dealt with" by our 		 * non-blocking environment. NB: "ZERO_RETURN" is the clean 		 * "error" indicating a successfully closed SSL tunnel. We let 		 * this happen because our IO loop should not appear to have 		 * broken on this condition - and outside the IO loop, the 		 * "shutdown" state is checked. */
case|case
name|SSL_ERROR_NONE
case|:
case|case
name|SSL_ERROR_WANT_READ
case|:
case|case
name|SSL_ERROR_WANT_WRITE
case|:
case|case
name|SSL_ERROR_WANT_X509_LOOKUP
case|:
case|case
name|SSL_ERROR_ZERO_RETURN
case|:
return|return;
comment|/* These seem to be indications of a genuine error that should 		 * result in the SSL tunnel being regarded as "dead". */
case|case
name|SSL_ERROR_SYSCALL
case|:
case|case
name|SSL_ERROR_SSL
case|:
name|SSL_set_app_data
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* For any other errors that (a) exist, and (b) crop up - we need to 	 * interpret what to do with them - so "politely inform" the caller that 	 * the code needs updating here. */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffer_from_SSL
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ssl
operator|||
name|buffer_full
argument_list|(
name|buf
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|SSL_read
argument_list|(
name|ssl
argument_list|,
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|used
argument_list|,
name|buffer_unused
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|used
operator|+=
name|ret
expr_stmt|;
name|buf
operator|->
name|total_in
operator|+=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|int_ssl_check
argument_list|(
name|ssl
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffer_to_SSL
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ssl
operator|||
name|buffer_empty
argument_list|(
name|buf
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|SSL_write
argument_list|(
name|ssl
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|buffer_takedata
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|buf
operator|->
name|total_out
operator|+=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|int_ssl_check
argument_list|(
name|ssl
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffer_from_BIO
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bio
operator|||
name|buffer_full
argument_list|(
name|buf
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|BIO_read
argument_list|(
name|bio
argument_list|,
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|used
argument_list|,
name|buffer_unused
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|buf
operator|->
name|used
operator|+=
name|ret
expr_stmt|;
name|buf
operator|->
name|total_in
operator|+=
name|ret
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|buffer_to_BIO
parameter_list|(
name|buffer_t
modifier|*
name|buf
parameter_list|,
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bio
operator|||
name|buffer_empty
argument_list|(
name|buf
argument_list|)
condition|)
return|return;
name|ret
operator|=
name|BIO_write
argument_list|(
name|bio
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|buffer_takedata
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|buf
operator|->
name|total_out
operator|+=
name|ret
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NO_OPENSSL) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NO_BUFFER) */
end_comment

end_unit

