begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crypto/engine/hw_ibmca.c */
end_comment

begin_comment
comment|/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL  * project 2000.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* (C) COPYRIGHT International Business Machines Corp. 2001 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dso.h>
end_include

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_HW_IBMCA
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FLAT_INC
end_ifdef

begin_include
include|#
directive|include
file|"ica_openssl_api.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"vendor_defns/ica_openssl_api.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IBMCA_LIB_NAME
value|"ibmca engine"
end_define

begin_include
include|#
directive|include
file|"hw_ibmca_err.c"
end_include

begin_function_decl
specifier|static
name|int
name|ibmca_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ibmca_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ibmca_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ibmca_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|IBMCA_F1
init|=
literal|"icaOpenAdapter"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|IBMCA_F2
init|=
literal|"icaCloseAdapter"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|IBMCA_F3
init|=
literal|"icaRsaModExpo"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|IBMCA_F4
init|=
literal|"icaRandomNumberGenerate"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|IBMCA_F5
init|=
literal|"icaRsaCrt"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ICA_ADAPTER_HANDLE
name|handle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BIGNUM stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|ibmca_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ibmca_mod_exp_crt
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|dmp1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|dmq1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|iqmp
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* RSA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|ibmca_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r0
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function_decl
specifier|static
name|int
name|ibmca_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* DSA stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|ibmca_dsa_mod_exp
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|rr
parameter_list|,
name|BIGNUM
modifier|*
name|a1
parameter_list|,
name|BIGNUM
modifier|*
name|p1
parameter_list|,
name|BIGNUM
modifier|*
name|a2
parameter_list|,
name|BIGNUM
modifier|*
name|p2
parameter_list|,
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|in_mont
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ibmca_mod_exp_dsa
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* DH stuff */
end_comment

begin_comment
comment|/* This function is alised to mod_exp (with the DH and mont dropped). */
end_comment

begin_function_decl
specifier|static
name|int
name|ibmca_mod_exp_dh
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAND stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|ibmca_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ibmca_rand_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* WJH - check for more commands, like in nuron */
end_comment

begin_comment
comment|/* The definitions for control commands specific to this engine */
end_comment

begin_define
define|#
directive|define
name|IBMCA_CMD_SO_PATH
value|ENGINE_CMD_BASE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|ibmca_cmd_defns
index|[]
init|=
block|{
block|{
name|IBMCA_CMD_SO_PATH
block|,
literal|"SO_PATH"
block|,
literal|"Specifies the path to the 'atasi' shared library"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_comment
comment|/* Our internal RSA_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|ibmca_rsa
init|=
block|{
literal|"Ibmca RSA method"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ibmca_rsa_mod_exp
block|,
name|ibmca_mod_exp_mont
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* Our internal DSA_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|DSA_METHOD
name|ibmca_dsa
init|=
block|{
literal|"Ibmca DSA method"
block|,
name|NULL
block|,
comment|/* dsa_do_sign */
name|NULL
block|,
comment|/* dsa_sign_setup */
name|NULL
block|,
comment|/* dsa_do_verify */
name|ibmca_dsa_mod_exp
block|,
comment|/* dsa_mod_exp */
name|ibmca_mod_exp_dsa
block|,
comment|/* bn_mod_exp */
name|NULL
block|,
comment|/* init */
name|NULL
block|,
comment|/* finish */
literal|0
block|,
comment|/* flags */
name|NULL
comment|/* app_data */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* Our internal DH_METHOD that we provide pointers to */
end_comment

begin_decl_stmt
specifier|static
name|DH_METHOD
name|ibmca_dh
init|=
block|{
literal|"Ibmca DH method"
block|,
name|NULL
block|,
name|NULL
block|,
name|ibmca_mod_exp_dh
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|RAND_METHOD
name|ibmca_rand
init|=
block|{
comment|/* "IBMCA RAND method", */
name|NULL
block|,
name|ibmca_rand_bytes
block|,
name|NULL
block|,
name|NULL
block|,
name|ibmca_rand_bytes
block|,
name|ibmca_rand_status
block|,         }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used when creating the ENGINE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_ibmca_id
init|=
literal|"ibmca"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_ibmca_name
init|=
literal|"Ibmca hardware engine support"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This internal function is used by ENGINE_ibmca() and possibly by the  * "dynamic" ENGINE support too */
end_comment

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
specifier|const
name|RSA_METHOD
modifier|*
name|meth1
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
specifier|const
name|DSA_METHOD
modifier|*
name|meth2
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
specifier|const
name|DH_METHOD
modifier|*
name|meth3
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_ibmca_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_ibmca_name
argument_list|)
operator|||
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|ibmca_rsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
operator|!
name|ENGINE_set_DSA
argument_list|(
name|e
argument_list|,
operator|&
name|ibmca_dsa
argument_list|)
operator|||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
operator|!
name|ENGINE_set_DH
argument_list|(
name|e
argument_list|,
operator|&
name|ibmca_dh
argument_list|)
operator|||
endif|#
directive|endif
operator|!
name|ENGINE_set_RAND
argument_list|(
name|e
argument_list|,
operator|&
name|ibmca_rand
argument_list|)
operator|||
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|ibmca_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|ibmca_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|ibmca_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|ibmca_ctrl
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|e
argument_list|,
name|ibmca_cmd_defns
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
comment|/* We know that the "PKCS1_SSLeay()" functions hook properly 	 * to the ibmca-specific mod_exp and mod_exp_crt so we use 	 * those functions. NB: We don't use ENGINE_openssl() or 	 * anything "more generic" because something like the RSAref 	 * code may not hook properly, and if you own one of these 	 * cards then you have the right to do RSA operations on it 	 * anyway! */
name|meth1
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
name|ibmca_rsa
operator|.
name|rsa_pub_enc
operator|=
name|meth1
operator|->
name|rsa_pub_enc
expr_stmt|;
name|ibmca_rsa
operator|.
name|rsa_pub_dec
operator|=
name|meth1
operator|->
name|rsa_pub_dec
expr_stmt|;
name|ibmca_rsa
operator|.
name|rsa_priv_enc
operator|=
name|meth1
operator|->
name|rsa_priv_enc
expr_stmt|;
name|ibmca_rsa
operator|.
name|rsa_priv_dec
operator|=
name|meth1
operator|->
name|rsa_priv_dec
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
comment|/* Use the DSA_OpenSSL() method and just hook the mod_exp-ish 	 * bits. */
name|meth2
operator|=
name|DSA_OpenSSL
argument_list|()
expr_stmt|;
name|ibmca_dsa
operator|.
name|dsa_do_sign
operator|=
name|meth2
operator|->
name|dsa_do_sign
expr_stmt|;
name|ibmca_dsa
operator|.
name|dsa_sign_setup
operator|=
name|meth2
operator|->
name|dsa_sign_setup
expr_stmt|;
name|ibmca_dsa
operator|.
name|dsa_do_verify
operator|=
name|meth2
operator|->
name|dsa_do_verify
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
comment|/* Much the same for Diffie-Hellman */
name|meth3
operator|=
name|DH_OpenSSL
argument_list|()
expr_stmt|;
name|ibmca_dh
operator|.
name|generate_key
operator|=
name|meth3
operator|->
name|generate_key
expr_stmt|;
name|ibmca_dh
operator|.
name|compute_key
operator|=
name|meth3
operator|->
name|compute_key
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure the ibmca error handling is set up */
name|ERR_load_IBMCA_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_ibmca
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|void
name|ENGINE_load_ibmca
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_ibmca
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destructor (complements the "ENGINE_ibmca()" constructor) */
end_comment

begin_function
specifier|static
name|int
name|ibmca_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
comment|/* Unload the ibmca error strings so any error state including our 	 * functs or reasons won't lead to a segfault (they simply get displayed 	 * without corresponding string data because none will be found). */
name|ERR_unload_IBMCA_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is a process-global DSO handle used for loading and unloading  * the Ibmca library. NB: This is only set (or unset) during an  * init() or finish() call (reference counts permitting) and they're  * operating with global locks, so this should be thread-safe  * implicitly. */
end_comment

begin_decl_stmt
specifier|static
name|DSO
modifier|*
name|ibmca_dso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the function pointers that are (un)set when the library has  * successfully (un)loaded. */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|int
function_decl|(
name|ICA_CALL
modifier|*
name|p_icaOpenAdapter
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
function_decl|(
name|ICA_CALL
modifier|*
name|p_icaCloseAdapter
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
function_decl|(
name|ICA_CALL
modifier|*
name|p_icaRsaModExpo
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
function_decl|(
name|ICA_CALL
modifier|*
name|p_icaRandomNumberGenerate
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
function_decl|(
name|ICA_CALL
modifier|*
name|p_icaRsaCrt
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* utility function to obtain a context */
end_comment

begin_function
specifier|static
name|int
name|get_context
parameter_list|(
name|ICA_ADAPTER_HANDLE
modifier|*
name|p_handle
parameter_list|)
block|{
name|unsigned
name|int
name|status
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|p_icaOpenAdapter
argument_list|(
literal|0
argument_list|,
name|p_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* similarly to release one. */
end_comment

begin_function
specifier|static
name|void
name|release_context
parameter_list|(
name|ICA_ADAPTER_HANDLE
name|handle
parameter_list|)
block|{
name|p_icaCloseAdapter
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* (de)initialisation functions. */
end_comment

begin_function
specifier|static
name|int
name|ibmca_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|p1
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|p2
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|p3
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|p4
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|p5
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|ibmca_dso
operator|!=
name|NULL
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_INIT
argument_list|,
name|IBMCA_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Attempt to load libatasi.so/atasi.dll/whatever. Needs to be          * changed unfortunately because the Ibmca drivers don't have          * standard library names that can be platform-translated well. */
comment|/* TODO: Work out how to actually map to the names the Ibmca          * drivers really use - for now a symbollic link needs to be          * created on the host system from libatasi.so to atasi.so on          * unix variants. */
comment|/* WJH XXX check name translation */
name|ibmca_dso
operator|=
name|DSO_load
argument_list|(
name|NULL
argument_list|,
name|IBMCA_LIBNAME
argument_list|,
name|NULL
argument_list|,
comment|/* DSO_FLAG_NAME_TRANSLATION */
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibmca_dso
operator|==
name|NULL
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_INIT
argument_list|,
name|IBMCA_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|p1
operator|=
name|DSO_bind_func
argument_list|(
name|ibmca_dso
argument_list|,
name|IBMCA_F1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p2
operator|=
name|DSO_bind_func
argument_list|(
name|ibmca_dso
argument_list|,
name|IBMCA_F2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p3
operator|=
name|DSO_bind_func
argument_list|(
name|ibmca_dso
argument_list|,
name|IBMCA_F3
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p4
operator|=
name|DSO_bind_func
argument_list|(
name|ibmca_dso
argument_list|,
name|IBMCA_F4
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|p5
operator|=
name|DSO_bind_func
argument_list|(
name|ibmca_dso
argument_list|,
name|IBMCA_F5
argument_list|)
operator|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_INIT
argument_list|,
name|IBMCA_R_DSO_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy the pointers */
name|p_icaOpenAdapter
operator|=
operator|(
name|unsigned
name|int
argument_list|(
name|ICA_CALL
operator|*
argument_list|)
argument_list|()
operator|)
name|p1
expr_stmt|;
name|p_icaCloseAdapter
operator|=
operator|(
name|unsigned
name|int
argument_list|(
name|ICA_CALL
operator|*
argument_list|)
argument_list|()
operator|)
name|p2
expr_stmt|;
name|p_icaRsaModExpo
operator|=
operator|(
name|unsigned
name|int
argument_list|(
name|ICA_CALL
operator|*
argument_list|)
argument_list|()
operator|)
name|p3
expr_stmt|;
name|p_icaRandomNumberGenerate
operator|=
operator|(
name|unsigned
name|int
argument_list|(
name|ICA_CALL
operator|*
argument_list|)
argument_list|()
operator|)
name|p4
expr_stmt|;
name|p_icaRsaCrt
operator|=
operator|(
name|unsigned
name|int
argument_list|(
name|ICA_CALL
operator|*
argument_list|)
argument_list|()
operator|)
name|p5
expr_stmt|;
if|if
condition|(
operator|!
name|get_context
argument_list|(
operator|&
name|handle
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_INIT
argument_list|,
name|IBMCA_R_UNIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|ibmca_dso
condition|)
name|DSO_free
argument_list|(
name|ibmca_dso
argument_list|)
expr_stmt|;
name|p_icaOpenAdapter
operator|=
name|NULL
expr_stmt|;
name|p_icaCloseAdapter
operator|=
name|NULL
expr_stmt|;
name|p_icaRsaModExpo
operator|=
name|NULL
expr_stmt|;
name|p_icaRandomNumberGenerate
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibmca_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|ibmca_dso
operator|==
name|NULL
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_FINISH
argument_list|,
name|IBMCA_R_NOT_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|release_context
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSO_free
argument_list|(
name|ibmca_dso
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_FINISH
argument_list|,
name|IBMCA_R_DSO_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ibmca_dso
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibmca_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|initialised
init|=
operator|(
operator|(
name|ibmca_dso
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IBMCA_CMD_SO_PATH
case|:
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_CTRL
argument_list|,
name|ERR_R_PASSED_NULL_PARAMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|initialised
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_CTRL
argument_list|,
name|IBMCA_R_ALREADY_LOADED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|IBMCA_LIBNAME
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_CTRL
argument_list|,
name|IBMCA_R_CTRL_COMMAND_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibmca_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* I need somewhere to store temporary serialised values for          * use with the Ibmca API calls. A neat cheat - I'll use          * BIGNUMs from the BN_CTX but access their arrays directly as          * byte arrays<grin>. This way I don't have to clean anything          * up. */
name|BIGNUM
modifier|*
name|argument
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|int
name|to_return
decl_stmt|;
name|int
name|inLen
decl_stmt|,
name|outLen
decl_stmt|,
name|tmpLen
decl_stmt|;
name|ICA_KEY_RSA_MODEXPO
modifier|*
name|publKey
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|rc
decl_stmt|;
name|to_return
operator|=
literal|0
expr_stmt|;
comment|/* expect failure */
if|if
condition|(
operator|!
name|ibmca_dso
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP
argument_list|,
name|IBMCA_R_NOT_LOADED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare the params */
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|argument
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|key
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argument
operator|||
operator|!
name|result
operator|||
operator|!
name|key
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP
argument_list|,
name|IBMCA_R_BN_CTX_FULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|bn_wexpand
argument_list|(
name|argument
argument_list|,
name|m
operator|->
name|top
argument_list|)
operator|||
operator|!
name|bn_wexpand
argument_list|(
name|result
argument_list|,
name|m
operator|->
name|top
argument_list|)
operator|||
operator|!
name|bn_wexpand
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|publKey
argument_list|)
operator|/
name|BN_BYTES
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP
argument_list|,
name|IBMCA_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|publKey
operator|=
operator|(
name|ICA_KEY_RSA_MODEXPO
operator|*
operator|)
name|key
operator|->
name|d
expr_stmt|;
if|if
condition|(
name|publKey
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
name|memset
argument_list|(
name|publKey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ICA_KEY_RSA_MODEXPO
argument_list|)
argument_list|)
expr_stmt|;
name|publKey
operator|->
name|keyType
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|ME_KEY_TYPE
argument_list|)
expr_stmt|;
name|publKey
operator|->
name|keyLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
sizeof|sizeof
argument_list|(
name|ICA_KEY_RSA_MODEXPO
argument_list|)
argument_list|)
expr_stmt|;
name|publKey
operator|->
name|expOffset
operator|=
operator|(
name|char
operator|*
operator|)
name|publKey
operator|->
name|keyRecord
operator|-
operator|(
name|char
operator|*
operator|)
name|publKey
expr_stmt|;
comment|/* A quirk of the card: the exponent length has to be the same      as the modulus (key) length */
name|outLen
operator|=
name|BN_num_bytes
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* check for modulus length SAB*/
if|if
condition|(
name|outLen
operator|>
literal|256
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP
argument_list|,
name|IBMCA_R_MEXP_LENGTH_TO_LARGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* check for modulus length SAB*/
name|publKey
operator|->
name|expLength
operator|=
name|publKey
operator|->
name|nLength
operator|=
name|outLen
expr_stmt|;
comment|/* SAB Check for underflow condition     the size of the exponent is less than the size of the parameter     then we have a big problem and will underflow the keyRecord    buffer.  Bad stuff could happen then */
if|if
condition|(
name|outLen
operator|<
name|BN_num_bytes
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP
argument_list|,
name|IBMCA_R_UNDERFLOW_KEYRECORD
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* SAB End check for underflow */
name|BN_bn2bin
argument_list|(
name|p
argument_list|,
operator|&
name|publKey
operator|->
name|keyRecord
index|[
name|publKey
operator|->
name|expLength
operator|-
name|BN_num_bytes
argument_list|(
name|p
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|m
argument_list|,
operator|&
name|publKey
operator|->
name|keyRecord
index|[
name|publKey
operator|->
name|expLength
index|]
argument_list|)
expr_stmt|;
name|publKey
operator|->
name|modulusBitLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|publKey
operator|->
name|nLength
operator|*
literal|8
argument_list|)
expr_stmt|;
name|publKey
operator|->
name|nOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|publKey
operator|->
name|expOffset
operator|+
name|publKey
operator|->
name|expLength
argument_list|)
expr_stmt|;
name|publKey
operator|->
name|expOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
operator|(
name|char
operator|*
operator|)
name|publKey
operator|->
name|keyRecord
operator|-
operator|(
name|char
operator|*
operator|)
name|publKey
argument_list|)
expr_stmt|;
name|tmpLen
operator|=
name|outLen
expr_stmt|;
name|publKey
operator|->
name|expLength
operator|=
name|publKey
operator|->
name|nLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|tmpLen
argument_list|)
expr_stmt|;
comment|/* Prepare the argument */
name|memset
argument_list|(
name|argument
operator|->
name|d
argument_list|,
literal|0
argument_list|,
name|outLen
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|a
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argument
operator|->
name|d
operator|+
name|outLen
operator|-
name|BN_num_bytes
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|inLen
operator|=
name|outLen
expr_stmt|;
comment|/* Perform the operation */
if|if
condition|(
operator|(
name|rc
operator|=
name|p_icaRsaModExpo
argument_list|(
name|handle
argument_list|,
name|inLen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argument
operator|->
name|d
argument_list|,
name|publKey
argument_list|,
operator|&
name|outLen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP
argument_list|,
name|IBMCA_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Convert the response */
name|BN_bin2bn
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
operator|->
name|d
argument_list|,
name|outLen
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_RSA
end_ifndef

begin_function
specifier|static
name|int
name|ibmca_rsa_mod_exp
parameter_list|(
name|BIGNUM
modifier|*
name|r0
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|I
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|rsa
operator|->
name|p
operator|||
operator|!
name|rsa
operator|->
name|q
operator|||
operator|!
name|rsa
operator|->
name|dmp1
operator|||
operator|!
name|rsa
operator|->
name|dmq1
operator|||
operator|!
name|rsa
operator|->
name|iqmp
condition|)
block|{
if|if
condition|(
operator|!
name|rsa
operator|->
name|d
operator|||
operator|!
name|rsa
operator|->
name|n
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_RSA_MOD_EXP
argument_list|,
name|IBMCA_R_MISSING_KEY_COMPONENTS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|to_return
operator|=
name|ibmca_mod_exp
argument_list|(
name|r0
argument_list|,
name|I
argument_list|,
name|rsa
operator|->
name|d
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_return
operator|=
name|ibmca_mod_exp_crt
argument_list|(
name|r0
argument_list|,
name|I
argument_list|,
name|rsa
operator|->
name|p
argument_list|,
name|rsa
operator|->
name|q
argument_list|,
name|rsa
operator|->
name|dmp1
argument_list|,
name|rsa
operator|->
name|dmq1
argument_list|,
name|rsa
operator|->
name|iqmp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
name|err
label|:
if|if
condition|(
name|ctx
condition|)
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Ein kleines chinesisches "Restessen"  */
end_comment

begin_function
specifier|static
name|int
name|ibmca_mod_exp_crt
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|dmp1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|dmq1
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|iqmp
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|argument
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* expect failure */
name|char
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
name|ICA_KEY_RSA_CRT
modifier|*
name|privKey
init|=
name|NULL
decl_stmt|;
name|int
name|inLen
decl_stmt|,
name|outLen
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|,
name|pSize
decl_stmt|,
name|qSize
decl_stmt|;
comment|/* SAB New variables */
name|unsigned
name|int
name|keyRecordSize
decl_stmt|;
name|unsigned
name|int
name|pbytes
init|=
name|BN_num_bytes
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|qbytes
init|=
name|BN_num_bytes
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dmp1bytes
init|=
name|BN_num_bytes
argument_list|(
name|dmp1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dmq1bytes
init|=
name|BN_num_bytes
argument_list|(
name|dmq1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|iqmpbytes
init|=
name|BN_num_bytes
argument_list|(
name|iqmp
argument_list|)
decl_stmt|;
comment|/* Prepare the params */
name|BN_CTX_start
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|argument
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|key
operator|=
name|BN_CTX_get
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argument
operator|||
operator|!
name|result
operator|||
operator|!
name|key
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_BN_CTX_FULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|bn_wexpand
argument_list|(
name|argument
argument_list|,
name|p
operator|->
name|top
operator|+
name|q
operator|->
name|top
argument_list|)
operator|||
operator|!
name|bn_wexpand
argument_list|(
name|result
argument_list|,
name|p
operator|->
name|top
operator|+
name|q
operator|->
name|top
argument_list|)
operator|||
operator|!
name|bn_wexpand
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privKey
argument_list|)
operator|/
name|BN_BYTES
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_BN_EXPAND_FAIL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|privKey
operator|=
operator|(
name|ICA_KEY_RSA_CRT
operator|*
operator|)
name|key
operator|->
name|d
expr_stmt|;
comment|/* SAB Add check for total size in bytes of the parms does not exceed    the buffer space we have    do this first */
name|keyRecordSize
operator|=
name|pbytes
operator|+
name|qbytes
operator|+
name|dmp1bytes
operator|+
name|dmq1bytes
operator|+
name|iqmpbytes
expr_stmt|;
if|if
condition|(
name|keyRecordSize
operator|>
sizeof|sizeof
argument_list|(
name|privKey
operator|->
name|keyRecord
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_OPERANDS_TO_LARGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|qbytes
operator|+
name|dmq1bytes
operator|)
operator|>
literal|256
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_OPERANDS_TO_LARGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|pbytes
operator|+
name|dmp1bytes
operator|>
literal|256
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_OPERANDS_TO_LARGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* end SAB additions */
name|memset
argument_list|(
name|privKey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ICA_KEY_RSA_CRT
argument_list|)
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|keyType
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|CRT_KEY_TYPE
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|keyLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
sizeof|sizeof
argument_list|(
name|ICA_KEY_RSA_CRT
argument_list|)
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|modulusBitLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|BN_num_bytes
argument_list|(
name|q
argument_list|)
operator|*
literal|2
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/*          * p,dp& qInv are 1 QWORD Larger          */
name|privKey
operator|->
name|pLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|BN_num_bytes
argument_list|(
name|p
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|qLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|BN_num_bytes
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|dpLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|BN_num_bytes
argument_list|(
name|dmp1
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|dqLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|BN_num_bytes
argument_list|(
name|dmq1
argument_list|)
argument_list|)
expr_stmt|;
name|privKey
operator|->
name|qInvLength
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|BN_num_bytes
argument_list|(
name|iqmp
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
name|privKey
operator|->
name|keyRecord
operator|-
operator|(
name|char
operator|*
operator|)
name|privKey
expr_stmt|;
name|qSize
operator|=
name|BN_num_bytes
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|pSize
operator|=
name|qSize
operator|+
literal|8
expr_stmt|;
comment|/*  1 QWORD larger */
comment|/* SAB  probably aittle redundant, but we'll verify that each of the    components which make up a key record sent ot the card does not exceed    the space that is allocated for it.  this handles the case where even if    the total length does not exceed keyrecord zied, if the operands are funny sized they could cause potential side affects on either the card or the result */
if|if
condition|(
operator|(
name|pbytes
operator|>
name|pSize
operator|)
operator|||
operator|(
name|dmp1bytes
operator|>
name|pSize
operator|)
operator|||
operator|(
name|iqmpbytes
operator|>
name|pSize
operator|)
operator|||
operator|(
name|qbytes
operator|>
name|qSize
operator|)
operator|||
operator|(
name|dmq1bytes
operator|>
name|qSize
operator|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_OPERANDS_TO_LARGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|privKey
operator|->
name|dpOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|pSize
expr_stmt|;
name|privKey
operator|->
name|dqOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|qSize
expr_stmt|;
name|privKey
operator|->
name|pOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|pSize
expr_stmt|;
name|privKey
operator|->
name|qOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|qSize
expr_stmt|;
name|privKey
operator|->
name|qInvOffset
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|pkey
operator|=
operator|(
name|char
operator|*
operator|)
name|privKey
operator|->
name|keyRecord
expr_stmt|;
comment|/* SAB first check that we don;t under flow the buffer */
if|if
condition|(
name|pSize
operator|<
name|pbytes
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_UNDERFLOW_CONDITION
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* pkey += pSize - BN_num_bytes(p); WROING this should be dmp1) */
name|pkey
operator|+=
name|pSize
operator|-
name|BN_num_bytes
argument_list|(
name|dmp1
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|dmp1
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|pkey
operator|+=
name|BN_num_bytes
argument_list|(
name|dmp1
argument_list|)
expr_stmt|;
comment|/* move the pointer */
name|BN_bn2bin
argument_list|(
name|dmq1
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
comment|/* Copy over dmq1 */
name|pkey
operator|+=
name|qSize
expr_stmt|;
comment|/* move pointer */
name|pkey
operator|+=
name|pSize
operator|-
name|BN_num_bytes
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* set up for zero padding of next field */
name|BN_bn2bin
argument_list|(
name|p
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|pkey
operator|+=
name|BN_num_bytes
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* increment pointer by number of bytes moved  */
name|BN_bn2bin
argument_list|(
name|q
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|pkey
operator|+=
name|qSize
expr_stmt|;
comment|/* move the pointer */
name|pkey
operator|+=
name|pSize
operator|-
name|BN_num_bytes
argument_list|(
name|iqmp
argument_list|)
expr_stmt|;
comment|/* Adjust for padding */
name|BN_bn2bin
argument_list|(
name|iqmp
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
comment|/* Prepare the argument and response */
name|outLen
operator|=
name|CORRECT_ENDIANNESS
argument_list|(
name|privKey
operator|->
name|qLength
argument_list|)
operator|*
literal|2
expr_stmt|;
comment|/* Correct endianess is used  						because the fields were converted above */
if|if
condition|(
name|outLen
operator|>
literal|256
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_OUTLEN_TO_LARGE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* SAB check for underflow here on the argeument */
if|if
condition|(
name|outLen
operator|<
name|BN_num_bytes
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_UNDERFLOW_CONDITION
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|BN_bn2bin
argument_list|(
name|a
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argument
operator|->
name|d
operator|+
name|outLen
operator|-
name|BN_num_bytes
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|inLen
operator|=
name|outLen
expr_stmt|;
name|memset
argument_list|(
name|result
operator|->
name|d
argument_list|,
literal|0
argument_list|,
name|outLen
argument_list|)
expr_stmt|;
comment|/* Perform the operation */
if|if
condition|(
operator|(
name|rc
operator|=
name|p_icaRsaCrt
argument_list|(
name|handle
argument_list|,
name|inLen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argument
operator|->
name|d
argument_list|,
name|privKey
argument_list|,
operator|&
name|outLen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_MOD_EXP_CRT
argument_list|,
name|IBMCA_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Convert the response */
name|BN_bin2bn
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|result
operator|->
name|d
argument_list|,
name|outLen
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
name|BN_CTX_end
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DSA
end_ifndef

begin_comment
comment|/* This code was liberated and adapted from the commented-out code in  * dsa_ossl.c. Because of the unoptimised form of the Ibmca acceleration  * (it doesn't have a CRT form for RSA), this function means that an  * Ibmca system running with a DSA server certificate can handshake  * around 5 or 6 times faster/more than an equivalent system running with  * RSA. Just check out the "signs" statistics from the RSA and DSA parts  * of "openssl speed -engine ibmca dsa1024 rsa1024". */
end_comment

begin_function
specifier|static
name|int
name|ibmca_dsa_mod_exp
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|rr
parameter_list|,
name|BIGNUM
modifier|*
name|a1
parameter_list|,
name|BIGNUM
modifier|*
name|p1
parameter_list|,
name|BIGNUM
modifier|*
name|a2
parameter_list|,
name|BIGNUM
modifier|*
name|p2
parameter_list|,
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|in_mont
parameter_list|)
block|{
name|BIGNUM
name|t
decl_stmt|;
name|int
name|to_return
init|=
literal|0
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* let rr = a1 ^ p1 mod m */
if|if
condition|(
operator|!
name|ibmca_mod_exp
argument_list|(
name|rr
argument_list|,
name|a1
argument_list|,
name|p1
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* let t = a2 ^ p2 mod m */
if|if
condition|(
operator|!
name|ibmca_mod_exp
argument_list|(
operator|&
name|t
argument_list|,
name|a2
argument_list|,
name|p2
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* let rr = rr * t mod m */
if|if
condition|(
operator|!
name|BN_mod_mul
argument_list|(
name|rr
argument_list|,
name|rr
argument_list|,
operator|&
name|t
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|to_return
operator|=
literal|1
expr_stmt|;
name|end
label|:
name|BN_free
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibmca_mod_exp_dsa
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|ibmca_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is aliased to mod_exp (with the mont stuff dropped). */
end_comment

begin_function
specifier|static
name|int
name|ibmca_mod_exp_mont
parameter_list|(
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|ibmca_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DH
end_ifndef

begin_comment
comment|/* This function is aliased to mod_exp (with the dh and mont dropped). */
end_comment

begin_function
specifier|static
name|int
name|ibmca_mod_exp_dh
parameter_list|(
name|DH
specifier|const
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|a
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|m
parameter_list|,
name|BN_CTX
modifier|*
name|ctx
parameter_list|,
name|BN_MONT_CTX
modifier|*
name|m_ctx
parameter_list|)
block|{
return|return
name|ibmca_mod_exp
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|m
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Random bytes are good */
end_comment

begin_function
specifier|static
name|int
name|ibmca_rand_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|to_return
init|=
literal|0
decl_stmt|;
comment|/* assume failure */
name|unsigned
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_RAND_BYTES
argument_list|,
name|IBMCA_R_NOT_INITIALISED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|p_icaRandomNumberGenerate
argument_list|(
name|handle
argument_list|,
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|IBMCAerr
argument_list|(
name|IBMCA_F_IBMCA_RAND_BYTES
argument_list|,
name|IBMCA_R_REQUEST_FAILED
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|to_return
operator|=
literal|1
expr_stmt|;
name|err
label|:
return|return
name|to_return
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibmca_rand_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This stuff is needed if this ENGINE is being compiled into a self-contained  * shared-library. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENGINE_DYNAMIC_SUPPORT
end_ifdef

begin_function
specifier|static
name|int
name|bind_fn
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_ibmca_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
comment|/* WJH XXX */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bind_helper
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_fn
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENGINE_DYNAMIC_SUPPORT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW_IBMCA */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OPENSSL_NO_HW */
end_comment

end_unit

