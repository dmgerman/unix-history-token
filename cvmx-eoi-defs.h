begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-eoi-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon eoi.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision: 69515 $<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_EOI_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_EOI_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_BIST_CTL_STA
value|CVMX_EOI_BIST_CTL_STA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_BIST_CTL_STA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_BIST_CTL_STA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000118ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_BIST_CTL_STA
value|(CVMX_ADD_IO_SEG(0x0001180013000118ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_CTL_STA
value|CVMX_EOI_CTL_STA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_CTL_STA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_CTL_STA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_CTL_STA
value|(CVMX_ADD_IO_SEG(0x0001180013000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_DEF_STA0
value|CVMX_EOI_DEF_STA0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_DEF_STA0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_DEF_STA0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_DEF_STA0
value|(CVMX_ADD_IO_SEG(0x0001180013000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_DEF_STA1
value|CVMX_EOI_DEF_STA1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_DEF_STA1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_DEF_STA1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_DEF_STA1
value|(CVMX_ADD_IO_SEG(0x0001180013000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_DEF_STA2
value|CVMX_EOI_DEF_STA2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_DEF_STA2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_DEF_STA2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_DEF_STA2
value|(CVMX_ADD_IO_SEG(0x0001180013000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_ECC_CTL
value|CVMX_EOI_ECC_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_ECC_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_ECC_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000110ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_ECC_CTL
value|(CVMX_ADD_IO_SEG(0x0001180013000110ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_ENDOR_BISTR_CTL_STA
value|CVMX_EOI_ENDOR_BISTR_CTL_STA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_ENDOR_BISTR_CTL_STA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_ENDOR_BISTR_CTL_STA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000120ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_ENDOR_BISTR_CTL_STA
value|(CVMX_ADD_IO_SEG(0x0001180013000120ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_ENDOR_CLK_CTL
value|CVMX_EOI_ENDOR_CLK_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_ENDOR_CLK_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_ENDOR_CLK_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_ENDOR_CLK_CTL
value|(CVMX_ADD_IO_SEG(0x0001180013000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_ENDOR_CTL
value|CVMX_EOI_ENDOR_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_ENDOR_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_ENDOR_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000100ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_ENDOR_CTL
value|(CVMX_ADD_IO_SEG(0x0001180013000100ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_INT_ENA
value|CVMX_EOI_INT_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_INT_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_INT_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_INT_ENA
value|(CVMX_ADD_IO_SEG(0x0001180013000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_INT_STA
value|CVMX_EOI_INT_STA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_INT_STA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_INT_STA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_INT_STA
value|(CVMX_ADD_IO_SEG(0x0001180013000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_IO_DRV
value|CVMX_EOI_IO_DRV_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_IO_DRV_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_IO_DRV not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_IO_DRV
value|(CVMX_ADD_IO_SEG(0x0001180013000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_EOI_THROTTLE_CTL
value|CVMX_EOI_THROTTLE_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_EOI_THROTTLE_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_EOI_THROTTLE_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180013000108ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_EOI_THROTTLE_CTL
value|(CVMX_ADD_IO_SEG(0x0001180013000108ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_eoi_bist_ctl_sta  *  * EOI_BIST_CTL_STA =  EOI BIST Status Register  *  * Description:  *   This register control EOI memory BIST and contains the bist result of EOI memories.  */
end_comment

begin_union
union|union
name|cvmx_eoi_bist_ctl_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_bist_ctl_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
comment|/**< Clear BIST on the HCLK memories */
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
comment|/**< Starts BIST on the HCLK memories during 0-to-1                                                          transition. */
name|uint64_t
name|reserved_3_15
range|:
literal|13
decl_stmt|;
name|uint64_t
name|stdf
range|:
literal|1
decl_stmt|;
comment|/**< STDF Bist Status. */
name|uint64_t
name|ppaf
range|:
literal|1
decl_stmt|;
comment|/**< PPAF Bist Status. */
name|uint64_t
name|lddf
range|:
literal|1
decl_stmt|;
comment|/**< LDDF Bist Status. */
else|#
directive|else
name|uint64_t
name|lddf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ppaf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stdf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_15
range|:
literal|13
decl_stmt|;
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_bist_ctl_sta_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_bist_ctl_sta
name|cvmx_eoi_bist_ctl_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_ctl_sta  *  * EOI_CTL_STA = EOI Configure Control Reigster  * This register configures EOI.  */
end_comment

begin_union
union|union
name|cvmx_eoi_ctl_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_ctl_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|ppaf_wm
range|:
literal|5
decl_stmt|;
comment|/**< Number of entries when PP Access FIFO will assert                                                          full (back pressure) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< 1: EOI is busy; 0: EOI is idle */
name|uint64_t
name|rwam
range|:
literal|2
decl_stmt|;
comment|/**< Rread Write Aribitration Mode:                                                          - 10: Reads  have higher priority                                                          - 01: Writes have higher priority                                                          00,11: Round-Robin between Reads and Writes */
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
comment|/**< When reset, all the inbound DMA accesses will be                                                          drop and all the outbound read response and write                                                          commits will be drop. It must be set to 1'b1 for                                                          normal access. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< EOI block Software Reset. */
else|#
directive|else
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwam
range|:
literal|2
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppaf_wm
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_ctl_sta_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_ctl_sta
name|cvmx_eoi_ctl_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_def_sta0  *  * Note: Working settings tabulated for each corner.  * ================================  * Corner pctl    nctl  * ===============================  *     1   26      22  *     2   30      28  *     3   32      31  *     4   23      19  *     5   27      24  *     6   29      27  *     7   21      17  *     8   25      22  *     9   27      24  *    10   29      24  *    11   34      31  *    12   36      35  *    13   26      21  *    14   31      27  *    15   33      30  *    16   23      18  *    17   28      24  *    18   30      27  *    19   21      17  *    20   27      25  *    21   29      28  *    22   21      17  *    23   25      22  *    24   27      25  *    25   19      15  *    26   23      20  *    27   25      22  *    28   24      24  *    29   28      31  *    30   30      35  *    31   21      21  *    32   25      27  *    33   27      30  *    34   19      18  *    35   23      24  *    36   25      27  *    37   29      19  *    38   33      25  *    39   36      28  *    40   25      17  *    41   30      22  *    42   32      25  *    43   23      15  *    44   27      20  *    45   29      22  * ===============================  *  *                   EOI_DEF_STA0 = EOI Defect Status Register 0  *  *  Register to hold repairout 0/1/2  */
end_comment

begin_union
union|union
name|cvmx_eoi_def_sta0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_def_sta0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|rout2
range|:
literal|18
decl_stmt|;
comment|/**< Repairout2 */
name|uint64_t
name|rout1
range|:
literal|18
decl_stmt|;
comment|/**< Repairout1 */
name|uint64_t
name|rout0
range|:
literal|18
decl_stmt|;
comment|/**< Repairout0 */
else|#
directive|else
name|uint64_t
name|rout0
range|:
literal|18
decl_stmt|;
name|uint64_t
name|rout1
range|:
literal|18
decl_stmt|;
name|uint64_t
name|rout2
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_def_sta0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_def_sta0
name|cvmx_eoi_def_sta0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_def_sta1  *  * EOI_DEF_STA1 = EOI Defect Status Register 1  *  * Register to hold repairout 3/4/5  */
end_comment

begin_union
union|union
name|cvmx_eoi_def_sta1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_def_sta1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|rout5
range|:
literal|18
decl_stmt|;
comment|/**< Repairout5 */
name|uint64_t
name|rout4
range|:
literal|18
decl_stmt|;
comment|/**< Repairout4 */
name|uint64_t
name|rout3
range|:
literal|18
decl_stmt|;
comment|/**< Repairout3 */
else|#
directive|else
name|uint64_t
name|rout3
range|:
literal|18
decl_stmt|;
name|uint64_t
name|rout4
range|:
literal|18
decl_stmt|;
name|uint64_t
name|rout5
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_def_sta1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_def_sta1
name|cvmx_eoi_def_sta1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_def_sta2  *  * EOI_DEF_STA2 = EOI Defect Status Register 2  *  * Register to hold repairout 6 and toomanydefects.  */
end_comment

begin_union
union|union
name|cvmx_eoi_def_sta2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_def_sta2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|toomany
range|:
literal|1
decl_stmt|;
comment|/**< Toomanydefects */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rout6
range|:
literal|18
decl_stmt|;
comment|/**< Repairout6 */
else|#
directive|else
name|uint64_t
name|rout6
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|toomany
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_def_sta2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_def_sta2
name|cvmx_eoi_def_sta2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_ecc_ctl  *  * EOI_ECC_CTL =  EOI ECC Control Register  *  * Description:  *   This register enables ECC for each individual internal memory that requires ECC. For debug purpose, it can also  *   control 1 or 2 bits be flipped in the ECC data.  */
end_comment

begin_union
union|union
name|cvmx_eoi_ecc_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_ecc_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|rben
range|:
literal|1
decl_stmt|;
comment|/**< 1: ECC Enable for read buffer                                                          - 0: ECC Enable for instruction buffer */
name|uint64_t
name|rbsf
range|:
literal|2
decl_stmt|;
comment|/**< read buffer ecc syndrome flip                                                          2'b00       : No Error Generation                                                          2'b10, 2'b01: Flip 1 bit                                                          2'b11       : Flip 2 bits */
else|#
directive|else
name|uint64_t
name|rbsf
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rben
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_ecc_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_ecc_ctl
name|cvmx_eoi_ecc_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_endor_bistr_ctl_sta  *  * EOI_ENDOR_BISTR_CTL_STA =  EOI BIST/BISR Control Status Register  *  * Description:  *   This register the bist result of EOI memories.  */
end_comment

begin_union
union|union
name|cvmx_eoi_endor_bistr_ctl_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_endor_bistr_ctl_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|bisr_done
range|:
literal|1
decl_stmt|;
comment|/**< Endor DSP Memroy Bisr Done Status: 1 - done;                                                          0 - Not done. */
name|uint64_t
name|failed
range|:
literal|1
decl_stmt|;
comment|/**< Bist/Bisr Status: 1 - failed; 0 - Not failed. */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|bisr_hr
range|:
literal|1
decl_stmt|;
comment|/**< BISR Hardrepair */
name|uint64_t
name|bisr_dir
range|:
literal|1
decl_stmt|;
comment|/**< BISR Direction: 0 = input repair packets;                                                          1 = output defect packets. */
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
comment|/**< Start Bist */
else|#
directive|else
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bisr_dir
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bisr_hr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|failed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bisr_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_endor_bistr_ctl_sta_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_endor_bistr_ctl_sta
name|cvmx_eoi_endor_bistr_ctl_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_endor_clk_ctl  *  * EOI_ENDOR_CLK_CTL = EOI Endor Clock Control  *  * Register control the generation of Endor DSP and HAB clocks.  */
end_comment

begin_union
union|union
name|cvmx_eoi_endor_clk_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_endor_clk_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|habclk_sel
range|:
literal|1
decl_stmt|;
comment|/**< HAB CLK select                                                          0x0: HAB CLK select from PHY_PLL output from HAB PS                                                          0x1: HAB CLK select from DDR_PLL output from HAB PS */
name|uint64_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsp_div_reset
range|:
literal|1
decl_stmt|;
comment|/**< DSP postscalar divider reset */
name|uint64_t
name|dsp_ps_en
range|:
literal|3
decl_stmt|;
comment|/**< DSP postscalar divide ratio                                                          Determines the DSP CK speed.                                                          0x0 : Divide DSP PLL output by 1                                                          0x1 : Divide DSP PLL output by 2                                                          0x2 : Divide DSP PLL output by 3                                                          0x3 : Divide DSP PLL output by 4                                                          0x4 : Divide DSP PLL output by 6                                                          0x5 : Divide DSP PLL output by 8                                                          0x6 : Divide DSP PLL output by 12                                                          0x7 : Divide DSP PLL output by 12                                                          DSP_PS_EN is not used when DSP_DIV_RESET = 1 */
name|uint64_t
name|hab_div_reset
range|:
literal|1
decl_stmt|;
comment|/**< HAB postscalar divider reset */
name|uint64_t
name|hab_ps_en
range|:
literal|3
decl_stmt|;
comment|/**< HAB postscalar divide ratio                                                          Determines the LMC CK speed.                                                          0x0 : Divide HAB PLL output by 1                                                          0x1 : Divide HAB PLL output by 2                                                          0x2 : Divide HAB PLL output by 3                                                          0x3 : Divide HAB PLL output by 4                                                          0x4 : Divide HAB PLL output by 6                                                          0x5 : Divide HAB PLL output by 8                                                          0x6 : Divide HAB PLL output by 12                                                          0x7 : Divide HAB PLL output by 12                                                          HAB_PS_EN is not used when HAB_DIV_RESET = 1 */
name|uint64_t
name|diffamp
range|:
literal|4
decl_stmt|;
comment|/**< PLL diffamp input transconductance */
name|uint64_t
name|cps
range|:
literal|3
decl_stmt|;
comment|/**< PLL charge-pump current */
name|uint64_t
name|cpb
range|:
literal|3
decl_stmt|;
comment|/**< PLL charge-pump current */
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
comment|/**< PLL reset */
name|uint64_t
name|clkf
range|:
literal|7
decl_stmt|;
comment|/**< Multiply reference by CLKF                                                          32<= CLKF<= 64                                                          PHY PLL frequency = 50 * CLKF                                                          min = 1.6 GHz, max = 3.2 GHz */
else|#
directive|else
name|uint64_t
name|clkf
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cps
range|:
literal|3
decl_stmt|;
name|uint64_t
name|diffamp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|hab_ps_en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|hab_div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsp_ps_en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dsp_div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|habclk_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_endor_clk_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_endor_clk_ctl
name|cvmx_eoi_endor_clk_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_endor_ctl  *  * EOI_ENDOR_CTL_STA = Endor Control Reigster  * This register controls Endor phy reset and access.  */
end_comment

begin_union
union|union
name|cvmx_eoi_endor_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_endor_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|r_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for data read from the L2C.                                                          IN:    A-B-C-D-E-F-G-H                                                          OUT0:  A-B-C-D-E-F-G-H                                                          OUT1:  H-G-F-E-D-C-B-A                                                          OUT2:  D-C-B-A-H-G-F-E                                                          OUT3:  E-F-G-H-A-B-C-D */
name|uint64_t
name|w_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for data written the L2C.                                                          IN:    A-B-C-D-E-F-G-H                                                          OUT0:  A-B-C-D-E-F-G-H                                                          OUT1:  H-G-F-E-D-C-B-A                                                          OUT2:  D-C-B-A-H-G-F-E                                                          OUT3:  E-F-G-H-A-B-C-D */
name|uint64_t
name|inv_rsl_ra2
range|:
literal|1
decl_stmt|;
comment|/**< Invert RSL CSR read  address bit 2. */
name|uint64_t
name|inv_rsl_wa2
range|:
literal|1
decl_stmt|;
comment|/**< Invert RSL CSR write address bit 2. */
name|uint64_t
name|inv_pp_ra2
range|:
literal|1
decl_stmt|;
comment|/**< Invert PP CSR read  address bit 2. */
name|uint64_t
name|inv_pp_wa2
range|:
literal|1
decl_stmt|;
comment|/**< Invert PP CSR write address bit 2. */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Endor block software reset. After hardware reset,                                                          this bit is set to 1'b1 which put Endor into reset                                                          state. Software must clear this bit to use Endor. */
else|#
directive|else
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|inv_pp_wa2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_pp_ra2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_rsl_wa2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_rsl_ra2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|w_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|r_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_endor_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_endor_ctl
name|cvmx_eoi_endor_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_int_ena  *  * EOI_INT_ENA = EOI Interrupt Enable Register  *  * Register to enable individual interrupt source in corresponding to EOI_INT_STA  */
end_comment

begin_union
union|union
name|cvmx_eoi_int_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_int_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|rb_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Read Buffer ECC DBE */
name|uint64_t
name|rb_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Read Buffer ECC SBE */
else|#
directive|else
name|uint64_t
name|rb_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rb_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_int_ena_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_int_ena
name|cvmx_eoi_int_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_int_sta  *  * EOI_INT_STA = EOI Interrupt Status Register  *  * Summary of different bits of RSL interrupt status.  */
end_comment

begin_union
union|union
name|cvmx_eoi_int_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_int_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|rb_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Read Buffer ECC DBE */
name|uint64_t
name|rb_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Read Buffer ECC SBE */
else|#
directive|else
name|uint64_t
name|rb_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rb_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_int_sta_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_int_sta
name|cvmx_eoi_int_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_io_drv  *  * EOI_IO_DRV = EOI Endor IO Drive Control  *  * Register to control Endor Phy IOs  */
end_comment

begin_union
union|union
name|cvmx_eoi_io_drv
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_io_drv_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|rfif_p
range|:
literal|6
decl_stmt|;
comment|/**< RFIF output driver P-Mos control */
name|uint64_t
name|rfif_n
range|:
literal|6
decl_stmt|;
comment|/**< RFIF output driver N-Mos control */
name|uint64_t
name|gpo_p
range|:
literal|6
decl_stmt|;
comment|/**< GPO  output driver P-Mos control */
name|uint64_t
name|gpo_n
range|:
literal|6
decl_stmt|;
comment|/**< GPO  output driver N-Mos control */
else|#
directive|else
name|uint64_t
name|gpo_n
range|:
literal|6
decl_stmt|;
name|uint64_t
name|gpo_p
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rfif_n
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rfif_p
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_io_drv_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_io_drv
name|cvmx_eoi_io_drv_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_eoi_throttle_ctl  *  * EOI_THROTTLE_CTL = EOI THROTTLE Control Reigster  * This register controls number of outstanding EOI loads to L2C . It is in phy_clock domain.  */
end_comment

begin_union
union|union
name|cvmx_eoi_throttle_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_eoi_throttle_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|std
range|:
literal|5
decl_stmt|;
comment|/**< Number of outstanding store data accepted by EOI on                                                          AXI before backpressure ADMA. The value must be from                                                          from 16 to 31 inclusively. */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|stc
range|:
literal|2
decl_stmt|;
comment|/**< Number of outstanding L2C store command accepted by                                                          EOI on AXI before backpressure ADMA. The value must be                                                          from 1 to 3 inclusively. */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ldc
range|:
literal|4
decl_stmt|;
comment|/**< Number of outstanding L2C loads. The value must be                                                          from 1 to 8 inclusively. */
else|#
directive|else
name|uint64_t
name|ldc
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|std
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_eoi_throttle_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_eoi_throttle_ctl
name|cvmx_eoi_throttle_ctl_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

