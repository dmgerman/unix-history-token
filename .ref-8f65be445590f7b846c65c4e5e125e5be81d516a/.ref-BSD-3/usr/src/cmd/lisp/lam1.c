begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*                                                                        */
end_comment

begin_comment
comment|/*   file: ccdfns.i                                                       */
end_comment

begin_comment
comment|/*   contents: LISP functions coded in C                                  */
end_comment

begin_comment
comment|/*                                                                        */
end_comment

begin_comment
comment|/*   These include LISP primitives, numeric and boolean functions and     */
end_comment

begin_comment
comment|/*   	predicates, some list-processing functions, i/o support functions */
end_comment

begin_comment
comment|/*  	and control flow functions (e.g. cont, break).                    */
end_comment

begin_comment
comment|/*   There are two types of functions: lambda (prefixed "L") and nlambda  */
end_comment

begin_comment
comment|/*	(prefixed "N"). 					  	  */
end_comment

begin_comment
comment|/*   Lambda's all call chkarg to insure that at least the minimum number  */
end_comment

begin_comment
comment|/* 	of necessary arguments are on the namestack.			  */
end_comment

begin_comment
comment|/*   All functions take their arguments from the namestack in a read-     */
end_comment

begin_comment
comment|/*  	only manner, and return their results via the normal C value	  */
end_comment

begin_comment
comment|/*	return mechanism.						  */
end_comment

begin_comment
comment|/*									  */
end_comment

begin_function
name|lispval
name|Leval
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
return|return
operator|(
name|eval
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lxcar
parameter_list|()
block|{
specifier|register
name|int
name|typ
decl_stmt|;
specifier|register
name|lispval
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|DTPR
operator|)
operator|||
operator|(
name|typ
operator|==
name|ATOM
operator|)
condition|)
return|return
operator|(
name|temp
operator|->
name|car
operator|)
return|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
name|result
operator|=
name|inewint
argument_list|(
name|temp
operator|->
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|error
argument_list|(
literal|"BAD ARG TO CAR"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lxcdr
parameter_list|()
block|{
specifier|register
name|int
name|typ
decl_stmt|;
specifier|register
name|lispval
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|DTPR
condition|)
return|return
operator|(
name|temp
operator|->
name|cdr
operator|)
return|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|CDR
operator|==
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
return|return
operator|(
name|temp
operator|->
name|CDR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|error
argument_list|(
literal|"BAD ARG TO CDR"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|cxxr
parameter_list|(
name|as
parameter_list|,
name|ds
parameter_list|)
specifier|register
name|int
name|as
decl_stmt|,
name|ds
decl_stmt|;
block|{
specifier|register
name|lispval
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|typ
decl_stmt|;
name|lispval
name|errorh
parameter_list|()
function_decl|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|temp
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|DTPR
condition|)
name|temp
operator|=
name|temp
operator|->
name|cdr
expr_stmt|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|CDR
operator|==
literal|0
condition|)
name|temp
operator|=
name|nil
expr_stmt|;
else|else
name|temp
operator|=
name|temp
operator|->
name|CDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"BAD ARG TO CDR"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|5
argument_list|,
name|temp
argument_list|)
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|as
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|temp
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|DTPR
condition|)
name|temp
operator|=
name|temp
operator|->
name|car
expr_stmt|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
name|temp2
operator|=
name|inewint
argument_list|(
name|temp
operator|->
name|i
argument_list|)
operator|,
name|temp
operator|=
name|temp2
expr_stmt|;
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"BAD ARG TO CAR"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|5
argument_list|,
name|temp
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcar
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcdr
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcadr
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcaar
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lc02r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|)
return|;
comment|/* cddr */
block|}
end_function

begin_function
name|lispval
name|Lc12r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
return|;
comment|/* caddr */
block|}
end_function

begin_function
name|lispval
name|Lc03r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|)
return|;
comment|/* cdddr */
block|}
end_function

begin_function
name|lispval
name|Lc13r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
return|;
comment|/* cadddr */
block|}
end_function

begin_function
name|lispval
name|Lc04r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
operator|)
return|;
comment|/* cddddr */
block|}
end_function

begin_function
name|lispval
name|Lc14r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
operator|)
return|;
comment|/* caddddr */
block|}
end_function

begin_comment
comment|/************************* *   *  (nthelem num list) * returns the num'th element of the list, by doing a caddddd...ddr * where there are num-1 d's * if num<=0 or greater than the length of the list, we return nil ******************************************************/
end_comment

begin_function
name|lispval
name|Lnthelem
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
operator|=
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
return|return
operator|(
name|error
argument_list|(
literal|"First arg to nthelem must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
name|i
operator|=
name|temp
operator|->
name|i
expr_stmt|;
comment|/* pick up the first arg */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
operator|++
name|lbot
expr_stmt|;
comment|/* fix lbot for call to cxxr() 'cadddd..r' */
name|temp
operator|=
name|cxxr
argument_list|(
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|lbot
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lscons
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|retp
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|int
name|typ
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|retp
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|handy
operator|=
operator|(
name|argp
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"First arg to scons must be an int."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retp
operator|->
name|I
operator|=
name|handy
operator|->
name|i
expr_stmt|;
name|handy
operator|=
operator|(
name|argp
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|retp
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|SDOT
condition|)
name|error
argument_list|(
literal|"Currently you may only link sdots to sdots."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retp
operator|->
name|CDR
operator|=
name|handy
expr_stmt|;
block|}
return|return
operator|(
name|retp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcons
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
name|lispval
name|retp
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|retp
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|retp
operator|->
name|cdr
operator|=
operator|(
operator|(
name|argp
operator|=
name|np
operator|-
literal|1
operator|)
operator|->
name|val
operator|)
expr_stmt|;
name|retp
operator|->
name|car
operator|=
operator|(
operator|--
name|argp
operator|)
operator|->
name|val
expr_stmt|;
return|return
operator|(
name|retp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CA
value|0
end_define

begin_define
define|#
directive|define
name|CD
value|1
end_define

begin_function
name|lispval
name|rpla
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
specifier|register
name|int
name|typ
decl_stmt|;
specifier|register
name|lispval
name|first
decl_stmt|,
name|second
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|argp
operator|=
name|np
operator|-
literal|1
expr_stmt|;
name|first
operator|=
operator|(
name|argp
operator|-
literal|1
operator|)
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|first
operator|==
name|nil
condition|)
name|first
operator|=
name|error
argument_list|(
literal|"Attempt to rplac[ad] nil."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|second
operator|=
name|argp
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|first
argument_list|)
operator|)
operator|==
name|DTPR
operator|)
operator|||
operator|(
name|typ
operator|==
name|ATOM
operator|)
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|CA
condition|)
name|first
operator|->
name|car
operator|=
name|second
expr_stmt|;
else|else
name|first
operator|->
name|cdr
operator|=
name|second
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|CA
condition|)
block|{
name|typ
operator|=
name|TYPE
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"Rplacca of a bignum will only replace INTS"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|first
operator|->
name|i
operator|=
name|second
operator|->
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|second
operator|==
name|nil
condition|)
name|first
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
else|else
name|first
operator|->
name|CDR
operator|=
name|second
expr_stmt|;
block|}
return|return
operator|(
name|first
operator|)
return|;
block|}
return|return
operator|(
name|error
argument_list|(
literal|"BAD ARG TO RPLA"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrplaca
parameter_list|()
block|{
return|return
operator|(
name|rpla
argument_list|(
name|CA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrplacd
parameter_list|()
block|{
return|return
operator|(
name|rpla
argument_list|(
name|CD
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Leq
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mynp
init|=
name|lbot
operator|+
name|AD
decl_stmt|;
name|int
name|itemp
decl_stmt|,
name|flag
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynp
operator|->
name|val
operator|==
operator|(
name|mynp
operator|+
literal|1
operator|)
operator|->
name|val
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnull
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|->
name|val
operator|==
name|nil
operator|)
condition|?
name|tatom
else|:
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lreturn **************************************************************/
end_comment

begin_comment
comment|/* Returns the first argument - which is nill if not specified.		*/
end_comment

begin_macro
name|Lreturn
argument_list|()
end_macro

begin_block
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|contval
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|reset
argument_list|(
name|BRRETN
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Lretbrk **************************************************************/
end_comment

begin_comment
comment|/* The first argument must be an integer and must be in the range	*/
end_comment

begin_comment
comment|/* -1 .. -depth.							*/
end_comment

begin_function
name|lispval
name|Lretbrk
parameter_list|()
block|{
name|lispval
name|number
decl_stmt|;
specifier|register
name|level
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|number
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|number
argument_list|)
operator|!=
name|INT
condition|)
name|level
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|level
operator|=
name|number
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
condition|)
name|level
operator|+=
name|depth
expr_stmt|;
name|contval
operator|=
operator|(
name|lispval
operator|)
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|depth
condition|)
name|reset
argument_list|(
name|BRRETB
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Linfile
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|name
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|name
argument_list|)
operator|!=
name|ATOM
condition|)
name|name
operator|=
name|error
argument_list|(
literal|"Please supply atom name for port."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* return nil if file couldnt be opened 	if ((port = fopen(name->pname,"r")) == NULL) return(nil); */
while|while
condition|(
operator|(
name|port
operator|=
name|fopen
argument_list|(
name|name
operator|->
name|pname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|name
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file for reading."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|xports
operator|+
operator|(
name|port
operator|-
name|_iob
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Loutfile
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|name
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|name
argument_list|)
operator|!=
name|ATOM
condition|)
name|name
operator|=
name|error
argument_list|(
literal|"Please supply atom name for port."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|port
operator|=
name|fopen
argument_list|(
name|name
operator|->
name|pname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|name
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file for writing."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|xports
operator|+
operator|(
name|port
operator|-
name|_iob
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lterpr
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lclose
parameter_list|()
block|{
name|lispval
name|port
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|port
operator|=
name|error
argument_list|(
literal|"Close requires one argument of type port"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|port
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|port
argument_list|)
operator|)
operator|==
name|PORT
condition|)
name|fclose
argument_list|(
name|port
operator|->
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnwritn
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|value
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|port
operator|->
name|_ptr
operator|-
name|port
operator|->
name|_base
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ldrain
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|int
name|iodes
decl_stmt|;
name|struct
name|sgttyb
name|arg
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|_flag
operator|&
name|_IOWRT
condition|)
block|{
name|fflush
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|port
operator|->
name|_flag
operator|&
name|_IOREAD
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|port
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|_ptr
operator|=
name|port
operator|->
name|_base
expr_stmt|;
name|iodes
operator|=
name|fileno
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
name|iodes
argument_list|,
operator|&
name|arg
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|stty
argument_list|(
name|iodes
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|xports
operator|+
operator|(
name|port
operator|-
name|_iob
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llist
parameter_list|()
block|{
comment|/* added for the benefit of mapping functions. */
specifier|register
name|struct
name|argent
modifier|*
name|ulim
decl_stmt|,
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|lispval
name|temp
decl_stmt|,
name|result
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|ulim
operator|=
name|np
expr_stmt|;
name|namptr
operator|=
name|lbot
operator|+
name|AD
expr_stmt|;
name|temp
operator|=
name|result
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|namptr
operator|<
name|ulim
condition|;
control|)
block|{
name|temp
operator|=
name|temp
operator|->
name|l
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|temp
operator|->
name|car
operator|=
operator|(
name|namptr
operator|++
operator|)
operator|->
name|val
expr_stmt|;
block|}
name|temp
operator|->
name|l
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|result
operator|->
name|l
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnumberp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
case|case
name|DOUB
case|:
case|case
name|SDOT
case|:
return|return
operator|(
name|tatom
operator|)
return|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Latom
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltype
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
return|return
operator|(
name|int_name
operator|)
return|;
case|case
name|ATOM
case|:
return|return
operator|(
name|atom_name
operator|)
return|;
case|case
name|SDOT
case|:
return|return
operator|(
name|sdot_name
operator|)
return|;
case|case
name|DOUB
case|:
return|return
operator|(
name|doub_name
operator|)
return|;
case|case
name|DTPR
case|:
return|return
operator|(
name|dtpr_name
operator|)
return|;
case|case
name|STRNG
case|:
return|return
operator|(
name|str_name
operator|)
return|;
case|case
name|ARRAY
case|:
return|return
operator|(
name|array_name
operator|)
return|;
case|case
name|BCD
case|:
return|return
operator|(
name|funct_name
operator|)
return|;
case|case
name|VALUE
case|:
return|return
operator|(
name|val_name
operator|)
return|;
case|case
name|PORT
case|:
return|return
operator|(
name|matom
argument_list|(
literal|"port"
argument_list|)
operator|)
return|;
comment|/* fix this when name exists */
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ldtpr
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|DTPR
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lbcdp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|BCD
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lportp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|PORT
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Larrayp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|ARRAY
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lset
parameter_list|()
block|{
name|lispval
name|varble
decl_stmt|;
name|snpand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|varble
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|varble
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
return|return
operator|(
name|varble
operator|->
name|clb
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
case|case
name|VALUE
case|:
return|return
operator|(
name|varble
operator|->
name|l
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
name|error
argument_list|(
literal|"IMPROPER USE OF SET"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Lequal
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|==
name|lbot
operator|->
name|val
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
if|if
condition|(
name|Iequal
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|Iequal
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
specifier|register
name|lispval
name|first
operator|,
name|second
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|type1
operator|,
name|type2
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lispval
name|Lsub
argument_list|()
decl_stmt|,
name|Lzerop
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|second
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|type1
operator|=
name|TYPE
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TYPE
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
if|if
condition|(
operator|(
name|type1
operator|==
name|SDOT
operator|&&
name|type2
operator|==
name|INT
operator|)
operator|||
operator|(
name|type1
operator|==
name|INT
operator|&&
name|type2
operator|==
name|SDOT
operator|)
condition|)
goto|goto
name|dosub
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|type1
condition|)
block|{
case|case
name|DTPR
case|:
return|return
operator|(
name|Iequal
argument_list|(
name|first
operator|->
name|car
argument_list|,
name|second
operator|->
name|car
argument_list|)
operator|&&
name|Iequal
argument_list|(
name|first
operator|->
name|cdr
argument_list|,
name|second
operator|->
name|cdr
argument_list|)
operator|)
return|;
case|case
name|DOUB
case|:
return|return
operator|(
name|first
operator|->
name|r
operator|==
name|second
operator|->
name|r
operator|)
return|;
case|case
name|INT
case|:
return|return
operator|(
operator|(
name|first
operator|->
name|i
operator|==
name|second
operator|->
name|i
operator|)
operator|)
return|;
name|dosub
label|:
case|case
name|SDOT
case|:
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|first
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|second
expr_stmt|;
name|lbot
operator|->
name|val
operator|=
name|Lsub
argument_list|()
expr_stmt|;
name|np
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|Lzerop
argument_list|()
operator|!=
name|nil
operator|)
return|;
case|case
name|VALUE
case|:
return|return
operator|(
name|first
operator|->
name|l
operator|==
name|second
operator|->
name|l
operator|)
return|;
case|case
name|STRNG
case|:
return|return
operator|(
name|strcmp
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Lprint
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkrtab
argument_list|(
name|Vreadtable
operator|->
name|clb
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|clb
argument_list|,
name|poport
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|okport
parameter_list|(
name|arg
parameter_list|,
name|proper
parameter_list|)
name|lispval
name|arg
decl_stmt|;
name|FILE
modifier|*
name|proper
decl_stmt|;
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|PORT
condition|)
return|return
operator|(
name|proper
operator|)
return|;
else|else
return|return
operator|(
name|arg
operator|->
name|p
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lpatom
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|FILE
modifier|*
name|port
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|temp
operator|=
name|Vreadtable
operator|->
name|clb
expr_stmt|;
name|chkrtab
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
operator|(
name|temp
operator|=
operator|(
name|lbot
operator|)
operator|->
name|val
operator|)
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|printr
argument_list|(
name|temp
argument_list|,
name|port
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|temp
operator|->
name|pname
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (pntlen thing) returns the length it takes to print out  * an atom or number.  */
end_comment

begin_function
name|lispval
name|Lpntlen
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|Ipntlen
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|Ipntlen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|char
modifier|*
name|handy
decl_stmt|;
name|temp
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|loop
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|handy
operator|=
name|temp
operator|->
name|pname
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|sprintf
argument_list|(
name|strbuf
argument_list|,
literal|"%d"
argument_list|,
name|temp
operator|->
name|i
argument_list|)
expr_stmt|;
name|handy
operator|=
name|strbuf
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|sprintf
argument_list|(
name|strbuf
argument_list|,
literal|"%g"
argument_list|,
name|temp
operator|->
name|r
argument_list|)
expr_stmt|;
name|handy
operator|=
name|strbuf
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
name|error
argument_list|(
literal|"Non atom or number to pntlen\n"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|(
name|strlen
argument_list|(
name|handy
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

