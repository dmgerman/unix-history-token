begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|NP
value|1000
end_define

begin_define
define|#
directive|define
name|INF
value|1.e37
end_define

begin_struct
struct|struct
name|proj
block|{
name|int
name|lbf
decl_stmt|,
name|ubf
decl_stmt|;
name|float
name|a
decl_stmt|,
name|b
decl_stmt|,
name|lb
decl_stmt|,
name|ub
decl_stmt|,
name|quant
decl_stmt|,
name|mult
decl_stmt|,
name|val
index|[
name|NP
index|]
decl_stmt|;
block|}
name|x
struct|,
name|y
struct|;
end_struct

begin_decl_stmt
name|float
modifier|*
name|diag
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|dx
init|=
literal|1.
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|ni
init|=
literal|100.
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|auta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|periodic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|konst
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|zero
init|=
literal|0.
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spline fit technique let x,y be vectors of abscissas and ordinates     h   be vector of differences h
comment|9i
comment|8=x
comment|9i
comment|8-x
comment|9i-1
comment|9
comment|8
comment|8     y"  be vector of 2nd derivs of approx function If the points are numbered 0,1,2,...,n+1 then y" satisfies (R W Hamming, Numerical Methods for Engineers and Scientists, 2nd Ed, p349ff) 	h
comment|9i
comment|8y"
comment|9i-1
comment|9
comment|8
comment|8+2(h
comment|9i
comment|8+h
comment|9i+1
comment|8)y"
comment|9i
comment|8+h
comment|9i+1
comment|8y"
comment|9i+1
comment|8 	 	= 6[(y
comment|9i+1
comment|8-y
comment|9i
comment|8)/h
comment|9i+1
comment|8-(y
comment|9i
comment|8-y
comment|9i-1
comment|8)/h
comment|9i
comment|8]   i=1,2,...,n  where y"
comment|90
comment|8 = y"
comment|9n+1
comment|8 = 0 This is a symmetric tridiagonal system of the form  	| a
comment|91
comment|8 h
comment|92
comment|8               |  |y"
comment|91
comment|8|      |b
comment|91
comment|8| 	| h
comment|92
comment|8 a
comment|92
comment|8 h
comment|93
comment|8            |  |y"
comment|92
comment|8|      |b
comment|92
comment|8| 	|    h
comment|93
comment|8 a
comment|93
comment|8 h
comment|94
comment|8         |  |y"
comment|93
comment|8|  =   |b
comment|93
comment|8| 	|         .           |  | .|      | .| 	|            .        |  | .|      | .| It can be triangularized into 	| d
comment|91
comment|8 h
comment|92
comment|8               |  |y"
comment|91
comment|8|      |r
comment|91
comment|8| 	|    d
comment|92
comment|8 h
comment|93
comment|8            |  |y"
comment|92
comment|8|      |r
comment|92
comment|8| 	|       d
comment|93
comment|8 h
comment|94
comment|8         |  |y"
comment|93
comment|8|  =   |r
comment|93
comment|8| 	|          .          |  | .|      | .| 	|             .       |  | .|      | .| where 	d
comment|91
comment|8 = a
comment|91
comment|8  	r
comment|90
comment|8 = 0  	d
comment|9i
comment|8 = a
comment|9i
comment|8 - h
comment|9i
comment|8
comment|82
comment|9/d
comment|9i-1
comment|8	1<i<
comment|_n  	r
comment|9i
comment|8 = b
comment|9i
comment|8 - h
comment|9i
comment|8r
comment|9i-1
comment|8/d
comment|9i-1
comment|i
comment|8	1<
comment|_i<
comment|_n  the back solution is 	y"
comment|9n
comment|8 = r
comment|9n
comment|8/d
comment|9n
comment|8  	y"
comment|9i
comment|8 = (r
comment|9i
comment|8-h
comment|9i+1
comment|8y"
comment|9i+1
comment|8)/d
comment|9i
comment|8	1<
comment|_i<n  superficially, d
comment|9i
comment|8 and r
comment|9i
comment|8 don't have to be stored for they can be recalculated backward by the formulas  	d
comment|9i-1
comment|8 = h
comment|9i
comment|8
comment|82
comment|9/(a
comment|9i
comment|8-d
comment|9i
comment|8)	1<i<
comment|_n  	r
comment|9i-1
comment|8 = (b
comment|9i
comment|8-r
comment|9i
comment|8)d
comment|9i-1
comment|8/h
comment|9i
comment|8	1<i<
comment|_n  unhappily it turns out that the recursion forward for d is quite strongly geometrically convergent--and is wildly unstable going backward. There's similar trouble with r, so the intermediate results must be kept.  Note that n-1 in the program below plays the role of n+1 in the theory  Other boundary conditions
comment|_________________________  The boundary conditions are easily generalized to handle  	y
comment|90
comment|8
comment|" = ky
comment|91
comment|8
comment|", y
comment|9n+1
comment|8
comment|"   = ky
comment|9n
comment|8
comment|"  for some constant k.  The above analysis was for k = 0; k = 1 fits parabolas perfectly as well as stright lines; k = 1/2 has been recommended as somehow pleasant.  All that is necessary is to add h
comment|91
comment|8 to a
comment|91
comment|8 and h
comment|9n+1
comment|8 to a
comment|9n
comment|8.   Periodic case
comment|_____________  To do this, add 1 more row and column thus  	| a
comment|91
comment|8 h
comment|92
comment|8            h
comment|91
comment|8 |  |y
comment|91
comment|8
comment|"|     |b
comment|91
comment|8| 	| h
comment|92
comment|8 a
comment|92
comment|8 h
comment|93
comment|8            |  |y
comment|92
comment|8
comment|"|     |b
comment|92
comment|8| 	|    h
comment|93
comment|8 a
comment|94
comment|8 h
comment|94
comment|8         |  |y
comment|93
comment|8
comment|"|     |b
comment|93
comment|8| 	|                     |  | .|  =  | .| 	|             .       |  | .|     | .| 	| h
comment|91
comment|8            h
comment|90
comment|8 a
comment|90
comment|8 |  | .|     | .|  where h
comment|90
comment|8=
comment|_ h
comment|9n+1
comment|8  The same diagonalization procedure works, except for the effect of the 2 corner elements.  Let s
comment|9i
comment|8 be the part of the last element in the i
comment|8th
comment|9 "diagonalized" row that arises from the extra top corner element.  		s
comment|91
comment|8 = h
comment|91
comment|8  		s
comment|9i
comment|8 = -s
comment|9i-1
comment|8h
comment|9i
comment|8/d
comment|9i-1
comment|8	2<
comment|_i<
comment|_n+1  After "diagonalizing", the lower corner element remains. Call t
comment|9i
comment|8 the bottom element that appears in the i
comment|8th
comment|9 colomn as the bottom element to its left is eliminated  		t
comment|91
comment|8 = h
comment|91
comment|8  		t
comment|9i
comment|8 = -t
comment|9i-1
comment|8h
comment|9i
comment|8/d
comment|9i-1
comment|8  Evidently t
comment|9i
comment|8 = s
comment|9i
comment|8. Elimination along the bottom row introduces further corrections to the bottom right element and to the last element of the right hand side. Call these corrections u and v.  	u
comment|91
comment|8 = v
comment|91
comment|8 = 0  	u
comment|9i
comment|8 = u
comment|9i-1
comment|8-s
comment|9i-1
comment|8*t
comment|9i-1
comment|8/d
comment|9i-1
comment|8  	v
comment|9i
comment|8 = v
comment|9i-1
comment|8-r
comment|9i-1
comment|8*t
comment|9i-1
comment|8/d
comment|9i-1
comment|8	2<
comment|_i<
comment|_n+1  The back solution is now obtained as follows  	y"
comment|9n+1
comment|8 = (r
comment|9n+1
comment|8+v
comment|9n+1
comment|8)/(d
comment|9n+1
comment|8+s
comment|9n+1
comment|8+t
comment|9n+1
comment|8+u
comment|9n+1
comment|8)  	y"
comment|9i
comment|8 = (r
comment|9i
comment|8-h
comment|9i+1
comment|8*y
comment|9i+1
comment|8-s
comment|9i
comment|8*y
comment|9n+1
comment|8)/d
comment|9i
comment|8	1<
comment|_i<
comment|_n  Interpolation in the interval x
comment|9i
comment|8<
comment|_x<
comment|_x
comment|9i+1
comment|8 is by the formula  	y = y
comment|9i
comment|8x
comment|9+
comment|8 + y
comment|9i+1
comment|8x
comment|9-
comment|8 -(h
comment|82
comment|9
comment|9i+1
comment|8/6)[y"
comment|9i
comment|8(x
comment|9+
comment|8-x
comment|9+
comment|8
comment|8
comment|3
comment|9)+y"
comment|9i+1
comment|8(x
comment|9-
comment|8-x
comment|9-
comment|8
comment|83
comment|9)] where 	x
comment|9+
comment|8 = x
comment|9i+1
comment|8-x  	x
comment|9-
comment|8 = x-x
comment|9i
comment|8 */
end_comment

begin_function
name|float
name|rhs
parameter_list|(
name|i
parameter_list|)
block|{
name|int
name|i_
decl_stmt|;
name|double
name|zz
decl_stmt|;
name|i_
operator|=
name|i
operator|==
name|n
operator|-
literal|1
condition|?
literal|0
else|:
name|i
expr_stmt|;
name|zz
operator|=
operator|(
name|y
operator|.
name|val
index|[
name|i
index|]
operator|-
name|y
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|/
operator|(
name|x
operator|.
name|val
index|[
name|i
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
return|return
operator|(
literal|6
operator|*
operator|(
operator|(
name|y
operator|.
name|val
index|[
name|i_
operator|+
literal|1
index|]
operator|-
name|y
operator|.
name|val
index|[
name|i_
index|]
operator|)
operator|/
operator|(
name|x
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
index|]
operator|)
operator|-
name|zz
operator|)
operator|)
return|;
block|}
end_function

begin_macro
name|spline
argument_list|()
end_macro

begin_block
block|{
name|float
name|d
decl_stmt|,
name|s
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|hi
decl_stmt|,
name|hi1
decl_stmt|;
name|float
name|h
decl_stmt|;
name|float
name|D2yi
decl_stmt|,
name|D2yi1
decl_stmt|,
name|D2yn1
decl_stmt|,
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|yy
decl_stmt|,
name|a
decl_stmt|;
name|int
name|end
decl_stmt|;
name|float
name|corr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|periodic
condition|)
name|konst
operator|=
literal|0
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|periodic
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|++
name|i
operator|<
name|n
operator|-
operator|!
name|periodic
condition|;
control|)
block|{
comment|/* triangularize */
name|hi
operator|=
name|x
operator|.
name|val
index|[
name|i
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|hi1
operator|=
name|i
operator|==
name|n
operator|-
literal|1
condition|?
name|x
operator|.
name|val
index|[
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
literal|0
index|]
else|:
name|x
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hi1
operator|*
name|hi
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|u
operator|=
name|i
operator|==
literal|1
condition|?
name|zero
else|:
name|u
operator|-
name|s
operator|*
name|s
operator|/
name|d
expr_stmt|;
name|v
operator|=
name|i
operator|==
literal|1
condition|?
name|zero
else|:
name|v
operator|-
name|s
operator|*
name|r
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|d
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
name|rhs
argument_list|(
name|i
argument_list|)
operator|-
name|hi
operator|*
name|r
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|d
expr_stmt|;
name|s
operator|=
operator|-
name|hi
operator|*
name|s
operator|/
name|d
expr_stmt|;
name|a
operator|=
literal|2
operator|*
operator|(
name|hi
operator|+
name|hi1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|2
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi1
expr_stmt|;
name|diag
index|[
name|i
index|]
operator|=
name|d
operator|=
name|i
operator|==
literal|1
condition|?
name|a
else|:
name|a
operator|-
name|hi
operator|*
name|hi
operator|/
name|d
expr_stmt|;
block|}
name|D2yi
operator|=
name|D2yn1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
operator|!
name|periodic
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* back substitute */
name|end
operator|=
name|i
operator|==
name|n
operator|-
literal|1
expr_stmt|;
name|hi1
operator|=
name|end
condition|?
name|x
operator|.
name|val
index|[
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
literal|0
index|]
else|:
name|x
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
index|]
expr_stmt|;
name|D2yi1
operator|=
name|D2yi
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|hi
operator|=
name|x
operator|.
name|val
index|[
name|i
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|corr
operator|=
name|end
condition|?
literal|2
operator|*
name|s
operator|+
name|u
else|:
name|zero
expr_stmt|;
name|D2yi
operator|=
operator|(
name|end
operator|*
name|v
operator|+
name|r
index|[
name|i
index|]
operator|-
name|hi1
operator|*
name|D2yi1
operator|-
name|s
operator|*
name|D2yn1
operator|)
operator|/
operator|(
name|diag
index|[
name|i
index|]
operator|+
name|corr
operator|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
name|D2yn1
operator|=
name|D2yi
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|a
operator|=
literal|2
operator|*
operator|(
name|hi
operator|+
name|hi1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|2
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi1
expr_stmt|;
name|d
operator|=
name|diag
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|s
operator|=
operator|-
name|s
operator|*
name|d
operator|/
name|hi
expr_stmt|;
block|}
block|}
else|else
name|D2yi
operator|=
name|D2yn1
expr_stmt|;
if|if
condition|(
operator|!
name|periodic
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|D2yi
operator|=
name|konst
operator|*
name|D2yi1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|2
condition|)
name|D2yi1
operator|=
name|konst
operator|*
name|D2yi
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
continue|continue;
name|m
operator|=
name|hi1
operator|>
literal|0
condition|?
name|ni
else|:
operator|-
name|ni
expr_stmt|;
name|m
operator|=
literal|1.001
operator|*
name|m
operator|*
name|hi1
operator|/
operator|(
name|x
operator|.
name|ub
operator|-
name|x
operator|.
name|lb
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
name|h
operator|=
name|hi1
operator|/
name|m
expr_stmt|;
for|for
control|(
name|j
operator|=
name|m
init|;
name|j
operator|>
literal|0
operator|||
name|i
operator|==
literal|0
operator|&&
name|j
operator|==
literal|0
condition|;
name|j
operator|--
control|)
block|{
comment|/* interpolate */
name|x0
operator|=
operator|(
name|m
operator|-
name|j
operator|)
operator|*
name|h
operator|/
name|hi1
expr_stmt|;
name|x1
operator|=
name|j
operator|*
name|h
operator|/
name|hi1
expr_stmt|;
name|yy
operator|=
name|D2yi
operator|*
operator|(
name|x0
operator|-
name|x0
operator|*
name|x0
operator|*
name|x0
operator|)
operator|+
name|D2yi1
operator|*
operator|(
name|x1
operator|-
name|x1
operator|*
name|x1
operator|*
name|x1
operator|)
expr_stmt|;
name|yy
operator|=
name|y
operator|.
name|val
index|[
name|i
index|]
operator|*
name|x0
operator|+
name|y
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|x1
operator|-
name|hi1
operator|*
name|hi1
operator|*
name|yy
operator|/
literal|6
expr_stmt|;
name|printf
argument_list|(
literal|"%f "
argument_list|,
name|x
operator|.
name|val
index|[
name|i
index|]
operator|+
name|j
operator|*
name|h
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%f\n"
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|readin
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NP
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|auta
condition|)
name|x
operator|.
name|val
index|[
name|n
index|]
operator|=
name|n
operator|*
name|dx
operator|+
name|x
operator|.
name|lb
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getfloat
argument_list|(
operator|&
name|x
operator|.
name|val
index|[
name|n
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|getfloat
argument_list|(
operator|&
name|y
operator|.
name|val
index|[
name|n
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
end_block

begin_macro
name|getfloat
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|float
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|buf
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
continue|continue;
block|}
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
continue|continue;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
continue|continue;
block|}
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
operator|*
name|p
operator|=
name|atof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getlim
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proj
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|lbf
operator|&&
name|p
operator|->
name|lb
operator|>
operator|(
name|p
operator|->
name|val
index|[
name|i
index|]
operator|)
condition|)
name|p
operator|->
name|lb
operator|=
name|p
operator|->
name|val
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ubf
operator|&&
name|p
operator|->
name|ub
operator|<
operator|(
name|p
operator|->
name|val
index|[
name|i
index|]
operator|)
condition|)
name|p
operator|->
name|ub
operator|=
name|p
operator|->
name|val
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|x
operator|.
name|lbf
operator|=
name|x
operator|.
name|ubf
operator|=
name|y
operator|.
name|lbf
operator|=
name|y
operator|.
name|ubf
operator|=
literal|0
expr_stmt|;
name|x
operator|.
name|lb
operator|=
name|INF
expr_stmt|;
name|x
operator|.
name|ub
operator|=
operator|-
name|INF
expr_stmt|;
name|y
operator|.
name|lb
operator|=
name|INF
expr_stmt|;
name|y
operator|.
name|ub
operator|=
operator|-
name|INF
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|argv
index|[
literal|0
index|]
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'a'
case|:
name|auta
operator|=
literal|1
expr_stmt|;
name|numb
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|numb
argument_list|(
operator|&
name|konst
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|numb
argument_list|(
operator|&
name|ni
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|periodic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|x
operator|.
name|lb
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
name|x
operator|.
name|lbf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|x
operator|.
name|ub
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
name|x
operator|.
name|ubf
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad agrument\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|auta
operator|&&
operator|!
name|x
operator|.
name|lbf
condition|)
name|x
operator|.
name|lb
operator|=
literal|0
expr_stmt|;
name|readin
argument_list|()
expr_stmt|;
name|getlim
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|getlim
argument_list|(
operator|&
name|y
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|diag
operator|=
operator|(
name|float
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|float
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
operator|||
operator|!
name|spline
argument_list|()
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%f "
argument_list|,
name|x
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%f\n"
argument_list|,
name|y
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|numb
argument_list|(
argument|np
argument_list|,
argument|argcp
argument_list|,
argument|argvp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|argcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|atof
parameter_list|()
function_decl|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|argcp
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|np
operator|=
name|atof
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argcp
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|argvp
operator|)
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

