begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: ip_input.c,v 1.39 85/07/31 09:31:26 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/domain.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../net/raw_cb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HMP
end_ifdef

begin_include
include|#
directive|include
file|"../bbnnet/hmp_traps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsiphdr
index|[]
init|=
name|RCSIPHDR
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|rawreaders
parameter_list|(
name|r
parameter_list|)
value|((r)->rcb_next != (r))
end_define

begin_define
define|#
directive|define
name|any_rawreaders
parameter_list|()
value|rawreaders(&rawcb)
end_define

begin_define
define|#
directive|define
name|FIELD_OFF
parameter_list|(
name|fld
parameter_list|,
name|type
parameter_list|)
value|(((char *) (&(((type *) 0)->fld))) - ((char *) 0))
end_define

begin_decl_stmt
name|struct
name|in_stat
name|otherstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ip_stat
name|ipstat
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|struct
name|ipq
modifier|*
name|n_ip_head
decl_stmt|;
comment|/* -> top of ip reass. queue */
name|struct
name|ipq
modifier|*
name|n_ip_tail
decl_stmt|;
comment|/* -> end of ip reass. queue */
block|}
name|ipfrags
struct|;
end_struct

begin_comment
comment|/*  * The protocol layers above IP assume the IP header and the protocol  * header are contiguous.  However, need to save the options in case  * a connection oriented protocol (RDP/TCP) wants to respond to an  * incoming packet (SYN) over the same route if the packet got here  * using IP source routing.  This allows connection establishment and  * maintenance when the remote end is on a network that is not known  * to our gateways.  Only applicable options are Loose/Strict source  * routing, so rather than saving them in ip_stripopt() and reinterpreting  * them, we'll set up something specific and appropriate here.  */
end_comment

begin_decl_stmt
name|int
name|nosum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip_nhops
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|ip_hops
index|[
name|MAX_IPOPTLEN
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use a dispatch table for protocol dispatching */
end_comment

begin_decl_stmt
name|struct
name|ipswitch
name|ipsw
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|ip
modifier|*
name|ip_reass
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|ip_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_IP
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
comment|/* build our internal switch table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ipsw
index|[
name|i
index|]
operator|.
name|ipsw_raw
operator|=
name|pr
expr_stmt|;
name|ipsw
index|[
name|i
index|]
operator|.
name|ipsw_user
operator|=
literal|0
expr_stmt|;
name|ipsw
index|[
name|i
index|]
operator|.
name|ipsw_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pr
operator|=
name|inetdomain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
name|inetdomain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_protocol
operator|>=
name|IPPROTO_MAX
condition|)
name|panic
argument_list|(
literal|"ip_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_type
operator|==
name|SOCK_RAW
condition|)
name|ipsw
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|.
name|ipsw_raw
operator|=
name|pr
expr_stmt|;
else|else
name|ipsw
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|.
name|ipsw_user
operator|=
name|pr
expr_stmt|;
block|}
name|ipintrq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/* got a better number? */
block|}
end_block

begin_comment
comment|/*  * Being global might be a little gross, but we just got the interface pointer  * passed up the week before 4.3 release.  */
end_comment

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|inetifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IP network software interrupt service routine.  Dequeue a message from the  * ip input queue, and pass to internal ip input processor (ip_input).  */
end_comment

begin_macro
name|ipintr
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|panicstr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
comment|/*      * Half-hearted attempt to prevent recursive panics due to network      * bugs since panic calls boot, which lowers spl.  Note that the      * drivers will still store packets in mbufs and that some processing      * (ARP, Chaosnet) that occurs at splimp() will still proceed.  At      * least this should preserve state information for post-mortem.      */
if|if
condition|(
name|panicstr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* for 4.3, Berkeley finally changed imp code to queue up messages 	     * for ctlinput path, so don't need to check for them here with our 	     * old queueing mechanism 	     */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUEIF
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|,
name|inetifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|ip_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * IP level input routine   *  * Called from local net level upon recpt of an internet datagram or fragment.  * This routine does fragment reassembly, if necessary, and passes completed  * datagrams to higher level protocol processing routines on the basis of the   * ip header protocol field.  It is passed a pointer to an mbuf chain   * containing the datagram/fragment. The mbuf offset+length are set to point   * at the ip header.  */
end_comment

begin_expr_stmt
name|ip_input
argument_list|(
name|mp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
name|fragsize
init|=
literal|0
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|inpcb
name|fwdinp
decl_stmt|;
name|ipstat
operator|.
name|ip_total
operator|++
expr_stmt|;
comment|/*      * make sure dtom() macro works by getting header out of mbufs using      * pages, also make sure header contiguous in first mbuf.      */
if|if
condition|(
operator|(
name|mp
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * Might as well avoid doing m_pullup twice. 	 * Common case is using cluster for large chunk of data. 	 */
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<
name|FIELD_OFF
argument_list|(
name|ip_p
argument_list|,
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|ip_p
argument_list|)
condition|)
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
else|else
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|i
operator|=
name|ipsw
index|[
name|ip
operator|->
name|ip_p
index|]
operator|.
name|ipsw_hlen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mp
operator|=
name|m_pullup
argument_list|(
name|mp
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipstat
operator|.
name|ip_tooshort
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/*      * make sure header does not overflow mbuf  (is contiguous)      */
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
name|IP_HLSHIFT
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|mp
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|m_pullup
argument_list|(
name|mp
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ip_log
argument_list|(
name|ip
argument_list|,
literal|"ip header overflow"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_IP_OVFLO, (caddr_t)0,0); */
else|#
directive|else
comment|/* netlog(mp); no longer have mbuf list */
endif|#
directive|endif
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/*      * Adjust msg length to remove any driver padding.  Make sure that       * message length matches ip length.      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
name|mp
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|i
operator|-=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
condition|)
name|m_adj
argument_list|(
name|mp
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|ip_log
argument_list|(
name|ip
argument_list|,
literal|"truncated ip packet"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_IP_TRUNC, (caddr_t)0, 0); */
else|#
directive|else
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
else|else
name|m
operator|->
name|m_len
operator|-=
name|i
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_sum
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
comment|/* used to do inline cksum here via sed */
if|if
condition|(
name|i
operator|!=
operator|(
name|j
operator|=
operator|(
name|u_short
operator|)
name|in_cksum
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|,
name|hlen
argument_list|)
operator|)
condition|)
block|{
name|ipstat
operator|.
name|ip_badsum
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nosum
condition|)
block|{
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_IP_CKSUM, (caddr_t)0,0); */
endif|#
directive|endif
name|inet_cksum_err
argument_list|(
literal|"ip"
argument_list|,
name|ip
argument_list|,
operator|(
name|u_long
operator|)
name|i
argument_list|,
operator|(
name|u_long
operator|)
name|j
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|i
expr_stmt|;
name|ic_errmsg
argument_list|(
name|icmp_addr
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ICMP_PARM
argument_list|,
literal|0
argument_list|,
name|FIELD_OFF
argument_list|(
name|ip_sum
argument_list|,
expr|struct
name|ip
argument_list|)
argument_list|,
name|hlen
operator|+
name|ICMP_ERRLEN
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|)
expr_stmt|;
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*      * Make sure this packet is addressed to us before we put fields      * in host order and do reassembly (fragments may reach destination      * by separate routes.)      * Remember that IP source routing option can change ip_dst, so have      * to do option processing for all incoming packets with options.      * Even if the packet turns out to be for us and we strip them.      */
name|fwdinp
operator|.
name|inp_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
comment|/* in case fwd, but no options */
name|ip_nhops
operator|=
literal|0
expr_stmt|;
comment|/* for source routed TCP/RDP... connections */
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
comment|/* 	 * Any route allocated by ip_opt() 1. will be used by 	 * ip_forward(), and 2. will only be needed by ip_forward() 	 */
if|if
condition|(
operator|!
name|ip_opt
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|,
operator|&
name|fwdinp
argument_list|)
condition|)
block|{
name|ip_log
argument_list|(
name|ip
argument_list|,
literal|"ip option error"
argument_list|)
expr_stmt|;
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * if packet is not for us then forward      */
if|if
condition|(
operator|(
name|ia
operator|=
name|in_iawithaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ip_forward
argument_list|(
operator|&
name|fwdinp
argument_list|,
name|ip
argument_list|,
name|mp
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* length of data */
name|ip_log
argument_list|(
name|ip
argument_list|,
literal|"ip header length error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_IP_HLEN, (caddr_t)0,0); */
else|#
directive|else
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_mff
operator|=
operator|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|ip_mf
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|<<=
name|IP_OFFSHIFT
expr_stmt|;
comment|/* look for chain on reassembly queue with this header */
for|for
control|(
name|fp
operator|=
name|ipfrags
operator|.
name|n_ip_head
init|;
operator|(
name|fp
operator|!=
name|NULL
operator|&&
operator|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_src
operator|.
name|s_addr
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_dst
operator|.
name|s_addr
operator|||
name|ip
operator|->
name|ip_id
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_id
operator|||
name|ip
operator|->
name|ip_p
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_p
operator|)
operator|)
condition|;
name|fp
operator|=
name|fp
operator|->
name|iq_next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|ip_mff
operator|&&
name|ip
operator|->
name|ip_off
operator|==
literal|0
condition|)
block|{
comment|/* not fragmented */
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* free existing reass chain */
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
name|struct
name|ip
modifier|*
name|p
decl_stmt|;
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* free mbufs assoc. w/chain */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
name|p
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* free header */
block|}
comment|/* 	 * The options aren't of any use to higher level 	 * protocols or of any concern to the user process. 	 */
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_stripopt
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|ip_reass
argument_list|(
name|ip
argument_list|,
name|fp
argument_list|,
operator|&
name|fragsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* call next level with completed datagram */
comment|/* any raw readers?? */
comment|/* if (rawreaders((struct rawcb *)ipsw[ip->ip_p].ipsw_raw->pr_ppcbq)) */
if|if
condition|(
name|any_rawreaders
argument_list|()
condition|)
block|{
name|otherstat
operator|.
name|in_total
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|m_copy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
condition|)
name|ipsw
index|[
name|ip
operator|->
name|ip_p
index|]
operator|.
name|ipsw_raw
operator|->
name|pr_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
comment|/* wish I didn't need this special case for fragsize */
name|tcp_input
argument_list|(
name|mp
argument_list|,
name|fragsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ipsw
index|[
name|ip
operator|->
name|ip_p
index|]
operator|.
name|ipsw_user
operator|!=
literal|0
condition|)
comment|/* There's a protocol implementation for these packets */
name|ipsw
index|[
name|ip
operator|->
name|ip_p
index|]
operator|.
name|ipsw_user
operator|->
name|pr_input
argument_list|(
name|mp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
comment|/* 	 * Since don't want user to get a non-raw ICMP socket, did not make 	 * an entry in the protocol jump table; also wanted to be able to 	 * make raw ICMP socket. 	 */
name|icmp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 	 * Don't bother everyone on the net, and remember some other 	 * host may support the protocol. 	 */
if|if
condition|(
operator|(
operator|!
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|)
condition|)
name|ic_errmsg
argument_list|(
name|icmp_addr
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ICMP_UNRCH
argument_list|,
name|ICMP_UNRCH_PR
argument_list|,
name|FIELD_OFF
argument_list|(
name|ip_p
argument_list|,
expr|struct
name|ip
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|ICMP_ERRLEN
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|)
expr_stmt|;
comment|/* get rid of the packet */
name|ipstat
operator|.
name|ip_drops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * We've received an IP fragment.  Try to perform IP reassembly.  */
end_comment

begin_function
name|struct
name|ip
modifier|*
name|ip_reass
parameter_list|(
name|ip
parameter_list|,
name|fp
parameter_list|,
name|fragsize
parameter_list|)
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
modifier|*
name|fragsize
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|,
modifier|*
name|savq
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mp
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
name|IP_HLSHIFT
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Only the first fragment retains the IP header. 	 */
name|mp
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
name|mp
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This is the first fragment of the IP datagram that we've 	 * received.  Set up reassembly q header. 	 */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_FTABLE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ipq
operator|*
argument_list|)
expr_stmt|;
name|fp
operator|->
name|iqx
operator|.
name|ip_next
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_prev
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|iqh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|iqx
operator|.
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
name|fp
operator|->
name|iq_size
operator|=
literal|0
expr_stmt|;
comment|/* 	 * and enter this into the list of fragmented IP datagrams 	 */
name|fp
operator|->
name|iq_next
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|iq_prev
operator|=
name|ipfrags
operator|.
name|n_ip_tail
expr_stmt|;
if|if
condition|(
name|ipfrags
operator|.
name|n_ip_head
operator|!=
name|NULL
condition|)
name|ipfrags
operator|.
name|n_ip_tail
operator|->
name|iq_next
operator|=
name|fp
expr_stmt|;
else|else
name|ipfrags
operator|.
name|n_ip_head
operator|=
name|fp
expr_stmt|;
name|ipfrags
operator|.
name|n_ip_tail
operator|=
name|fp
expr_stmt|;
block|}
comment|/*      * Merge fragment into reass.q      *      * Algorithm:   Match  start  and  end  bytes  of new      * fragment  with  fragments  on  the  queue.   If no      * overlaps  are  found,  add  new  frag. to the queue.      * Otherwise, adjust start and end of new frag.  so  no      * overlap   and   add  remainder  to  queue.   If  any      * fragments are completely covered by the new one,  or      * if  the  new  one is completely duplicated, free the      * fragments.      */
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* -> top of reass. chain */
name|ip
operator|->
name|ip_end
operator|=
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|-
literal|1
expr_stmt|;
comment|/* record the maximum fragment size for TCP */
name|fp
operator|->
name|iq_size
operator|=
name|MAX
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|,
name|fp
operator|->
name|iq_size
argument_list|)
expr_stmt|;
comment|/* skip frags which new doesn't overlap at end */
while|while
condition|(
operator|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_off
operator|>
name|q
operator|->
name|ip_end
operator|)
condition|)
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
if|if
condition|(
name|q
operator|==
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
comment|/* frag at end of chain */
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|fp
operator|->
name|iqx
operator|.
name|ip_prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* frag doesn't overlap any */
if|if
condition|(
name|ip
operator|->
name|ip_end
operator|<
name|q
operator|->
name|ip_off
condition|)
block|{
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|q
operator|->
name|ip_prev
argument_list|)
expr_stmt|;
comment|/* new overlaps beginning of next frag only */
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_end
operator|<
name|q
operator|->
name|ip_end
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|ip
operator|->
name|ip_end
operator|-
name|q
operator|->
name|ip_off
operator|+
literal|1
operator|)
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_end
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|mp
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|q
operator|->
name|ip_prev
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* new overlaps end of previous frag */
block|}
else|else
block|{
name|savq
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|<=
name|q
operator|->
name|ip_off
condition|)
block|{
comment|/* complete cover */
name|savq
operator|=
name|q
operator|->
name|ip_prev
expr_stmt|;
name|ip_deq
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* overlap */
if|if
condition|(
operator|(
name|i
operator|=
name|q
operator|->
name|ip_end
operator|-
name|ip
operator|->
name|ip_off
operator|+
literal|1
operator|)
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|ip
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|mp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* new overlaps at beginning of successor frags */
name|q
operator|=
name|savq
operator|->
name|ip_next
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|q
operator|->
name|ip_off
operator|<=
name|ip
operator|->
name|ip_end
operator|)
condition|)
comment|/* complete cover */
if|if
condition|(
name|q
operator|->
name|ip_end
operator|<=
name|ip
operator|->
name|ip_end
condition|)
block|{
name|struct
name|ip
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
name|ip_deq
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* overlap */
if|if
condition|(
operator|(
name|i
operator|=
name|ip
operator|->
name|ip_end
operator|-
name|q
operator|->
name|ip_off
operator|+
literal|1
operator|)
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_end
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|mp
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* enqueue whatever is left of new before successors */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|!=
literal|0
condition|)
block|{
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|savq
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for completed fragment reassembly */
if|if
condition|(
operator|(
name|i
operator|=
name|ip_done
argument_list|(
operator|&
name|fp
operator|->
name|iqx
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* -> top mbuf */
name|ip
operator|->
name|ip_len
operator|=
name|i
expr_stmt|;
comment|/* total data length */
operator|*
name|fragsize
operator|=
name|fp
operator|->
name|iq_size
expr_stmt|;
comment|/* remember for TCP */
comment|/* option processing */
if|if
condition|(
operator|(
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
name|IP_HLSHIFT
operator|)
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_stripopt
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip_mergef
argument_list|(
operator|&
name|fp
operator|->
name|iqx
argument_list|)
expr_stmt|;
comment|/* clean frag chain */
comment|/* copy src/dst internet address to header mbuf */
name|ip
operator|->
name|ip_src
operator|=
name|fp
operator|->
name|iqh
operator|.
name|ip_src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|fp
operator|->
name|iqh
operator|.
name|ip_dst
expr_stmt|;
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* dequeue header */
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Let people control gateway action by patching this:  */
end_comment

begin_decl_stmt
name|int
name|ip_forwarding
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Try to forward the packet.  Act like a gateway.  */
end_comment

begin_macro
name|ip_forward
argument_list|(
argument|fwdinp
argument_list|,
argument|ip
argument_list|,
argument|mp
argument_list|,
argument|hlen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|fwdinp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|type
decl_stmt|,
name|code
decl_stmt|;
specifier|register
name|u_short
name|len
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mcopy
decl_stmt|;
specifier|register
name|unsigned
name|icmplen
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/*      * Also copy forwarded packets, just like copy TCP/UDP/RDP...      * packets sent to us so that can debug gateway action problems.      * It's easy enough for the user-level program to filter these      * out.      */
if|if
condition|(
name|any_rawreaders
argument_list|()
condition|)
if|if
condition|(
name|mcopy
operator|=
name|m_copy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
condition|)
name|raw_ip_input
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_ttl
condition|)
name|ip
operator|->
name|ip_ttl
operator|--
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|icmplen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|hlen
operator|+
name|ICMP_ERRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip_forwarding
operator|&&
name|ip
operator|->
name|ip_ttl
condition|)
block|{
comment|/* 	 * Save chunk of ip packet in case there is an error 	 */
name|mcopy
operator|=
name|m_copy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|icmplen
argument_list|)
expr_stmt|;
comment|/* 	 * The packet is not sourced by the local machine, so 	 * save ourselves a useless call to ip_route in ip_send(). 	 * Also, don't want ip_send to work if sending from 	 * 8.7.0.2 to 192.1.11.1 via 8.0.0.16, and 8.0.0.16 	 * knows about a default gateway on net 8.  This can 	 * cause an ENETUNREACH if 192.1.11 is not a network 	 * that default gateway knows about.  [8.0.0.16 is on 	 * 192.1.11 and ip_route uses default gateway on net 8 	 * while rtalloc uses local interface] 	 * 	 * This route should be found by rtalloc, so let's do 	 * it here. 	 */
if|if
condition|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* Isn't a source routed packet */
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|fwdinp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwdinp
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_dst
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|fwdinp
operator|->
name|inp_route
argument_list|)
expr_stmt|;
comment|/* 	     * Check to see if should send ICMP redirect.  Don't 	     * send redirect if source routing was used. 	     */
if|if
condition|(
operator|(
name|rt
operator|=
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_GATEWAY
operator||
name|RTF_HOST
operator|)
operator|)
condition|)
name|send_redirect
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ICMP_REDIR_HOST
argument_list|,
name|icmplen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iptonet
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
operator|==
name|iptonet
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
name|send_redirect
argument_list|(
name|ip
argument_list|,
name|sin
operator|->
name|sin_addr
argument_list|,
name|ICMP_REDIR_NET
argument_list|,
name|icmplen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* no way to get there from here */
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
name|code
operator|=
name|ICMP_UNRCH_NET
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ip_send
argument_list|(
name|fwdinp
argument_list|,
name|mp
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rtfree
argument_list|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ipstat
operator|.
name|ip_forwarded
operator|++
expr_stmt|;
if|if
condition|(
name|mcopy
condition|)
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
name|code
operator|=
name|ICMP_UNRCH_NET
expr_stmt|;
break|break;
case|case
name|EMSGSIZE
case|:
name|code
operator|=
name|ICMP_UNRCH_FRAG
expr_stmt|;
break|break;
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|code
operator|=
name|ICMP_UNRCH_HOST
expr_stmt|;
break|break;
case|case
name|ENOBUFS
case|:
name|type
operator|=
name|ICMP_SRCQ
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ip_forward: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ICMP_TIMEX
expr_stmt|;
name|code
operator|=
name|ICMP_TIMEX_XMT
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
name|code
operator|=
name|ICMP_UNRCH_NET
expr_stmt|;
block|}
name|mcopy
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
block|{
comment|/* was source routed by IP option */
name|rtfree
argument_list|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mcopy
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|mcopy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ic_errmsg
argument_list|(
name|redir_addr
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|icmplen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_IP_ADDRS, (caddr_t) 0, 0); */
else|#
directive|else
if|if
condition|(
name|ip_forwarding
condition|)
comment|/* 	     * If not acting as a gateway, don't want some one else's 	     * misconception to flood our console or logfile.  This error 	     * can be found through netstat an ip_drops. 	     */
name|ip_log
argument_list|(
name|ip
argument_list|,
literal|"ip forwarding error"
argument_list|)
expr_stmt|;
name|netlog
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ipstat
operator|.
name|ip_drops
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check to see if fragment reassembly is complete  */
end_comment

begin_expr_stmt
name|ip_done
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
specifier|register
name|next
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|ip_next
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|ip_off
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
name|next
operator|=
name|q
operator|->
name|ip_end
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|q
operator|!=
name|p
operator|)
operator|&&
operator|(
name|q
operator|->
name|ip_off
operator|==
name|next
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|q
operator|==
name|p
operator|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|ip_prev
operator|->
name|ip_mff
operator|)
condition|)
comment|/* all fragments in */
return|return
operator|(
name|next
operator|)
return|;
comment|/* total data length */
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Merge mbufs of fragments of completed datagram   */
end_comment

begin_expr_stmt
name|ip_mergef
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|q
operator|=
name|p
operator|->
name|ip_next
expr_stmt|;
comment|/* -> bottom of reass chain */
name|n
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|&
name|dummy
expr_stmt|;
comment|/* dummy for init assignment */
while|while
condition|(
name|q
operator|!=
name|p
condition|)
block|{
comment|/* through chain */
comment|/* 	 * If free mbuf holding q, cannot access q->ip_next in case 	 * that mbuf is used by device code for an incoming packet. 	 */
specifier|register
name|struct
name|ip
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
comment|/* free null mbufs */
name|n
operator|->
name|m_next
operator|=
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
name|next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Dequeue and free reass.q header   */
end_comment

begin_expr_stmt
name|ip_freef
argument_list|(
name|fp
argument_list|)
specifier|register
expr|struct
name|ipq
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|fp
operator|->
name|iq_prev
operator|!=
name|NULL
condition|)
operator|(
name|fp
operator|->
name|iq_prev
operator|)
operator|->
name|iq_next
operator|=
name|fp
operator|->
name|iq_next
expr_stmt|;
else|else
name|ipfrags
operator|.
name|n_ip_head
operator|=
name|fp
operator|->
name|iq_next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|iq_next
operator|!=
name|NULL
condition|)
operator|(
name|fp
operator|->
name|iq_next
operator|)
operator|->
name|iq_prev
operator|=
name|fp
operator|->
name|iq_prev
expr_stmt|;
else|else
name|ipfrags
operator|.
name|n_ip_tail
operator|=
name|fp
operator|->
name|iq_prev
expr_stmt|;
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ip_stripopt
argument_list|(
argument|ip
argument_list|,
argument|hlen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|optlen
decl_stmt|;
if|if
condition|(
operator|(
name|optlen
operator|=
operator|(
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|end_of_ip
decl_stmt|,
name|end_of_opt
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|end_of_ip
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|end_of_opt
operator|=
name|end_of_ip
operator|+
name|optlen
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
operator|-
name|hlen
expr_stmt|;
name|bcopy
argument_list|(
name|end_of_opt
argument_list|,
name|end_of_ip
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|optlen
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Process ip options   * FALSE -> options were in error, and an icmp message has been sent  */
end_comment

begin_define
define|#
directive|define
name|OFF_OLEN
value|1
end_define

begin_define
define|#
directive|define
name|OFF_OFFSET
value|2
end_define

begin_define
define|#
directive|define
name|MIN_OFF
value|4
end_define

begin_comment
comment|/* since option is a 1, not 0, based array */
end_comment

begin_comment
comment|/*  * Record route in same form as ip_setopt()  */
end_comment

begin_macro
name|save_rte
argument_list|(
argument|option
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|option
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|olen
decl_stmt|;
name|int
name|off
decl_stmt|;
name|u_char
modifier|*
name|x
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|ip_nhops
operator|!=
literal|0
condition|)
block|{
comment|/* Use both loose and strict source routing? */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ip_nhops %d\n"
argument_list|,
name|ip_nhops
argument_list|)
expr_stmt|;
name|ip_nhops
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
if|if
condition|(
name|olen
operator|>
sizeof|sizeof
argument_list|(
name|ip_hops
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"save_rte: olen %d\n"
argument_list|,
name|olen
argument_list|)
expr_stmt|;
return|return;
block|}
name|off
operator|=
name|option
index|[
name|OFF_OFFSET
index|]
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
operator|&
name|option
index|[
name|off
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
operator|&
name|option
index|[
name|MIN_OFF
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip_hops
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|IP_NOP_OPT
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|option
index|[
literal|0
index|]
expr_stmt|;
comment|/* loose/strict source routing */
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|p
operator|-
name|q
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|+
literal|3
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|MIN_OFF
expr_stmt|;
name|ip_nhops
operator|++
expr_stmt|;
comment|/* = 1 (1 long for opt hdr) */
name|p
operator|--
expr_stmt|;
comment|/* p points at first hop for return route */
name|ip_hops
index|[
name|p
operator|-
name|q
operator|+
literal|2
index|]
operator|=
operator|(
operator|*
name|p
operator|)
expr_stmt|;
comment|/* save first hop after return route option */
name|p
operator|--
expr_stmt|;
comment|/* it is in what will be ip_hops[ip_nhops]  */
comment|/* record return path as an IP source route */
while|while
condition|(
name|p
operator|>=
name|q
condition|)
block|{
name|ip_hops
index|[
name|ip_nhops
index|]
operator|=
operator|(
operator|*
name|p
operator|)
expr_stmt|;
name|p
operator|--
expr_stmt|;
name|ip_nhops
operator|++
expr_stmt|;
block|}
comment|/* remember eventual destination is in the option field */
name|ip_hops
index|[
name|ip_nhops
index|]
operator|=
name|dst
expr_stmt|;
name|ip_nhops
operator|++
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ip_opt
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|,
name|fwdinp
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|fwdinp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|endopt
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|option
decl_stmt|;
specifier|register
name|int
name|olen
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|code
decl_stmt|;
name|struct
name|in_addr
name|nexthop
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|endopt
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
operator|+
name|hlen
expr_stmt|;
name|option
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|option
operator|<
name|endopt
condition|)
block|{
switch|switch
condition|(
operator|*
name|option
condition|)
block|{
case|case
name|IP_END_OPT
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|IP_NOP_OPT
case|:
name|olen
operator|=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_SEC_OPT
case|:
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
comment|/* so much for security */
break|break;
case|case
name|IP_LRTE_OPT
case|:
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
name|off
operator|=
name|option
index|[
name|OFF_OFFSET
index|]
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|MIN_OFF
condition|)
block|{
name|type
operator|=
name|ICMP_PARM
expr_stmt|;
name|code
operator|=
operator|&
name|option
index|[
name|OFF_OFFSET
index|]
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|off
operator|--
expr_stmt|;
comment|/* adjust for use by C */
if|if
condition|(
name|in_iawithaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
comment|/* 		 * With loose routing, may take a few hops 		 * to get to current nexthop. 		 */
break|break;
if|if
condition|(
name|off
operator|>
operator|(
name|olen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* hints all used up. pkt for us */
name|save_rte
argument_list|(
name|option
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
break|break;
block|}
name|nexthop
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
expr_stmt|;
comment|/* 	     * record outgoing interface 	     */
if|if
condition|(
operator|!
name|ip_opt_route
argument_list|(
name|fwdinp
argument_list|,
name|nexthop
argument_list|)
condition|)
block|{
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
comment|/* net? frag? host? */
name|code
operator|=
name|ICMP_UNRCH_SRC
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ip
operator|->
name|ip_dst
operator|=
name|nexthop
expr_stmt|;
name|option
index|[
name|OFF_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
comment|/* 		 * Destined for ourselves, and we're 		 * just going to strip the options off 		 */
break|break;
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
operator|=
name|IA_INADDR
argument_list|(
name|in_iafromif
argument_list|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_ifp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_SRTE_OPT
case|:
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
name|off
operator|=
name|option
index|[
name|OFF_OFFSET
index|]
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|MIN_OFF
condition|)
block|{
name|type
operator|=
name|ICMP_PARM
expr_stmt|;
name|code
operator|=
operator|&
name|option
index|[
name|OFF_OFFSET
index|]
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|off
operator|--
expr_stmt|;
comment|/* adjust for use by C */
if|if
condition|(
name|in_iawithaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* strict path -> someone goofed */
comment|/* should have come in on us for us */
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
name|code
operator|=
name|ICMP_UNRCH_SRC
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|off
operator|>
operator|(
name|olen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* hints all used up */
name|save_rte
argument_list|(
name|option
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
break|break;
block|}
name|nexthop
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ia
operator|=
name|in_iawithnet
argument_list|(
name|nexthop
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* strict path -> someone goofed 		 * we should be directly connected to 		 * next hop 		 */
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
name|code
operator|=
name|ICMP_UNRCH_SRC
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
operator|=
name|IA_INADDR
argument_list|(
name|ia
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|nexthop
expr_stmt|;
name|option
index|[
name|OFF_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_TIME_OPT
case|:
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
name|off
operator|=
name|option
index|[
name|OFF_OFFSET
index|]
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|MIN_OFF
condition|)
block|{
name|type
operator|=
name|ICMP_PARM
expr_stmt|;
name|code
operator|=
operator|&
name|option
index|[
name|OFF_OFFSET
index|]
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|off
operator|--
expr_stmt|;
comment|/* adjust for use by C */
if|if
condition|(
name|off
operator|>
operator|(
name|olen
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|)
condition|)
block|{
comment|/* increment overflow count */
if|if
condition|(
operator|(
name|option
index|[
literal|3
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|0xf0
condition|)
block|{
comment|/* overflow overflowed */
name|type
operator|=
name|ICMP_PARM
expr_stmt|;
name|code
operator|=
operator|&
name|option
index|[
name|OFF_OLEN
index|]
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|option
index|[
literal|3
index|]
operator|+=
literal|0x10
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|option
index|[
literal|3
index|]
operator|&
literal|2
condition|)
block|{
comment|/* want specific host to stamp */
name|ia
operator|=
name|in_iawithaddr
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
name|ia
operator|=
name|in_ifaddr
expr_stmt|;
if|if
condition|(
name|option
index|[
literal|3
index|]
operator|&
literal|1
condition|)
block|{
comment|/* record stamping host */
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
operator|=
name|IA_INADDR
argument_list|(
name|ia
argument_list|)
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|option
index|[
name|OFF_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|>
operator|(
name|olen
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|)
condition|)
block|{
name|option
index|[
literal|3
index|]
operator|+=
literal|0x10
expr_stmt|;
break|break;
block|}
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
operator|=
name|iptime
argument_list|()
expr_stmt|;
name|option
index|[
name|OFF_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_STRID_OPT
case|:
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
break|break;
case|case
name|IP_RRTE_OPT
case|:
name|olen
operator|=
name|option
index|[
name|OFF_OLEN
index|]
expr_stmt|;
name|off
operator|=
name|option
index|[
name|OFF_OFFSET
index|]
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|MIN_OFF
condition|)
block|{
name|type
operator|=
name|ICMP_PARM
expr_stmt|;
name|code
operator|=
operator|&
name|option
index|[
name|OFF_OFFSET
index|]
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|off
operator|--
expr_stmt|;
comment|/* adjust for use by C */
if|if
condition|(
name|off
operator|>
operator|(
name|olen
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|)
condition|)
comment|/* no space left for recording route */
break|break;
comment|/* record outgoing interface */
if|if
condition|(
operator|!
name|ip_opt_route
argument_list|(
name|fwdinp
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|)
condition|)
block|{
name|type
operator|=
name|ICMP_UNRCH
expr_stmt|;
name|code
operator|=
name|ICMP_UNRCH_NET
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|option
index|[
name|OFF_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
comment|/* 		 * Destined for us, and we're just 		 * going to strip options off 		 */
break|break;
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|option
operator|+
name|off
operator|)
operator|)
operator|=
name|IA_INADDR
argument_list|(
name|in_iafromif
argument_list|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_ifp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|option
operator|+=
name|olen
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
name|err
label|:
name|ic_errmsg
argument_list|(
name|icmp_addr
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|option
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|)
argument_list|,
name|hlen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|OFF_OLEN
end_undef

begin_undef
undef|#
directive|undef
name|OFF_OFFSET
end_undef

begin_undef
undef|#
directive|undef
name|MIN_OFF
end_undef

begin_expr_stmt
name|ip_opt_route
argument_list|(
name|fwdinp
argument_list|,
name|dst
argument_list|)
specifier|register
expr|struct
name|inpcb
operator|*
name|fwdinp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|in_addr
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* in case they use several options involving routing */
if|if
condition|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|fwdinp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwdinp
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_dst
expr_stmt|;
comment|/* not sure ip_send cares about this stuff ... */
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|dst
expr_stmt|;
comment|/* Don't allocate route if not forwarding packet.      * This saves us from doing a check in ip_input() to see      * if we should do a rtfree() for an uncommon occurrence.      */
if|if
condition|(
name|in_iawithaddr
argument_list|(
name|dst
argument_list|,
name|TRUE
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|rtalloc
argument_list|(
operator|&
name|fwdinp
operator|->
name|inp_route
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwdinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|!=
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * IP fragment reassembly timeout routine.  */
end_comment

begin_macro
name|ip_timeo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|static
name|int
name|timflag
decl_stmt|;
comment|/* check once per sec */
if|if
condition|(
name|timflag
operator|=
operator|!
name|timflag
condition|)
comment|/* looks strange, doesn't it? */
return|return;
comment|/* search through reass.q */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|ipfrags
operator|.
name|n_ip_head
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|next
control|)
block|{
comment|/* 	 * If fragment times out, mbufs are freed, and can't 	 * use next pointer since mbuf may be grabbed by 	 * an interface at splimp 	 */
name|next
operator|=
name|fp
operator|->
name|iq_next
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|fp
operator|->
name|iqx
operator|.
name|ip_ttl
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* time to die */
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* free mbufs assoc. w/chain */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
name|p
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
comment|/* ### generate timed out in reassembly msg */
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_IP_FDROP, (caddr_t)0,0); */
else|#
directive|else
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|=
name|p
expr_stmt|;
block|}
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* free header */
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Called at splimp from uipc_mbuf.c  * Network code needs to free up space!  IP fragments dropped.  */
end_comment

begin_macro
name|ip_drain
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
while|while
condition|(
name|fp
operator|=
name|ipfrags
operator|.
name|n_ip_head
condition|)
block|{
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* free mbufs assoc w/chain */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
name|p
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* free header */
block|}
block|}
end_block

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_macro
name|inet_cksum_err
argument_list|(
argument|protoname
argument_list|,
argument|ip
argument_list|,
argument|was
argument_list|,
argument|should_be
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|protoname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|was
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|should_be
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|u_long
name|ul
decl_stmt|;
name|u_char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|s
union|,
name|d
union|;
name|s
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|d
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s checksum was 0x%x not 0x%x src %d.%d.%d.%d dst %d.%d.%d.%d\n"
argument_list|,
name|protoname
argument_list|,
name|was
argument_list|,
name|should_be
argument_list|,
name|s
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|s
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|s
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|s
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ip_log
argument_list|(
argument|ip
argument_list|,
argument|emsg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|emsg
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|u_long
name|ul
decl_stmt|;
name|u_char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|s
union|,
name|d
union|;
name|s
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|d
operator|.
name|ul
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: src %d.%d.%d.%d dst %d.%d.%d.%d\n"
argument_list|,
name|emsg
argument_list|,
name|s
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|s
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|s
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|s
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|d
operator|.
name|c
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|no_route
argument_list|(
argument|msg
argument_list|,
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|u_long
name|ul
decl_stmt|;
name|u_char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|f
union|,
name|t
union|;
name|f
operator|.
name|ul
operator|=
name|from
operator|.
name|s_addr
expr_stmt|;
name|t
operator|.
name|ul
operator|=
name|to
operator|.
name|s_addr
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: no route %d.%d.%d.%d -> %d.%d.%d.%d\n"
argument_list|,
name|msg
argument_list|,
name|f
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|f
operator|.
name|c
index|[
literal|3
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|0
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|1
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|2
index|]
argument_list|,
name|t
operator|.
name|c
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

