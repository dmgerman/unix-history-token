begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vxc.c	1.5	86/01/12	*/
end_comment

begin_include
include|#
directive|include
file|"vx.h"
end_include

begin_if
if|#
directive|if
name|NVX
operator|>
literal|0
end_if

begin_comment
comment|/*  * VIOC driver  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VXPERF
end_ifdef

begin_define
define|#
directive|define
name|DOSCOPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vioc.h"
end_include

begin_include
include|#
directive|include
file|"../tahoesna/snadebug.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/scope.h"
end_include

begin_define
define|#
directive|define
name|CMDquals
value|0
end_define

begin_define
define|#
directive|define
name|RSPquals
value|1
end_define

begin_define
define|#
directive|define
name|UNSquals
value|2
end_define

begin_decl_stmt
specifier|extern
name|struct
name|vcx
name|vcx
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|tty
name|vx_tty
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vcmds
name|v_cmds
index|[
name|NVIOCX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|vxtype
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|vxbbno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|vxbopno
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SNA_DEBUG
end_ifdef

begin_extern
extern|extern vbrall(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|SNA_DEBUG
end_endif

begin_function_decl
specifier|extern
name|struct
name|vxcmd
modifier|*
name|vobtain
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|VX_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"../vba/vxdebug.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Write a command out to the VIOC  */
end_comment

begin_expr_stmt
name|vcmd
argument_list|(
name|n
argument_list|,
name|cmdad
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|cmdad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command address */
end_comment

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|v_cmds
index|[
name|n
index|]
expr_stmt|;
name|xp
operator|=
operator|&
name|vcx
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_state
operator|&
name|V_RESETTING
operator|&&
name|cmdad
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * When the vioc is resetting, don't process 		 * anything other than LIDENT commands. 		 */
specifier|register
name|struct
name|vxcmd
modifier|*
name|cmdp
init|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|cmdad
operator|-
sizeof|sizeof
argument_list|(
name|cmdp
operator|->
name|c_fwd
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|cmdp
operator|->
name|cmd
operator|!=
name|LIDENT
condition|)
block|{
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cmdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cmdad
operator|!=
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_fill
index|]
operator|=
name|cmdad
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_fill
operator|>=
name|VC_CMDBUFL
condition|)
name|cp
operator|->
name|v_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_fill
operator|==
name|cp
operator|->
name|v_empty
condition|)
block|{
name|vpanic
argument_list|(
literal|"vc: CMD Q OVFLO"
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|->
name|v_cmdsem
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|v_cmdsem
operator|&&
name|cp
operator|->
name|v_curcnt
operator|<
name|vcx
index|[
name|n
index|]
operator|.
name|v_maxcmd
condition|)
block|{
name|cp
operator|->
name|v_cmdsem
operator|--
expr_stmt|;
name|cp
operator|->
name|v_curcnt
operator|++
expr_stmt|;
name|vinthandl
argument_list|(
name|n
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|CMDquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOC acknowledge interrupt.  The VIOC has received the new  * command.  If no errors, the new command becomes one of 16 (max)  * current commands being executed.  */
end_comment

begin_expr_stmt
name|vackint
argument_list|(
name|n
argument_list|)
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* VIOC number */
end_comment

begin_block
block|{
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|scope_out
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|vxtype
index|[
name|n
index|]
condition|)
block|{
comment|/* Its a BOP */
ifdef|#
directive|ifdef
name|SNA_DEBUG
if|if
condition|(
name|snadebug
operator|&
name|SVIOC
condition|)
name|printf
argument_list|(
literal|"vack: interrupt from BOP at VIOC%d,1st vector.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vbrall
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Int. from BOP, port 0 */
endif|#
directive|endif
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|v_cmds
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vcid
operator|&
name|V_ERR
condition|)
block|{
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"INTR ERR type = %x VIOC = %x, v_dcd: %lx\n"
argument_list|,
name|vp
operator|->
name|v_vcid
operator|&
literal|07
argument_list|,
name|n
argument_list|,
name|vp
operator|->
name|v_dcd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* resp = (char *)vp + (vp->v_rspoff& 0x7FFF); */
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|vcx
index|[
name|n
index|]
operator|)
operator|->
name|v_mricmd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|resp
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|vpanic
argument_list|(
literal|"\nvcc: vackint"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return ;
block|}
elseif|else
if|if
condition|(
operator|(
name|vp
operator|->
name|v_hdwre
operator|&
literal|017
operator|)
operator|==
name|CMDquals
condition|)
block|{
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXERR4
condition|)
block|{
comment|/* causes VIOC INTR ERR 4 */
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp1
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp0
init|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
operator|-
literal|4
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|cp0
operator|->
name|cmd
operator|==
name|XMITDTA
operator|)
operator|||
operator|(
name|cp0
operator|->
name|cmd
operator|==
name|XMITIMM
operator|)
condition|)
block|{
name|cp1
operator|=
name|vobtain
argument_list|(
operator|&
name|vcx
index|[
name|n
index|]
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
operator|*
name|cp0
expr_stmt|;
name|vxintr4
operator|&=
operator|~
name|VXERR4
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|n
argument_list|,
operator|&
name|cp1
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cp
operator|->
name|v_curcmd
index|[
name|vp
operator|->
name|v_vcid
operator|&
name|VCMDLEN
operator|-
literal|1
index|]
operator|=
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_empty
operator|>=
name|VC_CMDBUFL
condition|)
name|cp
operator|->
name|v_empty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|cp
operator|->
name|v_itrempt
operator|>=
name|VC_IQLEN
condition|)
name|cp
operator|->
name|v_itrempt
operator|=
literal|0
expr_stmt|;
name|vintempt
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|n
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* queue next cmd, if any */
block|}
end_block

begin_comment
comment|/*  *  Command Response interrupt.  The Vioc has completed  *  a command.  The command may now be returned to  *  the appropriate device driver .  */
end_comment

begin_expr_stmt
name|vcmdrsp
argument_list|(
name|n
argument_list|)
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|caddr_t
name|cmd
decl_stmt|;
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|k
expr_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|vxtype
index|[
name|n
index|]
condition|)
block|{
comment|/* Its a BOP */
name|printf
argument_list|(
literal|"vcmdrsp: stray interrupt from BOP at VIOC%d...\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|v_cmds
index|[
name|n
index|]
expr_stmt|;
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|vp
expr_stmt|;
name|resp
operator|+=
name|vp
operator|->
name|v_rspoff
operator|&
literal|0x7FFF
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|resp
index|[
literal|1
index|]
operator|)
operator|&
name|V_UNBSY
condition|)
block|{
name|k
operator|&=
name|VCMDLEN
operator|-
literal|1
expr_stmt|;
name|cmd
operator|=
name|cp
operator|->
name|v_curcmd
index|[
name|k
index|]
expr_stmt|;
name|cp
operator|->
name|v_curcmd
index|[
name|k
index|]
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
name|cp
operator|->
name|v_curcnt
operator|--
expr_stmt|;
name|k
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|resp
index|[
literal|4
index|]
operator|)
expr_stmt|;
comment|/* cmd operation code */
if|if
condition|(
operator|(
name|k
operator|&
literal|0xFF00
operator|)
operator|==
name|LIDENT
condition|)
block|{
comment|/* want hiport number */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|VRESPLEN
condition|;
name|k
operator|++
control|)
name|cmd
index|[
name|k
index|]
operator|=
name|resp
index|[
name|k
operator|+
literal|4
index|]
expr_stmt|;
block|}
name|resp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vxxint
argument_list|(
name|n
argument_list|,
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|&
name|vcx
index|[
name|n
index|]
operator|)
operator|->
name|v_state
operator|==
name|V_RESETTING
condition|)
return|return;
block|}
else|else
block|{
name|vpanic
argument_list|(
literal|"vc, cmdresp debug"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|vinthandl
argument_list|(
name|n
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unsolicited interrupt.  */
end_comment

begin_expr_stmt
name|vunsol
argument_list|(
name|n
argument_list|)
specifier|register
operator|(
name|n
operator|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|scope_out
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vxtype
index|[
name|n
index|]
condition|)
block|{
comment|/* Its a BOP */
name|printf
argument_list|(
literal|"vunsol: stray interrupt from BOP at VIOC%d...\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_uqual
operator|&
name|V_UNBSY
condition|)
block|{
name|vxrint
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vinthandl
argument_list|(
name|n
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|UNSquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|}
else|else
block|{
name|vpanic
argument_list|(
literal|"vc: UNSOL INT ERR"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enqueue an interrupt  */
end_comment

begin_expr_stmt
name|vinthandl
argument_list|(
name|n
argument_list|,
name|item
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|item
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|empflag
init|=
literal|0
decl_stmt|;
name|cp
operator|=
operator|&
name|v_cmds
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrfill
operator|==
name|cp
operator|->
name|v_itrempt
condition|)
name|empflag
operator|++
expr_stmt|;
name|cp
operator|->
name|v_itrqueu
index|[
name|cp
operator|->
name|v_itrfill
index|]
operator|=
name|item
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_itrfill
operator|>=
name|VC_IQLEN
condition|)
name|cp
operator|->
name|v_itrfill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrfill
operator|==
name|cp
operator|->
name|v_itrempt
condition|)
block|{
name|vpanic
argument_list|(
literal|"vc: INT Q OVFLO"
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|empflag
condition|)
name|vintempt
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vintempt
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
specifier|register
name|short
name|item
decl_stmt|;
specifier|register
name|short
modifier|*
name|intr
decl_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vioc
operator|&
name|V_BSY
condition|)
return|return ;
name|cp
operator|=
operator|&
name|v_cmds
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrempt
operator|==
name|cp
operator|->
name|v_itrfill
condition|)
return|return ;
name|item
operator|=
name|cp
operator|->
name|v_itrqueu
index|[
name|cp
operator|->
name|v_itrempt
index|]
expr_stmt|;
name|intr
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|vp
operator|->
name|v_vioc
expr_stmt|;
switch|switch
condition|(
operator|(
name|item
operator|>>
literal|8
operator|)
operator|&
literal|03
condition|)
block|{
case|case
name|CMDquals
case|:
comment|/* command */
block|{
name|int
name|phys
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_empty
operator|==
name|cp
operator|->
name|v_fill
operator|||
name|vp
operator|->
name|v_vcbsy
operator|&
name|V_BSY
condition|)
break|break;
operator|(
operator|&
name|vcx
index|[
name|n
index|]
operator|)
operator|->
name|v_mricmd
operator|=
operator|(
name|caddr_t
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
expr_stmt|;
name|phys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
argument_list|)
expr_stmt|;
comment|/* should be a sys address */
name|vp
operator|->
name|v_vcp
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|phys
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|vp
operator|->
name|v_vcp
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|phys
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|vp
operator|->
name|v_vcbsy
operator|=
name|V_BSY
expr_stmt|;
operator|*
name|intr
operator|=
name|item
expr_stmt|;
block|}
name|scope_out
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break ;
case|case
name|RSPquals
case|:
comment|/* command response */
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break ;
case|case
name|UNSquals
case|:
comment|/* unsolicited interrupt */
name|vp
operator|->
name|v_uqual
operator|=
literal|0
expr_stmt|;
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break ;
block|}
block|}
end_block

begin_comment
comment|/* start a reset on a vioc after error (hopefully) */
end_comment

begin_expr_stmt
name|vxstreset
argument_list|(
name|n
argument_list|)
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|extern
name|int
name|vxinreset
parameter_list|()
function_decl|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|xp
operator|=
operator|&
name|vcx
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_state
operator|&
name|V_RESETTING
condition|)
comment|/* 		 * Avoid infinite recursion. 		 */
return|return;
comment|/* 	 * Zero out the vioc structures, mark the vioc as being 	 * reset, reinitialize the free command list, reset the vioc 	 * and start a timer to check on the progress of the reset. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|v_cmds
index|[
name|n
index|]
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|vcmds
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|xp
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|vcx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setting V_RESETTING prevents others from issuing 	 * commands while allowing currently queued commands to 	 * be passed to the VIOC. 	 */
name|xp
operator|->
name|v_state
operator||=
name|V_RESETTING
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVCXBUFS
condition|;
name|j
operator|++
control|)
comment|/* init all cmd buffers */
block|{
name|cp
operator|=
operator|&
name|xp
operator|->
name|vx_lst
index|[
name|j
index|]
expr_stmt|;
comment|/* index a buffer */
name|cp
operator|->
name|c_fwd
operator|=
operator|&
name|xp
operator|->
name|vx_lst
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
comment|/* point to next buf */
block|}
name|xp
operator|->
name|vx_avail
operator|=
operator|&
name|xp
operator|->
name|vx_lst
index|[
literal|0
index|]
expr_stmt|;
comment|/* set idx to 1st free buf */
name|cp
operator|->
name|c_fwd
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* mark last buf in free list */
name|printf
argument_list|(
literal|"resetting VIOC %x .. "
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_fault
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vioc
operator|=
name|V_BSY
expr_stmt|;
name|vp
operator|->
name|v_hdwre
operator|=
name|V_RESET
expr_stmt|;
comment|/* reset interrupt */
name|timeout
argument_list|(
name|vxinreset
argument_list|,
operator|(
name|caddr_t
operator|)
name|n
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* continue processing a reset on a vioc after an error (hopefully) */
end_comment

begin_macro
name|vxinreset
argument_list|(
argument|vioc
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|vioc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
init|=
operator|(
name|int
operator|)
name|vioc
decl_stmt|;
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"vxinreset "
argument_list|)
expr_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * See if the vioc has reset. 	 */
if|if
condition|(
name|vp
operator|->
name|v_fault
operator|!=
name|VREADY
condition|)
block|{
name|printf
argument_list|(
literal|"failed\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Send a LIDENT to the vioc and mess with carrier flags 	 * on parallel printer ports. 	 */
name|vxinit
argument_list|(
name|n
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Restore modem control, parameters and restart output.  * Since the vioc can handle no more then 24 commands at a time  * and we could generate as many as 48 commands, we must do this in  * phases, issuing no more then 16 commands at a time.  */
end_comment

begin_comment
comment|/* finish the reset on the vioc after an error (hopefully) */
end_comment

begin_expr_stmt
name|vxfnreset
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|vblok
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
specifier|register
name|int
name|on
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|vxrestart
parameter_list|()
function_decl|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"vxfnreset "
argument_list|)
expr_stmt|;
name|vp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|xp
operator|=
operator|&
name|vcx
index|[
name|n
index|]
expr_stmt|;
name|xp
operator|->
name|v_loport
operator|=
name|cp
operator|->
name|par
index|[
literal|5
index|]
expr_stmt|;
comment|/* save low port number */
name|xp
operator|->
name|v_hiport
operator|=
name|cp
operator|->
name|par
index|[
literal|7
index|]
expr_stmt|;
comment|/* VIOC knows high port numbr */
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* done with this control block */
name|xp
operator|->
name|v_nbr
operator|=
name|n
expr_stmt|;
comment|/* assign VIOC-X board number */
name|xp
operator|->
name|v_state
operator|&=
operator|~
name|V_RESETTING
expr_stmt|;
name|vp
operator|->
name|v_vcid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Restore modem information and control. 	 */
for|for
control|(
name|i
operator|=
name|xp
operator|->
name|v_loport
init|;
name|i
operator|<=
name|xp
operator|->
name|v_hiport
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|i
operator|+
name|n
operator|*
literal|16
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
name|vcmodem
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
name|VMOD_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|NOHANG
operator|)
operator|==
literal|0
condition|)
block|{
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * If carrier has changed while we were resetting, 		 * take appropriate action. 		 */
ifdef|#
directive|ifdef
name|notdef
name|on
operator|=
name|vp
operator|->
name|v_dcd
operator|&
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
name|on
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|NOHANG
operator|)
operator|==
literal|0
condition|)
block|{
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|gsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
name|xp
operator|->
name|v_state
operator||=
name|V_RESETTING
expr_stmt|;
name|timeout
argument_list|(
name|vxrestart
argument_list|,
operator|(
name|caddr_t
operator|)
name|n
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Restore a particular aspect of the VIOC.  */
end_comment

begin_macro
name|vxrestart
argument_list|(
argument|vioc
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|vioc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
specifier|register
name|int
name|n
init|=
operator|(
name|int
operator|)
name|vioc
decl_stmt|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|cnt
operator|=
name|n
operator|>>
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"vxrestart %d "
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|n
operator|&=
literal|0xff
expr_stmt|;
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|n
operator|*
literal|16
index|]
expr_stmt|;
name|xp
operator|=
operator|&
name|vcx
index|[
name|n
index|]
expr_stmt|;
name|xp
operator|->
name|v_state
operator|&=
operator|~
name|V_RESETTING
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xp
operator|->
name|v_loport
init|;
name|i
operator|<=
name|xp
operator|->
name|v_hiport
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_TIMEOUT
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
comment|/* restart pending output */
name|vxstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_WOPEN
operator||
name|TS_ISOPEN
operator|)
condition|)
name|vxcparam
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|xp
operator|->
name|v_state
operator||=
name|V_RESETTING
expr_stmt|;
name|timeout
argument_list|(
name|vxrestart
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|n
operator|+
literal|1
operator|*
literal|256
argument_list|)
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vxreset
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vxstreset
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* completes asynchronously */
block|}
end_block

begin_expr_stmt
name|vxfreset
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NVX
operator|||
name|VBAS
argument_list|(
name|n
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|vcx
index|[
name|n
index|]
operator|.
name|v_state
operator|&=
operator|~
name|V_RESETTING
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* completes asynchronously */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

