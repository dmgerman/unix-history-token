begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_output.c,v 5.4 88/11/18 17:28:08 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_output.c,v $  *	@(#)tp_output.c	7.8 (Berkeley) %G% *  *  * In here is tp_ctloutput(), the guy called by [sg]etsockopt(),  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_output.c,v 5.4 88/11/18 17:28:08 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_user.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_ip.h"
end_include

begin_include
include|#
directive|include
file|"tp_clnp.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_define
define|#
directive|define
name|USERFLAGSMASK_G
value|0x0f00643b
end_define

begin_define
define|#
directive|define
name|USERFLAGSMASK_S
value|0x0f000432
end_define

begin_define
define|#
directive|define
name|TPDUSIZESHIFT
value|24
end_define

begin_define
define|#
directive|define
name|CLASSHIFT
value|16
end_define

begin_comment
comment|/*  * NAME: 	tp_consistency()  *  * CALLED FROM:  * 	tp_ctloutput(), tp_input()  *  * FUNCTION and ARGUMENTS:  * 	Checks the consistency of options and tpdusize with class,  *	using the parameters passed in via (param).  *	(cmd) may be TP_STRICT or TP_FORCE or both.  *  Force means it will set all the values in (tpcb) to those in  *  the input arguements iff no errors were encountered.  *  Strict means that no inconsistency will be tolerated.  If it's  *  not used, checksum and tpdusize inconsistencies will be tolerated.  *  The reason for this is that in some cases, when we're negotiating down   *	from class  4, these options should be changed but should not   *  cause negotiation to fail.  *  * RETURNS  *  E* or EOK  *  E* if the various parms aren't ok for a given class  *  EOK if they are ok for a given class  */
end_comment

begin_function
name|int
name|tp_consistency
parameter_list|(
name|tpcb
parameter_list|,
name|cmd
parameter_list|,
name|param
parameter_list|)
name|u_int
name|cmd
decl_stmt|;
name|struct
name|tp_conn_param
modifier|*
name|param
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|int
name|error
init|=
name|EOK
decl_stmt|;
name|int
name|class_to_use
init|=
name|tp_mask_to_num
argument_list|(
name|param
operator|->
name|p_class
argument_list|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_consist enter class_to_use dontchange param.class cmd"
argument_list|,
name|class_to_use
argument_list|,
name|param
operator|->
name|p_dont_change_params
argument_list|,
name|param
operator|->
name|p_class
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"tp_consistency %s %s\n"
argument_list|,
name|cmd
operator|&
name|TP_FORCE
condition|?
literal|"TP_FORCE"
else|:
literal|""
argument_list|,
name|cmd
operator|&
name|TP_STRICT
condition|?
literal|"TP_STRICT"
else|:
literal|""
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|cmd
operator|&
name|TP_FORCE
operator|)
operator|&&
operator|(
name|param
operator|->
name|p_dont_change_params
operator|)
condition|)
block|{
name|cmd
operator|&=
operator|~
name|TP_FORCE
expr_stmt|;
block|}
comment|/* can switch net services within a domain, but 	 * cannot switch domains  	 */
switch|switch
condition|(
name|param
operator|->
name|p_netservice
condition|)
block|{
case|case
name|ISO_CONS
case|:
case|case
name|ISO_CLNS
case|:
case|case
name|ISO_COSNS
case|:
comment|/* param->p_netservice in ISO DOMAIN */
if|if
condition|(
name|tpcb
operator|->
name|tp_domain
operator|!=
name|AF_ISO
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|IN_CLNS
case|:
comment|/* param->p_netservice in INET DOMAIN */
if|if
condition|(
name|tpcb
operator|->
name|tp_domain
operator|!=
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
comment|/* no others not possible-> netservice is a 2-bit field! */
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"p_class 0x%x, class_to_use 0x%x\n"
argument_list|,
name|param
operator|->
name|p_class
argument_list|,
name|class_to_use
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_netservice
operator|<
literal|0
operator|)
operator|||
operator|(
name|param
operator|->
name|p_netservice
operator|>
name|TP_MAX_NETSERVICES
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|param
operator|->
name|p_class
operator|&
name|TP_CLASSES_IMPLEMENTED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"Nretrans 0x%x\n"
argument_list|,
name|param
operator|->
name|p_Nretrans
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_Nretrans
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_cr_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_cc_ticks
operator|<
literal|1
operator|)
condition|)
block|{
comment|/* bad for any class because negot has to be done a la class 4 */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"winsize 0x%x\n"
argument_list|,
name|param
operator|->
name|p_winsize
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_winsize
operator|<
literal|128
operator|)
operator|||
operator|(
name|param
operator|->
name|p_winsize
operator|<
name|param
operator|->
name|p_tpdusize
operator|)
operator|||
operator|(
name|param
operator|->
name|p_winsize
operator|>
operator|(
operator|(
literal|1
operator|+
name|SB_MAX
operator|)
operator|>>
literal|2
comment|/* 1/4 of the max */
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
name|soreserve
argument_list|(
name|tpcb
operator|->
name|tp_sock
argument_list|,
operator|(
name|u_long
operator|)
name|param
operator|->
name|p_winsize
argument_list|,
operator|(
name|u_long
operator|)
name|param
operator|->
name|p_winsize
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"use_csum 0x%x\n"
argument_list|,
name|param
operator|->
name|p_use_checksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xtd_format 0x%x\n"
argument_list|,
name|param
operator|->
name|p_xtd_format
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xpd_service 0x%x\n"
argument_list|,
name|param
operator|->
name|p_xpd_service
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tpdusize 0x%x\n"
argument_list|,
name|param
operator|->
name|p_tpdusize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tpcb->flags 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|class_to_use
condition|)
block|{
case|case
literal|0
case|:
comment|/* do not use checksums, xtd format, or XPD */
if|if
condition|(
name|param
operator|->
name|p_use_checksum
operator||
name|param
operator|->
name|p_xtd_format
operator||
name|param
operator|->
name|p_xpd_service
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_use_checksum
operator|=
literal|0
expr_stmt|;
name|param
operator|->
name|p_xtd_format
operator|=
literal|0
expr_stmt|;
name|param
operator|->
name|p_xpd_service
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|<
name|TP_MIN_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP_MIN_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|>
name|TP0_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP0_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
comment|/* connect/disc data not allowed for class 0 */
if|if
condition|(
name|tpcb
operator|->
name|tp_ucddata
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|&
name|TP_FORCE
condition|)
block|{
name|m_freem
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_ucddata
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|4
case|:
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"dt_ticks 0x%x\n"
argument_list|,
name|param
operator|->
name|p_dt_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x_ticks 0x%x\n"
argument_list|,
name|param
operator|->
name|p_x_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dr_ticks 0x%x\n"
argument_list|,
name|param
operator|->
name|p_dr_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keepalive 0x%x\n"
argument_list|,
name|param
operator|->
name|p_keepalive_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sendack 0x%x\n"
argument_list|,
name|param
operator|->
name|p_sendack_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"inact 0x%x\n"
argument_list|,
name|param
operator|->
name|p_inact_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ref 0x%x\n"
argument_list|,
name|param
operator|->
name|p_ref_ticks
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_class
operator|&
name|TP_CLASS_4
operator|)
operator|&&
operator|(
operator|(
name|param
operator|->
name|p_dt_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_dr_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_x_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_keepalive_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_sendack_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_ref_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_inact_ticks
operator|<
literal|1
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"rx_strat 0x%x\n"
argument_list|,
name|param
operator|->
name|p_rx_strat
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|param
operator|->
name|p_rx_strat
operator|>
operator|(
name|TPRX_USE_CW
operator||
name|TPRX_EACH
operator||
name|TPRX_FASTSTART
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_rx_strat
operator|=
name|TPRX_USE_CW
expr_stmt|;
block|}
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"ack_strat 0x%x\n"
argument_list|,
name|param
operator|->
name|p_ack_strat
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_ack_strat
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|param
operator|->
name|p_ack_strat
operator|!=
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_ack_strat
operator|=
name|TPACK_WINDOW
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|<
name|TP_MIN_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP_MIN_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|>
name|TP_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|&
name|TP_FORCE
operator|)
condition|)
block|{
comment|/* Enforce Negotation rules below */
if|if
condition|(
name|tpcb
operator|->
name|tp_tpdusize
operator|>
name|param
operator|->
name|p_tpdusize
condition|)
name|tpcb
operator|->
name|tp_tpdusize
operator|=
name|param
operator|->
name|p_tpdusize
expr_stmt|;
name|tpcb
operator|->
name|tp_class
operator|=
name|param
operator|->
name|p_class
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
operator|||
name|param
operator|->
name|p_use_checksum
condition|)
name|tpcb
operator|->
name|tp_use_checksum
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_xpd_service
operator|||
operator|!
name|param
operator|->
name|p_xpd_service
condition|)
name|tpcb
operator|->
name|tp_xpd_service
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_xtd_format
operator|||
operator|!
name|param
operator|->
name|p_xtd_format
condition|)
name|tpcb
operator|->
name|tp_xtd_format
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_consist returns class xtdfmt cmd"
argument_list|,
name|error
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|tpcb
operator|->
name|tp_xtd_format
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_consist rtns 0x%x class 0x%x xtd_fmt 0x%x cmd 0x%x\n"
argument_list|,
name|error
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|tpcb
operator|->
name|tp_xtd_format
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME: 	tp_ctloutput()  *  * CALLED FROM:  * 	[sg]etsockopt(), via so[sg]etopt().   *  * FUNCTION and ARGUMENTS:  * 	Implements the socket options at transport level.  * 	(cmd) is either PRCO_SETOPT or PRCO_GETOPT (see ../sys/protosw.h).  * 	(so) is the socket.  * 	(level) is SOL_TRANSPORT (see ../sys/socket.h)  * 	(optname) is the particular command or option to be set.  * 	(**mp) is an mbuf structure.    *  * RETURN VALUE:  * 	ENOTSOCK if the socket hasn't got an associated tpcb  *  EINVAL if   * 		trying to set window too big  * 		trying to set illegal max tpdu size   * 		trying to set illegal credit fraction  * 		trying to use unknown or unimplemented class of TP  *		structure passed to set timer values is wrong size  *  	illegal combination of command/GET-SET option,   *			e.g., GET w/ TPOPT_CDDATA_CLEAR:   *  EOPNOTSUPP if the level isn't transport, or command is neither GET nor SET  *   or if the transport-specific command is not implemented  *  EISCONN if trying a command that isn't allowed after a connection  *   is established  *  ENOTCONN if trying a command that is allowed only if a connection is  *   established  *  EMSGSIZE if trying to give too much data on connect/disconnect  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|ProtoHook
name|tp_ctloutput
parameter_list|(
name|cmd
parameter_list|,
name|so
parameter_list|,
name|level
parameter_list|,
name|optname
parameter_list|,
name|mp
parameter_list|)
name|int
name|cmd
decl_stmt|,
name|level
decl_stmt|,
name|optname
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|sototpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|caddr_t
name|value
decl_stmt|;
name|unsigned
name|val_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_REQUEST
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctloutput cmd so optname mp"
argument_list|,
name|cmd
argument_list|,
name|so
argument_list|,
name|optname
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"tp_ctloutput so 0x%x cmd 0x%x optname 0x%x, mp 0x%x *mp 0x%x tpcb 0x%x\n"
argument_list|,
name|so
argument_list|,
name|cmd
argument_list|,
name|optname
argument_list|,
name|mp
argument_list|,
name|mp
condition|?
operator|*
name|mp
else|:
literal|0
argument_list|,
name|tpcb
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
name|tpcb
operator|==
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|MNULL
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|TPMT_SONAME
argument_list|)
expr_stmt|;
comment|/* does off, type, next */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 *	Hook so one can set network options via a tp socket. 	 */
if|if
condition|(
name|level
operator|==
name|SOL_NETWORK
condition|)
block|{
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_nlproto
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tpcb
operator|->
name|tp_npcb
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
elseif|else
if|if
condition|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_ctloutput
operator|==
name|NULL
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_ctloutput
call|)
argument_list|(
name|cmd
argument_list|,
name|optname
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|level
operator|!=
name|SOL_TRANSPORT
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|cmd
operator|!=
name|PRCO_GETOPT
operator|&&
name|cmd
operator|!=
name|PRCO_SETOPT
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* The only options allowed after connection is established 	 * are GET (anything) and SET DISC DATA and SET PERF MEAS 	 */
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|)
operator|&&
operator|(
name|cmd
operator|==
name|PRCO_SETOPT
operator|&&
name|optname
operator|!=
name|TPOPT_DISC_DATA
operator|&&
name|optname
operator|!=
name|TPOPT_CFRM_DATA
operator|&&
name|optname
operator|!=
name|TPOPT_PERF_MEAS
operator|&&
name|optname
operator|!=
name|TPOPT_CDDATA_CLEAR
operator|)
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* The only options allowed after disconnection are GET DISC DATA, 	 * and TPOPT_PSTATISTICS 	 * and they're not allowed if the ref timer has gone off, because 	 * the tpcb is gone  	 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONFIRMING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_tpcb
operator|==
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_REFWAIT
operator|||
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSING
operator|)
operator|&&
operator|(
name|optname
operator|!=
name|TPOPT_DISC_DATA
operator|&&
name|optname
operator|!=
name|TPOPT_PSTATISTICS
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|value
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* it's aligned, don't worry, 								  * but lint complains about it  								  */
name|val_len
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|TPOPT_INTERCEPT
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|cmd
operator|!=
name|PRCO_SETOPT
operator|||
name|tpcb
operator|->
name|tp_state
operator|!=
name|TP_LISTENING
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|t
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SONAME
argument_list|)
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
decl_stmt|;
call|(
modifier|*
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|m
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_ISO
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|sa
operator|)
operator|->
name|siso_nlen
operator|==
literal|0
condition|)
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
for|for
control|(
name|t
operator|=
name|tp_intercepts
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|tp_nextlisten
control|)
block|{
if|if
condition|(
name|t
operator|->
name|tp_nlproto
operator|->
name|nlp_afamily
operator|!=
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_afamily
condition|)
continue|continue;
if|if
condition|(
call|(
modifier|*
name|t
operator|->
name|tp_nlproto
operator|->
name|nlp_cmpnetaddr
call|)
argument_list|(
name|t
operator|->
name|tp_npcb
argument_list|,
name|sa
argument_list|,
name|TP_LOCAL
argument_list|)
condition|)
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
modifier|*
name|tt
decl_stmt|;
for|for
control|(
name|tt
operator|=
operator|&
name|tp_listeners
init|;
operator|*
name|tt
condition|;
name|tt
operator|=
operator|&
operator|(
operator|(
operator|*
name|tt
operator|)
operator|->
name|tp_nextlisten
operator|)
control|)
if|if
condition|(
operator|*
name|tt
operator|==
name|tpcb
condition|)
break|break;
if|if
condition|(
operator|*
name|tt
condition|)
operator|*
name|tt
operator|=
name|tpcb
operator|->
name|tp_nextlisten
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|tpcb
operator|->
name|tp_nextlisten
operator|=
name|tp_intercepts
expr_stmt|;
name|tp_intercepts
operator|=
name|tpcb
expr_stmt|;
break|break;
case|case
name|TPOPT_MY_TSEL
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_lsuffixlen
operator|<=
name|MAX_TSAP_SEL_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|value
argument_list|,
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
name|tpcb
operator|->
name|tp_lsuffixlen
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
if|if
condition|(
operator|(
name|val_len
operator|>
name|MAX_TSAP_SEL_LEN
operator|)
operator|||
operator|(
name|val_len
operator|<=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"val_len 0x%x (*mp)->m_len 0x%x\n"
argument_list|,
name|val_len
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|value
argument_list|,
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_lsuffixlen
operator|=
name|val_len
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_PEER_TSEL
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_fsuffixlen
operator|<=
name|MAX_TSAP_SEL_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|value
argument_list|,
name|tpcb
operator|->
name|tp_fsuffixlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
name|tpcb
operator|->
name|tp_fsuffixlen
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
if|if
condition|(
operator|(
name|val_len
operator|>
name|MAX_TSAP_SEL_LEN
operator|)
operator|||
operator|(
name|val_len
operator|<=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"val_len 0x%x (*mp)->m_len 0x%x\n"
argument_list|,
name|val_len
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|value
argument_list|,
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_fsuffixlen
operator|=
name|val_len
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_FLAGS
case|:
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"%s TPOPT_FLAGS value 0x%x *value 0x%x, flags 0x%x \n"
argument_list|,
name|cmd
operator|==
name|PRCO_GETOPT
condition|?
literal|"GET"
else|:
literal|"SET"
argument_list|,
name|value
argument_list|,
operator|*
name|value
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|value
operator|=
operator|(
name|int
operator|)
name|tpcb
operator|->
name|tp_flags
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|TPOPT_PARAMS
case|:
comment|/* This handles: 		 * timer values, 		 * class, use of transport expedited data, 		 * max tpdu size, checksum, xtd format and 		 * disconnect indications, and may get rid of connect/disc data 		 */
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"TPOPT_PARAMS value 0x%x, cmd %s \n"
argument_list|,
name|value
argument_list|,
name|cmd
operator|==
name|PRCO_GETOPT
condition|?
literal|"GET"
else|:
literal|"SET"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFDEBUG
argument_list|(
name|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"TPOPT_PARAMS value 0x%x, cmd %s \n"
argument_list|,
name|value
argument_list|,
name|cmd
operator|==
name|PRCO_GETOPT
condition|?
literal|"GET"
else|:
literal|"SET"
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
operator|*
operator|(
expr|struct
name|tp_conn_param
operator|*
operator|)
name|value
operator|=
name|tpcb
operator|->
name|_tp_param
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|_tp_param
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|tp_consistency
argument_list|(
name|tpcb
argument_list|,
name|TP_STRICT
operator||
name|TP_FORCE
argument_list|,
operator|(
expr|struct
name|tp_conn_param
operator|*
operator|)
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  				 * tp_consistency doesn't copy the whole set of params  				 */
name|tpcb
operator|->
name|_tp_param
operator|=
operator|*
operator|(
expr|struct
name|tp_conn_param
operator|*
operator|)
name|value
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|_tp_param
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_PSTATISTICS
case|:
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
if|if
condition|(
operator|*
name|mp
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
do|do
block|{
name|MFREE
argument_list|(
operator|*
name|mp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
operator|*
name|mp
operator|=
name|m_copym
argument_list|(
name|tpcb
operator|->
name|tp_p_mbuf
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ENDPERF
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|done
goto|;
endif|#
directive|endif
endif|TP_PERF_MEAS
case|case
name|TPOPT_CDDATA_CLEAR
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_ucddata
condition|)
block|{
name|m_freem
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_ucddata
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_CFRM_DATA
case|:
case|case
name|TPOPT_DISC_DATA
case|:
case|case
name|TPOPT_CONN_DATA
case|:
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|optname
operator|==
name|TPOPT_DISC_DATA
condition|?
literal|"DISC data"
else|:
literal|"CONN data"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m_len 0x%x, vallen 0x%x so_snd.cc 0x%x\n"
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
argument_list|,
name|val_len
argument_list|,
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"tp_ctloutput: sosnd "
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
name|int
name|len
init|=
name|tpcb
operator|->
name|tp_ucddata
condition|?
name|tpcb
operator|->
name|tp_ucddata
operator|->
name|m_len
else|:
literal|0
decl_stmt|;
comment|/* can append connect data in several calls */
if|if
condition|(
name|len
operator|+
name|val_len
operator|>
operator|(
name|optname
operator|==
name|TPOPT_CONN_DATA
condition|?
name|TP_MAX_CR_DATA
else|:
name|TP_MAX_DR_DATA
operator|)
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
operator|=
name|MNULL
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_ucddata
condition|)
name|m_cat
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
else|else
name|tpcb
operator|->
name|tp_ucddata
operator|=
operator|*
name|mp
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|,
literal|"tp_ctloutput after CONN_DATA"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_REQUEST
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"C/D DATA: flags snd.sbcc val_len"
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|,
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|,
name|val_len
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
modifier|*
name|mp
init|=
name|MNULL
decl_stmt|;
comment|/* prevent sosetopt from freeing it! */
if|if
condition|(
name|optname
operator|==
name|TPOPT_CFRM_DATA
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
condition|)
operator|(
name|void
operator|)
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TPOPT_PERF_MEAS
case|:
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
operator|*
name|value
operator|=
operator|(
name|u_int
operator|)
name|tpcb
operator|->
name|tp_perf_on
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|value
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|value
operator|)
operator|!=
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|tpcb
operator|->
name|tp_perf_on
operator|=
operator|(
operator|*
name|value
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tpcb
operator|->
name|tp_perf_on
condition|)
name|error
operator|=
name|tp_setup_perf
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
else|#
directive|else
else|TP_PERF_MEAS
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
endif|TP_PERF_MEAS
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
name|done
label|:
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"tp_ctloutput sosnd at end"
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
operator|*
name|mp
argument_list|,
literal|"tp_ctloutput *mp"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/*  	 * sigh: getsockopt looks only at m_len : all output data must  	 * reside in the first mbuf  	 */
if|if
condition|(
name|error
operator|&&
operator|(
operator|*
name|mp
operator|)
operator|!=
name|MNULL
condition|)
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|!=
name|MNULL
condition|)
block|{
name|ASSERT
argument_list|(
name|m_compress
argument_list|(
operator|*
name|mp
argument_list|,
name|mp
argument_list|)
operator|<=
name|MLEN
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|dump_mbuf
argument_list|(
operator|*
name|mp
argument_list|,
literal|"tp_ctloutput *mp after compress"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

