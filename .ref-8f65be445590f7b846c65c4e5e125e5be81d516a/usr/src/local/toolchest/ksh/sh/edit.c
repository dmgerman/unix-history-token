begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)edit.c	1.1 */
end_comment

begin_comment
comment|/*  *  edit.c - common routines for vi and emacs one line editors in shell  *  *   David Korn				P.D. Sullivan  *   AT&T Bell Laboratories		AT&T Bell Laboratories  *   Room 5D-112			Room 1E253  *   Murray Hill, N. J. 07974		Columbus, OH 43213  *   Tel. x7975				Tel. x 2655  *  *   Coded April 1983.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_define
define|#
directive|define
name|BAD
value|-1
end_define

begin_define
define|#
directive|define
name|GOOD
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|(-1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|SYSERR
value|-1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VENIX
end_ifdef

begin_define
define|#
directive|define
name|RT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VENIX */
end_comment

begin_function_decl
name|void
name|e_crlf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|e_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|e_getchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|e_putchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|e_ringbell
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|e_setup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|e_virt_to_phys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|e_window
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setcooked
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ungetchar
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|BSD
operator|||
name|RT
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|ttyparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial tty parameters */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|nttyparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw tty parameters */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|tty_speeds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|l_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|l_ttychars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|l_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|l_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if mode bits changed */
end_comment

begin_define
define|#
directive|define
name|L_CHARS
value|4
end_define

begin_define
define|#
directive|define
name|T_CHARS
value|2
end_define

begin_define
define|#
directive|define
name|L_MASK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX
end_ifdef

begin_comment
comment|/* avoid symbol table overflows */
end_comment

begin_define
define|#
directive|define
name|NCC
value|8
end_define

begin_struct
struct|struct
name|termio
block|{
name|unsigned
name|short
name|c_iflag
decl_stmt|;
comment|/* input modes */
name|unsigned
name|short
name|c_oflag
decl_stmt|;
comment|/* output modes */
name|unsigned
name|short
name|c_cflag
decl_stmt|;
comment|/* control modes */
name|unsigned
name|short
name|c_lflag
decl_stmt|;
comment|/* line discipline modes */
name|char
name|c_line
decl_stmt|;
comment|/* line discipline */
name|unsigned
name|char
name|c_cc
index|[
name|NCC
index|]
decl_stmt|;
comment|/* control chars */
name|char
name|c_res
decl_stmt|;
comment|/* padding, AFTER the array */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TIOC
value|('T'<<8)
end_define

begin_define
define|#
directive|define
name|BRKINT
value|0000002
end_define

begin_define
define|#
directive|define
name|CBAUD
value|0000017
end_define

begin_define
define|#
directive|define
name|ECHO
value|0000010
end_define

begin_define
define|#
directive|define
name|ECHOE
value|0000020
end_define

begin_define
define|#
directive|define
name|ECHOK
value|0000040
end_define

begin_define
define|#
directive|define
name|ECHONL
value|0000100
end_define

begin_define
define|#
directive|define
name|ICANON
value|0000002
end_define

begin_define
define|#
directive|define
name|ICRNL
value|0000400
end_define

begin_define
define|#
directive|define
name|IGNCR
value|0000200
end_define

begin_define
define|#
directive|define
name|IGNPAR
value|0000004
end_define

begin_define
define|#
directive|define
name|INLCR
value|0000100
end_define

begin_define
define|#
directive|define
name|PARMRK
value|0000010
end_define

begin_define
define|#
directive|define
name|TCGETA
value|(TIOC|1)
end_define

begin_define
define|#
directive|define
name|TCSETAW
value|(TIOC|3)
end_define

begin_define
define|#
directive|define
name|TCXONC
value|(TIOC|6)
end_define

begin_define
define|#
directive|define
name|VEOF
value|4
end_define

begin_define
define|#
directive|define
name|VERASE
value|2
end_define

begin_define
define|#
directive|define
name|VKILL
value|3
end_define

begin_define
define|#
directive|define
name|VMIN
value|4
end_define

begin_define
define|#
directive|define
name|VTIME
value|5
end_define

begin_define
define|#
directive|define
name|TM_CECHO
value|0010
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XENIX */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termio
name|ttyparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial tty parameters */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termio
name|nttyparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw tty parameters */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RT */
end_comment

begin_define
define|#
directive|define
name|lookahead
value|editb.e_index
end_define

begin_define
define|#
directive|define
name|env
value|editb.e_env
end_define

begin_define
define|#
directive|define
name|previous
value|editb.e_lbuf
end_define

begin_define
define|#
directive|define
name|fildes
value|editb.e_fd
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|Amemory
modifier|*
name|alias
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|arg_build
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fault
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|Namnod
modifier|*
name|findnod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|f_complete
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gsort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|simple
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|tilde
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|macro
index|[]
init|=
literal|"_?"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|badcooked
index|[]
init|=
literal|"cannot reset tty to cooked mode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|edit
name|editb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|trapnote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|trapnote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|p_flush
parameter_list|()
value|fflush(stderr)
end_define

begin_define
define|#
directive|define
name|p_setout
parameter_list|(
name|s
parameter_list|)
value|fflush(stdout)
end_define

begin_define
define|#
directive|define
name|error
parameter_list|(
name|s
parameter_list|)
value|failed(s,NULL)
end_define

begin_define
define|#
directive|define
name|SIGSLOW
value|1
end_define

begin_define
define|#
directive|define
name|output
value|stderr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|bellchr
index|[]
init|=
literal|"\7"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bell char */
end_comment

begin_function_decl
specifier|static
name|int
name|control
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*{	SETCOOKED( fd )  *  *	This routine will set the tty in cooked mode.  * It is also called by error.done().  * }*/
end_comment

begin_function
name|void
name|setcooked
parameter_list|(
name|fd
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
block|{
comment|/*** don't do ioctl unless ttyparm has valid data ***/
comment|/* or in raw mode */
if|if
condition|(
name|editb
operator|.
name|e_ttyspeed
operator|==
literal|0
operator|||
name|editb
operator|.
name|e_raw
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|RAWMODE
operator|&&
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EBADF
operator|&&
name|errno
operator|!=
name|ENOTTY
condition|)
name|error
argument_list|(
name|badcooked
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* restore flags */
if|if
condition|(
name|l_changed
operator|&
name|L_MASK
condition|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|l_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_changed
operator|&
name|T_CHARS
condition|)
comment|/* restore alternate break character */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|l_ttychars
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_changed
operator|&
name|L_CHARS
condition|)
comment|/* restore alternate break character */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|l_chars
argument_list|)
expr_stmt|;
name|l_changed
operator|=
literal|0
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|RT
if|if
condition|(
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
else|#
directive|else
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|&&
name|control
argument_list|(
name|fd
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
endif|#
directive|endif
comment|/* RT */
block|{
if|if
condition|(
name|errno
operator|!=
name|EBADF
operator|&&
name|errno
operator|!=
name|ENOTTY
condition|)
name|error
argument_list|(
name|badcooked
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* BSD */
name|editb
operator|.
name|e_raw
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	SETRAW( fd )  *  *	This routine will set the tty in raw mode.  * }*/
end_comment

begin_expr_stmt
name|setraw
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD
name|struct
name|ltchars
name|lchars
decl_stmt|;
endif|#
directive|endif
comment|/* BSD */
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|RAWMODE
condition|)
return|return
operator|(
name|GOOD
operator|)
return|;
comment|/* characters are echoed on standard error */
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|||
name|RT
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
operator|)
else|#
directive|else
if|if
condition|(
operator|(
name|gtty
argument_list|(
name|fd
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
operator|)
endif|#
directive|endif
comment|/* BSD */
operator|||
operator|!
operator|(
name|ttyparm
operator|.
name|sg_flags
operator|&
name|ECHO
operator|)
operator|||
operator|(
name|ttyparm
operator|.
name|sg_flags
operator|&
name|LCASE
operator|)
condition|)
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|nttyparm
operator|=
name|ttyparm
expr_stmt|;
name|nttyparm
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|TBDELAY
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|nttyparm
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
else|#
directive|else
name|nttyparm
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|editb
operator|.
name|e_erase
operator|=
name|ttyparm
operator|.
name|sg_erase
expr_stmt|;
name|editb
operator|.
name|e_kill
operator|=
name|ttyparm
operator|.
name|sg_kill
expr_stmt|;
name|editb
operator|.
name|e_eof
operator|=
name|cntl
argument_list|(
name|D
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|nttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
else|#
directive|else
if|if
condition|(
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|nttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
endif|#
directive|endif
comment|/* BSD */
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|editb
operator|.
name|e_ttyspeed
operator|=
operator|(
name|ttyparm
operator|.
name|sg_ospeed
operator|>=
name|B1200
condition|?
name|FAST
else|:
name|SLOW
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|delay
operator|=
name|tty_speeds
index|[
name|ttyparm
operator|.
name|sg_ospeed
index|]
expr_stmt|;
comment|/* try to remove effect of ^V  and ^Y */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|l_chars
argument_list|)
operator|!=
name|SYSERR
condition|)
block|{
name|lchars
operator|=
name|l_chars
expr_stmt|;
name|lchars
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
name|lchars
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no delayed stop process signal */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|lchars
argument_list|)
operator|!=
name|SYSERR
condition|)
name|l_changed
operator||=
name|L_CHARS
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BSD */
else|#
directive|else
ifndef|#
directive|ifndef
name|RAWONLY
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|!=
name|ALTMODE
condition|)
endif|#
directive|endif
comment|/* RAWONLY */
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
operator|)
operator|||
operator|(
operator|!
operator|(
name|ttyparm
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|nttyparm
operator|=
name|ttyparm
expr_stmt|;
ifndef|#
directive|ifndef
name|u370
name|nttyparm
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNPAR
operator||
name|PARMRK
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator|)
expr_stmt|;
name|nttyparm
operator|.
name|c_iflag
operator||=
name|BRKINT
expr_stmt|;
name|nttyparm
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
else|#
directive|else
name|nttyparm
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNBRK
operator||
name|PARMRK
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator||
name|INPCK
operator|)
expr_stmt|;
name|nttyparm
operator|.
name|c_iflag
operator||=
operator|(
name|BRKINT
operator||
name|IGNPAR
operator|)
expr_stmt|;
name|nttyparm
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* u370 */
name|nttyparm
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|nttyparm
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|editb
operator|.
name|e_eof
operator|=
name|ttyparm
operator|.
name|c_cc
index|[
name|VEOF
index|]
expr_stmt|;
name|editb
operator|.
name|e_erase
operator|=
name|ttyparm
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|editb
operator|.
name|e_kill
operator|=
name|ttyparm
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|u370
if|if
condition|(
name|control
argument_list|(
name|fd
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|nttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
else|#
directive|else
comment|/* delays are too long, don't wait for output to drain */
if|if
condition|(
name|control
argument_list|(
name|fd
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|nttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
endif|#
directive|endif
comment|/* u370 */
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|control
argument_list|(
name|fd
argument_list|,
name|TCXONC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|editb
operator|.
name|e_ttyspeed
operator|=
name|ttyparm
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
endif|#
directive|endif
name|editb
operator|.
name|e_raw
operator|=
name|RAWMODE
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_comment
comment|/*  * give two tries for ioctl  * interrupts are ignored  */
end_comment

begin_function
specifier|static
name|int
name|control
parameter_list|(
name|fd
parameter_list|,
name|request
parameter_list|,
name|arg
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
init|=
literal|2
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|k
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|request
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
name|SYSERR
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|SYSERR
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAWONLY
end_ifndef

begin_comment
comment|/*	SET_TTY( fd )  *  *	Get tty parameters and make ESC and '\r' wakeup characters.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_expr_stmt
name|setalt
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|mask
decl_stmt|;
name|struct
name|tchars
name|ttychars
decl_stmt|;
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|ALTMODE
condition|)
return|return
operator|(
name|GOOD
operator|)
return|;
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|RAWMODE
condition|)
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|l_changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|editb
operator|.
name|e_ttyspeed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|!=
name|SYSERR
operator|)
condition|)
name|editb
operator|.
name|e_ttyspeed
operator|=
operator|(
name|ttyparm
operator|.
name|sg_ospeed
operator|>=
name|B1200
condition|?
name|FAST
else|:
name|SLOW
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|l_ttychars
argument_list|)
operator|==
name|SYSERR
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|l_mask
argument_list|)
operator|==
name|SYSERR
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
name|ttychars
operator|=
name|l_ttychars
expr_stmt|;
name|mask
operator|=
name|LCRTBS
operator||
name|LCRTERA
operator||
name|LCTLECH
operator||
name|LPENDIN
operator||
name|LCRTKIL
expr_stmt|;
if|if
condition|(
operator|(
name|l_mask
operator||
name|mask
operator|)
operator|!=
name|l_mask
condition|)
name|l_changed
operator|=
name|L_MASK
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCLBIS
argument_list|,
operator|&
name|mask
argument_list|)
operator|==
name|SYSERR
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
name|ttychars
operator|.
name|t_brkc
operator|=
name|ESC
expr_stmt|;
name|l_changed
operator||=
name|T_CHARS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|ttychars
argument_list|)
operator|==
name|SYSERR
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
name|editb
operator|.
name|e_raw
operator|=
name|ALTMODE
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|setalt
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|ALTMODE
condition|)
return|return
operator|(
name|GOOD
operator|)
return|;
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|RAWMODE
condition|)
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttyparm
argument_list|)
operator|==
name|SYSERR
operator|)
operator|||
operator|(
operator|!
operator|(
name|ttyparm
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|nttyparm
operator|=
name|ttyparm
expr_stmt|;
name|nttyparm
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNCR
operator||
name|ICRNL
operator|)
expr_stmt|;
name|nttyparm
operator|.
name|c_iflag
operator||=
name|INLCR
expr_stmt|;
name|nttyparm
operator|.
name|c_lflag
operator||=
operator|(
name|ECHOE
operator||
name|ECHOK
operator|)
expr_stmt|;
name|nttyparm
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|ESC
expr_stmt|;
comment|/* make ESC the eof char */
name|nttyparm
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
literal|'\r'
expr_stmt|;
comment|/* make CR an eol char */
name|editb
operator|.
name|e_eof
operator|=
name|ttyparm
operator|.
name|c_cc
index|[
name|VEOF
index|]
expr_stmt|;
name|nttyparm
operator|.
name|c_cc
index|[
name|VEOL2
index|]
operator|=
name|editb
operator|.
name|e_eof
expr_stmt|;
comment|/* make EOF an eol char */
name|editb
operator|.
name|e_erase
operator|=
name|ttyparm
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|editb
operator|.
name|e_kill
operator|=
name|ttyparm
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
if|if
condition|(
name|control
argument_list|(
name|fd
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|nttyparm
argument_list|)
operator|==
name|SYSERR
condition|)
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|editb
operator|.
name|e_ttyspeed
operator|=
operator|(
operator|(
name|ttyparm
operator|.
name|c_cflag
operator|&
name|CBAUD
operator|)
operator|>=
name|B1200
condition|?
name|FAST
else|:
name|SLOW
operator|)
expr_stmt|;
name|editb
operator|.
name|e_raw
operator|=
name|ALTMODE
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAWONLY */
end_comment

begin_comment
comment|/*  *	E_WINDOW()  *  *	return the window size  */
end_comment

begin_function
name|int
name|e_window
parameter_list|()
block|{
specifier|register
name|int
name|n
init|=
name|DFLTWINDOW
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|valup
argument_list|(
name|COLUMNS
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|n
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|MINWINDOW
condition|)
name|n
operator|=
name|MINWINDOW
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXWINDOW
condition|)
name|n
operator|=
name|MAXWINDOW
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*	E_FLUSH()  *  *	Flush the output buffer.  *  */
end_comment

begin_function
name|void
name|e_flush
parameter_list|()
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|buf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|output
operator|->
name|_base
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|editb
operator|.
name|e_outptr
operator|-
name|buf
decl_stmt|;
specifier|register
name|int
name|fd
init|=
name|fileno
argument_list|(
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|editb
operator|.
name|e_outptr
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifdef|#
directive|ifdef
name|BSD_4_2
if|if
condition|(
name|delay
operator|&&
name|n
operator|>
name|delay
operator|/
literal|100
condition|)
block|{
comment|/* delay until output drains */
name|struct
name|timeval
name|timeloc
decl_stmt|;
name|n
operator|*=
literal|10
expr_stmt|;
name|timeloc
operator|.
name|tv_sec
operator|=
name|n
operator|/
name|delay
expr_stmt|;
name|timeloc
operator|.
name|tv_usec
operator|=
operator|(
literal|1000000
operator|*
operator|(
name|n
operator|%
name|delay
operator|)
operator|)
operator|/
name|delay
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeloc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BSD_4_2 */
else|#
directive|else
ifndef|#
directive|ifndef
name|RT
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|RAWMODE
operator|&&
name|n
operator|>
literal|16
condition|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|nttyparm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RT */
endif|#
directive|endif
comment|/* BSD */
block|}
end_function

begin_comment
comment|/*  * send the bell character ^G to the terminal  */
end_comment

begin_function
name|void
name|e_ringbell
parameter_list|()
block|{
name|write
argument_list|(
name|fileno
argument_list|(
name|output
argument_list|)
argument_list|,
name|bellchr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * send a carriage return line feed to the terminal  */
end_comment

begin_function
name|void
name|e_crlf
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|u370
name|e_putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* u370 */
ifdef|#
directive|ifdef
name|VENIX
name|e_putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VENIX */
name|e_putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|e_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*	E_SETUP( max_prompt_size )  *  *	This routine sets up the prompt string  */
end_comment

begin_function
name|void
name|e_setup
parameter_list|(
name|fd
parameter_list|,
name|PRSIZE
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|last
decl_stmt|;
specifier|register
name|char
modifier|*
name|pp
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|output
operator|->
name|_base
operator|)
decl_stmt|;
name|char
modifier|*
name|ppmax
decl_stmt|;
name|editb
operator|.
name|e_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|fc_fix
condition|)
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
name|editb
operator|.
name|e_hismax
operator|=
name|fp
operator|->
name|fixind
expr_stmt|;
name|editb
operator|.
name|e_hloff
operator|=
name|fp
operator|->
name|fixline
expr_stmt|;
name|editb
operator|.
name|e_hismin
operator|=
name|fp
operator|->
name|fixind
operator|-
name|fp
operator|->
name|fixmax
expr_stmt|;
if|if
condition|(
name|editb
operator|.
name|e_hismin
operator|<
literal|0
condition|)
name|editb
operator|.
name|e_hismin
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|editb
operator|.
name|e_hismax
operator|=
name|editb
operator|.
name|e_hismin
operator|=
name|editb
operator|.
name|e_hloff
operator|=
literal|0
expr_stmt|;
block|}
name|editb
operator|.
name|e_hline
operator|=
name|editb
operator|.
name|e_hismax
expr_stmt|;
name|editb
operator|.
name|e_wsize
operator|=
name|e_window
argument_list|()
operator|-
literal|2
expr_stmt|;
name|editb
operator|.
name|e_outptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pp
expr_stmt|;
name|editb
operator|.
name|e_crlf
operator|=
name|YES
expr_stmt|;
operator|*
operator|(
name|output
operator|->
name|_ptr
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|last
operator|=
name|strrchr
argument_list|(
name|pp
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|last
operator|=
name|pp
operator|)
operator|==
literal|0
condition|)
name|editb
operator|.
name|e_crlf
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|last
operator|++
expr_stmt|;
name|pp
operator|=
name|editb
operator|.
name|e_prompt
expr_stmt|;
name|ppmax
operator|=
name|pp
operator|+
name|PRSIZE
operator|-
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|'\r'
expr_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|last
operator|++
condition|)
block|{
comment|/* cut out bells */
if|if
condition|(
name|c
operator|!=
name|BELL
condition|)
block|{
if|if
condition|(
name|pp
operator|<
name|ppmax
condition|)
operator|*
name|pp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|editb
operator|.
name|e_crlf
operator|=
name|NO
expr_stmt|;
block|}
block|}
block|}
name|editb
operator|.
name|e_plen
operator|=
name|pp
operator|-
name|editb
operator|.
name|e_prompt
operator|-
literal|1
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|u370
if|if
condition|(
name|editb
operator|.
name|e_raw
operator|==
name|RAWMODE
condition|)
name|u370fflush
argument_list|(
name|output
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* u370 */
name|p_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|u370
end_ifdef

begin_comment
comment|/* The u370 does not \r before \n in raw mode (known bug). 	  To get around this we will insert a \r before each \n 	  in the output buffer. */
end_comment

begin_macro
name|u370fflush
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|icnt
decl_stmt|,
name|ocnt
decl_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
name|icnt
operator|=
name|file
operator|->
name|_ptr
operator|-
name|file
operator|->
name|_base
expr_stmt|;
name|ocnt
operator|=
name|icnt
expr_stmt|;
name|base
operator|=
name|file
operator|->
name|_base
expr_stmt|;
if|if
condition|(
name|icnt
operator|<=
literal|0
condition|)
return|return;
while|while
condition|(
name|base
operator|<
name|file
operator|->
name|_ptr
condition|)
block|{
if|if
condition|(
operator|*
name|base
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|ocnt
operator|++
expr_stmt|;
block|}
operator|*
name|ptr
operator|++
operator|=
operator|*
name|base
operator|++
expr_stmt|;
block|}
name|base
operator|=
name|file
operator|->
name|_base
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
name|ocnt
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|icnt
operator|=
literal|0
init|;
name|icnt
operator|<
name|BUFSIZ
condition|;
name|icnt
operator|++
control|)
block|{
operator|*
name|base
operator|++
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|ocnt
operator|<=
literal|0
condition|)
break|break;
block|}
name|file
operator|->
name|_ptr
operator|=
name|base
expr_stmt|;
name|p_flush
argument_list|()
expr_stmt|;
name|base
operator|=
name|file
operator|->
name|_base
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* u370 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_comment
comment|/*  * look for edit macro named _i  * if found, puts the macro definition into lookahead buffer and returns 1  */
end_comment

begin_expr_stmt
name|e_macro
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
name|struct
name|Namnod
modifier|*
name|np
decl_stmt|;
name|genchar
name|buff
index|[
name|LOOKAHEAD
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'@'
condition|)
name|macro
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
name|np
operator|=
name|findnod
argument_list|(
name|macro
argument_list|,
name|alias
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|out
operator|=
name|valup
argument_list|(
name|np
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE
comment|/* copy to buff in internal representation */
name|int
name|c
init|=
name|out
index|[
name|LOOKAHEAD
index|]
decl_stmt|;
name|out
index|[
name|LOOKAHEAD
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|e_internal
argument_list|(
name|out
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|out
index|[
name|LOOKAHEAD
index|]
operator|=
name|c
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buff
argument_list|,
name|out
argument_list|,
name|LOOKAHEAD
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|ungetchar
argument_list|(
name|buff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file name generation for edit modes  * non-zero exit for error,<0 ring bell  * don't search back past<start> character of the buffer  * mode is '*' for inline expansion, otherwise files are listed in select format  */
end_comment

begin_macro
name|q_expand
argument_list|(
argument|outbuff
argument_list|,
argument|cur
argument_list|,
argument|eol
argument_list|,
argument|start
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|char
name|outbuff
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|cur
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|eol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|STKPTR
name|staksav
init|=
name|stakbot
decl_stmt|;
name|COMPTR
name|comptr
init|=
operator|(
name|COMPTR
operator|)
name|getstak
argument_list|(
name|COMTYPE
argument_list|)
decl_stmt|;
name|ARGPTR
name|ap
init|=
operator|(
name|ARGPTR
operator|)
name|locstak
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|outmin
init|=
name|outbuff
operator|+
name|start
decl_stmt|;
name|char
modifier|*
name|begin
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|int
name|strip
decl_stmt|;
name|optflag
name|savflags
init|=
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
block|{
specifier|register
name|int
name|c
init|=
operator|*
name|cur
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|cp
decl_stmt|;
comment|/* adjust cur */
name|cp
operator|=
operator|(
name|genchar
operator|*
operator|)
name|outbuff
operator|+
operator|*
name|cur
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
operator|*
name|cur
operator|=
name|e_external
argument_list|(
operator|(
name|genchar
operator|*
operator|)
name|outbuff
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stakbot
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|eol
operator|=
name|e_external
argument_list|(
operator|(
name|genchar
operator|*
operator|)
name|outbuff
argument_list|,
name|outbuff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
name|out
operator|=
name|outbuff
operator|+
operator|*
name|cur
expr_stmt|;
name|comptr
operator|->
name|comtyp
operator|=
name|COMSCAN
expr_stmt|;
name|comptr
operator|->
name|comarg
operator|=
name|ap
expr_stmt|;
name|ap
operator|->
name|argflag
operator|=
operator|(
name|A_MAC
operator||
name|A_EXP
operator|)
expr_stmt|;
name|ap
operator|->
name|argnxt
operator|=
literal|0
expr_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|ap
operator|->
name|argval
decl_stmt|;
name|int
name|chktilde
init|=
literal|0
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|out
operator|>
name|outmin
condition|)
block|{
comment|/* go to beginning of word */
do|do
block|{
name|out
operator|--
expr_stmt|;
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|out
expr_stmt|;
block|}
do|while
condition|(
name|out
operator|>
name|outmin
operator|&&
operator|!
name|isqmeta
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* copy word into arg */
if|if
condition|(
name|isqmeta
argument_list|(
name|c
argument_list|)
condition|)
name|out
operator|++
expr_stmt|;
block|}
else|else
name|out
operator|=
name|outmin
expr_stmt|;
name|begin
operator|=
name|out
expr_stmt|;
name|flag
operator|=
literal|'*'
expr_stmt|;
name|strip
operator|=
name|TRUE
expr_stmt|;
comment|/* copy word to arg and do ~ expansion */
do|do
block|{
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|out
operator|++
expr_stmt|;
if|if
condition|(
name|isexp
argument_list|(
name|c
argument_list|)
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|flag
operator|==
literal|0
operator|)
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|chktilde
operator|==
literal|0
operator|&&
operator|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|'/'
operator|)
condition|)
block|{
name|chktilde
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|tilde
argument_list|(
name|begin
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|movstr
argument_list|(
name|cp
argument_list|,
name|ap
operator|->
name|argval
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|c
operator|&&
operator|!
name|isqmeta
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|out
operator|--
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|=
name|flag
expr_stmt|;
name|endstak
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|last
operator|=
name|ptr
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
literal|'*'
condition|)
name|on_option
argument_list|(
name|MARKDIR
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|com
decl_stmt|;
name|int
name|narg
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|com
operator|=
name|arg_build
argument_list|(
operator|&
name|narg
argument_list|,
name|comptr
argument_list|)
expr_stmt|;
comment|/*  match? */
if|if
condition|(
name|narg
operator|>
literal|1
operator|||
operator|!
name|eq
argument_list|(
name|ap
operator|->
name|argval
argument_list|,
operator|*
name|com
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|last
operator|==
literal|0
condition|)
operator|*
name|last
operator|=
literal|'*'
expr_stmt|;
else|else
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|mode
operator|!=
literal|'*'
condition|)
block|{
if|if
condition|(
name|strip
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ptrcom
decl_stmt|;
for|for
control|(
name|ptrcom
operator|=
name|com
init|;
operator|*
name|ptrcom
condition|;
name|ptrcom
operator|++
control|)
comment|/* trim directory prefix */
operator|*
name|ptrcom
operator|=
name|simple
argument_list|(
operator|*
name|ptrcom
argument_list|)
expr_stmt|;
block|}
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|p_list
argument_list|(
name|narg
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|p_flush
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* see if there is enough room */
name|size
operator|=
operator|*
name|eol
operator|-
operator|(
name|out
operator|-
name|begin
operator|)
expr_stmt|;
name|size
operator|+=
name|narg
expr_stmt|;
block|{
name|char
modifier|*
modifier|*
name|savcom
init|=
name|com
decl_stmt|;
while|while
condition|(
operator|*
name|com
condition|)
name|size
operator|+=
name|strlen
argument_list|(
operator|*
name|com
operator|++
argument_list|)
expr_stmt|;
name|com
operator|=
name|savcom
expr_stmt|;
block|}
comment|/* see if room for expansion */
if|if
condition|(
name|outbuff
operator|+
name|size
operator|>=
operator|&
name|outbuff
index|[
name|MAXLINE
index|]
condition|)
block|{
name|com
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|argval
expr_stmt|;
name|com
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* save remainder of the buffer */
name|strcpy
argument_list|(
name|stakbot
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
name|begin
expr_stmt|;
while|while
condition|(
operator|*
name|com
condition|)
block|{
name|out
operator|=
name|movstr
argument_list|(
operator|*
name|com
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|com
condition|)
operator|*
name|out
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|cur
operator|=
operator|(
name|out
operator|-
name|outbuff
operator|)
expr_stmt|;
comment|/* restore rest of buffer */
name|out
operator|=
name|movstr
argument_list|(
name|stakbot
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|*
name|eol
operator|=
operator|(
name|out
operator|-
name|outbuff
operator|)
expr_stmt|;
block|}
name|done
label|:
name|tdystak
argument_list|(
name|staksav
argument_list|)
expr_stmt|;
name|flags
operator|=
name|savflags
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* first re-adjust cur */
name|out
operator|=
name|outbuff
operator|+
operator|*
name|cur
expr_stmt|;
name|c
operator|=
operator|*
name|out
expr_stmt|;
operator|*
name|out
operator|=
literal|0
expr_stmt|;
operator|*
name|cur
operator|=
name|e_internal
argument_list|(
name|outbuff
argument_list|,
operator|(
name|genchar
operator|*
operator|)
name|stakbot
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|c
expr_stmt|;
name|outbuff
index|[
operator|*
name|eol
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|eol
operator|=
name|e_internal
argument_list|(
name|outbuff
argument_list|,
operator|(
name|genchar
operator|*
operator|)
name|outbuff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_comment
comment|/*  * routine to perform read from terminal for vi and emacs mode  */
end_comment

begin_function
name|int
name|e_getchar
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|maxtry
init|=
literal|100
decl_stmt|;
name|int
name|nchar
decl_stmt|;
comment|/* number of characters to read at a time */
ifdef|#
directive|ifdef
name|MULTIBYTE
specifier|static
name|int
name|curchar
decl_stmt|;
specifier|static
name|int
name|cursize
decl_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|char
name|readin
index|[
name|LOOKAHEAD
index|]
decl_stmt|;
if|if
condition|(
name|lookahead
condition|)
block|{
name|c
operator|=
name|previous
index|[
operator|--
name|lookahead
index|]
expr_stmt|;
comment|/*** map '\r' to '\n' ***/
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|e_flush
argument_list|()
expr_stmt|;
comment|/* you can't chance read ahead at the end of line */
name|nchar
operator|=
operator|(
name|editb
operator|.
name|e_cur
operator|>=
name|editb
operator|.
name|e_eol
condition|?
literal|1
else|:
name|READAHEAD
operator|)
expr_stmt|;
comment|/* Set 'i' to indicate read failed, in case intr set */
name|retry
label|:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|editb
operator|.
name|e_inmacro
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|trapnote
operator|&
name|SIGSLOW
operator|)
operator|==
literal|0
operator|&&
name|maxtry
operator|--
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fildes
argument_list|,
name|readin
argument_list|,
name|nchar
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE
name|lookahead
operator|=
name|maxtry
operator|=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|maxtry
condition|)
block|{
name|c
operator|=
name|readin
index|[
name|i
operator|++
index|]
operator|&
name|STRIP
expr_stmt|;
name|next
label|:
if|if
condition|(
name|cursize
operator|--
operator|>
literal|0
condition|)
block|{
name|curchar
operator|=
operator|(
name|curchar
operator|<<
literal|7
operator|)
operator||
operator|(
name|c
operator|&
operator|~
name|HIGHBIT
operator|)
expr_stmt|;
if|if
condition|(
name|cursize
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|curchar
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|maxtry
condition|)
goto|goto
name|retry
goto|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|curchar
operator|=
name|echarset
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cursize
operator|=
name|in_csize
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
operator|!=
literal|1
condition|)
name|c
operator|=
literal|0
expr_stmt|;
name|curchar
operator|<<=
literal|7
operator|*
operator|(
name|ESS_MAXCHAR
operator|-
name|cursize
operator|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
goto|goto
name|next
goto|;
elseif|else
if|if
condition|(
name|i
operator|>=
name|maxtry
condition|)
goto|goto
name|retry
goto|;
continue|continue;
block|}
name|gotit
label|:
name|previous
index|[
operator|--
name|lookahead
index|]
operator|=
name|c
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|readin
index|[
operator|--
name|i
index|]
operator|&
name|STRIP
expr_stmt|;
name|previous
index|[
name|lookahead
operator|++
index|]
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
ifndef|#
directive|ifndef
name|BSD
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*** user break key ***/
name|lookahead
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|KSHELL
name|fault
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
name|UINTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KSHELL */
block|}
endif|#
directive|endif
comment|/* !BSD */
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE
comment|/* shift lookahead buffer if necessary */
if|if
condition|(
name|lookahead
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lookahead
init|;
name|i
operator|<
name|maxtry
condition|;
name|i
operator|++
control|)
name|previous
index|[
name|i
operator|-
name|lookahead
index|]
operator|=
name|previous
index|[
name|i
index|]
expr_stmt|;
block|}
name|lookahead
operator|=
name|maxtry
operator|-
name|lookahead
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
name|lookahead
operator|>
literal|0
condition|)
return|return
operator|(
name|e_getchar
argument_list|(
literal|1
argument_list|)
operator|)
return|;
name|longjmp
argument_list|(
name|env
argument_list|,
operator|(
name|i
operator|==
literal|0
condition|?
name|UEOF
else|:
name|UINTR
operator|)
argument_list|)
expr_stmt|;
comment|/* What a mess! Give up */
comment|/* NOTREACHED */
block|}
name|void
name|ungetchar
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|lookahead
operator|<
name|LOOKAHEAD
condition|)
name|previous
index|[
name|lookahead
operator|++
index|]
operator|=
name|c
expr_stmt|;
return|return;
block|}
comment|/*  * put a character into the output buffer  */
name|void
name|e_putchar
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|dp
init|=
name|editb
operator|.
name|e_outptr
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
specifier|register
name|int
name|d
decl_stmt|;
comment|/* check for place holder */
if|if
condition|(
name|c
operator|==
name|MARKER
condition|)
return|return;
if|if
condition|(
name|d
operator|=
name|icharset
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|2
condition|)
operator|*
name|dp
operator|++
operator|=
name|ESS2
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|3
condition|)
operator|*
name|dp
operator|++
operator|=
name|ESS3
expr_stmt|;
name|d
operator|=
name|in_csize
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|d
operator|>
literal|0
condition|)
operator|*
name|dp
operator|++
operator|=
name|HIGHBIT
operator||
operator|(
name|c
operator|>>
operator|(
literal|7
operator|*
name|d
operator|)
operator|)
expr_stmt|;
name|c
operator||=
name|HIGHBIT
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'\b'
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|output
operator|->
name|_base
operator|)
operator|)
operator|>=
operator|(
name|BUFSIZ
operator|-
literal|3
operator|)
condition|)
name|e_flush
argument_list|()
expr_stmt|;
else|else
name|editb
operator|.
name|e_outptr
operator|=
name|dp
expr_stmt|;
block|}
comment|/*  * copy virtual to physical and return the index for cursor in physical buffer  */
name|e_virt_to_phys
argument_list|(
argument|virt
argument_list|,
argument|phys
argument_list|,
argument|cur
argument_list|,
argument|voff
argument_list|,
argument|poff
argument_list|)
name|genchar
modifier|*
name|virt
decl_stmt|;
name|genchar
modifier|*
name|phys
decl_stmt|;
name|int
name|cur
decl_stmt|;
block|{
specifier|register
name|genchar
modifier|*
name|sp
init|=
name|virt
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|dp
init|=
name|phys
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|genchar
modifier|*
name|curp
init|=
name|sp
operator|+
name|cur
decl_stmt|;
name|genchar
modifier|*
name|dpmax
init|=
name|phys
operator|+
name|MAXLINE
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|int
name|d
decl_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|sp
operator|+=
name|voff
expr_stmt|;
name|dp
operator|+=
name|poff
expr_stmt|;
for|for
control|(
name|r
operator|=
name|poff
init|;
name|c
operator|=
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|curp
operator|==
name|sp
condition|)
name|r
operator|=
name|dp
operator|-
name|phys
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|d
operator|=
name|out_csize
argument_list|(
name|icharset
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|1
condition|)
block|{
comment|/* multiple width character put in place holders */
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|--
name|d
operator|>
literal|0
condition|)
operator|*
name|dp
operator|++
operator|=
name|MARKER
expr_stmt|;
comment|/* in vi mode the cursor is at the last character */
if|if
condition|(
name|dp
operator|>=
name|dpmax
condition|)
break|break;
continue|continue;
block|}
elseif|else
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|c
operator|=
name|dp
operator|-
name|phys
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|c
operator|+
literal|8
operator|)
operator|&
operator|~
literal|07
operator|)
operator|-
name|c
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dp
operator|++
operator|=
literal|'^'
expr_stmt|;
name|c
operator|^=
name|TO_PRINT
expr_stmt|;
block|}
comment|/* in vi mode the cursor is at the last character */
if|if
condition|(
name|curp
operator|==
name|sp
operator|&&
name|is_option
argument_list|(
name|EDITVI
argument_list|)
condition|)
name|r
operator|=
name|dp
operator|-
name|phys
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|dp
operator|>=
name|dpmax
condition|)
break|break;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE
comment|/*  * convert external representation<src> to an array of genchars<dest>  *<src> and<dest> can be the same  * returns number of chars in dest  */
name|int
name|e_internal
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
name|genchar
modifier|*
name|dest
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|dp
init|=
name|dest
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dest
operator|==
name|src
condition|)
block|{
name|genchar
name|buffer
index|[
name|MAXLINE
index|]
decl_stmt|;
name|c
operator|=
name|e_internal
argument_list|(
name|src
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|e_gencpy
argument_list|(
name|dp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
while|while
condition|(
name|c
operator|=
operator|*
name|src
operator|++
condition|)
block|{
if|if
condition|(
name|size
operator|=
name|echarset
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|d
operator|=
operator|(
name|size
operator|==
literal|1
condition|?
name|c
else|:
literal|0
operator|)
expr_stmt|;
name|c
operator|=
name|size
expr_stmt|;
name|size
operator|=
name|in_csize
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|<<=
literal|7
operator|*
operator|(
name|ESS_MAXCHAR
operator|-
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|size
operator|--
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|7
operator|)
operator||
operator|(
name|d
operator|&
operator|~
name|HIGHBIT
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
name|c
operator|=
operator|(
name|c
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
operator|*
name|src
operator|++
operator|)
operator|&
operator|~
name|HIGHBIT
operator|)
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dp
operator|-
name|dest
operator|)
return|;
block|}
comment|/*  * convert internal representation<src> into character array<dest>.  * The<src> and<dest> may be the same.  * returns number of chars in dest.  */
name|int
name|e_external
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|)
name|genchar
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
init|=
name|dest
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
name|char
modifier|*
name|dpmax
init|=
name|dp
operator|+
sizeof|sizeof
argument_list|(
name|genchar
argument_list|)
operator|*
name|MAXLINE
operator|-
literal|2
decl_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|src
operator|==
name|dp
condition|)
block|{
name|char
name|buffer
index|[
name|MAXLINE
operator|*
sizeof|sizeof
argument_list|(
name|genchar
argument_list|)
index|]
decl_stmt|;
name|c
operator|=
name|e_external
argument_list|(
name|src
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|&&
name|dp
operator|<
name|dpmax
condition|)
block|{
if|if
condition|(
name|d
operator|=
name|icharset
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|2
condition|)
operator|*
name|dp
operator|++
operator|=
name|ESS2
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|3
condition|)
operator|*
name|dp
operator|++
operator|=
name|ESS3
expr_stmt|;
name|d
operator|=
name|in_csize
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|d
operator|>
literal|0
condition|)
operator|*
name|dp
operator|++
operator|=
name|HIGHBIT
operator||
operator|(
name|c
operator|>>
operator|(
literal|7
operator|*
name|d
operator|)
operator|)
expr_stmt|;
name|c
operator||=
name|HIGHBIT
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dp
operator|-
name|dest
operator|)
return|;
block|}
comment|/*  * copy<sp> to<dp>  */
name|int
name|e_gencpy
parameter_list|(
name|dp
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|genchar
modifier|*
name|dp
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|sp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
condition|)
empty_stmt|;
block|}
comment|/*  * copy at most<n> items from<sp> to<dp>  */
name|int
name|e_genncpy
parameter_list|(
name|dp
parameter_list|,
name|sp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|genchar
modifier|*
name|dp
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
operator|&&
operator|(
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
operator|)
condition|)
empty_stmt|;
block|}
comment|/*  * find the string length of<str>  */
name|int
name|e_genlen
parameter_list|(
name|str
parameter_list|)
specifier|register
name|genchar
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|genchar
modifier|*
name|sp
init|=
name|str
decl_stmt|;
while|while
condition|(
operator|*
name|sp
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|sp
operator|-
name|str
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

end_unit

