begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)xec.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SXT
end_ifdef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/sxt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SXT */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_define
define|#
directive|define
name|TIC_SEC
value|60
end_define

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_comment
comment|/* These routines are defined by this module */
end_comment

begin_function_decl
name|int
name|execute
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|trace_command
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* These routines are referenced by this module */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|arg_build
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|DOLPTR
name|arg_use
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|DOLPTR
name|arg_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|await
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|chkopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|builtin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chktrap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chkpipe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|done
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|execa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exfunct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|findnod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|heap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|macro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mactrim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mem_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mem_unscope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|oldsigs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_sub
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|pipe_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|postclr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|qvalup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|rmtemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|setlist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|swap_iodoc_nm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|sync_io
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tdystak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|times
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFD
end_ifdef

begin_function_decl
specifier|extern
name|void
name|close_pipes
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_function_decl
specifier|extern
name|int
name|vfork_check
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|vfork_save
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|vfork_restore
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VFORK */
end_comment

begin_function_decl
specifier|static
name|int
name|trim_eq
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|locbuf
index|[
name|TMPSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* store last argument here if it fits */
end_comment

begin_comment
comment|/* ========	command execution	========*/
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|execute
argument_list|(
argument|argt
argument_list|,
argument|execflg
argument_list|,
argument|apf1
argument_list|,
argument|apf2
argument_list|)
end_macro

begin_decl_stmt
name|TREPTR
name|argt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|execflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|apf1
index|[]
decl_stmt|,
modifier|*
name|apf2
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* `stakbot' is preserved by this routine */
specifier|register
name|TREPTR
name|t
decl_stmt|;
name|STKPTR
name|sav
init|=
name|savstak
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|inpipe
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|otpipe
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|pf1
init|=
name|apf1
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|pf2
init|=
name|apf2
decl_stmt|;
name|unsigned
name|errorflg
init|=
operator|(
name|execflg
operator|&
name|ERRFLG
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VFORK
name|int
name|v_fork
decl_stmt|;
endif|#
directive|endif
comment|/* VFORK */
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorflg
operator|==
literal|0
condition|)
name|states
operator|&=
operator|~
name|ERRFLG
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|argt
operator|)
operator|&&
name|execbrk
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|type
decl_stmt|;
name|char
modifier|*
modifier|*
name|com
decl_stmt|;
name|int
name|argn
decl_stmt|;
name|char
modifier|*
name|com0
init|=
name|NIL
decl_stmt|;
name|type
operator|=
name|t
operator|->
name|tretyp
expr_stmt|;
name|oldexit
operator|=
name|exitval
expr_stmt|;
name|exitval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
name|COMMSK
condition|)
block|{
case|case
name|TCOM
case|:
block|{
specifier|register
name|IOPTR
name|io
decl_stmt|;
specifier|register
name|ARGPTR
name|argp
decl_stmt|;
name|NAMPTR
name|np
decl_stmt|;
name|type
operator|>>=
operator|(
name|COMBITS
operator|+
literal|1
operator|)
expr_stmt|;
name|cmdline
operator|=
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comline
expr_stmt|;
name|com
operator|=
name|arg_build
argument_list|(
operator|&
name|argn
argument_list|,
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tretyp
operator|&
name|COMSCAN
condition|)
block|{
name|argp
operator|=
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comarg
expr_stmt|;
if|if
condition|(
name|argp
operator|&&
operator|(
name|argp
operator|->
name|argflag
operator|&
name|A_RAW
operator|)
operator|==
literal|0
condition|)
name|type
operator|=
name|syslook
argument_list|(
name|com
index|[
literal|0
index|]
argument_list|,
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
block|}
name|com0
operator|=
name|com
index|[
literal|0
index|]
expr_stmt|;
name|argp
operator|=
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comset
expr_stmt|;
name|io
operator|=
name|t
operator|->
name|treio
expr_stmt|;
if|if
condition|(
name|argn
operator|==
literal|0
operator|||
operator|(
name|type
operator|>
literal|0
operator|&&
name|type
operator|<=
name|SYSSPECIAL
operator|)
condition|)
block|{
name|setlist
argument_list|(
name|argp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|io
operator|||
name|argn
operator|)
operator|&&
name|is_option
argument_list|(
name|NOEXEC
argument_list|)
operator|==
literal|0
condition|)
comment|/* print command if EXECPR */
block|{
if|if
condition|(
name|argn
operator|==
literal|0
condition|)
block|{
comment|/* fake a built-in */
name|argn
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|SYSMAX
expr_stmt|;
block|}
comment|/* set +x doesn't echo */
elseif|else
if|if
condition|(
name|type
operator|!=
name|SYSSET
condition|)
block|{
name|trace_command
argument_list|(
name|com
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
condition|)
name|p_flush
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|is_option
argument_list|(
name|INPROC
argument_list|)
operator|&&
name|type
operator|==
literal|0
operator|&&
operator|(
name|states
operator|&
name|FORKED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|findnod
argument_list|(
name|com0
argument_list|,
name|prnames
argument_list|,
name|CHK_FOR
argument_list|)
condition|)
block|{
name|type
operator|=
name|SYSINPROCESS
expr_stmt|;
name|com
operator|--
expr_stmt|;
name|argn
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* apollo */
comment|/* check for builtins */
if|if
condition|(
name|type
condition|)
block|{
comment|/* failures on built-ins not fatal */
name|jmp_buf
name|retbuf
decl_stmt|;
name|jmp_buf
modifier|*
name|savreturn
init|=
name|freturn
decl_stmt|;
name|int
name|indx
init|=
name|topfd
decl_stmt|;
name|int
name|scope
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|SYSNULL
condition|)
name|freturn
operator|=
operator|(
name|jmp_buf
operator|*
operator|)
name|retbuf
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|retbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|flag
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|SYSNULL
condition|)
name|states
operator||=
name|BUILTIN
expr_stmt|;
else|else
block|{
name|flag
operator|=
operator|(
name|type
operator|!=
name|SYSLOGIN
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYSEXEC
condition|)
name|flag
operator|=
operator|-
operator|(
name|com
index|[
literal|1
index|]
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|indx
operator|=
name|initio
argument_list|(
name|io
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
condition|)
block|{
name|mem_scope
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|scope
operator|++
expr_stmt|;
block|}
name|builtin
argument_list|(
name|type
argument_list|,
name|argn
argument_list|,
name|com
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|states
operator|&=
operator|~
name|BUILTIN
expr_stmt|;
name|freturn
operator|=
name|savreturn
expr_stmt|;
if|if
condition|(
name|scope
condition|)
name|mem_unscope
argument_list|()
expr_stmt|;
name|restore
argument_list|(
name|indx
argument_list|)
expr_stmt|;
goto|goto
name|setexit
goto|;
block|}
comment|/* check for functions */
if|if
condition|(
operator|(
name|np
operator|=
name|findnod
argument_list|(
name|com0
argument_list|,
name|prnames
argument_list|,
name|CHK_FOR
argument_list|)
operator|)
operator|&&
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|ip
condition|)
block|{
name|int
name|indx
decl_stmt|;
name|indx
operator|=
name|initio
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exfunct
argument_list|(
call|(
name|TREPTR
call|)
argument_list|(
operator|*
name|funtree
argument_list|(
name|np
argument_list|)
argument_list|)
argument_list|,
name|com
argument_list|,
name|execflg
operator||
operator|(
name|attest
argument_list|(
name|np
argument_list|,
name|T_FLAG
argument_list|)
condition|?
name|EXECPR
else|:
literal|0
operator|)
argument_list|,
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comset
argument_list|)
expr_stmt|;
name|restore
argument_list|(
name|indx
argument_list|)
expr_stmt|;
goto|goto
name|setexit
goto|;
block|}
comment|/* track alias if possible */
name|getpath
argument_list|(
name|com0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io
operator|==
literal|0
condition|)
block|{
name|setexit
label|:
name|exitset
argument_list|()
expr_stmt|;
name|chktrap
argument_list|()
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|TCOM
expr_stmt|;
block|}
case|case
name|TFORK
case|:
block|{
name|int
name|no_fork
decl_stmt|;
name|sync_io
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SXT
comment|/* find job number and create synchronization pipe */
if|if
condition|(
operator|(
name|jobstat
operator|.
name|cur_job
operator|=
name|next_job
argument_list|()
operator|)
operator|<
name|jobstat
operator|.
name|maxjob
condition|)
if|if
condition|(
name|pipe
argument_list|(
name|jobstat
operator|.
name|pipe
argument_list|)
operator|<
literal|0
condition|)
name|jobstat
operator|.
name|maxjob
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
name|no_fork
operator|=
operator|(
name|execflg
operator|&
literal|1
operator|)
operator|&&
operator|(
name|type
operator|&
operator|(
name|FAMP
operator||
name|FPOU
operator|)
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|no_fork
condition|)
name|parent
operator|=
literal|0
expr_stmt|;
else|else
comment|/* FORKLIM is the max period between forks - 					power of 2 usually.  Currently shell tries after 					2,4,8,16, and 32 seconds and then quits */
block|{
specifier|register
name|int
name|forkcnt
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|FTMP
condition|)
block|{
name|link_iodocs
argument_list|(
name|iotemp
argument_list|)
expr_stmt|;
name|linked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
operator|(
name|FPCL
operator||
name|FPIN
operator||
name|FPOU
operator|)
operator|)
operator|==
operator|(
name|FPIN
operator||
name|FPOU
operator|)
condition|)
comment|/* set up pipe for cooperating process */
block|{
if|if
condition|(
name|cpid
condition|)
name|failed
argument_list|(
name|cmdadr
argument_list|,
name|pexists
argument_list|)
expr_stmt|;
name|chkpipe
argument_list|(
name|pf2
operator|=
name|otpipe
argument_list|)
expr_stmt|;
name|cpipe
index|[
name|INPIPE
index|]
operator|=
name|frenumber
argument_list|(
name|pf2
index|[
name|INPIPE
index|]
argument_list|,
name|CINPIPE
argument_list|)
expr_stmt|;
name|chkpipe
argument_list|(
name|pf1
operator|=
name|inpipe
argument_list|)
expr_stmt|;
name|cpipe
index|[
name|OTPIPE
index|]
operator|=
name|frenumber
argument_list|(
name|pf1
index|[
name|OTPIPE
index|]
argument_list|,
name|COTPIPE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VFORK
if|if
condition|(
name|v_fork
operator|=
name|vfork_check
argument_list|(
name|t
argument_list|)
condition|)
name|vfork_save
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|parent
operator|=
operator|(
name|v_fork
condition|?
name|vfork
argument_list|()
else|:
name|fork
argument_list|()
operator|)
operator|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|parent
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/* VFORK */
block|{
if|if
condition|(
operator|(
name|forkcnt
operator|*=
literal|2
operator|)
operator|>
name|FORKLIM
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOMEM
case|:
name|error
argument_list|(
name|noswap
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|EAGAIN
case|:
name|error
argument_list|(
name|nofork
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|forkcnt
argument_list|)
expr_stmt|;
name|pause
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parent
condition|)
comment|/* This is the parent branch of fork;    */
comment|/* it may or may not wait for the child. */
block|{
specifier|register
name|int
name|pno
decl_stmt|;
ifdef|#
directive|ifdef
name|VFORK
if|if
condition|(
name|v_fork
condition|)
name|vfork_restore
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VFORK */
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|jobstat
operator|.
name|pipe
index|[
literal|1
index|]
operator|>
literal|0
condition|)
name|close
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
comment|/* assign each pipeline its own process group */
if|if
condition|(
name|jobstat
operator|.
name|j_flag
operator|==
literal|0
operator|||
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
condition|)
name|jobstat
operator|.
name|cur_pgrp
operator|=
name|parent
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
name|type
operator|&
name|FPCL
condition|)
name|fclose
argument_list|(
name|pf1
index|[
name|INPIPE
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|FPIN
operator|)
operator|&&
operator|(
name|type
operator|&
name|FPOU
operator|)
condition|)
block|{
name|cpid
operator|=
name|parent
expr_stmt|;
name|fclose
argument_list|(
name|pf1
index|[
name|INPIPE
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pf2
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
operator|(
name|FAMP
operator||
name|FPOU
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEVFD
name|close_pipes
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFD */
name|await
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|&
operator|(
name|FPOU
operator||
name|FPIN
operator|)
condition|)
block|{
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|cpid
operator|==
name|parent
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
else|else
name|flag
operator|=
name|P_PIPEJOB
expr_stmt|;
name|pno
operator|=
name|post
argument_list|(
name|parent
argument_list|,
name|flag
argument_list|)
expr_stmt|;
else|#
directive|else
name|pno
operator|=
name|post
argument_list|(
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|JOBS
name|pno
operator|=
name|post
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pno
operator|=
name|post
argument_list|(
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|movstr
argument_list|(
name|itos
argument_list|(
name|parent
argument_list|)
argument_list|,
name|pcsadr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|FPRS
operator|)
operator|&&
operator|(
name|states
operator|&
name|TTYFLG
operator|)
condition|)
block|{
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
comment|/* print job number */
name|p_sub
argument_list|(
name|pno
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|p_num
argument_list|(
name|parent
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
name|chktrap
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
comment|/* 				 * this is the FORKED branch (child) of execute 				 */
block|{
if|if
condition|(
name|standout
operator|!=
name|stdout
condition|)
name|standout
operator|=
name|frenumber
argument_list|(
name|standout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|states
operator||=
name|FORKED
expr_stmt|;
name|off_option
argument_list|(
name|HASHALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_fork
operator|==
literal|0
condition|)
block|{
name|states
operator|&=
operator|~
operator|(
name|RM_TMP
operator||
name|IS_TMP
operator|)
expr_stmt|;
name|states
operator||=
name|NO_TMP
expr_stmt|;
if|if
condition|(
name|linked
operator|==
literal|1
condition|)
block|{
name|swap_iodoc_nm
argument_list|(
name|iotemp
argument_list|)
expr_stmt|;
name|linked
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|iotemp
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACCT
name|suspacct
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ACCT */
comment|/* child should not unlink the tmpfile */
name|cpipe
index|[
name|INPIPE
index|]
operator|=
name|cpipe
index|[
name|OTPIPE
index|]
operator|=
name|NULL
expr_stmt|;
name|cpid
operator|=
literal|0
expr_stmt|;
comment|/* Turn off INTR and QUIT if `FINT'  */
comment|/* Reset remaining signals to parent */
comment|/* except for those `lost' by trap   */
name|oldsigs
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
if|if
condition|(
name|states
operator|&
name|MONITOR
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
specifier|register
name|int
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|int
name|pgrp
decl_stmt|;
if|if
condition|(
name|jobstat
operator|.
name|j_flag
operator|==
literal|0
condition|)
name|pgrp
operator|=
name|pid
expr_stmt|;
else|else
name|pgrp
operator|=
name|jobstat
operator|.
name|cur_pgrp
expr_stmt|;
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|NONSTOP
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|else
block|{
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|jobstat
operator|.
name|cur_job
operator|<
name|jobstat
operator|.
name|maxjob
operator|||
operator|(
name|type
operator|&
name|FAMP
operator|)
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|DEVFD
if|if
condition|(
operator|(
name|type
operator|&
operator|(
name|FINT
operator||
name|FAMP
operator|)
operator|)
operator|==
operator|(
name|FINT
operator||
name|FAMP
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|type
operator|&
name|FAMP
condition|)
endif|#
directive|endif
comment|/* DEVFD */
endif|#
directive|endif
comment|/* SXT */
name|setpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
elseif|else
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
name|type
operator|&
name|FINT
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
comment|/* pipe in or out */
if|if
condition|(
operator|(
name|type
operator|&
name|FAMP
operator|)
operator|&&
name|is_option
argument_list|(
name|BGNICE
argument_list|)
condition|)
name|nice
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|#
directive|if
name|VSH
operator|||
name|ESH
if|if
condition|(
name|type
operator|&
operator|(
name|FAMP
operator||
name|FPOU
operator|)
condition|)
name|off_option
argument_list|(
name|EMACS
operator||
name|EDITVI
operator||
name|GMACS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|&
name|FPIN
condition|)
block|{
name|frenumber
argument_list|(
name|pf1
index|[
name|INPIPE
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|FPOU
operator|)
operator|==
literal|0
condition|)
name|fclose
argument_list|(
name|pf1
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
name|FPOU
condition|)
block|{
name|frenumber
argument_list|(
name|pf2
index|[
name|OTPIPE
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pipe_close
argument_list|(
name|pf2
argument_list|)
expr_stmt|;
block|}
comment|/* default std input for& */
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* BSD */
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
operator|||
name|jobstat
operator|.
name|cur_job
operator|>=
name|jobstat
operator|.
name|maxjob
condition|)
block|{
endif|#
directive|endif
comment|/* SXT */
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
operator|(
name|type
operator|&
name|FINT
operator|)
operator|&&
name|ioset
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|chkopen
argument_list|(
name|devnull
argument_list|)
expr_stmt|;
block|}
comment|/* io redirection */
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|SXT
block|}
else|else
name|j_new_chan
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
name|states
operator|&=
operator|~
name|MONITOR
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|initio
argument_list|(
name|t
operator|->
name|treio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TCOM
condition|)
block|{
comment|/* don't clear job table for out 						   pipes so that jobs can be 						   piped 						 */
if|if
condition|(
name|no_fork
operator|==
literal|0
operator|&&
operator|(
name|type
operator|&
name|FPOU
operator|)
operator|==
literal|0
condition|)
name|postclr
argument_list|()
expr_stmt|;
name|execute
argument_list|(
operator|(
operator|(
name|FORKPTR
operator|)
name|t
operator|)
operator|->
name|forktre
argument_list|,
name|execflg
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com0
operator|!=
name|ENDARGS
condition|)
block|{
name|off_option
argument_list|(
name|ERRFLG
argument_list|)
expr_stmt|;
name|rmtemp
argument_list|(
operator|(
name|IOPTR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execa
argument_list|(
name|com
argument_list|,
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comset
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|TSETIO
case|:
block|{
comment|/* 			 * don't create a new process, just 			 * save and restore io-streams 			 */
name|int
name|indx
init|=
name|initio
argument_list|(
operator|(
operator|(
name|FORKPTR
operator|)
name|t
operator|)
operator|->
name|forkio
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|execute
argument_list|(
operator|(
operator|(
name|FORKPTR
operator|)
name|t
operator|)
operator|->
name|forktre
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
name|restore
argument_list|(
name|indx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TPAR
case|:
name|execute
argument_list|(
operator|(
operator|(
name|PARPTR
operator|)
name|t
operator|)
operator|->
name|partre
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|TFIL
case|:
block|{
comment|/* 			 * This code sets up a pipe. 			 * All elements of the pipe are started by the parent. 			 * Only the last one is waited for. 			 */
specifier|register
name|FORKPTR
name|tf
decl_stmt|;
name|FILE
modifier|*
name|pvo
index|[
literal|2
index|]
decl_stmt|;
comment|/* old pipe for multi-pipeline */
name|FILE
modifier|*
name|pvn
index|[
literal|2
index|]
decl_stmt|;
comment|/* set up pipe */
specifier|register
name|int
name|rc
init|=
literal|1
decl_stmt|;
do|do
block|{
comment|/* create the pipe */
name|chkpipe
argument_list|(
name|pvn
argument_list|)
expr_stmt|;
name|tf
operator|=
call|(
name|FORKPTR
call|)
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstlef
argument_list|)
expr_stmt|;
comment|/* rc==0 on multi-stage pipe */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|tf
operator|->
name|forktyp
operator||=
name|FPCL
operator||
name|FPIN
expr_stmt|;
comment|/* execute out part of pipe no wait */
name|rc
operator|=
name|execute
argument_list|(
operator|(
name|TREPTR
operator|)
name|tf
argument_list|,
name|errorflg
argument_list|,
name|pvo
argument_list|,
name|pvn
argument_list|)
expr_stmt|;
name|tf
operator|=
call|(
name|FORKPTR
call|)
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstrit
argument_list|)
expr_stmt|;
name|t
operator|=
name|tf
operator|->
name|forktre
expr_stmt|;
comment|/* save the pipe stream-ids */
name|pvo
index|[
literal|0
index|]
operator|=
name|pvn
index|[
literal|0
index|]
expr_stmt|;
comment|/*close out-part of pipe as soon as possible */
name|fclose
argument_list|(
name|pvn
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
comment|/* pipeline all in one process group */
name|jobstat
operator|.
name|j_flag
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
block|}
comment|/* repeat until end of pipeline */
do|while
condition|(
name|rc
operator|==
literal|0
operator|&&
name|tf
operator|->
name|forkio
operator|==
name|NULL
operator|&&
name|t
operator|->
name|tretyp
operator|==
name|TFIL
condition|)
do|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|execute
argument_list|(
operator|(
name|TREPTR
operator|)
name|tf
argument_list|,
name|execflg
argument_list|,
name|pvn
argument_list|,
name|pf2
argument_list|)
expr_stmt|;
else|else
comment|/* execution failure, close pipe */
name|pipe_close
argument_list|(
name|pvn
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TLST
case|:
block|{
comment|/*  a list of commands are executed here */
do|do
block|{
name|execute
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstlef
argument_list|,
name|errorflg
argument_list|)
expr_stmt|;
name|t
operator|=
call|(
name|TREPTR
call|)
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstrit
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|->
name|tretyp
operator|==
name|TLST
condition|)
do|;
name|execute
argument_list|(
name|t
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TAND
case|:
ifdef|#
directive|ifdef
name|JOBS
name|states
operator||=
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
name|execute
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstlef
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|execute
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstrit
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TORF
case|:
ifdef|#
directive|ifdef
name|JOBS
name|states
operator||=
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
name|execute
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstlef
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|execute
argument_list|(
operator|(
operator|(
name|LSTPTR
operator|)
name|t
operator|)
operator|->
name|lstrit
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFOR
case|:
case|case
name|TSELECT
case|:
block|{
specifier|register
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
specifier|register
name|int
name|nargs
decl_stmt|;
name|NAMPTR
name|n
init|=
name|lookup
argument_list|(
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|fornam
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|DOLPTR
name|argsav
init|=
name|NULL
decl_stmt|;
name|COMPTR
name|tp
decl_stmt|;
name|char
modifier|*
name|nullptr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|states
operator||=
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
operator|(
name|tp
operator|=
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|forlst
operator|)
operator|==
name|NULL
condition|)
block|{
name|args
operator|=
name|dolv
operator|+
literal|1
expr_stmt|;
name|nargs
operator|=
name|dolc
expr_stmt|;
name|argsav
operator|=
name|arg_use
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|args
operator|=
name|arg_build
argument_list|(
operator|&
name|argn
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|argn
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TSELECT
condition|)
block|{
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p_list
argument_list|(
name|nargs
argument_list|,
name|arglist
operator|=
name|args
argument_list|)
expr_stmt|;
block|}
name|loopcnt
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|!=
name|ENDARGS
operator|&&
name|execbrk
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|tretyp
operator|==
name|TSELECT
condition|)
block|{
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* reuse register */
define|#
directive|define
name|c
value|type
name|chkpr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|states
operator||=
name|PROMPT
expr_stmt|;
name|readvar
argument_list|(
operator|&
name|nullptr
argument_list|,
name|stdin
argument_list|,
name|R_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|exitval
operator|=
literal|1
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|qvalup
argument_list|(
name|REPLYNOD
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|val
operator|)
operator|==
literal|0
condition|)
block|{
name|p_list
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
if|if
condition|(
name|c
operator|<
literal|'0'
operator|&&
name|c
operator|>
literal|'9'
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|c
operator|=
name|nargs
expr_stmt|;
else|else
name|c
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>=
name|nargs
condition|)
name|c
operator|=
name|nargs
expr_stmt|;
name|args
operator|+=
name|c
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|c
name|assign
argument_list|(
name|n
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tretyp
operator|!=
name|TSELECT
condition|)
name|args
operator|++
expr_stmt|;
else|else
name|args
operator|=
name|arglist
expr_stmt|;
name|execute
argument_list|(
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|fortre
argument_list|,
name|errorflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakcnt
operator|<
literal|0
condition|)
name|execbrk
operator|=
operator|(
operator|++
name|breakcnt
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|breakcnt
operator|>
literal|0
condition|)
name|execbrk
operator|=
operator|(
operator|--
name|breakcnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|loopcnt
operator|--
expr_stmt|;
name|arg_free
argument_list|(
name|argsav
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TWH
case|:
case|case
name|TUN
case|:
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|states
operator||=
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|loopcnt
operator|++
expr_stmt|;
while|while
condition|(
name|execbrk
operator|==
literal|0
operator|&&
operator|(
name|execute
argument_list|(
operator|(
operator|(
name|WHPTR
operator|)
name|t
operator|)
operator|->
name|whtre
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
operator|==
operator|(
name|type
operator|==
name|TWH
operator|)
condition|)
block|{
name|i
operator|=
name|execute
argument_list|(
operator|(
operator|(
name|WHPTR
operator|)
name|t
operator|)
operator|->
name|dotre
argument_list|,
name|errorflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakcnt
operator|<
literal|0
condition|)
name|execbrk
operator|=
operator|(
operator|++
name|breakcnt
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|breakcnt
operator|>
literal|0
condition|)
name|execbrk
operator|=
operator|(
operator|--
name|breakcnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|loopcnt
operator|--
expr_stmt|;
name|exitval
operator|=
name|i
expr_stmt|;
break|break;
block|}
case|case
name|TIF
case|:
ifdef|#
directive|ifdef
name|JOBS
name|states
operator||=
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
name|execute
argument_list|(
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|iftre
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|execute
argument_list|(
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|thtre
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|eltre
condition|)
name|execute
argument_list|(
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|eltre
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
else|else
name|exitval
operator|=
literal|0
expr_stmt|;
comment|/* force zero exit for if-then-fi */
break|break;
case|case
name|TSW
case|:
block|{
name|char
modifier|*
name|r
init|=
name|mactrim
argument_list|(
operator|(
operator|(
name|SWPTR
operator|)
name|t
operator|)
operator|->
name|swarg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|t
operator|=
call|(
name|TREPTR
call|)
argument_list|(
operator|(
name|SWPTR
operator|)
name|t
argument_list|)
operator|->
name|swlst
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
specifier|register
name|ARGPTR
name|rex
init|=
call|(
name|ARGPTR
call|)
argument_list|(
operator|(
name|REGPTR
operator|)
name|t
argument_list|)
operator|->
name|regptr
decl_stmt|;
while|while
condition|(
name|rex
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|rex
operator|->
name|argflag
operator|&
name|A_MAC
condition|)
name|s
operator|=
name|macro
argument_list|(
name|rex
operator|->
name|argval
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|rex
operator|->
name|argval
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rex
operator|->
name|argflag
operator|&
name|A_RAW
operator|)
operator|==
literal|0
operator|&&
name|gmatch
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
operator|)
operator|||
name|trim_eq
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|execute
argument_list|(
operator|(
operator|(
name|REGPTR
operator|)
name|t
operator|)
operator|->
name|regcom
argument_list|,
name|errorflg
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|rex
operator|=
name|rex
operator|->
name|argnxt
expr_stmt|;
block|}
if|if
condition|(
name|t
condition|)
name|t
operator|=
call|(
name|TREPTR
call|)
argument_list|(
operator|(
name|REGPTR
operator|)
name|t
argument_list|)
operator|->
name|regnxt
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TTIME
case|:
block|{
comment|/* time the command */
name|struct
name|tms
name|before
decl_stmt|,
name|after
decl_stmt|;
name|long
name|at
decl_stmt|,
name|bt
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|struct
name|timeb
name|tb
decl_stmt|,
name|ta
decl_stmt|;
name|ftime
argument_list|(
operator|&
name|tb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|bt
operator|=
name|times
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
name|execute
argument_list|(
operator|(
operator|(
name|PARPTR
operator|)
name|t
operator|)
operator|->
name|partre
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|at
operator|=
name|times
argument_list|(
operator|&
name|after
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|ftime
argument_list|(
operator|&
name|ta
argument_list|)
expr_stmt|;
name|at
operator|=
name|TIC_SEC
operator|*
operator|(
name|ta
operator|.
name|time
operator|-
name|tb
operator|.
name|time
operator|)
expr_stmt|;
name|at
operator|+=
operator|(
operator|(
name|TIC_SEC
operator|*
operator|(
call|(
name|long
call|)
argument_list|(
name|ta
operator|.
name|millitm
operator|-
name|tb
operator|.
name|millitm
argument_list|)
operator|)
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
else|#
directive|else
name|at
operator|-=
name|bt
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|t_real
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|p_time
argument_list|(
name|at
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|t_user
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|at
operator|=
name|after
operator|.
name|tms_utime
operator|-
name|before
operator|.
name|tms_utime
expr_stmt|;
name|at
operator|+=
name|after
operator|.
name|tms_cutime
operator|-
name|before
operator|.
name|tms_cutime
expr_stmt|;
name|p_time
argument_list|(
name|at
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|t_sys
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|at
operator|=
name|after
operator|.
name|tms_stime
operator|-
name|before
operator|.
name|tms_stime
expr_stmt|;
name|at
operator|+=
name|after
operator|.
name|tms_cstime
operator|-
name|before
operator|.
name|tms_cstime
expr_stmt|;
name|p_time
argument_list|(
name|at
argument_list|,
name|NL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TPROC
case|:
block|{
specifier|register
name|NAMPTR
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|fname
init|=
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|procnam
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|fname
argument_list|)
condition|)
name|failed
argument_list|(
name|fname
argument_list|,
name|notid
argument_list|)
expr_stmt|;
name|np
operator|=
name|findnod
argument_list|(
name|fname
argument_list|,
name|prnames
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|rp
condition|)
name|free
argument_list|(
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|rp
operator|->
name|ptree
argument_list|)
expr_stmt|;
else|else
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|rp
operator|=
operator|(
expr|struct
name|Ufunction
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Ufunction
argument_list|)
argument_list|)
expr_stmt|;
name|funtree
argument_list|(
name|np
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|*
operator|)
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|proctre
expr_stmt|;
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|rp
operator|->
name|hoffset
operator|=
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|procloc
expr_stmt|;
name|sattrib
argument_list|(
name|np
argument_list|,
name|L_FLAG
operator||
name|INT_GER
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|JOBS
name|jobstat
operator|.
name|j_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
comment|/* set $. */
if|if
condition|(
name|com0
condition|)
block|{
if|if
condition|(
name|lastarg
operator|!=
name|locbuf
condition|)
name|free
argument_list|(
name|lastarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|com
index|[
name|argn
operator|-
literal|1
index|]
argument_list|)
operator|<
name|TMPSIZ
condition|)
name|lastarg
operator|=
name|strcpy
argument_list|(
name|locbuf
argument_list|,
name|com
index|[
name|argn
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|lastarg
operator|=
name|heap
argument_list|(
name|com
index|[
name|argn
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|exitset
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
operator||
name|exitval
argument_list|)
expr_stmt|;
name|tdystak
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|states
operator||=
name|errorflg
expr_stmt|;
name|linked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|exitval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * test for equality with second argument trimmed  * returns 1 if r == trim(s) otherwise 0  */
end_comment

begin_expr_stmt
specifier|static
name|trim_eq
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
specifier|register
name|char
operator|*
name|r
operator|,
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|*
name|r
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|r
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * print out the command line if set -x is on  */
end_comment

begin_function
name|void
name|trace_command
parameter_list|(
name|com
parameter_list|)
name|char
modifier|*
modifier|*
name|com
decl_stmt|;
block|{
if|if
condition|(
name|is_option
argument_list|(
name|EXECPR
argument_list|)
condition|)
block|{
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|execpmsg
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|echo_list
argument_list|(
literal|1
argument_list|,
name|com
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

