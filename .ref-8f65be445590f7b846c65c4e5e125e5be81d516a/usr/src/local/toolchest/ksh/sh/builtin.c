begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)builtin.c	1.1 */
end_comment

begin_comment
comment|/*  *  builtin routines for the shell  *  *   David Korn  *   AT&T Bell Laboratories  *   Room 5D-112  *   Murray Hill, N. J. 07974  *   Tel. x7975  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* needed for ulimit */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_comment
comment|/* needed for ulimit */
end_comment

begin_define
define|#
directive|define
name|LIM_FSIZE
value|RLIMIT_FSIZE
end_define

begin_define
define|#
directive|define
name|LIM_DATA
value|RLIMIT_DATA
end_define

begin_define
define|#
directive|define
name|LIM_STACK
value|RLIMIT_STACK
end_define

begin_define
define|#
directive|define
name|LIM_CORE
value|RLIMIT_CORE
end_define

begin_define
define|#
directive|define
name|LIM_CPU
value|RLIMIT_CPU
end_define

begin_define
define|#
directive|define
name|LIM_MAXRSS
value|RLIMIT_RSS
end_define

begin_define
define|#
directive|define
name|INFINITY
value|RLIM_INFINITY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_comment
comment|/* This module defines these routines */
end_comment

begin_function_decl
name|void
name|builtin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|execexp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This module references these external routines */
end_comment

begin_function_decl
specifier|extern
name|long
name|aeval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|arg_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|await
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|cannon_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|catpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|checkfor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|chkopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|clrsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|TREPTR
name|cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_whence
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|done
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ECHO_N
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|echo_mode
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECHO_N */
end_comment

begin_function_decl
specifier|extern
name|int
name|estabf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|execa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fassign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|getsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gscan_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|heap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_cancel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|histloc
name|hist_find
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hist_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_subst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hist_position
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|initf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|oldsigs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|pathopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|pipe_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|printflg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|prinscan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|printnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|realias
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|substitute
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|tmp_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|trace_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|unassign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|utos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flagset
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cmd_name
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sig_number
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mycom
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_function_decl
specifier|static
name|void
name|sig_list
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_function
name|void
name|builtin
parameter_list|(
name|xbuiltin
parameter_list|,
name|argn
parameter_list|,
name|com
parameter_list|,
name|t
parameter_list|)
name|int
name|argn
decl_stmt|;
specifier|register
name|char
modifier|*
name|com
index|[]
decl_stmt|;
name|TREPTR
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|a1
init|=
name|com
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|struct
name|Amemory
modifier|*
name|troot
decl_stmt|;
name|int
name|scoped
init|=
literal|0
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|cmd_name
operator|=
name|com
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|xbuiltin
condition|)
block|{
case|case
name|SYSEXEC
case|:
name|com
operator|++
expr_stmt|;
name|ioset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
break|break;
case|case
name|SYSLOGIN
case|:
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|restricted
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|JOBS
if|if
condition|(
name|close_jobs
argument_list|()
operator|<
literal|0
condition|)
block|{
name|exitval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* JOBS */
comment|/* force bad exec to terminate shell */
name|states
operator|&=
operator|~
operator|(
name|TTYFLG
operator||
name|BUILTIN
operator|)
expr_stmt|;
name|oldsigs
argument_list|()
expr_stmt|;
name|hist_close
argument_list|()
expr_stmt|;
name|rmtemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|execa
argument_list|(
name|com
argument_list|,
operator|(
name|ARGPTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
case|case
name|SYSTEST
case|:
comment|/* test	expression */
name|exitval
operator|=
name|testfn
argument_list|(
name|argn
argument_list|,
name|com
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSPWD
case|:
comment|/* pwd routine */
name|argn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mycom
operator|=
name|getpwd
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|pwderr
argument_list|)
expr_stmt|;
name|com
operator|=
name|mycom
operator|-
literal|1
expr_stmt|;
case|case
name|SYSECHO
case|:
comment|/* system V echo routine */
comment|/* equivalent to print - */
name|com
operator|--
expr_stmt|;
name|argn
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ECHO_N
comment|/* This mess is because /bin/echo on BSD is archaic */
name|a1
operator|=
name|echo_mode
argument_list|()
expr_stmt|;
else|#
directive|else
name|a1
operator|=
name|minus
expr_stmt|;
endif|#
directive|endif
comment|/* ECHO_N */
case|case
name|SYSPRINT
case|:
comment|/* print routine */
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|raw
init|=
literal|0
decl_stmt|;
name|wdnum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
name|int
name|c
init|=
operator|*
operator|(
name|a1
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* handle the -R flag for BSD style echo */
if|if
condition|(
name|flag
operator|&
name|R_JUST
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|a1
argument_list|,
literal|"-n"
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
break|break;
block|}
name|flag
operator||=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
operator|(
name|N_FLAG
operator||
name|R_FLAG
operator||
name|P_FLAG
operator||
name|U_FLAG
operator||
name|S_FLAG
operator||
name|R_JUST
operator|)
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
name|argn
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|a1
operator|=
name|com
index|[
literal|1
index|]
expr_stmt|;
block|}
name|wdnum
operator|%=
literal|10
expr_stmt|;
if|if
condition|(
name|flag
operator|&
operator|(
name|R_FLAG
operator||
name|R_JUST
operator|)
condition|)
name|raw
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|S_FLAG
condition|)
block|{
comment|/* print to history file */
name|hist_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|fc_fix
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|nohistory
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fc_fix
operator|->
name|fixfd
expr_stmt|;
name|states
operator||=
name|FIXFLG
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|P_FLAG
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|cpipe
index|[
name|OTPIPE
index|]
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|noquery
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|U_FLAG
condition|)
block|{
name|fd
operator|=
name|file_fd
argument_list|(
name|wdnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fiswrite
argument_list|(
name|fd
argument_list|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badfile
argument_list|)
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|standout
expr_stmt|;
name|clearerr
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|p_setout
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
name|echo_list
argument_list|(
name|raw
argument_list|,
name|com
operator|+
literal|1
argument_list|,
name|fd
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|N_FLAG
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
name|NL
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|S_FLAG
condition|)
name|hist_flush
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|SYSLET
case|:
block|{
if|if
condition|(
name|argn
operator|<
literal|2
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argn
condition|)
name|exitval
operator|=
operator|!
name|aeval
argument_list|(
operator|*
operator|++
name|com
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The following few builtins are provided to set,print, 		 * and test attributes and variables for shell variables, 		 * aliases, and functions. 		 * In addition, typeset -f can be used to test whether a 		 * function has been defined or to list all defined functions 		 * Note readonly is same as typeset -r. 		 * Note export is same as typeset -x. 		 */
case|case
name|SYSRDONLY
case|:
name|flag
operator|=
name|R_FLAG
expr_stmt|;
name|aflag
operator|=
literal|'-'
expr_stmt|;
goto|goto
name|typset
goto|;
case|case
name|SYSXPORT
case|:
name|flag
operator|=
name|X_FLAG
expr_stmt|;
name|aflag
operator|=
literal|'-'
expr_stmt|;
goto|goto
name|typset
goto|;
case|case
name|SYSALIAS
case|:
case|case
name|SYSTYPESET
case|:
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* 0 for typeset, non-zero for alias */
name|flag
operator|=
literal|0
expr_stmt|;
name|aflag
operator|=
operator|(
name|a1
condition|?
operator|*
name|a1
else|:
literal|0
operator|)
expr_stmt|;
name|wdnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
literal|'-'
operator|||
name|aflag
operator|==
literal|'+'
condition|)
block|{
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
operator|(
name|L_JUST
operator||
name|R_JUST
operator||
name|Z_FILL
operator||
name|INT_GER
operator||
name|L_TO_U
operator||
name|U_TO_L
operator||
name|X_FLAG
operator||
name|R_FLAG
operator||
name|F_FLAG
operator||
name|P_FLAG
operator||
name|T_FLAG
operator||
name|A_FLAG
operator|)
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|INT_GER
operator|)
operator|&&
operator|(
name|flag
operator|&
operator|(
name|L_JUST
operator||
name|R_JUST
operator||
name|Z_FILL
operator|)
operator|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
comment|/* S_FLAG forces name to be in newest scope */
if|if
condition|(
name|fn_depth
condition|)
name|scoped
operator|=
name|S_FLAG
expr_stmt|;
name|typset
label|:
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xbuiltin
operator|==
name|SYSALIAS
condition|)
block|{
if|if
condition|(
name|flag
operator|&
operator|~
operator|(
name|N_EXPORT
operator||
name|T_FLAG
operator|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
name|troot
operator|=
name|alias
expr_stmt|;
comment|/* setname treats this value specially */
name|type
operator|=
name|V_FLAG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|F_FLAG
condition|)
block|{
if|if
condition|(
name|flag
operator|&
operator|~
operator|(
name|N_EXPORT
operator||
name|F_FLAG
operator||
name|T_FLAG
operator|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
name|troot
operator|=
name|prnames
expr_stmt|;
name|flag
operator|&=
operator|~
name|F_FLAG
expr_stmt|;
block|}
else|else
name|troot
operator|=
name|namep
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|P_FLAG
condition|)
block|{
name|flag
operator|&=
operator|~
name|P_FLAG
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|cpipe
index|[
name|OTPIPE
index|]
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|noquery
argument_list|)
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|standout
expr_stmt|;
name|p_setout
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|prinscan
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|troot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|gscan_all
argument_list|(
name|printflg
argument_list|,
name|troot
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|com
index|[
literal|1
index|]
condition|)
block|{
while|while
condition|(
name|a1
operator|=
operator|*
operator|++
name|com
condition|)
block|{
specifier|register
name|unsigned
name|newflag
decl_stmt|;
specifier|register
name|struct
name|Namnod
modifier|*
name|np
decl_stmt|;
name|struct
name|Namnod
modifier|*
name|setname
parameter_list|()
function_decl|;
name|unsigned
name|curflag
decl_stmt|;
if|if
condition|(
name|troot
operator|==
name|prnames
condition|)
block|{
comment|/* 						 *functions can be exported or 						 * traced but not set 						 */
if|if
condition|(
name|np
operator|=
name|checkfor
argument_list|(
name|a1
argument_list|,
name|prnames
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|N_EXPORT
operator||
name|T_FLAG
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printnam
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aflag
operator|==
literal|'-'
condition|)
name|attrib
argument_list|(
name|np
argument_list|,
name|flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aflag
operator|==
literal|'+'
condition|)
name|pattrib
argument_list|(
name|np
argument_list|,
operator|~
name|flag
argument_list|)
expr_stmt|;
block|}
else|else
name|exitval
operator|++
expr_stmt|;
continue|continue;
block|}
name|np
operator|=
name|setname
argument_list|(
name|a1
argument_list|,
operator|(
name|type
operator||
name|scoped
operator|)
argument_list|)
expr_stmt|;
comment|/* tracked alias */
if|if
condition|(
name|type
operator|&&
operator|(
name|flag
operator|&
name|T_FLAG
operator|)
operator|&&
name|aflag
operator|==
literal|'-'
condition|)
block|{
name|attrib
argument_list|(
name|np
argument_list|,
name|flag
operator||
name|N_EXPORT
argument_list|)
expr_stmt|;
name|realias
argument_list|(
name|np
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
operator|&&
name|aflag
operator|!=
literal|'-'
operator|&&
name|strchr
argument_list|(
name|a1
argument_list|,
literal|'='
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* type==0 for TYPESET */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|valup
argument_list|(
name|np
argument_list|)
condition|)
name|printflg
argument_list|(
name|np
argument_list|)
expr_stmt|;
else|else
name|exitval
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|printnam
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|a1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|noalias
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|exitval
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|curflag
operator|=
name|namflag
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
literal|'-'
condition|)
block|{
name|newflag
operator|=
name|curflag
operator||
name|flag
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|INT_GER
condition|)
name|newflag
operator|&=
operator|~
operator|(
name|R_JUST
operator||
name|L_JUST
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|&
operator|(
name|L_JUST
operator||
name|R_JUST
operator|)
condition|)
block|{
name|newflag
operator|&=
operator|~
name|INT_GER
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|L_JUST
condition|)
name|newflag
operator|&=
operator|~
name|R_JUST
expr_stmt|;
else|else
name|newflag
operator|&=
operator|~
name|L_JUST
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|U_TO_L
condition|)
name|newflag
operator|&=
operator|~
name|L_TO_U
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|&
name|L_TO_U
condition|)
name|newflag
operator|&=
operator|~
name|U_TO_L
expr_stmt|;
block|}
else|else
name|newflag
operator|=
name|curflag
operator|&
operator|~
name|flag
expr_stmt|;
if|if
condition|(
name|aflag
operator|&&
operator|(
name|wdnum
operator|>
literal|0
operator|||
operator|(
name|curflag
operator|!=
name|newflag
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|apollo
comment|/* keep aliases from going 						   into environment */
if|if
condition|(
name|type
condition|)
name|namflag
argument_list|(
name|np
argument_list|)
operator|=
name|newflag
expr_stmt|;
else|else
name|chattrib
argument_list|(
name|np
argument_list|,
name|newflag
argument_list|,
name|wdnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
name|chattrib
argument_list|(
name|np
argument_list|,
name|newflag
argument_list|,
name|wdnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|prinscan
argument_list|(
name|fd
argument_list|,
name|flag
argument_list|,
name|troot
argument_list|,
name|aflag
operator|==
literal|'+'
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The removing of Shell variable names, aliases, and functions 		 * is performed here. 		 * Unset functions with unset -f 		 * Non-existent items being deleted give non-zero exit status 		 */
case|case
name|SYSUNALIAS
case|:
case|case
name|SYSUNSET
case|:
block|{
specifier|register
name|NAMPTR
name|np
decl_stmt|;
ifdef|#
directive|ifdef
name|apollo
name|short
name|namlen
decl_stmt|;
endif|#
directive|endif
comment|/* apollo */
if|if
condition|(
name|xbuiltin
operator|==
name|SYSUNALIAS
condition|)
block|{
name|troot
operator|=
name|alias
expr_stmt|;
goto|goto
name|unall
goto|;
block|}
if|if
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
name|F_FLAG
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
name|argn
operator|--
expr_stmt|;
name|troot
operator|=
name|prnames
expr_stmt|;
block|}
else|else
name|troot
operator|=
name|namep
expr_stmt|;
name|unall
label|:
if|if
condition|(
name|argn
operator|<
literal|2
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argn
condition|)
block|{
name|a1
operator|=
operator|*
operator|++
name|com
expr_stmt|;
name|np
operator|=
name|checkfor
argument_list|(
name|a1
argument_list|,
name|troot
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|troot
operator|==
name|namep
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|ARRAY
argument_list|)
operator|&&
operator|(
operator|(
name|a1
operator|=
name|strchr
argument_list|(
name|a1
argument_list|,
literal|']'
argument_list|)
operator|)
operator|==
name|NIL
operator|||
name|astchar
argument_list|(
name|a1
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|arayp
argument_list|(
name|np
argument_list|)
operator|->
name|adot
operator|=
name|NO_SUBSCRIPT
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|N_RDONLY
argument_list|)
condition|)
name|failed
argument_list|(
name|np
operator|->
name|namid
argument_list|,
name|wtfailed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
name|namlen
operator|=
name|strlen
argument_list|(
name|np
operator|->
name|namid
argument_list|)
expr_stmt|;
name|ev_$delete_var
argument_list|(
name|np
operator|->
name|namid
argument_list|,
operator|&
name|namlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
block|}
name|unassign
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
else|else
name|exitval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SYSDOT
case|:
if|if
condition|(
name|a1
condition|)
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|pathopen
argument_list|(
name|a1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|a1
argument_list|,
name|notfound
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|argn
operator|>
literal|2
condition|)
name|arg_set
argument_list|(
name|com
operator|+
literal|1
argument_list|)
expr_stmt|;
name|execexp
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SYSTIMES
case|:
block|{
name|long
name|int
name|t
index|[
literal|4
index|]
decl_stmt|;
name|times
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
name|p_time
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|p_time
argument_list|(
name|t
index|[
literal|1
index|]
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|p_time
argument_list|(
name|t
index|[
literal|2
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|p_time
argument_list|(
name|t
index|[
literal|3
index|]
argument_list|,
name|NL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SYSRETURN
case|:
comment|/* return from a subroutine */
if|if
condition|(
name|freturn
condition|)
block|{
name|exitval
operator|=
operator|(
name|a1
condition|?
name|atoi
argument_list|(
name|a1
argument_list|)
else|:
name|oldexit
operator|)
expr_stmt|;
name|longjmp
argument_list|(
operator|*
name|freturn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
name|SYSEXIT
case|:
ifdef|#
directive|ifdef
name|JOBS
if|if
condition|(
name|close_jobs
argument_list|()
operator|<
literal|0
condition|)
break|break;
endif|#
directive|endif
name|states
operator|&=
operator|~
operator|(
name|TTYFLG
operator||
name|BUILTIN
operator|)
expr_stmt|;
comment|/* force exit */
name|exitsh
argument_list|(
name|a1
condition|?
name|atoi
argument_list|(
name|a1
argument_list|)
else|:
name|oldexit
argument_list|)
expr_stmt|;
case|case
name|SYSNULL
case|:
break|break;
case|case
name|SYSCONT
case|:
if|if
condition|(
name|loopcnt
condition|)
block|{
name|execbrk
operator|=
name|breakcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a1
condition|)
name|breakcnt
operator|=
name|atoi
argument_list|(
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakcnt
operator|>
name|loopcnt
condition|)
name|breakcnt
operator|=
name|loopcnt
expr_stmt|;
else|else
name|breakcnt
operator|=
operator|-
name|breakcnt
expr_stmt|;
block|}
break|break;
case|case
name|SYSBREAK
case|:
if|if
condition|(
name|loopcnt
condition|)
block|{
name|execbrk
operator|=
name|breakcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a1
condition|)
name|breakcnt
operator|=
name|atoi
argument_list|(
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakcnt
operator|>
name|loopcnt
condition|)
name|breakcnt
operator|=
name|loopcnt
expr_stmt|;
block|}
break|break;
case|case
name|SYSTRAP
case|:
if|if
condition|(
name|a1
condition|)
block|{
specifier|register
name|BOOL
name|clear
decl_stmt|;
name|char
modifier|*
name|action
init|=
name|a1
decl_stmt|;
if|if
condition|(
operator|(
name|clear
operator|=
name|isdigit
argument_list|(
operator|*
name|a1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|com
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|'-'
condition|)
name|clear
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|a1
operator|=
operator|*
operator|++
name|com
condition|)
block|{
name|flag
operator|=
name|sig_number
argument_list|(
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|>
name|MAXTRAP
operator|||
name|flag
operator|<
name|MINTRAP
condition|)
name|failed
argument_list|(
name|a1
argument_list|,
name|badtrap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clear
condition|)
name|clrsig
argument_list|(
name|flag
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|trapcom
index|[
name|flag
index|]
argument_list|)
expr_stmt|;
name|trapcom
index|[
name|flag
index|]
operator|=
name|heap
argument_list|(
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|action
condition|)
name|getsig
argument_list|(
name|flag
argument_list|)
expr_stmt|;
else|else
name|ignsig
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* print out current traps */
block|{
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
for|for
control|(
name|flag
operator|=
literal|0
init|;
name|flag
operator|<=
name|MAXTRAP
condition|;
name|flag
operator|++
control|)
if|if
condition|(
name|trapcom
index|[
name|flag
index|]
condition|)
block|{
name|p_num
argument_list|(
name|flag
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|trapcom
index|[
name|flag
index|]
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SYSCD
case|:
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cdpath
init|=
name|nullstr
decl_stmt|;
name|char
name|newdir
index|[
literal|256
index|]
decl_stmt|;
comment|/* enough for any pathname */
name|char
modifier|*
name|oldpwd
decl_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|restricted
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argn
operator|>
literal|3
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|argn
operator|==
literal|3
condition|)
name|a1
operator|=
name|substitute
argument_list|(
name|getpwd
argument_list|(
literal|0
argument_list|)
argument_list|,
name|a1
argument_list|,
name|com
index|[
literal|2
index|]
argument_list|,
name|newdir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a1
operator|==
literal|0
operator|||
operator|*
name|a1
operator|==
literal|0
condition|)
name|a1
operator|=
name|valup
argument_list|(
name|HOME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|a1
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|a1
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
name|a1
operator|=
name|valup
argument_list|(
name|OLDPWDNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
operator|||
operator|*
name|a1
operator|==
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argn
operator|==
literal|3
condition|?
name|badsub
else|:
name|baddir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|!=
literal|'/'
condition|)
name|cdpath
operator|=
name|valup
argument_list|(
name|CDPNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdpath
operator|==
literal|0
condition|)
name|cdpath
operator|=
name|nullstr
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|'.'
condition|)
block|{
comment|/* test for pathname . ./ .. or ../ */
if|if
condition|(
operator|*
operator|(
name|dp
operator|=
name|a1
operator|+
literal|1
operator|)
operator|==
literal|'.'
condition|)
name|dp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|0
operator|||
operator|*
name|dp
operator|==
literal|'/'
condition|)
name|cdpath
operator|=
name|nullstr
expr_stmt|;
block|}
do|do
block|{
name|dp
operator|=
name|cdpath
expr_stmt|;
name|cdpath
operator|=
name|catpath
argument_list|(
name|dp
argument_list|,
name|a1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|flag
operator|=
name|chdir
argument_list|(
name|curstak
argument_list|()
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|cdpath
condition|)
do|;
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|a1
argument_list|,
name|baddir
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
name|valup
argument_list|(
name|OLDPWDNOD
argument_list|)
operator|||
name|argn
operator|==
literal|3
condition|)
name|dp
operator|=
name|a1
expr_stmt|;
comment|/* print out directory for cd - */
name|a1
operator|=
operator|(
name|char
operator|*
operator|)
name|fixstak
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|&&
operator|*
name|dp
operator|!=
literal|':'
operator|&&
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|&&
name|strchr
argument_list|(
name|a1
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|a1
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
name|oldpwd
operator|=
name|getpwd
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fassign
argument_list|(
name|OLDPWDNOD
argument_list|,
name|oldpwd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|newdir
argument_list|,
name|a1
argument_list|)
expr_stmt|;
else|else
block|{
name|dp
operator|=
name|movstr
argument_list|(
name|oldpwd
argument_list|,
name|newdir
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|movstr
argument_list|(
name|a1
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* eliminate redundant / */
name|a1
operator|=
name|newdir
expr_stmt|;
name|cannon_path
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|fassign
argument_list|(
name|PWDNOD
argument_list|,
name|a1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INT16
comment|/* Because of possible symbolic links, make sure we are where 			 * we think we are. 			 */
if|if
condition|(
operator|!
name|eq_inode
argument_list|(
name|dot
argument_list|,
name|a1
argument_list|)
condition|)
name|chdir
argument_list|(
name|a1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INT16 */
break|break;
block|}
case|case
name|SYSSHFT
case|:
block|{
name|flag
operator|=
operator|(
name|a1
condition|?
name|aeval
argument_list|(
name|a1
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
operator|||
name|dolc
operator|<
name|flag
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
else|else
block|{
name|dolv
operator|+=
name|flag
expr_stmt|;
name|dolc
operator|-=
name|flag
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SYSWAIT
case|:
name|await
argument_list|(
name|a1
condition|?
name|atoi
argument_list|(
name|a1
argument_list|)
else|:
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSREAD
case|:
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|wdnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
name|flag
operator||=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
operator|(
name|R_FLAG
operator||
name|P_FLAG
operator||
name|U_FLAG
operator||
name|S_FLAG
operator|)
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
name|argn
operator|--
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|a1
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
break|break;
name|a1
operator|=
name|com
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|P_FLAG
condition|)
block|{
name|fd
operator|=
name|cpipe
index|[
name|INPIPE
index|]
expr_stmt|;
name|states
operator||=
name|PROMPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|U_FLAG
condition|)
name|fd
operator|=
name|file_fd
argument_list|(
name|wdnum
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fisread
argument_list|(
name|fd
argument_list|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fdo
decl_stmt|;
name|p_setout
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|states
operator||=
name|PROMPT
expr_stmt|;
comment|/* look for prompt */
if|if
condition|(
name|a1
operator|=
name|strchr
argument_list|(
name|a1
argument_list|,
literal|'?'
argument_list|)
condition|)
block|{
if|if
condition|(
name|fiswrite
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|fdo
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fdo
operator|=
name|stderr
expr_stmt|;
name|p_setout
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|a1
operator|+
literal|1
argument_list|,
name|fdo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdo
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
block|}
block|}
name|readvar
argument_list|(
operator|&
name|com
index|[
literal|1
index|]
argument_list|,
name|fd
argument_list|,
name|flag
operator|&
operator|(
name|R_FLAG
operator||
name|S_FLAG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|exitval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|P_FLAG
condition|)
block|{
name|pipe_close
argument_list|(
name|cpipe
argument_list|)
expr_stmt|;
name|cpipe
index|[
name|INPIPE
index|]
operator|=
literal|0
expr_stmt|;
name|cpid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|clearerr
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SYSSET
case|:
name|flag
operator|=
name|is_option
argument_list|(
name|EXECPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
condition|)
block|{
specifier|register
name|int
name|argc
decl_stmt|;
name|argc
operator|=
name|arg_opts
argument_list|(
name|argn
argument_list|,
name|com
argument_list|)
expr_stmt|;
comment|/* RWAIT is set if -- flag is given */
if|if
condition|(
name|argc
operator|>
literal|1
operator|||
operator|(
name|states
operator|&
name|RWAIT
operator|)
condition|)
name|arg_set
argument_list|(
name|com
operator|+
name|argn
operator|-
name|argc
argument_list|)
expr_stmt|;
name|states
operator|&=
operator|~
operator|(
name|RWAIT
operator||
name|READPR
operator||
name|MONITOR
operator|)
expr_stmt|;
name|states
operator||=
name|is_option
argument_list|(
name|READPR
operator||
name|MONITOR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
name|trace_command
argument_list|(
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
operator|&&
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comset
operator|==
literal|0
condition|)
comment|/*scan name chain and print*/
name|prinscan
argument_list|(
name|standout
argument_list|,
literal|0
argument_list|,
name|namep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSEVAL
case|:
if|if
condition|(
name|a1
condition|)
name|execexp
argument_list|(
name|a1
argument_list|,
operator|(
name|FILE
operator|*
operator|)
operator|&
name|com
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSFC
case|:
block|{
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
decl_stmt|;
name|FILE
modifier|*
name|fdo
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|char
name|fname
index|[
name|TMPSIZ
index|]
decl_stmt|;
name|int
name|index2
decl_stmt|;
name|int
name|indx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* used as subscript for range */
name|char
modifier|*
name|edit
init|=
name|NULL
decl_stmt|;
comment|/* name of editor */
name|char
modifier|*
name|replace
init|=
name|NULL
decl_stmt|;
comment|/* replace old=new */
name|int
name|incr
decl_stmt|;
name|int
name|range
index|[
literal|2
index|]
decl_stmt|;
comment|/* upper and lower range of commands */
name|int
name|lflag
init|=
literal|0
decl_stmt|;
name|int
name|nflag
init|=
literal|0
decl_stmt|;
name|int
name|rflag
init|=
literal|0
decl_stmt|;
name|histloc
name|location
decl_stmt|;
name|wdnum
operator|=
literal|0
expr_stmt|;
name|hist_open
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fc_fix
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|nohistory
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|a1
operator|=
name|com
index|[
literal|1
index|]
operator|)
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
operator|(
name|E_FLAG
operator||
name|L_FLAG
operator||
name|N_FLAG
operator||
name|R_FLAG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|range
index|[
operator|++
name|indx
index|]
operator|=
name|fp
operator|->
name|fixind
operator|-
name|wdnum
operator|-
literal|1
expr_stmt|;
name|wdnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|1
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|flag
operator|&
name|E_FLAG
condition|)
block|{
comment|/* name of editor specified */
name|com
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|edit
operator|=
name|com
index|[
literal|1
index|]
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argexp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|N_FLAG
condition|)
name|nflag
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|L_FLAG
condition|)
name|lflag
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|R_FLAG
condition|)
name|rflag
operator|++
expr_stmt|;
block|}
name|com
operator|++
expr_stmt|;
block|}
name|flag
operator|=
name|indx
expr_stmt|;
while|while
condition|(
name|flag
operator|<
literal|1
operator|&&
operator|(
name|a1
operator|=
name|com
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a1
argument_list|)
operator|||
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
comment|/* see if completely numeric */
do|do
name|a1
operator|++
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|a1
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|0
condition|)
block|{
name|a1
operator|=
name|com
index|[
literal|1
index|]
expr_stmt|;
name|range
index|[
operator|++
name|flag
index|]
operator|=
name|atoi
argument_list|(
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|'-'
condition|)
name|range
index|[
name|flag
index|]
operator|+=
operator|(
name|fp
operator|->
name|fixind
operator|-
literal|1
operator|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* look for old=new argument */
elseif|else
if|if
condition|(
name|replace
operator|==
name|NULL
operator|&&
name|strchr
argument_list|(
name|a1
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
name|replace
operator|=
name|a1
expr_stmt|;
name|com
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* search for last line starting with string */
name|location
operator|=
name|hist_find
argument_list|(
name|com
index|[
literal|1
index|]
argument_list|,
name|fp
operator|->
name|fixind
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|range
index|[
operator|++
name|flag
index|]
operator|=
name|location
operator|.
name|his_command
operator|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|com
index|[
literal|1
index|]
argument_list|,
name|notfound
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
block|{
comment|/* set default starting range */
if|if
condition|(
name|lflag
condition|)
block|{
name|flag
operator|=
name|fp
operator|->
name|fixind
operator|-
literal|16
expr_stmt|;
if|if
condition|(
name|flag
operator|<
literal|1
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|flag
operator|=
name|fp
operator|->
name|fixind
operator|-
literal|2
expr_stmt|;
name|range
index|[
literal|0
index|]
operator|=
name|flag
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
comment|/* set default termination range */
name|range
index|[
literal|1
index|]
operator|=
operator|(
name|lflag
condition|?
name|fp
operator|->
name|fixind
operator|-
literal|1
else|:
name|range
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|index2
operator|=
name|fp
operator|->
name|fixind
operator|-
name|fp
operator|->
name|fixmax
operator|)
operator|<=
literal|0
condition|)
name|index2
operator|=
literal|1
expr_stmt|;
comment|/* check for valid ranges */
for|for
control|(
name|flag
operator|=
literal|0
init|;
name|flag
operator|<
literal|2
condition|;
name|flag
operator|++
control|)
if|if
condition|(
name|range
index|[
name|flag
index|]
operator|<
name|index2
operator|||
name|range
index|[
name|flag
index|]
operator|>=
operator|(
name|fp
operator|->
name|fixind
operator|-
operator|(
name|lflag
operator|==
literal|0
operator|)
operator|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit
operator|&&
operator|*
name|edit
operator|==
literal|'-'
operator|&&
name|range
index|[
literal|0
index|]
operator|!=
name|range
index|[
literal|1
index|]
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
comment|/* now list commands from range[rflag] to range[1-rflag] */
name|incr
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
name|rflag
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|range
index|[
literal|1
operator|-
name|flag
index|]
operator|<
name|range
index|[
name|flag
index|]
condition|)
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
block|{
name|fdo
operator|=
name|standout
expr_stmt|;
name|a1
operator|=
literal|"\n\t"
expr_stmt|;
block|}
else|else
block|{
name|fdo
operator|=
name|tmp_open
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|a1
operator|=
literal|"\n"
expr_stmt|;
name|nflag
operator|++
expr_stmt|;
block|}
name|p_setout
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|nflag
operator|==
literal|0
condition|)
name|p_num
argument_list|(
name|range
index|[
name|flag
index|]
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lflag
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fdo
argument_list|)
expr_stmt|;
name|hist_list
argument_list|(
name|hist_position
argument_list|(
name|range
index|[
name|flag
index|]
argument_list|)
argument_list|,
name|EOF
argument_list|,
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflag
operator|&&
operator|(
name|trapnote
operator|&
name|SIGSET
operator|)
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
index|[
name|flag
index|]
operator|==
name|range
index|[
literal|1
operator|-
name|flag
index|]
condition|)
break|break;
name|range
index|[
name|flag
index|]
operator|+=
name|incr
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
return|return;
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|a1
operator|=
name|edit
expr_stmt|;
if|if
condition|(
name|a1
operator|==
name|NULL
operator|&&
operator|(
name|a1
operator|=
name|valup
argument_list|(
name|FCEDNOD
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|a1
operator|=
name|defedit
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
name|fname
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|execexp
argument_list|(
name|a1
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
block|}
name|closefd
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
name|fdo
operator|=
name|chkopen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* don't history fc itself */
name|hist_cancel
argument_list|()
expr_stmt|;
name|states
operator||=
operator|(
name|READPR
operator||
name|FIXFLG
operator|)
expr_stmt|;
comment|/* echo lines as read */
if|if
condition|(
name|replace
operator|!=
name|NULL
condition|)
name|hist_subst
argument_list|(
name|cmd_name
argument_list|,
name|fdo
argument_list|,
name|replace
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exitval
operator|==
literal|0
condition|)
name|execexp
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|fdo
argument_list|)
expr_stmt|;
else|else
block|{
name|fclose
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|READPR
argument_list|)
operator|==
literal|0
condition|)
name|states
operator|&=
operator|~
operator|(
name|READPR
operator||
name|FIXFLG
operator|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SYSWHENCE
case|:
block|{
if|if
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
name|V_FLAG
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
name|argn
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argn
operator|<
literal|2
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
name|do_whence
argument_list|(
name|com
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SYSUMASK
case|:
block|{
if|if
condition|(
name|a1
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|a1
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|flag
operator|=
operator|(
name|flag
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
block|}
name|umask
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|pdp11
name|a1
operator|=
name|utos
argument_list|(
call|(
name|long
call|)
argument_list|(
name|argn
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|#
directive|else
name|a1
operator|=
name|utos
argument_list|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|argn
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pdp11 */
name|umask
argument_list|(
name|argn
argument_list|)
expr_stmt|;
operator|*
operator|++
name|a1
operator|=
literal|'0'
expr_stmt|;
name|p_str
argument_list|(
name|a1
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
ifndef|#
directive|ifndef
name|apollo
ifdef|#
directive|ifdef
name|BSD
define|#
directive|define
name|BLK_SIZ
value|512
define|#
directive|define
name|KBYTE
value|1024
ifdef|#
directive|ifdef
name|BSD_4_2
else|#
directive|else
include|#
directive|include
file|<sys/vlimit.h>
endif|#
directive|endif
case|case
name|SYSULIMIT
case|:
block|{
ifdef|#
directive|ifdef
name|BSD_4_2
name|struct
name|rlimit
name|rlp
decl_stmt|;
endif|#
directive|endif
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|opts
init|=
literal|0
decl_stmt|;
name|char
name|label
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|unit
init|=
name|BLK_SIZ
decl_stmt|;
name|flag
operator|=
name|LIM_FSIZE
expr_stmt|;
if|if
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
name|opts
operator|=
operator|++
name|a1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|opts
condition|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|'a'
case|:
name|label
operator|++
expr_stmt|;
name|opts
operator|=
literal|"tmdsfc"
expr_stmt|;
case|case
literal|'t'
case|:
name|flag
operator|=
name|LIM_CPU
expr_stmt|;
name|unit
operator|=
literal|1
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flag
operator|=
name|LIM_CORE
expr_stmt|;
name|n
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flag
operator|=
name|LIM_FSIZE
expr_stmt|;
name|n
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flag
operator|=
name|LIM_DATA
expr_stmt|;
name|unit
operator|=
name|KBYTE
expr_stmt|;
name|n
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flag
operator|=
name|LIM_STACK
expr_stmt|;
name|unit
operator|=
name|KBYTE
expr_stmt|;
name|n
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|flag
operator|=
name|LIM_MAXRSS
expr_stmt|;
name|unit
operator|=
name|KBYTE
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|a1
operator|&&
operator|*
operator|++
name|a1
operator|)
operator|||
operator|(
name|label
operator|&&
name|com
index|[
literal|2
index|]
operator|)
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
name|a1
operator|=
name|com
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|a1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|aeval
argument_list|(
name|a1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
name|i
operator|*=
name|unit
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_4_2
if|if
condition|(
name|getrlimit
argument_list|(
name|flag
argument_list|,
operator|&
name|rlp
argument_list|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
name|rlp
operator|.
name|rlim_cur
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|flag
argument_list|,
operator|&
name|rlp
argument_list|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BSD_4_2
if|if
condition|(
name|getrlimit
argument_list|(
name|flag
argument_list|,
operator|&
name|rlp
argument_list|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
name|i
operator|=
name|rlp
operator|.
name|rlim_cur
expr_stmt|;
else|#
directive|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|vlimit
argument_list|(
name|flag
argument_list|,
name|i
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|p_str
argument_list|(
name|limit_names
index|[
name|n
index|]
argument_list|,
name|SP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|INFINITY
condition|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
name|unit
operator|-
literal|1
operator|)
operator|/
name|unit
expr_stmt|;
name|p_str
argument_list|(
name|utos
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|,
literal|10
argument_list|)
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
else|else
name|p_str
argument_list|(
name|unlimited
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|opts
operator|&&
operator|*
operator|++
name|opts
condition|)
do|;
break|break;
block|}
else|#
directive|else
case|case
name|SYSULIMIT
case|:
block|{
ifndef|#
directive|ifndef
name|VENIX
name|long
name|i
decl_stmt|;
name|long
name|ulimit
parameter_list|()
function_decl|;
specifier|register
name|int
name|mode
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
ifdef|#
directive|ifdef
name|RT
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
operator|(
name|F_FLAG
operator||
name|P_FLAG
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
name|F_FLAG
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RT */
name|a1
operator|=
name|com
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|P_FLAG
condition|)
name|mode
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|a1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|aeval
argument_list|(
name|a1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|--
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|ulimit
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
block|{
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|pdp11
name|p_str
argument_list|(
name|utos
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|,
literal|10
argument_list|)
argument_list|,
name|NL
argument_list|)
expr_stmt|;
else|#
directive|else
name|p_str
argument_list|(
name|utos
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|,
literal|10
argument_list|)
argument_list|,
name|NL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pdp11 */
block|}
endif|#
directive|endif
comment|/* VENIX */
break|break;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* apollo */
ifdef|#
directive|ifdef
name|JOBS
if|#
directive|if
name|BSD
operator|||
name|SXT
case|case
name|SYSBG
case|:
name|flag
operator|=
literal|1
expr_stmt|;
case|case
name|SYSFG
case|:
if|if
condition|(
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
condition|)
block|{
name|exitval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|PROMPT
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|j_no_jctl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|argn
operator|==
literal|1
condition|)
name|a1
operator|=
name|nullstr
expr_stmt|;
if|if
condition|(
name|switch_jobs
argument_list|(
name|a1
argument_list|,
name|flag
argument_list|)
operator|==
literal|0
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|j_no_job
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SYSJOBS
case|:
if|if
condition|(
name|a1
operator|&&
operator|*
name|a1
operator|==
literal|'-'
condition|)
name|flag
operator|=
name|flagset
argument_list|(
name|a1
argument_list|,
operator|~
name|L_FLAG
argument_list|)
expr_stmt|;
name|list_jobs
argument_list|(
name|flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSKILL
case|:
block|{
if|if
condition|(
name|argn
operator|<
literal|2
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
comment|/* just in case we send a kill -9 $$ */
name|p_flush
argument_list|()
expr_stmt|;
name|flag
operator|=
literal|15
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|'-'
condition|)
block|{
name|a1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|a1
operator|==
literal|'l'
condition|)
block|{
name|sig_list
argument_list|()
expr_stmt|;
break|break;
block|}
name|flag
operator|=
name|sig_number
argument_list|(
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
operator|||
name|flag
operator|>=
name|NSIG
condition|)
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
name|com
operator|++
expr_stmt|;
name|argn
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|argn
condition|)
block|{
name|a1
operator|=
operator|*
operator|++
name|com
expr_stmt|;
name|exitval
operator|+=
name|job_kill
argument_list|(
name|a1
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|apollo
comment|/* 		 *  Apollo system support library loads into the virtual address space 		 */
case|case
name|SYSINLIB
case|:
block|{
name|int
name|status
decl_stmt|,
name|xfer
decl_stmt|;
name|short
name|len
decl_stmt|;
name|std_$call
name|void
name|pm_$load
parameter_list|()
function_decl|;
name|std_$call
name|void
name|pm_$call
parameter_list|()
function_decl|;
if|if
condition|(
name|a1
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|pm_$load
argument_list|(
operator|*
name|a1
argument_list|,
name|len
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|xfer
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|failed
argument_list|(
name|a1
argument_list|,
literal|"cannot inlib"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xfer
condition|)
name|pm_$call
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SYSINPROCESS
case|:
if|if
condition|(
name|argn
operator|<
literal|2
condition|)
name|on_option
argument_list|(
name|INPROC
argument_list|)
expr_stmt|;
else|else
name|exitval
operator|=
name|exec_here
argument_list|(
name|com
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* apollo */
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|flgchar
index|[]
init|=
literal|"efilmnprstuvwxzHLRZ"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|flgval
index|[]
init|=
block|{
name|E_FLAG
block|,
name|F_FLAG
block|,
name|I_FLAG
block|,
name|L_FLAG
block|,
name|M_FLAG
block|,
name|N_FLAG
block|,
name|P_FLAG
block|,
name|R_FLAG
block|,
name|S_FLAG
block|,
name|T_FLAG
block|,
name|U_FLAG
block|,
name|V_FLAG
block|,
name|W_FLAG
block|,
name|X_FLAG
block|,
name|Z_FLAG
block|,
name|A_FLAG
block|,
name|L_JUST
block|,
name|R_JUST
block|,
name|R_JUST
operator||
name|Z_FILL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * process option flags for built-ins  * flagmask are the invalid options  */
end_comment

begin_function
specifier|static
name|int
name|flagset
parameter_list|(
name|flaglist
parameter_list|,
name|flagmask
parameter_list|)
name|char
modifier|*
name|flaglist
decl_stmt|;
block|{
specifier|register
name|int
name|flag
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|flaglist
operator|+
literal|1
init|;
name|c
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|wdnum
operator|=
literal|10
operator|*
name|wdnum
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|=
name|strchr
argument_list|(
name|flgchar
argument_list|,
name|c
argument_list|)
condition|)
name|flag
operator||=
name|flgval
index|[
name|sp
operator|-
name|flgchar
index|]
expr_stmt|;
else|else
goto|goto
name|badoption
goto|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|flagmask
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|flag
operator|)
return|;
name|badoption
label|:
name|failed
argument_list|(
name|cmd_name
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|execexp
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|FILEBLK
name|fb
decl_stmt|;
name|FILE
name|fd
decl_stmt|;
name|TREPTR
name|t
decl_stmt|;
name|char
name|inbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|push
argument_list|(
operator|&
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|estabf
argument_list|(
name|s
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|fb
operator|.
name|feval
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|f
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|initf
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|f
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
block|}
name|exec_flag
operator|++
expr_stmt|;
name|t
operator|=
name|cmd
argument_list|(
name|NL
argument_list|,
name|NLFLG
operator||
name|MTFLG
argument_list|)
expr_stmt|;
name|exec_flag
operator|--
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|READPR
argument_list|)
operator|==
literal|0
condition|)
name|states
operator|&=
operator|~
name|READPR
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|fc_fix
condition|)
name|hist_flush
argument_list|()
expr_stmt|;
name|pop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|t
argument_list|,
name|states
operator|&
name|ERRFLG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given the name or number of a signal return the signal number  */
end_comment

begin_function
specifier|static
name|int
name|sig_number
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|n
operator|=
name|atoi
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|syslook
argument_list|(
name|string
argument_list|,
name|signal_names
argument_list|)
expr_stmt|;
name|n
operator|&=
operator|(
literal|1
operator|<<
name|SIGBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_comment
comment|/*  * list all the possible signals  */
end_comment

begin_function
specifier|static
name|void
name|sig_list
parameter_list|()
block|{
specifier|register
name|SYSPTR
name|syscan
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|MAXTRAP
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|names
index|[
name|MAXTRAP
operator|+
literal|1
index|]
decl_stmt|;
name|syscan
operator|=
name|signal_names
expr_stmt|;
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
comment|/* not all signals may be defined */
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|names
index|[
name|n
index|]
operator|=
name|badtrap
expr_stmt|;
while|while
condition|(
operator|*
name|syscan
operator|->
name|sysnam
condition|)
block|{
name|n
operator|=
name|syscan
operator|->
name|sysval
expr_stmt|;
name|n
operator|&=
operator|(
operator|(
literal|1
operator|<<
name|SIGBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|names
index|[
name|n
index|]
operator|=
name|syscan
operator|->
name|sysnam
expr_stmt|;
name|syscan
operator|++
expr_stmt|;
block|}
name|n
operator|=
name|MAXTRAP
expr_stmt|;
while|while
condition|(
name|names
index|[
operator|--
name|n
index|]
operator|==
name|badtrap
condition|)
empty_stmt|;
name|names
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|p_list
argument_list|(
name|n
operator|-
literal|1
argument_list|,
name|names
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

end_unit

