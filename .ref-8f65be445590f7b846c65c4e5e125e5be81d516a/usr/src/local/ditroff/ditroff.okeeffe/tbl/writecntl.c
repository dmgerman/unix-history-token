begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)writecntl.c	1.2 (CWI) 85/10/02"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * control to write table entries  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_define
define|#
directive|define
name|realsplit
value|((ct == 'a' || ct == 'n')&& table[ldata][c].rcol)
end_define

begin_macro
name|runout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|boxflg
operator|||
name|allflg
operator|||
name|dboxflg
condition|)
name|need
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctrflg
condition|)
block|{
name|printf
argument_list|(
literal|".nr #I \\n(.i\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".in +(\\n(.lu-\\n(TWu-\\n(.iu)/2u\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".fc %c %c\n"
argument_list|,
name|F1
argument_list|,
name|F2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr #T 0-1\n"
argument_list|)
expr_stmt|;
name|deftail
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlin
condition|;
name|i
operator|++
control|)
name|putline
argument_list|(
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftover
condition|)
name|yetmore
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|".fc\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr T. 1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".T# 1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrflg
condition|)
name|printf
argument_list|(
literal|".in \\n(#Iu\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|runtabs
argument_list|(
argument|lform
argument_list|,
argument|ldata
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|,
name|ct
decl_stmt|,
name|vforml
decl_stmt|,
name|lf
decl_stmt|;
name|printf
argument_list|(
literal|".ta "
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|ncol
condition|;
name|c
operator|++
control|)
block|{
name|vforml
operator|=
name|lform
expr_stmt|;
for|for
control|(
name|lf
operator|=
name|prev
argument_list|(
name|lform
argument_list|)
init|;
name|lf
operator|>=
literal|0
operator|&&
name|vspen
argument_list|(
name|table
index|[
name|lf
index|]
index|[
name|c
index|]
operator|.
name|col
argument_list|)
condition|;
name|lf
operator|=
name|prev
argument_list|(
name|lf
argument_list|)
control|)
name|vforml
operator|=
name|lf
expr_stmt|;
if|if
condition|(
name|fspan
argument_list|(
name|vforml
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|ct
operator|=
name|ctype
argument_list|(
name|vforml
argument_list|,
name|c
argument_list|)
condition|)
block|{
case|case
literal|'n'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|table
index|[
name|ldata
index|]
index|[
name|c
index|]
operator|.
name|rcol
condition|)
if|if
condition|(
name|lused
index|[
name|c
index|]
condition|)
block|{
comment|/* 					 * Zero field width 					 */
name|printf
argument_list|(
literal|"\\n(%2su "
argument_list|,
name|reg
argument_list|(
name|c
argument_list|,
name|CMID
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
literal|'c'
case|:
case|case
literal|'l'
case|:
case|case
literal|'r'
case|:
if|if
condition|(
name|realsplit
condition|?
name|rused
index|[
name|c
index|]
else|:
operator|(
name|used
index|[
name|c
index|]
operator|+
name|lused
index|[
name|c
index|]
operator|)
condition|)
name|printf
argument_list|(
literal|"\\n(%2su "
argument_list|,
name|reg
argument_list|(
name|c
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|lspan
argument_list|(
name|lform
argument_list|,
name|c
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\\n(%2su "
argument_list|,
name|reg
argument_list|(
name|c
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ifline
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|point
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
return|return
operator|(
literal|'-'
operator|)
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
return|return
operator|(
literal|'='
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|need
argument_list|()
end_macro

begin_block
block|{
name|int
name|texlin
decl_stmt|,
name|horlin
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|texlin
operator|=
name|horlin
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fullbot
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|horlin
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|instead
index|[
name|i
index|]
operator|!=
literal|0
condition|)
continue|continue;
else|else
name|texlin
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".ne %dv+%dp\n"
argument_list|,
name|texlin
argument_list|,
literal|2
operator|*
name|horlin
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|deftail
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|lf
decl_stmt|,
name|lwid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXHEAD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|linestop
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|".nr #%c 0-1\n"
argument_list|,
name|linestop
index|[
name|i
index|]
operator|+
literal|'a'
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr #a 0-1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".eo\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".de T#\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".ds #d .d\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\(ts\\n(.z\\(ts\\(ts .ds #d nl\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".mk ##\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr ## -1v\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".ls 1\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXHEAD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|linestop
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|".if \\n(#T>=0 .nr #%c \\n(#T\n"
argument_list|,
name|linestop
index|[
name|i
index|]
operator|+
literal|'a'
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * bottom of table line 	 */
if|if
condition|(
name|boxflg
operator|||
name|allflg
operator|||
name|dboxflg
condition|)
block|{
if|if
condition|(
name|fullbot
index|[
name|nlin
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pr1403
condition|)
name|printf
argument_list|(
literal|".if \\n(T. .vs \\n(.vu-\\n(.sp\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(T. "
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|nlin
argument_list|,
literal|0
argument_list|,
name|ncol
argument_list|,
name|dboxflg
condition|?
literal|'='
else|:
literal|'-'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n.if \\n(T. .vs\n"
argument_list|)
expr_stmt|;
comment|/* 			 * T. is really an argument to a macro but because 			 * of eqn we don't dare pass it as an argument and 			 * reference by $1 			 */
block|}
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|ncol
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|lf
operator|=
name|left
argument_list|(
name|nlin
operator|-
literal|1
argument_list|,
name|c
argument_list|,
operator|&
name|lwid
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|".if \\n(#%c>=0 .sp -1\n"
argument_list|,
name|linestop
index|[
name|lf
index|]
operator|+
literal|'a'
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(#%c>=0 "
argument_list|,
name|linestop
index|[
name|lf
index|]
operator|+
literal|'a'
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tohcol
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|drawvert
argument_list|(
name|lf
argument_list|,
name|nlin
operator|-
literal|1
argument_list|,
name|c
argument_list|,
name|lwid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\h'|\\n(TWu'\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * right hand line 	 */
if|if
condition|(
name|boxflg
operator|||
name|allflg
operator|||
name|dboxflg
condition|)
block|{
name|printf
argument_list|(
literal|".if \\n(#a>=0 .sp -1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(#a>=0 \\h'|\\n(TWu'"
argument_list|)
expr_stmt|;
name|drawvert
argument_list|(
literal|0
argument_list|,
name|nlin
operator|-
literal|1
argument_list|,
name|ncol
argument_list|,
name|dboxflg
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".ls\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"..\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".ec\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

