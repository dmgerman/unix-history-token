begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_split.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"btree.h"
end_include

begin_comment
comment|/*  *  _BT_SPLIT -- Split a page into two pages.  *  *	Splits are caused by insertions, and propogate up the tree in  *	the usual way.  The root page is always page 1 in the file on  *	disk, so root splits are handled specially.  On entry to this  *	routine, t->bt_curpage is the page to be split.  *  *	Parameters:  *		t -- btree in which to do split.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Changes the notion of the current page.  */
end_comment

begin_function
name|int
name|_bt_split
parameter_list|(
name|t
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|BTHEADER
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|pgno_t
name|nextpgno
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|len
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|IDATUM
modifier|*
name|new
decl_stmt|;
name|pgno_t
name|oldchain
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* split root page specially, since it must remain page 1 */
if|if
condition|(
name|h
operator|->
name|h_pgno
operator|==
name|P_ROOT
condition|)
block|{
return|return
operator|(
name|_bt_splitroot
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
comment|/* 	 *  This is a little complicated.  We go to some trouble to 	 *  figure out which of the three possible cases -- in-memory tree, 	 *  disk tree (no cache), and disk tree (cache) -- we have, in order 	 *  to avoid unnecessary copying.  If we have a disk cache, then we 	 *  have to do some extra copying, though, since the cache code 	 *  manages buffers externally to this code. 	 */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|left
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|left
operator|->
name|h_pgno
operator|=
name|left
operator|->
name|h_prevpg
operator|=
name|left
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
name|left
operator|->
name|h_flags
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
expr_stmt|;
name|left
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|left
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|left
operator|)
argument_list|)
expr_stmt|;
name|left
operator|->
name|h_upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|left
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|left
operator|->
name|h_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
operator|(
name|right
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|right
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
comment|/* now do the split */
if|if
condition|(
name|_bt_dopsplit
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|right
operator|->
name|h_prevpg
operator|=
name|left
operator|->
name|h_pgno
expr_stmt|;
name|nextpgno
operator|=
name|right
operator|->
name|h_nextpg
operator|=
name|h
operator|->
name|h_nextpg
expr_stmt|;
name|left
operator|->
name|h_nextpg
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
name|left
operator|->
name|h_prevpg
operator|=
name|h
operator|->
name|h_prevpg
expr_stmt|;
comment|/* okay, now use the left half of the page as the new page */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_curpage
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|left
argument_list|)
expr_stmt|;
name|left
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_curpage
argument_list|)
expr_stmt|;
name|t
operator|->
name|bt_curpage
operator|=
name|left
expr_stmt|;
block|}
comment|/* 	 *  Write the new pages out.  We need them to stay where they are 	 *  until we're done updating the parent pages. 	 */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|right
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* update 'prev' pointer of old neighbor of left */
if|if
condition|(
name|nextpgno
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|nextpgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|F_DIRTY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parent
operator|=
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|right
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|d
operator|->
name|d_ksize
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
argument_list|,
sizeof|sizeof
argument_list|(
name|oldchain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_markchain
argument_list|(
name|t
argument_list|,
name|oldchain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
expr_stmt|;
name|flags
operator|=
name|D_BIGKEY
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|id
operator|->
name|i_size
expr_stmt|;
name|flags
operator|=
name|id
operator|->
name|i_flags
expr_stmt|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
name|nbytes
operator|=
name|len
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|new
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|(
name|IDATUM
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|new
operator|->
name|i_size
operator|=
name|len
expr_stmt|;
name|new
operator|->
name|i_pgno
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
name|new
operator|->
name|i_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* 		 *  Split the parent if we need to, then reposition the 		 *  tree's current page pointer for the new datum. 		 */
if|if
condition|(
operator|(
name|h
operator|->
name|h_upper
operator|-
name|h
operator|->
name|h_lower
operator|)
operator|<
name|nbytes
condition|)
block|{
if|if
condition|(
name|_bt_split
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_reposition
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|parent
argument_list|,
name|right
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* okay, now insert the new idatum */
if|if
condition|(
name|_bt_inserti
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|right
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* 	 *  Okay, split is done; don't need right page stapled down anymore. 	 *  The page we call 'left' above is the new version of the old 	 *  (split) page, so we can't release it. 	 */
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_REPOSITION -- Reposition the current page pointer of a btree.  *  *	After splitting a node in the tree in order to make room for  *	an insertion, we need to figure out which page after the split  *	should get the item we want to insert.  This routine positions  *	the tree's current page pointer appropriately.  *  *	Parameters:  *		t -- tree to position  *		new -- the item we want to insert  *		parent -- parent of the node that we just split  *		prev -- page number of item directly to the left of  *			new's position in the tree.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|_bt_reposition
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|parent
parameter_list|,
name|prev
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|IDATUM
modifier|*
name|new
decl_stmt|;
name|pgno_t
name|parent
decl_stmt|;
name|pgno_t
name|prev
decl_stmt|;
block|{
name|index_t
name|i
decl_stmt|,
name|next
decl_stmt|;
name|IDATUM
modifier|*
name|idx
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|P_ROOT
condition|)
block|{
comment|/* 		 *  If we just split the root page, then there are guaranteed 		 *  to be exactly two IDATUMs on it.  Look at both of them 		 *  to see if they point to the page that we want. 		 */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|next
operator|=
name|NEXTINDEX
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|idx
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_isonpage
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|prev
argument_list|)
operator|==
name|RET_SUCCESS
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 *  Get the parent page -- which is where the new item would 		 *  have gone -- and figure out whether the new item now goes 		 *  on the parent, or the page immediately to the right of 		 *  the parent. 		 */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_isonpage
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|prev
argument_list|)
operator|==
name|RET_SUCCESS
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|bt_curpage
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_isonpage
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|prev
argument_list|)
operator|==
name|RET_SUCCESS
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_ISONPAGE -- Is the IDATUM for a given page number on the current page?  *  *	This routine is used by _bt_reposition to decide whether the current  *	page is the correct one on which to insert a new item.  *  *	Parameters:  *		t -- tree to check  *		new -- the item that will be inserted (used for binary search)  *		prev -- page number of page whose IDATUM is immediately to  *			the left of new's position in the tree.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR (corresponding to TRUE, FALSE).  */
end_comment

begin_function
name|int
name|_bt_isonpage
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|prev
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|IDATUM
modifier|*
name|new
decl_stmt|;
name|pgno_t
name|prev
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|index_t
name|i
decl_stmt|,
name|next
decl_stmt|;
name|IDATUM
modifier|*
name|idx
decl_stmt|;
name|i
operator|=
name|_bt_binsrch
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|new
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|new
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
operator|--
name|i
expr_stmt|;
name|next
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|next
operator|&&
name|idx
operator|->
name|i_pgno
operator|!=
name|prev
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|->
name|i_pgno
operator|==
name|prev
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
else|else
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SPLITROOT -- Split the root of a btree.  *  *	The root page for a btree is always page one.  This means that in  *	order to split the root, we need to do extra work.  *  *	Parameters:  *		t -- tree to split  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Splits root upward in the usual way, adding two new pages  *		to the tree (rather than just one, as in usual splits).  */
end_comment

begin_function
name|int
name|_bt_splitroot
parameter_list|(
name|t
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|BTHEADER
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|BTHEADER
modifier|*
name|where_h
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nbytes
decl_stmt|;
name|u_long
name|was_leaf
decl_stmt|;
name|pgno_t
name|oldchain
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
comment|/* get two new pages for the split */
if|if
condition|(
operator|(
name|left
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|left
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|right
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|right
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
comment|/* do the split */
if|if
condition|(
name|_bt_dopsplit
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* connect the new pages correctly */
name|right
operator|->
name|h_prevpg
operator|=
name|left
operator|->
name|h_pgno
expr_stmt|;
name|left
operator|->
name|h_nextpg
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
comment|/* 	 *  Write the child pages out now.  We need them to remain 	 *  where they are until we finish updating parent pages, 	 *  however. 	 */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|right
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* now change the root page into an internal page */
name|was_leaf
operator|=
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|F_LEAF
expr_stmt|;
name|h
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
operator|(
name|index_t
operator|)
name|t
operator|->
name|bt_psize
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|h
operator|->
name|h_upper
operator|-
name|h
operator|->
name|h_lower
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put two new keys on root page */
name|where_h
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|where_h
condition|)
block|{
name|DATUM
modifier|*
name|data
decl_stmt|;
name|IDATUM
modifier|*
name|idata
decl_stmt|;
if|if
condition|(
name|was_leaf
condition|)
block|{
name|data
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|where_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_h
operator|==
name|left
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
comment|/* first key in tree is null */
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|data
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
argument_list|,
sizeof|sizeof
argument_list|(
name|oldchain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_markchain
argument_list|(
name|t
argument_list|,
name|oldchain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
expr_stmt|;
name|flags
operator|=
name|D_BIGKEY
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|data
operator|->
name|d_ksize
expr_stmt|;
block|}
block|}
else|else
block|{
name|idata
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|where_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|idata
operator|->
name|i_size
expr_stmt|;
name|flags
operator|=
name|idata
operator|->
name|i_flags
expr_stmt|;
name|src
operator|=
operator|&
operator|(
name|idata
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
name|dest
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|h
operator|->
name|h_upper
expr_stmt|;
name|nbytes
operator|=
name|len
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|dest
operator|-=
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|dest
expr_stmt|;
name|id
operator|->
name|i_size
operator|=
name|len
expr_stmt|;
name|id
operator|->
name|i_pgno
operator|=
name|where_h
operator|->
name|h_pgno
expr_stmt|;
name|id
operator|->
name|i_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
operator|-=
operator|(
operator|(
name|int
operator|)
name|h
operator|)
expr_stmt|;
name|h
operator|->
name|h_linp
index|[
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
index|]
operator|=
operator|(
name|index_t
operator|)
name|dest
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
operator|(
name|index_t
operator|)
name|dest
expr_stmt|;
name|h
operator|->
name|h_lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* next page */
if|if
condition|(
name|where_h
operator|==
name|left
condition|)
name|where_h
operator|=
name|right
expr_stmt|;
else|else
name|where_h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|left
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 *  That's it, split is done.  If we're doing a non-cached disk 	 *  btree, we can free up the pages we allocated, as they're on 	 *  disk, now. 	 */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|left
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|right
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|h_flags
operator||=
name|F_DIRTY
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_DOPSPLIT -- Do the work of splitting a page  *  *	This routine takes two page pointers and splits the data on the  *	current page of the btree between them.  *  *	We do a lot of work here to handle duplicate keys on a page; we  *	have to place these keys carefully to guarantee that later searches  *	will find them correctly.  See comments in the code below for details.  *  *	Parameters:  *		t -- tree to split  *		left -- pointer to page to get left half of the data  *		right -- pointer to page to get right half of the data  *  *	Returns:  *		None.  */
end_comment

begin_function
name|int
name|_bt_dopsplit
parameter_list|(
name|t
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|BTHEADER
modifier|*
name|left
decl_stmt|;
name|BTHEADER
modifier|*
name|right
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|BTHEADER
modifier|*
name|where_h
decl_stmt|;
name|index_t
name|where_i
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|dsize
decl_stmt|,
name|fixedsize
decl_stmt|,
name|freespc
decl_stmt|;
name|index_t
name|i
decl_stmt|;
name|index_t
name|save_lower
decl_stmt|,
name|save_upper
decl_stmt|,
name|save_i
decl_stmt|;
name|index_t
name|switch_i
decl_stmt|;
name|char
modifier|*
name|save_key
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|index_t
name|top
decl_stmt|;
name|int
name|free_save
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|int
name|ignore
decl_stmt|;
comment|/* 	 *  Our strategy is to put half the bytes on each page.  We figure 	 *  out how many bytes we have total, and then move items until 	 *  the last item moved put at least 50% of the data on the left 	 *  page. 	 */
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|psize
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|bt_psize
expr_stmt|;
name|where
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|left
operator|)
operator|+
name|psize
expr_stmt|;
name|where_h
operator|=
name|left
expr_stmt|;
name|where_i
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
name|psize
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|freespc
operator|=
name|nbytes
expr_stmt|;
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
name|fixedsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
else|else
name|fixedsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* move data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 *  Internal and leaf pages have different layouts for 		 *  data items, but in both cases the first entry in the 		 *  data item is a size_t. 		 */
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|dsize
operator|=
name|d
operator|->
name|d_ksize
operator|+
name|d
operator|->
name|d_dsize
operator|+
name|fixedsize
expr_stmt|;
block|}
else|else
block|{
name|dsize
operator|=
name|d
operator|->
name|d_ksize
operator|+
name|fixedsize
expr_stmt|;
block|}
comment|/* 		 *  If a page contains duplicate keys, we have to be 		 *  careful about splits.  A sequence of duplicate keys 		 *  may not begin in the middle of one page and end in 		 *  the middle of another; it must begin on a page boundary, 		 *  in order for searches on the internal nodes to work 		 *  correctly. 		 */
if|if
condition|(
name|where_h
operator|==
name|left
condition|)
block|{
if|if
condition|(
name|save_key
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IDATUM
modifier|*
name|id
init|=
operator|(
name|IDATUM
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
name|save_i
operator|=
literal|0
expr_stmt|;
name|save_lower
operator|=
name|where_h
operator|->
name|h_lower
expr_stmt|;
name|save_upper
operator|=
name|where_h
operator|->
name|h_upper
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|save_key
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|save_lower
operator|=
name|where_h
operator|->
name|h_lower
expr_stmt|;
name|save_upper
operator|=
name|where_h
operator|->
name|h_upper
expr_stmt|;
name|save_i
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|free_save
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|save_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IDATUM
modifier|*
name|id
init|=
operator|(
name|IDATUM
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* copy data and update page state */
name|where
operator|-=
name|LONGALIGN
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
operator|(
name|char
operator|*
operator|)
name|where
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|where_h
operator|->
name|h_upper
operator|=
name|where_h
operator|->
name|h_linp
index|[
name|where_i
index|]
operator|=
call|(
name|index_t
call|)
argument_list|(
name|where
operator|-
operator|(
name|int
operator|)
name|where_h
argument_list|)
expr_stmt|;
name|where_h
operator|->
name|h_lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
name|where_i
operator|++
expr_stmt|;
comment|/* if we've moved half, switch to the right-hand page */
name|nbytes
operator|-=
name|LONGALIGN
argument_list|(
name|dsize
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|freespc
operator|-
name|nbytes
operator|)
operator|>
name|nbytes
condition|)
block|{
name|nbytes
operator|=
literal|2
operator|*
name|freespc
expr_stmt|;
comment|/* identical keys go on the same page */
if|if
condition|(
name|save_i
operator|>
literal|0
condition|)
block|{
comment|/* i gets incremented at loop bottom... */
name|i
operator|=
name|save_i
operator|-
literal|1
expr_stmt|;
name|where_h
operator|->
name|h_lower
operator|=
name|save_lower
expr_stmt|;
name|where_h
operator|->
name|h_upper
operator|=
name|save_upper
expr_stmt|;
block|}
name|where
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|right
operator|)
operator|+
name|psize
expr_stmt|;
name|where_h
operator|=
name|right
expr_stmt|;
name|switch_i
operator|=
name|where_i
expr_stmt|;
name|where_i
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 *  If there was an active scan on the database, and we just 	 *  split the page that the cursor was on, we may need to 	 *  adjust the cursor to point to the same entry as before the 	 *  split. 	 */
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|)
operator|&&
operator|(
name|c
operator|->
name|c_pgno
operator|==
name|h
operator|->
name|h_pgno
operator|)
operator|&&
operator|(
name|c
operator|->
name|c_index
operator|>=
name|switch_i
operator|)
condition|)
block|{
name|c
operator|->
name|c_pgno
operator|=
name|where_h
operator|->
name|h_pgno
expr_stmt|;
name|c
operator|->
name|c_index
operator|-=
name|where_i
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

