begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_overflow.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"btree.h"
end_include

begin_comment
comment|/*  *  _BT_GETBIG -- Get big data from indirect pages.  *  *	This routine chases indirect blocks for the big object at the   *	specified page to a buffer, and return the address of the buffer.  *  *	Parameters:  *		t -- btree with the indirect blocks  *		pgno -- page number that starts the chain  *		p -- (char **) to get the address of the buffer containing  *		     the key or datum.  *		sz -- pointer to an int to get the size of the instantiated  *		      object.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|_bt_getbig
parameter_list|(
name|t
parameter_list|,
name|pgno
parameter_list|,
name|p
parameter_list|,
name|sz
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|sz
decl_stmt|;
block|{
name|pgno_t
name|save
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|size_t
name|nhere
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|top
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|where
decl_stmt|;
name|save
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
operator|*
name|sz
operator|=
name|nbytes
expr_stmt|;
name|from
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|t
operator|->
name|bt_psize
expr_stmt|;
comment|/* need more space for data? */
name|where
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
name|nhere
operator|=
call|(
name|int
call|)
argument_list|(
name|top
operator|-
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhere
operator|>
name|nbytes
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
operator|(
name|size_t
operator|)
name|nbytes
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
name|nhere
argument_list|)
expr_stmt|;
name|where
operator|+=
name|nhere
expr_stmt|;
name|nbytes
operator|-=
name|nhere
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|top
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|t
operator|->
name|bt_psize
expr_stmt|;
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_DELINDIR -- Delete a chain of indirect blocks from the btree.  *  *	When a large item is deleted from the tree, this routine puts the  *	space that it occupied onto the free list for later reuse.  The  *	bt_free entry in the btree structure points at the head of this list.  *	This value is also stored on disk in the btree's metadata.  *  *	Parameters:  *		t -- btree from which to delete pages  *		chain -- page number that starts the chain.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Invalidates the current on-disk version of the btree's  *		metadata (if any), and updates the free list appropriately.  */
end_comment

begin_function
name|int
name|_bt_delindir
parameter_list|(
name|t
parameter_list|,
name|chain
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|pgno_t
name|save
decl_stmt|;
name|pgno_t
name|oldfree
decl_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|save
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 *  If some internal node is pointing at this chain, don't 	 *  delete it. 	 */
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
operator|&
name|F_PRESERVE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
comment|/* if there's nothing on the free list, this is easy... */
if|if
condition|(
name|t
operator|->
name|bt_free
operator|==
name|P_NONE
condition|)
block|{
name|t
operator|->
name|bt_free
operator|=
name|chain
expr_stmt|;
block|}
else|else
block|{
name|oldfree
operator|=
name|t
operator|->
name|bt_free
expr_stmt|;
comment|/* find the end of the data chain for the deleted datum */
name|t
operator|->
name|bt_free
operator|=
name|chain
expr_stmt|;
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
name|chain
operator|=
name|h
operator|->
name|h_nextpg
expr_stmt|;
block|}
do|while
condition|(
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
comment|/* link freed pages into free list */
name|h
operator|->
name|h_nextpg
operator|=
name|oldfree
expr_stmt|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|oldfree
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* restore the tree's current page pointer */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* we have trashed the tree metadata; rewrite it later */
name|t
operator|->
name|bt_flags
operator|&=
operator|~
name|BTF_METAOK
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_INDIRECT -- Write a series of indirect pages for big objects.  *  *	A chain of indirect pages looks like  *  *	   +-------------------+   +---------------------+  *	   |hdr|size|	       |   |hdr|		 |  *	   +---+----+	       |   +---+		 |  *	   |   ... data ...    |   |   ... data ...	 |    ...  *	   |		       |   |			 |  *	   +-------------------+   +---------------------+  *  *	where hdr is a standard btree page header (with the indirect bit  *	set), size on the first page is the real size of the datum, and  *	data are bytes of the datum, split across as many pages as necessary.  *	Indirect pages are chained together with the h_prevpg and h_nextpg  *	entries of the page header struct.  *  *	A single DBT is written per chain, so space on the last page is  *	wasted.  *  *	We return the page number of the start of the chain.  *  *	When a big object is deleted from a tree, the space that it occupied  *	is placed on a free list for later reuse.  This routine checks that  *	free list before allocating new pages to the big datum being inserted.  *  *	Parameters:  *		t -- btree in which to store indirect blocks  *		data -- DBT with the big datum in it  *		pgno -- place to put the starting page number of the chain  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Current page is changed on return.  */
end_comment

begin_function
name|int
name|_bt_indirect
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|,
name|pgno
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|pgno_t
modifier|*
name|pgno
decl_stmt|;
block|{
name|pgno_t
name|prev
decl_stmt|;
name|char
modifier|*
name|top
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|size_t
name|dsize
decl_stmt|;
name|pgno_t
name|nextchn
decl_stmt|;
name|int
name|ischain
decl_stmt|;
name|BTHEADER
modifier|*
name|cur
decl_stmt|;
comment|/* get set for first page in chain */
name|prev
operator|=
name|P_NONE
expr_stmt|;
name|dsize
operator|=
name|data
operator|->
name|size
expr_stmt|;
name|from
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|data
expr_stmt|;
comment|/* if there are blocks on the free list, use them first */
if|if
condition|(
operator|(
operator|*
name|pgno
operator|=
name|t
operator|->
name|bt_free
operator|)
operator|==
name|P_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|0
expr_stmt|;
operator|*
name|pgno
operator|=
name|cur
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
operator|*
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|1
expr_stmt|;
name|cur
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|cur
operator|->
name|h_flags
operator|=
name|F_CONT
operator||
name|F_LEAF
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cur
operator|->
name|h_linp
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|cur
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
comment|/* fill and write pages in the chain */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nhere
decl_stmt|;
name|top
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|cur
operator|)
operator|+
name|t
operator|->
name|bt_psize
expr_stmt|;
name|cur
operator|->
name|h_prevpg
operator|=
name|prev
expr_stmt|;
name|nextchn
operator|=
name|cur
operator|->
name|h_nextpg
expr_stmt|;
name|nhere
operator|=
call|(
name|int
call|)
argument_list|(
name|top
operator|-
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhere
operator|>=
name|dsize
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|dsize
argument_list|)
expr_stmt|;
name|cur
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
name|dsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|nhere
argument_list|)
expr_stmt|;
name|dsize
operator|-=
name|nhere
expr_stmt|;
name|from
operator|+=
name|nhere
expr_stmt|;
if|if
condition|(
name|nextchn
operator|==
name|P_NONE
condition|)
name|cur
operator|->
name|h_nextpg
operator|=
name|t
operator|->
name|bt_npages
operator|+
literal|1
expr_stmt|;
name|prev
operator|=
name|cur
operator|->
name|h_pgno
expr_stmt|;
block|}
comment|/* current page is ready to go; write it out */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|cur
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* free the current page, if appropriate */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ISCACHE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ischain
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|)
expr_stmt|;
block|}
comment|/* done? */
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
break|break;
comment|/* allocate another page */
if|if
condition|(
name|nextchn
operator|==
name|P_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|nextchn
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|1
expr_stmt|;
name|cur
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|cur
operator|->
name|h_flags
operator|=
name|F_LEAF
operator||
name|F_CONT
expr_stmt|;
name|where
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|cur
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|/* if we used pages from the free list, record changes to it */
if|if
condition|(
operator|*
name|pgno
operator|==
name|t
operator|->
name|bt_free
condition|)
block|{
name|t
operator|->
name|bt_free
operator|=
name|nextchn
expr_stmt|;
name|t
operator|->
name|bt_flags
operator|&=
operator|~
name|BTF_METAOK
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_MARKCHAIN -- Mark a chain of pages as used by an internal node.  *  *	Chains of indirect blocks pointed to by leaf nodes get reclaimed  *	when the item that points to them gets deleted.  Chains pointed  *	to by internal nodes never get deleted.  This routine marks a  *	chain as pointed to by an internal node.  *  *	Parameters:  *		t -- tree in which to mark  *		chain -- number of first page in chain  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|_bt_markchain
parameter_list|(
name|t
parameter_list|,
name|chain
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
block|{
name|pgno_t
name|save
decl_stmt|;
name|save
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
operator||=
operator|(
name|F_DIRTY
operator||
name|F_PRESERVE
operator|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

