begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)atof.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/*  * simple atof() for IEEE 754 architectures  */
end_comment

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|static
name|double
name|twoemax
init|=
literal|9007199254740992.
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*2^53*/
end_comment

begin_comment
comment|/* attempt to be as exact as possible */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|long
name|low_word
decl_stmt|;
name|long
name|high_word
decl_stmt|;
block|}
name|exp5
index|[]
init|=
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
block|{
literal|0x40140000
block|,
literal|0x00000000
block|}
block|,
comment|/* 5 */
block|{
literal|0x40390000
block|,
literal|0x00000000
block|}
block|,
comment|/* 25 */
block|{
literal|0x40838800
block|,
literal|0x00000000
block|}
block|,
comment|/* 625 */
block|{
literal|0x4117d784
block|,
literal|0x00000000
block|}
block|,
comment|/* 390625 */
block|{
literal|0x4241c379
block|,
literal|0x37e08000
block|}
block|,
comment|/* 152587890625 */
block|{
literal|0x4493b8b5
block|,
literal|0xb5056e17
block|}
block|,
comment|/* 2.3283064365387e+022 */
block|{
literal|0x49384f03
block|,
literal|0xe93ff9f6
block|}
block|,
comment|/* 5.42101086242753e+044 */
block|{
literal|0x52827748
block|,
literal|0xf9301d33
block|}
block|,
comment|/* 2.93873587705572e+089 */
block|{
literal|0x65154fdd
block|,
literal|0x7f73bf3f
block|}
comment|/* 8.63616855509445e+178 */
else|#
directive|else
comment|/* BYTE_ORDER == LITTLE_ENDIAN */
block|{
literal|0x00000000
block|,
literal|0x40140000
block|}
block|,
comment|/* 5 */
block|{
literal|0x00000000
block|,
literal|0x40390000
block|}
block|,
comment|/* 25 */
block|{
literal|0x00000000
block|,
literal|0x40838800
block|}
block|,
comment|/* 625 */
block|{
literal|0x00000000
block|,
literal|0x4117d784
block|}
block|,
comment|/* 390625 */
block|{
literal|0x37e08000
block|,
literal|0x4241c379
block|}
block|,
comment|/* 152587890625 */
block|{
literal|0xb5056e17
block|,
literal|0x4493b8b5
block|}
block|,
comment|/* 2.3283064365387e+022 */
block|{
literal|0xe93ff9f6
block|,
literal|0x49384f03
block|}
block|,
comment|/* 5.42101086242753e+044 */
block|{
literal|0xf9301d33
block|,
literal|0x52827748
block|}
block|,
comment|/* 2.93873587705572e+089 */
block|{
literal|0x7f73bf3f
block|,
literal|0x65154fdd
block|}
comment|/* 8.63616855509445e+178 */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_function
name|double
name|atof
parameter_list|(
name|p
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|exp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|eexp
init|=
literal|0
decl_stmt|;
name|double
name|fl
init|=
literal|0
decl_stmt|;
name|double
name|flexp
init|=
literal|1.0
decl_stmt|;
name|int
name|bexp
decl_stmt|;
name|int
name|neg
init|=
literal|1
decl_stmt|;
name|int
name|negexp
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'-'
condition|)
name|neg
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
comment|/* skip it */
empty_stmt|;
else|else
operator|--
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|fl
operator|<
name|twoemax
condition|)
name|fl
operator|=
literal|10
operator|*
name|fl
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
operator|++
name|exp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|fl
operator|<
name|twoemax
condition|)
block|{
name|fl
operator|=
literal|10
operator|*
name|fl
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|--
name|exp
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'-'
condition|)
name|negexp
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
comment|/* skip it */
empty_stmt|;
else|else
operator|--
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|eexp
operator|=
literal|10
operator|*
name|eexp
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|negexp
operator|<
literal|0
condition|)
name|eexp
operator|=
operator|-
name|eexp
expr_stmt|;
name|exp
operator|+=
name|eexp
expr_stmt|;
block|}
name|bexp
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|exp
operator|&&
name|c
operator|<
sizeof|sizeof
name|exp5
operator|/
sizeof|sizeof
name|exp5
index|[
literal|0
index|]
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|exp
operator|&
literal|1
condition|)
name|flexp
operator|*=
operator|*
operator|(
name|double
operator|*
operator|)
operator|&
name|exp5
index|[
name|c
index|]
expr_stmt|;
name|exp
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bexp
operator|<
literal|0
condition|)
name|fl
operator|/=
name|flexp
expr_stmt|;
else|else
name|fl
operator|*=
name|flexp
expr_stmt|;
name|fl
operator|=
name|ldexp
argument_list|(
name|fl
argument_list|,
name|bexp
argument_list|)
expr_stmt|;
return|return
name|neg
operator|<
literal|0
condition|?
operator|-
name|fl
else|:
name|fl
return|;
block|}
end_function

end_unit

