begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Timothy C. Stoehr.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pack.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * pack.c  *  * This source herein may be modified and/or distributed by anybody who  * so desires, with the following restrictions:  *    1.)  No portion of this notice shall be removed.  *    2.)  Credit shall not be taken for the creation of this source.  *    3.)  This code is not to be traded, sold, or used for personal  *         gain or profit.  *  */
end_comment

begin_include
include|#
directive|include
file|"rogue.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|curse_message
init|=
literal|"you can't, it appears to be cursed"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|levitate
decl_stmt|;
end_decl_stmt

begin_function
name|object
modifier|*
name|add_to_pack
parameter_list|(
name|obj
parameter_list|,
name|pack
parameter_list|,
name|condense
parameter_list|)
name|object
modifier|*
name|obj
decl_stmt|,
decl|*
name|pack
decl_stmt|;
end_function

begin_block
block|{
name|object
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|condense
condition|)
block|{
if|if
condition|(
name|op
operator|=
name|check_duplicate
argument_list|(
name|obj
argument_list|,
name|pack
argument_list|)
condition|)
block|{
name|free_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
else|else
block|{
name|obj
operator|->
name|ichar
operator|=
name|next_avail_ichar
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pack
operator|->
name|next_object
operator|==
literal|0
condition|)
block|{
name|pack
operator|->
name|next_object
operator|=
name|obj
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|pack
operator|->
name|next_object
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|next_object
condition|)
block|{
name|op
operator|=
name|op
operator|->
name|next_object
expr_stmt|;
block|}
name|op
operator|->
name|next_object
operator|=
name|obj
expr_stmt|;
block|}
name|obj
operator|->
name|next_object
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
end_block

begin_macro
name|take_from_pack
argument_list|(
argument|obj
argument_list|,
argument|pack
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|pack
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|pack
operator|->
name|next_object
operator|!=
name|obj
condition|)
block|{
name|pack
operator|=
name|pack
operator|->
name|next_object
expr_stmt|;
block|}
name|pack
operator|->
name|next_object
operator|=
name|pack
operator|->
name|next_object
operator|->
name|next_object
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Note: *status is set to 0 if the rogue attempts to pick up a scroll  * of scare-monster and it turns to dust.  *status is otherwise set to 1.  */
end_comment

begin_function
name|object
modifier|*
name|pick_up
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|,
name|status
parameter_list|)
name|short
modifier|*
name|status
decl_stmt|;
block|{
name|object
modifier|*
name|obj
decl_stmt|;
operator|*
name|status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|levitate
condition|)
block|{
name|message
argument_list|(
literal|"you're floating in the air!"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|object
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|obj
operator|=
name|object_at
argument_list|(
operator|&
name|level_objects
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|message
argument_list|(
literal|"pick_up(): inconsistent"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|obj
operator|->
name|what_is
operator|==
name|SCROL
operator|)
operator|&&
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|SCARE_MONSTER
operator|)
operator|&&
name|obj
operator|->
name|picked_up
condition|)
block|{
name|message
argument_list|(
literal|"the scroll turns to dust as you pick it up"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&=
operator|(
operator|~
name|OBJECT
operator|)
expr_stmt|;
name|vanish
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|level_objects
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|id_scrolls
index|[
name|SCARE_MONSTER
index|]
operator|.
name|id_status
operator|==
name|UNIDENTIFIED
condition|)
block|{
name|id_scrolls
index|[
name|SCARE_MONSTER
index|]
operator|.
name|id_status
operator|=
name|IDENTIFIED
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|object
operator|*
operator|)
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|what_is
operator|==
name|GOLD
condition|)
block|{
name|rogue
operator|.
name|gold
operator|+=
name|obj
operator|->
name|quantity
expr_stmt|;
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&=
operator|~
operator|(
name|OBJECT
operator|)
expr_stmt|;
name|take_from_pack
argument_list|(
name|obj
argument_list|,
operator|&
name|level_objects
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_GOLD
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
comment|/* obj will be free_object()ed in caller */
block|}
if|if
condition|(
name|pack_count
argument_list|(
name|obj
argument_list|)
operator|>=
name|MAX_PACK_COUNT
condition|)
block|{
name|message
argument_list|(
literal|"pack too full"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|object
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&=
operator|~
operator|(
name|OBJECT
operator|)
expr_stmt|;
name|take_from_pack
argument_list|(
name|obj
argument_list|,
operator|&
name|level_objects
argument_list|)
expr_stmt|;
name|obj
operator|=
name|add_to_pack
argument_list|(
name|obj
argument_list|,
operator|&
name|rogue
operator|.
name|pack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obj
operator|->
name|picked_up
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
end_function

begin_macro
name|drop
argument_list|()
end_macro

begin_block
block|{
name|object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|short
name|ch
decl_stmt|;
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
if|if
condition|(
name|dungeon
index|[
name|rogue
operator|.
name|row
index|]
index|[
name|rogue
operator|.
name|col
index|]
operator|&
operator|(
name|OBJECT
operator||
name|STAIRS
operator||
name|TRAP
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"there's already something there"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|rogue
operator|.
name|pack
operator|.
name|next_object
condition|)
block|{
name|message
argument_list|(
literal|"you have nothing to drop"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"drop what?"
argument_list|,
name|ALL_OBJECTS
argument_list|)
operator|)
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|BEING_WIELDED
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|is_cursed
condition|)
block|{
name|message
argument_list|(
name|curse_message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|unwield
argument_list|(
name|rogue
operator|.
name|weapon
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|BEING_WORN
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|is_cursed
condition|)
block|{
name|message
argument_list|(
name|curse_message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mv_aquatars
argument_list|()
expr_stmt|;
name|unwear
argument_list|(
name|rogue
operator|.
name|armor
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_ARMOR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|ON_EITHER_HAND
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|is_cursed
condition|)
block|{
name|message
argument_list|(
name|curse_message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|un_put_on
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|obj
operator|->
name|row
operator|=
name|rogue
operator|.
name|row
expr_stmt|;
name|obj
operator|->
name|col
operator|=
name|rogue
operator|.
name|col
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|quantity
operator|>
literal|1
operator|)
operator|&&
operator|(
name|obj
operator|->
name|what_is
operator|!=
name|WEAPON
operator|)
condition|)
block|{
name|obj
operator|->
name|quantity
operator|--
expr_stmt|;
name|new
operator|=
name|alloc_object
argument_list|()
expr_stmt|;
operator|*
name|new
operator|=
operator|*
name|obj
expr_stmt|;
name|new
operator|->
name|quantity
operator|=
literal|1
expr_stmt|;
name|obj
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|ichar
operator|=
literal|'L'
expr_stmt|;
name|take_from_pack
argument_list|(
name|obj
argument_list|,
operator|&
name|rogue
operator|.
name|pack
argument_list|)
expr_stmt|;
block|}
name|place_at
argument_list|(
name|obj
argument_list|,
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
argument_list|,
literal|"dropped "
argument_list|)
expr_stmt|;
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|object
modifier|*
name|check_duplicate
parameter_list|(
name|obj
parameter_list|,
name|pack
parameter_list|)
name|object
modifier|*
name|obj
decl_stmt|,
decl|*
name|pack
decl_stmt|;
end_function

begin_block
block|{
name|object
modifier|*
name|op
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|what_is
operator|&
operator|(
name|WEAPON
operator||
name|FOOD
operator||
name|SCROL
operator||
name|POTION
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|obj
operator|->
name|what_is
operator|==
name|FOOD
operator|)
operator|&&
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|FRUIT
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|op
operator|=
name|pack
operator|->
name|next_object
expr_stmt|;
while|while
condition|(
name|op
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|->
name|what_is
operator|==
name|obj
operator|->
name|what_is
operator|)
operator|&&
operator|(
name|op
operator|->
name|which_kind
operator|==
name|obj
operator|->
name|which_kind
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|obj
operator|->
name|what_is
operator|!=
name|WEAPON
operator|)
operator|||
operator|(
operator|(
name|obj
operator|->
name|what_is
operator|==
name|WEAPON
operator|)
operator|&&
operator|(
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|ARROW
operator|)
operator|||
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|DAGGER
operator|)
operator|||
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|DART
operator|)
operator|||
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|SHURIKEN
operator|)
operator|)
operator|&&
operator|(
name|obj
operator|->
name|quiver
operator|==
name|op
operator|->
name|quiver
operator|)
operator|)
condition|)
block|{
name|op
operator|->
name|quantity
operator|+=
name|obj
operator|->
name|quantity
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
block|}
name|op
operator|=
name|op
operator|->
name|next_object
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|next_avail_ichar
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|object
modifier|*
name|obj
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|boolean
name|ichars
index|[
literal|26
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|ichars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|obj
operator|=
name|rogue
operator|.
name|pack
operator|.
name|next_object
expr_stmt|;
while|while
condition|(
name|obj
condition|)
block|{
name|ichars
index|[
operator|(
name|obj
operator|->
name|ichar
operator|-
literal|'a'
operator|)
index|]
operator|=
literal|1
expr_stmt|;
name|obj
operator|=
name|obj
operator|->
name|next_object
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ichars
index|[
name|i
index|]
condition|)
block|{
return|return
operator|(
name|i
operator|+
literal|'a'
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|'?'
operator|)
return|;
block|}
end_block

begin_macro
name|wait_for_ack
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|rgetchar
argument_list|()
operator|!=
literal|' '
condition|)
empty_stmt|;
block|}
end_block

begin_macro
name|pack_letter
argument_list|(
argument|prompt
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|ch
decl_stmt|;
name|unsigned
name|short
name|tmask
init|=
name|mask
decl_stmt|;
if|if
condition|(
operator|!
name|mask_pack
argument_list|(
operator|&
name|rogue
operator|.
name|pack
argument_list|,
name|mask
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"nothing appropriate"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|CANCEL
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|message
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|rgetchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_pack_letter
argument_list|(
operator|&
name|ch
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|sound_bell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ch
operator|==
name|LIST
condition|)
block|{
name|check_message
argument_list|()
expr_stmt|;
name|inventory
argument_list|(
operator|&
name|rogue
operator|.
name|pack
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|mask
operator|=
name|tmask
expr_stmt|;
block|}
name|check_message
argument_list|()
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_macro
name|take_off
argument_list|()
end_macro

begin_block
block|{
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
name|object
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
name|rogue
operator|.
name|armor
condition|)
block|{
if|if
condition|(
name|rogue
operator|.
name|armor
operator|->
name|is_cursed
condition|)
block|{
name|message
argument_list|(
name|curse_message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mv_aquatars
argument_list|()
expr_stmt|;
name|obj
operator|=
name|rogue
operator|.
name|armor
expr_stmt|;
name|unwear
argument_list|(
name|rogue
operator|.
name|armor
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
argument_list|,
literal|"was wearing "
argument_list|)
expr_stmt|;
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_ARMOR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|message
argument_list|(
literal|"not wearing any"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|wear
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
specifier|register
name|object
modifier|*
name|obj
decl_stmt|;
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
if|if
condition|(
name|rogue
operator|.
name|armor
condition|)
block|{
name|message
argument_list|(
literal|"your already wearing some"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"wear what?"
argument_list|,
name|ARMOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|what_is
operator|!=
name|ARMOR
condition|)
block|{
name|message
argument_list|(
literal|"you can't wear that"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|obj
operator|->
name|identified
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
argument_list|,
literal|"wearing "
argument_list|)
expr_stmt|;
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_wear
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_ARMOR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|unwear
argument_list|(
argument|obj
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|obj
condition|)
block|{
name|obj
operator|->
name|in_use_flags
operator|&=
operator|(
operator|~
name|BEING_WORN
operator|)
expr_stmt|;
block|}
name|rogue
operator|.
name|armor
operator|=
operator|(
name|object
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|do_wear
argument_list|(
argument|obj
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rogue
operator|.
name|armor
operator|=
name|obj
expr_stmt|;
name|obj
operator|->
name|in_use_flags
operator||=
name|BEING_WORN
expr_stmt|;
name|obj
operator|->
name|identified
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|wield
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
specifier|register
name|object
modifier|*
name|obj
decl_stmt|;
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
if|if
condition|(
name|rogue
operator|.
name|weapon
operator|&&
name|rogue
operator|.
name|weapon
operator|->
name|is_cursed
condition|)
block|{
name|message
argument_list|(
name|curse_message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"wield what?"
argument_list|,
name|WEAPON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"No such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|what_is
operator|&
operator|(
name|ARMOR
operator||
name|RING
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|desc
argument_list|,
literal|"you can't wield %s"
argument_list|,
operator|(
operator|(
name|obj
operator|->
name|what_is
operator|==
name|ARMOR
operator|)
condition|?
literal|"armor"
else|:
literal|"rings"
operator|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|BEING_WIELDED
condition|)
block|{
name|message
argument_list|(
literal|"in use"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unwield
argument_list|(
name|rogue
operator|.
name|weapon
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
argument_list|,
literal|"wielding "
argument_list|)
expr_stmt|;
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
operator|+
literal|9
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_wield
argument_list|(
name|obj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|do_wield
argument_list|(
argument|obj
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rogue
operator|.
name|weapon
operator|=
name|obj
expr_stmt|;
name|obj
operator|->
name|in_use_flags
operator||=
name|BEING_WIELDED
expr_stmt|;
block|}
end_block

begin_macro
name|unwield
argument_list|(
argument|obj
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|obj
condition|)
block|{
name|obj
operator|->
name|in_use_flags
operator|&=
operator|(
operator|~
name|BEING_WIELDED
operator|)
expr_stmt|;
block|}
name|rogue
operator|.
name|weapon
operator|=
operator|(
name|object
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|call_it
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
specifier|register
name|object
modifier|*
name|obj
decl_stmt|;
name|struct
name|id
modifier|*
name|id_table
decl_stmt|;
name|char
name|buf
index|[
name|MAX_TITLE_LENGTH
operator|+
literal|2
index|]
decl_stmt|;
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"call what?"
argument_list|,
operator|(
name|SCROL
operator||
name|POTION
operator||
name|WAND
operator||
name|RING
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|what_is
operator|&
operator|(
name|SCROL
operator||
name|POTION
operator||
name|WAND
operator||
name|RING
operator|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"surely you already know what that's called"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|id_table
operator|=
name|get_id_table
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_input_line
argument_list|(
literal|"call it:"
argument_list|,
literal|""
argument_list|,
name|buf
argument_list|,
name|id_table
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|title
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|id_table
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|=
name|CALLED
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|id_table
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|title
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pack_count
argument_list|(
argument|new_obj
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|new_obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|object
modifier|*
name|obj
decl_stmt|;
name|short
name|count
init|=
literal|0
decl_stmt|;
name|obj
operator|=
name|rogue
operator|.
name|pack
operator|.
name|next_object
expr_stmt|;
while|while
condition|(
name|obj
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|what_is
operator|!=
name|WEAPON
condition|)
block|{
name|count
operator|+=
name|obj
operator|->
name|quantity
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|new_obj
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_obj
operator|->
name|what_is
operator|!=
name|WEAPON
operator|)
operator|||
operator|(
operator|(
name|obj
operator|->
name|which_kind
operator|!=
name|ARROW
operator|)
operator|&&
operator|(
name|obj
operator|->
name|which_kind
operator|!=
name|DAGGER
operator|)
operator|&&
operator|(
name|obj
operator|->
name|which_kind
operator|!=
name|DART
operator|)
operator|&&
operator|(
name|obj
operator|->
name|which_kind
operator|!=
name|SHURIKEN
operator|)
operator|)
operator|||
operator|(
name|new_obj
operator|->
name|which_kind
operator|!=
name|obj
operator|->
name|which_kind
operator|)
operator|||
operator|(
name|obj
operator|->
name|quiver
operator|!=
name|new_obj
operator|->
name|quiver
operator|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|obj
operator|=
name|obj
operator|->
name|next_object
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_function
name|boolean
name|mask_pack
parameter_list|(
name|pack
parameter_list|,
name|mask
parameter_list|)
name|object
modifier|*
name|pack
decl_stmt|;
name|unsigned
name|short
name|mask
decl_stmt|;
block|{
while|while
condition|(
name|pack
operator|->
name|next_object
condition|)
block|{
name|pack
operator|=
name|pack
operator|->
name|next_object
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|what_is
operator|&
name|mask
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|is_pack_letter
argument_list|(
argument|c
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
modifier|*
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|c
operator|==
literal|'?'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|'='
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|')'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|','
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'?'
case|:
operator|*
name|mask
operator|=
name|SCROL
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
operator|*
name|mask
operator|=
name|POTION
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|*
name|mask
operator|=
name|FOOD
expr_stmt|;
break|break;
case|case
literal|')'
case|:
operator|*
name|mask
operator|=
name|WEAPON
expr_stmt|;
break|break;
case|case
literal|']'
case|:
operator|*
name|mask
operator|=
name|ARMOR
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
operator|*
name|mask
operator|=
name|WAND
expr_stmt|;
break|break;
case|case
literal|'='
case|:
operator|*
name|mask
operator|=
name|RING
expr_stmt|;
break|break;
case|case
literal|','
case|:
operator|*
name|mask
operator|=
name|AMULET
expr_stmt|;
break|break;
block|}
operator|*
name|c
operator|=
name|LIST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
operator|(
operator|*
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|c
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
name|CANCEL
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
name|LIST
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|has_amulet
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|mask_pack
argument_list|(
operator|&
name|rogue
operator|.
name|pack
argument_list|,
name|AMULET
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|kick_into_pack
argument_list|()
end_macro

begin_block
block|{
name|object
modifier|*
name|obj
decl_stmt|;
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
name|short
name|n
decl_stmt|,
name|stat
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dungeon
index|[
name|rogue
operator|.
name|row
index|]
index|[
name|rogue
operator|.
name|col
index|]
operator|&
name|OBJECT
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"nothing here"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|obj
operator|=
name|pick_up
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|,
operator|&
name|stat
argument_list|)
condition|)
block|{
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|what_is
operator|==
name|GOLD
condition|)
block|{
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|strlen
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|desc
index|[
name|n
index|]
operator|=
literal|'('
expr_stmt|;
name|desc
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|obj
operator|->
name|ichar
expr_stmt|;
name|desc
index|[
name|n
operator|+
literal|2
index|]
operator|=
literal|')'
expr_stmt|;
name|desc
index|[
name|n
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|obj
operator|||
operator|(
operator|!
name|stat
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

