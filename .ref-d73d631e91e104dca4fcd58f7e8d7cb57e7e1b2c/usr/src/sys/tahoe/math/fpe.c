begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * %sccs.include.redist.c%  *  *	@(#)fpe.c	7.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"../include/psl.h"
end_include

begin_include
include|#
directive|include
file|"../include/reg.h"
end_include

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"../include/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../math/Kfp.h"
end_include

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/user.h"
end_include

begin_include
include|#
directive|include
file|"sys/proc.h"
end_include

begin_include
include|#
directive|include
file|"sys/seg.h"
end_include

begin_include
include|#
directive|include
file|"sys/acct.h"
end_include

begin_include
include|#
directive|include
file|"sys/kernel.h"
end_include

begin_comment
comment|/*  * Floating point emulation support.  */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|Kcvtlf
argument_list|()
decl_stmt|,
name|Kaddf
argument_list|()
decl_stmt|,
name|Ksubf
argument_list|()
decl_stmt|,
name|Kmulf
argument_list|()
decl_stmt|,
name|Kdivf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|Kcvtld
argument_list|()
decl_stmt|,
name|Kaddd
argument_list|()
decl_stmt|,
name|Ksubd
argument_list|()
decl_stmt|,
name|Kmuld
argument_list|()
decl_stmt|,
name|Kdivd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|float
name|Ksinf
argument_list|()
decl_stmt|,
name|Kcosf
argument_list|()
decl_stmt|,
name|Katanf
argument_list|()
decl_stmt|,
name|Klogf
argument_list|()
decl_stmt|,
name|Ksqrtf
argument_list|()
decl_stmt|,
name|Kexpf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OP
parameter_list|(
name|dop
parameter_list|)
value|((dop)&~ 01)
end_define

begin_comment
comment|/* precision-less version of opcode */
end_comment

begin_define
define|#
directive|define
name|isdouble
parameter_list|(
name|op
parameter_list|)
value|((op)& 01)
end_define

begin_comment
comment|/* is opcode double or float */
end_comment

begin_struct
struct|struct
name|fpetab
block|{
name|int
name|fpe_op
decl_stmt|;
comment|/* base opcode emulating */
name|float
function_decl|(
modifier|*
name|fpe_ffunc
function_decl|)
parameter_list|()
function_decl|;
comment|/* float version of op */
name|double
function_decl|(
modifier|*
name|fpe_dfunc
function_decl|)
parameter_list|()
function_decl|;
comment|/* double version of op */
block|}
name|fpetab
index|[]
init|=
block|{
block|{
name|OP
argument_list|(
name|CVLD
argument_list|)
block|,
name|Kcvtlf
block|,
name|Kcvtld
block|}
block|,
block|{
name|OP
argument_list|(
name|ADDD
argument_list|)
block|,
name|Kaddf
block|,
name|Kaddd
block|}
block|,
block|{
name|OP
argument_list|(
name|SUBD
argument_list|)
block|,
name|Ksubf
block|,
name|Ksubd
block|}
block|,
block|{
name|OP
argument_list|(
name|MULD
argument_list|)
block|,
name|Kmulf
block|,
name|Kmuld
block|}
block|,
block|{
name|OP
argument_list|(
name|DIVD
argument_list|)
block|,
name|Kdivf
block|,
name|Kdivd
block|}
block|,
block|{
name|SINF
block|,
name|Ksinf
block|,
literal|0
block|}
block|,
block|{
name|COSF
block|,
name|Kcosf
block|,
literal|0
block|}
block|,
block|{
name|ATANF
block|,
name|Katanf
block|,
literal|0
block|}
block|,
block|{
name|LOGF
block|,
name|Klogf
block|,
literal|0
block|}
block|,
block|{
name|SQRTF
block|,
name|Ksqrtf
block|,
literal|0
block|}
block|,
block|{
name|EXPF
block|,
name|Kexpf
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|NFPETAB
value|(sizeof (fpetab) / sizeof (fpetab[0]))
end_define

begin_comment
comment|/*  * Emulate the FP opcode. Update psl as necessary.  * If OK, set opcode to 0, else to the FP exception #.  * Not all parameter longwords are relevant, depends on opcode.  *  * The entry mask is set by locore.s so ALL registers are saved.  * This enables FP opcodes to change user registers on return.  */
end_comment

begin_comment
comment|/* WARNING!!!! THIS CODE MUST NOT PRODUCE ANY FLOATING POINT EXCEPTIONS */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|fpemulate
argument_list|(
argument|hfsreg
argument_list|,
argument|acc_most
argument_list|,
argument|acc_least
argument_list|,
argument|dbl
argument_list|,
argument|op_most
argument_list|,
argument|op_least
argument_list|,
argument|opcode
argument_list|,
argument|pc
argument_list|,
argument|psl
argument_list|)
end_macro

begin_block
block|{
name|int
name|r0
decl_stmt|,
name|r1
decl_stmt|;
comment|/* must reserve space */
specifier|register
name|int
modifier|*
name|locr0
init|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|psl
operator|)
operator|-
name|PS
decl_stmt|;
specifier|register
name|struct
name|fpetab
modifier|*
name|fp
decl_stmt|;
name|int
name|hfs
init|=
literal|0
decl_stmt|;
comment|/* returned data about exceptions */
name|int
name|type
decl_stmt|;
comment|/* opcode type, FLOAT or DOUBLE */
union|union
block|{
name|float
name|ff
decl_stmt|;
name|int
name|fi
decl_stmt|;
block|}
name|f_res
union|;
union|union
block|{
name|double
name|dd
decl_stmt|;
name|int
name|di
index|[
literal|2
index|]
decl_stmt|;
block|}
name|d_res
union|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|r0
operator|=
literal|0
expr_stmt|;
name|r0
operator|=
name|r0
expr_stmt|;
name|r1
operator|=
literal|0
expr_stmt|;
name|r1
operator|=
name|r1
expr_stmt|;
endif|#
directive|endif
name|type
operator|=
name|isdouble
argument_list|(
name|opcode
argument_list|)
condition|?
name|DOUBLE
else|:
name|FLOAT
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|fpetab
init|;
name|fp
operator|<
operator|&
name|fpetab
index|[
name|NFPETAB
index|]
condition|;
name|fp
operator|++
control|)
if|if
condition|(
operator|(
name|opcode
operator|&
literal|0xfe
operator|)
operator|==
name|fp
operator|->
name|fpe_op
condition|)
break|break;
if|if
condition|(
name|type
operator|==
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fpe_dfunc
operator|==
literal|0
condition|)
name|fp
operator|=
operator|&
name|fpetab
index|[
name|NFPETAB
index|]
expr_stmt|;
else|else
name|locr0
index|[
name|PS
index|]
operator|&=
operator|~
name|PSL_DBL
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|>=
operator|&
name|fpetab
index|[
name|NFPETAB
index|]
condition|)
block|{
name|opcode
operator|=
name|DIV0_EXC
expr_stmt|;
comment|/* generate SIGILL - XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|d_res
operator|.
name|dd
operator|=
call|(
modifier|*
name|fp
operator|->
name|fpe_dfunc
call|)
argument_list|(
name|acc_most
argument_list|,
name|acc_least
argument_list|,
name|op_most
argument_list|,
name|op_least
argument_list|,
operator|&
name|hfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_res
operator|.
name|di
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|d_res
operator|.
name|di
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_Z
expr_stmt|;
if|if
condition|(
name|d_res
operator|.
name|di
index|[
literal|0
index|]
operator|<
literal|0
condition|)
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_N
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|f_res
operator|.
name|ff
operator|=
call|(
modifier|*
name|fp
operator|->
name|fpe_ffunc
call|)
argument_list|(
name|acc_most
argument_list|,
name|acc_least
argument_list|,
name|op_most
argument_list|,
name|op_least
argument_list|,
operator|&
name|hfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_res
operator|.
name|fi
operator|==
literal|0
condition|)
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_Z
expr_stmt|;
if|if
condition|(
name|f_res
operator|.
name|fi
operator|==
literal|0
condition|)
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_N
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hfs
operator|&
name|HFS_OVF
condition|)
block|{
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_V
expr_stmt|;
comment|/* turn on overflow bit */
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|locr0
index|[
name|PS
index|]
operator|&
name|PSL_IV
condition|)
block|{
comment|/* overflow enabled? */
endif|#
directive|endif
name|opcode
operator|=
name|OVF_EXC
expr_stmt|;
return|return
operator|(
operator|(
name|hfs
operator|&
name|HFS_DOM
operator|)
condition|?
name|EDOM
else|:
name|ERANGE
operator|)
return|;
ifdef|#
directive|ifdef
name|notdef
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|hfs
operator|&
name|HFS_UNDF
condition|)
block|{
if|if
condition|(
name|locr0
index|[
name|PS
index|]
operator|&
name|PSL_FU
condition|)
block|{
comment|/* underflow enabled? */
name|opcode
operator|=
name|UNDF_EXC
expr_stmt|;
return|return
operator|(
operator|(
name|hfs
operator|&
name|HFS_DOM
operator|)
condition|?
name|EDOM
else|:
name|ERANGE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|hfs
operator|&
name|HFS_DIVZ
condition|)
block|{
name|opcode
operator|=
name|DIV0_EXC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|hfs
operator|&
name|HFS_DOM
condition|)
name|error
operator|=
name|EDOM
expr_stmt|;
elseif|else
if|if
condition|(
name|hfs
operator|&
name|HFS_RANGE
condition|)
name|error
operator|=
name|ERANGE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
if|if
condition|(
name|hfs
operator|&
operator|(
name|HFS_OVF
operator||
name|HFS_UNDF
operator|)
condition|)
block|{
name|d_res
operator|.
name|dd
operator|=
literal|0.0
expr_stmt|;
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_Z
expr_stmt|;
block|}
name|mvtodacc
argument_list|(
name|d_res
operator|.
name|di
index|[
literal|0
index|]
argument_list|,
name|d_res
operator|.
name|di
index|[
literal|1
index|]
argument_list|,
operator|&
name|acc_most
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|hfs
operator|&
operator|(
name|HFS_OVF
operator||
name|HFS_UNDF
operator|)
condition|)
block|{
name|f_res
operator|.
name|ff
operator|=
literal|0.0
expr_stmt|;
name|locr0
index|[
name|PS
index|]
operator||=
name|PSL_Z
expr_stmt|;
block|}
name|mvtofacc
argument_list|(
name|f_res
operator|.
name|ff
argument_list|,
operator|&
name|acc_most
argument_list|)
expr_stmt|;
break|break;
block|}
name|opcode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

end_unit

