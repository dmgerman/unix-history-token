begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	tp_input.c	1.3	82/10/09	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../netdecnet/dn_systm.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../netdecnet/tp.h"
end_include

begin_include
include|#
directive|include
file|"../netdecnet/tp_var.h"
end_include

begin_comment
comment|/*  * Initialize a few of the Transport variables here.  */
end_comment

begin_macro
name|tp_init
argument_list|()
end_macro

begin_block
block|{
name|tp_host
operator|=
literal|244
expr_stmt|;
name|tprp
operator|.
name|tprp_nn
operator|=
literal|255
expr_stmt|;
comment|/* max node number */
block|}
end_block

begin_comment
comment|/*  * Attach a DECnet interface.  * For now, since we are an end node,  * there can only be one.  */
end_comment

begin_expr_stmt
name|tp_attach
argument_list|(
name|ifp
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|tpifp
condition|)
block|{
name|printf
argument_list|(
literal|"tp: Only one DECnet interface allowed, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d ignored\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|tpifp
operator|=
name|ifp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Transport input routine.  Decode header, process  * initialization messages, flush other control messages,  * and strip route headers and pass to NSP.  */
end_comment

begin_macro
name|tp_input
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|next
label|:
comment|/* 	 * Get next packet off input queue. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|tpintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|&
name|TP_MSGTYPE
condition|)
block|{
comment|/* 	 * Transport initialization message from neighbor. 	 */
case|case
name|TP_INIT
case|:
block|{
specifier|register
name|struct
name|tpin
modifier|*
name|t
init|=
operator|(
expr|struct
name|tpin
operator|*
operator|)
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"tpinit: node %d, %d, blksize %d, ver %o.%o.%o\n"
argument_list|,
name|D_SHORT
argument_list|(
name|t
operator|->
name|tpin_srcnode
argument_list|)
argument_list|,
name|t
operator|->
name|tpin_tiinfo
argument_list|,
name|D_SHORT
argument_list|(
name|t
operator|->
name|tpin_blksize
argument_list|)
argument_list|,
name|t
operator|->
name|tpin_ver
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|tpin_ver
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|tpin_ver
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* perform a few consistency checks */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tpin
argument_list|)
condition|)
block|{
name|tpstat
operator|.
name|tps_badinit
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|D_SHORT
argument_list|(
name|t
operator|->
name|tpin_srcnode
argument_list|)
operator|>
name|tprp
operator|.
name|tprp_nn
condition|)
block|{
name|tpstat
operator|.
name|tps_badinit
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|tpin_res
operator|!=
literal|0
condition|)
block|{
name|tpstat
operator|.
name|tps_badinit
operator|++
expr_stmt|;
break|break;
block|}
name|tpstat
operator|.
name|tps_init
operator|++
expr_stmt|;
if|if
condition|(
name|tpstate
operator|==
name|TPS_TIS
condition|)
block|{
name|tpstate
operator|=
name|TPS_RUN
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tpstate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tpstate
operator|==
name|TPS_HALT
condition|)
block|{
name|tp_linit
argument_list|()
expr_stmt|;
name|tpstate
operator|=
name|TPS_RUN
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Route header.  Flush bad ones, 	 * strip good ones and pass to NSP. 	 */
case|case
name|TP_RH
case|:
block|{
specifier|register
name|struct
name|tprh
modifier|*
name|t
init|=
operator|(
expr|struct
name|tprh
operator|*
operator|)
name|p
decl_stmt|;
comment|/* 		 * Is it a reasonable route header? 		 */
if|if
condition|(
name|tpstate
operator|!=
name|TPS_RUN
condition|)
block|{
name|printf
argument_list|(
literal|"tp: not running!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|tprh_rtflg
operator|&
name|TPRF_EV
condition|)
block|{
name|printf
argument_list|(
literal|"tp: got P2 ASCII header\n"
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_p2hdr
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|tprh_rtflg
operator|&
name|TPRF_RTS
condition|)
block|{
name|printf
argument_list|(
literal|"tp: got returned packet\n"
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_returned
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|tprh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tp: got short packet, %d\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_shortpacket
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|D_SHORT
argument_list|(
name|t
operator|->
name|tprh_srcnode
argument_list|)
operator|>
name|tprp
operator|.
name|tprp_nn
condition|)
block|{
name|tpstat
operator|.
name|tps_badsrc
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Is it for us?  If so,  		 * add it to the NSP input queue. 		 */
if|if
condition|(
name|D_SHORT
argument_list|(
name|t
operator|->
name|tprh_dstnode
argument_list|)
operator|!=
name|tp_host
condition|)
block|{
name|printf
argument_list|(
literal|"tp: not for me, %d\n"
argument_list|,
name|D_SHORT
argument_list|(
name|t
operator|->
name|tprh_dstnode
argument_list|)
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_notforme
operator|++
expr_stmt|;
break|break;
block|}
name|setnspintr
argument_list|()
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|nspintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 	 * Verification messge.  We should never see one 	 * of these because we never ask for one.  Flush it. 	 */
case|case
name|TP_VERIF
case|:
name|printf
argument_list|(
literal|"tp: got verification message\n"
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_verif
operator|++
expr_stmt|;
break|break;
comment|/* 	 * Hello and test message.  Make sure it's 	 * valid then flush it. 	 */
case|case
name|TP_TEST
case|:
block|{
specifier|register
name|struct
name|tpht
modifier|*
name|t
init|=
operator|(
expr|struct
name|tpht
operator|*
operator|)
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|D_SHORT
argument_list|(
name|t
operator|->
name|tpht_srcnode
argument_list|)
operator|>
name|tprp
operator|.
name|tprp_nn
condition|)
block|{
name|tpstat
operator|.
name|tps_badsrc
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|t
operator|->
name|tpht_cnt
operator|)
operator|<
literal|0
operator|||
name|i
operator|>
literal|128
condition|)
block|{
name|printf
argument_list|(
literal|"tp: test, bad count, %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_badtest
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|tpht
argument_list|)
operator|+
name|i
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"tp: test, bad len, %d\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_bad_test
operator|++
expr_stmt|;
break|break;
block|}
for|for
control|(
name|p
operator|=
name|t
operator|->
name|tpht_data
init|;
name|i
operator|--
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|0252
condition|)
block|{
name|printf
argument_list|(
literal|"tp: test, bad data, %o\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_badtest
operator|++
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* 	 * Routing message.  We should never get this, 	 * at least not yet.  Just flush it. 	 */
case|case
name|TP_ROUTE
case|:
name|printf
argument_list|(
literal|"tp: got routing message\n"
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_route
operator|++
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"tp: unknown packet type, 0x%x\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|tpstat
operator|.
name|tps_unknown
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 	 * Free the current packet and get the next one. 	 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
end_block

end_unit

