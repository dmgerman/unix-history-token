begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: tcp_input.c,v 1.25 85/07/31 09:33:47 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/seq.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsmdef.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/macros.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/nopcb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HMPTRAPS
end_ifdef

begin_include
include|#
directive|include
file|"../bbnnet/hmp_traps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HMPTRAPS
end_ifdef

begin_define
define|#
directive|define
name|HMP_TRAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|hmp_trap(a,b,c)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HMP_TRAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|nosum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|inpcb
name|tcp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * net preproc (66,67,68,69,70,71,72,73,74,75,76)  *  * macro form of former function netprepr()  *  * tp	valid tcpcb  * n	valid th  * inp	valid inpcb ( == tp->t_in_pcb )  */
end_comment

begin_define
define|#
directive|define
name|NETPREPR
parameter_list|(
name|tp
parameter_list|,
name|n
parameter_list|,
name|inp
parameter_list|,
name|retval
parameter_list|)
define|\
value|{ \ 	retval = (-1);
comment|/* assume bad */
value|\
comment|/* tell caller to eat segment (unacceptable) */
value|\  \ 	switch (tp->t_state) { \ 	    case LISTEN: \
comment|/* Ignore resets, ACKs cause resets, must have SYN. */
value|\ 		if (n->t_flags&T_RST) \ 			break; \ 		else if (n->t_flags&T_ACK) \ 			send_rst(tp, n); \ 		else if (n->t_flags&T_SYN) \ 			retval = SAME; \ 		break; \ \ 	case SYN_SENT: \
comment|/* Bad ACKs cause resets, good resets close, must have SYN. */
value|\ 		if (n->t_flags&T_ACK&& (SEQ_GEQ(tp->iss, n->t_ackno) || \ 					 SEQ_GT(n->t_ackno, tp->snd_hi))) \ 			send_rst(tp, n); \ 		else if (n->t_flags&T_RST) { \ 			if (n->t_flags&T_ACK) { \ 				t_close(tp, ECONNREFUSED); \ 				retval = CLOSED; \ 			} \ 		} else if (n->t_flags&T_SYN) \ 			retval = SAME; \ 		break; \  \ 	case 0: \
comment|/* \ 		 * after bind, but before we've had a chance to \ 		 * listen or connect \ 		 */
value|\ 		break; \  \ 	default: \ 		{ struct sockbuf *sorcv; sequence xend; \
comment|/* \ 		 * Part of packet must fall in window. \ 		 * This allows for segments that are partially retransmits \ 		 * and partially new. \ 		 * otherwise just ACK and drop. \ 		 */
value|\ 		sorcv =&inp->inp_socket->so_rcv; \ 		xend = n->t_seq; \ 		if (n->t_len) \
comment|/* remember, could be an ACK-only packet */
value|\ 			xend += n->t_len -1; \ 		if (n->t_flags& T_FIN) \ 			xend ++;
comment|/* in case FIN + rxmitted data (TOPS-20) */
value|\ 		if (SEQ_LT(xend, tp->rcv_nxt) || \ 		    SEQ_GEQ(n->t_seq, tp->rcv_nxt + sbspace(sorcv))) { \ 			tp->t_preproc++; \ 			send_tcp(tp, TCP_CTL); \ 			HMP_TRAP(T_TCP_WINDOW, (caddr_t)0,0); \
comment|/* \ 		 * Due to 4.2BSD net architecture, don't need to send \ 		 * L_SYN_RCVD socket back to LISTEN on reset since server \ 		 * socket and communication paths are separate. \ 		 */
value|\ 		} else if (n->t_flags&T_RST) { \ 			t_close(tp, ENETRESET); \ 			retval = CLOSED; \
comment|/* No SYNs allowed unless *SYN_RCVD */
value|\ 		} else if ((n->t_flags&T_SYN)&& (tp->t_state>= ESTAB)) { \ 			send_rst(tp, n); \ 			t_close(tp, ENETRESET); \ 			retval = CLOSED; \
comment|/* \ 		 * Must have good ACK.  Bad ACKs cause resets only in \ 		 * SYN_RCVD states.  In other states, this may be a slow pkt? \ 		 */
value|\ 		} else if (n->t_flags&T_ACK) \ 			if (SEQ_GT(tp->snd_una, n->t_ackno) ||	\ 			    SEQ_GT(n->t_ackno, tp->snd_hi)) {	\ 				if (tp->t_state == SYN_RCVD ||	\ 				    tp->t_state == L_SYN_RCVD)	\ 					send_rst(tp, n); \ 			} else { \
comment|/* \ 				 * Acceptable segment: \ 				 * Reset no activity timer on established and \ 				 * closing connections. \ 				 */
value|\ 				 if (tp->t_state>= ESTAB) \ 					tp->t_timers[TNOACT] = tp->t_noact; \ 				retval = SAME; \ }	}	}	}
end_define

begin_decl_stmt
name|int
name|tcp_net_keep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the scheduler for the tcp machine.  It is called  * from the lower network levels, either directly from the  * internet level, in case of input from the network; or  * indirectly from netmain, in case of user or timer events  * which awaken the main loop.  */
end_comment

begin_expr_stmt
name|tcp_input
argument_list|(
name|mp
argument_list|,
name|fragsize
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|mp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fragsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|th
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|hlen
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tlen
decl_stmt|;
name|struct
name|work
name|w
decl_stmt|;
name|u_short
name|cks
decl_stmt|;
name|tcpstat
operator|.
name|t_total
operator|++
expr_stmt|;
comment|/*      * see ip_input()      */
if|if
condition|(
operator|(
name|mp
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|m_pullup
argument_list|(
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tcpstat
operator|.
name|t_tooshort
operator|++
expr_stmt|;
return|return;
block|}
block|}
comment|/* set up needed info from ip header, note that beginning        of tcp header struct overlaps ip header.  ip options        have been removed by ip level option processing */
name|tp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|th
operator|*
argument_list|)
expr_stmt|;
comment|/* make sure header does not overflow mbuf */
name|hlen
operator|=
name|tp
operator|->
name|t_off
operator|<<
name|TCP_OFFSHIFT
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
name|TCPSIZE
condition|)
block|{
name|ip_log
argument_list|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tp
argument_list|,
literal|"tcp t_off too small"
argument_list|)
expr_stmt|;
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hlen
operator|>
name|mp
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|m_pullup
argument_list|(
name|mp
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ip_log
argument_list|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tp
argument_list|,
literal|"tcp header overflow"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_OVFLO, (caddr_t)0, 0); */
else|#
directive|else
comment|/* netlog(mp); */
endif|#
directive|endif
return|return;
block|}
name|tp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|th
operator|*
argument_list|)
expr_stmt|;
block|}
name|tlen
operator|=
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tp
operator|)
operator|->
name|ip_len
expr_stmt|;
name|tp
operator|->
name|t_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|tlen
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_next
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_prev
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_x1
operator|=
literal|0
expr_stmt|;
comment|/*      * do checksum calculation, drop seg if bad      */
name|i
operator|=
operator|(
name|u_short
operator|)
name|tp
operator|->
name|t_sum
expr_stmt|;
name|tp
operator|->
name|t_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|cks
operator|=
operator|(
name|u_short
operator|)
name|in_cksum
argument_list|(
name|mp
argument_list|,
name|tlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tcpstat
operator|.
name|t_badsum
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nosum
condition|)
block|{
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_CKSUM, (caddr_t)0,0); */
endif|#
directive|endif
name|inet_cksum_err
argument_list|(
literal|"tcp"
argument_list|,
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tp
argument_list|,
operator|(
name|u_long
operator|)
name|i
argument_list|,
operator|(
name|u_long
operator|)
name|cks
argument_list|)
expr_stmt|;
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* find a tcb for incoming message */
name|inp
operator|=
name|in_pcblookup
argument_list|(
operator|&
name|tcp
argument_list|,
name|tp
operator|->
name|t_s
operator|.
name|s_addr
argument_list|,
name|tp
operator|->
name|t_src
argument_list|,
name|tp
operator|->
name|t_d
operator|.
name|s_addr
argument_list|,
name|tp
operator|->
name|t_dst
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|t
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|inp
operator|->
name|inp_ppcb
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* found a tcp for message */
comment|/* byte swap header */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|tp
operator|->
name|t_len
operator|=
name|tlen
operator|-
name|hlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ip_log
argument_list|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tp
argument_list|,
literal|"tcp header length"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMPTRAPS
comment|/* hmp_trap(T_TCP_HLEN, (caddr_t)0,0); */
else|#
directive|else
name|netlog
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|tp
operator|->
name|t_seq
operator|=
name|ntohl
argument_list|(
name|tp
operator|->
name|t_seq
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_ackno
operator|=
name|ntohl
argument_list|(
name|tp
operator|->
name|t_ackno
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_win
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|tp
operator|->
name|t_win
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_urp
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|tp
operator|->
name|t_urp
argument_list|)
expr_stmt|;
comment|/* record the max fragment size */
name|t
operator|->
name|t_maxfrag
operator|=
name|MAX
argument_list|(
name|t
operator|->
name|t_maxfrag
argument_list|,
name|fragsize
argument_list|)
expr_stmt|;
comment|/* do TCP option processing */
if|if
condition|(
name|hlen
operator|>
name|TCPSIZE
condition|)
name|tcp_opt
argument_list|(
name|t
argument_list|,
name|tp
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* check seg seq #, do RST processing */
name|NETPREPR
argument_list|(
name|t
argument_list|,
name|tp
argument_list|,
name|inp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|SAME
condition|)
block|{
comment|/* segment failed preprocessing.  Drop it and 	     * possibly enter new state.  For now, always 	     * returns SAME/-1/CLOSED 	     */
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	    if ((i != -1)&& (i != CLOSED)) 		t->t_state = i; */
block|}
else|else
block|{
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|inp
operator|->
name|inp_socket
operator|->
name|so_rcv
argument_list|)
operator|<=
literal|0
operator|&&
name|tp
operator|->
name|t_len
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The user's receive q is full.  Either the 		 * remote TCP is not paying attention to the 		 * window, or this is a persistence packet. 		 * 		 * The first reason was once common with 		 * TOPS-20.  Let's conserve network resources 		 * by holding onto the packet in the unack q. 		 * Place it at the end of the list. 		 */
name|mp
operator|->
name|m_act
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|t
operator|->
name|t_rcv_unack
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|m
operator|->
name|m_act
operator|!=
name|NULL
condition|)
name|m
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
name|mp
expr_stmt|;
block|}
else|else
name|t
operator|->
name|t_rcv_unack
operator|=
name|mp
expr_stmt|;
comment|/* 		 * ACK if it was a window probe, just in case 		 * they have a TNOACT timer running. 		 */
name|send_tcp
argument_list|(
name|t
argument_list|,
name|TCP_CTL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|act
decl_stmt|,
name|newstate
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
comment|/* set up work entry for seg, and call 		   the fsm to process it */
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
name|mp
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
comment|/** HAND CODED action() CALL **/
name|w
operator|.
name|w_type
operator|=
name|INRECV
expr_stmt|;
name|w
operator|.
name|w_tcb
operator|=
name|t
expr_stmt|;
name|w
operator|.
name|w_dat
operator|=
operator|(
name|char
operator|*
operator|)
name|tp
expr_stmt|;
comment|/* get index of action routine from 		 * transition table 		 */
name|act
operator|=
name|fstab
index|[
name|t
operator|->
name|t_state
index|]
index|[
name|INRECV
index|]
expr_stmt|;
comment|/* invalid state transition, just 		 * print a message and ignore */
if|if
condition|(
name|act
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"tcp bad state: tcb=%x state=%d INRECV\n"
argument_list|,
name|t
argument_list|,
name|t
operator|->
name|t_state
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|so
operator|=
name|t
operator|->
name|t_in_pcb
operator|->
name|inp_socket
expr_stmt|;
name|tcp_net_keep
operator|=
name|FALSE
expr_stmt|;
name|newstate
operator|=
call|(
modifier|*
name|fsactab
index|[
name|act
index|]
call|)
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
comment|/* debugging info */
name|TCP_DEBUG
argument_list|(
name|so
argument_list|,
name|t
argument_list|,
operator|&
name|w
argument_list|,
name|act
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
comment|/* if CLOSED, lost tcpcb */
if|if
condition|(
operator|(
name|newstate
operator|!=
name|SAME
operator|)
operator|&&
operator|(
name|newstate
operator|!=
name|CLOSED
operator|)
condition|)
name|t
operator|->
name|t_state
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
operator|!
name|tcp_net_keep
condition|)
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/** END action() **/
block|}
block|}
block|}
else|else
comment|/* nobody wants it */
name|send_uncon_rst
argument_list|(
name|tp
argument_list|,
name|mp
argument_list|,
name|tlen
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|send_uncon_rst
argument_list|(
name|n
argument_list|,
name|mp
argument_list|,
name|tlen
argument_list|,
name|hlen
argument_list|)
specifier|register
expr|struct
name|th
operator|*
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|in_addr
name|tempinaddr
decl_stmt|;
name|u_short
name|tempport
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* make sure we don't send a RST in response to an RST */
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_RST
condition|)
block|{
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* free everything but the header */
name|m_freem
argument_list|(
name|mp
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
expr_stmt|;
comment|/* form a reset from the packet and send */
name|tempinaddr
operator|=
name|n
operator|->
name|t_d
expr_stmt|;
name|n
operator|->
name|t_d
operator|=
name|n
operator|->
name|t_s
expr_stmt|;
name|n
operator|->
name|t_s
operator|=
name|tempinaddr
expr_stmt|;
name|tempport
operator|=
name|n
operator|->
name|t_src
expr_stmt|;
name|n
operator|->
name|t_src
operator|=
name|n
operator|->
name|t_dst
expr_stmt|;
name|n
operator|->
name|t_dst
operator|=
name|tempport
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
condition|)
name|n
operator|->
name|t_seq
operator|=
name|n
operator|->
name|t_ackno
expr_stmt|;
else|else
block|{
name|n
operator|->
name|t_ackno
operator|=
name|htonl
argument_list|(
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
operator|(
name|u_long
operator|)
name|n
operator|->
name|t_seq
argument_list|)
operator|+
name|tlen
operator|-
name|hlen
operator|+
operator|(
name|n
operator|->
name|t_flags
operator|&
name|T_SYN
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|t_seq
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|->
name|t_flags
operator|=
operator|(
name|n
operator|->
name|t_flags
operator|&
name|T_ACK
operator|)
condition|?
name|T_RST
else|:
name|T_RST
operator|+
name|T_ACK
expr_stmt|;
name|n
operator|->
name|t_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|TCPSIZE
argument_list|)
expr_stmt|;
name|n
operator|->
name|t_off
operator|=
name|TCPSIZE
operator|>>
name|TCP_OFFSHIFT
expr_stmt|;
name|n
operator|->
name|t_sum
operator|=
name|in_cksum
argument_list|(
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|NOPCB_IPSEND
argument_list|(
name|mp
argument_list|,
name|TCPSIZE
argument_list|,
name|FALSE
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|t_badsegs
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Entry into TCP finite state machine  */
end_comment

begin_expr_stmt
name|action
argument_list|(
name|wp
argument_list|)
specifier|register
expr|struct
name|work
operator|*
name|wp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|act
operator|,
name|newstate
expr_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|tp
operator|=
name|wp
operator|->
name|w_tcb
expr_stmt|;
name|so
operator|=
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
expr_stmt|;
name|ACTION
argument_list|(
name|tp
argument_list|,
name|so
argument_list|,
name|wp
argument_list|,
name|wp
operator|->
name|w_type
argument_list|,
name|wp
operator|->
name|w_dat
argument_list|,
name|act
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstate
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|tcpdebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write a record in the tcp debugging log  */
end_comment

begin_expr_stmt
name|tcp_debug
argument_list|(
name|tp
argument_list|,
name|wp
argument_list|,
name|newstate
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|work
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|newstate
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|t_debug
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|TCPDEBUG
if|if
condition|(
name|tcprint
condition|)
block|{
comment|/* 	 * Print debugging info directly on the console (use this for  	 * intial testing only). 	 */
name|printf
argument_list|(
literal|"TCP(%x) %s X %s"
argument_list|,
name|tp
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|tcpinputs
index|[
name|wp
operator|->
name|w_type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|w_type
operator|==
name|ISTIMER
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|tcptimers
index|[
name|wp
operator|->
name|w_stype
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" --> %s"
argument_list|,
name|tcpstates
index|[
operator|(
name|newstate
operator|>
literal|0
operator|)
condition|?
name|newstate
else|:
name|tp
operator|->
name|t_state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstate
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|" (FAILED)\n"
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Get an mbuf to write the debugging record into.  If we don't already      * have one, allocate a new one.      */
if|if
condition|(
operator|(
name|m
operator|=
name|tcpdebuf
operator|)
operator|==
name|NULL
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|tcpdebuf
operator|=
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If possible, use a cluster so that we need to wake up the 	 * raw listener less often and reduce likelihood he misses 	 * some information. 	 */
name|MCLGET
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|m
operator|->
name|m_off
operator|=
operator|(
operator|(
name|int
operator|)
name|c
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
name|m
operator|)
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|TCDBLEN
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|TDBLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
name|dp
operator|=
operator|(
expr|struct
name|t_debug
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|)
expr_stmt|;
comment|/*      * Set up the debugging record.      */
name|dp
operator|->
name|t_iptime
operator|=
name|iptime
argument_list|()
expr_stmt|;
name|dp
operator|->
name|t_input
operator|=
name|wp
operator|->
name|w_type
expr_stmt|;
name|dp
operator|->
name|t_timer
operator|=
name|wp
operator|->
name|w_stype
expr_stmt|;
name|dp
operator|->
name|t_newstate
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|t_oldstate
operator|=
name|tp
operator|->
name|t_state
expr_stmt|;
name|dp
operator|->
name|t_tcb
operator|=
operator|(
operator|*
name|tp
operator|)
expr_stmt|;
comment|/* structure copy */
block|}
else|else
name|dp
operator|->
name|t_oldstate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|w_type
operator|==
name|INRECV
condition|)
block|{
specifier|register
name|struct
name|th
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|wp
operator|->
name|w_dat
expr_stmt|;
name|dp
operator|->
name|t_hdr
operator|=
operator|(
operator|*
name|n
operator|)
expr_stmt|;
comment|/* structure copy */
block|}
comment|/*      * If the mbuf is full, dispatch it to a raw listener.      * Also flush if the connection we're debugging closes so that      * packet-printer/systems analyst sees final transitions.      */
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|t_debug
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|>=
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_act
operator|)
operator|)
operator|||
operator|(
name|newstate
operator|==
name|CLOSED
operator|)
condition|)
block|{
name|m
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
name|tcpdebuglog
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tcpdebuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

end_unit

