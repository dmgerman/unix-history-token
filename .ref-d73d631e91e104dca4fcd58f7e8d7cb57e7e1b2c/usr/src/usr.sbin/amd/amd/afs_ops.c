begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: afs_ops.c,v 5.2 90/06/23 22:19:14 jsp Rel $  *  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * %sccs.include.redist.c%  *  *	@(#)afs_ops.c	5.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"am.h"
end_include

begin_define
define|#
directive|define
name|NFS
end_define

begin_define
define|#
directive|define
name|NFSCLIENT
end_define

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NFS_3
end_ifdef

begin_typedef
typedef|typedef
name|nfs_fh
name|fhandle_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_3 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NFS_HDR
end_ifdef

begin_include
include|#
directive|include
include|NFS_HDR
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_HDR */
end_comment

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_comment
comment|/*  * Automount file system  */
end_comment

begin_comment
comment|/*  * Interval between forced retries of a mount.  */
end_comment

begin_define
define|#
directive|define
name|RETRY_INTERVAL
value|2
end_define

begin_comment
comment|/*  * AFS needs nothing in particular.  */
end_comment

begin_function
specifier|static
name|int
name|afs_match
parameter_list|(
name|fo
parameter_list|)
name|am_opts
modifier|*
name|fo
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|fo
operator|->
name|opt_rfs
decl_stmt|;
if|if
condition|(
operator|!
name|fo
operator|->
name|opt_rfs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"auto: no mount point named (rfs:=)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|fo
operator|->
name|opt_fs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"auto: no map named (fs:=)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Swap round fs:= and rfs:= options 	 * ... historical (jsp) 	 */
name|fo
operator|->
name|opt_rfs
operator|=
name|fo
operator|->
name|opt_fs
expr_stmt|;
name|fo
operator|->
name|opt_fs
operator|=
name|p
expr_stmt|;
comment|/* 	 * fs_mtab turns out to be the name of the mount map 	 */
name|fo
operator|->
name|fs_mtab
operator|=
name|strealloc
argument_list|(
name|fo
operator|->
name|fs_mtab
argument_list|,
name|fo
operator|->
name|opt_rfs
condition|?
name|fo
operator|->
name|opt_rfs
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|afs_init
parameter_list|(
name|mf
parameter_list|)
name|mntfs
modifier|*
name|mf
decl_stmt|;
block|{
comment|/* 	 * Fill in attribute fields 	 */
name|mf
operator|->
name|mf_fattr
operator|.
name|type
operator|=
name|NFDIR
expr_stmt|;
name|mf
operator|->
name|mf_fattr
operator|.
name|mode
operator|=
name|NFSMODE_DIR
operator||
literal|0555
expr_stmt|;
name|mf
operator|->
name|mf_fattr
operator|.
name|nlink
operator|=
literal|2
expr_stmt|;
name|mf
operator|->
name|mf_fattr
operator|.
name|size
operator|=
literal|512
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Mount the an automounter directory.  * The automounter is connected into the system  * as a user-level NFS server.  mount_afs constructs  * the necessary NFS parameters to be given to the  * kernel so that it will talk back to us.  */
end_comment

begin_function
specifier|static
name|int
name|mount_afs
parameter_list|(
name|dir
parameter_list|,
name|fs_name
parameter_list|,
name|opts
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|fs_name
decl_stmt|;
name|char
modifier|*
name|opts
decl_stmt|;
block|{
name|struct
name|nfs_args
name|nfs_args
decl_stmt|;
name|struct
name|mntent
name|mnt
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|extern
name|nfs_fh
modifier|*
name|root_fh
parameter_list|()
function_decl|;
name|nfs_fh
modifier|*
name|fhp
decl_stmt|;
name|char
name|fs_hostname
index|[
name|MAXHOSTNAMELEN
operator|+
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|MTYPE_TYPE
name|type
init|=
name|MOUNT_TYPE_NFS
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|nfs_args
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoid */
name|mnt
operator|.
name|mnt_dir
operator|=
name|dir
expr_stmt|;
name|mnt
operator|.
name|mnt_fsname
operator|=
name|fs_name
expr_stmt|;
name|mnt
operator|.
name|mnt_type
operator|=
name|MNTTYPE_AUTO
expr_stmt|;
name|mnt
operator|.
name|mnt_opts
operator|=
name|opts
expr_stmt|;
name|mnt
operator|.
name|mnt_freq
operator|=
literal|0
expr_stmt|;
name|mnt
operator|.
name|mnt_passno
operator|=
literal|0
expr_stmt|;
name|retry
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"retry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|<=
literal|0
condition|)
name|retry
operator|=
literal|2
expr_stmt|;
comment|/* XXX */
comment|/* 	 * get fhandle of remote path for automount point 	 */
name|fhp
operator|=
name|root_fh
argument_list|(
name|fs_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fhp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Can't find root file handle for %s"
argument_list|,
name|fs_name
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|NFS_FH_DREF
argument_list|(
name|nfs_args
operator|.
name|fh
argument_list|,
operator|(
name|NFS_FH_TYPE
operator|)
name|fhp
argument_list|)
expr_stmt|;
comment|/* 	 * Create sockaddr to point to the local machine.  127.0.0.1 	 * is not used since that will not work in HP-UX clusters and 	 * this is no more expensive. 	 */
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|myipaddr
expr_stmt|;
if|if
condition|(
name|port
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"port"
argument_list|)
condition|)
block|{
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"no port number specified for %s"
argument_list|,
name|fs_name
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * set mount args 	 */
name|NFS_SA_DREF
argument_list|(
name|nfs_args
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
comment|/* 	 * Make a ``hostname'' string for the kernel 	 */
ifndef|#
directive|ifndef
name|HOSTNAMESZ
define|#
directive|define
name|SHORT_MOUNT_NAME
endif|#
directive|endif
comment|/* HOSTNAMESZ */
ifdef|#
directive|ifdef
name|SHORT_MOUNT_NAME
name|sprintf
argument_list|(
name|fs_hostname
argument_list|,
literal|"amd:%d"
argument_list|,
name|mypid
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|fs_hostname
argument_list|,
literal|"pid%d@%s:%s"
argument_list|,
name|mypid
argument_list|,
name|hostname
argument_list|,
name|dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHORT_MOUNT_NAME */
name|nfs_args
operator|.
name|hostname
operator|=
name|fs_hostname
expr_stmt|;
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_HOSTNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|HOSTNAMESZ
comment|/* 	 * Most kernels have a name length restriction. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|fs_hostname
argument_list|)
operator|>=
name|HOSTNAMESZ
condition|)
name|strcpy
argument_list|(
name|fs_hostname
operator|+
name|HOSTNAMESZ
operator|-
literal|3
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HOSTNAMESZ */
comment|/* 	 * Parse a subset of the standard nfs options.  The 	 * others are probably irrelevant for this application 	 */
if|if
condition|(
name|nfs_args
operator|.
name|timeo
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"timeo"
argument_list|)
condition|)
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_TIMEO
expr_stmt|;
if|if
condition|(
name|nfs_args
operator|.
name|retrans
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"retrans"
argument_list|)
condition|)
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_RETRANS
expr_stmt|;
ifdef|#
directive|ifdef
name|NFSMNT_BIODS
if|if
condition|(
name|nfs_args
operator|.
name|biods
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"biods"
argument_list|)
condition|)
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_BIODS
expr_stmt|;
endif|#
directive|endif
comment|/* NFSMNT_BIODS */
if|#
directive|if
name|defined
argument_list|(
name|NFSMNT_ACREGMIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|NFSMNT_ACREGMAX
argument_list|)
comment|/* 	 * Don't cache attributes - they are changing under 	 * the kernel's feet... 	 */
name|nfs_args
operator|.
name|acregmin
operator|=
name|nfs_args
operator|.
name|acregmax
operator|=
literal|1
expr_stmt|;
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_ACREGMIN
operator||
name|NFSMNT_ACREGMAX
expr_stmt|;
endif|#
directive|endif
comment|/* defined(NFSMNT_ACREGMIN)&& defined(NFSMNT_ACREGMAX) */
comment|/* 	 * These two are constructed internally by the calling routine 	 */
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTOPT_SOFT
argument_list|)
operator|!=
name|NULL
condition|)
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_SOFT
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTOPT_INTR
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTOPT_INTR
argument_list|)
operator|!=
name|NULL
condition|)
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_INT
expr_stmt|;
endif|#
directive|endif
comment|/* MNTOPT_INTR */
name|flags
operator|=
name|compute_mount_flags
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ULTRIX_HACK
name|nfs_args
operator|.
name|gfs_flags
operator|=
name|flags
expr_stmt|;
name|flags
operator|&=
name|M_RDONLY
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|M_RDONLY
condition|)
name|nfs_args
operator|.
name|flags
operator||=
name|NFSMNT_RONLY
expr_stmt|;
endif|#
directive|endif
comment|/* ULTRIX_HACK */
return|return
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|flags
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_args
argument_list|,
name|retry
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|afs_mount
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/* 	 * There are two cases to consider... 	 */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_parent
condition|)
block|{
comment|/* 		 * If this am_node has a parent which is not the root node, in 		 * which case we are supplying a pseudo-directory, in which 		 * case no action is needed.  Pseudo-directories are used to 		 * provide some structure to the automounted directories instead 		 * of putting them all in the top-level automount directory. 		 */
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_fattr
operator|.
name|nlink
operator|++
expr_stmt|;
comment|/* 		 * Info field of . means use parent's info field. 		 */
if|if
condition|(
name|mf
operator|->
name|mf_info
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|mf
operator|->
name|mf_info
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|mf
operator|->
name|mf_info
operator|=
name|strealloc
argument_list|(
name|mf
operator|->
name|mf_info
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/* 		 * Compute prefix: 		 * 		 * If there is an option prefix then use that else 		 * If the parent had a prefix then use that with name 		 *	of this node appended else 		 * Use the name of this node. 		 * 		 * That means if you want no prefix you must say so 		 * in the map. 		 */
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_pref
condition|)
block|{
comment|/* 			 * the prefix specified as an option 			 */
name|mp
operator|->
name|am_pref
operator|=
name|strdup
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_pref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * else the parent's prefix 			 * followed by the name 			 * followed by / 			 */
name|char
modifier|*
name|ppref
init|=
name|mp
operator|->
name|am_parent
operator|->
name|am_pref
decl_stmt|;
if|if
condition|(
name|ppref
operator|==
literal|0
condition|)
name|ppref
operator|=
literal|""
expr_stmt|;
name|mp
operator|->
name|am_pref
operator|=
name|str3cat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ppref
argument_list|,
name|mp
operator|->
name|am_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Otherwise, we are mounting the automounter.  In which case 		 * we need to make sure the mount directory exists, construct 		 * the mount options and call the mount_afs routine. 		 */
name|struct
name|stat
name|stb
decl_stmt|;
name|char
name|opts
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 		 * Top-level mount - so make 		 * sure the mount point exists 		 * and is a directory. 		 */
name|error
operator|=
name|mkdirs
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
literal|0555
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|mp
operator|->
name|am_flags
operator||=
name|AMF_MKPATH
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"%s is not a directory"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
name|ENOTDIR
return|;
block|}
name|mf
operator|->
name|mf_mount
operator|=
name|strealloc
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
comment|/* 		 * Construct some mount options 		 */
name|sprintf
argument_list|(
name|opts
argument_list|,
ifdef|#
directive|ifdef
name|MNTOPT_INTR
literal|"%s,%s,%s=%d,%s=%d,%s=%d,%sdirect"
argument_list|,
name|MNTOPT_INTR
argument_list|,
else|#
directive|else
literal|"%s,%s=%d,%s=%d,%s=%d,%sdirect"
argument_list|,
endif|#
directive|endif
comment|/* MNTOPT_INTR */
ifdef|#
directive|ifdef
name|AUTOMOUNT_RO
name|MNTOPT_RO
argument_list|,
comment|/* You don't really want this... */
else|#
directive|else
literal|"rw"
argument_list|,
endif|#
directive|endif
comment|/* AUTOMOUNT_RO */
literal|"port"
argument_list|,
name|nfs_port
argument_list|,
literal|"timeo"
argument_list|,
name|afs_timeo
argument_list|,
literal|"retrans"
argument_list|,
name|afs_retrans
argument_list|,
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|afs_ops
condition|?
literal|"in"
else|:
literal|""
argument_list|)
expr_stmt|;
name|error
operator|=
name|mount_afs
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_name
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"mount_afs: %m"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|mp
operator|->
name|am_name
operator|=
name|pid_fsname
expr_stmt|;
block|}
comment|/* 	 * Build a new map cache for this node, or re-use 	 * an existing cache for the same map. 	 */
block|{
name|char
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_cache
condition|)
name|cache
operator|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_cache
expr_stmt|;
else|else
name|cache
operator|=
literal|"none"
expr_stmt|;
name|mf
operator|->
name|mf_private
operator|=
operator|(
name|voidp
operator|)
name|mapc_find
argument_list|(
name|mf
operator|->
name|mf_info
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_prfree
operator|=
name|mapc_free
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount an automount node  */
end_comment

begin_function
specifier|static
name|int
name|afs_umount
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * If this is a pseudo-directory then just adjust the link count 	 * in the parent, otherwise call the generic unmount routine 	 */
if|if
condition|(
operator|!
name|mp
operator|->
name|am_parent
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_parent
condition|)
block|{
operator|--
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_fattr
operator|.
name|nlink
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|stb
decl_stmt|;
name|again
label|:
comment|/* 		 * The lstat is needed if this mount is type=direct. 		 * When that happens, the kernel cache gets confused 		 * between the underlying type (dir) and the mounted 		 * type (link) and so needs to be re-synced before 		 * the unmount.  This is all because the unmount system 		 * call follows links and so can't actually unmount 		 * a link (stupid!).  It was noted that doing an ls -ld 		 * of the mount point to see why things were not working 		 * actually fixed the problem - so simulate an ls -ld here. 		 */
if|if
condition|(
name|lstat
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"lstat(%s): %m"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|error
operator|=
name|UMOUNT_FS
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"afs_unmount retrying %s in 1s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount an automount node  */
end_comment

begin_function
specifier|static
name|void
name|afs_umounted
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
comment|/* 	 * If this is a pseudo-directory then just adjust the link count 	 * in the parent, otherwise call the generic unmount routine 	 */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_parent
condition|)
operator|--
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_fattr
operator|.
name|nlink
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mounting a file system may take a significant period of time.  The  * problem is that if this is done in the main process thread then  * the entire automounter could be blocked, possibly hanging lots of  * processes on the system.  Instead we use a continuation scheme to  * allow mounts to be attempted in a sub-process.  When the sub-process  * exits we pick up the exit status (by convention a UN*X error number)  * and continue in a notifier.  The notifier gets handed a data structure  * and can then determine whether the mount was successful or not.  If  * not, it updates the data structure and tries again until there are no  * more ways to try the mount, or some other permanent error occurs.  * In the mean time no RPC reply is sent, even after the mount is succesful.  * We rely on the RPC retry mechanism to resend the lookup request which  * can then be handled.  */
end_comment

begin_struct
struct|struct
name|continuation
block|{
name|char
modifier|*
modifier|*
name|ivec
decl_stmt|;
comment|/* Current mount info */
name|am_node
modifier|*
name|mp
decl_stmt|;
comment|/* Node we are trying to mount */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Map key */
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Info string */
name|char
modifier|*
modifier|*
name|xivec
decl_stmt|;
comment|/* Saved strsplit vector */
name|char
modifier|*
name|opts
decl_stmt|;
comment|/* Mount options */
name|am_opts
name|fs_opts
decl_stmt|;
comment|/* Filesystem options */
name|char
modifier|*
name|def_opts
decl_stmt|;
comment|/* Default options */
name|int
name|retry
decl_stmt|;
comment|/* Try again? */
name|int
name|tried
decl_stmt|;
comment|/* Have we tried any yet? */
name|time_t
name|start
decl_stmt|;
comment|/* Time we started this mount */
name|int
name|callout
decl_stmt|;
comment|/* Callout identifier */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Discard an old continuation  */
end_comment

begin_function
specifier|static
name|void
name|free_continuation
parameter_list|(
name|cp
parameter_list|)
name|struct
name|continuation
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|cp
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|cp
operator|->
name|xivec
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|cp
operator|->
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|cp
operator|->
name|opts
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|cp
operator|->
name|def_opts
argument_list|)
expr_stmt|;
name|free_opts
argument_list|(
operator|&
name|cp
operator|->
name|fs_opts
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|afs_bgmount
name|P
argument_list|(
operator|(
expr|struct
name|continuation
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Discard the underlying mount point and replace  * with a reference to an error filesystem.  */
end_comment

begin_function
specifier|static
name|void
name|assign_error_mntfs
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
if|if
condition|(
name|mp
operator|->
name|am_error
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Save the old error code 		 */
name|int
name|error
init|=
name|mp
operator|->
name|am_error
decl_stmt|;
comment|/* 		 * Discard the old filesystem 		 */
name|free_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate a new error reference 		 */
name|mp
operator|->
name|am_mnt
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
comment|/* 		 * Put back the error code 		 */
name|mp
operator|->
name|am_mnt
operator|->
name|mf_error
operator|=
name|error
expr_stmt|;
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
comment|/* 		 * Zero the error in the mount point 		 */
name|mp
operator|->
name|am_error
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The continuation function.  This is called by  * the task notifier when a background mount attempt  * completes.  */
end_comment

begin_function
specifier|static
name|void
name|afs_cont
parameter_list|(
name|rc
parameter_list|,
name|term
parameter_list|,
name|closure
parameter_list|)
name|int
name|rc
decl_stmt|;
name|int
name|term
decl_stmt|;
name|voidp
name|closure
decl_stmt|;
block|{
name|struct
name|continuation
modifier|*
name|cp
init|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|closure
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/* 	 * Definitely not trying to mount at the moment 	 */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MOUNTING
expr_stmt|;
comment|/* 	 * While we are mounting - try to avoid race conditions 	 */
name|new_ttl
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Wakeup anything waiting for this mount 	 */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
comment|/* 	 * Check for termination signal or exit status... 	 */
if|if
condition|(
name|rc
operator|||
name|term
condition|)
block|{
if|if
condition|(
name|term
condition|)
block|{
comment|/* 			 * Not sure what to do for an error code. 			 */
name|mf
operator|->
name|mf_error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX ? */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount for %s got signal %d"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Check for exit status... 			 */
name|mf
operator|->
name|mf_error
operator|=
name|rc
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|errno
operator|=
name|rc
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: mount (afs_cont): %m"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we get here then that attempt didn't work, so 		 * move the info vector pointer along by one and 		 * call the background mount routine again 		 */
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
name|cp
operator|->
name|ivec
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|afs_bgmount
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assign_error_mntfs
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The mount worked. 		 */
name|am_mounted
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retry a mount  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|afs_retry
parameter_list|(
name|rc
parameter_list|,
name|term
parameter_list|,
name|closure
parameter_list|)
name|int
name|rc
decl_stmt|;
name|int
name|term
decl_stmt|;
name|voidp
name|closure
decl_stmt|;
block|{
name|struct
name|continuation
modifier|*
name|cp
init|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Commencing retry for mount of %s"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|cp
operator|->
name|start
operator|+
name|ALLOWED_MOUNT_TIME
operator|)
operator|<
name|clocktime
argument_list|()
condition|)
block|{
comment|/* 		 * The entire mount has timed out. 		 * Set the error code and skip past 		 * all the info vectors so that 		 * afs_bgmount will not have any more 		 * ways to try the mount, so causing 		 * an error. 		 */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"mount of \"%s\" has timed out"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
name|new_ttl
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|->
name|ivec
condition|)
name|cp
operator|->
name|ivec
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|afs_bgmount
argument_list|(
name|cp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to mount a file system.  Can be called  * directly or in a sub-process by run_task  */
end_comment

begin_function
specifier|static
name|int
name|try_mount
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
comment|/* 	 * Mount it! 	 */
name|int
name|error
decl_stmt|;
name|error
operator|=
name|mount_node
argument_list|(
name|mp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
name|dlog
argument_list|(
literal|"afs call to mount_node failed: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Pick a file system to try mounting and  * do that in the background if necessary  * For each location: 	if it is new -defaults then 		extract and process 		continue; 	fi 	if it is a cut then 		if a location has been tried then 			break; 		fi 		continue; 	fi 	parse mount location 	discard previous mount location if required 	find matching mounted filesystem 	if not applicable then 		this_error = No such file or directory 		continue 	fi 	if the filesystem failed to be mounted then 		this_error = error from filesystem 	elif the filesystem is mounting or unmounting then 		this_error = -1 	elif the fileserver is down then 		this_error = -1 	elif the filesystem is already mounted 		this_error = 0 		break 	fi 	if no error on this mount then 		this_error = initialise mount point 	fi 	if no error on this mount and mount is delayed then 		this_error = -1 	fi 	if this_error< 0 then 		retry = true 	fi 	if no error on this mount then 		make mount point if required 	fi 	if no error on this mount then 		if mount in background then 			run mount in background 			return -1 		else 			this_error = mount in foreground 		fi 	fi 	if an error occured on this mount then 		update stats 		save error in mount point 	fi endfor  */
end_comment

begin_function
specifier|static
name|int
name|afs_bgmount
parameter_list|(
name|cp
parameter_list|,
name|mpe
parameter_list|)
name|struct
name|continuation
modifier|*
name|cp
decl_stmt|;
name|int
name|mpe
decl_stmt|;
block|{
name|mntfs
modifier|*
name|mf
init|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/* Current mntfs */
name|mntfs
modifier|*
name|mf_retry
init|=
literal|0
decl_stmt|;
comment|/* First mntfs which needed retrying */
name|int
name|this_error
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Per-mount error */
name|int
name|hard_error
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|mp_error
init|=
name|mpe
decl_stmt|;
comment|/* 	 * Try to mount each location. 	 * At the end: 	 * hard_error == 0 indicates something was mounted. 	 * hard_error> 0 indicates everything failed with a hard error 	 * hard_error< 0 indicates nothing could be mounted now 	 */
for|for
control|(
init|;
name|this_error
operator|&&
operator|*
name|cp
operator|->
name|ivec
condition|;
name|cp
operator|->
name|ivec
operator|++
control|)
block|{
name|am_ops
modifier|*
name|p
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|cp
operator|->
name|mp
decl_stmt|;
name|char
modifier|*
name|link_dir
decl_stmt|;
name|int
name|dont_retry
decl_stmt|;
if|if
condition|(
name|hard_error
operator|<
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cp
operator|->
name|ivec
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * Pick up new defaults 			 */
if|if
condition|(
name|cp
operator|->
name|opts
operator|&&
operator|*
name|cp
operator|->
name|opts
condition|)
name|cp
operator|->
name|def_opts
operator|=
name|str3cat
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
name|cp
operator|->
name|opts
argument_list|,
literal|";"
argument_list|,
operator|*
name|cp
operator|->
name|ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|->
name|def_opts
operator|=
name|strealloc
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Setting def_opts to \"%s\""
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
continue|continue;
block|}
comment|/* 		 * If a mount has been attempted, and we find 		 * a cut then don't try any more locations. 		 */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|"||"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|tried
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Cut: not trying any more locations for %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SUNOS4_COMPAT
comment|/* 		 * By default, you only get this bit on SunOS4. 		 * If you want this anyway, then define SUNOS4_COMPAT 		 * in the relevant "os-blah.h" file. 		 * 		 * We make the observation that if the local key line contains 		 * no '=' signs then either it is sick, or it is a SunOS4-style 		 * "host:fs[:link]" line.  In the latter case the am_opts field 		 * is also assumed to be in old-style, so you can't mix& match. 		 * You can use ${} expansions for the fs and link bits though... 		 * 		 * Actually, this doesn't really cover all the possibilities for 		 * the latest SunOS automounter and it is debatable whether there 		 * is any point bothering. 		 */
if|if
condition|(
name|strchr
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|'='
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
name|sunos4_match
argument_list|(
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|cp
operator|->
name|key
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* SUNOS4_COMPAT */
name|p
operator|=
name|ops_match
argument_list|(
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|cp
operator|->
name|key
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/* 		 * Find a mounted filesystem for this node. 		 */
name|mp
operator|->
name|am_mnt
operator|=
name|mf
operator|=
name|realloc_mntfs
argument_list|(
name|mf
argument_list|,
name|p
argument_list|,
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
argument_list|,
name|cp
operator|->
name|opts
argument_list|)
expr_stmt|;
name|p
operator|=
name|mf
operator|->
name|mf_ops
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Got a hit with %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 		 * Note whether this is a real mount attempt 		 */
if|if
condition|(
name|p
operator|==
operator|&
name|efs_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Map entry %s for %s failed to match"
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
operator|<=
literal|0
condition|)
name|this_error
operator|=
name|ENOENT
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Trying mount of %s on %s fstype %s"
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|tried
operator|=
name|TRUE
expr_stmt|;
block|}
name|this_error
operator|=
literal|0
expr_stmt|;
name|dont_retry
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
block|{
name|free
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_link
operator|=
literal|0
expr_stmt|;
block|}
name|link_dir
operator|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_sublink
expr_stmt|;
if|if
condition|(
name|link_dir
operator|&&
operator|*
name|link_dir
condition|)
block|{
if|if
condition|(
operator|*
name|link_dir
operator|==
literal|'/'
condition|)
block|{
name|mp
operator|->
name|am_link
operator|=
name|strdup
argument_list|(
name|link_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|am_link
operator|=
name|str3cat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|mf
operator|->
name|mf_fo
operator|->
name|opt_fs
argument_list|,
literal|"/"
argument_list|,
name|link_dir
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|>
literal|0
condition|)
block|{
name|this_error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
operator|(
name|MFF_MOUNTING
operator||
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
comment|/* 			 * Still mounting - retry later 			 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Duplicate pending mount fstype %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/* 			 * Would just mount from the same place 			 * as a hung mount - so give up 			 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"%s is already hung - giving up"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|mp_error
operator|=
name|EWOULDBLOCK
expr_stmt|;
name|dont_retry
operator|=
name|TRUE
expr_stmt|;
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"duplicate mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
literal|0
expr_stmt|;
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Will usually need to play around with the mount nodes 		 * file attribute structure.  This must be done here. 		 */
if|if
condition|(
operator|!
name|this_error
condition|)
block|{
comment|/* 			 * Fill in attribute fields 			 */
name|mf
operator|->
name|mf_fattr
operator|.
name|type
operator|=
name|NFLNK
expr_stmt|;
name|mf
operator|->
name|mf_fattr
operator|.
name|mode
operator|=
name|NFSMODE_LNK
operator||
literal|0777
expr_stmt|;
name|mf
operator|->
name|mf_fattr
operator|.
name|nlink
operator|=
literal|1
expr_stmt|;
name|mf
operator|->
name|mf_fattr
operator|.
name|size
operator|=
name|MAXPATHLEN
operator|/
literal|4
expr_stmt|;
comment|/* Conservative */
name|mf
operator|->
name|mf_fattr
operator|.
name|fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fs_init
condition|)
name|this_error
operator|=
call|(
modifier|*
name|p
operator|->
name|fs_init
call|)
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_error
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
condition|)
block|{
comment|/* 			 * If there is a delay timer on the mount 			 * then don't try to mount if the timer 			 * has not expired. 			 */
name|int
name|i
init|=
name|atoi
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|cp
operator|->
name|start
operator|+
name|i
operator|)
operator|<
name|clocktime
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Mount of %s delayed by %ds"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_error
operator|<
literal|0
operator|&&
operator|!
name|dont_retry
condition|)
block|{
if|if
condition|(
operator|!
name|mf_retry
condition|)
name|mf_retry
operator|=
name|dup_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_error
condition|)
block|{
comment|/* 			 * If the directory is not yet made and 			 * it needs to be made, then make it! 			 */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MKMNT
operator|)
operator|&&
name|p
operator|->
name|fs_flags
operator|&
name|FS_MKMNT
condition|)
block|{
name|this_error
operator|=
name|mkdirs
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|,
literal|0555
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_error
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MKMNT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|this_error
condition|)
if|if
condition|(
name|p
operator|->
name|fs_flags
operator|&
name|FS_MBACKGROUND
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MOUNTING
expr_stmt|;
comment|/*XXX*/
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"backgrounding mount of \"%s\""
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
block|{
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
block|}
name|run_task
argument_list|(
name|try_mount
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|,
name|afs_cont
argument_list|,
operator|(
name|voidp
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf_retry
condition|)
name|free_mntfs
argument_list|(
name|mf_retry
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"foreground mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
name|try_mount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this_error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|this_error
operator|>
literal|0
condition|)
block|{
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
if|if
condition|(
name|mf
operator|!=
name|mf_retry
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|this_error
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
block|}
comment|/* 			 * Wakeup anything waiting for this mount 			 */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_error
operator|&&
name|cp
operator|->
name|retry
condition|)
block|{
name|free_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|mf
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
operator|=
name|mf_retry
expr_stmt|;
comment|/* 		 * Not retrying again (so far) 		 */
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|tried
operator|=
name|FALSE
expr_stmt|;
comment|/* 		 * Start at the beginning. 		 * Rewind the location vector and 		 * reset the default options. 		 */
name|cp
operator|->
name|ivec
operator|=
name|cp
operator|->
name|xivec
expr_stmt|;
name|cp
operator|->
name|def_opts
operator|=
name|strealloc
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
name|cp
operator|->
name|opts
argument_list|)
expr_stmt|;
comment|/* 		 * Arrange that afs_bgmount is called 		 * after anything else happens. 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Arranging to retry mount of %s"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|sched_task
argument_list|(
name|afs_retry
argument_list|,
operator|(
name|voidp
operator|)
name|cp
argument_list|,
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
name|timeout
argument_list|(
name|RETRY_INTERVAL
argument_list|,
name|wakeup
argument_list|,
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
operator|+
name|RETRY_INTERVAL
expr_stmt|;
comment|/* 		 * Not done yet - so don't return anything 		 */
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Discard handle on duff filesystem. 	 * This should never happen since it 	 * should be caught by the case above. 	 */
if|if
condition|(
name|mf_retry
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"discarding a retry mntfs for %s"
argument_list|,
name|mf_retry
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|free_mntfs
argument_list|(
name|mf_retry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hard_error
operator|<
literal|0
operator|||
operator|!
name|this_error
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
comment|/* 	 * If we get here, then either the mount succeeded or 	 * there is no more mount information available. 	 */
if|if
condition|(
name|hard_error
operator|<
literal|0
operator|&&
name|mp_error
condition|)
name|hard_error
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_error
operator|=
name|mp_error
expr_stmt|;
if|if
condition|(
name|hard_error
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Set a small(ish) timeout on an error node if 		 * the error was not a time out. 		 */
switch|switch
condition|(
name|hard_error
condition|)
block|{
case|case
name|ETIMEDOUT
case|:
case|case
name|EWOULDBLOCK
case|:
name|cp
operator|->
name|mp
operator|->
name|am_timeo
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|cp
operator|->
name|mp
operator|->
name|am_timeo
operator|=
literal|17
expr_stmt|;
break|break;
block|}
name|cp
operator|->
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Make sure that the error value in the mntfs has a 	 * reasonable value. 	 */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|hard_error
expr_stmt|;
if|if
condition|(
name|hard_error
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
comment|/* 	 * In any case we don't need the continuation any more 	 */
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
name|hard_error
return|;
block|}
end_function

begin_comment
comment|/*  * Automount interface to RPC lookup routine  */
end_comment

begin_function
specifier|static
name|am_node
modifier|*
name|afs_lookuppn
parameter_list|(
name|mp
parameter_list|,
name|fname
parameter_list|,
name|error_return
parameter_list|,
name|op
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
modifier|*
name|error_return
decl_stmt|;
name|int
name|op
decl_stmt|;
block|{
define|#
directive|define
name|ereturn
parameter_list|(
name|x
parameter_list|)
value|{ *error_return = x; return 0; }
comment|/* 	 * Find the corresponding entry and return 	 * the file handle for it. 	 */
name|am_node
modifier|*
name|ap
decl_stmt|,
modifier|*
name|new_mp
decl_stmt|,
modifier|*
name|ap_hung
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Mount info - where to get the file system */
name|char
modifier|*
modifier|*
name|ivec
decl_stmt|,
modifier|*
modifier|*
name|xivec
decl_stmt|;
comment|/* Split version of info */
name|char
modifier|*
name|opts
decl_stmt|;
comment|/* Mount options */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Error so far */
name|char
name|path_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* General path name buffer */
name|char
modifier|*
name|pfname
decl_stmt|;
comment|/* Path for database lookup */
name|struct
name|continuation
modifier|*
name|cp
decl_stmt|;
comment|/* Continuation structure if we need to mount */
name|int
name|in_progress
init|=
literal|0
decl_stmt|;
comment|/* # of (un)mount in progress */
name|char
modifier|*
name|dflts
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"in afs_lookuppn"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * If the server is shutting down 	 * then don't return information 	 * about the mount point. 	 */
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"%s/%s mount ignored - going down"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Handle special case of "." and ".." 	 */
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|mp
return|;
comment|/* "." is the current node */
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|fname
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|".. in %s gives %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|mp
operator|->
name|am_parent
return|;
comment|/* ".." is the parent node */
block|}
name|ereturn
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for valid key name. 	 * If it is invalid then pretend it doesn't exist. 	 */
if|if
condition|(
operator|!
name|valid_key
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"Key \"%s\" contains a disallowed character"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Expand key name. 	 * fname is now a private copy. 	 */
name|fname
operator|=
name|expand_key
argument_list|(
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
name|ap_hung
operator|=
literal|0
operator|,
name|ap
operator|=
name|mp
operator|->
name|am_child
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|am_osib
control|)
block|{
comment|/* 		 * Otherwise search children of this node 		 */
if|if
condition|(
name|FSTREQ
argument_list|(
name|ap
operator|->
name|am_name
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|mf
operator|=
name|ap
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|am_error
condition|)
block|{
name|error
operator|=
name|ap
operator|->
name|am_error
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If the error code is undefined then it must be 			 * in progress. 			 */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
goto|goto
name|in_progrss
goto|;
comment|/* 			 * Check for a hung node 			 */
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
name|ap_hung
operator|=
name|ap
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If there was a previous error with this node 			 * then return that error code. 			 */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
block|{
name|error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
comment|/*|| (mf->mf_flags& MFF_UNMOUNTING)*/
condition|)
block|{
name|in_progrss
label|:
comment|/* 				 * If the fs is not mounted or it is unmounting then there 				 * is a background (un)mount in progress.  In this case 				 * we just drop the RPC request (return nil) and 				 * wait for a retry, by which time the (un)mount may 				 * have completed. 				 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"ignoring mount of %s in %s -- in progress"
argument_list|,
name|fname
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|in_progress
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Otherwise we have a hit: return the current mount point. 			 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"matched %s in %s"
argument_list|,
name|fname
argument_list|,
name|ap
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|ap
return|;
block|}
block|}
if|if
condition|(
name|in_progress
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Waiting while %d mount(s) in progress"
argument_list|,
name|in_progress
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If an error occured then return it. 	 */
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|dlog
argument_list|(
literal|"Returning error: %m"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If doing a delete then don't create again! 	 */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|VLOOK_DELETE
case|:
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|VLOOK_CREATE
case|:
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Unknown op to afs_lookuppn: 0x%x"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If the server is going down then just return, 	 * don't try to mount any more file systems 	 */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"not found - server going down anyway"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we get there then this is a reference to an, 	 * as yet, unknown name so we need to search the mount 	 * map for it. 	 */
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
block|{
name|sprintf
argument_list|(
name|path_name
argument_list|,
literal|"%s%s"
argument_list|,
name|mp
operator|->
name|am_pref
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pfname
operator|=
name|path_name
expr_stmt|;
block|}
else|else
block|{
name|pfname
operator|=
name|fname
expr_stmt|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"will search map info in %s to find %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Consult the oracle for some mount information. 	 * info is malloc'ed and belongs to this routine. 	 * It ends up being free'd in free_continuation(). 	 * 	 * Note that this may return -1 indicating that information 	 * is not yet available. 	 */
name|error
operator|=
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
name|pfname
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"No map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"mount info is %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Split info into an argument vector. 	 * The vector is malloc'ed and belongs to 	 * this routine.  It is free'd in free_continuation() 	 */
name|xivec
operator|=
name|ivec
operator|=
name|strsplit
argument_list|(
name|info
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/* 	 * Default error code... 	 */
if|if
condition|(
name|ap_hung
condition|)
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/* 	 * Allocate a new map 	 */
name|new_mp
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_mp
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|xivec
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_opts
condition|)
name|opts
operator|=
name|mf
operator|->
name|mf_opts
expr_stmt|;
else|else
name|opts
operator|=
literal|""
expr_stmt|;
name|opts
operator|=
name|strdup
argument_list|(
name|opts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"searching for /defaults entry"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
literal|"/defaults"
argument_list|,
operator|&
name|dflts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|dfl
decl_stmt|;
name|char
modifier|*
modifier|*
name|rvec
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"/defaults gave %s"
argument_list|,
name|dflts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|*
name|dflts
operator|==
literal|'-'
condition|)
name|dfl
operator|=
name|dflts
operator|+
literal|1
expr_stmt|;
else|else
name|dfl
operator|=
name|dflts
expr_stmt|;
comment|/* 		 * Chop the defaults up 		 */
name|rvec
operator|=
name|strsplit
argument_list|(
name|dfl
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/* 		 * Extract first value 		 */
name|dfl
operator|=
name|rvec
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * Log error if there were other values 		 */
if|if
condition|(
name|rvec
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"/defaults chopped into %s"
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"More than a single value for /defaults in %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Don't need info vector any more 		 */
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|rvec
argument_list|)
expr_stmt|;
comment|/* 		 * If there were any values at all... 		 */
if|if
condition|(
name|dfl
condition|)
block|{
comment|/* 			 * Prepend to existing defaults if they exist, 			 * otherwise just use these defaults. 			 */
if|if
condition|(
operator|*
name|opts
operator|&&
operator|*
name|dfl
condition|)
block|{
name|char
modifier|*
name|nopts
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|opts
argument_list|)
operator|+
name|strlen
argument_list|(
name|dfl
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|nopts
argument_list|,
literal|"%s;%s"
argument_list|,
name|dfl
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|=
name|nopts
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|dfl
condition|)
block|{
name|opts
operator|=
name|strealloc
argument_list|(
name|opts
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dflts
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill it in 	 */
name|init_map
argument_list|(
name|new_mp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* 	 * Put it in the table 	 */
name|insert_am
argument_list|(
name|new_mp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in some other fields, 	 * path and mount point 	 */
name|new_mp
operator|->
name|am_path
operator|=
name|str3cat
argument_list|(
name|new_mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
operator|*
name|fname
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"setting path to %s"
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Take private copy of pfname 	 */
name|pfname
operator|=
name|strdup
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
comment|/* 	 * Construct a continuation 	 */
name|cp
operator|=
name|ALLOC
argument_list|(
name|continuation
argument_list|)
expr_stmt|;
name|cp
operator|->
name|mp
operator|=
name|new_mp
expr_stmt|;
name|cp
operator|->
name|xivec
operator|=
name|xivec
expr_stmt|;
name|cp
operator|->
name|ivec
operator|=
name|ivec
expr_stmt|;
name|cp
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|cp
operator|->
name|key
operator|=
name|pfname
expr_stmt|;
name|cp
operator|->
name|opts
operator|=
name|opts
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|tried
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|start
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|cp
operator|->
name|def_opts
operator|=
name|strdup
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|fs_opts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try and mount the file system 	 * If this succeeds immediately (possible 	 * for a ufs file system) then return 	 * the attributes, otherwise just 	 * return an error. 	 */
name|error
operator|=
name|afs_bgmount
argument_list|(
name|cp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|new_mp
return|;
block|}
name|assign_error_mntfs
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ereturn
block|}
end_function

begin_comment
comment|/*  * Locate next node in sibling list which is mounted  * and is not an error node.  */
end_comment

begin_function
specifier|static
name|am_node
modifier|*
name|next_nonerror_node
parameter_list|(
name|xp
parameter_list|)
name|am_node
modifier|*
name|xp
decl_stmt|;
block|{
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/* 	 * Bug report (7/12/89) from Rein Tollevik<rein@ifi.uio.no> 	 * Fixes a race condition when mounting direct automounts. 	 * Also fixes a problem when doing a readdir on a directory 	 * containing hung automounts. 	 */
while|while
condition|(
name|xp
operator|&&
operator|(
operator|!
operator|(
name|mf
operator|=
name|xp
operator|->
name|am_mnt
operator|)
operator|||
comment|/* No mounted filesystem */
name|mf
operator|->
name|mf_error
operator|!=
literal|0
operator|||
comment|/* There was a mntfs error */
name|xp
operator|->
name|am_error
operator|!=
literal|0
operator|||
comment|/* There was a mount error */
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|||
comment|/* The fs is not mounted */
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|)
comment|/* The fs may be down */
condition|)
name|xp
operator|=
name|xp
operator|->
name|am_osib
expr_stmt|;
return|return
name|xp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|afs_readdir
parameter_list|(
name|mp
parameter_list|,
name|cookie
parameter_list|,
name|dp
parameter_list|,
name|ep
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|nfscookie
name|cookie
decl_stmt|;
name|struct
name|dirlist
modifier|*
name|dp
decl_stmt|;
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
block|{
name|unsigned
name|int
name|gen
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|cookie
decl_stmt|;
name|am_node
modifier|*
name|xp
decl_stmt|;
name|dp
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|gen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * In the default instance (which is used to 		 * start a search) we return "." and "..". 		 * 		 * This assumes that the count is big enough 		 * to allow both "." and ".." to be returned in 		 * a single packet.  If it isn't (which would 		 * be fairly unbelievable) then tough. 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"default search"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|xp
operator|=
name|next_nonerror_node
argument_list|(
name|mp
operator|->
name|am_child
argument_list|)
expr_stmt|;
name|dp
operator|->
name|entries
operator|=
name|ep
expr_stmt|;
comment|/* construct "." */
name|ep
index|[
literal|0
index|]
operator|.
name|fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|ep
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"."
expr_stmt|;
name|ep
index|[
literal|0
index|]
operator|.
name|nextentry
operator|=
operator|&
name|ep
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ep
index|[
literal|0
index|]
operator|.
name|cookie
operator|=
literal|0
expr_stmt|;
comment|/* construct ".." */
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
name|ep
index|[
literal|1
index|]
operator|.
name|fileid
operator|=
name|mp
operator|->
name|am_parent
operator|->
name|am_gen
expr_stmt|;
else|else
name|ep
index|[
literal|1
index|]
operator|.
name|fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|ep
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|".."
expr_stmt|;
name|ep
index|[
literal|1
index|]
operator|.
name|nextentry
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ep
index|[
literal|1
index|]
operator|.
name|cookie
operator|=
name|xp
condition|?
name|xp
operator|->
name|am_gen
else|:
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|xp
condition|)
name|dp
operator|->
name|eof
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"real child"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|gen
operator|==
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"End of readdir in %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|dp
operator|->
name|eof
operator|=
name|TRUE
expr_stmt|;
name|dp
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xp
operator|=
name|mp
operator|->
name|am_child
expr_stmt|;
while|while
condition|(
name|xp
operator|&&
name|xp
operator|->
name|am_gen
operator|!=
name|gen
condition|)
name|xp
operator|=
name|xp
operator|->
name|am_osib
expr_stmt|;
if|if
condition|(
name|xp
condition|)
block|{
name|am_node
modifier|*
name|xp_next
init|=
name|next_nonerror_node
argument_list|(
name|xp
operator|->
name|am_osib
argument_list|)
decl_stmt|;
if|if
condition|(
name|xp_next
condition|)
block|{
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ep
operator|->
name|cookie
operator|=
name|xp_next
operator|->
name|am_gen
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ep
operator|->
name|cookie
operator|=
operator|~
operator|(
name|unsigned
name|int
operator|)
literal|0
expr_stmt|;
name|dp
operator|->
name|eof
operator|=
name|TRUE
expr_stmt|;
block|}
name|ep
operator|->
name|fileid
operator|=
name|xp
operator|->
name|am_gen
expr_stmt|;
name|ep
operator|->
name|name
operator|=
name|xp
operator|->
name|am_name
expr_stmt|;
name|ep
operator|->
name|nextentry
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|entries
operator|=
name|ep
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ESTALE
return|;
block|}
end_function

begin_function
specifier|static
name|am_node
modifier|*
name|dfs_readlink
parameter_list|(
name|mp
parameter_list|,
name|error_return
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|error_return
decl_stmt|;
block|{
name|am_node
modifier|*
name|xp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|xp
operator|=
name|next_nonerror_node
argument_list|(
name|mp
operator|->
name|am_child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xp
condition|)
name|xp
operator|=
name|afs_lookuppn
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|am_path
operator|+
literal|1
argument_list|,
operator|&
name|rc
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
condition|)
block|{
name|new_ttl
argument_list|(
name|xp
argument_list|)
expr_stmt|;
comment|/* (7/12/89) from Rein Tollevik */
return|return
name|xp
return|;
block|}
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
name|rc
operator|=
name|ENOENT
expr_stmt|;
operator|*
name|error_return
operator|=
name|rc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Ops structure  */
end_comment

begin_decl_stmt
name|am_ops
name|afs_ops
init|=
block|{
literal|"auto"
block|,
name|afs_match
block|,
name|afs_init
block|,
name|afs_mount
block|,
name|afs_umount
block|,
name|afs_lookuppn
block|,
name|afs_readdir
block|,
literal|0
block|,
comment|/* afs_readlink */
literal|0
block|,
comment|/* afs_mounted */
name|afs_umounted
block|,
name|find_afs_srvr
block|,
name|FS_NOTIMEOUT
operator||
name|FS_UBACKGROUND
operator||
name|FS_AMQINFO
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|am_ops
name|dfs_ops
init|=
block|{
literal|"direct"
block|,
name|afs_match
block|,
literal|0
block|,
comment|/* dfs_init */
name|afs_mount
block|,
name|afs_umount
block|,
name|efs_lookuppn
block|,
name|efs_readdir
block|,
name|dfs_readlink
block|,
literal|0
block|,
comment|/* afs_mounted */
name|afs_umounted
block|,
name|find_afs_srvr
block|,
name|FS_NOTIMEOUT
operator||
name|FS_UBACKGROUND
operator||
name|FS_AMQINFO
block|}
decl_stmt|;
end_decl_stmt

end_unit

