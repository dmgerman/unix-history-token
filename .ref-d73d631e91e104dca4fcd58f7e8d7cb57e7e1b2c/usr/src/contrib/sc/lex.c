begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	SC	A Spreadsheet Calculator  *		Lexical analyser  *  *		original by James Gosling, September 1982  *		modifications by Mark Weiser and Bruce Israel,  *			University of Maryland  *  *              More mods Robert Bond, 12/86  *		More mods by Alan Silverstein, 3/88, see list of changes.  *		$Revision: 6.8 $  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD43
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_MATH
end_ifdef

begin_include
include|#
directive|include
file|<ieeefp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE_MATH */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|SYSIII
end_ifndef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|"gram_tab.h"
end_include

begin_typedef
typedef|typedef
union|union
block|{
name|int
name|ival
decl_stmt|;
name|double
name|fval
decl_stmt|;
name|struct
name|ent
modifier|*
name|ent
decl_stmt|;
name|struct
name|enode
modifier|*
name|enode
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
name|struct
name|range_s
name|rval
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|VMS_read_raw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*sigh*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS */
end_comment

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_function_decl
name|char
modifier|*
name|strtof
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|jmp_buf
name|wakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|fpe_buf
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|key
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|key
name|experres
index|[]
init|=
block|{
include|#
directive|include
file|"experres.h"
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key
name|statres
index|[]
init|=
block|{
include|#
directive|include
file|"statres.h"
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|line
operator|+
name|linelim
decl_stmt|;
name|int
name|ret
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tokenst
init|=
name|p
decl_stmt|;
specifier|register
name|tokenl
expr_stmt|;
specifier|register
name|struct
name|key
modifier|*
name|tblp
decl_stmt|;
name|tokenl
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This picks up either 1 or 2 alpha characters (a column) or 	 * tokens with at least three leading alphas and '_' or digits 	 * (a function or token or command or a range name) 	*/
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
operator|||
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|(
name|tokenl
operator|>
literal|2
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|tokenl
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tokenl
operator|<=
literal|2
condition|)
block|{
comment|/* a COL is 1 or 2 char alpha 		(but not pi, ln, fv, pv, if -- this should be fixed!) */
if|if
condition|(
name|tokenl
operator|==
literal|2
operator|&&
name|tokenst
index|[
literal|0
index|]
operator|==
literal|'p'
operator|&&
name|tokenst
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
block|{
name|ret
operator|=
name|K_PI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tokenl
operator|==
literal|2
operator|&&
name|tokenst
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|tokenst
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
block|{
name|ret
operator|=
name|K_LN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tokenl
operator|==
literal|2
operator|&&
name|tokenst
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|tokenst
index|[
literal|1
index|]
operator|==
literal|'v'
condition|)
block|{
name|ret
operator|=
name|K_FV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tokenl
operator|==
literal|2
operator|&&
name|tokenst
index|[
literal|0
index|]
operator|==
literal|'p'
operator|&&
name|tokenst
index|[
literal|1
index|]
operator|==
literal|'v'
condition|)
block|{
name|ret
operator|=
name|K_PV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tokenl
operator|==
literal|2
operator|&&
name|tokenst
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|tokenst
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
name|ret
operator|=
name|K_IF
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|COL
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|atocol
argument_list|(
name|tokenst
argument_list|,
name|tokenl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|WORD
expr_stmt|;
for|for
control|(
name|tblp
operator|=
name|linelim
condition|?
name|experres
else|:
name|statres
init|;
name|tblp
operator|->
name|key
condition|;
name|tblp
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|tblp
operator|->
name|key
index|[
literal|0
index|]
operator|^
name|tokenst
index|[
literal|0
index|]
operator|)
operator|&
literal|0137
operator|)
operator|==
literal|0
operator|&&
name|tblp
operator|->
name|key
index|[
name|tokenl
index|]
operator|==
literal|0
condition|)
block|{
specifier|register
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|tokenl
operator|&&
operator|(
operator|(
name|tokenst
index|[
name|i
index|]
operator|^
name|tblp
operator|->
name|key
index|[
name|i
index|]
operator|)
operator|&
literal|0137
operator|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|tokenl
condition|)
block|{
name|ret
operator|=
name|tblp
operator|->
name|val
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|WORD
condition|)
block|{
name|struct
name|range
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|r
operator|=
name|find_range
argument_list|(
name|tokenst
argument_list|,
name|tokenl
argument_list|,
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|rval
operator|.
name|left
operator|=
name|r
operator|->
name|r_left
expr_stmt|;
name|yylval
operator|.
name|rval
operator|.
name|right
operator|=
name|r
operator|->
name|r_right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|r_is_range
condition|)
name|ret
operator|=
name|RANGE
expr_stmt|;
else|else
name|ret
operator|=
name|VAR
expr_stmt|;
block|}
else|else
block|{
name|linelim
operator|=
name|p
operator|-
name|line
expr_stmt|;
name|yyerror
argument_list|(
literal|"Unintelligible word"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|||
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|double
name|v
init|=
literal|0
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|char
modifier|*
name|nstart
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
block|{
do|do
name|v
operator|=
name|v
operator|*
literal|10
operator|+
call|(
name|double
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|p
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'e'
operator|||
operator|*
name|p
operator|==
literal|'E'
condition|)
block|{
name|ret
operator|=
name|FNUMBER
expr_stmt|;
name|p
operator|=
name|strtof
argument_list|(
name|nstart
argument_list|,
operator|&
name|yylval
operator|.
name|fval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A NUMBER must hold at least MAXROW and MAXCOL */
comment|/* This is consistent with a short row and col in struct ent */
if|if
condition|(
name|v
operator|>
operator|(
name|double
operator|)
literal|32767
operator|||
name|v
operator|<
operator|(
name|double
operator|)
operator|-
literal|32768
condition|)
block|{
name|ret
operator|=
name|FNUMBER
expr_stmt|;
name|yylval
operator|.
name|fval
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|int
operator|)
name|v
expr_stmt|;
if|if
condition|(
operator|(
name|double
operator|)
name|temp
operator|!=
name|v
condition|)
block|{
name|ret
operator|=
name|FNUMBER
expr_stmt|;
name|yylval
operator|.
name|fval
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|NUMBER
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|++
operator|!=
literal|'"'
condition|)
empty_stmt|;
name|ptr
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|ptr
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|sval
operator|=
name|ptr
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'"'
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
name|ret
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
name|linelim
operator|=
name|p
operator|-
name|line
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
else|else
name|ret
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|linelim
operator|=
name|p
operator|-
name|line
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/*  * Given a token string starting with a symbolic column name and its valid  * length, convert column name ("A"-"Z" or "AA"-"ZZ") to a column number (0-N).  * Never mind if the column number is illegal (too high).  The procedure's name  * and function are the inverse of coltoa().  *   * Case-insensitivity is done crudely, by ignoring the 040 bit.  */
end_comment

begin_function
name|int
name|atocol
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|col
decl_stmt|;
name|col
operator|=
operator|(
name|string
index|[
literal|0
index|]
operator|&
literal|0137
operator|)
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
condition|)
comment|/* has second char */
name|col
operator|=
operator|(
operator|(
name|col
operator|+
literal|1
operator|)
operator|*
literal|26
operator|)
operator|+
operator|(
operator|(
name|string
index|[
literal|1
index|]
operator|&
literal|0137
operator|)
operator|-
literal|'A'
operator|)
expr_stmt|;
return|return
operator|(
name|col
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIMPLE
end_ifdef

begin_macro
name|initkbd
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|kbd_again
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|resetkbd
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_macro
name|nmgetch
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|toascii
argument_list|(
name|getchar
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS */
end_comment

begin_macro
name|nmgetch
argument_list|()
end_macro

begin_comment
comment|/*    This is not perfect, it doesn't move the cursor when goraw changes    over to deraw, but it works well enough since the whole sc package    is incredibly stable (loop constantly positions cursor).     Question, why didn't the VMS people just implement cbreak?     NOTE: During testing it was discovered that the DEBUGGER and curses    and this method of reading would collide (the screen was not updated    when continuing from screen mode in the debugger). */
end_comment

begin_block
block|{
name|short
name|c
decl_stmt|;
specifier|static
name|int
name|key_id
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
define|#
directive|define
name|VMScheck
parameter_list|(
name|a
parameter_list|)
value|{if (~(status = (a))& 1) VMS_MSG (status);}
if|if
condition|(
name|VMS_read_raw
condition|)
block|{
name|VMScheck
argument_list|(
name|smg$read_keystroke
argument_list|(
operator|&
name|stdkb
operator|->
name|_id
argument_list|,
operator|&
name|c
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SMG$K_TRM_LEFT
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMG$K_TRM_RIGHT
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMG$K_TRM_UP
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMG$K_TRM_DOWN
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|c
operator|=
name|c
operator|&
literal|0x7f
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|VMS_MSG
argument_list|(
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Routine to put out the VMS operating system error (if one occurs). */
end_comment

begin_block
block|{
include|#
directive|include
file|<descrip.h>
name|char
name|errstr
index|[
literal|81
index|]
decl_stmt|,
name|buf
index|[
literal|120
index|]
decl_stmt|;
name|$DESCRIPTOR
argument_list|(
name|errdesc
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|short
name|int
name|length
decl_stmt|;
define|#
directive|define
name|err_out
parameter_list|(
name|msg
parameter_list|)
value|fprintf (stderr,msg)
comment|/* Check for no error or standard error */
if|if
condition|(
operator|~
name|status
operator|&
literal|1
condition|)
block|{
name|status
operator|=
name|status
operator|&
literal|0x8000
condition|?
name|status
operator|&
literal|0xFFFFFFF
else|:
name|status
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|SYS$GETMSG
argument_list|(
name|status
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|errdesc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
name|SS$_NORMAL
condition|)
block|{
name|errstr
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"<0x%x> %s"
argument_list|,
name|status
argument_list|,
name|errdesc
operator|.
name|dsc$a_pointer
argument_list|)
expr_stmt|;
name|err_out
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|err_out
argument_list|(
literal|"System error"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*SIMPLE*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSIII
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD43
argument_list|)
end_if

begin_define
define|#
directive|define
name|N_KEY
value|4
end_define

begin_struct
struct|struct
name|key_map
block|{
name|char
modifier|*
name|k_str
decl_stmt|;
name|char
name|k_val
decl_stmt|;
name|char
name|k_index
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|key_map
name|km
index|[
name|N_KEY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|keyarea
index|[
name|N_KEY
operator|*
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|ks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ks_buf
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ke
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ke_buf
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSLTC
end_ifdef

begin_decl_stmt
name|struct
name|ltchars
name|old_chars
decl_stmt|,
name|new_chars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|dont_use
index|[]
init|=
block|{
name|ctl
argument_list|(
literal|'['
argument_list|)
block|,
name|ctl
argument_list|(
literal|'a'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'b'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'c'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'e'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'f'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'g'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'h'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'i'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'j'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'l'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'m'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'n'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'p'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'q'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'r'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'s'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'t'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'u'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'v'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'w'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'x'
argument_list|)
block|,
name|ctl
argument_list|(
literal|'z'
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|charout
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|initkbd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|key_map
modifier|*
name|kp
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|char
modifier|*
name|p
init|=
name|keyarea
decl_stmt|;
name|char
modifier|*
name|ktmp
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* Why do I have to do this again? */
if|if
condition|(
name|tgetent
argument_list|(
name|buf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return;
name|km
index|[
literal|0
index|]
operator|.
name|k_str
operator|=
name|tgetstr
argument_list|(
literal|"kl"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|km
index|[
literal|0
index|]
operator|.
name|k_val
operator|=
name|ctl
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|km
index|[
literal|1
index|]
operator|.
name|k_str
operator|=
name|tgetstr
argument_list|(
literal|"kr"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|km
index|[
literal|1
index|]
operator|.
name|k_val
operator|=
name|ctl
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
name|km
index|[
literal|2
index|]
operator|.
name|k_str
operator|=
name|tgetstr
argument_list|(
literal|"ku"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|km
index|[
literal|2
index|]
operator|.
name|k_val
operator|=
name|ctl
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|km
index|[
literal|3
index|]
operator|.
name|k_str
operator|=
name|tgetstr
argument_list|(
literal|"kd"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|km
index|[
literal|3
index|]
operator|.
name|k_val
operator|=
name|ctl
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|ktmp
operator|=
name|tgetstr
argument_list|(
literal|"ks"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ktmp
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ks_buf
argument_list|,
name|ktmp
argument_list|)
expr_stmt|;
name|ks
operator|=
name|ks_buf
expr_stmt|;
name|tputs
argument_list|(
name|ks
argument_list|,
literal|1
argument_list|,
name|charout
argument_list|)
expr_stmt|;
block|}
name|ktmp
operator|=
name|tgetstr
argument_list|(
literal|"ke"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ktmp
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ke_buf
argument_list|,
name|ktmp
argument_list|)
expr_stmt|;
name|ke
operator|=
name|ke_buf
expr_stmt|;
block|}
comment|/* Unmap arrow keys which conflict with our ctl keys   */
comment|/* Ignore unset, longer than length 1, and 1-1 mapped keys */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_KEY
condition|;
name|i
operator|++
control|)
block|{
name|kp
operator|=
operator|&
name|km
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|k_str
operator|&&
operator|(
name|kp
operator|->
name|k_str
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|kp
operator|->
name|k_str
index|[
literal|0
index|]
operator|!=
name|kp
operator|->
name|k_val
operator|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|dont_use
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|k_str
index|[
literal|0
index|]
operator|==
name|dont_use
index|[
name|j
index|]
condition|)
block|{
name|kp
operator|->
name|k_str
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|old_chars
argument_list|)
expr_stmt|;
name|new_chars
operator|=
name|old_chars
expr_stmt|;
if|if
condition|(
name|old_chars
operator|.
name|t_lnextc
operator|==
name|ctl
argument_list|(
literal|'v'
argument_list|)
condition|)
name|new_chars
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|old_chars
operator|.
name|t_rprntc
operator|==
name|ctl
argument_list|(
literal|'r'
argument_list|)
condition|)
name|new_chars
operator|.
name|t_rprntc
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|new_chars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|void
name|kbd_again
parameter_list|()
block|{
if|if
condition|(
name|ks
condition|)
name|tputs
argument_list|(
name|ks
argument_list|,
literal|1
argument_list|,
name|charout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|new_chars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|resetkbd
parameter_list|()
block|{
if|if
condition|(
name|ke
condition|)
name|tputs
argument_list|(
name|ke
argument_list|,
literal|1
argument_list|,
name|charout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|old_chars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_macro
name|nmgetch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|key_map
modifier|*
name|kp
decl_stmt|;
specifier|register
name|struct
name|key_map
modifier|*
name|biggest
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|almost
decl_stmt|;
name|int
name|maybe
decl_stmt|;
specifier|static
name|char
name|dumpbuf
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|dumpindex
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGVOID
name|void
name|time_out
parameter_list|()
function_decl|;
else|#
directive|else
name|int
name|time_out
parameter_list|()
function_decl|;
endif|#
directive|endif
if|if
condition|(
name|dumpindex
operator|&&
operator|*
name|dumpindex
condition|)
return|return
operator|(
operator|*
name|dumpindex
operator|++
operator|)
return|;
name|c
operator|=
name|toascii
argument_list|(
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
name|biggest
operator|=
literal|0
expr_stmt|;
name|almost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kp
operator|=
operator|&
name|km
index|[
literal|0
index|]
init|;
name|kp
operator|<
operator|&
name|km
index|[
name|N_KEY
index|]
condition|;
name|kp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|kp
operator|->
name|k_str
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|kp
operator|->
name|k_str
index|[
name|kp
operator|->
name|k_index
index|]
condition|)
block|{
name|almost
operator|=
literal|1
expr_stmt|;
name|kp
operator|->
name|k_index
operator|++
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|k_str
index|[
name|kp
operator|->
name|k_index
index|]
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|kp
operator|->
name|k_val
expr_stmt|;
for|for
control|(
name|kp
operator|=
operator|&
name|km
index|[
literal|0
index|]
init|;
name|kp
operator|<
operator|&
name|km
index|[
name|N_KEY
index|]
condition|;
name|kp
operator|++
control|)
name|kp
operator|->
name|k_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|biggest
operator|&&
name|kp
operator|->
name|k_index
condition|)
name|biggest
operator|=
name|kp
expr_stmt|;
elseif|else
if|if
condition|(
name|kp
operator|->
name|k_index
operator|&&
name|biggest
operator|->
name|k_index
operator|<
name|kp
operator|->
name|k_index
condition|)
name|biggest
operator|=
name|kp
expr_stmt|;
block|}
if|if
condition|(
name|almost
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|time_out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|wakeup
argument_list|)
operator|==
literal|0
condition|)
block|{
name|maybe
operator|=
name|nmgetch
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|maybe
operator|)
return|;
block|}
block|}
if|if
condition|(
name|biggest
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|biggest
operator|->
name|k_index
condition|;
name|i
operator|++
control|)
name|dumpbuf
index|[
name|i
index|]
operator|=
name|biggest
operator|->
name|k_str
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|almost
condition|)
name|dumpbuf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|dumpbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dumpindex
operator|=
operator|&
name|dumpbuf
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|kp
operator|=
operator|&
name|km
index|[
literal|0
index|]
init|;
name|kp
operator|<
operator|&
name|km
index|[
name|N_KEY
index|]
condition|;
name|kp
operator|++
control|)
name|kp
operator|->
name|k_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dumpbuf
index|[
literal|0
index|]
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV3
argument_list|)
end_if

begin_macro
name|initkbd
argument_list|()
end_macro

begin_block
block|{
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|kbd_again
parameter_list|()
block|{
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|resetkbd
parameter_list|()
block|{
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|nmgetch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_LEFT
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|KEY_C1
comment|/* This stuff works for a wyse wy75 in ANSI mode under 5.3.  Good luck. */
comment|/* It is supposed to map the curses keypad back to the numeric equiv. */
case|case
name|KEY_C1
case|:
name|c
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
name|KEY_A1
case|:
name|c
operator|=
literal|'1'
expr_stmt|;
break|break;
case|case
name|KEY_B2
case|:
name|c
operator|=
literal|'2'
expr_stmt|;
break|break;
case|case
name|KEY_A3
case|:
name|c
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|5
argument_list|)
case|:
name|c
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|6
argument_list|)
case|:
name|c
operator|=
literal|'5'
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|7
argument_list|)
case|:
name|c
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|9
argument_list|)
case|:
name|c
operator|=
literal|'7'
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|10
argument_list|)
case|:
name|c
operator|=
literal|'8'
expr_stmt|;
break|break;
case|case
name|KEY_F0
case|:
name|c
operator|=
literal|'9'
expr_stmt|;
break|break;
case|case
name|KEY_C3
case|:
name|c
operator|=
literal|'.'
expr_stmt|;
break|break;
case|case
name|KEY_ENTER
case|:
name|c
operator|=
name|ctl
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|c
operator|=
name|toascii
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV2 || SYSV3 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIMPLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGVOID
end_ifdef

begin_function
name|void
endif|#
directive|endif
name|time_out
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IEEE_MATH
operator|(
name|void
operator|)
name|fpsetsticky
argument_list|(
operator|(
name|fp_except
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear exception */
endif|#
directive|endif
comment|/* IEEE_MATH */
name|longjmp
argument_list|(
name|wakeup
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGVOID
end_ifdef

begin_function
name|void
endif|#
directive|endif
name|fpe_trap
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|fpe_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This converts a floating point number of the form  * [s]ddd[.d*][esd*]  where s can be a + or - and e is E or e.  * to floating point.   * p is advanced.  */
end_comment

begin_function
name|char
modifier|*
name|strtof
parameter_list|(
name|p
parameter_list|,
name|res
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|double
modifier|*
name|res
decl_stmt|;
block|{
name|double
name|acc
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|double
name|fpos
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|int
name|exps
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGVOID
name|void
function_decl|(
modifier|*
name|sig_save
function_decl|)
parameter_list|()
function_decl|;
else|#
directive|else
name|int
function_decl|(
modifier|*
name|sig_save
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
name|sig_save
operator|=
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fpe_trap
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|fpe_buf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Floating point exception\n"
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
literal|0.0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|sig_save
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|acc
operator|=
literal|0.0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|exps
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|acc
operator|=
name|acc
operator|*
literal|10.0
operator|+
call|(
name|double
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'e'
operator|||
operator|*
name|p
operator|==
literal|'E'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exps
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|exp
operator|=
name|exp
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|fpos
operator|=
literal|1.0
operator|/
literal|10.0
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|acc
operator|+=
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
operator|*
name|fpos
expr_stmt|;
name|fpos
operator|*=
literal|1.0
operator|/
literal|10.0
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'e'
operator|||
operator|*
name|p
operator|==
literal|'E'
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
name|exps
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|exps
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|exp
operator|=
name|exp
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exp
condition|)
block|{
if|if
condition|(
name|exps
operator|>
literal|0
condition|)
while|while
condition|(
name|exp
operator|--
condition|)
name|acc
operator|*=
literal|10.0
expr_stmt|;
else|else
while|while
condition|(
name|exp
operator|--
condition|)
name|acc
operator|*=
literal|1.0
operator|/
literal|10.0
expr_stmt|;
block|}
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
operator|*
name|res
operator|=
name|acc
expr_stmt|;
else|else
operator|*
name|res
operator|=
operator|-
name|acc
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|sig_save
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

