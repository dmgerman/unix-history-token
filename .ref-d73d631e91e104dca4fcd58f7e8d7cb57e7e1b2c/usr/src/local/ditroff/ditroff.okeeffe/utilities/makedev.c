begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)makedev.c	1.2	(CWI)	1.2	85/10/24"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*   makedev: 	read text info about a particular device 	(e.g., cat, 202, aps5) from file, convert 	it into internal (binary) form suitable for 	fast reading by troff initialization (ptinit()).  	Usage:  	makedev DESC [ F ... ] 		uses DESC to create a description file 		using the information therein. 		It creates the file DESC.out.  	makedev F ... 		makes the font tables for fonts F only, 		creates files F.out.  	DESC.out contains: 	dev structure with fundamental sizes 	list of sizes (nsizes+1) terminated by 0, as short's 	indices of char names (nchtab * sizeof(short)) 	char names as hy\0em\0... (lchname) 	nfonts occurrences of 		widths (nwidth) 		kerning (nwidth) [ascender+descender only so far] 		codes (nwidth) to drive actual typesetter 		fitab (nchtab+128-32) 	each of these is an array of char.  	dev.filesize contains the number of bytes 	in the file, excluding the dev part itself.  	F.out contains the font header, width, kern, codes, and fitab. 	Width, kern and codes are parallel arrays. 	(Which suggests that they ought to be together?) 	Later, we might allow for codes which are actually 	sequences of formatting info so characters can be drawn. */
end_comment

begin_comment
comment|/*  * Changes made at the Mathematisch centrum:  *  * 1	added another table of shorts, with contains a number of the  *	physical font where the char actual lives. This is done because  *	the typesetter at the MC (harris 7400)has "mixed fonts".  *	(for instance, the font with number 4478 contains the   *	ligatures etc. for as well the times roman  *	and the times italic fonts).  *	This table (fcode(nwidth)) starts after the fitab,  *	this is done so we don't have to change in troff t6.c setfp().  *	For the sake of compatibility, this change will only be effective  *	if the field fonttab is set to 1. This change has to be wired  *	in troff etc. as well.  *   * 2	The sans-serif fonts of the Harris doesn't have an italian  *	equivalent, they are suppose to be made bij the Oblique  *	facility of the Harris. This will slant the character by  *	9, 12 or 15 degrees. So another field in the font sruct is added  *	for this function as well.  *  * 3	added some checking of input desciption (for instance declaring  *	too many sizes).  *  * These changes are made by jaap akkerhuis, 1982  *  * Warning: using the spare fields may give bizarre effects, see comment  *	at font.spare1  */
end_comment

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"../dev.h"
end_include

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_define
define|#
directive|define
name|skipline
parameter_list|(
name|f
parameter_list|)
value|while(getc(f) != '\n')
end_define

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Font
name|font
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSIZE
value|100
end_define

begin_comment
comment|/* maximum number of sizes */
end_comment

begin_decl_stmt
name|short
name|size
index|[
name|NSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCH
value|256
end_define

begin_comment
comment|/* max number of characters with funny names */
end_comment

begin_decl_stmt
name|char
name|chname
index|[
literal|5
operator|*
name|NCH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character names, including \0 for each */
end_comment

begin_decl_stmt
name|short
name|chtab
index|[
name|NCH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of character in chname */
end_comment

begin_decl_stmt
name|char
name|nmseen
index|[
literal|5
operator|*
name|NCH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names we have seen */
end_comment

begin_define
define|#
directive|define
name|NFITAB
value|(NCH + 128-32)
end_define

begin_comment
comment|/* includes ascii chars, but not non-graphics */
end_comment

begin_decl_stmt
name|char
name|fitab
index|[
name|NFITAB
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font index table: position of char i on this font. */
end_comment

begin_comment
comment|/* zero if not there */
end_comment

begin_define
define|#
directive|define
name|FSIZE
value|200
end_define

begin_comment
comment|/* size of a physical font (e.g., 102 for cat) */
end_comment

begin_decl_stmt
name|char
name|width
index|[
name|FSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width table for a physical font */
end_comment

begin_decl_stmt
name|char
name|kern
index|[
name|FSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ascender+descender info */
end_comment

begin_decl_stmt
name|char
name|code
index|[
name|FSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual device codes for a physical font */
end_comment

begin_decl_stmt
name|short
name|fcode
index|[
name|FSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MC:jna physical font number */
end_comment

begin_define
define|#
directive|define
name|NFONT
value|60
end_define

begin_comment
comment|/* max number of default fonts */
end_comment

begin_comment
comment|/* 				 * 60 to support Versatec Berkeley style 				 * filters. Aargh! 				 */
end_comment

begin_decl_stmt
name|char
name|fname
index|[
name|NFONT
index|]
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp space to hold default font names */
end_comment

begin_decl_stmt
name|int
name|fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* on if font table to be written */
end_comment

begin_decl_stmt
name|int
name|fdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fout
init|=
literal|"DESC.out"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fin
decl_stmt|;
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|totfont
decl_stmt|,
name|v
decl_stmt|,
name|check
decl_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|fopen
argument_list|(
literal|"DESC"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makedev: can't open %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|cmd
argument_list|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* comment */
name|skipline
argument_list|(
name|fin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"res"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|res
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"hor"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|hor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"vert"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|vert
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"unitwidth"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|unitwidth
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"sizescale"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|sizescale
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"paperwidth"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|paperwidth
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"paperlength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|paperlength
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"spare1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|spare1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"spare2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|spare2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"sizes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dev
operator|.
name|nsizes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
name|EOF
operator|&&
name|v
operator|!=
literal|0
condition|)
block|{
name|size
index|[
name|dev
operator|.
name|nsizes
operator|++
index|]
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|dev
operator|.
name|nsizes
operator|>=
name|NSIZE
condition|)
block|{
comment|/*MC:jna addition */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many sizes\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|size
index|[
name|dev
operator|.
name|nsizes
index|]
operator|=
literal|0
expr_stmt|;
comment|/* need an extra 0 at the end */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"fonts"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|dev
operator|.
name|nfonts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|.
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|NFONT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many default fonts\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"charset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|chname
expr_stmt|;
name|dev
operator|.
name|nchtab
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|chtab
index|[
name|dev
operator|.
name|nchtab
operator|++
index|]
operator|=
name|p
operator|-
name|chname
expr_stmt|;
if|if
condition|(
name|dev
operator|.
name|nchtab
operator|>
name|NCH
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many charnames at %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|.
name|nchtab
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Warning: charname %s used more then once\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
comment|/* skip to end of name */
empty_stmt|;
block|}
name|dev
operator|.
name|lchname
operator|=
name|p
operator|-
name|chname
expr_stmt|;
name|chtab
index|[
name|dev
operator|.
name|nchtab
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* terminate properly */
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makedev: unknown command %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"DESC"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|check
operator|++
expr_stmt|;
name|fdout
operator|=
name|creat
argument_list|(
name|fout
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdout
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makedev: can't open %s\n"
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|fdout
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|size
argument_list|,
operator|(
name|dev
operator|.
name|nsizes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we need a 0 on the end */
name|write
argument_list|(
name|fdout
argument_list|,
name|chtab
argument_list|,
name|dev
operator|.
name|nchtab
operator|*
sizeof|sizeof
argument_list|(
name|chtab
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|chname
argument_list|,
name|dev
operator|.
name|lchname
argument_list|)
expr_stmt|;
name|totfont
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|.
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Get fontinfo ... 			 */
name|dofont
argument_list|(
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * ... and force space in troff allocated for the 			 * biggest font possible and limited by makedev 			 * to be loaded in troff by faking font.nwfont 			 * (and bumping up the size of DESC.out) by 			 * recalculating the padded out fontsize (v) 			 *	jna 			 */
name|font
operator|.
name|nwfont
operator|=
name|FSIZE
expr_stmt|;
name|v
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
operator|+
literal|3
operator|*
name|FSIZE
operator|+
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
expr_stmt|;
comment|/* 				 * This is not correct, we can still 				 * have too less space if the default 				 * mounted fonts does not contain a 				 * fonttab, but I don't want to change 				 * troff on the moment... 				 */
if|if
condition|(
name|font
operator|.
name|fonttab
operator|==
literal|1
condition|)
name|v
operator|+=
name|FSIZE
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|totfont
operator|+=
name|v
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
operator|&
name|font
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|width
argument_list|,
name|font
operator|.
name|nwfont
operator|&
name|BMASK
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|kern
argument_list|,
name|font
operator|.
name|nwfont
operator|&
name|BMASK
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|code
argument_list|,
name|font
operator|.
name|nwfont
operator|&
name|BMASK
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|fitab
argument_list|,
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|fonttab
operator|==
literal|1
condition|)
name|write
argument_list|(
name|fdout
argument_list|,
name|fcode
argument_list|,
operator|(
name|font
operator|.
name|nwfont
operator|&
name|BMASK
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|fcode
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|fdout
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* back to beginning to install proper size */
name|dev
operator|.
name|filesize
operator|=
comment|/* excluding dev struct itself */
operator|(
name|dev
operator|.
name|nsizes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size
index|[
literal|0
index|]
argument_list|)
operator|+
name|dev
operator|.
name|nchtab
operator|*
sizeof|sizeof
argument_list|(
name|chtab
index|[
literal|0
index|]
argument_list|)
operator|+
name|dev
operator|.
name|lchname
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|+
name|totfont
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|dofont
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
condition|)
name|checknames
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|dofont
argument_list|(
argument|name
argument_list|)
end_macro

begin_comment
comment|/* create fitab and width tab for font */
end_comment

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fin
decl_stmt|;
name|int
name|fdout
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nw
decl_stmt|,
name|spacewidth
decl_stmt|,
name|n
decl_stmt|,
name|v
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
name|ch
index|[
literal|10
index|]
decl_stmt|,
name|s1
index|[
literal|10
index|]
decl_stmt|,
name|s2
index|[
literal|10
index|]
decl_stmt|,
name|s3
index|[
literal|10
index|]
decl_stmt|,
name|s4
index|[
literal|10
index|]
decl_stmt|,
name|cmd
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makedev: can't open font %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s.out"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fdout
operator|=
name|creat
argument_list|(
name|cmd
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFITAB
condition|;
name|i
operator|++
control|)
name|fitab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FSIZE
condition|;
name|i
operator|++
control|)
block|{
name|width
index|[
name|i
index|]
operator|=
name|kern
index|[
name|i
index|]
operator|=
name|code
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fcode
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|font
operator|.
name|fonttab
operator|=
name|font
operator|.
name|slant
operator|=
name|font
operator|.
name|specfont
operator|=
name|font
operator|.
name|ligfont
operator|=
name|spacewidth
operator|=
literal|0
expr_stmt|;
name|font
operator|.
name|spare1
operator|=
name|NULL
expr_stmt|;
name|font
operator|.
name|namefont
index|[
literal|0
index|]
operator|=
name|font
operator|.
name|intname
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|cmd
argument_list|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|skipline
argument_list|(
name|fin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|font
operator|.
name|namefont
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"internalname"
argument_list|)
operator|==
literal|0
condition|)
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|font
operator|.
name|intname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"special"
argument_list|)
operator|==
literal|0
condition|)
name|font
operator|.
name|specfont
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"fonttab"
argument_list|)
operator|==
literal|0
condition|)
name|font
operator|.
name|fonttab
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"slant"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|font
operator|.
name|slant
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"spare1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%1s"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
comment|/*MC:jna %1s will get 1 char + 						 * a \0 added, so 						 *&font.spare1 will place 						 * a \0 in font.name[0] 						 */
name|font
operator|.
name|spare1
operator|=
name|s1
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"ligatures"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|font
operator|.
name|ligfont
operator|=
name|getlig
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"spacewidth"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|spacewidth
argument_list|)
expr_stmt|;
name|width
index|[
literal|0
index|]
operator|=
name|spacewidth
expr_stmt|;
comment|/* width of space on this font */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"charset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipline
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nw
operator|=
literal|0
expr_stmt|;
comment|/* widths are origin 1 so fitab==0 can mean "not there" */
comment|/* 			 *MC:jna and so width[0] can mean spacewidth 			 * 			 * note that in charset part cann't be any comments! 			 */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|100
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|x
decl_stmt|;
comment|/* printf(buf); */
if|if
condition|(
name|font
operator|.
name|fonttab
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|ch
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|5
operator|&&
name|s1
index|[
literal|0
index|]
operator|!=
literal|'"'
condition|)
name|printf
argument_list|(
literal|"sscanf mismatch %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s %s"
argument_list|,
name|ch
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|4
operator|&&
name|s1
index|[
literal|0
index|]
operator|!=
literal|'"'
condition|)
name|printf
argument_list|(
literal|"sscanf mismatch %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s1
index|[
literal|0
index|]
operator|!=
literal|'"'
condition|)
block|{
comment|/* it's a genuine new character */
name|nw
operator|++
expr_stmt|;
if|if
condition|(
name|nw
operator|>
name|FSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too big font!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|width
index|[
name|nw
index|]
operator|=
name|atoi
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|kern
index|[
name|nw
index|]
operator|=
name|atoi
argument_list|(
name|s2
argument_list|)
expr_stmt|;
comment|/* temporarily, pick up one byte as code */
if|if
condition|(
name|s3
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|sscanf
argument_list|(
name|s3
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
else|else
name|sscanf
argument_list|(
name|s3
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|code
index|[
name|nw
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|fonttab
operator|==
literal|1
condition|)
name|fcode
index|[
name|nw
index|]
operator|=
name|atoi
argument_list|(
name|s4
argument_list|)
expr_stmt|;
block|}
comment|/* otherwise it's a synonym for previous character, 				/* so leave previous values intact 				*/
if|if
condition|(
name|strlen
argument_list|(
name|ch
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* it's ascii */
if|if
condition|(
name|fitab
index|[
name|ch
index|[
literal|0
index|]
operator|-
literal|32
index|]
condition|)
name|printf
argument_list|(
literal|"Warning: redefining character %c\n"
argument_list|,
name|ch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fitab
index|[
name|ch
index|[
literal|0
index|]
operator|-
literal|32
index|]
operator|=
name|nw
expr_stmt|;
comment|/* fitab origin omits non-graphics */
block|}
else|else
block|{
comment|/* it has a funny name */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|.
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|ch
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fitab
index|[
name|i
operator|+
literal|128
operator|-
literal|32
index|]
condition|)
name|printf
argument_list|(
literal|"Warning: redefining character %s\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|fitab
index|[
name|i
operator|+
literal|128
operator|-
literal|32
index|]
operator|=
name|nw
expr_stmt|;
comment|/* starts after the ascii */
if|if
condition|(
operator|!
name|nmseen
index|[
name|chtab
index|[
name|i
index|]
index|]
condition|)
block|{
name|p
operator|=
operator|&
name|nmseen
index|[
name|chtab
index|[
name|i
index|]
index|]
expr_stmt|;
name|p1
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|*
name|p1
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|dev
operator|.
name|nchtab
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makedev: font %s: %s not in charset\n"
argument_list|,
name|name
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|nw
operator|++
expr_stmt|;
name|font
operator|.
name|nwfont
operator|=
name|n
operator|=
name|nw
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spacewidth
operator|==
literal|0
condition|)
name|width
index|[
literal|0
index|]
operator|=
name|dev
operator|.
name|res
operator|*
name|dev
operator|.
name|unitwidth
operator|/
literal|72
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|intname
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keyword internalname not specified\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|namefont
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keyword fontname not specified\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
operator|&
name|font
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|width
argument_list|,
name|font
operator|.
name|nwfont
operator|&
name|BMASK
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|kern
argument_list|,
name|font
operator|.
name|nwfont
operator|&
name|BMASK
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|code
argument_list|,
name|font
operator|.
name|nwfont
operator|&
name|BMASK
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdout
argument_list|,
name|fitab
argument_list|,
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|fonttab
operator|==
literal|1
condition|)
name|write
argument_list|(
name|fdout
argument_list|,
name|fcode
argument_list|,
operator|(
name|font
operator|.
name|nwfont
operator|&
name|BMASK
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|fcode
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
name|v
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
operator|+
literal|3
operator|*
name|n
operator|+
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|fonttab
operator|==
literal|1
condition|)
name|v
operator|+=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3s: %3d chars, width %3d, size %3d\n"
argument_list|,
name|font
operator|.
name|namefont
argument_list|,
name|nw
argument_list|,
name|width
index|[
literal|0
index|]
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
comment|/* 	 * MC:jna v is the filesize of one font in bytes 	 */
block|}
end_block

begin_macro
name|getlig
argument_list|(
argument|fin
argument_list|)
end_macro

begin_comment
comment|/* pick up ligature list */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lig
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|lig
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fin
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
operator|!=
name|EOF
operator|&&
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"fi"
argument_list|)
operator|==
literal|0
condition|)
name|lig
operator||=
name|LFI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"fl"
argument_list|)
operator|==
literal|0
condition|)
name|lig
operator||=
name|LFL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"ff"
argument_list|)
operator|==
literal|0
condition|)
name|lig
operator||=
name|LFF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"ffi"
argument_list|)
operator|==
literal|0
condition|)
name|lig
operator||=
name|LFFI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"ffl"
argument_list|)
operator|==
literal|0
condition|)
name|lig
operator||=
name|LFFL
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"illegal ligature %s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|skipline
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|lig
return|;
block|}
end_block

begin_macro
name|checknames
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|.
name|nchtab
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nmseen
index|[
name|chtab
index|[
name|i
index|]
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: %s not defined in any of the font(s)\n"
argument_list|,
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"This can lead to strange results when these "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"characters are actually used!\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Number of special character names: %d\n"
argument_list|,
name|dev
operator|.
name|nchtab
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

