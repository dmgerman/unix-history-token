begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"memut.c	(CWI)	1.1	85/03/01"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* memory utilities */
end_comment

begin_include
include|#
directive|include
file|"ideal.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|fooalloc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tryalloc
parameter_list|(
name|new
parameter_list|,
name|kind
parameter_list|)
define|\
value|if (!(new =(kind *) malloc(sizeof (kind)))) {\ 	emergency ();\ 	if (!(new =(kind *) malloc(sizeof (kind)))) {\ 		fprintf (stderr, "ideal: Out of space\n");\ 		exit (1);\ 		}\ 	};\ 	for (fooalloc = (char *) new;\ 		fooalloc< ((char *) new) + sizeof (kind);\ 		fooalloc ++)\ 		*fooalloc = '\0';
end_define

begin_function
name|STMTPTR
name|stmtgen
parameter_list|(
name|kind
parameter_list|,
name|stmt
parameter_list|)
name|int
name|kind
decl_stmt|;
name|char
modifier|*
name|stmt
decl_stmt|;
block|{
specifier|register
name|STMTPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|STMTNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|newguy
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|BOXPTR
name|boxgen
parameter_list|(
name|name
parameter_list|,
name|stmtlist
parameter_list|)
name|int
name|name
decl_stmt|;
name|STMTPTR
name|stmtlist
decl_stmt|;
block|{
specifier|register
name|BOXPTR
name|newguy
decl_stmt|;
name|STMTPTR
name|bdstmt
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|BOXNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|name
operator|=
name|name
expr_stmt|;
comment|/* the stmts are in reverse order (check the yacc grammar) */
name|newguy
operator|->
name|stmtlist
operator|=
name|reverse
argument_list|(
name|stmtlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdstmt
operator|=
name|nextstmt
argument_list|(
name|BDLIST
argument_list|,
name|stmtlist
argument_list|)
condition|)
name|bdstmt
operator|->
name|stmt
operator|=
operator|(
name|char
operator|*
operator|)
name|reverse
argument_list|(
operator|(
name|STMTPTR
operator|)
name|bdstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|NAMEPTR
name|namegen
parameter_list|(
name|name
parameter_list|)
name|int
name|name
decl_stmt|;
block|{
specifier|register
name|NAMEPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|NAMENODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|EXPRPTR
name|exprgen
parameter_list|(
name|expr
parameter_list|)
name|EXPR
name|expr
decl_stmt|;
block|{
specifier|register
name|EXPRPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EXPRNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|PUTPTR
name|putgen
parameter_list|(
name|name
parameter_list|,
name|parm
parameter_list|,
name|p_or_c
parameter_list|)
name|int
name|name
decl_stmt|;
name|BOXPTR
name|parm
decl_stmt|;
name|int
name|p_or_c
decl_stmt|;
block|{
specifier|register
name|PUTPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|PUTNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|newguy
operator|->
name|parm
operator|=
name|parm
expr_stmt|;
name|newguy
operator|->
name|p_or_c
operator|=
name|p_or_c
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|PENPTR
name|pengen
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|copies
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|pen
parameter_list|)
name|EXPR
name|from
decl_stmt|,
name|to
decl_stmt|,
name|copies
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
name|BOXPTR
name|pen
decl_stmt|;
block|{
specifier|register
name|PENPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|PEN_NODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|newguy
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|newguy
operator|->
name|copies
operator|=
name|copies
expr_stmt|;
name|newguy
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|newguy
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|newguy
operator|->
name|pen
operator|=
name|pen
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|MISCPTR
name|miscgen
parameter_list|(
name|info
parameter_list|)
name|int
name|info
decl_stmt|;
block|{
specifier|register
name|MISCPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|MISCNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|info
operator|=
name|info
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|INTLPTR
name|intlgen
parameter_list|(
name|oper
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|)
name|int
name|oper
decl_stmt|;
name|EXPR
name|left
decl_stmt|,
name|right
decl_stmt|;
block|{
specifier|register
name|INTLPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EXPRINTL
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|leaf
operator|=
name|FALSE
expr_stmt|;
name|newguy
operator|->
name|oper
operator|=
name|oper
expr_stmt|;
name|newguy
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|newguy
operator|->
name|right
operator|=
name|right
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|INTLPTR
name|commagen
parameter_list|(
name|real
parameter_list|,
name|imag
parameter_list|)
name|float
name|real
decl_stmt|,
name|imag
decl_stmt|;
block|{
specifier|register
name|INTLPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EXPRINTL
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|leaf
operator|=
name|FALSE
expr_stmt|;
name|newguy
operator|->
name|oper
operator|=
literal|';'
expr_stmt|;
name|newguy
operator|->
name|left
operator|=
operator|(
name|EXPR
operator|)
name|depgen
argument_list|(
operator|(
name|VARPTR
operator|)
name|NULL
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depgen
argument_list|(
operator|(
name|VARPTR
operator|)
name|NULL
argument_list|,
name|imag
argument_list|)
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|EXTLPTR
name|extlgen
parameter_list|(
name|path
parameter_list|)
name|NAMEPTR
name|path
decl_stmt|;
block|{
specifier|register
name|EXTLPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EXPREXTL
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|leaf
operator|=
name|TRUE
expr_stmt|;
name|newguy
operator|->
name|info
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|PATH
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|EXTLPTR
name|fextlgen
parameter_list|(
name|value
parameter_list|)
name|float
name|value
decl_stmt|;
block|{
specifier|register
name|EXTLPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EXPREXTL
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|leaf
operator|=
name|TRUE
expr_stmt|;
name|newguy
operator|->
name|info
operator|.
expr|const
operator|=
name|value
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|CONST
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|NOADPTR
name|noadgen
parameter_list|(
name|defnode
parameter_list|,
name|edgevarlist
parameter_list|,
name|boxvarlist
parameter_list|)
name|PUTPTR
name|defnode
decl_stmt|;
name|VARPTR
name|edgevarlist
decl_stmt|;
name|VARPTR
name|boxvarlist
decl_stmt|;
block|{
specifier|register
name|NOADPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|NOAD
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|defnode
operator|=
name|defnode
expr_stmt|;
name|newguy
operator|->
name|edgevarlist
operator|=
name|edgevarlist
expr_stmt|;
name|newguy
operator|->
name|boxvarlist
operator|=
name|boxvarlist
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|VARPTR
name|vargen
parameter_list|(
name|name
parameter_list|,
name|re
parameter_list|,
name|deplist
parameter_list|)
name|int
name|name
decl_stmt|;
name|boolean
name|re
decl_stmt|;
name|DEPPTR
name|deplist
decl_stmt|;
block|{
specifier|register
name|VARPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|VARNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|re_name
operator|=
name|re
condition|?
name|name
else|:
operator|-
name|name
expr_stmt|;
name|newguy
operator|->
name|deplist
operator|=
name|deplist
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|DEPPTR
name|depavh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DEPPTR
name|depavt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|DEPPTR
name|depgen
parameter_list|(
name|var
parameter_list|,
name|coeff
parameter_list|)
name|VARPTR
name|var
decl_stmt|;
name|float
name|coeff
decl_stmt|;
block|{
specifier|register
name|DEPPTR
name|newguy
decl_stmt|;
if|if
condition|(
name|depavh
condition|)
block|{
name|newguy
operator|=
name|depavh
expr_stmt|;
name|depavh
operator|=
name|depavh
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|depavh
condition|)
name|depavt
operator|=
name|NULL
expr_stmt|;
name|newguy
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|DEPNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|newguy
operator|->
name|coeff
operator|=
name|coeff
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|LINEPTR
name|linegen
parameter_list|(
name|x0
parameter_list|,
name|y0
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|)
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
block|{
specifier|register
name|LINEPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|LINENODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|LINE
expr_stmt|;
name|newguy
operator|->
name|x0
operator|=
name|x0
expr_stmt|;
name|newguy
operator|->
name|y0
operator|=
name|y0
expr_stmt|;
name|newguy
operator|->
name|x1
operator|=
name|x1
expr_stmt|;
name|newguy
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|EDGEPTR
name|edgeline
parameter_list|(
name|x0
parameter_list|,
name|y0
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|)
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
block|{
name|EDGEPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EDGENODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|fax
operator|=
operator|(
name|ARCPTR
operator|)
name|NULL
expr_stmt|;
name|newguy
operator|->
name|sx
operator|=
name|x0
expr_stmt|;
name|newguy
operator|->
name|sy
operator|=
name|y0
expr_stmt|;
name|newguy
operator|->
name|ex
operator|=
name|x1
expr_stmt|;
name|newguy
operator|->
name|ey
operator|=
name|y1
expr_stmt|;
name|newguy
operator|->
name|stx
operator|=
name|newguy
operator|->
name|sx
operator|+
literal|0.2
operator|*
operator|(
name|newguy
operator|->
name|ex
operator|-
name|newguy
operator|->
name|sx
operator|)
expr_stmt|;
name|newguy
operator|->
name|sty
operator|=
name|newguy
operator|->
name|sy
operator|+
literal|0.2
operator|*
operator|(
name|newguy
operator|->
name|ey
operator|-
name|newguy
operator|->
name|sy
operator|)
expr_stmt|;
name|newguy
operator|->
name|etx
operator|=
name|newguy
operator|->
name|ex
operator|+
literal|0.2
operator|*
operator|(
name|newguy
operator|->
name|sx
operator|-
name|newguy
operator|->
name|ex
operator|)
expr_stmt|;
name|newguy
operator|->
name|ety
operator|=
name|newguy
operator|->
name|ey
operator|+
literal|0.2
operator|*
operator|(
name|newguy
operator|->
name|sy
operator|-
name|newguy
operator|->
name|ey
operator|)
expr_stmt|;
name|dprintf
literal|"opaque polygon edge: %f,%f -- %f,%f\n"
operator|,
name|x0
operator|,
name|y0
operator|,
name|x1
operator|,
name|y1
block|)
function|;
end_function

begin_return
return|return
operator|(
name|newguy
operator|)
return|;
end_return

begin_macro
unit|}  LINEPTR
name|circgen
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|CIRCPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|CIRCNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|CIRCLE
expr_stmt|;
name|newguy
operator|->
name|x0
operator|=
name|x0
expr_stmt|;
name|newguy
operator|->
name|y0
operator|=
name|y0
expr_stmt|;
name|newguy
operator|->
name|r
operator|=
name|r
expr_stmt|;
return|return
operator|(
operator|(
name|LINEPTR
operator|)
name|newguy
operator|)
return|;
block|}
end_block

begin_comment
comment|/* LINEPTR arcgen (x0, y0, x1, y1, x2, y2, theta1, theta2, radius) float x0, 	y0, 	x1, 	y1, 	x2, 	y2, 	theta1, 	theta2, 	radius; { 	register ARCPTR newguy; 	tryalloc(newguy,ARCNODE); 	newguy->kind = ARC; 	newguy->x0 = x0; 	newguy->y0 = y0; 	newguy->x1 = x1; 	newguy->y1 = y1; 	newguy->x2 = x2; 	newguy->y2 = y2; 	newguy->theta1 = theta1; 	newguy->theta2 = theta2; 	newguy->radius = radius; 	return ((LINEPTR) newguy); } */
end_comment

begin_function
name|LINEPTR
name|angularc
parameter_list|(
name|x0
parameter_list|,
name|y0
parameter_list|,
name|radius
parameter_list|,
name|theta1
parameter_list|,
name|theta2
parameter_list|)
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|theta1
decl_stmt|,
name|theta2
decl_stmt|,
name|radius
decl_stmt|;
block|{
comment|/* theta1 and theta2 should be in radians */
specifier|register
name|ARCPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|ARCNODE
argument_list|)
expr_stmt|;
name|radius
operator|=
name|fabs
argument_list|(
name|radius
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|ARC
expr_stmt|;
name|newguy
operator|->
name|x0
operator|=
name|x0
expr_stmt|;
name|newguy
operator|->
name|y0
operator|=
name|y0
expr_stmt|;
name|newguy
operator|->
name|x1
operator|=
name|x0
operator|+
name|cos
argument_list|(
name|theta1
argument_list|)
operator|*
name|radius
expr_stmt|;
name|newguy
operator|->
name|y1
operator|=
name|y0
operator|+
name|sin
argument_list|(
name|theta1
argument_list|)
operator|*
name|radius
expr_stmt|;
name|newguy
operator|->
name|x2
operator|=
name|x0
operator|+
name|cos
argument_list|(
name|theta2
argument_list|)
operator|*
name|radius
expr_stmt|;
name|newguy
operator|->
name|y2
operator|=
name|y0
operator|+
name|sin
argument_list|(
name|theta2
argument_list|)
operator|*
name|radius
expr_stmt|;
name|theta1
operator|=
name|rprin
argument_list|(
name|theta1
argument_list|)
expr_stmt|;
name|theta2
operator|=
name|rprin
argument_list|(
name|theta2
argument_list|)
expr_stmt|;
while|while
condition|(
name|theta2
operator|-
name|theta1
operator|<
name|EPSILON
condition|)
name|theta2
operator|+=
literal|2
operator|*
name|PI
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|theta2
operator|-
name|theta1
argument_list|)
operator|>
name|PI
condition|)
name|radius
operator|*=
operator|-
literal|1
expr_stmt|;
name|newguy
operator|->
name|theta1
operator|=
name|theta1
expr_stmt|;
name|newguy
operator|->
name|theta2
operator|=
name|theta2
expr_stmt|;
name|newguy
operator|->
name|radius
operator|=
name|radius
expr_stmt|;
return|return
operator|(
operator|(
name|LINEPTR
operator|)
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|LINEPTR
name|pointarc
parameter_list|(
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|x3
parameter_list|,
name|y3
parameter_list|)
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
block|{
name|float
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|,
name|E
decl_stmt|,
name|F
decl_stmt|;
name|float
name|denom
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|float
name|startang
decl_stmt|,
name|midang
decl_stmt|,
name|endang
decl_stmt|;
name|A
operator|=
operator|-
literal|2.0
operator|*
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
name|B
operator|=
operator|-
literal|2.0
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|C
operator|=
operator|-
literal|2.0
operator|*
operator|(
name|x3
operator|-
name|x2
operator|)
expr_stmt|;
name|D
operator|=
operator|-
literal|2.0
operator|*
operator|(
name|y3
operator|-
name|y2
operator|)
expr_stmt|;
name|denom
operator|=
name|A
operator|*
name|D
operator|-
name|B
operator|*
name|C
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|denom
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|dprintf
literal|"pointarc: (%f,%f) (%f,%f) (%f,%f) collinear\n"
operator|,
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
operator|,
name|x3
operator|,
name|y3
block|)
empty_stmt|;
return|return
operator|(
name|linegen
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|E
operator|=
name|x1
operator|*
name|x1
operator|+
name|y1
operator|*
name|y1
operator|-
name|x2
operator|*
name|x2
operator|-
name|y2
operator|*
name|y2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|F
operator|=
name|x2
operator|*
name|x2
operator|+
name|y2
operator|*
name|y2
operator|-
name|x3
operator|*
name|x3
operator|-
name|y3
operator|*
name|y3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|=
name|E
operator|*
name|D
operator|-
name|F
operator|*
name|B
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|/=
name|denom
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|A
operator|*
name|F
operator|-
name|C
operator|*
name|E
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|/=
name|denom
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|startang
operator|=
name|rprin
argument_list|(
name|atan2
argument_list|(
name|y1
operator|-
name|y
argument_list|,
name|x1
operator|-
name|x
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|midang
operator|=
name|rprin
argument_list|(
name|atan2
argument_list|(
name|y2
operator|-
name|y
argument_list|,
name|x2
operator|-
name|x
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|endang
operator|=
name|rprin
argument_list|(
name|atan2
argument_list|(
name|y3
operator|-
name|y
argument_list|,
name|x3
operator|-
name|x
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|angorder
argument_list|(
operator|&
name|startang
argument_list|,
name|midang
argument_list|,
operator|&
name|endang
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"pointarc: (%f,%f) (%f,%f) (%f,%f)\n"
operator|,
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
operator|,
name|x3
operator|,
name|y3
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"pointarc: (%f,%f) %f\n"
operator|,
name|x
operator|,
name|y
operator|,
name|hypot
argument_list|(
name|x1
operator|-
name|x
argument_list|,
name|y1
operator|-
name|y
argument_list|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"pointarc: /_%f -- /_%f\n"
operator|,
name|startang
operator|,
name|endang
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_return
return|return
operator|(
name|angularc
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|hypot
argument_list|(
name|x1
operator|-
name|x
argument_list|,
name|y1
operator|-
name|y
argument_list|)
argument_list|,
name|startang
argument_list|,
name|endang
argument_list|)
operator|)
return|;
end_return

begin_macro
unit|}  EDGEPTR
name|edgearc
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|x3
argument_list|,
argument|y3
argument_list|)
end_macro

begin_decl_stmt
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EDGEPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EDGENODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|fax
operator|=
operator|(
name|ARCPTR
operator|)
name|pointarc
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
if|if
condition|(
name|newguy
operator|->
name|fax
operator|->
name|kind
operator|==
name|LINE
condition|)
block|{
name|newguy
operator|->
name|sx
operator|=
name|newguy
operator|->
name|etx
operator|=
name|x1
expr_stmt|;
name|newguy
operator|->
name|sy
operator|=
name|newguy
operator|->
name|ety
operator|=
name|y1
expr_stmt|;
name|newguy
operator|->
name|ex
operator|=
name|newguy
operator|->
name|stx
operator|=
name|x3
expr_stmt|;
name|newguy
operator|->
name|ey
operator|=
name|newguy
operator|->
name|sty
operator|=
name|y3
expr_stmt|;
name|tryfree
argument_list|(
name|newguy
operator|->
name|fax
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|fax
operator|=
name|NULL
expr_stmt|;
name|newguy
operator|->
name|flipped
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newguy
operator|->
name|fax
operator|->
name|kind
operator|==
name|ARC
condition|)
block|{
name|ARCPTR
name|temp
decl_stmt|;
name|temp
operator|=
name|newguy
operator|->
name|fax
expr_stmt|;
name|newguy
operator|->
name|sx
operator|=
name|x1
expr_stmt|;
name|newguy
operator|->
name|sy
operator|=
name|y1
expr_stmt|;
name|newguy
operator|->
name|ex
operator|=
name|x3
expr_stmt|;
name|newguy
operator|->
name|ey
operator|=
name|y3
expr_stmt|;
name|newguy
operator|->
name|stx
operator|=
name|temp
operator|->
name|x0
operator|+
name|fabs
argument_list|(
name|temp
operator|->
name|radius
argument_list|)
operator|*
name|cos
argument_list|(
name|temp
operator|->
name|theta1
operator|+
literal|0.2
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|sty
operator|=
name|temp
operator|->
name|y0
operator|+
name|fabs
argument_list|(
name|temp
operator|->
name|radius
argument_list|)
operator|*
name|sin
argument_list|(
name|temp
operator|->
name|theta1
operator|+
literal|0.2
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|etx
operator|=
name|temp
operator|->
name|x0
operator|+
name|fabs
argument_list|(
name|temp
operator|->
name|radius
argument_list|)
operator|*
name|cos
argument_list|(
name|temp
operator|->
name|theta2
operator|-
literal|0.2
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|ety
operator|=
name|temp
operator|->
name|y0
operator|+
name|fabs
argument_list|(
name|temp
operator|->
name|radius
argument_list|)
operator|*
name|sin
argument_list|(
name|temp
operator|->
name|theta2
operator|-
literal|0.2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fabs
argument_list|(
name|newguy
operator|->
name|sx
operator|-
name|temp
operator|->
name|x1
argument_list|)
operator|>
name|EPSILON
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|newguy
operator|->
name|sy
operator|-
name|temp
operator|->
name|y1
argument_list|)
operator|>
name|EPSILON
operator|)
condition|)
block|{
name|newguy
operator|->
name|flipped
operator|=
name|TRUE
expr_stmt|;
name|fexch
argument_list|(
operator|&
name|newguy
operator|->
name|stx
argument_list|,
operator|&
name|newguy
operator|->
name|etx
argument_list|)
expr_stmt|;
name|fexch
argument_list|(
operator|&
name|newguy
operator|->
name|sty
argument_list|,
operator|&
name|newguy
operator|->
name|ety
argument_list|)
expr_stmt|;
block|}
else|else
name|newguy
operator|->
name|flipped
operator|=
name|FALSE
expr_stmt|;
name|dprintf
literal|"edgearc: (%f,%f) --> (%f,%f)\n"
operator|,
name|newguy
operator|->
name|sx
operator|,
name|newguy
operator|->
name|sy
operator|,
name|newguy
operator|->
name|ex
operator|,
name|newguy
operator|->
name|ey
block|)
empty_stmt|;
name|dprintf
literal|"edgearc: st (%f,%f); et (%f,%f)\n"
operator|,
name|newguy
operator|->
name|stx
operator|,
name|newguy
operator|->
name|sty
operator|,
name|newguy
operator|->
name|etx
operator|,
name|newguy
operator|->
name|ety
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"edgearc: %sflipped\n"
operator|,
name|newguy
operator|->
name|flipped
condition|?
literal|""
else|:
literal|"UN"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|} else
name|impossible
argument_list|(
literal|"edgearc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|newguy
operator|)
return|;
end_return

begin_macro
unit|}  LINEPTR
name|textgen
argument_list|(
argument|command
argument_list|,
argument|string
argument_list|,
argument|x0
argument_list|,
argument|y0
argument_list|)
end_macro

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TEXTPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|TEXTNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|STRING
expr_stmt|;
name|newguy
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|newguy
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|newguy
operator|->
name|x0
operator|=
name|x0
expr_stmt|;
name|newguy
operator|->
name|y0
operator|=
name|y0
expr_stmt|;
return|return
operator|(
operator|(
name|LINEPTR
operator|)
name|newguy
operator|)
return|;
block|}
end_block

begin_function
name|LINEPTR
name|splgen
parameter_list|(
name|knotlist
parameter_list|)
name|EXPRPTR
name|knotlist
decl_stmt|;
block|{
specifier|register
name|SPLPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|SPLNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|kind
operator|=
name|SPLINE
expr_stmt|;
name|newguy
operator|->
name|knotlist
operator|=
name|knotlist
expr_stmt|;
return|return
operator|(
operator|(
name|LINEPTR
operator|)
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|STRPTR
name|strgen
parameter_list|(
name|command
parameter_list|,
name|string
parameter_list|,
name|at
parameter_list|)
name|int
name|command
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|EXPR
name|at
decl_stmt|;
block|{
specifier|register
name|STRPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|STRNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|newguy
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|newguy
operator|->
name|at
operator|=
name|at
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|EQNPTR
name|eqngen
parameter_list|(
name|eqn
parameter_list|,
name|noad
parameter_list|)
name|EXPR
name|eqn
decl_stmt|;
name|NOADPTR
name|noad
decl_stmt|;
block|{
specifier|register
name|EQNPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|EQNNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|eqn
operator|=
name|eqn
expr_stmt|;
name|newguy
operator|->
name|noad
operator|=
name|noad
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|OPQPTR
name|opqgen
parameter_list|(
name|code
parameter_list|,
name|alpha
parameter_list|)
name|int
name|code
decl_stmt|;
name|float
name|alpha
decl_stmt|;
block|{
name|OPQPTR
name|newguy
decl_stmt|;
name|tryalloc
argument_list|(
name|newguy
argument_list|,
name|OPQNODE
argument_list|)
expr_stmt|;
name|newguy
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|newguy
operator|->
name|alpha
operator|=
name|alpha
expr_stmt|;
return|return
operator|(
name|newguy
operator|)
return|;
block|}
end_function

begin_function
name|void
name|depfree
parameter_list|(
name|doomed
parameter_list|)
name|DEPPTR
name|doomed
decl_stmt|;
block|{
specifier|register
name|DEPPTR
name|doomwalk
decl_stmt|;
if|if
condition|(
operator|!
name|doomed
operator|||
name|doomed
operator|==
name|depavt
condition|)
return|return;
if|if
condition|(
operator|!
name|depavh
condition|)
block|{
name|depavt
operator|=
name|depavh
operator|=
name|doomed
expr_stmt|;
while|while
condition|(
name|depavt
operator|->
name|next
condition|)
name|depavt
operator|=
name|depavt
operator|->
name|next
expr_stmt|;
return|return;
block|}
name|doomwalk
operator|=
name|doomed
expr_stmt|;
while|while
condition|(
name|doomwalk
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|doomwalk
operator|->
name|next
operator|==
name|depavt
condition|)
return|return;
name|doomwalk
operator|=
name|doomwalk
operator|->
name|next
expr_stmt|;
block|}
name|depavt
operator|->
name|next
operator|=
name|doomed
expr_stmt|;
name|depavt
operator|=
name|doomwalk
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nextfree
parameter_list|(
name|doomed
parameter_list|)
name|DEPPTR
name|doomed
decl_stmt|;
block|{
specifier|register
name|DEPPTR
name|walk
decl_stmt|;
while|while
condition|(
name|doomed
condition|)
block|{
name|walk
operator|=
name|doomed
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|doomed
argument_list|)
expr_stmt|;
name|doomed
operator|=
name|walk
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|namefree
parameter_list|(
name|doomed
parameter_list|)
name|NAMEPTR
name|doomed
decl_stmt|;
block|{
name|nextfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|doomed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exprlsfree
parameter_list|(
name|doomed
parameter_list|)
name|EXPRPTR
name|doomed
decl_stmt|;
block|{
specifier|register
name|EXPRPTR
name|walk
decl_stmt|;
while|while
condition|(
name|doomed
condition|)
block|{
name|walk
operator|=
name|doomed
operator|->
name|next
expr_stmt|;
name|exprfree
argument_list|(
name|doomed
operator|->
name|expr
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|doomed
argument_list|)
expr_stmt|;
name|doomed
operator|=
name|walk
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|linefree
parameter_list|(
name|doomed
parameter_list|)
name|LINEPTR
name|doomed
decl_stmt|;
block|{
name|nextfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|doomed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intlfree
parameter_list|(
name|doomed
parameter_list|)
name|INTLPTR
name|doomed
decl_stmt|;
block|{
name|depfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|doomed
operator|->
name|left
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|doomed
operator|->
name|right
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|doomed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|noadfree
parameter_list|(
name|doomed
parameter_list|)
name|NOADPTR
name|doomed
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|doomed
condition|)
return|return;
name|noadfree
argument_list|(
name|doomed
operator|->
name|son
argument_list|)
expr_stmt|;
name|noadfree
argument_list|(
name|doomed
operator|->
name|brother
argument_list|)
expr_stmt|;
name|varfree
argument_list|(
name|doomed
operator|->
name|edgevarlist
argument_list|)
expr_stmt|;
name|varfree
argument_list|(
name|doomed
operator|->
name|boxvarlist
argument_list|)
expr_stmt|;
name|linefree
argument_list|(
name|doomed
operator|->
name|linelist
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|doomed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|varfree
parameter_list|(
name|doomed
parameter_list|)
name|VARPTR
name|doomed
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|doomed
condition|)
return|return;
name|varfree
argument_list|(
name|doomed
operator|->
name|next
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
name|doomed
operator|->
name|deplist
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|doomed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exprfree
parameter_list|(
name|doomed
parameter_list|)
name|EXPR
name|doomed
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|doomed
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
operator|(
name|EXTLPTR
operator|)
name|doomed
operator|)
operator|->
name|leaf
condition|)
block|{
comment|/* convention for functions (name in left, arg list hanging 		/* off right) will ream you if not careful 		/* This also depends on the allocator not complaining if 		/* you free things twice with no intervening allocation. 		/* (see processing of alpha[x,y] in idyac.y) */
if|if
condition|(
operator|(
operator|(
name|INTLPTR
operator|)
name|doomed
operator|)
operator|->
name|oper
operator|==
name|NAME
condition|)
block|{
name|exprfree
argument_list|(
operator|(
call|(
name|EXPRPTR
call|)
argument_list|(
operator|(
name|INTLPTR
operator|)
name|doomed
argument_list|)
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
operator|(
operator|(
name|INTLPTR
operator|)
name|doomed
operator|)
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|INTLPTR
operator|)
name|doomed
operator|)
operator|->
name|oper
operator|==
literal|';'
condition|)
block|{
name|depfree
argument_list|(
call|(
name|DEPPTR
call|)
argument_list|(
operator|(
name|INTLPTR
operator|)
name|doomed
argument_list|)
operator|->
name|left
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
call|(
name|DEPPTR
call|)
argument_list|(
operator|(
name|INTLPTR
operator|)
name|doomed
argument_list|)
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprfree
argument_list|(
operator|(
operator|(
name|INTLPTR
operator|)
name|doomed
operator|)
operator|->
name|left
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
operator|(
operator|(
name|INTLPTR
operator|)
name|doomed
operator|)
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
block|}
name|tryfree
argument_list|(
name|doomed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|boxfree
parameter_list|(
name|doomed
parameter_list|)
name|BOXPTR
name|doomed
decl_stmt|;
block|{
specifier|register
name|STMTPTR
name|curstmt
decl_stmt|,
name|nextstmt
decl_stmt|;
for|for
control|(
name|curstmt
operator|=
name|doomed
operator|->
name|stmtlist
init|;
name|curstmt
condition|;
name|curstmt
operator|=
name|nextstmt
control|)
block|{
switch|switch
condition|(
name|curstmt
operator|->
name|kind
condition|)
block|{
case|case
literal|'='
case|:
name|exprfree
argument_list|(
operator|(
name|EXPR
operator|)
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONN
case|:
name|exprlsfree
argument_list|(
operator|(
name|EXPRPTR
operator|)
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING
case|:
name|exprfree
argument_list|(
operator|(
operator|(
name|PENPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|from
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
operator|(
operator|(
name|PENPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|to
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
operator|(
operator|(
name|PENPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|copies
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
operator|(
operator|(
name|PENPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|start
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
operator|(
operator|(
name|PENPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|end
argument_list|)
expr_stmt|;
name|boxfree
argument_list|(
operator|(
operator|(
name|PENPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|pen
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PUT
case|:
name|boxfree
argument_list|(
operator|(
operator|(
name|PUTPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|parm
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRAW
case|:
name|tryfree
argument_list|(
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
comment|/* if using malloc to get string space, can use the real free here */
name|free
argument_list|(
operator|(
operator|(
name|STRPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|string
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
operator|(
operator|(
name|STRPTR
operator|)
name|curstmt
operator|->
name|stmt
operator|)
operator|->
name|at
argument_list|)
expr_stmt|;
name|tryfree
argument_list|(
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPLINE
case|:
name|exprlsfree
argument_list|(
operator|(
name|EXPRPTR
operator|)
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPAQUE
case|:
name|tryfree
argument_list|(
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|BDLIST
case|:
name|exprlsfree
argument_list|(
operator|(
name|EXPRPTR
operator|)
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR
case|:
name|namefree
argument_list|(
operator|(
name|NAMEPTR
operator|)
name|curstmt
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
block|}
name|nextstmt
operator|=
name|curstmt
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|curstmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|emergency
parameter_list|()
block|{
name|nextfree
argument_list|(
name|depavh
argument_list|)
expr_stmt|;
name|depavh
operator|=
name|depavt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

