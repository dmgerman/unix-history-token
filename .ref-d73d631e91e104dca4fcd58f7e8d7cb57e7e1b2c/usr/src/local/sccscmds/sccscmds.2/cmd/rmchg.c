begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"../hdr/had.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"@(#)rmchg.c	4.4	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Program to remove a specified delta from an SCCS file, 	when invoked as 'rmdel', 	or to change the MRs and/or comments of a specified delta, 	when invoked as 'chghist'. 	(The program has two links to it, one called 'rmdel', the 	other 'chghist'.)  	The delta to be removed (or whose MRs and/or comments 	are to be changed) is specified via the 	r argument, in the form of an SID.  	If the delta is to be removed, it must be the most recent one 	in its branch in the delta tree (a so-called 'leaf' delta). 	For either function, the delta being processed must not 	have any 'delivered' MRs, and the user must have basically 	the same permissions as are required to make deltas.  	If a directory is given as an argument, each SCCS file 	within the directory will be processed as if it had been 	specifically named. If a name of '-' is given, the standard 	input will be read for a list of names of SCCS files to be 	processed. Non SCCS files are ignored. */
end_comment

begin_define
define|#
directive|define
name|COPY
value|0
end_define

begin_define
define|#
directive|define
name|NOCOPY
value|1
end_define

begin_decl_stmt
name|struct
name|sid
name|sid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|had
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|D_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|D_serial
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
extern|extern rmchg(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|int
name|Fcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Set flags for 'fatal' to issue message, call clean-up 	routine, and terminate processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|)
condition|)
name|fatal
argument_list|(
literal|"r has no sid (rc11)"
argument_list|)
expr_stmt|;
name|chksid
argument_list|(
name|sid_ab
argument_list|(
name|p
argument_list|,
operator|&
name|sid
argument_list|)
argument_list|,
operator|&
name|sid
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown key letter (cm1)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had
index|[
name|c
operator|-
literal|'a'
index|]
operator|++
condition|)
name|fatal
argument_list|(
literal|"key letter twice (cm2)"
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|num_files
operator|++
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|num_files
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"missing file arg (cm3)"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|sname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
literal|'n'
condition|)
name|p
operator|++
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|equal
argument_list|(
name|p
argument_list|,
literal|"rmdel"
argument_list|)
condition|)
name|D_type
operator|=
literal|'R'
expr_stmt|;
comment|/* invoked as 'rmdel' */
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|p
argument_list|,
literal|"chghist"
argument_list|)
condition|)
name|D_type
operator|=
literal|'D'
expr_stmt|;
comment|/* invoked as 'chghist' */
else|else
name|fatal
argument_list|(
literal|"bad invocation (rc10)"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|setsig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Change flags for 'fatal' so that it will return to this 	routine (main) instead of terminating processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|&=
operator|~
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fflags
operator||=
name|FTLJMP
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Call 'rmchg' routine for each file argument. 	*/
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|argv
index|[
name|i
index|]
condition|)
name|do_file
argument_list|(
name|p
argument_list|,
name|rmchg
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* 	Routine that actually causes processing of the delta. 	Processing on the file takes place on a 	temporary copy of the SCCS file (the x-file). 	The name of the x-file is the same as that of the 	s-file (SCCS file) with the 's.' replaced by 'x.'. 	At end of processing, the s-file is removed 	and the x-file is renamed with the name of the old s-file.  	This routine makes use of the z-file to lock out simultaneous 	updates to the SCCS file by more than one user. */
end_comment

begin_decl_stmt
unit|struct
name|packet
name|gpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see file s.h */
end_comment

begin_decl_stmt
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Mrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Comments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Domrs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|USXALLOC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* defines alloc() and free() */
end_comment

begin_macro
name|rmchg
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
name|struct
name|deltab
name|dt
decl_stmt|;
comment|/* see file s.defines.h */
name|struct
name|stats
name|stats
decl_stmt|;
comment|/* see file s.defines.h */
specifier|extern
name|char
modifier|*
name|Sflags
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|keep
decl_stmt|;
specifier|extern
name|char
name|Pgmr
index|[
literal|8
index|]
decl_stmt|;
name|int
name|fowner
decl_stmt|,
name|downer
decl_stmt|,
name|user
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
comment|/* set up to return here from 'fatal' */
return|return;
comment|/* and return to caller of rmchg */
if|if
condition|(
operator|!
name|HADR
condition|)
name|fatal
argument_list|(
literal|"missing r (rc1)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|D_type
operator|==
literal|'D'
operator|&&
name|first_time
condition|)
block|{
name|first_time
operator|=
literal|0
expr_stmt|;
name|dohist
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"file %s does not exist (rc2)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|Error
argument_list|)
expr_stmt|;
block|}
comment|/* 	Lock out any other user who may be trying to process 	the same file. 	*/
if|if
condition|(
name|lockit
argument_list|(
name|auxf
argument_list|(
name|file
argument_list|,
literal|'z'
argument_list|)
argument_list|,
literal|2
argument_list|,
name|getpid
argument_list|()
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"cannot create lock file (cm4)"
argument_list|)
expr_stmt|;
name|sinit
argument_list|(
operator|&
name|gpkt
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* initialize packet and open s-file */
comment|/* 	Flag for 'putline' routine to tell it to open x-file 	and allow writing on it. 	*/
name|gpkt
operator|.
name|p_upd
operator|=
literal|1
expr_stmt|;
comment|/* 	Save requested SID for later checking of 	permissions (by 'permiss'). 	*/
name|bcopy
argument_list|(
operator|&
name|sid
argument_list|,
operator|&
name|gpkt
operator|.
name|p_reqsid
argument_list|,
sizeof|sizeof
argument_list|(
name|gpkt
operator|.
name|p_reqsid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	Now read-in delta table. The 'dodelt' routine 	will read the table and change the delta entry of the 	requested SID to be of type 'R' if this is 	being executed as 'rmdel'; otherwise, for 'chghist', only 	the MR and comments sections will be changed  	(by 'escdodelt', called by 'dodelt'). 	*/
if|if
condition|(
name|dodelt
argument_list|(
operator|&
name|gpkt
argument_list|,
operator|&
name|stats
argument_list|,
operator|&
name|sid
argument_list|,
name|D_type
argument_list|)
operator|==
literal|0
condition|)
name|fmterr
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
comment|/* 	Get serial number of requested SID from 	delta table just processed. 	*/
name|D_serial
operator|=
name|sidtoser
argument_list|(
operator|&
name|gpkt
operator|.
name|p_reqsid
argument_list|,
operator|&
name|gpkt
argument_list|)
expr_stmt|;
comment|/* 	If SID has not been zeroed (by 'dodelt'), 	SID was not found in file. 	*/
if|if
condition|(
name|sid
operator|.
name|s_rel
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"nonexistent sid (rc3)"
argument_list|)
expr_stmt|;
comment|/* 	Replace 'sid' with original 'sid' 	requested. 	*/
name|bcopy
argument_list|(
operator|&
name|gpkt
operator|.
name|p_reqsid
argument_list|,
operator|&
name|sid
argument_list|,
sizeof|sizeof
argument_list|(
name|gpkt
operator|.
name|p_reqsid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	Now check permissions. 	*/
name|finduser
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|doflags
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|permiss
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
comment|/* 	Check that user is either owner of file or 	directory, or is one who made the delta. 	*/
name|fstat
argument_list|(
name|fileno
argument_list|(
name|gpkt
operator|.
name|p_iop
argument_list|)
argument_list|,
operator|&
name|Statbuf
argument_list|)
expr_stmt|;
name|fowner
operator|=
name|Statbuf
operator|.
name|st_uid
operator|&
literal|0377
expr_stmt|;
name|copy
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* temporary for dname() */
if|if
condition|(
name|stat
argument_list|(
name|dname
argument_list|(
name|line
argument_list|)
argument_list|,
operator|&
name|Statbuf
argument_list|)
condition|)
name|downer
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|downer
operator|=
name|Statbuf
operator|.
name|st_uid
operator|&
literal|0377
expr_stmt|;
name|user
operator|=
name|getuid
argument_list|()
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
name|user
operator|!=
name|fowner
operator|||
name|user
operator|!=
name|downer
condition|)
if|if
condition|(
operator|!
name|equal
argument_list|(
name|Pgmr
argument_list|,
name|logname
argument_list|()
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"you are neither owner nor '%s' (rc4)"
argument_list|,
name|Pgmr
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|Error
argument_list|)
expr_stmt|;
block|}
comment|/* 	For 'rmdel', check that delta being removed is a 	'leaf' delta, and if ok, 	process the body. 	*/
if|if
condition|(
name|D_type
operator|==
literal|'R'
condition|)
block|{
for|for
control|(
name|n
operator|=
name|maxser
argument_list|(
operator|&
name|gpkt
argument_list|)
init|;
name|n
operator|>
name|D_serial
condition|;
name|n
operator|--
control|)
block|{
name|p
operator|=
operator|&
name|gpkt
operator|.
name|p_idel
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|i_pred
operator|==
name|D_serial
condition|)
name|fatal
argument_list|(
literal|"not a 'leaf' delta (rc5)"
argument_list|)
expr_stmt|;
block|}
comment|/* 		   For 'rmdel' check that the sid requested is 		   not contained in p-file, should a p-file 		   exist. 		*/
if|if
condition|(
name|exists
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'p'
argument_list|)
argument_list|)
condition|)
name|rdpfile
argument_list|(
operator|&
name|gpkt
argument_list|,
operator|&
name|sid
argument_list|)
expr_stmt|;
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|EUSERTXT
argument_list|,
name|COPY
argument_list|)
expr_stmt|;
name|keep
operator|=
name|YES
expr_stmt|;
name|gpkt
operator|.
name|p_chkeof
operator|=
literal|1
expr_stmt|;
comment|/* set EOF is ok */
while|while
condition|(
operator|(
name|p
operator|=
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|CTLCHAR
condition|)
block|{
name|cp
operator|=
name|p
operator|++
expr_stmt|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 				Convert serial number to binary. 				*/
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|satoi
argument_list|(
name|p
argument_list|,
operator|&
name|n
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
name|fmterr
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|D_serial
condition|)
block|{
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|INS
condition|)
name|keep
operator|=
name|NO
expr_stmt|;
else|else
name|keep
operator|=
name|YES
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|keep
operator|==
name|NO
condition|)
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		This is for invocation as 'chghist'. 		Check MRs. 		*/
if|if
condition|(
name|Mrs
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|Sflags
index|[
name|VALFLAG
operator|-
literal|'a'
index|]
operator|)
condition|)
name|fatal
argument_list|(
literal|"MRs not allowed (rc6)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
name|valmrs
argument_list|(
operator|&
name|gpkt
argument_list|,
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"inavlid MRs (rc7)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Sflags
index|[
name|VALFLAG
operator|-
literal|'a'
index|]
condition|)
name|fatal
argument_list|(
literal|"MRs required (rc8)"
argument_list|)
expr_stmt|;
comment|/* 		Indicate that EOF at this point is ok, and 		flush rest of s-file to x-file. 		*/
name|gpkt
operator|.
name|p_chkeof
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
condition|)
empty_stmt|;
block|}
name|flushline
argument_list|(
operator|&
name|gpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	Delete old s-file, change x-file name to s-file. 	*/
name|rename
argument_list|(
name|auxf
argument_list|(
operator|&
name|gpkt
argument_list|,
literal|'x'
argument_list|)
argument_list|,
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|clean_up
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|escdodelt
argument_list|(
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|First_esc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|long
name|Timenow
decl_stmt|;
if|if
condition|(
name|D_type
operator|==
literal|'D'
operator|&&
name|First_esc
condition|)
block|{
comment|/* chghist, first time */
name|First_esc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Mrs
condition|)
name|putmrs
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c "
argument_list|,
name|CTLCHAR
argument_list|,
name|COMMENTS
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|Comments
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c "
argument_list|,
name|CTLCHAR
argument_list|,
name|COMMENTS
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
literal|"*** CHANGED *** "
argument_list|)
expr_stmt|;
name|date_ba
argument_list|(
operator|&
name|Timenow
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* get date and time */
name|putline
argument_list|(
name|pkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" %s\n"
argument_list|,
name|logname
argument_list|()
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
operator|==
name|MRNUM
condition|)
block|{
name|p
operator|=
operator|&
name|pkt
operator|->
name|p_line
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|2
operator|)
operator|==
name|DELIVER
condition|)
name|fatal
argument_list|(
literal|"delta specified has delivered MR (rc9)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|D_type
operator|==
literal|'D'
condition|)
comment|/* turn MRs into comments */
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
operator|=
name|COMMENTS
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putmrs
argument_list|(
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
name|str
index|[
literal|64
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Varg
index|[]
decl_stmt|;
for|for
control|(
name|argv
operator|=
operator|&
name|Varg
index|[
name|VSTART
index|]
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%c%c %s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|MRNUM
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clean_up
argument_list|()
end_macro

begin_block
block|{
name|xrm
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpkt
operator|.
name|p_file
index|[
literal|0
index|]
condition|)
name|unlockit
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'z'
argument_list|)
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'x'
argument_list|)
argument_list|)
condition|)
name|xunlink
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'x'
argument_list|)
argument_list|)
expr_stmt|;
name|xfreeall
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdpfile
argument_list|(
name|pkt
argument_list|,
name|sp
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sid
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|pfile
name|pf
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|in
operator|=
name|xfopen
argument_list|(
name|auxf
argument_list|(
name|pkt
operator|->
name|p_file
argument_list|,
literal|'p'
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|pf_ab
argument_list|(
name|line
argument_list|,
operator|&
name|pf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_rel
operator|==
name|pf
operator|.
name|pf_gsid
operator|.
name|s_rel
operator|&&
name|sp
operator|->
name|s_lev
operator|==
name|pf
operator|.
name|pf_gsid
operator|.
name|s_lev
operator|&&
name|sp
operator|->
name|s_br
operator|==
name|pf
operator|.
name|pf_gsid
operator|.
name|s_br
operator|&&
name|sp
operator|->
name|s_seq
operator|==
name|pf
operator|.
name|pf_gsid
operator|.
name|s_seq
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"being edited -- sid is in p-file (rc12)"
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

