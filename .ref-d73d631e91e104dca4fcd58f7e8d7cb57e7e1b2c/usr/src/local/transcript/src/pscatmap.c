begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: pscatmap.c,v 2.1 85/11/24 11:50:07 shore Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pscatmap.c  *  * Copyright (C) 1985 Adobe Systems Incorporated  *  * Build font width files for troff and correspondence tables  * for pscat.  *  * Edit History:  * Andrew Shore: Sat Nov  9 15:37:04 1985  * End Edit History.  *  * The correspondence tables are intended to be created by humans for  * describing a set of 4 fonts to be used by troff: detailing the  * mapping from troff& C/A/T codes to output actions for pscat  * These actions take one of three forms:  *	PFONT	- map to a character in a PostScript font  *	PLIG	- map to a "fake" ligature  *	PPROC	- map to a named PostScript procedure  *	PNONE	- no action  *  * PFONT is straightforward, the mapping specifies which character in  * which PostScript font is desired and the character width is  * collected from the PostScript "afm" font metrics file format.  * Note that ascender and descender information is "wired in" to the code;  * it might be a better idea to "compute" it from the character  * bounding box information.  *  * PLIG is provided so that the correct width for the ligature may  * be "computed" by this program, rather than hand done by the user.  * There are 3 ligature types:  *	0126	- build "ff" out of "f" and "f"  *	0131	- build "ffi" out of "f" and "fi"  *	0130	- build "ffl" out of "f" and "fl"  * This list should probably be expanded to span the space.  *  * PPROC provides a general callback mechanism so that users can  * create and character definition with a PostScript procedure.  * The procedures are "named" with user-specified numbers, and are  * called with all information available to them (current position,  * font size, intended width, railmag, ...).  Such procedures are used  * for troff characters not in any PostScript font (rules, boxes,  * constructed braces, etc.), but may also be used as a general  * "escape hatch" for incorporating ANY PostScript routine into a  * troff document -- a logo, a scanned image, etc.  The exact  * calling rules are:  *	an absolute moveto is performed to the position for this character  *	The following numbers are pushed on the PS stack:  *	pointsize  *	troff character code  *	"railmag"  *	character width  *	procedure "number"  *	x offset  *	y offset  *	width  *  *	then a procedure named "PSn" where n is the procedure number  *	is executed.  It is that procedure's responsibility to image  *	the character and move by the appropriate width.  *  * RCSLOG:  * $Log:	pscatmap.c,v $  * Revision 2.1  85/11/24  11:50:07  shore  * Product Release 2.0  *   * Revision 1.3  85/11/20  00:32:45  shore  * support for System V  * short names, non ".c" output, better arith.  *   * Revision 1.2  85/05/14  11:24:04  shore  *   *   *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_include
include|#
directive|include
file|"action.h"
end_include

begin_define
define|#
directive|define
name|LFONT
value|1
end_define

begin_define
define|#
directive|define
name|LMAP
value|2
end_define

begin_define
define|#
directive|define
name|LNONE
value|3
end_define

begin_decl_stmt
name|private
name|char
name|linebuf
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|libdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for AFM files */
end_comment

begin_decl_stmt
name|private
name|struct
name|chAction
name|chAction
index|[]
init|=
block|{
name|PFONT
block|,
literal|"PFONT"
block|,
comment|/* character in PostScript font */
name|PLIG
block|,
literal|"PLIG"
block|,
comment|/* fake ligatures: ff ffi ffl */
name|PPROC
block|,
literal|"PPROC"
block|,
comment|/* PostScript procedure outcall */
name|PNONE
block|,
literal|"0"
block|,
comment|/* null action */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXFONTS
value|25
end_define

begin_decl_stmt
name|private
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|font
block|{
name|char
name|mapname
index|[
literal|20
index|]
decl_stmt|;
comment|/* short name in map file e.g., "ROMAN" */
name|char
name|afmname
index|[
literal|80
index|]
decl_stmt|;
comment|/* name of AFM file for this font (in map file) */
name|char
name|psname
index|[
literal|80
index|]
decl_stmt|;
comment|/* PS font name from AFM file */
name|int
name|widths
index|[
literal|256
index|]
decl_stmt|;
comment|/* PostScript widths of encoded chars (1000/em) */
comment|/* more here */
block|}
name|fonts
index|[
name|MAXFONTS
index|]
struct|;
end_struct

begin_decl_stmt
name|private
name|char
name|faces
index|[]
init|=
literal|"RIBS0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* order important! */
end_comment

begin_decl_stmt
name|private
name|char
name|familyname
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|facenames
index|[
literal|4
index|]
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* there should be on the order of 4 * 128 characters, so 1000 is generous */
end_comment

begin_define
define|#
directive|define
name|MAXCHARS
value|1000
end_define

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|ctab
block|{
name|int
name|trcode
decl_stmt|;
comment|/* troff char code */
name|int
name|catcode
decl_stmt|;
comment|/* CAT char code */
name|int
name|wid
decl_stmt|;
comment|/* table-driven width */
name|int
name|action
decl_stmt|;
comment|/* action type */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* x and y offset */
name|int
name|font
decl_stmt|;
comment|/* PostScript font */
name|int
name|pschar
decl_stmt|;
comment|/* PS character code */
name|int
name|pswidth
decl_stmt|;
comment|/* PS width (/1000) */
name|char
modifier|*
name|descr
decl_stmt|;
comment|/* short print description */
block|}
name|ctab
index|[
name|MAXCHARS
index|]
struct|;
end_struct

begin_decl_stmt
name|private
name|int
name|nchars
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|BuildTable
parameter_list|()
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|gotfamily
decl_stmt|,
name|gotfaces
decl_stmt|,
name|gotfonts
decl_stmt|,
name|gotmap
decl_stmt|;
name|gotfamily
operator|=
name|gotfaces
operator|=
name|gotfonts
operator|=
name|gotmap
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* strip off newline */
if|if
condition|(
operator|(
name|c
operator|=
name|INDEX
argument_list|(
name|linebuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line too long \"%s\"\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* ignore blank or comment (%) lines */
if|if
condition|(
operator|(
operator|*
name|linebuf
operator|==
literal|'%'
operator|)
operator|||
operator|(
operator|*
name|linebuf
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|linebuf
operator|==
literal|'@'
condition|)
block|{
comment|/* "command" line */
comment|/* printf("C: %s\n", linebuf); */
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|linebuf
index|[
literal|1
index|]
argument_list|,
literal|"FAMILYNAME"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|linebuf
argument_list|,
literal|"@FAMILYNAME %s"
argument_list|,
name|familyname
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad familyname %s\n"
argument_list|,
name|familyname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gotfamily
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|linebuf
index|[
literal|1
index|]
argument_list|,
literal|"FACENAMES"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|linebuf
argument_list|,
literal|"@FACENAMES %s %s %s %s"
argument_list|,
name|facenames
index|[
literal|0
index|]
argument_list|,
name|facenames
index|[
literal|1
index|]
argument_list|,
name|facenames
index|[
literal|2
index|]
argument_list|,
name|facenames
index|[
literal|3
index|]
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"must be four facenames\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gotfaces
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|linebuf
index|[
literal|1
index|]
argument_list|,
literal|"BEGINFONTS"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|gotfamily
operator|)
operator|||
operator|(
operator|!
name|gotfaces
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FAMILYNAME and FACENAMES must come before BEGINFONTS\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|strcpy
argument_list|(
name|fonts
index|[
literal|0
index|]
operator|.
name|mapname
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|fonts
index|[
literal|0
index|]
operator|.
name|afmname
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|fonts
index|[
literal|0
index|]
operator|.
name|psname
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
name|nfonts
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|LFONT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|linebuf
index|[
literal|1
index|]
argument_list|,
literal|"ENDFONTS"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gotfonts
operator|++
expr_stmt|;
name|status
operator|=
name|LNONE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|linebuf
index|[
literal|1
index|]
argument_list|,
literal|"BEGINMAP"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|gotfonts
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BEGINFONTS/ENDFONTS must come before map\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|LMAP
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|linebuf
index|[
literal|1
index|]
argument_list|,
literal|"ENDMAP"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|LNONE
expr_stmt|;
name|gotmap
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|LFONT
case|:
name|GetFont
argument_list|()
expr_stmt|;
break|break;
case|case
name|LMAP
case|:
name|GetMap
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|gotmap
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing @ENDMAP\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|GetFont
parameter_list|()
block|{
name|char
modifier|*
name|eqp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|afmpath
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|char
name|shortname
index|[
literal|40
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|eqp
operator|=
name|INDEX
argument_list|(
name|linebuf
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad FONTS line:%s\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|eqp
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fonts
index|[
name|i
index|]
operator|.
name|mapname
argument_list|,
name|linebuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"duplicate entry for font %s\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfonts
operator|>=
name|MAXFONTS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many FONTS\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|>
operator|(
sizeof|sizeof
name|fonts
index|[
literal|0
index|]
operator|.
name|mapname
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FONT name too long %s\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|eqp
argument_list|)
operator|>
operator|(
sizeof|sizeof
name|fonts
index|[
literal|0
index|]
operator|.
name|afmname
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FONT name too long %s\n"
argument_list|,
name|eqp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|strcpy
argument_list|(
name|fonts
index|[
name|nfonts
index|]
operator|.
name|mapname
argument_list|,
name|linebuf
argument_list|)
decl_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|fonts
index|[
name|nfonts
index|]
operator|.
name|afmname
argument_list|,
name|eqp
argument_list|)
decl_stmt|;
comment|/* read the font's .afm file to get real widths */
if|if
condition|(
operator|*
name|eqp
operator|==
literal|'/'
condition|)
block|{
name|VOIDC
name|strcpy
argument_list|(
name|afmpath
argument_list|,
name|eqp
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|VOIDC
name|strcpy
argument_list|(
name|afmpath
argument_list|,
name|libdir
argument_list|)
decl_stmt|;
name|VOIDC
name|strcat
argument_list|(
name|afmpath
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|mapname
argument_list|(
name|eqp
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
name|VOIDC
name|strcat
argument_list|(
name|afmpath
argument_list|,
name|shortname
argument_list|)
decl_stmt|;
else|#
directive|else
name|VOIDC
name|strcat
argument_list|(
name|afmpath
argument_list|,
name|eqp
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|VOIDC
name|strcat
argument_list|(
name|afmpath
argument_list|,
literal|".afm"
argument_list|)
decl_stmt|;
block|}
name|ReadAFM
argument_list|(
name|afmpath
argument_list|)
expr_stmt|;
name|nfonts
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|private
name|ReadAFM
parameter_list|(
name|afmfile
parameter_list|)
name|char
modifier|*
name|afmfile
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|FILE
modifier|*
name|afm
decl_stmt|;
name|int
name|gotMetrics
decl_stmt|,
name|gotName
decl_stmt|,
name|inChars
decl_stmt|,
name|ccode
decl_stmt|,
name|cwidth
decl_stmt|;
name|char
name|afmbuf
index|[
literal|1000
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|afm
operator|=
name|fopen
argument_list|(
name|afmfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open afm file %s\n"
argument_list|,
name|afmfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|inChars
operator|=
name|gotMetrics
operator|=
name|gotName
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|afmbuf
argument_list|,
sizeof|sizeof
name|afmbuf
argument_list|,
name|afm
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* strip off newline */
if|if
condition|(
operator|(
name|c
operator|=
name|INDEX
argument_list|(
name|afmbuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AFM line too long %s\n"
argument_list|,
name|afmbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* ignore blank lines */
if|if
condition|(
operator|*
name|afmbuf
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"StartFontMetrics 2.0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gotMetrics
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|afmbuf
argument_list|,
literal|"FontName "
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VOIDC
name|sscanf
argument_list|(
name|afmbuf
argument_list|,
literal|"FontName %s"
argument_list|,
name|fonts
index|[
name|nfonts
index|]
operator|.
name|psname
argument_list|)
decl_stmt|;
name|gotName
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"EndCharMetrics"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|inChars
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AFM: %s without StartCharMetrics\n"
argument_list|,
name|afmbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|inChars
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"StartCharMetrics"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inChars
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|inChars
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|afmbuf
argument_list|,
literal|"C %d ; WX %d ;"
argument_list|,
operator|&
name|ccode
argument_list|,
operator|&
name|cwidth
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad Character in AFM file %s\n"
argument_list|,
name|afmbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccode
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* skip unencoded chars */
if|if
condition|(
name|ccode
operator|>
literal|255
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad Character Code skipped %s\n"
argument_list|,
name|afmbuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fonts
index|[
name|nfonts
index|]
operator|.
name|widths
index|[
name|ccode
index|]
operator|=
name|cwidth
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|inChars
operator|!=
literal|2
operator|)
operator|||
operator|(
operator|!
name|gotMetrics
operator|)
operator|||
operator|(
operator|!
name|gotName
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"improper AFM file %s\n"
argument_list|,
name|afmfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|fclose
argument_list|(
name|afm
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|private
name|GetMap
parameter_list|()
block|{
name|int
name|trcode
decl_stmt|;
name|char
name|trfont
decl_stmt|;
name|int
name|catcode
decl_stmt|;
name|int
name|wid
decl_stmt|;
name|char
name|action
index|[
literal|10
index|]
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|char
name|psfont
index|[
literal|20
index|]
decl_stmt|;
name|int
name|pschar
decl_stmt|;
name|char
name|descr
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|trface
decl_stmt|;
comment|/* 0 - 3  : R I B S */
name|int
name|pf
decl_stmt|;
name|struct
name|ctab
modifier|*
name|ch
decl_stmt|;
name|struct
name|chAction
modifier|*
name|act
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|linebuf
argument_list|,
literal|"%o %c %o %d %s %d %d %s %o \"%[^\"]\""
argument_list|,
operator|&
name|trcode
argument_list|,
operator|&
name|trfont
argument_list|,
operator|&
name|catcode
argument_list|,
operator|&
name|wid
argument_list|,
name|action
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|psfont
argument_list|,
operator|&
name|pschar
argument_list|,
name|descr
argument_list|)
operator|!=
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad line %s"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
block|}
comment|/* verify the integrity of the data we got */
if|if
condition|(
operator|(
name|fp
operator|=
name|INDEX
argument_list|(
name|faces
argument_list|,
name|trfont
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad face code in %s\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|trface
operator|=
name|fp
operator|-
name|faces
expr_stmt|;
for|for
control|(
name|act
operator|=
name|chAction
init|;
name|act
operator|->
name|actName
operator|!=
literal|0
condition|;
name|act
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|action
argument_list|,
name|act
operator|->
name|actName
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|act
operator|->
name|actName
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad action in %s\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pf
operator|=
literal|0
init|;
name|pf
operator|<
name|nfonts
condition|;
name|pf
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fonts
index|[
name|pf
index|]
operator|.
name|mapname
argument_list|,
name|psfont
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|gotfont
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad font (%s) name %s\n"
argument_list|,
name|linebuf
argument_list|,
name|psfont
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|gotfont
label|:
if|if
condition|(
name|nchars
operator|>=
name|MAXCHARS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many character definitions\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
operator|&
name|ctab
index|[
name|nchars
index|]
expr_stmt|;
name|ch
operator|->
name|trcode
operator|=
name|trcode
expr_stmt|;
name|ch
operator|->
name|catcode
operator|=
operator|(
name|trface
operator|<<
literal|7
operator|)
operator||
name|catcode
expr_stmt|;
name|ch
operator|->
name|action
operator|=
name|act
operator|->
name|actCode
expr_stmt|;
name|ch
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|ch
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|ch
operator|->
name|font
operator|=
name|pf
expr_stmt|;
name|ch
operator|->
name|pschar
operator|=
name|pschar
expr_stmt|;
if|if
condition|(
name|descr
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|->
name|descr
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|descr
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|strcpy
argument_list|(
name|ch
operator|->
name|descr
argument_list|,
name|descr
argument_list|)
decl_stmt|;
block|}
comment|/* calculate width in cat units (432 per inch) of 6 pt      * character (the way troff wants them).      * 6 pts = 36 cat units      */
if|if
condition|(
name|ch
operator|->
name|action
operator|==
name|PLIG
condition|)
block|{
comment|/* fake ligature, fake width */
switch|switch
condition|(
name|catcode
condition|)
block|{
case|case
literal|0126
case|:
comment|/* ff = f f */
name|ch
operator|->
name|pswidth
operator|=
name|fonts
index|[
name|pf
index|]
operator|.
name|widths
index|[
literal|'f'
index|]
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|0131
case|:
comment|/* ffi = f fi */
name|ch
operator|->
name|pswidth
operator|=
name|fonts
index|[
name|pf
index|]
operator|.
name|widths
index|[
literal|'f'
index|]
operator|+
name|fonts
index|[
name|pf
index|]
operator|.
name|widths
index|[
literal|0256
index|]
expr_stmt|;
break|break;
case|case
literal|0130
case|:
comment|/* ffl = f fl */
name|ch
operator|->
name|pswidth
operator|=
name|fonts
index|[
name|pf
index|]
operator|.
name|widths
index|[
literal|'f'
index|]
operator|+
name|fonts
index|[
name|pf
index|]
operator|.
name|widths
index|[
literal|0257
index|]
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown ligature 0%o\n"
argument_list|,
name|catcode
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ch
operator|->
name|pswidth
operator|=
name|fonts
index|[
name|pf
index|]
operator|.
name|widths
index|[
name|pschar
index|]
expr_stmt|;
block|}
name|ch
operator|->
name|wid
operator|=
operator|(
name|wid
operator|>=
literal|0
operator|)
condition|?
name|wid
else|:
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|float
operator|)
name|ch
operator|->
name|pswidth
operator|*
literal|36.0
operator|)
operator|/
literal|1000.0
operator|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|wid
operator|>
literal|255
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Scaled width too big!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nchars
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|private
name|int
name|compCTent
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|ctab
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|catcode
operator|<
name|b
operator|->
name|catcode
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|catcode
operator|>
name|b
operator|->
name|catcode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|private
name|WriteTable
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|curcode
decl_stmt|;
name|struct
name|ctab
modifier|*
name|ct
decl_stmt|;
name|struct
name|map
name|map
decl_stmt|,
name|emptymap
decl_stmt|;
name|char
name|outname
index|[
literal|84
index|]
decl_stmt|;
name|FILE
modifier|*
name|mapfile
decl_stmt|;
comment|/* write out font mapping */
if|if
condition|(
name|familyname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No FAMILYNAME specified!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|strcpy
argument_list|(
name|outname
argument_list|,
name|familyname
argument_list|)
decl_stmt|;
name|VOIDC
name|strcat
argument_list|(
name|outname
argument_list|,
literal|".ct"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mapfile
operator|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open output file %s\n"
argument_list|,
name|mapfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|putw
argument_list|(
name|nfonts
argument_list|,
name|mapfile
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|VOIDC
name|fwrite
argument_list|(
name|fonts
index|[
name|i
index|]
operator|.
name|psname
argument_list|,
sizeof|sizeof
name|fonts
index|[
literal|0
index|]
operator|.
name|psname
argument_list|,
literal|1
argument_list|,
name|mapfile
argument_list|)
decl_stmt|;
block|}
comment|/* sort ctab by catcode */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ctab
argument_list|,
name|nchars
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctab
argument_list|)
argument_list|,
name|compCTent
argument_list|)
expr_stmt|;
comment|/* write it out */
name|VOIDC
name|putw
argument_list|(
name|ctab
index|[
name|nchars
operator|-
literal|1
index|]
operator|.
name|catcode
argument_list|,
name|mapfile
argument_list|)
decl_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|mapfile
argument_list|)
decl_stmt|;
name|emptymap
operator|.
name|wid
operator|=
name|emptymap
operator|.
name|x
operator|=
name|emptymap
operator|.
name|y
operator|=
name|emptymap
operator|.
name|font
operator|=
name|emptymap
operator|.
name|pschar
operator|=
name|emptymap
operator|.
name|action
operator|=
name|emptymap
operator|.
name|pswidth
operator|=
literal|0
expr_stmt|;
name|ct
operator|=
operator|&
name|ctab
index|[
literal|0
index|]
expr_stmt|;
name|curcode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCHARS
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|curcode
operator|<
name|ct
operator|->
name|catcode
condition|)
block|{
name|VOIDC
name|write
argument_list|(
name|fileno
argument_list|(
name|mapfile
argument_list|)
argument_list|,
operator|&
name|emptymap
argument_list|,
sizeof|sizeof
name|map
argument_list|)
decl_stmt|;
name|curcode
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ct
operator|->
name|catcode
operator|<
name|curcode
operator|)
operator|&&
operator|(
name|ct
operator|<=
operator|&
name|ctab
index|[
name|nchars
index|]
operator|)
condition|)
block|{
name|ct
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|>=
operator|&
name|ctab
index|[
name|nchars
index|]
condition|)
break|break;
name|map
operator|.
name|wid
operator|=
name|ct
operator|->
name|wid
expr_stmt|;
name|map
operator|.
name|pswidth
operator|=
name|ct
operator|->
name|pswidth
expr_stmt|;
name|map
operator|.
name|x
operator|=
name|ct
operator|->
name|x
expr_stmt|;
name|map
operator|.
name|y
operator|=
name|ct
operator|->
name|y
expr_stmt|;
name|map
operator|.
name|action
operator|=
name|ct
operator|->
name|action
expr_stmt|;
name|map
operator|.
name|pschar
operator|=
name|ct
operator|->
name|pschar
expr_stmt|;
name|map
operator|.
name|font
operator|=
name|ct
operator|->
name|font
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fileno
argument_list|(
name|mapfile
argument_list|)
argument_list|,
operator|&
name|map
argument_list|,
sizeof|sizeof
name|map
argument_list|)
decl_stmt|;
name|ct
operator|++
expr_stmt|;
name|curcode
operator|++
expr_stmt|;
block|}
name|VOIDC
name|fclose
argument_list|(
name|mapfile
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* called by qsort to compare troff codes */
end_comment

begin_comment
comment|/* if troff codes are the same, use facecode to decide */
end_comment

begin_function
name|private
name|compTRcode
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|ctab
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|a
operator|->
name|trcode
operator|-
name|b
operator|->
name|trcode
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|a
operator|->
name|catcode
operator|>>
literal|7
operator|)
operator|-
operator|(
name|b
operator|->
name|catcode
operator|>>
literal|7
operator|)
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_function
name|private
name|DoWidths
parameter_list|()
block|{
name|int
name|f
decl_stmt|;
comment|/* font index 0-3 */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ctab
argument_list|,
name|nchars
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctab
argument_list|)
argument_list|,
name|compTRcode
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|4
condition|;
name|f
operator|++
control|)
block|{
name|dofont
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ASCENDER
value|0200
end_define

begin_define
define|#
directive|define
name|DESCENDER
value|0100
end_define

begin_comment
comment|/* note that both is 0300 */
end_comment

begin_comment
comment|/* ascenders are:  *	b d f h i j k l t beta gamma delta zeta theta lambda xi  *	phi psi Gamma Delta  Theta Lambda Xi Pi Sigma  *	Upsilon Phi Psi Omega gradient  */
end_comment

begin_decl_stmt
name|private
name|char
name|Ascenders
index|[]
init|=
literal|"bdfhijklt\231\232\233\235\237\242\245\254\256\260\261\262\263\264\264\265\266\270\271\272\273\326"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* descenders are:  *	g j p q y beta zeta eta mu xi  *	rho phi chi psi terminal-sigma  */
end_comment

begin_decl_stmt
name|private
name|char
name|Descenders
index|[]
init|=
literal|"gjpqy\231\235\236\243\245\250\254\255\256\275"
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|dofont
parameter_list|(
name|fontno
parameter_list|)
name|int
name|fontno
decl_stmt|;
comment|/* troff font number 0-3 */
block|{
name|char
name|ftfilename
index|[
literal|100
index|]
decl_stmt|;
name|FILE
modifier|*
name|ftfile
decl_stmt|;
comment|/* generated font widths file */
name|int
name|wid
decl_stmt|,
name|curcode
decl_stmt|;
name|struct
name|ctab
modifier|*
name|ct
decl_stmt|,
modifier|*
name|cc
decl_stmt|;
name|int
name|asde
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|VOIDC
name|sprintf
argument_list|(
name|ftfilename
argument_list|,
literal|"ft%s"
argument_list|,
name|facenames
index|[
name|fontno
index|]
argument_list|)
decl_stmt|;
else|#
directive|else
name|VOIDC
name|sprintf
argument_list|(
name|ftfilename
argument_list|,
literal|"ft%s.c"
argument_list|,
name|facenames
index|[
name|fontno
index|]
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ftfile
operator|=
name|fopen
argument_list|(
name|ftfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ftfilename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BSD
name|fprintf
argument_list|(
name|ftfile
argument_list|,
literal|"/* troff width file for %s - %s (%c) */\n"
argument_list|,
name|familyname
argument_list|,
name|facenames
index|[
name|fontno
index|]
argument_list|,
name|faces
index|[
name|fontno
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftfile
argument_list|,
literal|"char ft%s[256-32] = {\n"
argument_list|,
name|facenames
index|[
name|fontno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* write out entry for each troff character code */
comment|/* codes 0-31 (decimal) are not used */
comment|/* the first interesting code is 32 (040) - space */
name|ct
operator|=
name|ctab
expr_stmt|;
for|for
control|(
name|curcode
operator|=
literal|32
init|;
name|curcode
operator|<
literal|256
condition|;
name|curcode
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|ct
operator|<
operator|&
name|ctab
index|[
name|nchars
index|]
operator|)
operator|&&
operator|(
name|ct
operator|->
name|trcode
operator|<
name|curcode
operator|)
operator|||
operator|(
operator|(
name|ct
operator|->
name|trcode
operator|==
name|curcode
operator|)
operator|&&
operator|(
operator|(
name|ct
operator|->
name|catcode
operator|>>
literal|7
operator|)
operator|<
name|fontno
operator|)
operator|)
condition|)
block|{
name|ct
operator|++
expr_stmt|;
block|}
name|asde
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ct
operator|>=
operator|&
name|ctab
index|[
name|nchars
index|]
operator|)
operator|||
operator|(
name|curcode
operator|!=
name|ct
operator|->
name|trcode
operator|)
operator|||
operator|(
operator|(
name|ct
operator|->
name|catcode
operator|>>
literal|7
operator|)
operator|!=
name|fontno
operator|)
condition|)
block|{
comment|/* not found */
name|wid
operator|=
literal|0
expr_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wid
operator|=
name|ct
operator|->
name|wid
expr_stmt|;
name|cc
operator|=
name|ct
expr_stmt|;
comment|/* calculate ascender/descender info (heuristic) */
if|if
condition|(
operator|(
operator|(
name|curcode
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|curcode
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
name|curcode
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|curcode
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
name|asde
operator||=
name|ASCENDER
expr_stmt|;
if|if
condition|(
name|INDEX
argument_list|(
name|Ascenders
argument_list|,
name|curcode
argument_list|)
condition|)
name|asde
operator||=
name|ASCENDER
expr_stmt|;
if|if
condition|(
name|INDEX
argument_list|(
name|Descenders
argument_list|,
name|curcode
argument_list|)
condition|)
name|asde
operator||=
name|DESCENDER
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSV
comment|/* for system V we write a binary file of the width bytes */
name|putc
argument_list|(
literal|0377
operator|&
operator|(
name|wid
operator|+
name|asde
operator|)
argument_list|,
name|ftfile
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* for BSD we write a "c" array to be compiled */
name|fprintf
argument_list|(
name|ftfile
argument_list|,
literal|"%d"
argument_list|,
name|wid
argument_list|)
expr_stmt|;
if|if
condition|(
name|asde
condition|)
name|fprintf
argument_list|(
name|ftfile
argument_list|,
literal|"+0%o"
argument_list|,
name|asde
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftfile
argument_list|,
literal|",\t%s/* %s */\n"
argument_list|,
name|asde
condition|?
literal|""
else|:
literal|"\t"
argument_list|,
name|cc
condition|?
name|cc
operator|->
name|descr
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BSD
name|fprintf
argument_list|(
name|ftfile
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VOIDC
name|fclose
argument_list|(
name|ftfile
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: pscatmap mapfile\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"pscatmap"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|libdir
operator|=
name|envget
argument_list|(
literal|"PSLIBDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|libdir
operator|=
name|LibDir
expr_stmt|;
name|BuildTable
argument_list|()
expr_stmt|;
name|WriteTable
argument_list|()
expr_stmt|;
name|DoWidths
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

