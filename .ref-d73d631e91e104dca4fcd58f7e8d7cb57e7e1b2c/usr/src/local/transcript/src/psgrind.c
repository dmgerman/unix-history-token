begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)psgrind.c	1.3 %G%	*/
end_comment

begin_comment
comment|/*  *  psgrind - quick hack to grind C source files directly into  *  PostScript.  *  *  John Coker  *  University of California, Berkeley  *  *  The basis for this program is the enscript utility provided  *  by TranScript to driver the Apple LaserWriter printer.  This  *  code was taken and mangled without permission of any kind;  *  don't tell anyone.  -john  */
end_comment

begin_define
define|#
directive|define
name|POSTSCRIPTPRINTER
value|"gp"
end_define

begin_define
define|#
directive|define
name|HEADERFONT
value|"Helvetica-Bold"
end_define

begin_define
define|#
directive|define
name|BODYFONT
value|"Helvetica"
end_define

begin_define
define|#
directive|define
name|KWORDFONT
value|"Helvetica-Bold"
end_define

begin_define
define|#
directive|define
name|COMMENTFONT
value|"Helvetica-Oblique"
end_define

begin_define
define|#
directive|define
name|LITERALFONT
value|"Courier"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PSGRINDPRO
end_ifndef

begin_define
define|#
directive|define
name|PSGRINDPRO
value|"/psgrind.pro"
end_define

begin_endif
endif|#
directive|endif
endif|!PSGRINDPRO
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSGRINDTEMP
end_ifndef

begin_define
define|#
directive|define
name|PSGRINDTEMP
value|"/GRXXXXXX"
end_define

begin_endif
endif|#
directive|endif
endif|!PSGRINDTEMP
end_endif

begin_define
define|#
directive|define
name|UperInch
value|1440
end_define

begin_define
define|#
directive|define
name|PtsPerInch
value|72
end_define

begin_define
define|#
directive|define
name|UperPt
value|20
end_define

begin_define
define|#
directive|define
name|TruePageWidth
value|(UperInch*17/2)
end_define

begin_define
define|#
directive|define
name|PageWidth
value|(UperInch*(4*17-3)/8)
end_define

begin_define
define|#
directive|define
name|PageLength
value|(UperInch*(8*11-3)/8)
end_define

begin_define
define|#
directive|define
name|TruePageLength
value|(UperInch*11)
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_define
define|#
directive|define
name|LPR
value|"lpr"
end_define

begin_define
define|#
directive|define
name|REVERSE
value|"psrev"
end_define

begin_define
define|#
directive|define
name|MAXBAD
value|20
end_define

begin_comment
comment|/* number of bad chars to pass before complaint */
end_comment

begin_decl_stmt
name|private
name|struct
name|stat
name|S
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FSIZEMAX
value|256
end_define

begin_comment
comment|/* number of chars per font */
end_comment

begin_comment
comment|/* the layout of a font information block */
end_comment

begin_struct
struct|struct
name|font
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
comment|/* PostScript font name */
name|int
name|dsize
decl_stmt|;
comment|/* size */
name|int
name|Xwid
index|[
name|FSIZEMAX
index|]
decl_stmt|;
comment|/* X widths for each character */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|font
name|fonts
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 16 possible fonts at one time */
end_comment

begin_decl_stmt
name|private
name|int
name|nf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fonts known about */
end_comment

begin_decl_stmt
name|private
name|int
name|HeaderFont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle for header font */
end_comment

begin_decl_stmt
name|private
name|int
name|BodyFont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle for body font */
end_comment

begin_decl_stmt
name|private
name|int
name|KwordFont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle for keyword font */
end_comment

begin_decl_stmt
name|private
name|int
name|LiteralFont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle for literal font */
end_comment

begin_decl_stmt
name|private
name|int
name|CommentFont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle for comment font */
end_comment

begin_decl_stmt
name|private
name|int
name|TabWidth
init|=
name|TruePageWidth
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of a tab */
end_comment

begin_decl_stmt
name|private
name|int
name|BSWidth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of a backspace */
end_comment

begin_decl_stmt
name|private
name|int
name|UperLine
init|=
name|UperInch
operator|/
literal|7
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|UperHLine
init|=
name|UperInch
operator|/
literal|7
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name argv[0] */
end_comment

begin_decl_stmt
name|private
name|char
name|TempName
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of temporary PostScript file */
end_comment

begin_decl_stmt
name|private
name|char
name|OutName
index|[
literal|256
index|]
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename for disk output */
end_comment

begin_decl_stmt
name|private
name|int
name|PipeOut
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if output to stdout (-p -) */
end_comment

begin_decl_stmt
name|private
name|int
name|ListOmitted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list omitted chars on the tty */
end_comment

begin_decl_stmt
name|private
name|int
name|LPTsimulate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if an lpt should be simulated */
end_comment

begin_decl_stmt
name|private
name|int
name|LinesLeft
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines left on page when in LPT mode */
end_comment

begin_decl_stmt
name|private
name|int
name|col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* column number on current line */
end_comment

begin_decl_stmt
name|private
name|int
name|LineNo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number in current file */
end_comment

begin_decl_stmt
name|private
name|int
name|SeenText
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if seen some text on this page */
end_comment

begin_decl_stmt
name|private
name|int
name|OutOnly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if PS file only wanted */
end_comment

begin_decl_stmt
name|private
name|int
name|Rotated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if the page is to be rotated */
end_comment

begin_decl_stmt
name|private
name|int
name|Reverse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output should be piped to psrev */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|PageSpec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ditto */
end_comment

begin_decl_stmt
name|private
name|int
name|PreFeed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if prefeed should be enabled */
end_comment

begin_decl_stmt
name|private
name|int
name|TwoColumn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true of if in two-column mode */
end_comment

begin_decl_stmt
name|private
name|int
name|FirstCol
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we're printing column 1 */
end_comment

begin_decl_stmt
name|private
name|int
name|NoTitle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if title line is to be suppressed */
end_comment

begin_decl_stmt
name|private
name|int
name|Cvted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if converted a file to PS format */
end_comment

begin_decl_stmt
name|private
name|int
name|IgnoreGarbage
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if garbage should be ignored */
end_comment

begin_decl_stmt
name|private
name|int
name|SeenFile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if a file has been processed */
end_comment

begin_decl_stmt
name|private
name|int
name|SeenFont
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we've seen a font request */
end_comment

begin_decl_stmt
name|private
name|int
name|ScannedFonts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we've scanned the font file */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|FileName
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file currently being PSed */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|FileDate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last mod date of file being PSed */
end_comment

begin_decl_stmt
name|private
name|char
name|DateStr
index|[
literal|27
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* thanks, but no thanks ctime! */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|spoolJobClass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|spoolJobName
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|PrinterName
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|spoolNotify
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|spoolNoBurst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|spoolCopies
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|tempstr
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* various path names */
end_comment

begin_decl_stmt
name|private
name|int
name|CurFont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current Font */
end_comment

begin_decl_stmt
name|private
name|int
name|LastFont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous Font */
end_comment

begin_decl_stmt
name|private
name|int
name|cX
decl_stmt|,
name|cY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current page positions */
end_comment

begin_decl_stmt
name|private
name|int
name|dX
decl_stmt|,
name|dY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* desired page positions */
end_comment

begin_decl_stmt
name|private
name|int
name|lX
decl_stmt|,
name|lY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page positions of the start of the line */
end_comment

begin_decl_stmt
name|private
name|int
name|crX
decl_stmt|,
name|crY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* X and Y increments to apply to CR's */
end_comment

begin_define
define|#
directive|define
name|None
value|0
end_define

begin_define
define|#
directive|define
name|RelX
value|1
end_define

begin_define
define|#
directive|define
name|RelY
value|2
end_define

begin_define
define|#
directive|define
name|RelXY
value|3
end_define

begin_define
define|#
directive|define
name|AbsX
value|4
end_define

begin_define
define|#
directive|define
name|AbsY
value|8
end_define

begin_define
define|#
directive|define
name|AbsXY
value|12
end_define

begin_decl_stmt
name|private
name|int
name|movepending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* moveto pending coords on stack */
end_comment

begin_decl_stmt
name|private
name|int
name|showpending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters waiting to be shown */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|UsersHeader
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user specified heading */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|Header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generated header (usually FileName) */
end_comment

begin_decl_stmt
name|private
name|int
name|Page
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current page number */
end_comment

begin_decl_stmt
name|private
name|int
name|TotalPages
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of pages printed */
end_comment

begin_decl_stmt
name|private
name|int
name|TruncChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters truncated */
end_comment

begin_decl_stmt
name|private
name|int
name|UndefChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters skipped because 				   they weren't defined in some font */
end_comment

begin_decl_stmt
name|private
name|int
name|BadChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bad characters seen so far */
end_comment

begin_decl_stmt
name|private
name|FILE
modifier|*
name|OutFile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output ps file */
end_comment

begin_comment
comment|/* decode a fontname string - e.g. Courier10 Helvetica-Bold12 */
end_comment

begin_function
name|private
name|decodefont
parameter_list|(
name|name
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|SeenFont
operator|++
expr_stmt|;
if|if
condition|(
name|ScannedFonts
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fonts must be specified before any files are processed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|name
expr_stmt|;
name|d
operator|=
name|f
operator|->
name|name
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
operator|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|f
operator|->
name|dsize
operator|=
literal|0
expr_stmt|;
do|do
name|f
operator|->
name|dsize
operator|=
name|f
operator|->
name|dsize
operator|*
literal|10
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
literal|'0'
operator|<=
operator|*
name|p
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|p
operator|||
operator|!
name|f
operator|->
name|dsize
operator|||
operator|!
name|f
operator|->
name|name
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Poorly formed font name: \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|NOTDEF
value|0x8000
end_define

begin_define
define|#
directive|define
name|ForAllFonts
parameter_list|(
name|p
parameter_list|)
value|for(p =&fonts[nf-1]; p>=&fonts[0]; p--)
end_define

begin_comment
comment|/* Scan the font metrics directory looking for entries that match the  * entries in ``fonts''.  For entries  * that are found the data in the font description is filled in,  * if any are missing, it dies horribly.  */
end_comment

begin_function
name|private
name|ScanFont
parameter_list|()
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|FontData
decl_stmt|;
comment|/* afm file */
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|ccode
decl_stmt|,
name|cwidth
decl_stmt|,
name|inChars
decl_stmt|;
name|char
modifier|*
name|MetricsDir
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"METRICS"
argument_list|)
decl_stmt|;
name|char
name|FontFile
index|[
literal|512
index|]
decl_stmt|;
comment|/* afm file name */
name|char
name|afmbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|MetricsDir
operator|==
literal|0
condition|)
name|MetricsDir
operator|=
name|LibDir
expr_stmt|;
if|if
condition|(
operator|!
name|SeenFont
operator|&
name|Rotated
operator|&
name|TwoColumn
condition|)
block|{
name|fonts
index|[
name|HeaderFont
index|]
operator|.
name|dsize
operator|=
literal|10
expr_stmt|;
name|fonts
index|[
name|BodyFont
index|]
operator|.
name|dsize
operator|=
literal|7
expr_stmt|;
name|fonts
index|[
name|KwordFont
index|]
operator|.
name|dsize
operator|=
literal|7
expr_stmt|;
name|fonts
index|[
name|LiteralFont
index|]
operator|.
name|dsize
operator|=
literal|8
expr_stmt|;
name|fonts
index|[
name|CommentFont
index|]
operator|.
name|dsize
operator|=
literal|7
expr_stmt|;
block|}
comment|/* loop through fonts, find and read metric entry in dir */
name|ForAllFonts
argument_list|(
argument|f
argument_list|)
block|{
name|mstrcat
argument_list|(
name|FontFile
argument_list|,
name|MetricsDir
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
name|FontFile
argument_list|)
expr_stmt|;
name|mstrcat
argument_list|(
name|FontFile
argument_list|,
name|FontFile
argument_list|,
name|f
operator|->
name|name
argument_list|,
sizeof|sizeof
name|FontFile
argument_list|)
expr_stmt|;
name|mstrcat
argument_list|(
name|FontFile
argument_list|,
name|FontFile
argument_list|,
literal|".afm"
argument_list|,
sizeof|sizeof
name|FontFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FontData
operator|=
name|fopen
argument_list|(
name|FontFile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open font metrics file %s\n"
argument_list|,
name|FontFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* read the .afm file to get the widths */
for|for
control|(
name|ccode
operator|=
literal|0
init|;
name|ccode
operator|<
name|FSIZEMAX
condition|;
name|ccode
operator|++
control|)
name|f
operator|->
name|Xwid
index|[
name|ccode
index|]
operator|=
name|NOTDEF
expr_stmt|;
name|inChars
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|afmbuf
argument_list|,
sizeof|sizeof
name|afmbuf
argument_list|,
name|FontData
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* strip off newline */
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|afmbuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AFM file %s line too long %s\n"
argument_list|,
name|FontFile
argument_list|,
name|afmbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|afmbuf
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"StartCharMetrics"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inChars
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"EndCharMetrics"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|inChars
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|afmbuf
argument_list|,
literal|"C %d ; WX %d ;"
argument_list|,
operator|&
name|ccode
argument_list|,
operator|&
name|cwidth
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Trouble with AFM file %s\n"
argument_list|,
name|FontFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get out once we see an unencoded char */
if|if
condition|(
name|ccode
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|ccode
operator|>
literal|255
condition|)
continue|continue;
name|f
operator|->
name|Xwid
index|[
name|ccode
index|]
operator|=
operator|(
name|cwidth
operator|*
name|f
operator|->
name|dsize
operator|*
name|UperPt
operator|)
operator|/
literal|1000
expr_stmt|;
continue|continue;
block|}
block|}
name|fclose
argument_list|(
name|FontData
argument_list|)
expr_stmt|;
block|}
name|TabWidth
operator|=
name|fonts
index|[
name|BodyFont
index|]
operator|.
name|Xwid
index|[
literal|'0'
index|]
operator|*
literal|8
expr_stmt|;
comment|/* 8 * figure width */
name|BSWidth
operator|=
name|fonts
index|[
name|BodyFont
index|]
operator|.
name|Xwid
index|[
literal|' '
index|]
expr_stmt|;
comment|/* space width */
name|UperLine
operator|=
operator|(
name|fonts
index|[
name|BodyFont
index|]
operator|.
name|dsize
operator|+
literal|1
operator|)
operator|*
name|UperPt
expr_stmt|;
if|if
condition|(
name|LPTsimulate
condition|)
name|UperHLine
operator|=
name|UperLine
expr_stmt|;
else|else
name|UperHLine
operator|=
operator|(
name|fonts
index|[
name|HeaderFont
index|]
operator|.
name|dsize
operator|+
literal|1
operator|)
operator|*
name|UperPt
expr_stmt|;
name|crX
operator|=
literal|0
expr_stmt|;
name|crY
operator|=
operator|-
name|UperLine
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a font number for the font with the indicated name  * and size.  Adds info to the font list for the eventual search.  */
end_comment

begin_function
name|private
name|DefineFont
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|font
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|fonts
index|[
name|nf
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|dsize
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|nf
operator|++
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* add a shown character to the PS file */
end_comment

begin_function
name|private
name|OUTputc
parameter_list|(
name|c
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|showpending
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'('
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|showpending
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>
literal|0176
operator|)
operator|||
operator|(
name|c
operator|<
literal|040
operator|)
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the current font */
end_comment

begin_function
name|private
name|SetFont
parameter_list|(
name|f
parameter_list|)
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|LastFont
operator|=
name|CurFont
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d F\n"
argument_list|,
name|CurFont
operator|=
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset to previous font */
end_comment

begin_function
name|private
name|PrevFont
parameter_list|()
block|{
name|int
name|temp
decl_stmt|;
name|FlushShow
argument_list|()
expr_stmt|;
name|temp
operator|=
name|CurFont
expr_stmt|;
name|CurFont
operator|=
name|LastFont
expr_stmt|;
name|LastFont
operator|=
name|temp
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d F\n"
argument_list|,
name|CurFont
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put a character onto the page at the desired X and Y positions.  * If the current position doesn't agree with the desired position, put out  * movement directives.  Leave the current position updated  * to account for the character.  */
end_comment

begin_function
name|private
name|ShowChar
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
specifier|register
name|nX
operator|,
name|nY
expr_stmt|;
specifier|static
name|level
operator|=
literal|0
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|f
operator|=
operator|&
name|fonts
index|[
name|CurFont
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|Xwid
index|[
name|c
index|]
operator|==
name|NOTDEF
condition|)
block|{
name|UndefChars
operator|++
expr_stmt|;
if|if
condition|(
name|ListOmitted
condition|)
name|printf
argument_list|(
literal|"\'%c\' (%03o) not found in font %s\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
literal|1
condition|)
block|{
name|ShowChar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|level
operator|--
expr_stmt|;
return|return;
block|}
name|nX
operator|=
name|dX
operator|+
name|f
operator|->
name|Xwid
index|[
name|c
index|]
expr_stmt|;
comment|/* resulting position after showing this char */
name|nY
operator|=
name|dY
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
operator|||
operator|(
operator|(
name|cX
operator|==
name|dX
operator|)
operator|&&
operator|(
name|cY
operator|==
name|dY
operator|)
operator|)
condition|)
block|{
comment|/* 	     * If character doesn't fit on this line 	     * (and we're not at left margin), simulate newline 	     * and then call ourselves recursively. 	     */
if|if
condition|(
operator|(
operator|(
operator|!
name|Rotated
operator|&&
name|nX
operator|>
name|PageWidth
operator|)
operator|||
operator|(
name|Rotated
operator|&&
name|nX
operator|>
name|PageLength
operator|)
operator|)
operator|&&
name|dX
operator|>
name|lX
condition|)
block|{
name|LineNo
operator|++
expr_stmt|;
name|SeenText
operator|++
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
expr_stmt|;
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|!
name|Rotated
operator|)
operator|&&
operator|(
name|dY
operator|<
name|UperLine
operator|)
operator|)
operator|||
operator|(
name|Rotated
operator|&&
operator|(
name|dY
operator|<
operator|(
operator|(
name|PageLength
operator|-
name|TruePageWidth
operator|)
operator|+
literal|3
operator|*
name|UperLine
operator|+
literal|480
operator|)
operator|)
operator|)
operator|||
operator|(
name|LPTsimulate
operator|&&
operator|(
operator|--
name|LinesLeft
operator|<=
literal|0
operator|)
operator|)
condition|)
name|PageEject
argument_list|()
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
name|ShowChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cX
operator|!=
name|dX
condition|)
block|{
if|if
condition|(
name|cY
operator|!=
name|dY
condition|)
block|{
name|FlushShow
argument_list|()
expr_stmt|;
comment|/* absolute x, relative y */
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d %d"
argument_list|,
name|dX
argument_list|,
name|dY
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|AbsXY
expr_stmt|;
block|}
else|else
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d"
argument_list|,
name|dX
operator|-
name|cX
argument_list|)
expr_stmt|;
comment|/* relative x */
name|movepending
operator|=
name|RelX
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cY
operator|!=
name|dY
condition|)
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d"
argument_list|,
name|dY
operator|-
name|cY
argument_list|)
expr_stmt|;
comment|/* relative y */
name|movepending
operator|=
name|RelY
expr_stmt|;
block|}
name|OUTputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|showpending
operator|++
expr_stmt|;
name|cX
operator|=
name|nX
expr_stmt|;
name|cY
operator|=
name|nY
expr_stmt|;
block|}
name|dX
operator|=
name|nX
expr_stmt|;
name|dY
operator|=
name|nY
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put out a shown string to the PS file */
end_comment

begin_function
name|private
name|ShowStr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|>=
literal|040
condition|)
name|ShowChar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* flush pending show */
end_comment

begin_function
name|private
name|FlushShow
parameter_list|()
block|{
if|if
condition|(
name|showpending
condition|)
block|{
name|putc
argument_list|(
literal|')'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|movepending
condition|)
block|{
case|case
name|RelX
case|:
name|putc
argument_list|(
literal|'X'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|RelY
case|:
name|putc
argument_list|(
literal|'Y'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AbsXY
case|:
name|putc
argument_list|(
literal|'B'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|None
case|:
name|putc
argument_list|(
literal|'S'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|None
expr_stmt|;
name|showpending
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* put out a page heading to the PS file */
end_comment

begin_function
name|private
name|InitPage
parameter_list|()
block|{
name|char
modifier|*
name|basename
parameter_list|()
function_decl|;
name|char
name|header
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|int
name|OldFont
init|=
name|CurFont
decl_stmt|;
name|TotalPages
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Page: ? %d\n"
argument_list|,
name|TotalPages
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"StartPage\n"
argument_list|)
expr_stmt|;
name|LinesLeft
operator|=
literal|64
expr_stmt|;
name|SeenText
operator|=
literal|0
expr_stmt|;
name|cX
operator|=
name|cY
operator|=
operator|-
literal|1
expr_stmt|;
name|showpending
operator|=
literal|0
expr_stmt|;
name|FirstCol
operator|=
literal|1
expr_stmt|;
name|lX
operator|=
name|dX
operator|=
name|UperInch
expr_stmt|;
name|lY
operator|=
name|dY
operator|=
name|PageLength
operator|-
name|UperHLine
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|Rotated
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"Landscape\n"
argument_list|)
expr_stmt|;
name|lX
operator|=
name|dX
operator|=
name|UperInch
operator|/
literal|4
expr_stmt|;
block|}
name|movepending
operator|=
name|None
expr_stmt|;
name|cX
operator|=
name|dX
expr_stmt|;
name|cY
operator|=
name|dY
expr_stmt|;
if|if
condition|(
operator|!
name|NoTitle
condition|)
block|{
name|SetFont
argument_list|(
name|HeaderFont
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d %d "
argument_list|,
name|cX
argument_list|,
name|cY
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|AbsXY
expr_stmt|;
if|if
condition|(
name|UsersHeader
condition|)
block|{
if|if
condition|(
operator|*
name|UsersHeader
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"()B\n"
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|None
expr_stmt|;
name|showpending
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ShowStr
argument_list|(
name|UsersHeader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Page
operator|++
expr_stmt|;
if|if
condition|(
name|FileName
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|header
argument_list|,
literal|"Page %d"
argument_list|,
name|Page
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|header
argument_list|,
literal|"%s,  page %d"
argument_list|,
name|basename
argument_list|(
name|FileName
argument_list|)
argument_list|,
name|Page
argument_list|)
expr_stmt|;
name|ShowStr
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|FlushShow
argument_list|()
expr_stmt|;
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
operator|*
literal|3
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
operator|*
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* fake it to force a moveto */
name|cX
operator|=
name|cY
operator|=
literal|0
expr_stmt|;
block|}
name|SetFont
argument_list|(
name|OldFont
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminate a page. */
end_comment

begin_function
name|private
name|ClosePage
parameter_list|()
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"EndPage\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* skip to a new page */
end_comment

begin_function
name|private
name|PageEject
parameter_list|()
block|{
if|if
condition|(
name|TwoColumn
operator|&&
name|FirstCol
condition|)
block|{
name|FirstCol
operator|=
literal|0
expr_stmt|;
name|lX
operator|=
name|dX
operator|=
name|TruePageWidth
operator|/
literal|2
expr_stmt|;
name|lY
operator|=
name|dY
operator|=
name|PageLength
operator|-
operator|(
name|UperHLine
operator|*
literal|3
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|Rotated
condition|)
block|{
name|lX
operator|=
name|dX
operator|=
name|TruePageLength
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NoTitle
condition|)
block|{
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
operator|*
literal|3
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
operator|*
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
name|ClosePage
argument_list|()
expr_stmt|;
name|InitPage
argument_list|()
expr_stmt|;
block|}
name|LinesLeft
operator|=
literal|64
expr_stmt|;
name|SeenText
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* commented out AIS Fri Feb 22 10:00:36 1985 */
end_comment

begin_endif
unit|private PageMessage (TotalPages)  {     if (TotalPages> 0) { 	printf ("psgrind formatted[ %d page%s * %d cop%s ]\n", 		TotalPages, TotalPages> 1 ? "s" : "", 		spoolCopies, spoolCopies> 1 ? "ies" : "y" );     } }
endif|#
directive|endif
end_endif

begin_function
name|private
name|CommentHeader
parameter_list|()
block|{
name|long
name|clock
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pswd
decl_stmt|;
name|char
name|hostname
index|[
literal|40
index|]
decl_stmt|;
comment|/* copy the file, prepending a new comment header */
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%!%s\n"
argument_list|,
name|COMMENTVERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Creator: "
argument_list|)
expr_stmt|;
name|pswd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|gethostname
argument_list|(
name|hostname
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|hostname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%s:%s (%s)%s\n"
argument_list|,
name|hostname
argument_list|,
name|pswd
operator|->
name|pw_name
argument_list|,
name|pswd
operator|->
name|pw_gecos
argument_list|,
name|spoolJobClass
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Title: %s %s\n"
argument_list|,
operator|(
name|FileName
condition|?
name|FileName
else|:
literal|"stdin"
operator|)
argument_list|,
name|spoolJobName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%CreationDate: %s"
argument_list|,
operator|(
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* list of C keywords to put in KwordFont */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|KeyWordList
index|[]
init|=
block|{
literal|"asm"
block|,
literal|"auto"
block|,
literal|"break"
block|,
literal|"case"
block|,
literal|"char"
block|,
literal|"continue"
block|,
literal|"default"
block|,
literal|"do"
block|,
literal|"double"
block|,
literal|"else"
block|,
literal|"entry"
block|,
literal|"enum"
block|,
literal|"extern"
block|,
literal|"float"
block|,
literal|"for"
block|,
literal|"fortran"
block|,
literal|"goto"
block|,
literal|"if"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"register"
block|,
literal|"return"
block|,
literal|"short"
block|,
literal|"sizeof"
block|,
literal|"static"
block|,
literal|"struct"
block|,
literal|"switch"
block|,
literal|"typedef"
block|,
literal|"union"
block|,
literal|"unsigned"
block|,
literal|"void"
block|,
literal|"while"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* macros identifying C identifiers */
end_comment

begin_define
define|#
directive|define
name|isfirst
parameter_list|(
name|c
parameter_list|)
value|(isalpha(c) || (c) == '_')
end_define

begin_define
define|#
directive|define
name|isident
parameter_list|(
name|c
parameter_list|)
value|(isalnum(c) || (c) == '_')
end_define

begin_comment
comment|/* Copy the standard input file to the PS file */
end_comment

begin_function
name|private
name|CopyFile
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
name|int
name|InComment
decl_stmt|,
name|InString
decl_stmt|,
name|InChar
decl_stmt|,
name|IsKword
decl_stmt|;
name|char
name|token
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|tend
init|=
name|token
operator|+
sizeof|sizeof
argument_list|(
name|token
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
modifier|*
name|kwp
decl_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|OutFile
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OutOnly
operator|&&
operator|!
operator|(
name|PageSpec
operator|||
name|Reverse
operator|)
condition|)
block|{
name|OutFile
operator|=
name|PipeOut
condition|?
name|stdout
else|:
name|fopen
argument_list|(
name|OutName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mktemp
argument_list|(
name|mstrcat
argument_list|(
name|TempName
argument_list|,
name|TempDir
argument_list|,
name|PSGRINDTEMP
argument_list|,
sizeof|sizeof
name|TempName
argument_list|)
argument_list|)
expr_stmt|;
name|OutFile
operator|=
name|fopen
argument_list|(
name|TempName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|OutFile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create PS file %s\n"
argument_list|,
name|TempName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ScannedFonts
condition|)
block|{
name|ScannedFonts
operator|++
expr_stmt|;
name|ScanFont
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Cvted
condition|)
block|{
name|CommentHeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|nf
condition|)
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%DocumentFonts:"
argument_list|)
expr_stmt|;
name|ForAllFonts
argument_list|(
argument|f
argument_list|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|" %s"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* copy in fixed prolog */
if|if
condition|(
name|copyfile
argument_list|(
name|mstrcat
argument_list|(
name|tempstr
argument_list|,
name|LibDir
argument_list|,
name|PSGRINDPRO
argument_list|,
sizeof|sizeof
name|tempstr
argument_list|)
argument_list|,
name|OutFile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trouble copying prolog file \"%s\".\n"
argument_list|,
name|tempstr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"StartEnscriptDoc %% end fixed prolog\n"
argument_list|)
expr_stmt|;
name|DumpFonts
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%EndProlog\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PreFeed
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"true DoPreFeed\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|Cvted
operator|++
expr_stmt|;
name|Page
operator|=
literal|0
expr_stmt|;
name|LineNo
operator|=
literal|1
expr_stmt|;
name|BadChars
operator|=
literal|0
expr_stmt|;
comment|/* give each file a clean slate */
name|InitPage
argument_list|()
expr_stmt|;
name|last
operator|=
literal|'\0'
expr_stmt|;
name|InComment
operator|=
name|InChar
operator|=
name|InString
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>
literal|0177
operator|||
name|c
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|!
name|IgnoreGarbage
operator|)
condition|)
block|{
if|if
condition|(
name|BadChars
operator|++
operator|>
name|MAXBAD
condition|)
block|{
comment|/* allow some kruft but not much */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" not a text file? - char '\\%03o'@0%o\nTry -g.\n"
argument_list|,
name|FileName
condition|?
name|FileName
else|:
literal|"stdin"
argument_list|,
name|c
argument_list|,
name|ftell
argument_list|(
name|stdin
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|010
case|:
comment|/* backspace */
name|dX
operator|-=
name|BSWidth
expr_stmt|;
break|break;
case|case
literal|015
case|:
comment|/* carriage return ^M */
name|dY
operator|=
name|lY
expr_stmt|;
name|dX
operator|=
name|lX
expr_stmt|;
break|break;
case|case
literal|012
case|:
comment|/* linefeed ^J */
name|LineNo
operator|++
expr_stmt|;
if|if
condition|(
name|dX
operator|!=
name|lX
operator|||
name|dY
operator|!=
name|lY
operator|||
operator|!
name|LPTsimulate
operator|||
name|SeenText
condition|)
block|{
name|SeenText
operator|++
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
expr_stmt|;
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
expr_stmt|;
block|}
else|else
name|LinesLeft
operator|=
literal|64
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|!
name|Rotated
operator|)
operator|&&
operator|(
name|dY
operator|<
name|UperLine
operator|)
operator|)
operator|||
operator|(
name|Rotated
operator|&&
operator|(
name|dY
operator|<
operator|(
operator|(
name|PageLength
operator|-
name|TruePageWidth
operator|)
operator|+
literal|3
operator|*
name|UperLine
operator|+
literal|480
operator|)
operator|)
operator|)
operator|||
operator|(
name|LPTsimulate
operator|&&
operator|(
operator|--
name|LinesLeft
operator|<=
literal|0
operator|)
operator|)
condition|)
name|PageEject
argument_list|()
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|014
case|:
comment|/* form feed ^L */
name|PageEject
argument_list|()
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|011
case|:
comment|/* tab ^I */
name|col
operator|=
operator|(
name|col
operator|-
literal|1
operator|)
operator|/
literal|8
operator|*
literal|8
operator|+
literal|9
expr_stmt|;
name|dX
operator|+=
name|TabWidth
operator|-
operator|(
operator|(
name|dX
operator|-
name|lX
operator|)
operator|%
name|TabWidth
operator|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* special escape */
name|last
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
goto|goto
name|done
goto|;
name|ShowChar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* want to leave newlines alone */
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ShowChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
comment|/* a string quote mark */
if|if
condition|(
name|InComment
operator|||
name|InChar
condition|)
block|{
comment|/* just put out the quote */
name|ShowChar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|InString
condition|)
block|{
name|ShowChar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
name|PrevFont
argument_list|()
expr_stmt|;
name|InString
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SetFont
argument_list|(
name|LiteralFont
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
name|InString
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
comment|/* a char quote mark */
if|if
condition|(
name|InComment
operator|||
name|InString
condition|)
block|{
comment|/* just put out the character */
name|ShowChar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|InChar
condition|)
block|{
name|ShowChar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
name|PrevFont
argument_list|()
expr_stmt|;
name|InChar
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SetFont
argument_list|(
name|LiteralFont
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
name|InChar
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|InComment
operator|&&
name|last
operator|==
literal|'*'
condition|)
block|{
name|ShowChar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
name|SetFont
argument_list|(
name|BodyFont
argument_list|)
expr_stmt|;
name|InComment
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'*'
operator|&&
operator|!
name|InComment
condition|)
block|{
name|SetFont
argument_list|(
name|CommentFont
argument_list|)
expr_stmt|;
name|InComment
operator|=
literal|1
expr_stmt|;
name|ShowChar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
name|c
operator|=
literal|'/'
expr_stmt|;
block|}
break|break;
default|default:
comment|/* plain text, put it out */
if|if
condition|(
operator|!
name|InComment
operator|&&
operator|!
name|InString
operator|&&
name|isfirst
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|tp
operator|=
name|token
expr_stmt|;
while|while
condition|(
name|isident
argument_list|(
name|c
argument_list|)
operator|&&
name|tp
operator|<
name|tend
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|tp
operator|=
name|token
expr_stmt|;
name|IsKword
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kwp
operator|=
name|KeyWordList
init|;
operator|*
name|kwp
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|kwp
operator|<=
operator|*
name|tp
condition|;
name|kwp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|kwp
argument_list|,
name|tp
argument_list|)
condition|)
block|{
name|IsKword
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IsKword
condition|)
name|SetFont
argument_list|(
name|KwordFont
argument_list|)
expr_stmt|;
name|ShowStr
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|col
operator|+=
name|strlen
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsKword
condition|)
name|SetFont
argument_list|(
name|BodyFont
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fonts
index|[
name|CurFont
index|]
operator|.
name|Xwid
index|[
name|c
index|]
operator|!=
name|NOTDEF
condition|)
block|{
comment|/* other normal character */
name|ShowChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* not in font, quote it */
name|ShowChar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
block|}
name|last
operator|=
name|c
expr_stmt|;
block|}
name|done
label|:
name|ClosePage
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dump the fonts to the PS file for setup */
end_comment

begin_function
name|private
name|DumpFonts
parameter_list|()
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
name|ForAllFonts
argument_list|(
argument|f
argument_list|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d %d /%s\n"
argument_list|,
name|f
operator|-
operator|&
name|fonts
index|[
literal|0
index|]
argument_list|,
name|f
operator|->
name|dsize
operator|*
name|UperPt
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d SetUpFonts\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * close the PS file  */
end_comment

begin_function
name|private
name|ClosePS
parameter_list|()
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Trailer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PreFeed
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"false DoPreFeed\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"EndEnscriptDoc\nEnscriptJob restore\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|private
name|ProcessArg
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
enum|enum
name|State
block|{
name|normal
block|,
name|PSname
block|,
name|H_fontname
block|,
name|B_fontname
block|,
name|K_fontname
block|,
name|C_fontname
block|,
name|L_fontname
block|,
name|grabheader
block|,
name|getclass
block|,
name|getjobname
block|}
name|state
init|=
name|normal
enum|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PSname
case|:
name|strcpy
argument_list|(
name|OutName
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|OutName
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|PipeOut
operator|++
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|H_fontname
case|:
name|decodefont
argument_list|(
name|p
argument_list|,
operator|&
name|fonts
index|[
name|HeaderFont
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|B_fontname
case|:
name|decodefont
argument_list|(
name|p
argument_list|,
operator|&
name|fonts
index|[
name|BodyFont
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|K_fontname
case|:
name|decodefont
argument_list|(
name|p
argument_list|,
operator|&
name|fonts
index|[
name|KwordFont
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|L_fontname
case|:
name|decodefont
argument_list|(
name|p
argument_list|,
operator|&
name|fonts
index|[
name|LiteralFont
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|C_fontname
case|:
name|decodefont
argument_list|(
name|p
argument_list|,
operator|&
name|fonts
index|[
name|CommentFont
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|grabheader
case|:
name|UsersHeader
operator|=
name|p
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|getclass
case|:
name|spoolJobClass
operator|=
name|p
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|getjobname
case|:
name|spoolJobName
operator|=
name|p
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|*
operator|++
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'1'
case|:
name|TwoColumn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SeenFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify -1 before any files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'2'
case|:
name|TwoColumn
operator|++
expr_stmt|;
if|if
condition|(
name|SeenFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify -2 before any files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|Reverse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|PageSpec
operator|=
operator|(
operator|++
name|p
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
return|return;
comment|/* the following options allow uswer specification 		   of the five files used by the program */
case|case
literal|'H'
case|:
name|state
operator|=
name|H_fontname
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|state
operator|=
name|B_fontname
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|state
operator|=
name|K_fontname
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|state
operator|=
name|L_fontname
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|state
operator|=
name|C_fontname
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|IgnoreGarbage
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|ListOmitted
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|OutOnly
operator|++
expr_stmt|;
name|state
operator|=
name|PSname
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Rotated
operator|++
expr_stmt|;
if|if
condition|(
name|SeenFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify rotation before any files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
name|Rotated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SeenFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify rotation before any files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
name|PreFeed
operator|++
expr_stmt|;
if|if
condition|(
name|SeenFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify prefeed before any files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* the following switches are as in lpr(1) and */
comment|/* are passed through when spooling to a printer */
case|case
literal|'P'
case|:
comment|/* printer name */
name|PrinterName
operator|=
operator|(
operator|++
name|p
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
comment|/* job name (title) for the Job: field */
name|state
operator|=
name|getjobname
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* notify by mail */
name|spoolNotify
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|spoolNoBurst
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|spoolCopies
operator|=
name|atoi
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoolCopies
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad argument for -# (number of copies)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown option: %c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|SeenFile
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* not a flag -- a filename */
name|FileName
operator|=
name|Header
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|FileName
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Can't open %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|S
argument_list|)
expr_stmt|;
name|FileDate
operator|=
name|strcpy
argument_list|(
name|DateStr
argument_list|,
name|ctime
argument_list|(
operator|&
name|S
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|CopyFile
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|SeenFile
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|prog
operator|=
operator|*
name|argv
expr_stmt|;
name|BodyFont
operator|=
name|LastFont
operator|=
name|CurFont
operator|=
name|DefineFont
argument_list|(
name|BODYFONT
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|HeaderFont
operator|=
name|DefineFont
argument_list|(
name|HEADERFONT
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|KwordFont
operator|=
name|DefineFont
argument_list|(
name|KWORDFONT
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|CommentFont
operator|=
name|DefineFont
argument_list|(
name|COMMENTFONT
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|LiteralFont
operator|=
name|DefineFont
argument_list|(
name|LITERALFONT
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* process args in environment variable PSGRIND */
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"PSGRIND"
argument_list|)
condition|)
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|char
name|quote
init|=
literal|' '
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
name|quote
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|quote
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|arg
condition|)
name|ProcessArg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ProcessArg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* process the command line arguments */
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|ProcessArg
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SeenFile
condition|)
block|{
name|FileName
operator|=
name|Header
operator|=
literal|0
expr_stmt|;
name|FileDate
operator|=
literal|""
expr_stmt|;
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|S
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|S
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
name|FileDate
operator|=
name|strcpy
argument_list|(
name|DateStr
argument_list|,
name|ctime
argument_list|(
operator|&
name|S
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|CopyFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Cvted
condition|)
block|{
name|ClosePS
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
name|OutFile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TruncChars
condition|)
name|printf
argument_list|(
literal|"%d characters omitted because of long lines.\n"
argument_list|,
name|TruncChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|UndefChars
condition|)
name|printf
argument_list|(
literal|"%d characters omitted because of incomplete fonts.\n"
argument_list|,
name|UndefChars
argument_list|)
expr_stmt|;
comment|/*  PageMessage (TotalPages); */
if|if
condition|(
name|Cvted
condition|)
block|{
if|if
condition|(
name|OutOnly
condition|)
block|{
if|if
condition|(
name|Reverse
operator|||
name|PageSpec
condition|)
block|{
name|char
name|temparg
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|sargs
index|[
literal|200
index|]
decl_stmt|;
name|int
name|args
init|=
literal|0
decl_stmt|;
name|int
name|cpid
init|=
literal|0
decl_stmt|;
comment|/* feed Temporary through psrev */
name|freopen
argument_list|(
name|TempName
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PipeOut
condition|)
name|freopen
argument_list|(
name|OutName
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TempName
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|sargs
argument_list|,
name|REVERSE
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|sargs
argument_list|,
literal|"-r"
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Reverse
condition|)
name|addarg
argument_list|(
name|sargs
argument_list|,
literal|"-R"
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|PageSpec
condition|)
block|{
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-s%s"
argument_list|,
name|PageSpec
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|sargs
argument_list|,
name|temparg
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cpid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpid
operator|==
literal|0
condition|)
block|{
name|execvp
argument_list|(
name|REVERSE
argument_list|,
name|sargs
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  fprintf (stderr,"PS file left on %s\n", OutName); */
block|}
else|else
name|SpoolIt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|addarg
parameter_list|(
name|argv
parameter_list|,
name|argstr
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|argstr
decl_stmt|;
specifier|register
name|int
modifier|*
name|argc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|argstr
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|argstr
argument_list|)
expr_stmt|;
name|argv
index|[
operator|(
operator|*
name|argc
operator|)
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|argv
index|[
operator|*
name|argc
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|private
name|SpoolIt
parameter_list|()
block|{
name|char
name|temparg
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|argstr
index|[
literal|200
index|]
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rargs
index|[
literal|40
index|]
decl_stmt|;
name|int
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|cpid
init|=
literal|0
decl_stmt|;
name|int
name|fdpipe
index|[
literal|2
index|]
decl_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|LPR
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoolCopies
operator|>
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-#%d"
argument_list|,
name|spoolCopies
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|temparg
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PrinterName
condition|)
block|{
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-P%s"
argument_list|,
name|PrinterName
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|temparg
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"PRINTER"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* no printer name known anywhere, use default */
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-P%s"
argument_list|,
name|POSTSCRIPTPRINTER
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|temparg
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spoolJobClass
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-C"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|spoolJobClass
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-J"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoolJobName
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
name|spoolJobName
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|FileName
condition|)
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"stdin"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
else|else
name|addarg
argument_list|(
name|argstr
argument_list|,
name|FileName
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spoolNotify
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-m"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spoolNoBurst
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-h"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Reverse
operator|||
name|PageSpec
condition|)
block|{
comment|/* lpr input will be stdin */
name|addarg
argument_list|(
name|rargs
argument_list|,
name|REVERSE
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|rargs
argument_list|,
literal|"-r"
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Reverse
condition|)
name|addarg
argument_list|(
name|rargs
argument_list|,
literal|"-R"
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PageSpec
condition|)
block|{
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-s%s"
argument_list|,
name|PageSpec
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|rargs
argument_list|,
name|temparg
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
block|}
comment|/*	addarg(rargs, TempName,&nr); */
name|freopen
argument_list|(
name|TempName
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TempName
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fdpipe
argument_list|)
condition|)
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cpid
condition|)
block|{
comment|/* child */
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set stdout to be the output pipe */
if|if
condition|(
name|dup
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* don't want to read or write the pipe itself, since dup */
if|if
condition|(
name|close
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* leave stderr alone */
name|execvp
argument_list|(
name|REVERSE
argument_list|,
name|rargs
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parent */
comment|/* replace stdin with pipe */
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* leave stdout and stderr alone */
name|execvp
argument_list|(
name|LPR
argument_list|,
name|argstr
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* just do lpr */
comment|/* remove the temporary file after spooling */
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-r"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
comment|/* should we use a symbolic link too? */
name|addarg
argument_list|(
name|argstr
argument_list|,
name|TempName
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|LPR
argument_list|,
name|argstr
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|path
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
for|for
control|(
operator|--
name|cp
init|;
name|cp
operator|>
name|path
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|;
name|cp
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|cp
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

end_unit

