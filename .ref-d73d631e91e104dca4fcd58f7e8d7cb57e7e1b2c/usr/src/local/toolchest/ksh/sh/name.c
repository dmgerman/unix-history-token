begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/*  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"timeout.h"
end_include

begin_comment
comment|/* This module defines the following routines */
end_comment

begin_function_decl
name|NAMPTR
name|checkfor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_whence
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ECHO_N
end_ifdef

begin_function_decl
name|char
modifier|*
name|echo_mode
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECHO_N */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|apollo
end_ifdef

begin_function_decl
name|void
name|ev_$set_var
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* apollo */
end_comment

begin_function_decl
name|int
name|genenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|heap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|meminit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mem_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mem_unscope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|name_unscope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|qvalup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prinscan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|printnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printflg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|readvar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rmlocal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|setenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setlist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|NAMPTR
name|setname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|syslook
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This module references the following external routines */
end_comment

begin_function_decl
specifier|extern
name|void
name|assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|bracket_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|chkid
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ECHO_N
end_ifdef

begin_decl_stmt
specifier|extern
name|MSG
name|echo_bin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|MSG
name|echo_opt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECHO_N */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|findnod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|fullname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getstak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|Amemory
modifier|*
name|gettree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gsort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hist_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|initf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gscan_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gscan_some
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|linknod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mactrim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|rand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_sub
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scan_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|simple
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|srand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|rmnval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|unassign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|utos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|countnam
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ECHO_N
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|echo_arg
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECHO_N */
end_comment

begin_function_decl
specifier|static
name|long
name|get_rand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|get_second
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|Amemory
modifier|*
name|inittree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|no_export
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pushnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pushnid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rehash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rm_node
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_second
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_rand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|staknam
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|rsflag
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* used to see if "SHELL" has been set in the environment */
end_comment

begin_decl_stmt
specifier|static
name|int
name|namec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argnam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Amemory
modifier|*
name|namebase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Bfunction
name|seconds
init|=
block|{
name|get_second
block|,
name|set_second
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Bfunction
name|randnum
init|=
block|{
name|get_rand
block|,
name|set_rand
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========	variable and string handling	======== */
end_comment

begin_comment
comment|/*  *  Table lookup routine  *  The table<syswds> is searched for string<w> and corresponding value is returned  */
end_comment

begin_expr_stmt
name|syslook
argument_list|(
name|w
argument_list|,
name|syswds
argument_list|)
specifier|register
name|char
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SYSTAB
name|syswds
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|first
decl_stmt|;
specifier|register
name|SYSPTR
name|syscan
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
operator|||
operator|(
name|first
operator|=
operator|*
name|w
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|syscan
operator|=
name|syswds
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|syscan
operator|->
name|sysnam
operator|)
operator|&&
name|c
operator|<=
name|first
condition|)
block|{
if|if
condition|(
name|first
operator|==
name|c
operator|&&
name|eq
argument_list|(
name|w
argument_list|,
name|syscan
operator|->
name|sysnam
argument_list|)
condition|)
return|return
operator|(
name|syscan
operator|->
name|sysval
operator|)
return|;
name|syscan
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * perform parameter assignment on an argument list  */
end_comment

begin_function
name|void
name|setlist
parameter_list|(
name|arg
parameter_list|,
name|xp
parameter_list|)
specifier|register
name|ARGPTR
name|arg
decl_stmt|;
specifier|register
name|int
name|xp
decl_stmt|;
block|{
if|if
condition|(
name|is_option
argument_list|(
name|ALLEXP
argument_list|)
condition|)
name|xp
operator||=
name|N_EXPORT
expr_stmt|;
while|while
condition|(
name|arg
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argflag
operator|&
name|A_MAC
condition|)
name|s
operator|=
name|mactrim
argument_list|(
name|arg
operator|->
name|argval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|arg
operator|->
name|argval
expr_stmt|;
name|setname
argument_list|(
name|s
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|argnxt
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|EXECPR
argument_list|)
condition|)
block|{
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|s
argument_list|,
name|arg
condition|?
name|SP
else|:
name|NL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Put<arg> into associative memory.  * If<xp>& V_FLAG then the alias list is used instead  * If<xp>& S_FLAG then use the current scope only  */
end_comment

begin_function
name|NAMPTR
name|setname
parameter_list|(
name|argi
parameter_list|,
name|xp
parameter_list|)
name|char
modifier|*
name|argi
decl_stmt|;
name|int
name|xp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|argscan
init|=
name|argi
decl_stmt|;
specifier|register
name|NAMPTR
name|n
decl_stmt|;
specifier|register
name|int
name|sep
init|=
operator|*
name|argscan
decl_stmt|;
name|char
modifier|*
name|sim
decl_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|sep
argument_list|)
operator|||
operator|(
operator|(
name|xp
operator|&
name|V_FLAG
operator|)
operator|&&
operator|!
name|expchar
argument_list|(
name|sep
argument_list|)
operator|)
condition|)
block|{
do|do
block|{
name|sep
operator|=
operator|*
operator|++
name|argscan
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|sep
argument_list|)
condition|)
do|;
comment|/* check for subscript*/
if|if
condition|(
name|sep
operator|==
literal|'['
condition|)
block|{
name|argscan
operator|=
name|bracket_match
argument_list|(
name|argscan
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sep
operator|=
operator|*
name|argscan
operator|)
operator|&&
name|sep
operator|!=
literal|'='
condition|)
name|failed
argument_list|(
name|argi
argument_list|,
name|notid
argument_list|)
expr_stmt|;
operator|*
name|argscan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xp
operator|&
name|V_FLAG
condition|)
block|{
name|n
operator|=
name|findnod
argument_list|(
name|argi
argument_list|,
name|alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|T_FLAG
operator||
name|NO_ALIAS
argument_list|)
condition|)
name|pattrib
argument_list|(
name|n
argument_list|,
operator|~
operator|(
name|NO_ALIAS
operator||
name|T_FLAG
operator||
name|N_EXPORT
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xp
operator|&
name|S_FLAG
condition|)
comment|/* scoped name must be in first tree */
name|n
operator|=
name|findnod
argument_list|(
name|argi
argument_list|,
name|namep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|lookup
argument_list|(
name|argi
argument_list|)
expr_stmt|;
operator|*
name|argscan
operator|++
operator|=
name|sep
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|PATHNOD
operator|||
name|n
operator|==
name|ENVNOD
operator|||
name|n
operator|==
name|SHELLNOD
condition|)
block|{
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
name|failed
argument_list|(
name|argi
argument_list|,
name|restricted
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|SHELLNOD
condition|)
block|{
name|sim
operator|=
name|simple
argument_list|(
name|argscan
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|sim
argument_list|,
literal|'r'
argument_list|)
operator|!=
name|NULL
condition|)
name|rsflag
operator|=
literal|0
expr_stmt|;
comment|/* restricted shell */
block|}
block|}
name|assign
argument_list|(
name|n
argument_list|,
name|argscan
argument_list|)
expr_stmt|;
name|attrib
argument_list|(
name|n
argument_list|,
name|xp
operator|&
operator|~
operator|(
name|S_FLAG
operator||
name|V_FLAG
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|N_EXPORT
argument_list|)
operator|&&
name|attest
argument_list|(
name|n
argument_list|,
name|N_IMPORT
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|xp
operator|&
operator|(
name|S_FLAG
operator||
name|V_FLAG
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|short
name|namlen
decl_stmt|,
name|vallen
decl_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|n
operator|->
name|namid
argument_list|)
expr_stmt|;
name|vallen
operator|=
name|strlen
argument_list|(
name|argscan
argument_list|)
expr_stmt|;
name|ev_$set_var
argument_list|(
name|n
operator|->
name|namid
argument_list|,
operator|&
name|namlen
argument_list|,
name|argscan
argument_list|,
operator|&
name|vallen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* apollo */
if|if
condition|(
name|n
operator|==
name|PATHNOD
condition|)
block|{
name|gscan_some
argument_list|(
name|rehash
argument_list|,
name|alias
argument_list|,
name|T_FLAG
argument_list|,
name|T_FLAG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ECHO_N
name|echo_arg
operator|=
name|NIL
expr_stmt|;
endif|#
directive|endif
comment|/* ECHO_N */
block|}
if|if
condition|(
name|n
operator|==
name|VISINOD
operator|||
operator|(
operator|(
name|n
operator|==
name|EDITNOD
operator|)
operator|&&
name|isnull
argument_list|(
name|VISINOD
argument_list|)
operator|)
condition|)
block|{
comment|/* turn on vi or emacs option if editor name is either*/
name|argscan
operator|=
name|simple
argument_list|(
name|argscan
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|argscan
argument_list|,
literal|"*vi"
argument_list|)
condition|)
block|{
name|off_option
argument_list|(
name|EDITVI
operator||
name|EMACS
operator||
name|GMACS
argument_list|)
expr_stmt|;
name|on_option
argument_list|(
name|EDITVI
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gmatch
argument_list|(
name|argscan
argument_list|,
literal|"*macs"
argument_list|)
condition|)
block|{
name|off_option
argument_list|(
name|EDITVI
operator||
name|EMACS
operator||
name|GMACS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argscan
operator|==
literal|'g'
condition|)
name|on_option
argument_list|(
name|GMACS
argument_list|)
expr_stmt|;
else|else
name|on_option
argument_list|(
name|EMACS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
name|failed
argument_list|(
name|argi
argument_list|,
name|notid
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Mark each node is invalid  */
end_comment

begin_function
specifier|static
name|void
name|rehash
parameter_list|(
name|np
parameter_list|)
specifier|register
name|NAMPTR
name|np
decl_stmt|;
block|{
name|attrib
argument_list|(
name|np
argument_list|,
name|NO_ALIAS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  alias each name to full path name  *  realias returns the pathname or NULL if not found  */
end_comment

begin_function
name|char
modifier|*
name|realias
parameter_list|(
name|np
parameter_list|)
specifier|register
name|NAMPTR
name|np
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|vp
init|=
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
decl_stmt|;
name|int
name|flag
init|=
name|namflag
argument_list|(
name|np
argument_list|)
operator|&
operator|(
name|N_EXPORT
operator||
name|NO_ALIAS
operator||
name|T_FLAG
operator|)
decl_stmt|;
comment|/* turn of T_FLAG to avoid recursion */
name|pattrib
argument_list|(
name|np
argument_list|,
operator|~
operator|(
name|NO_ALIAS
operator||
name|T_FLAG
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|fullname
argument_list|(
name|np
operator|->
name|namid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NIL
condition|)
block|{
name|unassign
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'/'
condition|)
block|{
name|sattrib
argument_list|(
name|np
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|)
operator|!=
literal|0
condition|)
name|assign
argument_list|(
name|np
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* turn T_FLAG back on */
name|attrib
argument_list|(
name|np
argument_list|,
name|T_FLAG
operator||
name|N_EXPORT
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|readvar
parameter_list|(
name|names
parameter_list|,
name|fd
parameter_list|,
name|raw
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
name|FILEBLK
name|fb
decl_stmt|;
name|SHFILE
name|f
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|issep
decl_stmt|;
specifier|register
name|NAMPTR
name|n
decl_stmt|;
name|int
name|checksep
init|=
literal|1
decl_stmt|;
comment|/* set when looking for separators */
name|STKPTR
name|rel
decl_stmt|;
name|char
modifier|*
name|seps
decl_stmt|;
name|char
name|is_eol
decl_stmt|;
name|FILE
modifier|*
name|savef
decl_stmt|;
name|states
operator||=
name|RWAIT
expr_stmt|;
comment|/* save in history file if S_FLAG is set */
if|if
condition|(
operator|(
name|raw
operator|&
name|S_FLAG
operator|)
operator|&&
name|fc_fix
condition|)
name|states
operator||=
name|FIXFLG
expr_stmt|;
name|raw
operator|&=
name|R_FLAG
expr_stmt|;
name|f
operator|=
operator|&
name|fb
expr_stmt|;
if|if
condition|(
operator|*
name|names
condition|)
block|{
if|if
condition|(
name|seps
operator|=
name|strchr
argument_list|(
operator|*
name|names
argument_list|,
literal|'?'
argument_list|)
condition|)
operator|*
name|seps
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|lookup
argument_list|(
operator|*
name|names
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|seps
condition|)
operator|*
name|seps
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|n
operator|=
name|REPLYNOD
expr_stmt|;
name|rel
operator|=
operator|(
name|STKPTR
operator|)
name|relstak
argument_list|()
expr_stmt|;
name|seps
operator|=
name|qvalup
argument_list|(
name|IFSNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|seps
operator|==
name|NULL
condition|)
name|seps
operator|=
name|sptbnl
expr_stmt|;
name|savef
operator|=
name|input
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|bread
argument_list|,
name|noquery
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|input
condition|)
block|{
comment|/* buffer the input stream if possible */
if|if
condition|(
name|fnobuff
argument_list|(
name|fd
argument_list|)
operator|&&
operator|(
name|fd
operator|!=
name|stdin
operator|||
operator|!
name|ispipe
argument_list|(
name|stdin
argument_list|)
operator|)
condition|)
name|setbuf
argument_list|(
name|fd
argument_list|,
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|(
name|raw
condition|?
name|readc
argument_list|()
else|:
name|nextc
argument_list|()
operator|)
expr_stmt|;
name|issep
operator|=
operator|(
name|strchr
argument_list|(
name|seps
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|is_eol
operator|=
name|eolchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksep
operator|&&
name|issep
operator|&&
operator|!
name|is_eol
condition|)
block|{
comment|/* visable adjacent separators signify null fields*/
if|if
condition|(
name|strchr
argument_list|(
name|sptbnl
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
name|checksep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|issep
operator|&&
operator|*
name|names
operator|)
operator|||
name|is_eol
condition|)
comment|/* from non-separator to separator */
block|{
if|if
condition|(
operator|*
name|names
operator|==
name|NULL
operator|&&
name|staktop
operator|>
name|stakbot
condition|)
block|{
comment|/* remove trailing separators */
while|while
condition|(
name|strchr
argument_list|(
name|seps
argument_list|,
operator|*
operator|--
name|staktop
argument_list|)
condition|)
empty_stmt|;
name|staktop
operator|++
expr_stmt|;
block|}
name|zerostak
argument_list|()
expr_stmt|;
name|assign
argument_list|(
name|n
argument_list|,
name|absstak
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|setstak
argument_list|(
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|ALLEXP
argument_list|)
condition|)
name|attrib
argument_list|(
name|n
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|names
condition|?
name|lookup
argument_list|(
operator|*
name|names
operator|++
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_eol
condition|)
break|break;
name|checksep
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* not a separator */
name|pushstak
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|n
condition|)
block|{
name|assign
argument_list|(
name|n
argument_list|,
name|nullstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|ALLEXP
argument_list|)
condition|)
name|attrib
argument_list|(
name|n
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|names
condition|?
name|lookup
argument_list|(
operator|*
name|names
operator|++
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|savef
operator|!=
name|fd
condition|)
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|FIXFLG
condition|)
name|hist_flush
argument_list|()
expr_stmt|;
name|states
operator|&=
operator|~
operator|(
name|RWAIT
operator||
name|PROMPT
operator|)
expr_stmt|;
name|states
operator||=
name|is_option
argument_list|(
name|INTFLG
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * put string v onto the heap and return the heap pointer  */
end_comment

begin_function
name|char
modifier|*
name|heap
parameter_list|(
name|v
parameter_list|)
specifier|register
name|char
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|movstr
argument_list|(
name|v
argument_list|,
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|v
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * print out the name and value of a name-value pair<n>  */
end_comment

begin_function
name|int
name|printnam
parameter_list|(
name|n
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|NAMPTR
name|n
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|union
name|Namval
modifier|*
name|up
init|=
operator|&
name|n
operator|->
name|value
operator|.
name|namval
decl_stmt|;
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
name|fd
operator|=
name|output
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|NO_ALIAS
argument_list|)
operator|==
name|NO_ALIAS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|is_afunction
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|bltfn
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|n
operator|->
name|namid
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
operator|&&
name|n
operator|->
name|value
operator|.
name|namval
operator|.
name|rp
operator|->
name|hoffset
operator|>=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|fn_hdr
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|hist_list
argument_list|(
name|n
operator|->
name|value
operator|.
name|namval
operator|.
name|rp
operator|->
name|hoffset
argument_list|,
name|EOF
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|->
name|namsz
operator|+
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|=
name|valup
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|char
name|numbuf
index|[
literal|30
index|]
decl_stmt|;
name|pr_name
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flag
operator|=
operator|(
name|flag
condition|?
name|NL
else|:
literal|'='
operator|)
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|ARRAY
argument_list|)
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|INT_GER
argument_list|)
condition|)
block|{
comment|/* copy to a save place */
name|strcpy
argument_list|(
name|numbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|numbuf
expr_stmt|;
block|}
name|p_sub
argument_list|(
operator|(
name|int
operator|)
name|up
operator|->
name|aray
operator|->
name|adot
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|flag
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
name|NL
condition|)
name|p_str
argument_list|(
name|s
argument_list|,
name|NL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * print the name of a node followed by the character c  */
end_comment

begin_function
specifier|static
name|void
name|pr_name
parameter_list|(
name|n
parameter_list|,
name|c
parameter_list|)
specifier|register
name|NAMPTR
name|n
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|n
operator|->
name|namid
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|p_str
argument_list|(
name|n
operator|->
name|namid
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'='
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pushnid
parameter_list|(
name|np
parameter_list|)
name|NAMPTR
name|np
decl_stmt|;
block|{
operator|*
name|argnam
operator|++
operator|=
name|np
operator|->
name|namid
expr_stmt|;
name|namec
operator|++
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|ARRAY
argument_list|)
condition|)
name|arayp
argument_list|(
name|np
argument_list|)
operator|->
name|adot
operator|=
name|arayp
argument_list|(
name|np
argument_list|)
operator|->
name|maxi
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print the nodes in tree<root> which have attributes<flag> set  */
end_comment

begin_function
name|void
name|prinscan
parameter_list|(
name|file
parameter_list|,
name|flag
parameter_list|,
name|root
parameter_list|,
name|option
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|Amemory
modifier|*
name|root
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|NAMPTR
name|np
decl_stmt|;
name|p_setout
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|argv
operator|=
name|argnam
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|locstak
argument_list|()
expr_stmt|;
name|namec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|gscan_some
argument_list|(
name|pushnid
argument_list|,
name|root
argument_list|,
name|flag
argument_list|,
name|flag
argument_list|)
expr_stmt|;
else|else
name|gscan_all
argument_list|(
name|pushnid
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|gsort
argument_list|(
name|argv
argument_list|,
name|namec
argument_list|)
expr_stmt|;
while|while
condition|(
name|namec
operator|--
condition|)
block|{
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|cp
operator|=
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'='
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|checkfor
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'='
expr_stmt|;
block|}
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|ARRAY
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|Namaray
modifier|*
name|ap
init|=
name|arayp
argument_list|(
name|np
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|imax
decl_stmt|;
name|i
operator|=
name|ap
operator|->
name|adot
operator|=
literal|0
expr_stmt|;
name|imax
operator|=
name|ap
operator|->
name|maxi
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|imax
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|->
name|adot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|val
index|[
name|i
index|]
condition|)
name|printnam
argument_list|(
name|np
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printnam
argument_list|(
name|np
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|staknam
parameter_list|(
name|n
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
specifier|register
name|NAMPTR
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|getstak
argument_list|(
name|strlen
argument_list|(
name|n
operator|->
name|namid
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|movstr
argument_list|(
name|n
operator|->
name|namid
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'='
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|void
name|printflg
parameter_list|(
name|n
parameter_list|)
specifier|register
name|NAMPTR
name|n
decl_stmt|;
block|{
specifier|register
name|SYSPTR
name|syscan
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
if|if
condition|(
name|namflag
argument_list|(
name|n
argument_list|)
operator|!=
name|N_DEFAULT
condition|)
block|{
name|syscan
operator|=
name|attributes
expr_stmt|;
while|while
condition|(
operator|*
name|syscan
operator|->
name|sysnam
condition|)
block|{
name|val
operator|=
name|syscan
operator|->
name|sysval
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|val
argument_list|)
operator|==
name|val
condition|)
block|{
name|p_str
argument_list|(
name|syscan
operator|->
name|sysnam
argument_list|,
name|SP
argument_list|)
expr_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|L_JUST
operator||
name|R_JUST
operator||
name|Z_FILL
argument_list|)
condition|)
name|p_num
argument_list|(
name|n
operator|->
name|namsz
argument_list|,
name|SP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
name|BLT_NOD
operator||
name|INT_GER
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|val
operator|==
name|INT_GER
operator|&&
name|attest
argument_list|(
name|n
argument_list|,
name|INT_GER
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|namsz
operator|!=
literal|10
condition|)
block|{
name|p_str
argument_list|(
name|intbase
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|p_num
argument_list|(
name|n
operator|->
name|namsz
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|syscan
operator|++
expr_stmt|;
block|}
name|pr_name
argument_list|(
name|n
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|genenv
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|e
init|=
name|environ
decl_stmt|;
specifier|register
name|NAMPTR
name|n
decl_stmt|;
name|rsflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
while|while
condition|(
operator|*
name|e
condition|)
block|{
name|n
operator|=
name|setname
argument_list|(
operator|*
name|e
argument_list|,
operator|(
name|N_IMPORT
operator||
name|N_EXPORT
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|namid
operator|=
operator|*
name|e
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rsflag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|countnam
parameter_list|()
block|{
name|namec
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pushnam
parameter_list|(
name|n
parameter_list|)
specifier|register
name|NAMPTR
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|attest
argument_list|(
name|n
argument_list|,
name|N_IMPORT
argument_list|)
condition|)
operator|*
name|argnam
operator|++
operator|=
name|n
operator|->
name|namid
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|=
name|valup
argument_list|(
name|n
argument_list|)
condition|)
operator|*
name|argnam
operator|++
operator|=
name|staknam
argument_list|(
name|n
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the environment list for the child.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|setenv
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|er
decl_stmt|;
name|namec
operator|=
literal|0
expr_stmt|;
comment|/* L_ARGNOD gets generated automatically as full path name of command */
name|pattrib
argument_list|(
name|L_ARGNOD
argument_list|,
operator|~
name|N_EXPORT
argument_list|)
expr_stmt|;
name|gscan_some
argument_list|(
name|countnam
argument_list|,
name|namep
argument_list|,
name|N_EXPORT
operator||
name|N_IMPORT
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
name|er
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|getstak
argument_list|(
operator|(
name|namec
operator|+
literal|2
operator|)
operator|*
name|BYTESPERWORD
argument_list|)
expr_stmt|;
name|argnam
operator|=
operator|++
name|er
expr_stmt|;
name|gscan_some
argument_list|(
name|pushnam
argument_list|,
name|namep
argument_list|,
name|N_EXPORT
operator||
name|N_IMPORT
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
operator|*
name|argnam
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|er
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the shell name and alias table  */
end_comment

begin_function
name|void
name|meminit
parameter_list|()
block|{
specifier|register
name|NAMPTR
name|np
decl_stmt|;
name|bltin_nodes
operator|=
operator|(
name|NAMPTR
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|NNODES
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Namnod
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|namebase
operator|=
name|namep
operator|=
name|inittree
argument_list|(
name|node_names
argument_list|,
name|bltin_nodes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up random number generator */
ifdef|#
directive|ifdef
name|apollo
operator|(
name|PPIDNOD
operator|)
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ppid
operator|)
expr_stmt|;
operator|(
name|L_ARGNOD
operator|)
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|lastarg
operator|)
expr_stmt|;
operator|(
name|TMOUTNOD
operator|)
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|timeout
operator|)
expr_stmt|;
operator|(
name|SECONDS
operator|)
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|seconds
operator|)
expr_stmt|;
operator|(
name|MCHKNOD
operator|)
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|mailchk
operator|)
expr_stmt|;
operator|(
name|RANDNOD
operator|)
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|randnum
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
name|namflag
argument_list|(
name|RANDNOD
argument_list|)
operator|=
name|N_FREE
operator||
name|INT_GER
operator||
name|BLT_NOD
expr_stmt|;
comment|/* set up the seconds clock */
name|namflag
argument_list|(
name|SECONDS
argument_list|)
operator|=
name|N_FREE
operator||
name|INT_GER
operator||
name|BLT_NOD
expr_stmt|;
name|set_second
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|namflag
argument_list|(
name|MCHKNOD
argument_list|)
operator|=
name|N_FREE
operator||
name|INT_GER
expr_stmt|;
name|namflag
argument_list|(
name|TMOUTNOD
argument_list|)
operator|=
name|INT_GER
expr_stmt|;
name|namflag
argument_list|(
name|PPIDNOD
argument_list|)
operator|=
operator|(
name|N_FREE
operator||
name|INT_GER
operator||
name|N_RDONLY
operator|)
expr_stmt|;
name|namflag
argument_list|(
name|L_ARGNOD
argument_list|)
operator|=
name|N_FREE
operator||
name|IN_DIR
expr_stmt|;
name|np
operator|=
operator|(
name|NAMPTR
operator|)
name|malloc
argument_list|(
name|NALIAS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Namnod
argument_list|)
argument_list|)
expr_stmt|;
name|alias
operator|=
name|inittree
argument_list|(
name|alias_names
argument_list|,
name|np
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
name|prnames
operator|=
name|gettree
argument_list|(
name|MEMSIZE
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * re-initialize name-value pairs after fork  */
end_comment

begin_function
specifier|static
name|struct
name|Amemory
modifier|*
name|inittree
parameter_list|(
name|name_vals
parameter_list|,
name|nodes
parameter_list|,
name|atflag
parameter_list|)
name|struct
name|name_value
modifier|*
name|name_vals
decl_stmt|;
name|NAMPTR
name|nodes
decl_stmt|;
block|{
specifier|register
name|struct
name|Amemory
modifier|*
name|treep
decl_stmt|;
specifier|register
name|NAMPTR
name|np
decl_stmt|;
specifier|register
name|struct
name|name_value
modifier|*
name|nv
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|treep
operator|=
name|gettree
argument_list|(
name|MEMSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nodes
operator|,
name|nv
operator|=
name|name_vals
init|;
operator|*
name|nv
operator|->
name|nv_name
condition|;
name|nv
operator|++
operator|,
name|np
operator|++
control|)
block|{
name|np
operator|->
name|namid
operator|=
name|nv
operator|->
name|nv_name
expr_stmt|;
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
name|nv
operator|->
name|nv_value
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|nv
operator|->
name|nv_value
operator|==
literal|0
condition|)
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
literal|0
expr_stmt|;
elseif|else
else|#
directive|else
if|if
condition|(
name|nv
operator|->
name|nv_value
condition|)
endif|#
directive|endif
comment|/* apollo */
block|{
name|flag
operator|=
name|atflag
operator||
name|N_FREE
expr_stmt|;
if|if
condition|(
name|atflag
operator|&&
operator|*
name|nv
operator|->
name|nv_value
operator|==
literal|'/'
condition|)
name|flag
operator||=
name|T_FLAG
expr_stmt|;
block|}
name|sattrib
argument_list|(
name|np
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|np
operator|->
name|namsz
operator|=
literal|10
expr_stmt|;
name|linknod
argument_list|(
name|np
argument_list|,
name|treep
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|treep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a new environment scope  */
end_comment

begin_function
name|void
name|mem_scope
parameter_list|(
name|envlist
parameter_list|)
name|ARGPTR
name|envlist
decl_stmt|;
block|{
specifier|register
name|struct
name|Amemory
modifier|*
name|sav_namep
init|=
name|namep
decl_stmt|;
specifier|register
name|struct
name|Amemory
modifier|*
name|newscope
decl_stmt|;
name|newscope
operator|=
name|gettree
argument_list|(
name|MEMSIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
name|newscope
operator|->
name|nexttree
operator|=
name|sav_namep
expr_stmt|;
name|namep
operator|=
name|newscope
expr_stmt|;
name|setlist
argument_list|(
name|envlist
argument_list|,
name|N_EXPORT
operator||
name|S_FLAG
argument_list|)
expr_stmt|;
name|newscope
operator|->
name|nexttree
operator|=
name|NULL
expr_stmt|;
name|namep
operator|=
name|sav_namep
expr_stmt|;
name|scan_all
argument_list|(
name|no_export
argument_list|,
name|newscope
argument_list|)
expr_stmt|;
name|newscope
operator|->
name|nexttree
operator|=
name|sav_namep
expr_stmt|;
name|namep
operator|=
name|newscope
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Temporarily remove name from export list of previous scopes  */
end_comment

begin_function
specifier|static
name|void
name|no_export
parameter_list|(
name|nnod
parameter_list|)
specifier|register
name|struct
name|Namnod
modifier|*
name|nnod
decl_stmt|;
block|{
specifier|register
name|struct
name|Namnod
modifier|*
name|np
init|=
name|checkfor
argument_list|(
name|nnod
operator|->
name|namid
argument_list|,
name|namep
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|&&
name|attest
argument_list|(
name|np
argument_list|,
name|N_EXPORT
argument_list|)
condition|)
block|{
name|pattrib
argument_list|(
name|np
argument_list|,
operator|~
name|N_EXPORT
argument_list|)
expr_stmt|;
name|attrib
argument_list|(
name|np
argument_list|,
name|E_FLAG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * free up top environment scope  */
end_comment

begin_function
name|void
name|mem_unscope
parameter_list|()
block|{
specifier|register
name|struct
name|Amemory
modifier|*
name|ap
init|=
name|namep
decl_stmt|;
if|if
condition|(
operator|(
name|namep
operator|=
name|ap
operator|->
name|nexttree
operator|)
operator|==
name|NULL
condition|)
name|namep
operator|=
name|namebase
expr_stmt|;
name|scan_all
argument_list|(
name|rm_node
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up all environment scopes except the first  */
end_comment

begin_function
name|void
name|name_unscope
parameter_list|()
block|{
while|while
condition|(
name|namep
operator|->
name|nexttree
condition|)
name|mem_unscope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a node and free up all the space  * Restate export attribute for hidden nodes if necessary  */
end_comment

begin_function
specifier|static
name|void
name|rm_node
parameter_list|(
name|nnod
parameter_list|)
specifier|register
name|struct
name|Namnod
modifier|*
name|nnod
decl_stmt|;
block|{
specifier|register
name|struct
name|Namnod
modifier|*
name|np
init|=
name|checkfor
argument_list|(
name|nnod
operator|->
name|namid
argument_list|,
name|namep
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|&&
name|attest
argument_list|(
name|np
argument_list|,
name|E_FLAG
argument_list|)
condition|)
block|{
name|pattrib
argument_list|(
name|np
argument_list|,
operator|~
name|E_FLAG
argument_list|)
expr_stmt|;
name|attrib
argument_list|(
name|np
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
block|}
name|pattrib
argument_list|(
name|nnod
argument_list|,
operator|~
name|N_EXPORT
argument_list|)
expr_stmt|;
name|rmlocal
argument_list|(
name|nnod
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nnod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Remove freeable local space associated with the namval field  * of nnod. This includes any strings representing the value(s) of the  * node, as well as its dope vector, if it is an array.  */
end_comment

begin_function
name|void
name|rmlocal
parameter_list|(
name|nnod
parameter_list|)
specifier|register
name|struct
name|Namnod
modifier|*
name|nnod
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|Nodval
modifier|*
name|nv
decl_stmt|;
specifier|register
name|struct
name|Namaray
modifier|*
name|ap
decl_stmt|;
specifier|register
name|union
name|Namval
modifier|*
name|up
init|=
operator|&
name|nnod
operator|->
name|value
operator|.
name|namval
decl_stmt|;
comment|/* return if the node is global or unfreeable */
if|if
condition|(
name|attest
argument_list|(
name|nnod
argument_list|,
name|N_EXPORT
operator||
name|N_FREE
argument_list|)
condition|)
return|return;
comment|/* 	 * If the node is a freeable array, then free both the stringspace 	 * associated with it and its dope vector. 	 */
elseif|else
if|if
condition|(
name|attest
argument_list|(
name|nnod
argument_list|,
name|ARRAY
argument_list|)
condition|)
block|{
name|ap
operator|=
name|up
operator|->
name|aray
expr_stmt|;
name|i
operator|=
name|ap
operator|->
name|maxi
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|nv
operator|=
name|ap
operator|->
name|val
index|[
name|i
operator|--
index|]
expr_stmt|;
if|if
condition|(
name|nv
condition|)
block|{
if|if
condition|(
name|freeble
argument_list|(
name|nv
argument_list|)
condition|)
name|rmnval
argument_list|(
name|unmark
argument_list|(
name|nv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|up
operator|=
operator|&
name|nv
operator|->
name|namval
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|->
name|cp
operator|)
operator|&&
operator|(
operator|(
name|nv
operator|->
name|namflg
operator|&
operator|(
name|N_FREE
operator||
name|N_ALLOC
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|free
argument_list|(
operator|(
name|nv
operator|->
name|namflg
operator|&
name|IN_DIR
operator|)
condition|?
name|up
operator|->
name|up
operator|->
name|cp
else|:
name|up
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|arayp
argument_list|(
name|nnod
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nnod
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  	 * otherwise node is a freeable scalar, so free the string  	 * representing its value. 	 */
else|else
block|{
name|unassign
argument_list|(
name|nnod
argument_list|)
expr_stmt|;
block|}
name|sattrib
argument_list|(
name|nnod
argument_list|,
name|N_DEFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the value of a built-in node  * A lookup may not be necessary  */
end_comment

begin_function
name|char
modifier|*
name|qvalup
parameter_list|(
name|n
parameter_list|)
specifier|register
name|NAMPTR
name|n
decl_stmt|;
block|{
if|if
condition|(
name|namep
operator|->
name|nexttree
condition|)
name|n
operator|=
name|lookup
argument_list|(
operator|(
name|node_names
operator|+
operator|(
name|n
operator|-
name|bltin_nodes
operator|)
operator|)
operator|->
name|nv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|valup
argument_list|(
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lookup name in trees root and return Namnod pointer with this name.  * If none exists, it will not be created.  */
end_comment

begin_function
name|NAMPTR
name|checkfor
parameter_list|(
name|name
parameter_list|,
name|root
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|Amemory
modifier|*
name|root
decl_stmt|;
block|{
specifier|register
name|struct
name|Namnod
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|Amemory
modifier|*
name|app
init|=
name|root
decl_stmt|;
name|struct
name|Namnod
modifier|*
name|findnod
parameter_list|()
function_decl|;
while|while
condition|(
name|app
operator|&&
name|np
operator|==
name|NULL
condition|)
block|{
name|np
operator|=
name|findnod
argument_list|(
name|name
argument_list|,
name|app
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|app
operator|=
name|app
operator|->
name|nexttree
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|np
operator|==
name|NULL
operator|||
name|isnull
argument_list|(
name|np
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  for the whence command  */
end_comment

begin_function
name|void
name|do_whence
parameter_list|(
name|com
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
modifier|*
name|com
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|a1
decl_stmt|;
specifier|register
name|struct
name|Namnod
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|Namnod
modifier|*
name|fp
decl_stmt|;
while|while
condition|(
name|a1
operator|=
operator|*
operator|++
name|com
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|fputs
argument_list|(
name|a1
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
comment|/* reserved words first */
if|if
condition|(
name|syslook
argument_list|(
name|a1
argument_list|,
name|reserved
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|a1
operator|=
name|is_reserved
expr_stmt|;
block|}
comment|/* non-tracked aliases */
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|findnod
argument_list|(
name|a1
argument_list|,
name|alias
argument_list|,
name|CHK_FOR
argument_list|)
operator|)
operator|&&
operator|!
name|isnull
argument_list|(
name|np
argument_list|)
operator|&&
name|attest
argument_list|(
name|np
argument_list|,
name|T_FLAG
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|a1
operator|=
name|valup
argument_list|(
name|np
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|N_EXPORT
argument_list|)
condition|)
name|cp
operator|=
name|is_xalias
expr_stmt|;
else|else
name|cp
operator|=
name|is_alias
expr_stmt|;
name|fputs
argument_list|(
name|cp
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* built-in commands next */
elseif|else
if|if
condition|(
name|syslook
argument_list|(
name|a1
argument_list|,
name|commands
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|a1
operator|=
name|is_builtin
expr_stmt|;
block|}
comment|/* functions next */
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|findnod
argument_list|(
name|a1
argument_list|,
name|prnames
argument_list|,
name|CHK_FOR
argument_list|)
operator|)
operator|&&
operator|!
name|isnull
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|a1
operator|=
name|attest
argument_list|(
name|fp
argument_list|,
name|N_EXPORT
argument_list|)
condition|?
name|is_xfunction
else|:
name|is_function
expr_stmt|;
block|}
else|else
block|{
comment|/* find full pathname */
name|a1
operator|=
name|fullname
argument_list|(
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
comment|/* tracked aliases next */
if|if
condition|(
name|np
operator|&&
name|attest
argument_list|(
name|np
argument_list|,
name|T_FLAG
argument_list|)
operator|&&
operator|*
name|a1
operator|==
literal|'/'
condition|)
name|fputs
argument_list|(
name|is_talias
argument_list|,
name|output
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|is_
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|a1
operator|=
operator|(
name|flag
condition|?
name|notfound
else|:
name|nullstr
operator|)
expr_stmt|;
name|exitval
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|p_str
argument_list|(
name|a1
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * these functions are used to get and set the SECONDS variable  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|sec_offset
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|set_second
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
name|sec_offset
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
operator|-
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_second
parameter_list|()
block|{
return|return
operator|(
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
operator|-
name|sec_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These functions are used to get and set the RANDOM variable  */
end_comment

begin_function
specifier|static
name|int
name|set_rand
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
name|srand
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_rand
parameter_list|()
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|rand
argument_list|()
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ECHO_N
end_ifdef

begin_function
name|char
modifier|*
name|echo_mode
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|optflag
name|savopts
decl_stmt|;
if|if
condition|(
name|echo_arg
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|apollo
specifier|register
name|NAMPTR
name|np
init|=
name|checkfor
argument_list|(
literal|"SYSTYPE"
argument_list|,
name|namep
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
name|cp
operator|=
name|valup
argument_list|(
name|np
argument_list|)
operator|)
condition|)
block|{
name|echo_arg
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'b'
condition|?
name|echo_opt
else|:
name|minus
operator|)
expr_stmt|;
return|return
operator|(
name|echo_arg
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* apollo */
name|savopts
operator|=
name|flags
expr_stmt|;
name|off_option
argument_list|(
name|HASHALL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|fullname
argument_list|(
name|echo_bin
operator|+
literal|5
argument_list|)
expr_stmt|;
name|flags
operator|=
name|savopts
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|cp
argument_list|,
name|echo_bin
argument_list|)
condition|)
name|echo_arg
operator|=
name|echo_opt
expr_stmt|;
else|else
name|echo_arg
operator|=
name|minus
expr_stmt|;
block|}
return|return
operator|(
name|echo_arg
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECHO_N */
end_comment

end_unit

