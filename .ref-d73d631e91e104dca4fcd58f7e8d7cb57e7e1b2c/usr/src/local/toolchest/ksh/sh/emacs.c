begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)emacs.c	1.1 */
end_comment

begin_comment
comment|/* Adapted for ksh by David Korn */
end_comment

begin_comment
comment|/* EMACS_MODES: c tabstop=4   One line screen editor for any program   Questions and comments should be directed to   	Michael T. Veach 	IX 1C-341 X1614 	ihuxl!veach  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DMERT
end_ifdef

begin_comment
comment|/* 3bcc #undefs RT */
end_comment

begin_define
define|#
directive|define
name|RT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_undef
undef|#
directive|undef
name|blank
end_undef

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_define
define|#
directive|define
name|putchar
parameter_list|(
name|c
parameter_list|)
value|e_putchar(c)
end_define

begin_define
define|#
directive|define
name|beep
parameter_list|()
value|e_ringbell()
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|version
index|[]
init|=
literal|"@(#)Editlib version 06/03/86"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
modifier|*
name|_sobuf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|p_flush
parameter_list|()
value|fflush(stderr)
end_define

begin_define
define|#
directive|define
name|output
value|stderr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_define
define|#
directive|define
name|gencpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|e_gencpy(a,b)
end_define

begin_define
define|#
directive|define
name|genncpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|e_genncpy(a,b,n)
end_define

begin_define
define|#
directive|define
name|genlen
parameter_list|(
name|str
parameter_list|)
value|e_genlen(str)
end_define

begin_function_decl
specifier|static
name|int
name|print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isword
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gencpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strcpy((char*)(a),(char*)(b))
end_define

begin_define
define|#
directive|define
name|genncpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|strncpy((char*)(a),(char*)(b),n)
end_define

begin_define
define|#
directive|define
name|genlen
parameter_list|(
name|str
parameter_list|)
value|strlen(str)
end_define

begin_define
define|#
directive|define
name|print
parameter_list|(
name|c
parameter_list|)
value|isprint(c)
end_define

begin_define
define|#
directive|define
name|isword
parameter_list|(
name|c
parameter_list|)
value|isalnum(out[c])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MULTIBYTE */
end_comment

begin_function_decl
specifier|extern
name|histloc
name|hist_find
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|histloc
name|hist_locate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|hist_word
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|e_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|e_getchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|e_putchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ungetchar
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|eol
value|editb.e_eol
end_define

begin_define
define|#
directive|define
name|cur
value|editb.e_cur
end_define

begin_define
define|#
directive|define
name|mark
value|editb.e_fchar
end_define

begin_define
define|#
directive|define
name|hline
value|editb.e_hline
end_define

begin_define
define|#
directive|define
name|hloff
value|editb.e_hloff
end_define

begin_define
define|#
directive|define
name|hismin
value|editb.e_hismin
end_define

begin_define
define|#
directive|define
name|usrkill
value|editb.e_kill
end_define

begin_define
define|#
directive|define
name|usreof
value|editb.e_eof
end_define

begin_define
define|#
directive|define
name|usrerase
value|editb.e_erase
end_define

begin_define
define|#
directive|define
name|crallowed
value|editb.e_crlf
end_define

begin_define
define|#
directive|define
name|llimit
value|editb.e_llimit
end_define

begin_define
define|#
directive|define
name|Prompt
value|editb.e_prompt
end_define

begin_define
define|#
directive|define
name|plen
value|editb.e_plen
end_define

begin_define
define|#
directive|define
name|kstack
value|editb.e_tmp
end_define

begin_define
define|#
directive|define
name|lstring
value|editb.e_search
end_define

begin_define
define|#
directive|define
name|lookahead
value|editb.e_index
end_define

begin_define
define|#
directive|define
name|env
value|editb.e_env
end_define

begin_define
define|#
directive|define
name|raw
value|editb.e_raw
end_define

begin_define
define|#
directive|define
name|histlines
value|editb.e_hismax
end_define

begin_define
define|#
directive|define
name|w_size
value|editb.e_wsize
end_define

begin_define
define|#
directive|define
name|drawbuff
value|editb.e_inbuf
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|LBUF
value|100
end_define

begin_define
define|#
directive|define
name|KILLCHAR
value|UKILL
end_define

begin_define
define|#
directive|define
name|ERASECHAR
value|UERASE
end_define

begin_define
define|#
directive|define
name|EOFCHAR
value|UEOF
end_define

begin_comment
comment|/********************** A large lookahead helps when the user is inserting characters in the middle of the line. ************************/
end_comment

begin_decl_stmt
specifier|static
name|genchar
modifier|*
name|screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to window buffer */
end_comment

begin_decl_stmt
specifier|static
name|genchar
modifier|*
name|cursor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor in real screen */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|CRT
init|=
literal|0
block|,
comment|/* Crt terminal */
name|PAPER
comment|/* Paper terminal */
block|}
name|terminal
enum|;
end_enum

begin_typedef
typedef|typedef
enum|enum
block|{
name|FIRST
block|,
comment|/* First time thru for logical line, prompt on screen */
name|REFRESH
block|,
comment|/* Redraw entire screen */
name|APPEND
block|,
comment|/* Append char before cursor to screen */
name|UPDATE
block|,
comment|/* Update the screen as need be */
name|FINAL
comment|/* Update screen even if pending look ahead */
block|}
name|DRAWTYPE
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|draw
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|escape
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putstring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|search
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setcursor
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|cr_ok
decl_stmt|;
end_decl_stmt

begin_macro
name|hread
argument_list|(
argument|fd
argument_list|,
argument|buff
argument_list|,
argument|scend
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|scend
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|out
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|int
name|adjust
decl_stmt|,
name|oadjust
decl_stmt|;
name|char
name|backslash
decl_stmt|;
name|genchar
modifier|*
name|kptr
decl_stmt|;
specifier|static
name|histloc
name|location
decl_stmt|;
specifier|static
name|int
name|CntrlO
decl_stmt|;
name|char
name|prompt
index|[
name|LBUF
index|]
decl_stmt|;
name|genchar
name|stack
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|string
index|[
name|LBUF
operator|*
name|CHARSIZE
index|]
decl_stmt|;
name|genchar
name|Screen
index|[
name|MAXWINDOW
index|]
decl_stmt|;
name|Prompt
operator|=
name|prompt
expr_stmt|;
name|kstack
operator|=
name|stack
expr_stmt|;
name|lstring
operator|=
name|string
expr_stmt|;
name|screen
operator|=
name|Screen
expr_stmt|;
name|drawbuff
operator|=
name|out
operator|=
operator|(
name|genchar
operator|*
operator|)
name|buff
expr_stmt|;
name|kstack
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|setraw
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p_flush
argument_list|()
expr_stmt|;
return|return
operator|(
name|read
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
name|scend
argument_list|)
operator|)
return|;
block|}
name|raw
operator|=
literal|1
expr_stmt|;
comment|/* This mess in case the read system call fails */
name|e_setup
argument_list|(
name|fd
argument_list|,
name|LBUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|setjmp
argument_list|(
name|env
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|UEOF
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* EOF */
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* some other error */
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE
name|plen
operator|=
name|e_internal
argument_list|(
operator|&
name|Prompt
index|[
literal|1
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Skip the leading \r */
else|#
directive|else
name|gencpy
argument_list|(
name|buff
argument_list|,
operator|&
name|Prompt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Skip the leading \r */
endif|#
directive|endif
comment|/* MULTIBYTE */
name|scend
operator|-=
name|plen
expr_stmt|;
name|llimit
operator|=
name|scend
expr_stmt|;
name|mark
operator|=
name|eol
operator|=
name|cur
operator|=
name|plen
expr_stmt|;
name|draw
argument_list|(
name|FIRST
argument_list|)
expr_stmt|;
name|adjust
operator|=
operator|-
literal|1
expr_stmt|;
name|backslash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CntrlO
condition|)
block|{
name|location
operator|=
name|hist_locate
argument_list|(
name|location
operator|.
name|his_command
argument_list|,
name|location
operator|.
name|his_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|.
name|his_command
operator|<
name|histlines
condition|)
block|{
name|hline
operator|=
name|location
operator|.
name|his_command
expr_stmt|;
name|hloff
operator|=
name|location
operator|.
name|his_line
expr_stmt|;
name|hist_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kstack
argument_list|,
name|hline
argument_list|,
name|hloff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kstack
argument_list|,
name|kstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|Y
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|CntrlO
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|e_getchar
argument_list|()
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|backslash
condition|)
block|{
name|backslash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|usrerase
operator|||
name|c
operator|==
name|usrkill
operator|||
operator|(
operator|!
name|print
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|'\n'
operator|)
operator|)
condition|)
block|{
comment|/* accept a backslashed character */
name|cur
operator|--
expr_stmt|;
name|out
index|[
name|cur
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|out
index|[
name|eol
index|]
operator|=
literal|'\0'
expr_stmt|;
name|draw
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|usrkill
condition|)
block|{
name|c
operator|=
name|KILLCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|usrerase
condition|)
block|{
name|c
operator|=
name|ERASECHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|usreof
operator|)
operator|&&
operator|(
name|eol
operator|==
name|plen
operator|)
condition|)
block|{
name|c
operator|=
name|EOFCHAR
expr_stmt|;
block|}
name|oadjust
operator|=
name|count
operator|=
name|adjust
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|adjust
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|cur
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|cntl
argument_list|(
name|V
argument_list|)
case|:
block|{
name|genchar
name|string
index|[
literal|100
index|]
decl_stmt|;
comment|/* save current line */
name|genncpy
argument_list|(
name|string
argument_list|,
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|string
argument_list|)
operator|/
name|CHARSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out
index|[
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cur
operator|=
name|plen
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_internal
argument_list|(
operator|&
name|version
index|[
literal|4
index|]
argument_list|,
name|out
operator|+
name|plen
argument_list|)
expr_stmt|;
else|#
directive|else
name|gencpy
argument_list|(
name|buff
operator|+
name|plen
argument_list|,
operator|&
name|version
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
name|c
operator|=
name|e_getchar
argument_list|()
expr_stmt|;
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* restore line */
name|cur
operator|=
name|i
expr_stmt|;
name|genncpy
argument_list|(
name|out
argument_list|,
name|string
argument_list|,
sizeof|sizeof
argument_list|(
name|string
argument_list|)
operator|/
name|CHARSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'\0'
case|:
name|mark
operator|=
name|i
expr_stmt|;
continue|continue;
case|case
name|cntl
argument_list|(
name|X
argument_list|)
case|:
name|i
operator|=
name|e_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|cntl
argument_list|(
name|X
argument_list|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mark
operator|>
name|eol
condition|)
name|mark
operator|=
name|eol
expr_stmt|;
name|i
operator|=
name|mark
expr_stmt|;
name|mark
operator|=
name|cur
expr_stmt|;
goto|goto
name|update
goto|;
case|case
name|EOFCHAR
case|:
name|e_flush
argument_list|()
expr_stmt|;
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|u370
case|case
name|cntl
argument_list|(
name|S
argument_list|)
case|:
case|case
name|cntl
argument_list|(
name|Q
argument_list|)
case|:
continue|continue;
endif|#
directive|endif
comment|/* u370 */
default|default:
name|i
operator|=
operator|++
name|eol
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|scend
operator|)
condition|)
comment|/*  will not fit on line */
block|{
name|eol
operator|--
expr_stmt|;
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* save character for next line */
name|draw
argument_list|(
name|FINAL
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
for|for
control|(
name|i
operator|=
name|eol
init|;
name|i
operator|>=
name|cur
condition|;
name|i
operator|--
control|)
block|{
name|out
index|[
name|i
index|]
operator|=
name|out
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|backslash
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|)
expr_stmt|;
name|out
index|[
name|cur
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|draw
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|cntl
argument_list|(
name|Y
argument_list|)
case|:
block|{
name|c
operator|=
name|genlen
argument_list|(
name|kstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|+
name|eol
operator|)
operator|>
name|scend
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|mark
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|eol
init|;
name|i
operator|>=
name|cur
condition|;
name|i
operator|--
control|)
name|out
index|[
name|c
operator|+
name|i
index|]
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
name|kptr
operator|=
name|kstack
expr_stmt|;
while|while
condition|(
name|i
operator|=
operator|*
name|kptr
operator|++
condition|)
name|out
index|[
name|cur
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
name|eol
operator|=
name|genlen
argument_list|(
name|out
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|draw
argument_list|(
name|FINAL
argument_list|)
expr_stmt|;
name|out
index|[
name|eol
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|out
index|[
name|eol
index|]
operator|=
literal|'\0'
expr_stmt|;
name|e_crlf
argument_list|()
expr_stmt|;
goto|goto
name|process
goto|;
case|case
name|ERASECHAR
case|:
if|if
condition|(
name|count
operator|>
operator|(
name|i
operator|-
name|plen
operator|)
condition|)
name|count
operator|=
name|i
operator|-
name|plen
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|--
operator|)
operator|&&
operator|(
name|i
operator|>
name|plen
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|eol
operator|--
expr_stmt|;
block|}
name|genncpy
argument_list|(
name|kstack
argument_list|,
name|out
operator|+
name|i
argument_list|,
name|cur
operator|-
name|i
argument_list|)
expr_stmt|;
name|kstack
index|[
name|cur
operator|-
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|gencpy
argument_list|(
name|out
operator|+
name|i
argument_list|,
name|out
operator|+
name|cur
argument_list|)
expr_stmt|;
name|mark
operator|=
name|i
expr_stmt|;
goto|goto
name|update
goto|;
case|case
name|cntl
argument_list|(
name|W
argument_list|)
case|:
if|if
condition|(
name|mark
operator|>
name|eol
condition|)
name|mark
operator|=
name|eol
expr_stmt|;
if|if
condition|(
name|mark
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
name|mark
operator|>
name|i
condition|)
block|{
name|adjust
operator|=
name|mark
operator|-
name|i
expr_stmt|;
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|D
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|adjust
operator|=
name|i
operator|-
name|mark
expr_stmt|;
name|ungetchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|cntl
argument_list|(
name|D
argument_list|)
case|:
name|mark
operator|=
name|i
expr_stmt|;
name|kptr
operator|=
name|kstack
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|--
operator|)
operator|&&
operator|(
name|eol
operator|>
name|plen
operator|)
operator|&&
operator|(
name|i
operator|<
name|eol
operator|)
condition|)
block|{
operator|*
name|kptr
operator|++
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
name|eol
operator|--
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|out
index|[
name|i
index|]
operator|=
name|out
index|[
operator|(
name|i
operator|+
literal|1
operator|)
index|]
operator|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|cur
expr_stmt|;
block|}
operator|*
name|kptr
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|update
goto|;
case|case
name|cntl
argument_list|(
name|C
argument_list|)
case|:
case|case
name|cntl
argument_list|(
name|F
argument_list|)
case|:
block|{
name|int
name|cntlC
init|=
operator|(
name|c
operator|==
name|cntl
argument_list|(
name|C
argument_list|)
operator|)
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|eol
operator|>
name|i
condition|)
block|{
if|if
condition|(
name|cntlC
condition|)
block|{
name|c
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
if|if
condition|(
operator|(
name|c
operator|&
operator|~
name|STRIP
operator|)
operator|==
literal|0
operator|&&
name|islower
argument_list|(
name|c
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
endif|#
directive|endif
comment|/* MULTIBYTE */
block|{
name|c
operator|+=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
goto|goto
name|update
goto|;
block|}
case|case
name|cntl
argument_list|(])
case|:
name|c
operator|=
name|e_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|eol
condition|)
block|{
if|if
condition|(
name|out
index|[
name|i
index|]
operator|==
name|c
condition|)
goto|goto
name|update
goto|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|plen
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|cur
condition|)
block|{
if|if
condition|(
name|out
index|[
name|i
index|]
operator|==
name|c
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|update
label|:
name|cur
operator|=
name|i
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|cntl
argument_list|(
name|B
argument_list|)
case|:
if|if
condition|(
name|count
operator|>
operator|(
name|i
operator|-
name|plen
operator|)
condition|)
name|count
operator|=
name|i
operator|-
name|plen
expr_stmt|;
name|i
operator|-=
name|count
expr_stmt|;
goto|goto
name|update
goto|;
case|case
name|cntl
argument_list|(
name|T
argument_list|)
case|:
if|if
condition|(
operator|(
name|is_option
argument_list|(
name|GMACS
argument_list|)
operator|)
operator|||
operator|(
name|eol
operator|==
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|plen
operator|+
literal|2
condition|)
block|{
name|c
operator|=
name|out
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|out
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|out
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
name|out
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|eol
operator|>
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
block|{
name|c
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|out
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|out
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
goto|goto
name|update
goto|;
case|case
name|cntl
argument_list|(
name|A
argument_list|)
case|:
name|i
operator|=
name|plen
expr_stmt|;
goto|goto
name|update
goto|;
case|case
name|cntl
argument_list|(
name|E
argument_list|)
case|:
name|i
operator|=
name|eol
expr_stmt|;
goto|goto
name|update
goto|;
case|case
name|cntl
argument_list|(
name|U
argument_list|)
case|:
name|adjust
operator|=
literal|4
operator|*
name|count
expr_stmt|;
continue|continue;
case|case
name|KILLCHAR
case|:
name|cur
operator|=
name|plen
expr_stmt|;
name|oadjust
operator|=
operator|-
literal|1
expr_stmt|;
case|case
name|cntl
argument_list|(
name|K
argument_list|)
case|:
if|if
condition|(
name|oadjust
operator|>=
literal|0
condition|)
block|{
name|mark
operator|=
name|plen
operator|+
name|count
expr_stmt|;
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|W
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|cur
expr_stmt|;
name|eol
operator|=
name|i
expr_stmt|;
name|mark
operator|=
name|i
expr_stmt|;
name|gencpy
argument_list|(
name|kstack
argument_list|,
operator|&
name|out
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|KILLCHAR
condition|)
block|{
if|if
condition|(
name|terminal
operator|==
name|PAPER
condition|)
name|putstring
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|c
operator|=
name|e_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|usrkill
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|terminal
operator|==
name|PAPER
condition|)
name|terminal
operator|=
name|CRT
expr_stmt|;
else|else
block|{
name|terminal
operator|=
name|PAPER
expr_stmt|;
name|putstring
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
name|cntl
argument_list|(
name|L
argument_list|)
case|:
name|e_crlf
argument_list|()
expr_stmt|;
name|draw
argument_list|(
name|REFRESH
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|cntl
argument_list|(
index|[
argument_list|)
operator|:
name|adjust
operator|=
name|escape
argument_list|(
name|out
argument_list|,
name|oadjust
argument_list|)
expr|;
continue|continue;
case|case
name|cntl
argument_list|(
name|R
argument_list|)
case|:
name|search
argument_list|(
name|out
argument_list|,
name|count
argument_list|)
expr_stmt|;
goto|goto
name|drawline
goto|;
case|case
name|cntl
argument_list|(
name|P
argument_list|)
case|:
name|location
operator|=
name|hist_locate
argument_list|(
name|hline
argument_list|,
name|hloff
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
name|hline
operator|=
name|location
operator|.
name|his_command
expr_stmt|;
if|if
condition|(
name|hline
operator|<
name|hismin
condition|)
block|{
name|hline
operator|=
name|hismin
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
goto|goto
name|common
goto|;
case|case
name|cntl
argument_list|(
name|O
argument_list|)
case|:
name|location
operator|.
name|his_command
operator|=
name|hline
expr_stmt|;
name|location
operator|.
name|his_line
operator|=
name|hloff
expr_stmt|;
name|CntrlO
operator|=
literal|1
expr_stmt|;
name|draw
argument_list|(
name|FINAL
argument_list|)
expr_stmt|;
name|out
index|[
name|eol
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|out
index|[
name|eol
index|]
operator|=
literal|'\0'
expr_stmt|;
name|e_crlf
argument_list|()
expr_stmt|;
goto|goto
name|process
goto|;
case|case
name|cntl
argument_list|(
name|N
argument_list|)
case|:
name|location
operator|=
name|hist_locate
argument_list|(
name|hline
argument_list|,
name|hloff
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|.
name|his_command
operator|>
name|histlines
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|hline
operator|=
name|location
operator|.
name|his_command
expr_stmt|;
name|common
label|:
name|hloff
operator|=
name|location
operator|.
name|his_line
expr_stmt|;
name|hist_copy
argument_list|(
operator|&
name|out
index|[
name|plen
index|]
argument_list|,
name|hline
argument_list|,
name|hloff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|out
index|[
name|plen
index|]
operator|)
argument_list|,
operator|&
name|out
index|[
name|plen
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|drawline
label|:
name|eol
operator|=
name|genlen
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eol
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|process
label|:
if|if
condition|(
name|c
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
name|lookahead
operator|=
literal|0
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|out
index|[
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|gencpy
argument_list|(
name|out
argument_list|,
operator|&
name|out
index|[
name|plen
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_external
argument_list|(
name|out
argument_list|,
name|buff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
ifdef|#
directive|ifdef
name|u370
name|putchar
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* u370 */
name|e_flush
argument_list|()
expr_stmt|;
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|putstring
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|escape
parameter_list|(
name|out
parameter_list|,
name|count
parameter_list|)
specifier|register
name|genchar
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|value
decl_stmt|;
name|int
name|digit
decl_stmt|,
name|ch
decl_stmt|;
name|digit
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|e_getchar
argument_list|()
operator|)
operator|,
name|isdigit
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|value
operator|*=
literal|10
expr_stmt|;
name|value
operator|+=
operator|(
name|i
operator|-
literal|'0'
operator|)
expr_stmt|;
name|digit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|digit
condition|)
block|{
name|ungetchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
name|value
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|ch
operator|=
name|i
condition|)
block|{
case|case
literal|' '
case|:
name|mark
operator|=
name|cur
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'p'
case|:
comment|/* M-p == ^W^Y (copy stack == kill& yank) */
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|Y
argument_list|)
argument_list|)
expr_stmt|;
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|W
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'l'
case|:
comment|/* M-l == lower-case */
case|case
literal|'d'
case|:
case|case
literal|'c'
case|:
case|case
literal|'f'
case|:
block|{
name|i
operator|=
name|cur
expr_stmt|;
while|while
condition|(
name|value
operator|--
operator|&&
name|i
operator|<
name|eol
condition|)
block|{
while|while
condition|(
operator|!
name|isword
argument_list|(
name|i
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|out
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|isword
argument_list|(
name|i
argument_list|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
block|{
name|value
operator|=
name|i
operator|-
name|cur
expr_stmt|;
while|while
condition|(
name|value
operator|--
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|out
index|[
name|cur
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
if|if
condition|(
operator|(
name|i
operator|&
operator|~
name|STRIP
operator|)
operator|==
literal|0
operator|&&
name|isupper
argument_list|(
name|i
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|isupper
argument_list|(
name|i
argument_list|)
condition|)
endif|#
directive|endif
comment|/* MULTIBYTE */
block|{
name|i
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
name|out
index|[
name|cur
index|]
operator|=
name|i
expr_stmt|;
block|}
name|cur
operator|++
expr_stmt|;
block|}
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'f'
condition|)
block|{
name|cur
operator|=
name|i
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'c'
condition|)
block|{
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|C
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|-
name|cur
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|-
name|cur
condition|)
block|{
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|D
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|-
name|cur
operator|)
return|;
block|}
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
case|case
literal|'b'
case|:
case|case
name|DELETE
case|:
case|case
literal|'\b'
case|:
case|case
literal|'h'
case|:
block|{
name|i
operator|=
name|cur
expr_stmt|;
while|while
condition|(
name|value
operator|--
operator|&&
name|i
operator|>
name|plen
condition|)
block|{
name|i
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|>
name|plen
operator|)
operator|&&
operator|(
operator|!
name|isword
argument_list|(
name|i
argument_list|)
operator|)
condition|)
name|i
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|>
name|plen
operator|)
operator|&&
operator|(
name|isword
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|)
condition|)
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'b'
condition|)
block|{
name|cur
operator|=
name|i
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|ungetchar
argument_list|(
name|ERASECHAR
argument_list|)
expr_stmt|;
return|return
operator|(
name|cur
operator|-
name|i
operator|)
return|;
block|}
block|}
case|case
literal|'>'
case|:
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|N
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|histlines
operator|-
operator|(
name|hline
operator|+
literal|1
operator|)
operator|)
return|;
case|case
literal|'<'
case|:
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|P
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hline
operator|)
return|;
ifdef|#
directive|ifdef
name|KSHELL
case|case
literal|'_'
case|:
case|case
literal|'.'
case|:
block|{
name|genchar
name|name
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|hist_word
argument_list|(
name|buf
argument_list|,
operator|(
name|count
condition|?
name|count
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|KSHELL
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* KSHELL */
if|if
condition|(
operator|(
name|eol
operator|-
name|cur
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mark
operator|=
name|cur
expr_stmt|;
name|gencpy
argument_list|(
name|name
argument_list|,
operator|&
name|out
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
name|out
index|[
name|cur
operator|++
index|]
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|eol
operator|++
expr_stmt|;
block|}
name|gencpy
argument_list|(
operator|&
name|out
index|[
name|cur
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* file name expansion */
case|case
name|cntl
argument_list|(
index|[
argument_list|)
operator|:
comment|/* easier to type */
name|i
operator|=
literal|'*'
expr|;
case|case
literal|'*'
case|:
case|case
literal|'='
case|:
comment|/* escape = - list all matching file names */
name|mark
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|q_expand
argument_list|(
name|out
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|eol
argument_list|,
name|plen
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
else|else
name|draw
argument_list|(
name|REFRESH
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
comment|/* look for user defined macro definitions */
if|if
condition|(
name|e_macro
argument_list|(
name|i
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
default|default:
endif|#
directive|endif
comment|/* KSHELL */
name|ungetchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ungetchar
argument_list|(
name|cntl
argument_list|(
index|[
argument_list|)
argument_list|)
expr|;
name|ungetchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|search
parameter_list|(
name|out
parameter_list|,
name|direction
parameter_list|)
name|genchar
name|out
index|[]
decl_stmt|;
block|{
specifier|static
name|int
name|prevdirection
init|=
literal|1
decl_stmt|;
name|histloc
name|location
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|sl
decl_stmt|;
name|genchar
name|str_buff
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|string
init|=
name|drawbuff
decl_stmt|;
comment|/* save current line */
name|char
name|sav_cur
init|=
name|cur
decl_stmt|;
name|genncpy
argument_list|(
name|str_buff
argument_list|,
name|string
argument_list|,
sizeof|sizeof
argument_list|(
name|str_buff
argument_list|)
operator|/
name|CHARSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|plen
index|]
operator|=
literal|'^'
expr_stmt|;
name|string
index|[
name|plen
operator|+
literal|1
index|]
operator|=
literal|'R'
expr_stmt|;
name|string
index|[
name|plen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sl
operator|=
literal|2
operator|+
name|plen
expr_stmt|;
name|cur
operator|=
name|sl
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|e_getchar
argument_list|()
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|usrerase
condition|)
block|{
if|if
condition|(
name|sl
operator|>
literal|2
operator|+
name|plen
condition|)
block|{
name|string
index|[
operator|--
name|sl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cur
operator|=
name|sl
expr_stmt|;
name|draw
argument_list|(
name|UPDATE
argument_list|)
expr_stmt|;
block|}
else|else
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
name|usrkill
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
goto|goto
name|restore
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|'\\'
condition|)
block|{
name|string
index|[
name|sl
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|string
index|[
name|sl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cur
operator|=
name|sl
expr_stmt|;
name|draw
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
name|i
operator|=
name|e_getchar
argument_list|()
expr_stmt|;
name|string
index|[
operator|--
name|sl
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|string
index|[
name|sl
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|string
index|[
name|sl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cur
operator|=
name|sl
expr_stmt|;
name|draw
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|genlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|<
literal|1
condition|)
block|{
name|prevdirection
operator|=
operator|-
name|prevdirection
expr_stmt|;
name|direction
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|direction
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|2
operator|+
name|plen
condition|)
block|{
name|gencpy
argument_list|(
name|lstring
argument_list|,
operator|&
name|string
index|[
literal|2
operator|+
name|plen
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_external
argument_list|(
name|lstring
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lstring
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|prevdirection
operator|=
name|direction
expr_stmt|;
block|}
else|else
name|direction
operator|=
name|prevdirection
expr_stmt|;
name|location
operator|=
name|hist_find
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lstring
argument_list|,
name|hline
argument_list|,
literal|1
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|i
operator|=
name|location
operator|.
name|his_command
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|hline
operator|=
name|i
expr_stmt|;
name|hloff
operator|=
name|location
operator|.
name|his_line
expr_stmt|;
name|hist_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|out
index|[
name|plen
index|]
argument_list|,
name|hline
argument_list|,
name|hloff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|out
index|[
name|plen
index|]
argument_list|,
operator|&
name|out
index|[
name|plen
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
return|return;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|hloff
operator|=
operator|(
name|fc_fix
condition|?
name|fc_fix
operator|->
name|fixline
else|:
literal|0
operator|)
expr_stmt|;
name|hline
operator|=
name|histlines
expr_stmt|;
block|}
name|restore
label|:
name|genncpy
argument_list|(
name|string
argument_list|,
name|str_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|str_buff
argument_list|)
operator|/
name|CHARSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|sav_cur
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Adjust screen to agree with inputs: logical line and cursor */
end_comment

begin_comment
comment|/* If 'first' assume screen is blank */
end_comment

begin_function
specifier|static
name|void
name|draw
parameter_list|(
name|option
parameter_list|)
name|DRAWTYPE
name|option
decl_stmt|;
block|{
define|#
directive|define
name|NORMAL
value|' '
define|#
directive|define
name|LOWER
value|'<'
define|#
directive|define
name|BOTH
value|'*'
define|#
directive|define
name|UPPER
value|'>'
define|#
directive|define
name|UNDEF
value|0
specifier|static
name|char
name|overflow
decl_stmt|;
comment|/* Screen overflow flag set */
specifier|register
name|genchar
modifier|*
name|sptr
decl_stmt|;
comment|/* Pointer within screen */
specifier|static
name|int
name|offset
decl_stmt|;
comment|/* Screen offset */
specifier|static
name|char
name|scvalid
decl_stmt|;
comment|/* Screen is up to date */
name|genchar
name|nscreen
index|[
literal|2
operator|*
name|MAXLINE
index|]
decl_stmt|;
comment|/* New entire screen */
name|genchar
modifier|*
name|ncursor
decl_stmt|;
comment|/* New cursor */
specifier|register
name|genchar
modifier|*
name|nptr
decl_stmt|;
comment|/* Pointer to New screen */
name|char
name|longline
decl_stmt|;
comment|/* Line overflow */
name|genchar
modifier|*
name|logcursor
decl_stmt|;
name|genchar
modifier|*
name|nscend
decl_stmt|;
comment|/* end of logical screen */
specifier|register
name|int
name|i
decl_stmt|;
name|nptr
operator|=
name|nscreen
expr_stmt|;
name|sptr
operator|=
name|drawbuff
expr_stmt|;
name|logcursor
operator|=
name|sptr
operator|+
name|cur
expr_stmt|;
name|ncursor
operator|=
name|nscreen
expr_stmt|;
name|longline
operator|=
name|NORMAL
expr_stmt|;
if|if
condition|(
name|option
operator|==
name|FIRST
operator|||
name|option
operator|==
name|REFRESH
condition|)
block|{
name|overflow
operator|=
name|NORMAL
expr_stmt|;
name|cursor
operator|=
name|screen
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|cr_ok
operator|=
name|crallowed
expr_stmt|;
if|if
condition|(
name|option
operator|==
name|FIRST
condition|)
block|{
name|scvalid
operator|=
literal|1
expr_stmt|;
name|gencpy
argument_list|(
name|cursor
argument_list|,
name|sptr
argument_list|)
expr_stmt|;
name|cursor
operator|+=
name|plen
expr_stmt|;
return|return;
block|}
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/********************* 	 Do not update screen if pending characters 	**********************/
if|if
condition|(
operator|(
name|lookahead
operator|)
operator|&&
operator|(
name|option
operator|!=
name|FINAL
operator|)
condition|)
block|{
name|scvalid
operator|=
literal|0
expr_stmt|;
comment|/* Screen is out of date, APPEND will not work */
return|return;
block|}
comment|/*************************************** 	If in append mode, cursor at end of line, screen up to date, 	the previous character was a 'normal' character, 	and the window has room for another character. 	Then output the character and adjust the screen only. 	*****************************************/
name|i
operator|=
operator|*
operator|(
name|logcursor
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|==
name|APPEND
operator|)
operator|&&
operator|(
name|scvalid
operator|)
operator|&&
operator|(
operator|*
name|logcursor
operator|==
literal|'\0'
operator|)
operator|&&
name|print
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
operator|(
name|cursor
operator|-
name|screen
operator|)
operator|<
operator|(
name|w_size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|putchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|i
expr_stmt|;
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
comment|/* copy the prompt */
name|i
operator|=
name|plen
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|nptr
index|[
name|i
index|]
operator|=
name|sptr
index|[
name|i
index|]
expr_stmt|;
comment|/* now the rest of the line */
name|ncursor
operator|=
name|nptr
operator|+
name|e_virt_to_phys
argument_list|(
name|sptr
argument_list|,
name|nptr
argument_list|,
name|cur
argument_list|,
name|plen
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|nptr
operator|+=
name|genlen
argument_list|(
name|nptr
argument_list|)
expr_stmt|;
name|sptr
operator|+=
name|genlen
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
name|nscend
operator|=
name|nptr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sptr
operator|==
name|logcursor
condition|)
name|ncursor
operator|=
name|nptr
expr_stmt|;
comment|/********************* 	 Does ncursor appear on the screen? 	 If not, adjust the screen offset so it does. 	**********************/
name|i
operator|=
name|ncursor
operator|-
name|nscreen
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<=
name|offset
operator|)
operator|||
operator|(
name|i
operator|>=
operator|(
name|offset
operator|+
name|w_size
operator|)
operator|)
condition|)
block|{
name|offset
operator|=
name|i
operator|-
operator|(
name|w_size
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|plen
condition|)
block|{
name|offset
operator|=
operator|(
name|crallowed
operator|==
name|YES
operator|)
condition|?
literal|0
else|:
name|plen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|offset
operator|>=
name|plen
operator|)
operator|&&
operator|(
name|cr_ok
operator|==
name|NO
operator|)
condition|)
block|{
comment|/********************************* 			 Don't really know whats on the screen 			 because of strange characters in the prompt. 			 			 Mark entire screen as unknow. 			***********************************/
name|cursor
operator|=
name|screen
expr_stmt|;
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|UNDEF
expr_stmt|;
name|cr_ok
operator|=
name|YES
expr_stmt|;
block|}
block|}
comment|/********************* 	 Is the range of screen[0] thru screen[w_size] up-to-date 	 with nscreen[offset] thru nscreen[offset+w_size] ? 	 If not, update as need be. 	***********************/
name|nptr
operator|=
operator|&
name|nscreen
index|[
name|offset
index|]
expr_stmt|;
name|sptr
operator|=
name|screen
expr_stmt|;
name|i
operator|=
name|w_size
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nptr
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|(
name|nptr
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|nptr
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|(
name|sptr
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sptr
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nptr
operator|==
operator|*
name|sptr
condition|)
block|{
name|nptr
operator|++
expr_stmt|;
name|sptr
operator|++
expr_stmt|;
continue|continue;
block|}
name|setcursor
argument_list|(
name|sptr
operator|-
name|screen
argument_list|,
operator|*
name|nptr
argument_list|)
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
operator|*
name|nptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
while|while
condition|(
operator|*
name|nptr
operator|==
name|MARKER
condition|)
block|{
operator|*
name|sptr
operator|++
operator|=
operator|*
name|nptr
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
block|}
comment|/****************** 	 	Screen overflow checks  	 	********************/
if|if
condition|(
name|nscend
operator|>=
operator|&
name|nscreen
index|[
name|offset
operator|+
name|w_size
index|]
condition|)
block|{
if|if
condition|(
name|offset
operator|>
name|plen
condition|)
name|longline
operator|=
name|BOTH
expr_stmt|;
else|else
name|longline
operator|=
name|UPPER
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|>
name|plen
condition|)
name|longline
operator|=
name|LOWER
expr_stmt|;
block|}
comment|/* Update screen overflow indicator if need be */
if|if
condition|(
name|longline
operator|!=
name|overflow
condition|)
block|{
name|setcursor
argument_list|(
name|w_size
argument_list|,
name|longline
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|longline
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|ncursor
operator|-
name|nscreen
operator|)
operator|-
name|offset
expr_stmt|;
name|setcursor
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scvalid
operator|=
literal|1
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * put the cursor to the<new> position within screen buffer  * if<c> is non-zero then output this character  * cursor is set to reflect the change  */
end_comment

begin_function
specifier|static
name|void
name|setcursor
parameter_list|(
name|new
parameter_list|,
name|c
parameter_list|)
specifier|register
name|int
name|new
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|old
init|=
name|cursor
operator|-
name|screen
decl_stmt|;
if|if
condition|(
name|old
operator|>
name|new
condition|)
block|{
if|if
condition|(
operator|(
name|cr_ok
operator|==
name|NO
operator|)
operator|||
operator|(
operator|(
name|new
operator|*
literal|2
operator|)
operator|>
name|old
operator|)
condition|)
block|{
while|while
condition|(
name|old
operator|>
name|new
condition|)
block|{
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|old
operator|--
expr_stmt|;
block|}
goto|goto
name|skip
goto|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|old
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|new
operator|>
name|old
condition|)
name|putchar
argument_list|(
name|screen
index|[
name|old
operator|++
index|]
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
name|c
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|new
operator|++
expr_stmt|;
block|}
name|cursor
operator|=
name|screen
operator|+
name|new
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_function
specifier|static
name|int
name|print
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|c
operator|&
operator|~
name|STRIP
operator|)
operator|==
literal|0
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isword
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|drawbuff
index|[
name|i
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|c
operator|&
operator|~
name|STRIP
operator|)
operator|||
name|isalnum
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

end_unit

