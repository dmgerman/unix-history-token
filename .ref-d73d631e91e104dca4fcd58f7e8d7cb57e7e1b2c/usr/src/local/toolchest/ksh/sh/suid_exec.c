begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This is a program to execute 'execute only' and suid/sgid shell scripts.  * This program must be owned by root and  must have the suid bit set.  * This program must be installed as define parameter THISPROG for this to work  *  on system V machines  *  *  Written by David Korn  *  AT&T Bell Laboratories  *  ulysses!dgk  */
end_comment

begin_comment
comment|/* The file name of the script to execute is argv[0]  * Argv[1] is the  program name  * The basic idea is to open the script as standard input, set the effective  *   user and group id correctly, and then exec the shell.  * The complicated part is getting the effective uid of the caller and   *   setting the effective uid/gid.  The program which execs this program  *   must pass file descriptor FDIN as an open file with mode SPECIAL if  *   the effective user id is not the real user id.  The effective  *   user id for authentication purposes will be the owner of this  *   open file.  On systems without the setreuid() call, e[ug]id is set  *   by copying this program to a /tmp/file, making it a suid and/or sgid  *   program, and then execing this program.  * A forked version of this program waits until it can unlink the /tmp  *   file and then exits.  Actually, we fork() twice so the parent can  *   wait for the child to complete.  A pipe is used to guarantee that we  *   do not remove the /tmp file too soon.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|fcntl
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|dup2(a,c)
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|SPECIAL
value|04100
end_define

begin_comment
comment|/* setuid execute only by owner */
end_comment

begin_define
define|#
directive|define
name|FDIN
value|10
end_define

begin_comment
comment|/* must be same as /dev/fd below */
end_comment

begin_define
define|#
directive|define
name|FDSYNC
value|11
end_define

begin_comment
comment|/* used on sys5 to syncronize cleanup */
end_comment

begin_define
define|#
directive|define
name|BLKSIZE
value|sizeof(char*)*1024
end_define

begin_define
define|#
directive|define
name|THISPROG
value|"/etc/suid_exec"
end_define

begin_define
define|#
directive|define
name|DEFSHELL
value|"/bin/sh"
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_dir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|endsh
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|BSD_4_2
end_ifndef

begin_function_decl
specifier|static
name|int
name|copy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|version
index|[]
init|=
literal|"@(#)suid_exec 06/03/86a"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|badopen
index|[]
init|=
literal|"cannot open"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|badexec
index|[]
init|=
literal|"cannot exec"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tmpname
index|[]
init|=
literal|"/tmp/SUIDXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|devfd
index|[]
init|=
literal|"/dev/fd/10"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|created
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ruserid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|euserid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rgroupid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egroupid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stat
name|statb
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|effuid
decl_stmt|;
name|int
name|effgid
decl_stmt|;
name|int
name|priv
init|=
literal|0
decl_stmt|;
name|arglist
operator|=
name|argv
expr_stmt|;
name|command
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|ruserid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|euserid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|rgroupid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|egroupid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD_4_2
name|mktemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|tmpname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This enables the grandchild to clean up /tmp file */
name|close
argument_list|(
name|FDSYNC
argument_list|)
expr_stmt|;
comment|/* make sure that this is a valid invocation of /tmp prog */
comment|/* the /tmp file must be owned by root, setuid, and not a link */
if|if
condition|(
name|euserid
operator|==
literal|0
operator|&&
name|ruserid
operator|!=
literal|0
condition|)
block|{
comment|/* keep out forgers */
if|if
condition|(
name|stat
argument_list|(
name|tmpname
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
comment|/* don't trust /tmp file unless suid root */
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|==
literal|0
operator|||
name|statb
operator|.
name|st_uid
operator|||
name|statb
operator|.
name|st_nlink
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exec
goto|;
block|}
comment|/* make sure that this is the real setuid program, not the clone */
if|if
condition|(
name|euserid
operator|||
name|command
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD_4_2 */
comment|/* validate execution rights to this script */
if|if
condition|(
name|fstat
argument_list|(
name|FDIN
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|effuid
operator|++
expr_stmt|;
name|euserid
operator|=
name|ruserid
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
operator|)
operator|!=
name|SPECIAL
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
name|euserid
operator|=
name|statb
operator|.
name|st_uid
expr_stmt|;
block|}
comment|/* do it the easy way if you can */
if|if
condition|(
name|euserid
operator|==
name|ruserid
operator|&&
name|egroupid
operator|==
name|rgroupid
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* have to check access on each component */
while|while
condition|(
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eaccess
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|n
expr_stmt|;
block|}
block|}
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* open the script for reading and make it be FDIN */
name|n
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badopen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|n
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badopen
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|FDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|n
argument_list|,
name|F_DUPFD
argument_list|,
name|FDIN
argument_list|)
operator|!=
name|FDIN
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* compute the desired new effective user and group id */
name|effuid
operator|=
name|euserid
expr_stmt|;
name|effgid
operator|=
name|egroupid
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|statb
operator|.
name|st_mode
operator|&
name|S_ISUID
condition|)
name|effuid
operator|=
name|statb
operator|.
name|st_uid
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|statb
operator|.
name|st_mode
operator|&
name|S_ISGID
condition|)
name|effgid
operator|=
name|statb
operator|.
name|st_gid
expr_stmt|;
comment|/* see if group needs setting */
if|if
condition|(
name|effgid
operator|!=
name|egroupid
condition|)
if|if
condition|(
name|effgid
operator|!=
name|rgroupid
operator|||
name|setgid
argument_list|(
name|rgroupid
argument_list|)
operator|<
literal|0
condition|)
name|mode
operator|=
name|S_ISGID
expr_stmt|;
comment|/* now see if the uid needs setting */
if|if
condition|(
name|effuid
condition|)
if|if
condition|(
name|mode
operator|||
name|effuid
operator|!=
name|ruserid
operator|||
name|setuid
argument_list|(
name|ruserid
argument_list|)
operator|<
literal|0
condition|)
name|mode
operator||=
name|S_ISUID
expr_stmt|;
if|if
condition|(
name|mode
condition|)
name|setids
argument_list|(
name|mode
argument_list|,
name|effuid
argument_list|,
name|effgid
argument_list|)
expr_stmt|;
name|exec
label|:
comment|/* only use SHELL if file is in trusted directory and ends in sh */
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell
operator|==
literal|0
operator|||
operator|!
name|endsh
argument_list|(
name|shell
argument_list|)
operator|||
operator|(
operator|!
name|in_dir
argument_list|(
literal|"/bin"
argument_list|,
name|shell
argument_list|)
operator|&&
operator|!
name|in_dir
argument_list|(
literal|"/usr/bin"
argument_list|,
name|shell
argument_list|)
operator|&&
operator|!
name|in_dir
argument_list|(
literal|"/usr/lbin"
argument_list|,
name|shell
argument_list|)
operator|)
condition|)
name|shell
operator|=
name|DEFSHELL
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|command
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|devfd
expr_stmt|;
name|execv
argument_list|(
name|shell
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return true of shell ends in sh  */
end_comment

begin_function
specifier|static
name|int
name|endsh
parameter_list|(
name|shell
parameter_list|)
specifier|register
name|char
modifier|*
name|shell
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|shell
condition|)
name|shell
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|shell
operator|!=
literal|'h'
operator|||
operator|*
operator|--
name|shell
operator|!=
literal|'s'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return true of shell is in<dir> directory  */
end_comment

begin_function
specifier|static
name|int
name|in_dir
parameter_list|(
name|dir
parameter_list|,
name|shell
parameter_list|)
specifier|register
name|char
modifier|*
name|dir
decl_stmt|;
specifier|register
name|char
modifier|*
name|shell
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|dir
condition|)
block|{
if|if
condition|(
operator|*
name|dir
operator|++
operator|!=
operator|*
name|shell
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* return true if next character is a '/' */
return|return
operator|(
operator|*
name|shell
operator|==
literal|'/'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|error
parameter_list|(
name|message
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|command
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|created
condition|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This version of access checks against effective uid and effective gid  */
end_comment

begin_expr_stmt
name|eaccess
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|euserid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|||
name|mode
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* root needs execute permission for someone */
name|mode
operator|=
operator|(
name|S_IEXEC
operator||
operator|(
name|S_IEXEC
operator|>>
literal|3
operator|)
operator||
operator|(
name|S_IEXEC
operator|>>
literal|6
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|euserid
operator|==
name|statb
operator|.
name|st_uid
condition|)
name|mode
operator|<<=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|egroupid
operator|==
name|statb
operator|.
name|st_gid
condition|)
name|mode
operator|<<=
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifdef|#
directive|ifdef
name|BSD_4_2
comment|/* in BSD_4_2 you can be in several groups */
else|else
block|{
name|int
name|groups
index|[
name|NGROUPS
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|groups
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|groups
index|[
name|n
index|]
operator|==
name|statb
operator|.
name|st_gid
condition|)
block|{
name|mode
operator|<<=
literal|3
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* BSD_4_2 */
endif|#
directive|endif
comment|/* BSD */
if|if
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_macro
name|setids
argument_list|(
argument|mode
argument_list|,
argument|owner
argument_list|,
argument|group
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|mode
operator|&
name|S_ISGID
condition|)
name|setregid
argument_list|(
name|rgroupid
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_ISUID
condition|)
name|setreuid
argument_list|(
name|ruserid
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * This version of setids creats a /tmp file and copies this program into  * it.  The /tmp file is made executable with appropriate suid/sgid bits.  *  Finally, the /tmp file is exec'ed.  The /tmp file is unlinked by a  * grandchild of this program, who waits until the text is free  */
end_comment

begin_macro
name|setids
argument_list|(
argument|mode
argument_list|,
argument|owner
argument_list|,
argument|group
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|pv
index|[
literal|2
index|]
decl_stmt|;
comment|/* create a setuid program with a copy of this program without RW */
if|if
condition|(
operator|(
name|n
operator|=
name|creat
argument_list|(
name|tmpname
argument_list|,
name|mode
operator||
name|SPECIAL
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
name|created
operator|++
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|tmpname
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* create a pipe for syncronization */
name|pv
index|[
literal|0
index|]
operator|=
name|pv
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|pipe
argument_list|(
name|pv
argument_list|)
expr_stmt|;
comment|/* pipe failure could cause the /tmp file to be removed prematurely */
comment|/*  This is not worth waiting for */
if|if
condition|(
operator|(
name|n
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* the grandchild has to clean up the text file */
name|close
argument_list|(
name|pv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* wait until the parent closes the pipe */
name|read
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* sleep granularity too crude to trust sleep(1) */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|tmpname
argument_list|)
operator|>=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ETXTBSY
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
else|else
block|{
name|arglist
index|[
literal|0
index|]
operator|=
name|tmpname
expr_stmt|;
name|close
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|wait
argument_list|(
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
comment|/* put write end of pipe into FDSYNC */
name|close
argument_list|(
name|FDSYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
index|[
literal|1
index|]
operator|!=
name|FDSYNC
condition|)
name|n
operator|=
name|fcntl
argument_list|(
name|pv
index|[
literal|1
index|]
argument_list|,
name|F_DUPFD
argument_list|,
name|FDSYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FDSYNC
condition|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|tmpname
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * create a unique name into the<template>  */
end_comment

begin_function
specifier|static
name|void
name|mktemp
parameter_list|(
name|template
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|template
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|getpid
argument_list|()
decl_stmt|;
comment|/* skip to end of string */
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
empty_stmt|;
comment|/* convert process id to string */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
operator|(
name|n
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  copy THISPROG into the open file number<fdo> and close<fdo>  */
end_comment

begin_function
specifier|static
name|int
name|copy
parameter_list|(
name|fdo
parameter_list|)
name|int
name|fdo
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BLKSIZE
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|fdi
decl_stmt|;
if|if
condition|(
operator|(
name|fdi
operator|=
name|open
argument_list|(
name|THISPROG
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fdi
argument_list|,
name|buffer
argument_list|,
name|BLKSIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badexec
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fdo
argument_list|,
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fdi
argument_list|)
expr_stmt|;
return|return
operator|(
name|close
argument_list|(
name|fdo
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

end_unit

