begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)service.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD_4_2
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_define
define|#
directive|define
name|fcntl
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|dup2(a,b)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_function_decl
name|FILE
modifier|*
name|pathopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fullname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|initio
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|exfunct
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|JOBS
end_ifndef

begin_function_decl
name|void
name|postclr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|post
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|await
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_function_decl
specifier|extern
name|void
name|arg_clear
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|DOLPTR
name|arg_new
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|arg_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|arg_reset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|catpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|chkopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|STKPTR
name|cpystak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|create
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|findnod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gscan_some
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|STKPTR
name|locstak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mac_subst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mactrim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mem_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mem_unscope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_prp
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_function_decl
specifier|extern
name|void
name|postclr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|qvalup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|realias
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|rmlocal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|setenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|setlist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|simple
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|tmp_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|trim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|prune
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|VFORK
end_ifndef

begin_function_decl
specifier|static
name|void
name|exscript
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VFORK */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|execs
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LOBYTE
value|0377
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|u370
end_ifdef

begin_define
define|#
directive|define
name|MAXP
value|75
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXP
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* u370 */
end_comment

begin_define
define|#
directive|define
name|MAXDEPTH
value|(32*sizeof(int))
end_define

begin_comment
comment|/* maximum levels of recursion */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|JOBS
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|maxpost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* highest number running process */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numpost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of running processes */
end_comment

begin_comment
comment|/* for processes to be waited for */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|process
name|pwlist
index|[
name|MAXP
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xecmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|xecenv
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_function_decl
name|NAMPTR
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VFORK */
end_comment

begin_comment
comment|/*  * service routines for `execute'  * flag> 0 if files are to be restored  * flag< 0 if files are to be closed on exec  */
end_comment

begin_function
name|int
name|initio
parameter_list|(
name|iop
parameter_list|,
name|flag
parameter_list|)
name|IOPTR
name|iop
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ion
decl_stmt|;
specifier|register
name|int
name|iof
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
name|fname
index|[
name|TMPSIZ
index|]
decl_stmt|;
name|int
name|fn
decl_stmt|;
name|int
name|mark
init|=
name|MARK
decl_stmt|;
name|int
name|indx
init|=
name|topfd
decl_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
name|mark
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|iop
condition|;
name|iop
operator|=
name|iop
operator|->
name|ionxt
control|)
block|{
name|iof
operator|=
name|iop
operator|->
name|iofile
expr_stmt|;
if|if
condition|(
name|flag
operator|>
literal|0
condition|)
block|{
comment|/* save current file descriptor */
name|savefd
argument_list|(
name|iof
operator|&
name|IOUFD
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
name|ion
operator|=
name|mactrim
argument_list|(
name|iop
operator|->
name|ioname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ion
operator|&&
name|is_option
argument_list|(
name|NOEXEC
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iof
operator|&
name|IODOC
condition|)
block|{
name|fd
operator|=
name|tmp_open
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|mac_subst
argument_list|(
name|chkopen
argument_list|(
name|ion
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iof
operator|&
name|IOMOV
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|minus
argument_list|,
name|ion
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|file_fd
argument_list|(
name|iof
operator|&
name|IOUFD
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|fn
operator|=
name|atoi
argument_list|(
name|ion
argument_list|)
operator|)
operator|>=
name|USERIO
operator|)
operator|||
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|fn
argument_list|)
argument_list|,
operator|(
name|iof
operator|&
name|IOPUT
operator|)
condition|?
literal|"w+"
else|:
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|ion
argument_list|,
name|badfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|iof
operator|&
name|IOPUT
operator|)
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|chkopen
argument_list|(
name|ion
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
name|failed
argument_list|(
name|ion
argument_list|,
name|restricted
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|iof
operator|&
name|IOAPP
operator|)
operator|==
literal|0
operator|||
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
name|ion
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|create
argument_list|(
name|ion
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|ion
argument_list|,
name|badcreate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
name|frenumber
argument_list|(
name|fd
argument_list|,
operator|(
name|iof
operator|&
name|IOUFD
operator|)
operator||
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|indx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given<s> return a colon separated list of directories to search on the stack  * This routine adds names to the tracked alias list, if possible, and returns  * a reduced path string for tracked aliases  */
end_comment

begin_function
name|char
modifier|*
name|getpath
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|NAMPTR
name|np
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
operator|(
name|nullstr
operator|)
return|;
name|path
operator|=
name|qvalup
argument_list|(
name|PATHNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|defpath
expr_stmt|;
name|path
operator|=
name|cpystak
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* track alias if possible */
name|np
operator|=
name|findnod
argument_list|(
name|s
argument_list|,
name|alias
argument_list|,
name|CHK_FOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|&&
name|is_option
argument_list|(
name|HASHALL
argument_list|)
operator|&&
operator|(
name|np
operator|=
name|findnod
argument_list|(
name|s
argument_list|,
name|alias
argument_list|,
name|CHK_FOR
operator||
literal|1
argument_list|)
operator|)
condition|)
name|attrib
argument_list|(
name|np
argument_list|,
name|N_EXPORT
operator||
name|NO_ALIAS
operator||
name|T_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|&&
name|attest
argument_list|(
name|np
argument_list|,
name|T_FLAG
argument_list|)
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|NO_ALIAS
argument_list|)
condition|)
block|{
comment|/* don't bother to look up alias if forked  */
if|if
condition|(
name|states
operator|&
name|FORKED
condition|)
return|return
operator|(
name|path
operator|)
return|;
comment|/* if realias fails then a search won't find anything */
if|if
condition|(
name|realias
argument_list|(
name|np
argument_list|)
operator|==
name|NIL
condition|)
return|return
operator|(
name|nullstr
operator|)
return|;
block|}
comment|/* tracked alias use reduced path */
name|path
operator|=
name|prune
argument_list|(
name|path
argument_list|,
name|valup
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pathopen
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
name|failed
argument_list|(
name|name
argument_list|,
name|restricted
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|nullstr
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|qvalup
argument_list|(
name|PATHNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|defpath
expr_stmt|;
name|path
operator|=
name|cpystak
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|path
operator|=
name|catpath
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|open
argument_list|(
name|curstak
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|n
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|n
operator|<
literal|0
operator|&&
name|path
condition|)
do|;
return|return
operator|(
name|fdopen
argument_list|(
name|n
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * do a path search and find the full pathname of file name  * if name is not a simple name, then name is a tracked alias  */
end_comment

begin_function
name|char
modifier|*
name|fullname
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|*
name|fname
operator|!=
literal|'/'
condition|)
name|name
operator|=
name|fname
expr_stmt|;
else|else
name|name
operator|=
name|simple
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|path
operator|=
name|getpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
do|do
block|{
name|path
operator|=
name|catpath
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|access
argument_list|(
name|curstak
argument_list|()
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ftype
argument_list|(
name|curstak
argument_list|()
argument_list|,
name|S_IFMT
argument_list|,
name|S_IFREG
argument_list|)
condition|)
name|f
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|f
operator|<
literal|0
operator|&&
name|path
condition|)
do|;
return|return
operator|(
name|f
operator|<
literal|0
condition|?
literal|0
else|:
name|curstak
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|catpath
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* leaves result on top of stack */
specifier|register
name|char
modifier|*
name|scanp
init|=
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|argp
init|=
name|locstak
argument_list|()
decl_stmt|;
while|while
condition|(
operator|*
name|scanp
operator|&&
operator|*
name|scanp
operator|!=
literal|':'
condition|)
operator|*
name|argp
operator|++
operator|=
operator|*
name|scanp
operator|++
expr_stmt|;
if|if
condition|(
name|scanp
operator|!=
name|path
condition|)
block|{
operator|*
name|argp
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* position past ":" unless a trailing colon after pathname */
if|if
condition|(
operator|*
name|scanp
operator|&&
operator|*
operator|++
name|scanp
operator|==
literal|0
condition|)
name|scanp
operator|--
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|scanp
operator|==
literal|':'
condition|)
name|scanp
operator|++
expr_stmt|;
name|path
operator|=
operator|(
operator|*
name|scanp
condition|?
name|scanp
else|:
literal|0
operator|)
expr_stmt|;
name|scanp
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argp
operator|++
operator|=
operator|*
name|scanp
operator|++
operator|)
condition|)
empty_stmt|;
name|staktop
operator|=
name|argp
expr_stmt|;
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_function
name|void
name|execa
parameter_list|(
name|at
parameter_list|,
name|local
parameter_list|)
name|char
modifier|*
name|at
index|[]
decl_stmt|;
name|ARGPTR
name|local
decl_stmt|;
comment|/* local environment modification */
block|{
specifier|register
name|char
modifier|*
name|path
init|=
name|nullstr
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|t
init|=
name|at
decl_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|NOEXEC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xecmsg
operator|=
name|notfound
expr_stmt|;
ifdef|#
directive|ifdef
name|VFORK
if|if
condition|(
name|local
condition|)
name|mem_scope
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|xecenv
operator|=
name|setenv
argument_list|()
expr_stmt|;
else|#
directive|else
name|setlist
argument_list|(
name|local
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
name|xecenv
operator|=
name|setenv
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VFORK */
if|if
condition|(
name|strchr
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* name containing / not allowed for restricted shell */
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
name|failed
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|,
name|restricted
argument_list|)
expr_stmt|;
block|}
else|else
name|path
operator|=
name|getpath
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VFORK
if|if
condition|(
name|local
condition|)
name|mem_unscope
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VFORK */
comment|/* insert _= onto stack in front of pathname */
operator|*
operator|--
name|xecenv
operator|=
name|stakbot
expr_stmt|;
operator|*
name|stakbot
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|stakbot
operator|++
operator|=
literal|'='
expr_stmt|;
while|while
condition|(
name|path
operator|=
name|execs
argument_list|(
name|path
argument_list|,
name|t
argument_list|)
condition|)
empty_stmt|;
name|failed
argument_list|(
operator|*
name|t
argument_list|,
name|xecmsg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine constructs a short path consisting of all  * Relative directories up to the directory of fullname<name>  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|prune
parameter_list|(
name|path
parameter_list|,
name|fullname
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|inpath
init|=
name|path
decl_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
operator|||
operator|*
name|fullname
operator|!=
literal|'/'
operator|||
operator|*
name|path
operator|==
literal|0
condition|)
return|return
operator|(
name|path
operator|)
return|;
name|base
operator|=
name|simple
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* a null path means current directory */
if|if
condition|(
operator|*
name|path
operator|==
literal|':'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
name|path
operator|++
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|catpath
argument_list|(
name|path
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|||
operator|(
name|n
operator|=
name|strcmp
argument_list|(
name|curstak
argument_list|()
argument_list|,
name|fullname
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* position p past end of path */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|':'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|inpath
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|path
condition|)
do|;
comment|/* if there is no match just return path */
name|path
operator|=
name|qvalup
argument_list|(
name|PATHNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|defpath
expr_stmt|;
name|strcpy
argument_list|(
name|inpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|inpath
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX
end_ifdef

begin_comment
comment|/*  *  This code takes care of a bug in the XENIX exec routine  *  Contributed by Pat Wood  */
end_comment

begin_expr_stmt
specifier|static
name|ex_xenix
argument_list|(
argument|file
argument_list|)
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|stats
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|unsigned
name|short
name|magic
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* can't read, so can't be shell prog */
return|return
operator|(
literal|1
operator|)
return|;
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|==
literal|01006
condition|)
comment|/* magic for xenix executable */
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOEXEC
expr_stmt|;
if|if
condition|(
operator|!
name|geteuid
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stats
operator|.
name|st_mode
operator|&
literal|0111
operator|)
condition|)
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|geteuid
argument_list|()
operator|==
name|stats
operator|.
name|st_uid
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stats
operator|.
name|st_mode
operator|&
literal|0100
operator|)
condition|)
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|getegid
argument_list|()
operator|==
name|stats
operator|.
name|st_gid
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stats
operator|.
name|st_mode
operator|&
literal|0010
operator|)
condition|)
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|stats
operator|.
name|st_mode
operator|&
literal|0001
operator|)
condition|)
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XENIX */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|execs
parameter_list|(
name|ap
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|prefix
operator|=
name|catpath
argument_list|(
name|ap
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|p
operator|=
name|curstak
argument_list|()
argument_list|)
expr_stmt|;
name|p_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XENIX
if|if
condition|(
name|ex_xenix
argument_list|(
name|p
argument_list|)
condition|)
endif|#
directive|endif
comment|/* XENIX */
name|execve
argument_list|(
name|p
argument_list|,
operator|&
name|t
index|[
literal|0
index|]
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOEXEC
case|:
ifdef|#
directive|ifdef
name|VFORK
block|{
comment|/* this code handles the !# interpreter name convention */
name|char
name|iname
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SUID_EXEC
comment|/* check if file cannot open for read or script is setuid/setgid  */
specifier|static
name|char
name|name
index|[]
init|=
literal|"/tmp/euidXXXXXX"
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|euserid
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|n
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|openok
goto|;
block|}
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|euserid
operator|=
name|geteuid
argument_list|()
operator|)
operator|!=
name|userid
condition|)
block|{
name|strcpy
argument_list|(
name|name
operator|+
literal|9
argument_list|,
name|itos
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create a suid open file with owner equal effective uid */
if|if
condition|(
operator|(
name|n
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|04100
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* make sure that file has right owner */
if|if
condition|(
name|fstat
argument_list|(
name|n
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
operator|||
name|statb
operator|.
name|st_uid
operator|!=
name|euserid
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|n
operator|!=
literal|10
condition|)
block|{
name|close
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
operator|--
name|t
operator|=
name|p
expr_stmt|;
name|execve
argument_list|(
name|suid_exec
argument_list|,
name|t
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
name|fail
label|:
name|failed
argument_list|(
name|p
argument_list|,
name|badopen
argument_list|)
expr_stmt|;
name|openok
label|:
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SUID_EXEC
comment|/* get name returns the interpreter name */
if|if
condition|(
name|get_shell
argument_list|(
name|p
argument_list|,
name|iname
argument_list|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|p
argument_list|,
name|badexec
argument_list|)
expr_stmt|;
name|t
operator|--
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|iname
expr_stmt|;
name|execve
argument_list|(
name|iname
argument_list|,
name|t
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|iname
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|xecmsg
operator|=
name|badexec
expr_stmt|;
name|failed
argument_list|(
name|iname
argument_list|,
name|xecmsg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|exscript
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VFORK */
case|case
name|ENOMEM
case|:
name|failed
argument_list|(
name|p
argument_list|,
name|toobig
argument_list|)
expr_stmt|;
case|case
name|E2BIG
case|:
name|failed
argument_list|(
name|p
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
case|case
name|ETXTBSY
case|:
name|failed
argument_list|(
name|p
argument_list|,
name|txtbsy
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|access
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|xecmsg
operator|=
name|badexec
expr_stmt|;
case|case
name|ENOENT
case|:
return|return
operator|(
name|prefix
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * File is executable but not machine code.  * Assume file is a Shell script and execute it.  */
end_comment

begin_function
specifier|static
name|void
name|exscript
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|savet
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|states
operator|=
literal|0
expr_stmt|;
name|comdiv
operator|=
literal|0
expr_stmt|;
name|ioset
operator|=
literal|0
expr_stmt|;
name|arg_clear
argument_list|()
expr_stmt|;
comment|/* remove open files and for loop junk */
name|postclr
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|input
argument_list|)
condition|)
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|p_flush
argument_list|()
expr_stmt|;
name|standout
operator|=
name|stdout
expr_stmt|;
name|setbuf
argument_list|(
name|stdin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_sibuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUID_EXEC
comment|/* check if file cannot open for read or script is setuid/setgid  */
block|{
specifier|static
name|char
name|name
index|[]
init|=
literal|"/tmp/euidXXXXXX"
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|euserid
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|n
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|openok
goto|;
block|}
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|euserid
operator|=
name|geteuid
argument_list|()
operator|)
operator|!=
name|userid
condition|)
block|{
name|strcpy
argument_list|(
name|name
operator|+
literal|9
argument_list|,
name|itos
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create a suid open file with owner equal effective uid */
if|if
condition|(
operator|(
name|n
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|04100
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* make sure that file has right owner */
if|if
condition|(
name|fstat
argument_list|(
name|n
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
operator|||
name|statb
operator|.
name|st_uid
operator|!=
name|euserid
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|n
operator|!=
literal|10
condition|)
block|{
name|close
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|savet
operator|=
operator|*
operator|--
name|t
expr_stmt|;
operator|*
name|t
operator|=
name|p
expr_stmt|;
name|execve
argument_list|(
name|suid_exec
argument_list|,
name|t
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
name|fail
label|:
comment|/* 		 *  The following code is just for compatibility 		 *  It should be replaced with the line failed(p,badexec); 		 */
name|n
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|p
argument_list|,
name|badopen
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|savet
expr_stmt|;
name|close
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|openok
label|:
name|input
operator|=
name|fdopen
argument_list|(
name|n
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|input
operator|=
name|chkopen
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUID_EXEC */
ifdef|#
directive|ifdef
name|ACCT
name|preacct
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* reset accounting */
endif|#
directive|endif
comment|/* ACCT */
name|gscan_some
argument_list|(
name|rmlocal
argument_list|,
name|namep
argument_list|,
name|N_EXPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* remove local variables*/
name|gscan_some
argument_list|(
name|rmlocal
argument_list|,
name|alias
argument_list|,
name|N_EXPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* remove local aliases*/
name|gscan_some
argument_list|(
name|rmlocal
argument_list|,
name|prnames
argument_list|,
name|N_EXPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* remove local functions*/
if|if
condition|(
name|attest
argument_list|(
name|IFSNOD
argument_list|,
name|N_EXPORT
argument_list|)
operator|==
literal|0
condition|)
name|assign
argument_list|(
name|IFSNOD
argument_list|,
name|sptbnl
argument_list|)
expr_stmt|;
comment|/* set up new args */
name|arg_set
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|subshell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following routine is used to execute shell functions and command subs  * when com!=NULL $* is saved and restored  */
end_comment

begin_function
name|void
name|exfunct
parameter_list|(
name|t
parameter_list|,
name|com
parameter_list|,
name|execflg
parameter_list|,
name|envlist
parameter_list|)
name|TREPTR
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|com
index|[]
decl_stmt|;
specifier|register
name|unsigned
name|execflg
decl_stmt|;
name|ARGPTR
name|envlist
decl_stmt|;
block|{
comment|/* execute user defined function */
specifier|register
name|char
modifier|*
name|trap
decl_stmt|;
name|jmp_buf
name|retbuf
decl_stmt|;
name|jmp_buf
modifier|*
name|savreturn
init|=
name|freturn
decl_stmt|;
name|DOLPTR
name|argsav
init|=
literal|0
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|DOLPTR
name|savargfor
decl_stmt|;
name|char
modifier|*
name|savtrap0
init|=
name|trapcom
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|savtrap1
init|=
name|trapcom
index|[
name|MAXTRAP
index|]
decl_stmt|;
name|SHFILE
name|savstandin
decl_stmt|;
name|struct
name|State
name|savst
decl_stmt|;
name|savst
operator|=
name|st
expr_stmt|;
name|loopcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
condition|)
block|{
name|mem_scope
argument_list|(
name|envlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|execflg
operator|&
name|EXECPR
condition|)
name|on_option
argument_list|(
name|EXECPR
argument_list|)
expr_stmt|;
else|else
name|off_option
argument_list|(
name|EXECPR
argument_list|)
expr_stmt|;
name|execflg
operator|&=
operator|~
name|EXECPR
expr_stmt|;
name|cmdadr
operator|=
name|com
index|[
literal|0
index|]
expr_stmt|;
name|trapcom
index|[
name|MAXTRAP
index|]
operator|=
literal|0
expr_stmt|;
name|argsav
operator|=
name|arg_new
argument_list|(
name|com
argument_list|,
operator|&
name|savargfor
argument_list|)
expr_stmt|;
block|}
name|freturn
operator|=
operator|(
name|jmp_buf
operator|*
operator|)
name|retbuf
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|setjmp
argument_list|(
name|retbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|states
operator||=
name|FUNCTION
expr_stmt|;
if|if
condition|(
name|fn_depth
operator|++
operator|>
name|MAXDEPTH
condition|)
name|longjmp
argument_list|(
operator|*
name|freturn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|execute
argument_list|(
name|t
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
block|}
name|fn_depth
operator|--
expr_stmt|;
name|freturn
operator|=
name|savreturn
expr_stmt|;
if|if
condition|(
name|com
condition|)
block|{
name|mem_unscope
argument_list|()
expr_stmt|;
name|arg_reset
argument_list|(
name|argsav
argument_list|,
name|savargfor
argument_list|)
expr_stmt|;
name|trapcom
index|[
name|MAXTRAP
index|]
operator|=
name|savtrap1
expr_stmt|;
name|trapnote
operator|=
literal|0
expr_stmt|;
block|}
name|savstandin
operator|=
name|standin
expr_stmt|;
name|st
operator|=
name|savst
expr_stmt|;
while|while
condition|(
operator|(
name|savstandin
operator|!=
name|standin
operator|)
operator|&&
name|pop
argument_list|(
literal|0
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|fn_depth
operator|==
literal|0
condition|)
name|failed
argument_list|(
name|com
index|[
literal|0
index|]
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
else|else
name|longjmp
argument_list|(
operator|*
name|freturn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|&&
operator|(
name|trap
operator|=
name|trapcom
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|savtrap0
operator|!=
name|trap
operator|)
condition|)
block|{
name|trapcom
index|[
literal|0
index|]
operator|=
name|savtrap0
expr_stmt|;
name|execexp
argument_list|(
name|trap
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|trap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|JOBS
end_ifndef

begin_comment
comment|/*  * These routines have been moved to jobs.c when compiling with JOBS option  */
end_comment

begin_comment
comment|/*  * Initialize the process posting array  */
end_comment

begin_function
name|void
name|postclr
parameter_list|()
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
while|while
condition|(
name|pw
operator|<
operator|&
name|pwlist
index|[
name|maxpost
index|]
condition|)
operator|(
name|pw
operator|++
operator|)
operator|->
name|p_pid
operator|=
literal|0
expr_stmt|;
name|numpost
operator|=
literal|0
expr_stmt|;
name|maxpost
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|post
parameter_list|(
name|pcsid
parameter_list|)
name|int
name|pcsid
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
if|if
condition|(
name|pcsid
condition|)
block|{
while|while
condition|(
name|pw
operator|->
name|p_pid
condition|)
name|pw
operator|++
expr_stmt|;
if|if
condition|(
name|numpost
operator|>=
name|MAXP
operator|-
literal|1
condition|)
name|pw
operator|--
expr_stmt|;
else|else
name|numpost
operator|++
expr_stmt|;
if|if
condition|(
name|numpost
operator|>
name|maxpost
condition|)
name|maxpost
operator|=
name|numpost
expr_stmt|;
name|pw
operator|->
name|p_pid
operator|=
name|pcsid
expr_stmt|;
if|if
condition|(
name|numpost
operator|>=
name|MAXP
operator|-
literal|1
condition|)
name|await
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|-
name|pwlist
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|await
parameter_list|(
name|i
parameter_list|,
name|bckg
parameter_list|)
name|int
name|i
decl_stmt|,
name|bckg
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|wx
init|=
literal|0
decl_stmt|;
name|int
name|w
decl_stmt|;
name|post
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|numpost
condition|)
block|{
specifier|register
name|int
name|p
decl_stmt|;
specifier|register
name|int
name|sig
decl_stmt|;
name|int
name|w_hi
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|==
operator|-
literal|1
operator|)
operator|&&
name|bckg
operator|&&
name|errno
operator|==
name|EINTR
condition|)
break|break;
while|while
condition|(
name|pw
operator|<=
operator|&
name|pwlist
index|[
name|maxpost
index|]
condition|)
block|{
if|if
condition|(
name|pw
operator|->
name|p_pid
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|cpid
condition|)
block|{
name|cpid
operator|=
literal|0
expr_stmt|;
name|cpipe
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|pw
operator|->
name|p_pid
operator|=
literal|0
expr_stmt|;
name|numpost
operator|--
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
name|pw
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bckg
condition|)
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
while|while
condition|(
name|pw
operator|<=
operator|&
name|pwlist
index|[
name|maxpost
index|]
operator|&&
name|i
operator|!=
name|pw
operator|->
name|p_pid
condition|)
name|pw
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|pw
operator|->
name|p_pid
condition|)
block|{
name|pw
operator|->
name|p_pid
operator|=
literal|0
expr_stmt|;
name|numpost
operator|--
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|w_hi
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
name|LOBYTE
expr_stmt|;
if|if
condition|(
name|sig
operator|=
name|w
operator|&
literal|0177
condition|)
block|{
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0177
comment|/* ptrace! return */
condition|)
block|{
name|fputs
argument_list|(
name|ptrace
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|sig
operator|=
name|w_hi
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|sysmsg
index|[
name|sig
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|sysmsg
index|[
name|sig
index|]
condition|)
endif|#
directive|endif
comment|/* apollo */
block|{
if|if
condition|(
name|i
operator|!=
name|p
operator|||
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|==
literal|0
condition|)
block|{
name|p_prp
argument_list|(
name|itos
argument_list|(
name|p
argument_list|)
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|sysmsg
index|[
name|sig
index|]
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&
name|HIGHBIT
condition|)
name|fputs
argument_list|(
name|coredump
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|newline
argument_list|()
expr_stmt|;
block|}
name|wx
operator||=
name|w
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|i
condition|)
block|{
name|rc
operator|=
operator|(
name|sig
condition|?
name|sig
operator||
name|SIGFLG
else|:
name|w_hi
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|exitval
operator|=
name|rc
expr_stmt|;
name|exitset
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ACCT
end_ifdef

begin_include
include|#
directive|include
file|<acctdef.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_function_decl
specifier|static
name|int
name|compress
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|acct
name|sabuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tms
name|buffer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|times
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|long
name|before
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SHACCT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 environment variable SHACCT not set so never acct 		ptr to SHACCT value if set, so acct if shell procedure*/
end_comment

begin_expr_stmt
specifier|static
name|shaccton
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 0 implies do not write record on exit 			  1 implies write acct record on exit 		*/
end_comment

begin_comment
comment|/*  *	initialize accounting, i.e., see if SHACCT variable set  */
end_comment

begin_function
name|void
name|initacct
parameter_list|()
block|{
name|SHACCT
operator|=
name|valup
argument_list|(
name|ACCTNOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * suspend accounting unitl turned on by preacct() */
end_comment

begin_function
name|void
name|suspacct
parameter_list|()
block|{
name|shaccton
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|preacct
parameter_list|(
name|cmdname
parameter_list|)
name|char
modifier|*
name|cmdname
decl_stmt|;
block|{
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
if|if
condition|(
name|SHACCT
condition|)
block|{
name|sabuf
operator|.
name|ac_btime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|before
operator|=
name|times
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|sabuf
operator|.
name|ac_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|sabuf
operator|.
name|ac_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|strncpy
argument_list|(
name|sabuf
operator|.
name|ac_comm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|simple
argument_list|(
name|cmdname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sabuf
operator|.
name|ac_comm
argument_list|)
argument_list|)
expr_stmt|;
name|shaccton
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_function
name|void
name|doacct
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
name|long
name|after
decl_stmt|;
if|if
condition|(
name|shaccton
condition|)
block|{
name|after
operator|=
name|times
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|sabuf
operator|.
name|ac_utime
operator|=
name|compress
argument_list|(
name|buffer
operator|.
name|tms_utime
operator|+
name|buffer
operator|.
name|tms_cutime
argument_list|)
expr_stmt|;
name|sabuf
operator|.
name|ac_stime
operator|=
name|compress
argument_list|(
name|buffer
operator|.
name|tms_stime
operator|+
name|buffer
operator|.
name|tms_cstime
argument_list|)
expr_stmt|;
name|sabuf
operator|.
name|ac_etime
operator|=
name|compress
argument_list|(
name|after
operator|-
name|before
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|SHACCT
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|sabuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sabuf
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Produce a pseudo-floating point representation  * with 3 bits base-8 exponent, 13 bits fraction.  */
end_comment

begin_function
specifier|static
name|int
name|compress
parameter_list|(
name|t
parameter_list|)
specifier|register
name|time_t
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|exp
init|=
literal|0
decl_stmt|,
name|rund
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|t
operator|>=
literal|8192
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|rund
operator|=
name|t
operator|&
literal|04
expr_stmt|;
name|t
operator|>>=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|rund
condition|)
block|{
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|8192
condition|)
block|{
name|t
operator|>>=
literal|3
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|exp
operator|<<
literal|13
operator|)
operator|+
name|t
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACCT */
end_comment

end_unit

