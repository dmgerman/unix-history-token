begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Simple test program for regexp(3) stuff.  Knows about debugging hooks.  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  * Usage: try re [string [output [-]]]  * The re is compiled and dumped, regexeced against the string, the result  * is applied to output using regsub().  The - triggers a running narrative  * from regexec().  Dumping and narrative don't happen unless DEBUG.  *  * If there are no arguments, stdin is assumed to be a stream of lines with  * five fields:  a r.e., a string to match it against, a result code, a  * source string for regsub, and the proper result.  Result codes are 'c'  * for compile failure, 'y' for match success, 'n' for match failure.  * Field separator is tab.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ERRAVAIL
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|mkprogname
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|regnarrate
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errreport
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report errors via errseen? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|errseen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error message. */
end_comment

begin_decl_stmt
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit status. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|regexp
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ERRAVAIL
name|progname
operator|=
name|mkprogname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|multiple
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|regcomp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"regcomp failure"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|regdump
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|regnarrate
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|i
operator|=
name|regexec
argument_list|(
name|r
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSUBEXP
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
operator|->
name|startp
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|endp
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" \\%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|regsub
argument_list|(
name|r
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|errreport
condition|)
name|errseen
operator|=
name|s
expr_stmt|;
else|else
name|error
argument_list|(
name|s
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ERRAVAIL
end_ifndef

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regexp: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|regexp
name|badregexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implicit init to 0. */
end_comment

begin_macro
name|multiple
argument_list|()
end_macro

begin_block
block|{
name|char
name|rbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|field
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regexp
modifier|*
name|r
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
name|errreport
operator|=
literal|1
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|rbuf
index|[
name|strlen
argument_list|(
name|rbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Dispense with \n. */
name|lineno
operator|++
expr_stmt|;
name|scan
operator|=
name|rbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|field
index|[
name|i
index|]
operator|=
name|scan
expr_stmt|;
if|if
condition|(
name|field
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
literal|"bad testfile format"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|scan
operator|=
name|strchr
argument_list|(
name|scan
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|try
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* And finish up with some internal testing... */
name|lineno
operator|=
literal|9990
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
name|NULL
operator|||
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regcomp(NULL) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9991
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regexec
argument_list|(
operator|(
name|regexp
operator|*
operator|)
name|NULL
argument_list|,
literal|"foo"
argument_list|)
operator|||
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regexec(NULL, ...) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9992
expr_stmt|;
name|r
operator|=
name|regcomp
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
literal|"regcomp(\"foo\") fails"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|lineno
operator|=
literal|9993
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regexec
argument_list|(
name|r
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|||
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regexec(..., NULL) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9994
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
name|regsub
argument_list|(
operator|(
name|regexp
operator|*
operator|)
name|NULL
argument_list|,
literal|"foo"
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regsub(NULL, ..., ...) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9995
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
name|regsub
argument_list|(
name|r
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regsub(..., NULL, ...) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9996
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
name|regsub
argument_list|(
name|r
argument_list|,
literal|"foo"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regsub(..., ..., NULL) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9997
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|badregexp
argument_list|,
literal|"foo"
argument_list|)
operator|||
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regexec(nonsense, ...) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|9998
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
name|regsub
argument_list|(
operator|&
name|badregexp
argument_list|,
literal|"foo"
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errseen
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"regsub(nonsense, ..., ...) doesn't complain"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|try
argument_list|(
argument|fields
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|fields
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|regexp
modifier|*
name|r
decl_stmt|;
name|char
name|dbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|regcomp
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|fields
index|[
literal|2
index|]
operator|!=
literal|'c'
condition|)
name|complain
argument_list|(
literal|"regcomp failure in `%s'"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|complain
argument_list|(
literal|"unexpected regcomp success in `%s'"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|r
argument_list|,
name|fields
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|fields
index|[
literal|2
index|]
operator|!=
literal|'n'
condition|)
name|complain
argument_list|(
literal|"regexec failure in `%s'"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
literal|2
index|]
operator|==
literal|'n'
condition|)
block|{
name|complain
argument_list|(
literal|"unexpected regexec success"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
name|errseen
operator|=
name|NULL
expr_stmt|;
name|regsub
argument_list|(
name|r
argument_list|,
name|fields
index|[
literal|3
index|]
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errseen
operator|!=
name|NULL
condition|)
block|{
name|complain
argument_list|(
literal|"regsub complaint"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|dbuf
argument_list|,
name|fields
index|[
literal|4
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|complain
argument_list|(
literal|"regsub result `%s' wrong"
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|complain
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"try: %d: "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)\n"
argument_list|,
operator|(
name|errseen
operator|!=
name|NULL
operator|)
condition|?
name|errseen
else|:
literal|""
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
end_block

end_unit

