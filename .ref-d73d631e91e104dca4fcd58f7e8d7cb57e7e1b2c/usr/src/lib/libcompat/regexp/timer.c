begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Simple timing program for regcomp().  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  * Usage: timer ncomp nexec nsub  *	or  *	timer ncomp nexec nsub regexp string [ answer [ sub ] ]  *  * The second form is for timing repetitions of a single test case.  * The first form's test data is a compiled-in copy of the "tests" file.  * Ncomp, nexec, nsub are how many times to do each regcomp, regexec,  * and regsub.  The way to time an operation individually is to do something  * like "timer 1 50 1".  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_struct
struct|struct
name|try
block|{
name|char
modifier|*
name|re
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|ans
decl_stmt|,
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
block|}
name|tests
index|[]
init|=
block|{
include|#
directive|include
file|"timer.t.h"
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_decl_stmt
name|int
name|errreport
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report errors via errseen? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|errseen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error message. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ncomp
decl_stmt|,
name|nexec
decl_stmt|,
name|nsub
decl_stmt|;
name|struct
name|try
name|one
decl_stmt|;
name|char
name|dummy
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|ncomp
operator|=
literal|1
expr_stmt|;
name|nexec
operator|=
literal|1
expr_stmt|;
name|nsub
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ncomp
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nexec
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|nsub
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|5
condition|)
block|{
name|one
operator|.
name|re
operator|=
name|argv
index|[
literal|4
index|]
expr_stmt|;
name|one
operator|.
name|str
operator|=
name|argv
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|6
condition|)
name|one
operator|.
name|ans
operator|=
name|argv
index|[
literal|6
index|]
expr_stmt|;
else|else
name|one
operator|.
name|ans
operator|=
literal|"y"
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|7
condition|)
block|{
name|one
operator|.
name|src
operator|=
name|argv
index|[
literal|7
index|]
expr_stmt|;
name|one
operator|.
name|dst
operator|=
literal|"xxx"
expr_stmt|;
block|}
else|else
block|{
name|one
operator|.
name|src
operator|=
literal|"x"
expr_stmt|;
name|one
operator|.
name|dst
operator|=
literal|"x"
expr_stmt|;
block|}
name|errreport
operator|=
literal|1
expr_stmt|;
name|try
argument_list|(
name|one
argument_list|,
name|ncomp
argument_list|,
name|nexec
argument_list|,
name|nsub
argument_list|)
expr_stmt|;
block|}
else|else
name|multiple
argument_list|(
name|ncomp
argument_list|,
name|nexec
argument_list|,
name|nsub
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|errreport
condition|)
name|errseen
operator|=
name|s
expr_stmt|;
else|else
name|error
argument_list|(
name|s
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ERRAVAIL
end_ifndef

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regexp: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|multiple
argument_list|(
argument|ncomp
argument_list|,
argument|nexec
argument_list|,
argument|nsub
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ncomp
decl_stmt|,
name|nexec
decl_stmt|,
name|nsub
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
name|errreport
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tests
index|[
name|i
index|]
operator|.
name|re
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|lineno
operator|++
expr_stmt|;
name|try
argument_list|(
name|tests
index|[
name|i
index|]
argument_list|,
name|ncomp
argument_list|,
name|nexec
argument_list|,
name|nsub
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|try
argument_list|(
argument|fields
argument_list|,
argument|ncomp
argument_list|,
argument|nexec
argument_list|,
argument|nsub
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|try
name|fields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncomp
decl_stmt|,
name|nexec
decl_stmt|,
name|nsub
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|regexp
modifier|*
name|r
decl_stmt|;
name|char
name|dbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|regcomp
argument_list|(
name|fields
operator|.
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|fields
operator|.
name|ans
operator|!=
literal|'c'
condition|)
name|complain
argument_list|(
literal|"regcomp failure in `%s'"
argument_list|,
name|fields
operator|.
name|re
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
operator|.
name|ans
operator|==
literal|'c'
condition|)
block|{
name|complain
argument_list|(
literal|"unexpected regcomp success in `%s'"
argument_list|,
name|fields
operator|.
name|re
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|ncomp
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|regcomp
argument_list|(
name|fields
operator|.
name|re
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|r
argument_list|,
name|fields
operator|.
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|fields
operator|.
name|ans
operator|!=
literal|'n'
condition|)
name|complain
argument_list|(
literal|"regexec failure in `%s'"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
operator|.
name|ans
operator|==
literal|'n'
condition|)
block|{
name|complain
argument_list|(
literal|"unexpected regexec success"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|nexec
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|(
name|void
operator|)
name|regexec
argument_list|(
name|r
argument_list|,
name|fields
operator|.
name|str
argument_list|)
expr_stmt|;
name|errseen
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nsub
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|regsub
argument_list|(
name|r
argument_list|,
name|fields
operator|.
name|src
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errseen
operator|!=
name|NULL
condition|)
block|{
name|complain
argument_list|(
literal|"regsub complaint"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|dbuf
argument_list|,
name|fields
operator|.
name|dst
argument_list|)
operator|!=
literal|0
condition|)
name|complain
argument_list|(
literal|"regsub result `%s' wrong"
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|complain
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"try: %d: "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)\n"
argument_list|,
operator|(
name|errseen
operator|!=
name|NULL
operator|)
condition|?
name|errseen
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

