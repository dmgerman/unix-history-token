begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)radixsort.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  *  * __rspartition is the cutoff point for a further partitioning instead  * of a shellsort.  If it changes check __rsshell_increments.  Both of  * these are exported, as the best values are data dependent.  Unrolling  * this loop has not proven worthwhile.  */
end_comment

begin_define
define|#
directive|define
name|NPARTITION
value|40
end_define

begin_decl_stmt
name|int
name|__rspartition
init|=
name|NPARTITION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SHELLSORT
value|{ \ 	register u_char ch, *s1, *s2; \ 	register int incr, *incrp; \ 	for (incrp = __rsshell_increments; incr = *incrp++;) \ 		for (t1 = incr; t1< nmemb; ++t1) \ 			for (t2 = t1 - incr; t2>= 0;) { \ 				s1 = p[t2] + indx; \ 				s2 = p[t2 + incr] + indx; \ 				while ((ch = tr[*s1++]) == tr[*s2]&& ch) \ 					++s2; \ 				if (ch> tr[*s2]) { \ 					s1 = p[t2]; \ 					p[t2] = p[t2 + incr]; \ 					p[t2 + incr] = s1; \ 					t2 -= incr; \ 				} else \ 					break; \ 			} \ }
end_define

begin_comment
comment|/*  * Stackp points to context structures, where each structure schedules a  * partitioning.  Radixsort exits when the stack is empty.  *  * If the buckets are placed on the stack randomly, the worst case is when  * all the buckets but one contain (npartitions + 1) elements and the bucket  * pushed on the stack last contains the rest of the elements.  In this case,  * stack growth is bounded by:  *  *	limit = (nelements / (npartitions + 1)) - 1;  *  * This is a very large number, 52,377,648 for the maximum 32-bit signed int.  *  * By forcing the largest bucket to be pushed on the stack first, the worst  * case is when all but two buckets each contain (npartitions + 1) elements,  * with the remaining elements split equally between the first and last  * buckets pushed on the stack.  In this case, stack growth is bounded when:  *  *	for (partition_cnt = 0; nelements> npartitions; ++partition_cnt)  *		nelements =  *		    (nelements - (npartitions + 1) * (nbuckets - 2)) / 2;  * The bound is:  *  *	limit = partition_cnt * (nbuckets - 1);  *  * This is a much smaller number, 4590 for the maximum 32-bit signed int.  */
end_comment

begin_define
define|#
directive|define
name|NBUCKETS
value|(UCHAR_MAX + 1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|_stack
block|{
name|u_char
modifier|*
modifier|*
name|bot
decl_stmt|;
name|int
name|indx
decl_stmt|,
name|nmemb
decl_stmt|;
block|}
name|CONTEXT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|STACKPUSH
value|{ \ 	stackp->bot = p; \ 	stackp->nmemb = nmemb; \ 	stackp->indx = indx; \ 	++stackp; \ }
end_define

begin_define
define|#
directive|define
name|STACKPOP
value|{ \ 	if (stackp == stack) \ 		break; \ 	--stackp; \ 	bot = stackp->bot; \ 	nmemb = stackp->nmemb; \ 	indx = stackp->indx; \ }
end_define

begin_comment
comment|/*  * A variant of MSD radix sorting; see Knuth Vol. 3, page 177, and 5.2.5,  * Ex. 10 and 12.  Also, "Three Partition Refinement Algorithms, Paige  * and Tarjan, SIAM J. Comput. Vol. 16, No. 6, December 1987.  *  * This uses a simple sort as soon as a bucket crosses a cutoff point,  * rather than sorting the entire list after partitioning is finished.  * This should be an advantage.  *  * This is pure MSD instead of LSD of some number of MSD, switching to  * the simple sort as soon as possible.  Takes linear time relative to  * the number of bytes in the strings.  */
end_comment

begin_macro
name|radixsort
argument_list|(
argument|l1
argument_list|,
argument|nmemb
argument_list|,
argument|tab
argument_list|,
argument|endbyte
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
modifier|*
name|l1
decl_stmt|,
modifier|*
name|tab
decl_stmt|,
name|endbyte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|nmemb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|indx
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|u_char
modifier|*
modifier|*
name|l2
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|bot
decl_stmt|,
modifier|*
name|tr
decl_stmt|;
name|CONTEXT
modifier|*
name|stack
decl_stmt|,
modifier|*
name|stackp
decl_stmt|;
name|int
name|c
index|[
name|NBUCKETS
operator|+
literal|1
index|]
decl_stmt|,
name|max
decl_stmt|;
name|u_char
name|ltab
index|[
name|NBUCKETS
index|]
decl_stmt|;
if|if
condition|(
name|nmemb
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * T1 is the constant part of the equation, the number of elements 	 * represented on the stack between the top and bottom entries. 	 * It doesn't get rounded as the divide by 2 rounds down (correct 	 * for a value being subtracted).  T2, the nelem value, has to be 	 * rounded up before each divide because we want an upper bound; 	 * this could overflow if nmemb is the maximum int. 	 */
name|t1
operator|=
operator|(
operator|(
name|__rspartition
operator|+
literal|1
operator|)
operator|*
operator|(
name|NBUCKETS
operator|-
literal|2
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t2
operator|=
name|nmemb
init|;
name|t2
operator|>
name|__rspartition
condition|;
name|i
operator|+=
name|NBUCKETS
operator|-
literal|1
control|)
name|t2
operator|=
operator|(
operator|(
name|t2
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|-
name|t1
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stack
operator|=
name|stackp
operator|=
operator|(
name|CONTEXT
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CONTEXT
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|stack
operator|=
name|stackp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * There are two arrays, one provided by the user (l1), and the 	 * temporary one (l2).  The data is sorted to the temporary stack, 	 * and then copied back.  The speedup of using index to determine 	 * which stack the data is on and simply swapping stacks back and 	 * forth, thus avoiding the copy every iteration, turns out to not 	 * be any faster than the current implementation. 	 */
if|if
condition|(
operator|!
operator|(
name|l2
operator|=
operator|(
name|u_char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_char
operator|*
argument_list|)
operator|*
name|nmemb
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Tr references a table of sort weights; multiple entries may 	 * map to the same weight; EOS char must have the lowest weight. 	 */
if|if
condition|(
name|tab
condition|)
name|tr
operator|=
name|tab
expr_stmt|;
else|else
block|{
name|tr
operator|=
name|ltab
expr_stmt|;
for|for
control|(
name|t1
operator|=
literal|0
operator|,
name|t2
operator|=
name|endbyte
init|;
name|t1
operator|<
name|t2
condition|;
operator|++
name|t1
control|)
name|tr
index|[
name|t1
index|]
operator|=
name|t1
operator|+
literal|1
expr_stmt|;
name|tr
index|[
name|t2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t1
operator|=
name|endbyte
operator|+
literal|1
init|;
name|t1
operator|<
name|NBUCKETS
condition|;
operator|++
name|t1
control|)
name|tr
index|[
name|t1
index|]
operator|=
name|t1
expr_stmt|;
block|}
comment|/* First sort is entire stack */
name|bot
operator|=
name|l1
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Clear bucket count array */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Compute number of items that sort to the same bucket 		 * for this index. 		 */
for|for
control|(
name|p
operator|=
name|bot
operator|,
name|i
operator|=
name|nmemb
init|;
name|i
operator|--
condition|;
control|)
operator|++
name|c
index|[
name|tr
index|[
operator|(
operator|*
name|p
operator|++
operator|)
index|[
name|indx
index|]
index|]
index|]
expr_stmt|;
comment|/* 		 * Sum the number of characters into c, dividing the temp 		 * stack into the right number of buckets for this bucket, 		 * this index.  C contains the cumulative total of keys 		 * before and included in this bucket, and will later be 		 * used as an index to the bucket.  c[NBUCKETS] contains 		 * the total number of elements, for determining how many 		 * elements the last bucket contains.  At the same time 		 * find the largest bucket so it gets pushed first. 		 */
for|for
control|(
name|i
operator|=
name|max
operator|=
name|t1
operator|=
literal|0
operator|,
name|t2
operator|=
name|__rspartition
init|;
name|i
operator|<=
name|NBUCKETS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|c
index|[
name|i
index|]
operator|>
name|t2
condition|)
block|{
name|t2
operator|=
name|c
index|[
name|i
index|]
expr_stmt|;
name|max
operator|=
name|i
expr_stmt|;
block|}
name|t1
operator|=
name|c
index|[
name|i
index|]
operator|+=
name|t1
expr_stmt|;
block|}
comment|/* 		 * Partition the elements into buckets; c decrements through 		 * the bucket, and ends up pointing to the first element of 		 * the bucket. 		 */
for|for
control|(
name|i
operator|=
name|nmemb
init|;
name|i
operator|--
condition|;
control|)
block|{
operator|--
name|p
expr_stmt|;
name|l2
index|[
operator|--
name|c
index|[
name|tr
index|[
operator|(
operator|*
name|p
operator|)
index|[
name|indx
index|]
index|]
index|]
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
comment|/* Copy the partitioned elements back to user stack */
name|bcopy
argument_list|(
name|l2
argument_list|,
name|bot
argument_list|,
name|nmemb
operator|*
sizeof|sizeof
argument_list|(
name|u_char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|indx
expr_stmt|;
comment|/* 		 * Sort buckets as necessary; don't sort c[0], it's the 		 * EOS character bucket, and nothing can follow EOS. 		 */
for|for
control|(
name|i
operator|=
name|max
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|nmemb
operator|=
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|-
operator|(
name|t1
operator|=
name|c
index|[
name|i
index|]
operator|)
operator|)
operator|<
literal|2
condition|)
continue|continue;
name|p
operator|=
name|bot
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|nmemb
operator|>
name|__rspartition
condition|)
name|STACKPUSH
else|else
name|SHELLSORT
block|}
for|for
control|(
name|i
operator|=
name|max
operator|+
literal|1
init|;
name|i
operator|<
name|NBUCKETS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|nmemb
operator|=
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|-
operator|(
name|t1
operator|=
name|c
index|[
name|i
index|]
operator|)
operator|)
operator|<
literal|2
condition|)
continue|continue;
name|p
operator|=
name|bot
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|nmemb
operator|>
name|__rspartition
condition|)
name|STACKPUSH
else|else
name|SHELLSORT
block|}
comment|/* Break out when stack is empty */
name|STACKPOP
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|l2
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stack
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

