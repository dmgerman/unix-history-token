begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)atof.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|double
name|_twoemax
init|=
ifdef|#
directive|ifdef
name|IEEE
literal|9007199254740992.
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*2^53*/
end_comment

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|72057594037927936.
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*2^56*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|hp300
end_ifdef

begin_comment
comment|/* attempt to be as exact as possible */
end_comment

begin_struct
struct|struct
block|{
name|long
name|d_high
decl_stmt|;
name|long
name|d_low
decl_stmt|;
block|}
name|_exp5
index|[]
init|=
block|{
block|{
literal|0x40140000
block|,
literal|0x00000000
block|}
block|,
comment|/* 5 */
block|{
literal|0x40390000
block|,
literal|0x00000000
block|}
block|,
comment|/* 25 */
block|{
literal|0x40838800
block|,
literal|0x00000000
block|}
block|,
comment|/* 625 */
block|{
literal|0x4117d784
block|,
literal|0x00000000
block|}
block|,
comment|/* 390625 */
block|{
literal|0x4241c379
block|,
literal|0x37e08000
block|}
block|,
comment|/* 152587890625 */
block|{
literal|0x4493b8b5
block|,
literal|0xb5056e17
block|}
block|,
comment|/* 2.3283064365387e+022 */
block|{
literal|0x49384f03
block|,
literal|0xe93ff9f6
block|}
block|,
comment|/* 5.42101086242753e+044 */
block|{
literal|0x52827748
block|,
literal|0xf9301d33
block|}
block|,
comment|/* 2.93873587705572e+089 */
block|{
literal|0x65154fdd
block|,
literal|0x7f73bf3f
block|}
comment|/* 8.63616855509445e+178 */
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|double
name|_exp5
index|[]
init|=
block|{
literal|5.
block|,
literal|25.
block|,
literal|625.
block|,
literal|390625.
block|,
literal|152587890625.
block|,
literal|23283064365386962890625.
block|,
ifdef|#
directive|ifdef
name|IEEE
literal|5.4210108624275231e+044
block|,
literal|2.9387358770557196e+089
block|,
literal|8.6361685550944492e+178
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|atof
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|extern
name|double
name|ldexp
parameter_list|()
function_decl|;
specifier|register
name|c
operator|,
name|exp
operator|=
literal|0
operator|,
name|eexp
operator|=
literal|0
expr_stmt|;
name|double
name|fl
init|=
literal|0
decl_stmt|,
name|flexp
init|=
literal|1.0
decl_stmt|;
name|int
name|bexp
decl_stmt|,
name|neg
init|=
literal|1
decl_stmt|,
name|negexp
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|neg
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
empty_stmt|;
else|else
operator|--
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|,
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|fl
operator|<
name|_twoemax
condition|)
name|fl
operator|=
literal|10
operator|*
name|fl
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|exp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|,
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|fl
operator|<
name|_twoemax
condition|)
block|{
name|fl
operator|=
literal|10
operator|*
name|fl
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'e'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'+'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|negexp
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|--
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|,
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|eexp
operator|=
literal|10
operator|*
name|eexp
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|negexp
operator|<
literal|0
condition|)
name|eexp
operator|=
operator|-
name|eexp
expr_stmt|;
name|exp
operator|+=
name|eexp
expr_stmt|;
block|}
name|bexp
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
sizeof|sizeof
argument_list|(
name|_exp5
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_exp5
index|[
literal|0
index|]
argument_list|)
condition|;
name|c
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|hp300
if|if
condition|(
name|exp
operator|&
literal|01
condition|)
name|flexp
operator|*=
operator|*
operator|(
name|double
operator|*
operator|)
operator|&
name|_exp5
index|[
name|c
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|exp
operator|&
literal|01
condition|)
name|flexp
operator|*=
name|_exp5
index|[
name|c
index|]
expr_stmt|;
endif|#
directive|endif
name|exp
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|bexp
operator|<
literal|0
condition|)
name|fl
operator|/=
name|flexp
expr_stmt|;
else|else
name|fl
operator|*=
name|flexp
expr_stmt|;
name|fl
operator|=
name|ldexp
argument_list|(
name|fl
argument_list|,
name|bexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|fl
operator|)
return|;
else|else
return|return
operator|(
name|fl
operator|)
return|;
block|}
end_function

end_unit

