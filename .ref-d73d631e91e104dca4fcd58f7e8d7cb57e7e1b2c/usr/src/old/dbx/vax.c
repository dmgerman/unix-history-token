begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vax.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Target machine dependent stuff.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_include
include|#
directive|include
file|"ops.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Address
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Word
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NREG
value|16
end_define

begin_define
define|#
directive|define
name|ARGP
value|12
end_define

begin_define
define|#
directive|define
name|FRP
value|13
end_define

begin_define
define|#
directive|define
name|STKP
value|14
end_define

begin_define
define|#
directive|define
name|PROGCTR
value|15
end_define

begin_define
define|#
directive|define
name|CODESTART
value|0
end_define

begin_define
define|#
directive|define
name|FUNCOFFSET
value|2
end_define

begin_define
define|#
directive|define
name|nargspassed
parameter_list|(
name|frame
parameter_list|)
value|argn(0, frame)
end_define

begin_define
define|#
directive|define
name|BITSPERBYTE
value|8
end_define

begin_define
define|#
directive|define
name|BITSPERWORD
value|(BITSPERBYTE * sizeof(Word))
end_define

begin_comment
comment|/*  * This magic macro enables us to look at the process' registers  * in its user structure.  */
end_comment

begin_define
define|#
directive|define
name|regloc
parameter_list|(
name|reg
parameter_list|)
value|(ctob(UPAGES) + (sizeof(Word) * (reg)))
end_define

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|DELETE
end_undef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_decl_stmt
name|Address
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Address
name|prtaddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Indices into u. for use in collecting registers values.  */
end_comment

begin_decl_stmt
name|public
name|int
name|rloc
index|[]
init|=
block|{
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,
name|AP
block|,
name|FP
block|,
name|SP
block|,
name|PC
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|Address
name|printop
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|Optab
modifier|*
name|ioptab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index by opcode to optab */
end_comment

begin_decl_stmt
name|private
name|Optab
modifier|*
name|esctab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for extended opcodes */
end_comment

begin_comment
comment|/*  * Initialize the opcode lookup table.  */
end_comment

begin_function
name|public
name|optab_init
parameter_list|()
block|{
specifier|register
name|Optab
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|optab
init|;
name|p
operator|->
name|iname
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|format
operator|==
name|O_ESCD
condition|)
block|{
name|esctab
index|[
name|p
operator|->
name|val
index|]
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|format
operator|!=
name|O_ESCD
operator|&&
name|p
operator|->
name|format
operator|!=
name|O_ESCE
condition|)
block|{
name|ioptab
index|[
name|p
operator|->
name|val
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Decode and print the instructions within the given address range.  */
end_comment

begin_function
name|public
name|printinst
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
control|)
block|{
name|addr
operator|=
name|printop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Another approach:  print n instructions starting at the given address.  */
end_comment

begin_function
name|public
name|printninst
parameter_list|(
name|count
parameter_list|,
name|addr
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Address
name|newaddr
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newaddr
operator|=
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|newaddr
operator|=
name|printop
argument_list|(
name|newaddr
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|newaddr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the contents of the addresses within the given range  * according to the given format.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|String
name|name
decl_stmt|;
name|String
name|printfstring
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|Format
typedef|;
end_typedef

begin_decl_stmt
name|private
name|Format
name|fmt
index|[]
init|=
block|{
block|{
literal|"d"
block|,
literal|" %d"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"D"
block|,
literal|" %ld"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"o"
block|,
literal|" %o"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"O"
block|,
literal|" %lo"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"x"
block|,
literal|" %04x"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"X"
block|,
literal|" %08x"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"b"
block|,
literal|" \\%o"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"c"
block|,
literal|" '%c'"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"s"
block|,
literal|"%c"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"f"
block|,
literal|" %f"
block|,
expr|sizeof
operator|(
name|float
operator|)
block|}
block|,
block|{
literal|"g"
block|,
literal|" %g"
block|,
expr|sizeof
operator|(
name|double
operator|)
block|}
block|,
block|{
name|nil
block|,
name|nil
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Format
modifier|*
name|findformat
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|&
name|fmt
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|name
operator|!=
name|nil
name|and
name|not
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|s
argument_list|)
condition|)
block|{
operator|++
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|name
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"bad print format \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve and print out the appropriate data in the given format.  * Floats have to be handled specially to allow the compiler to  * convert them to doubles when passing to printf.  */
end_comment

begin_function
name|private
name|printformat
parameter_list|(
name|f
parameter_list|,
name|addr
parameter_list|)
name|Format
modifier|*
name|f
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
union|union
block|{
name|char
name|charv
decl_stmt|;
name|short
name|shortv
decl_stmt|;
name|int
name|intv
decl_stmt|;
name|float
name|floatv
decl_stmt|;
name|double
name|doublev
decl_stmt|;
block|}
name|value
union|;
name|value
operator|.
name|intv
operator|=
literal|0
expr_stmt|;
name|dread
argument_list|(
operator|&
name|value
argument_list|,
name|addr
argument_list|,
name|f
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"f"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
operator|.
name|floatv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|Address
name|printdata
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|,
name|format
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
name|Format
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|lowaddr
operator|>
name|highaddr
condition|)
block|{
name|error
argument_list|(
literal|"first address larger than second"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
name|addr
operator|+=
name|f
operator|->
name|length
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|printformat
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * The other approach is to print n items starting with a given address.  */
end_comment

begin_function
name|public
name|printndata
parameter_list|(
name|count
parameter_list|,
name|startaddr
parameter_list|,
name|format
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Format
modifier|*
name|f
decl_stmt|;
name|Boolean
name|isstring
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|isstring
operator|=
operator|(
name|Boolean
operator|)
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isstring
condition|)
block|{
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|printchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|addr
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|String
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printformat
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|addr
operator|+=
name|f
operator|->
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a value according to the given format.  */
end_comment

begin_function
name|public
name|printvalue
parameter_list|(
name|v
parameter_list|,
name|format
parameter_list|)
name|long
name|v
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|Format
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|v
expr_stmt|;
name|q
operator|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|printchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out an execution time error.  * Assumes the source position of the error has been calculated.  *  * Have to check if the -r option was specified; if so then  * the object file information hasn't been read in yet.  */
end_comment

begin_function
name|public
name|printerror
parameter_list|()
block|{
specifier|extern
name|Integer
name|sys_nsig
decl_stmt|;
specifier|extern
name|String
name|sys_siglist
index|[]
decl_stmt|;
name|integer
name|err
decl_stmt|;
if|if
condition|(
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|err
operator|=
name|exitcode
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\" terminated normally\n"
argument_list|,
name|objname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\"%s\" terminated abnormally (exit code %d)\n"
argument_list|,
name|objname
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
name|err
operator|=
name|errnum
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printsig
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printloc
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
condition|)
block|{
name|printlines
argument_list|(
name|curline
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printinst
argument_list|(
name|pc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a signal.  */
end_comment

begin_decl_stmt
name|private
name|String
name|illinames
index|[]
init|=
block|{
literal|"reserved addressing fault"
block|,
literal|"privileged instruction fault"
block|,
literal|"reserved operand fault"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|String
name|fpenames
index|[]
init|=
block|{
name|nil
block|,
literal|"integer overflow trap"
block|,
literal|"integer divide by zero trap"
block|,
literal|"floating overflow trap"
block|,
literal|"floating/decimal divide by zero trap"
block|,
literal|"floating underflow trap"
block|,
literal|"decimal overflow trap"
block|,
literal|"subscript out of range trap"
block|,
literal|"floating overflow fault"
block|,
literal|"floating divide by zero fault"
block|,
literal|"floating underflow fault"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|printsig
parameter_list|(
name|signo
parameter_list|)
name|integer
name|signo
decl_stmt|;
block|{
name|integer
name|code
decl_stmt|;
if|if
condition|(
name|signo
operator|<
literal|0
name|or
name|signo
operator|>
name|sys_nsig
condition|)
block|{
name|printf
argument_list|(
literal|"[signal %d]"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sys_siglist
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|errcode
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|==
name|SIGILL
condition|)
block|{
if|if
condition|(
name|code
operator|>=
literal|0
name|and
name|code
operator|<
sizeof|sizeof
argument_list|(
name|illinames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|illinames
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|illinames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|signo
operator|==
name|SIGFPE
condition|)
block|{
if|if
condition|(
name|code
operator|>
literal|0
name|and
name|code
operator|<
sizeof|sizeof
argument_list|(
name|fpenames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fpenames
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|fpenames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Note the termination of the program.  We do this so as to avoid  * having the process exit, which would make the values of variables  * inaccessible.  We do want to flush all output buffers here,  * otherwise it'll never get done.  */
end_comment

begin_function
name|public
name|endprogram
parameter_list|()
block|{
name|Integer
name|exitcode
decl_stmt|;
name|stepto
argument_list|(
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|printnews
argument_list|()
expr_stmt|;
name|exitcode
operator|=
name|argn
argument_list|(
literal|1
argument_list|,
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nexecution completed (exit code %d)\n"
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nexecution completed\n"
argument_list|)
expr_stmt|;
block|}
name|getsrcpos
argument_list|()
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Single step the machine a source line (or instruction if "inst_tracing"  * is true).  If "isnext" is true, skip over procedure calls.  */
end_comment

begin_function_decl
name|private
name|Address
name|getcall
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|dostep
parameter_list|(
name|isnext
parameter_list|)
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Lineno
name|line
decl_stmt|;
name|String
name|filename
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|startaddr
operator|=
name|pc
expr_stmt|;
name|addr
operator|=
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|inst_tracing
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|nextaddr
argument_list|(
name|addr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|curline
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
name|curline
operator|=
literal|0
expr_stmt|;
block|}
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|filename
operator|=
name|srcfilename
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|setsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|char
name|Bpinst
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BP_OP
value|O_BPT
end_define

begin_comment
comment|/* breakpoint trap */
end_comment

begin_define
define|#
directive|define
name|BP_ERRNO
value|SIGTRAP
end_define

begin_comment
comment|/* signal received at a breakpoint */
end_comment

begin_comment
comment|/*  * Setting a breakpoint at a location consists of saving  * the word at the location and poking a BP_OP there.  *  * We save the locations and words on a list for use in unsetting.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|Savelist
modifier|*
name|Savelist
typedef|;
end_typedef

begin_struct
struct|struct
name|Savelist
block|{
name|Address
name|location
decl_stmt|;
name|Bpinst
name|save
decl_stmt|;
name|short
name|refcount
decl_stmt|;
name|Savelist
name|link
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|Savelist
name|savelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a breakpoint at the given address.  Only save the word there  * if it's not already a breakpoint.  */
end_comment

begin_function
name|public
name|setbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Bpinst
name|w
decl_stmt|,
name|save
decl_stmt|;
specifier|register
name|Savelist
name|newsave
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|s
operator|->
name|refcount
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|iread
argument_list|(
operator|&
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|newsave
operator|=
name|new
argument_list|(
name|Savelist
argument_list|)
expr_stmt|;
name|newsave
operator|->
name|location
operator|=
name|addr
expr_stmt|;
name|newsave
operator|->
name|save
operator|=
name|save
expr_stmt|;
name|newsave
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|newsave
operator|->
name|link
operator|=
name|savelist
expr_stmt|;
name|savelist
operator|=
name|newsave
expr_stmt|;
name|w
operator|=
name|BP_OP
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|w
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unset a breakpoint; unfortunately we have to search the SAVELIST  * to find the saved value.  The assumption is that the SAVELIST will  * usually be quite small.  */
end_comment

begin_function
name|public
name|unsetbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Savelist
name|s
decl_stmt|,
name|prev
decl_stmt|;
name|prev
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|iwrite
argument_list|(
operator|&
name|s
operator|->
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|nil
condition|)
block|{
name|savelist
operator|=
name|s
operator|->
name|link
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|link
operator|=
name|s
operator|->
name|link
expr_stmt|;
block|}
name|dispose
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|prev
operator|=
name|s
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"unsetbp: couldn't find address %d"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * VAX instruction decoder, derived from adb.  */
end_comment

begin_function
name|private
name|Address
name|printop
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Optab
modifier|*
name|op
decl_stmt|;
name|VaxOpcode
name|ins
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|int
name|argtype
decl_stmt|,
name|amode
decl_stmt|,
name|argno
decl_stmt|,
name|argval
decl_stmt|;
name|String
name|reg
decl_stmt|;
name|Boolean
name|indexf
decl_stmt|;
name|short
name|offset
decl_stmt|;
name|argval
operator|=
literal|0
expr_stmt|;
name|indexf
operator|=
name|false
expr_stmt|;
name|printf
argument_list|(
literal|"%08x  "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ins
operator|==
name|O_ESCF
condition|)
block|{
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|ioptab
index|[
name|ins
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ins
operator|==
name|O_ESCD
condition|)
block|{
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|esctab
index|[
name|ins
index|]
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|ioptab
index|[
name|ins
index|]
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"[unrecognized opcode %#0x]\n"
argument_list|,
name|ins
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|op
operator|->
name|iname
argument_list|)
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|op
operator|->
name|numargs
condition|;
name|argno
operator|++
control|)
block|{
if|if
condition|(
name|indexf
operator|==
name|true
condition|)
block|{
name|indexf
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argno
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|op
operator|->
name|argtype
index|[
name|argno
index|]
expr_stmt|;
if|if
condition|(
name|is_branch_disp
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|0xAF
operator|+
operator|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iread
argument_list|(
operator|&
name|mode
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
block|}
name|reg
operator|=
name|regname
index|[
name|regnm
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
name|amode
operator|=
name|addrmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|amode
condition|)
block|{
case|case
name|LITSHORT
case|:
case|case
name|LITUPTO31
case|:
case|case
name|LITUPTO47
case|:
case|case
name|LITUPTO63
case|:
if|if
condition|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|==
name|TYPF
operator|||
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|==
name|TYPD
operator|||
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|==
name|TYPG
operator|||
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|==
name|TYPH
condition|)
name|printf
argument_list|(
literal|"$%s"
argument_list|,
name|fltimm
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"$%x"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|argval
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|indexf
operator|=
name|true
expr_stmt|;
name|argno
operator|--
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGDEF
case|:
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTODEC
case|:
name|printf
argument_list|(
literal|"-(%s)"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTOINC
case|:
if|if
condition|(
name|reg
operator|!=
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"(%s)+"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|typelen
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
case|case
name|TYPB
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TYPW
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPL
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPF
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argval
operator|&
literal|0xffff007f
operator|)
operator|==
literal|0x8000
condition|)
block|{
name|printf
argument_list|(
literal|"[reserved operand]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%g"
argument_list|,
operator|*
operator|(
name|float
operator|*
operator|)
operator|&
name|argval
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPD
case|:
comment|/* XXX this bags the low order bits */
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argval
operator|&
literal|0xffff007f
operator|)
operator|==
literal|0x8000
condition|)
block|{
name|printf
argument_list|(
literal|"[reserved operand]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%g"
argument_list|,
operator|*
operator|(
name|float
operator|*
operator|)
operator|&
name|argval
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|TYPG
case|:
case|case
name|TYPQ
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|TYPH
case|:
case|case
name|TYPO
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|12
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%08x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|16
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|AUTOINCDEF
case|:
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"*$"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"*(%s)+"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BYTEDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|BYTEDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|WORDDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|WORDDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONGDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|LONGDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ins
operator|==
name|O_CASEB
operator|||
name|ins
operator|==
name|O_CASEW
operator|||
name|ins
operator|==
name|O_CASEL
condition|)
block|{
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<=
name|argval
condition|;
name|argno
operator|++
control|)
block|{
name|iread
argument_list|(
operator|&
name|offset
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Print the displacement of an instruction that uses displacement  * addressing.  */
end_comment

begin_function
name|private
name|int
name|printdisp
parameter_list|(
name|addr
parameter_list|,
name|nbytes
parameter_list|,
name|reg
parameter_list|,
name|mode
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|char
modifier|*
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|short
name|hword
decl_stmt|;
name|int
name|argval
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|iread
argument_list|(
operator|&
name|byte
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iread
argument_list|(
operator|&
name|hword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|hword
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|hword
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
operator|&&
name|mode
operator|>=
name|BYTEDISP
condition|)
block|{
name|argval
operator|+=
name|addr
operator|+
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|f
operator|=
name|whatblock
argument_list|(
operator|(
name|Address
operator|)
name|argval
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeloc
argument_list|(
name|f
argument_list|)
operator|==
name|argval
operator|+
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$hexoffsets"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argval
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"-%x(%s)"
argument_list|,
operator|-
operator|(
name|argval
operator|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%x(%s)"
argument_list|,
name|argval
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d(%s)"
argument_list|,
name|argval
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|argval
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the next address that will be executed from the given one.  * If "isnext" is true then consider a procedure call as straight line code.  *  * We must unfortunately do much of the same work that is necessary  * to print instructions.  In addition we have to deal with branches.  * Unconditional branches we just follow, for conditional branches  * we continue execution to the current location and then single step  * the machine.  We assume that the last argument in an instruction  * that branches is the branch address (or relative offset).  */
end_comment

begin_function_decl
name|private
name|Address
name|findnextaddr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|Address
name|nextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|boolean
name|isnext
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|usignal
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
name|or
name|addr
operator|==
literal|1
condition|)
block|{
name|addr
operator|=
name|findnextaddr
argument_list|(
name|startaddr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if it's ok to skip function f entered by instruction ins.  * If so, we're going to compute the return address and step to it.  * Therefore we cannot skip over a function entered by a jsb or bsb,  * since the return address is not easily computed for them.  */
end_comment

begin_function
name|private
name|boolean
name|skipfunc
parameter_list|(
name|ins
parameter_list|,
name|f
parameter_list|)
name|VaxOpcode
name|ins
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
block|{
name|boolean
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|boolean
operator|)
operator|(
name|ins
operator|!=
name|O_JSB
name|and
name|ins
operator|!=
name|O_BSBB
name|and
name|ins
operator|!=
name|O_BSBW
name|and
name|not
name|inst_tracing
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
name|and
name|nosource
argument_list|(
argument|curfunc
argument_list|)
name|and
name|canskip
argument_list|(
name|curfunc
argument_list|)
operator|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|private
name|Address
name|findnextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Optab
modifier|*
name|op
decl_stmt|;
name|VaxOpcode
name|ins
decl_stmt|,
name|ins2
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|int
name|argtype
decl_stmt|,
name|amode
decl_stmt|,
name|argno
decl_stmt|,
name|argval
decl_stmt|;
name|String
name|r
decl_stmt|;
name|Boolean
name|indexf
decl_stmt|;
enum|enum
block|{
name|KNOWN
block|,
name|SEQUENTIAL
block|,
name|BRANCH
block|}
name|addrstatus
enum|;
name|argval
operator|=
literal|0
expr_stmt|;
name|indexf
operator|=
name|false
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ins
condition|)
block|{
comment|/* 	 * It used to be that unconditional jumps and branches were handled 	 * by taking their destination address as the next address.  While 	 * saving the cost of starting up the process, this approach 	 * doesn't work when jumping indirect (since the value in the 	 * register might not yet have been set). 	 * 	 * So unconditional jumps and branches are now handled the same way 	 * as conditional jumps and branches. 	 * 	case O_BRB: 	case O_BRW: 	    addrstatus = BRANCH; 	    break; 	 * 	 */
case|case
name|O_BSBB
case|:
case|case
name|O_BSBW
case|:
case|case
name|O_JSB
case|:
case|case
name|O_CALLG
case|:
case|case
name|O_CALLS
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
name|setcurfunc
argument_list|(
name|whatblock
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|bpact
argument_list|()
expr_stmt|;
if|if
condition|(
name|isnext
name|or
name|skipfunc
argument_list|(
name|ins
argument_list|,
name|curfunc
argument_list|)
condition|)
block|{
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|bpact
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callnews
argument_list|(
comment|/* iscall = */
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_RSB
case|:
case|case
name|O_RET
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|callnews
argument_list|(
comment|/* iscall = */
name|false
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
name|bpact
argument_list|()
expr_stmt|;
break|break;
case|case
name|O_BRB
case|:
case|case
name|O_BRW
case|:
case|case
name|O_JMP
case|:
comment|/* because it may be jmp (r1) */
case|case
name|O_BNEQ
case|:
case|case
name|O_BEQL
case|:
case|case
name|O_BGTR
case|:
case|case
name|O_BLEQ
case|:
case|case
name|O_BGEQ
case|:
case|case
name|O_BLSS
case|:
case|case
name|O_BGTRU
case|:
case|case
name|O_BLEQU
case|:
case|case
name|O_BVC
case|:
case|case
name|O_BVS
case|:
case|case
name|O_BCC
case|:
case|case
name|O_BCS
case|:
case|case
name|O_CASEB
case|:
case|case
name|O_CASEW
case|:
case|case
name|O_CASEL
case|:
case|case
name|O_BBS
case|:
case|case
name|O_BBC
case|:
case|case
name|O_BBSS
case|:
case|case
name|O_BBCS
case|:
case|case
name|O_BBSC
case|:
case|case
name|O_BBCC
case|:
case|case
name|O_BBSSI
case|:
case|case
name|O_BBCCI
case|:
case|case
name|O_BLBS
case|:
case|case
name|O_BLBC
case|:
case|case
name|O_ACBL
case|:
case|case
name|O_AOBLSS
case|:
case|case
name|O_AOBLEQ
case|:
case|case
name|O_SOBGEQ
case|:
case|case
name|O_SOBGTR
case|:
case|case
name|O_ESCF
case|:
comment|/* bugchecks */
name|branches
label|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|O_ESCD
case|:
name|iread
argument_list|(
operator|&
name|ins2
argument_list|,
name|addr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ins2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins2
operator|==
name|O_ACBF
operator|||
name|ins2
operator|==
name|O_ACBD
condition|)
comment|/* actually ACBG and ACBH */
goto|goto
name|branches
goto|;
comment|/* fall through */
default|default:
name|addrstatus
operator|=
name|SEQUENTIAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addrstatus
operator|!=
name|KNOWN
condition|)
block|{
name|addr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ins
operator|==
name|O_ESCD
condition|)
block|{
name|ins
operator|=
name|ins2
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|esctab
index|[
name|ins
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"[bad extended opcode %#x in findnextaddr]\n"
argument_list|,
name|ins
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
else|else
block|{
name|op
operator|=
name|ioptab
index|[
name|ins
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"[bad opcode %#x in findnextaddr]\n"
argument_list|,
name|ins
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|op
operator|->
name|numargs
condition|;
name|argno
operator|++
control|)
block|{
if|if
condition|(
name|indexf
operator|==
name|true
condition|)
block|{
name|indexf
operator|=
name|false
expr_stmt|;
block|}
name|argtype
operator|=
name|op
operator|->
name|argtype
index|[
name|argno
index|]
expr_stmt|;
if|if
condition|(
name|is_branch_disp
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|0xAF
operator|+
operator|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iread
argument_list|(
operator|&
name|mode
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
block|}
name|r
operator|=
name|regname
index|[
name|regnm
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
name|amode
operator|=
name|addrmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|amode
condition|)
block|{
case|case
name|LITSHORT
case|:
case|case
name|LITUPTO31
case|:
case|case
name|LITUPTO47
case|:
case|case
name|LITUPTO63
case|:
name|argval
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|indexf
operator|=
name|true
expr_stmt|;
operator|--
name|argno
expr_stmt|;
break|break;
case|case
name|REG
case|:
case|case
name|REGDEF
case|:
case|case
name|AUTODEC
case|:
break|break;
case|case
name|AUTOINC
case|:
if|if
condition|(
name|r
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
switch|switch
condition|(
name|typelen
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
case|case
name|TYPB
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TYPW
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPL
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPF
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPQ
case|:
case|case
name|TYPD
case|:
case|case
name|TYPG
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|TYPO
case|:
case|case
name|TYPH
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|12
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|16
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|AUTOINCDEF
case|:
if|if
condition|(
name|r
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|BYTEDISP
case|:
case|case
name|BYTEDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|WORDDISP
case|:
case|case
name|WORDDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONGDISP
case|:
case|case
name|LONGDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ins
operator|==
name|O_CALLS
name|or
name|ins
operator|==
name|O_CALLG
condition|)
block|{
name|argval
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|addrstatus
operator|==
name|BRANCH
condition|)
block|{
name|addr
operator|=
name|argval
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Get the displacement of an instruction that uses displacement addressing.  */
end_comment

begin_function
name|private
name|int
name|getdisp
parameter_list|(
name|addr
parameter_list|,
name|nbytes
parameter_list|,
name|reg
parameter_list|,
name|mode
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|String
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|short
name|hword
decl_stmt|;
name|int
name|argval
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|iread
argument_list|(
operator|&
name|byte
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iread
argument_list|(
operator|&
name|hword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|hword
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|hword
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
operator|&&
name|mode
operator|>=
name|BYTEDISP
condition|)
block|{
name|argval
operator|+=
name|addr
operator|+
name|nbytes
expr_stmt|;
block|}
return|return
name|argval
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a procedure by creating and executing a call instruction.  */
end_comment

begin_define
define|#
directive|define
name|CALLSIZE
value|7
end_define

begin_comment
comment|/* size of call instruction */
end_comment

begin_function
name|public
name|beginproc
parameter_list|(
name|p
parameter_list|,
name|argc
parameter_list|)
name|Symbol
name|p
decl_stmt|;
name|Integer
name|argc
decl_stmt|;
block|{
name|char
name|save
index|[
name|CALLSIZE
index|]
decl_stmt|;
struct|struct
block|{
name|VaxOpcode
name|op
decl_stmt|;
name|unsigned
name|char
name|numargs
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|char
name|addr
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
comment|/* unaligned long */
block|}
name|call
struct|;
name|long
name|dest
decl_stmt|;
name|pc
operator|=
literal|2
expr_stmt|;
name|iread
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|.
name|op
operator|=
name|O_CALLS
expr_stmt|;
name|call
operator|.
name|numargs
operator|=
name|argc
expr_stmt|;
name|call
operator|.
name|mode
operator|=
literal|0xef
expr_stmt|;
name|dest
operator|=
name|codeloc
argument_list|(
name|p
argument_list|)
operator|-
literal|2
operator|-
operator|(
name|pc
operator|+
literal|7
operator|)
expr_stmt|;
name|mov
argument_list|(
operator|&
name|dest
argument_list|,
name|call
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|call
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|call
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Special variables for debugging the kernel.  */
end_comment

begin_decl_stmt
name|public
name|integer
name|masterpcbb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|integer
name|slr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|struct
name|pte
modifier|*
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|getpcb
parameter_list|()
block|{
name|integer
name|i
decl_stmt|;
name|fseek
argument_list|(
name|corefile
argument_list|,
name|masterpcbb
operator|&
operator|~
literal|0x80000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get
argument_list|(
name|corefile
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|.
name|pcb_p0lr
operator|&=
operator|~
name|AST_CLR
expr_stmt|;
name|printf
argument_list|(
literal|"p0br %lx p0lr %lx p1br %lx p1lr %lx\n"
argument_list|,
name|pcb
operator|.
name|pcb_p0br
argument_list|,
name|pcb
operator|.
name|pcb_p0lr
argument_list|,
name|pcb
operator|.
name|pcb_p1br
argument_list|,
name|pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|0
argument_list|,
name|pcb
operator|.
name|pcb_r0
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|1
argument_list|,
name|pcb
operator|.
name|pcb_r1
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|2
argument_list|,
name|pcb
operator|.
name|pcb_r2
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|3
argument_list|,
name|pcb
operator|.
name|pcb_r3
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|4
argument_list|,
name|pcb
operator|.
name|pcb_r4
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|5
argument_list|,
name|pcb
operator|.
name|pcb_r5
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|6
argument_list|,
name|pcb
operator|.
name|pcb_r6
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|7
argument_list|,
name|pcb
operator|.
name|pcb_r7
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|8
argument_list|,
name|pcb
operator|.
name|pcb_r8
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|9
argument_list|,
name|pcb
operator|.
name|pcb_r9
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|10
argument_list|,
name|pcb
operator|.
name|pcb_r10
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|11
argument_list|,
name|pcb
operator|.
name|pcb_r11
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|ARGP
argument_list|,
name|pcb
operator|.
name|pcb_ap
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|FRP
argument_list|,
name|pcb
operator|.
name|pcb_fp
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|pcb
operator|.
name|pcb_ksp
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|public
name|copyregs
argument_list|(
name|savreg
argument_list|,
name|reg
argument_list|)
name|Word
name|savreg
index|[]
decl_stmt|,
name|reg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
index|[
literal|0
index|]
operator|=
name|savreg
index|[
name|R0
index|]
expr_stmt|;
name|reg
index|[
literal|1
index|]
operator|=
name|savreg
index|[
name|R1
index|]
expr_stmt|;
name|reg
index|[
literal|2
index|]
operator|=
name|savreg
index|[
name|R2
index|]
expr_stmt|;
name|reg
index|[
literal|3
index|]
operator|=
name|savreg
index|[
name|R3
index|]
expr_stmt|;
name|reg
index|[
literal|4
index|]
operator|=
name|savreg
index|[
name|R4
index|]
expr_stmt|;
name|reg
index|[
literal|5
index|]
operator|=
name|savreg
index|[
name|R5
index|]
expr_stmt|;
name|reg
index|[
literal|6
index|]
operator|=
name|savreg
index|[
name|R6
index|]
expr_stmt|;
name|reg
index|[
literal|7
index|]
operator|=
name|savreg
index|[
name|R7
index|]
expr_stmt|;
name|reg
index|[
literal|8
index|]
operator|=
name|savreg
index|[
name|R8
index|]
expr_stmt|;
name|reg
index|[
literal|9
index|]
operator|=
name|savreg
index|[
name|R9
index|]
expr_stmt|;
name|reg
index|[
literal|10
index|]
operator|=
name|savreg
index|[
name|R10
index|]
expr_stmt|;
name|reg
index|[
literal|11
index|]
operator|=
name|savreg
index|[
name|R11
index|]
expr_stmt|;
name|reg
index|[
name|ARGP
index|]
operator|=
name|savreg
index|[
name|AP
index|]
expr_stmt|;
name|reg
index|[
name|FRP
index|]
operator|=
name|savreg
index|[
name|FP
index|]
expr_stmt|;
name|reg
index|[
name|STKP
index|]
operator|=
name|savreg
index|[
name|SP
index|]
expr_stmt|;
name|reg
index|[
name|PROGCTR
index|]
operator|=
name|savreg
index|[
name|PC
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map a virtual address to a physical address.  */
end_comment

begin_function
name|public
name|Address
name|vmap
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Address
name|r
decl_stmt|;
name|integer
name|v
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
name|r
operator|=
name|addr
operator|&
operator|~
literal|0xc0000000
expr_stmt|;
name|v
operator|=
name|btop
argument_list|(
name|r
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addr
operator|&
literal|0xc0000000
condition|)
block|{
case|case
literal|0xc0000000
case|:
case|case
literal|0x80000000
case|:
comment|/* 	     * In system space, so get system pte. 	     * If it is valid or reclaimable then the physical address 	     * is the combination of its page number and the page offset 	     * of the original address. 	     */
if|if
condition|(
name|v
operator|>=
name|slr
condition|)
block|{
name|error
argument_list|(
literal|"address %x out of segment"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|sbr
operator|+
name|v
argument_list|)
operator|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
goto|goto
name|simple
goto|;
case|case
literal|0x40000000
case|:
comment|/* 	     * In p1 space, must not be in shadow region. 	     */
if|if
condition|(
name|v
operator|<
name|pcb
operator|.
name|pcb_p1lr
condition|)
block|{
name|error
argument_list|(
literal|"address %x out of segment"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
call|(
name|Address
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p1br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00000000
case|:
comment|/* 	     * In p0 space, must not be off end of region. 	     */
if|if
condition|(
name|v
operator|>=
name|pcb
operator|.
name|pcb_p0lr
condition|)
block|{
name|error
argument_list|(
literal|"address %x out of segment"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
call|(
name|Address
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p0br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
comment|/*      * For p0/p1 address, user-level page table should be in      * kernel virtual memory.  Do second-level indirect by recursing.      */
if|if
condition|(
operator|(
name|r
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"bad p0br or p1br in pcb"
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|vmap
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|simple
label|:
comment|/*      * "r" is now the address of the pte of the page      * we are interested in; get the pte and paste up the physical address.      */
name|fseek
argument_list|(
name|corefile
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|fread
argument_list|(
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|corefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"page table botch (fread at %x returns %d)"
argument_list|,
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pte
operator|.
name|pg_v
operator|==
literal|0
name|and
argument_list|(
argument|pte.pg_fod !=
literal|0
argument|or pte.pg_pfnum ==
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"page no valid or reclamable"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
operator|+
operator|(
operator|(
name|Address
operator|)
name|ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract a bit field from an integer.  */
end_comment

begin_function
name|public
name|integer
name|extractField
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|integer
name|n
decl_stmt|,
name|nbytes
decl_stmt|,
name|r
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
name|size
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[bad size in extractField -- word assumed]\n"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|popn
argument_list|(
name|nbytes
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|r
operator|=
name|n
operator|>>
operator|(
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
name|mod
name|BITSPERBYTE
operator|)
expr_stmt|;
name|r
operator|&=
operator|(
operator|(
literal|1
operator|<<
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Change the length of a value in memory according to a given difference  * in the lengths of its new and old types.  */
end_comment

begin_function
name|public
name|loophole
parameter_list|(
name|oldlen
parameter_list|,
name|newlen
parameter_list|)
name|integer
name|oldlen
decl_stmt|,
name|newlen
decl_stmt|;
block|{
name|integer
name|n
decl_stmt|,
name|i
decl_stmt|;
name|n
operator|=
name|newlen
operator|-
name|oldlen
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sp
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|sp
operator|+=
name|n
expr_stmt|;
block|}
end_function

end_unit

