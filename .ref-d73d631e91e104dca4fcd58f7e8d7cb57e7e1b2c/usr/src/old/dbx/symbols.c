begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)symbols.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Symbol management.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"printsym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|Symbol
modifier|*
name|Symbol
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * Symbol classes  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|BADUSE
block|,
name|CONST
block|,
name|TYPE
block|,
name|VAR
block|,
name|ARRAY
block|,
name|OPENARRAY
block|,
name|DYNARRAY
block|,
name|SUBARRAY
block|,
name|PTRFILE
block|,
name|RECORD
block|,
name|FIELD
block|,
name|PROC
block|,
name|FUNC
block|,
name|FVAR
block|,
name|REF
block|,
name|PTR
block|,
name|FILET
block|,
name|SET
block|,
name|RANGE
block|,
name|LABEL
block|,
name|WITHPTR
block|,
name|SCAL
block|,
name|STR
block|,
name|PROG
block|,
name|IMPROPER
block|,
name|VARNT
block|,
name|FPROC
block|,
name|FFUNC
block|,
name|MODULE
block|,
name|TAG
block|,
name|COMMON
block|,
name|EXTREF
block|,
name|TYPEREF
block|}
name|Symclass
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|R_CONST
block|,
name|R_TEMP
block|,
name|R_ARG
block|,
name|R_ADJUST
block|}
name|Rangetype
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INREG
value|0
end_define

begin_define
define|#
directive|define
name|STK
value|1
end_define

begin_define
define|#
directive|define
name|EXT
value|2
end_define

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Storage
typedef|;
end_typedef

begin_struct
struct|struct
name|Symbol
block|{
name|Name
name|name
decl_stmt|;
name|Language
name|language
decl_stmt|;
name|Symclass
name|class
range|:
literal|8
decl_stmt|;
name|Storage
name|storage
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|level
range|:
literal|6
decl_stmt|;
comment|/* for variables stored on stack only */
name|Symbol
name|type
decl_stmt|;
name|Symbol
name|chain
decl_stmt|;
union|union
block|{
name|Node
name|constval
decl_stmt|;
comment|/* value of constant symbol */
name|int
name|offset
decl_stmt|;
comment|/* variable address */
name|long
name|iconval
decl_stmt|;
comment|/* integer constant value */
name|double
name|fconval
decl_stmt|;
comment|/* floating constant value */
name|int
name|ndims
decl_stmt|;
comment|/* no. of dimensions for dynamic/sub-arrays */
struct|struct
block|{
comment|/* field offset and size (both in bits) */
name|int
name|offset
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|field
struct|;
struct|struct
block|{
comment|/* common offset and chain; used to relocate */
name|int
name|offset
decl_stmt|;
comment|/* vars in global BSS */
name|Symbol
name|chain
decl_stmt|;
block|}
name|common
struct|;
struct|struct
block|{
comment|/* range bounds */
name|Rangetype
name|lowertype
range|:
literal|16
decl_stmt|;
name|Rangetype
name|uppertype
range|:
literal|16
decl_stmt|;
name|long
name|lower
decl_stmt|;
name|long
name|upper
decl_stmt|;
block|}
name|rangev
struct|;
struct|struct
block|{
name|int
name|offset
range|:
literal|16
decl_stmt|;
comment|/* offset for of function value */
name|Boolean
name|src
range|:
literal|1
decl_stmt|;
comment|/* true if there is source line info */
name|Boolean
specifier|inline
operator|:
literal|1
expr_stmt|;
comment|/* true if no separate act. rec. */
name|Boolean
name|intern
range|:
literal|1
decl_stmt|;
comment|/* internal calling sequence */
name|int
name|unused
range|:
literal|13
decl_stmt|;
name|Address
name|beginaddr
decl_stmt|;
comment|/* address of function code */
block|}
name|funcv
struct|;
struct|struct
block|{
comment|/* variant record info */
name|int
name|size
decl_stmt|;
name|Symbol
name|vtorec
decl_stmt|;
name|Symbol
name|vtag
decl_stmt|;
block|}
name|varnt
struct|;
name|String
name|typeref
decl_stmt|;
comment|/* type defined by "<module>:<type>" */
name|Symbol
name|extref
decl_stmt|;
comment|/* indirect symbol for external reference */
block|}
name|symvalue
union|;
name|Symbol
name|block
decl_stmt|;
comment|/* symbol containing this symbol */
name|Symbol
name|next_sym
decl_stmt|;
comment|/* hash chain */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Basic types.  */
end_comment

begin_decl_stmt
name|Symbol
name|t_boolean
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_real
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|curfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|showaggrs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|symname
parameter_list|(
name|s
parameter_list|)
value|ident(s->name)
end_define

begin_define
define|#
directive|define
name|codeloc
parameter_list|(
name|f
parameter_list|)
value|((f)->symvalue.funcv.beginaddr)
end_define

begin_define
define|#
directive|define
name|isblock
parameter_list|(
name|s
parameter_list|)
value|(Boolean) ( \     s->class == FUNC or s->class == PROC or \     s->class == MODULE or s->class == PROG \ )
end_define

begin_define
define|#
directive|define
name|isroutine
parameter_list|(
name|s
parameter_list|)
value|(Boolean) ( \     s->class == FUNC or s->class == PROC \ )
end_define

begin_define
define|#
directive|define
name|nosource
parameter_list|(
name|f
parameter_list|)
value|(not (f)->symvalue.funcv.src)
end_define

begin_define
define|#
directive|define
name|isinline
parameter_list|(
name|f
parameter_list|)
value|((f)->symvalue.funcv.inline)
end_define

begin_define
define|#
directive|define
name|isreg
parameter_list|(
name|s
parameter_list|)
value|(s->storage == INREG)
end_define

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * Some macros to make finding a symbol with certain attributes.  */
end_comment

begin_define
define|#
directive|define
name|find
parameter_list|(
name|s
parameter_list|,
name|withname
parameter_list|)
define|\
value|{ \     s = lookup(withname); \     while (s != nil and not (s->name == (withname) and
end_define

begin_define
define|#
directive|define
name|where
end_define

begin_comment
comment|/* qualification */
end_comment

begin_define
define|#
directive|define
name|endfind
parameter_list|(
name|s
parameter_list|)
value|)) { \ 	s = s->next_sym; \     } \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Symbol table structure currently does not support deletions.  * Hash table size is a power of two to make hashing faster.  * Using a non-prime is ok since we aren't doing rehashing.  */
end_comment

begin_define
define|#
directive|define
name|HASHTABLESIZE
value|8192
end_define

begin_decl_stmt
name|private
name|Symbol
name|hashtab
index|[
name|HASHTABLESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hash
parameter_list|(
name|name
parameter_list|)
value|((((unsigned) name)>> 2)& (HASHTABLESIZE - 1))
end_define

begin_comment
comment|/*  * Allocate a new symbol.  */
end_comment

begin_define
define|#
directive|define
name|SYMBLOCKSIZE
value|1000
end_define

begin_typedef
typedef|typedef
struct|struct
name|Sympool
block|{
name|struct
name|Symbol
name|sym
index|[
name|SYMBLOCKSIZE
index|]
decl_stmt|;
name|struct
name|Sympool
modifier|*
name|prevpool
decl_stmt|;
block|}
typedef|*
name|Sympool
typedef|;
end_typedef

begin_decl_stmt
name|private
name|Sympool
name|sympool
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Integer
name|nleft
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|Symbol
name|symbol_alloc
parameter_list|()
block|{
specifier|register
name|Sympool
name|newpool
decl_stmt|;
if|if
condition|(
name|nleft
operator|<=
literal|0
condition|)
block|{
name|newpool
operator|=
name|new
argument_list|(
name|Sympool
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|newpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newpool
argument_list|)
argument_list|)
expr_stmt|;
name|newpool
operator|->
name|prevpool
operator|=
name|sympool
expr_stmt|;
name|sympool
operator|=
name|newpool
expr_stmt|;
name|nleft
operator|=
name|SYMBLOCKSIZE
expr_stmt|;
block|}
operator|--
name|nleft
expr_stmt|;
return|return
operator|&
operator|(
name|sympool
operator|->
name|sym
index|[
name|nleft
index|]
operator|)
return|;
block|}
end_function

begin_function
name|public
name|symbol_dump
parameter_list|(
name|func
parameter_list|)
name|Symbol
name|func
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|integer
name|i
decl_stmt|;
name|printf
argument_list|(
literal|" symbols in %s \n"
argument_list|,
name|symname
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHTABLESIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
name|hashtab
index|[
name|i
index|]
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|next_sym
control|)
block|{
if|if
condition|(
name|s
operator|->
name|block
operator|==
name|func
condition|)
block|{
name|psym
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Free all the symbols currently allocated.  */
end_comment

begin_function
name|public
name|symbol_free
parameter_list|()
block|{
name|Sympool
name|s
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|Integer
name|i
decl_stmt|;
name|s
operator|=
name|sympool
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|nil
condition|)
block|{
name|t
operator|=
name|s
operator|->
name|prevpool
expr_stmt|;
name|dispose
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHTABLESIZE
condition|;
name|i
operator|++
control|)
block|{
name|hashtab
index|[
name|i
index|]
operator|=
name|nil
expr_stmt|;
block|}
name|sympool
operator|=
name|nil
expr_stmt|;
name|nleft
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new symbol with the given attributes.  */
end_comment

begin_function
name|public
name|Symbol
name|newSymbol
parameter_list|(
name|name
parameter_list|,
name|blevel
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|chain
parameter_list|)
name|Name
name|name
decl_stmt|;
name|Integer
name|blevel
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
name|Symbol
name|type
decl_stmt|;
name|Symbol
name|chain
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|primlang
expr_stmt|;
name|s
operator|->
name|storage
operator|=
name|EXT
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|blevel
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|s
operator|->
name|chain
operator|=
name|chain
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a symbol into the hash table.  */
end_comment

begin_function
name|public
name|Symbol
name|insert
parameter_list|(
name|name
parameter_list|)
name|Name
name|name
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|unsigned
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|next_sym
operator|=
name|hashtab
index|[
name|h
index|]
expr_stmt|;
name|hashtab
index|[
name|h
index|]
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Symbol lookup.  */
end_comment

begin_function
name|public
name|Symbol
name|lookup
parameter_list|(
name|name
parameter_list|)
name|Name
name|name
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|unsigned
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|hashtab
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|nil
name|and
name|s
operator|->
name|name
operator|!=
name|name
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|next_sym
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a symbol from the symbol table.  */
end_comment

begin_function
name|public
name|delete
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
specifier|register
name|unsigned
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|t
operator|=
name|hashtab
index|[
name|h
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"delete of non-symbol '%s'"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|s
condition|)
block|{
name|hashtab
index|[
name|h
index|]
operator|=
name|s
operator|->
name|next_sym
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|t
operator|->
name|next_sym
operator|!=
name|s
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|next_sym
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"delete of non-symbol '%s'"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|t
operator|->
name|next_sym
operator|=
name|s
operator|->
name|next_sym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump out all the variables associated with the given  * procedure, function, or program associated with the given stack frame.  *  * This is quite inefficient.  We traverse the entire symbol table  * each time we're called.  The assumption is that this routine  * won't be called frequently enough to merit improved performance.  */
end_comment

begin_function
name|public
name|dumpvars
parameter_list|(
name|f
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|f
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHTABLESIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
name|hashtab
index|[
name|i
index|]
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|next_sym
control|)
block|{
if|if
condition|(
name|container
argument_list|(
name|s
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|should_print
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printv
argument_list|(
name|s
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|dumpvars
argument_list|(
name|s
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Create a builtin type.  * Builtin types are circular in that btype->type->type = btype.  */
end_comment

begin_function
name|private
name|Symbol
name|maketype
parameter_list|(
name|name
parameter_list|,
name|lower
parameter_list|,
name|upper
parameter_list|)
name|String
name|name
decl_stmt|;
name|long
name|lower
decl_stmt|;
name|long
name|upper
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|Name
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|nil
condition|)
block|{
name|n
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|primlang
expr_stmt|;
name|s
operator|->
name|level
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|nil
expr_stmt|;
name|s
operator|->
name|chain
operator|=
name|nil
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|RANGE
argument_list|,
name|s
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
name|lower
expr_stmt|;
name|s
operator|->
name|type
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Create the builtin symbols.  */
end_comment

begin_function
name|public
name|symbols_init
parameter_list|()
block|{
name|Symbol
name|s
decl_stmt|;
name|t_boolean
operator|=
name|maketype
argument_list|(
literal|"$boolean"
argument_list|,
literal|0L
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|t_int
operator|=
name|maketype
argument_list|(
literal|"$integer"
argument_list|,
literal|0x80000000L
argument_list|,
literal|0x7fffffffL
argument_list|)
expr_stmt|;
name|t_char
operator|=
name|maketype
argument_list|(
literal|"$char"
argument_list|,
literal|0L
argument_list|,
literal|255L
argument_list|)
expr_stmt|;
name|t_real
operator|=
name|maketype
argument_list|(
literal|"$real"
argument_list|,
literal|8L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|t_nil
operator|=
name|maketype
argument_list|(
literal|"$nil"
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|t_addr
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
literal|"$address"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|t_addr
operator|->
name|language
operator|=
name|primlang
expr_stmt|;
name|t_addr
operator|->
name|level
operator|=
literal|0
expr_stmt|;
name|t_addr
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|t_addr
operator|->
name|type
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|1
argument_list|,
name|PTR
argument_list|,
name|t_int
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
literal|"true"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|CONST
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|t_boolean
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|->
name|nodetype
operator|=
name|t_boolean
expr_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
literal|"false"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|CONST
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|t_boolean
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|->
name|nodetype
operator|=
name|t_boolean
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reduce type to avoid worrying about type names.  */
end_comment

begin_function
name|public
name|Symbol
name|rtype
parameter_list|(
name|type
parameter_list|)
name|Symbol
name|type
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|VAR
name|or
name|t
operator|->
name|class
operator|==
name|CONST
name|or
name|t
operator|->
name|class
operator|==
name|FIELD
name|or
name|t
operator|->
name|class
operator|==
name|REF
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|TYPEREF
condition|)
block|{
name|resolveRef
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|t
operator|->
name|class
operator|==
name|TYPE
name|or
name|t
operator|->
name|class
operator|==
name|TAG
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|TYPEREF
condition|)
block|{
name|resolveRef
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*  * Find the end of a module name.  Return nil if there is none  * in the given string.  */
end_comment

begin_function
name|private
name|String
name|findModuleMark
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|boolean
name|done
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|r
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|r
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
operator|++
name|p
expr_stmt|;
block|}
block|}
do|while
condition|(
name|not
name|done
condition|)
do|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve a type reference by modifying to be the appropriate type.  *  * If the reference has a name, then it refers to an opaque type and  * the actual type is directly accessible.  Otherwise, we must use  * the type reference string, which is of the form "module:{module:}name".  */
end_comment

begin_function
name|public
name|resolveRef
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|Symbol
name|s
decl_stmt|,
name|m
decl_stmt|,
name|outer
decl_stmt|;
name|Name
name|n
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|name
operator|!=
name|nil
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|t
operator|->
name|symvalue
operator|.
name|typeref
expr_stmt|;
name|outer
operator|=
name|program
expr_stmt|;
name|p
operator|=
name|findModuleMark
argument_list|(
name|start
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|start
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|find
argument_list|(
argument|m
argument_list|,
argument|n
argument_list|)
name|where
name|m
operator|->
name|block
operator|==
name|outer
name|endfind
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|nil
condition|)
block|{
name|p
operator|=
name|nil
expr_stmt|;
name|outer
operator|=
name|nil
expr_stmt|;
name|s
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|outer
operator|=
name|m
expr_stmt|;
name|start
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|findModuleMark
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outer
operator|!=
name|nil
condition|)
block|{
name|n
operator|=
name|identname
argument_list|(
name|start
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|block
operator|==
name|outer
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|!=
name|nil
name|and
name|s
operator|->
name|type
operator|!=
name|nil
condition|)
block|{
name|t
operator|->
name|name
operator|=
name|s
operator|->
name|type
operator|->
name|name
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|s
operator|->
name|type
operator|->
name|class
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|s
operator|->
name|type
operator|->
name|type
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|s
operator|->
name|type
operator|->
name|chain
expr_stmt|;
name|t
operator|->
name|symvalue
operator|=
name|s
operator|->
name|type
operator|->
name|symvalue
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|s
operator|->
name|type
operator|->
name|block
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|integer
name|regnum
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|integer
name|r
decl_stmt|;
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|storage
operator|==
name|INREG
condition|)
block|{
name|r
operator|=
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|public
name|Symbol
name|container
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|block
return|;
block|}
end_function

begin_function
name|public
name|Node
name|constval
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|!=
name|CONST
condition|)
block|{
name|error
argument_list|(
literal|"[internal error: constval(non-CONST)]"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|->
name|symvalue
operator|.
name|constval
return|;
block|}
end_function

begin_comment
comment|/*  * Return the object address of the given symbol.  *  * There are the following possibilities:  *  *	globals		- just take offset  *	locals		- take offset from locals base  *	arguments	- take offset from argument base  *	register	- offset is register number  */
end_comment

begin_define
define|#
directive|define
name|isglobal
parameter_list|(
name|s
parameter_list|)
value|(s->storage == EXT)
end_define

begin_define
define|#
directive|define
name|islocaloff
parameter_list|(
name|s
parameter_list|)
value|(s->storage == STK and s->symvalue.offset< 0)
end_define

begin_define
define|#
directive|define
name|isparamoff
parameter_list|(
name|s
parameter_list|)
value|(s->storage == STK and s->symvalue.offset>= 0)
end_define

begin_function
name|public
name|Address
name|address
parameter_list|(
name|s
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
specifier|register
name|Frame
name|frp
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Symbol
name|cur
decl_stmt|;
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isactive
argument_list|(
name|s
operator|->
name|block
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not currently defined"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isglobal
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|frame
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|cur
operator|=
name|s
operator|->
name|block
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|nil
name|and
name|cur
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|cur
operator|=
name|cur
operator|->
name|block
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|==
name|nil
condition|)
block|{
name|frp
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|findframe
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"[internal error: unexpected nil frame for \"%s\"]"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|islocaloff
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|locals_base
argument_list|(
name|frp
argument_list|)
operator|+
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isparamoff
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|args_base
argument_list|(
name|frp
argument_list|)
operator|+
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isreg
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|savereg
argument_list|(
name|s
operator|->
name|symvalue
operator|.
name|offset
argument_list|,
name|frp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"address: bad symbol \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Define a symbol used to access register values.  */
end_comment

begin_function
name|public
name|defregname
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
name|Name
name|n
decl_stmt|;
name|integer
name|r
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|t_addr
operator|->
name|language
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|s
operator|->
name|storage
operator|=
name|INREG
expr_stmt|;
name|s
operator|->
name|level
operator|=
literal|3
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|t_addr
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resolve an "abstract" type reference.  *  * It is possible in C to define a pointer to a type, but never define  * the type in a particular source file.  Here we try to resolve  * the type definition.  This is problematic, it is possible to  * have multiple, different definitions for the same name type.  */
end_comment

begin_function
name|public
name|findtype
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|,
name|u
decl_stmt|,
name|prev
decl_stmt|;
name|u
operator|=
name|s
expr_stmt|;
name|prev
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|u
operator|!=
name|nil
name|and
name|u
operator|->
name|class
operator|!=
name|BADUSE
condition|)
block|{
if|if
condition|(
name|u
operator|->
name|name
operator|!=
name|nil
condition|)
block|{
name|prev
operator|=
name|u
expr_stmt|;
block|}
name|u
operator|=
name|u
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"couldn't find link to type reference"
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|lookup
argument_list|(
name|prev
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|nil
name|and
name|not
argument_list|(
argument|t != prev and t->name == prev->name and 	    t->block->class == MODULE and t->class == prev->class and 	    t->type != nil and t->type->type != nil and 	    t->type->type->class != BADUSE
argument_list|)
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|next_sym
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"couldn't resolve reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|type
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the size in bytes of the given type.  *  * This is probably the WRONG thing to do.  The size should be kept  * as an attribute in the symbol information as is done for structures  * and fields.  I haven't gotten around to cleaning this up yet.  */
end_comment

begin_define
define|#
directive|define
name|MAXUCHAR
value|255
end_define

begin_define
define|#
directive|define
name|MAXUSHORT
value|65535L
end_define

begin_define
define|#
directive|define
name|MINCHAR
value|-128
end_define

begin_define
define|#
directive|define
name|MAXCHAR
value|127
end_define

begin_define
define|#
directive|define
name|MINSHORT
value|-32768
end_define

begin_define
define|#
directive|define
name|MAXSHORT
value|32767
end_define

begin_function
name|public
name|findbounds
parameter_list|(
name|u
parameter_list|,
name|lower
parameter_list|,
name|upper
parameter_list|)
name|Symbol
name|u
decl_stmt|;
name|long
modifier|*
name|lower
decl_stmt|,
decl|*
name|upper
decl_stmt|;
end_function

begin_block
block|{
name|Rangetype
name|lbt
decl_stmt|,
name|ubt
decl_stmt|;
name|long
name|lb
decl_stmt|,
name|ub
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|class
operator|==
name|RANGE
condition|)
block|{
name|lbt
operator|=
name|u
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lowertype
expr_stmt|;
name|ubt
operator|=
name|u
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|uppertype
expr_stmt|;
name|lb
operator|=
name|u
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|ub
operator|=
name|u
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
if|if
condition|(
name|lbt
operator|==
name|R_ARG
name|or
name|lbt
operator|==
name|R_TEMP
condition|)
block|{
if|if
condition|(
name|not
name|getbound
argument_list|(
name|u
argument_list|,
name|lb
argument_list|,
name|lbt
argument_list|,
name|lower
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"dynamic bounds not currently available"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|lower
operator|=
name|lb
expr_stmt|;
block|}
if|if
condition|(
name|ubt
operator|==
name|R_ARG
name|or
name|ubt
operator|==
name|R_TEMP
condition|)
block|{
if|if
condition|(
name|not
name|getbound
argument_list|(
name|u
argument_list|,
name|ub
argument_list|,
name|ubt
argument_list|,
name|upper
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"dynamic bounds not currently available"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|upper
operator|=
name|ub
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|u
operator|->
name|class
operator|==
name|SCAL
condition|)
block|{
operator|*
name|lower
operator|=
literal|0
expr_stmt|;
operator|*
name|upper
operator|=
name|u
operator|->
name|symvalue
operator|.
name|iconval
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"[internal error: unexpected array bound type]"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|public
name|integer
name|size
parameter_list|(
name|sym
parameter_list|)
name|Symbol
name|sym
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
specifier|register
name|integer
name|nel
decl_stmt|,
name|elsize
decl_stmt|;
name|long
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|integer
name|r
decl_stmt|,
name|off
decl_stmt|,
name|len
decl_stmt|;
name|t
operator|=
name|sym
expr_stmt|;
name|checkref
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|TYPEREF
condition|)
block|{
name|resolveRef
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
name|lower
operator|=
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|upper
operator|=
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
if|if
condition|(
name|upper
operator|==
literal|0
name|and
name|lower
operator|>
literal|0
condition|)
block|{
comment|/* real */
name|r
operator|=
name|lower
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lower
operator|>
name|upper
condition|)
block|{
comment|/* unsigned long */
name|r
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lower
operator|>=
name|MINCHAR
name|and
name|upper
operator|<=
name|MAXCHAR
operator|)
name|or
argument_list|(
argument|lower>=
literal|0
argument|and upper<= MAXUCHAR
argument_list|)
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lower
operator|>=
name|MINSHORT
name|and
name|upper
operator|<=
name|MAXSHORT
operator|)
name|or
argument_list|(
argument|lower>=
literal|0
argument|and upper<= MAXUSHORT
argument_list|)
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY
case|:
name|elsize
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|nel
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|t
operator|->
name|chain
init|;
name|t
operator|!=
name|nil
condition|;
name|t
operator|=
name|t
operator|->
name|chain
control|)
block|{
name|u
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|findbounds
argument_list|(
name|u
argument_list|,
operator|&
name|lower
argument_list|,
operator|&
name|upper
argument_list|)
expr_stmt|;
name|nel
operator|*=
operator|(
name|upper
operator|-
name|lower
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|r
operator|=
name|nel
operator|*
name|elsize
expr_stmt|;
break|break;
case|case
name|OPENARRAY
case|:
case|case
name|DYNARRAY
case|:
name|r
operator|=
operator|(
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBARRAY
case|:
name|r
operator|=
operator|(
literal|2
operator|*
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|REF
case|:
case|case
name|VAR
case|:
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* 	     * 	    if (r< sizeof(Word) and isparam(t)) { 		r = sizeof(Word); 	    } 	    */
break|break;
case|case
name|FVAR
case|:
case|case
name|CONST
case|:
case|case
name|TAG
case|:
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE
case|:
comment|/* 	     * This causes problems on the IRIS because of the compiler bug 	     * with stab offsets for parameters.  Not sure it's really 	     * necessary anyway. 	     */
ifndef|#
directive|ifndef
name|IRIS
if|if
condition|(
name|t
operator|->
name|type
operator|->
name|class
operator|==
name|PTR
name|and
name|t
operator|->
name|type
operator|->
name|type
operator|->
name|class
operator|==
name|BADUSE
condition|)
block|{
name|findtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD
case|:
name|off
operator|=
name|t
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
expr_stmt|;
name|len
operator|=
name|t
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
expr_stmt|;
name|r
operator|=
operator|(
name|off
operator|+
name|len
operator|+
literal|7
operator|)
name|div
literal|8
operator|-
operator|(
name|off
name|div
literal|8
operator|)
expr_stmt|;
break|break;
case|case
name|RECORD
case|:
case|case
name|VARNT
case|:
name|r
operator|=
name|t
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
name|and
name|t
operator|->
name|chain
operator|!=
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"missing size information for record"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTR
case|:
case|case
name|TYPEREF
case|:
case|case
name|FILET
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCAL
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
comment|/* 	     * 	    if (t->symvalue.iconval> 255) { 		r = sizeof(short); 	    } else { 		r = sizeof(char); 	    } 	     * 	     */
break|break;
case|case
name|FPROC
case|:
case|case
name|FFUNC
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROC
case|:
case|case
name|FUNC
case|:
case|case
name|MODULE
case|:
case|case
name|PROG
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|u
operator|=
name|rtype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|u
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
name|r
operator|=
name|u
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|-
name|u
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|SCAL
case|:
name|r
operator|=
name|u
operator|->
name|symvalue
operator|.
name|iconval
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"expected range for set base type"
argument_list|)
expr_stmt|;
break|break;
block|}
name|r
operator|=
operator|(
name|r
operator|+
name|BITSPERBYTE
operator|-
literal|1
operator|)
name|div
name|BITSPERBYTE
expr_stmt|;
break|break;
comment|/* 	 * These can happen in C (unfortunately) for unresolved type references 	 * Assume they are pointers. 	 */
case|case
name|BADUSE
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Address
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ord
argument_list|(
name|t
operator|->
name|class
argument_list|)
operator|>
name|ord
argument_list|(
name|TYPEREF
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"size: bad class (%d)"
argument_list|,
name|ord
argument_list|(
name|t
operator|->
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't compute size of a %s\n"
argument_list|,
name|classname
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return the size associated with a symbol that takes into account  * reference parameters.  This might be better as the normal size function, but  * too many places already depend on it working the way it does.  */
end_comment

begin_function
name|public
name|integer
name|psize
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|integer
name|r
decl_stmt|;
name|Symbol
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|REF
condition|)
block|{
name|t
operator|=
name|rtype
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|OPENARRAY
condition|)
block|{
name|r
operator|=
operator|(
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|SUBARRAY
condition|)
block|{
name|r
operator|=
operator|(
literal|2
operator|*
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|r
operator|=
name|size
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a parameter.  This is true if there  * is a cycle from s->block to s via chain pointers.  */
end_comment

begin_function
name|public
name|Boolean
name|isparam
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|s
operator|->
name|block
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|nil
name|and
name|t
operator|!=
name|s
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
block|}
return|return
call|(
name|Boolean
call|)
argument_list|(
name|t
operator|!=
name|nil
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a type is an open array parameter type.  */
end_comment

begin_function
name|public
name|boolean
name|isopenarray
parameter_list|(
name|type
parameter_list|)
name|Symbol
name|type
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
call|(
name|boolean
call|)
argument_list|(
name|t
operator|->
name|class
operator|==
name|OPENARRAY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a var parameter, i.e. has class REF.  */
end_comment

begin_function
name|public
name|Boolean
name|isvarparam
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|s
operator|->
name|class
operator|==
name|REF
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a variable (actually any addressible quantity  * with do).  */
end_comment

begin_function
name|public
name|Boolean
name|isvariable
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
return|return
operator|(
name|Boolean
operator|)
operator|(
name|s
operator|->
name|class
operator|==
name|VAR
name|or
name|s
operator|->
name|class
operator|==
name|FVAR
name|or
name|s
operator|->
name|class
operator|==
name|REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a constant.  */
end_comment

begin_function
name|public
name|Boolean
name|isconst
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|s
operator|->
name|class
operator|==
name|CONST
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a module.  */
end_comment

begin_function
name|public
name|Boolean
name|ismodule
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|s
operator|->
name|class
operator|==
name|MODULE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark a procedure or function as internal, meaning that it is called  * with a different calling sequence.  */
end_comment

begin_function
name|public
name|markInternal
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|intern
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|public
name|boolean
name|isinternal
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|intern
return|;
block|}
end_function

begin_comment
comment|/*  * Decide if a field begins or ends on a bit rather than byte boundary.  */
end_comment

begin_function
name|public
name|Boolean
name|isbitfield
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
name|boolean
name|b
decl_stmt|;
specifier|register
name|integer
name|off
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|;
name|off
operator|=
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
expr_stmt|;
name|len
operator|=
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|off
name|mod
name|BITSPERBYTE
operator|)
operator|!=
literal|0
name|or
argument_list|(
argument|len mod BITSPERBYTE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|rtype
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|Boolean
operator|)
operator|(
operator|(
name|t
operator|->
name|class
operator|==
name|SCAL
name|and
name|len
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|BITSPERBYTE
operator|)
operator|)
name|or
name|len
operator|!=
operator|(
name|size
argument_list|(
name|t
argument_list|)
operator|*
name|BITSPERBYTE
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_function
name|private
name|boolean
name|primlang_typematch
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|Symbol
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
return|return
call|(
name|boolean
call|)
argument_list|(
operator|(
name|t1
operator|==
name|t2
operator|)
name|or
argument_list|(
argument|t1->class == RANGE and t2->class == RANGE and 	    t1->symvalue.rangev.lower == t2->symvalue.rangev.lower and 	    t1->symvalue.rangev.upper == t2->symvalue.rangev.upper
argument_list|)
name|or
argument_list|(
argument|t1->class == PTR and t2->class == RANGE and 	    t2->symvalue.rangev.upper>= t2->symvalue.rangev.lower
argument_list|)
name|or
argument_list|(
argument|t2->class == PTR and t1->class == RANGE and 	    t1->symvalue.rangev.upper>= t1->symvalue.rangev.lower
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if two types match.  * Equivalent names implies a match in any language.  *  * Special symbols must be handled with care.  */
end_comment

begin_function
name|public
name|Boolean
name|compatible
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|Symbol
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
name|Boolean
name|b
decl_stmt|;
name|Symbol
name|rt1
decl_stmt|,
name|rt2
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|nil
name|or
name|t2
operator|==
name|nil
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|procsym
condition|)
block|{
name|b
operator|=
name|isblock
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|procsym
condition|)
block|{
name|b
operator|=
name|isblock
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|->
name|language
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|t2
operator|->
name|language
operator|==
name|nil
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
name|b
operator|=
operator|(
name|boolean
operator|)
name|primlang_typematch
argument_list|(
name|rtype
argument_list|(
name|t1
argument_list|)
argument_list|,
name|rtype
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
call|(
name|boolean
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|t2
operator|->
name|language
argument_list|,
name|L_TYPEMATCH
argument_list|)
argument_list|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t1
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
if|if
condition|(
name|t2
operator|->
name|language
operator|==
name|primlang
name|or
name|t2
operator|->
name|language
operator|==
name|nil
condition|)
block|{
name|b
operator|=
name|primlang_typematch
argument_list|(
name|rtype
argument_list|(
name|t1
argument_list|)
argument_list|,
name|rtype
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
call|(
name|boolean
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|t2
operator|->
name|language
argument_list|,
name|L_TYPEMATCH
argument_list|)
argument_list|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|b
operator|=
call|(
name|boolean
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|t1
operator|->
name|language
argument_list|,
name|L_TYPEMATCH
argument_list|)
argument_list|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a type of the given name.  */
end_comment

begin_function
name|public
name|Boolean
name|istypename
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|Symbol
name|type
decl_stmt|;
name|String
name|name
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|Boolean
name|b
decl_stmt|;
name|t
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
operator|(
name|Boolean
operator|)
operator|(
name|t
operator|->
name|class
operator|==
name|TYPE
name|and
name|streq
argument_list|(
name|ident
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if a (value) parameter should actually be passed by address.  */
end_comment

begin_function
name|public
name|boolean
name|passaddr
parameter_list|(
name|p
parameter_list|,
name|exprtype
parameter_list|)
name|Symbol
name|p
decl_stmt|,
name|exprtype
decl_stmt|;
block|{
name|boolean
name|b
decl_stmt|;
name|Language
name|def
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|def
operator|=
name|findlanguage
argument_list|(
literal|".c"
argument_list|)
expr_stmt|;
name|b
operator|=
call|(
name|boolean
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|def
argument_list|,
name|L_PASSADDR
argument_list|)
argument_list|)
argument_list|(
name|p
argument_list|,
name|exprtype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|language
operator|==
name|nil
name|or
name|p
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopenarray
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
call|(
name|boolean
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|p
operator|->
name|language
argument_list|,
name|L_PASSADDR
argument_list|)
argument_list|)
argument_list|(
name|p
argument_list|,
name|exprtype
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Test if the name of a symbol is uniquely defined or not.  */
end_comment

begin_function
name|public
name|Boolean
name|isambiguous
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|find
argument_list|(
argument|t
argument_list|,
argument|s->name
argument_list|)
name|where
name|t
operator|!=
name|s
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|Boolean
call|)
argument_list|(
name|t
operator|!=
name|nil
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|char
modifier|*
name|Arglist
typedef|;
end_typedef

begin_define
define|#
directive|define
name|nextarg
parameter_list|(
name|type
parameter_list|)
value|((type *) (ap += sizeof(type)))[-1]
end_define

begin_function_decl
name|private
name|Symbol
name|mkstring
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine the type of a parse tree.  *  * Also make some symbol-dependent changes to the tree such as  * removing indirection for constant or register symbols.  */
end_comment

begin_function
name|public
name|assigntypes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Node
name|p
decl_stmt|;
block|{
specifier|register
name|Node
name|p1
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|O_SYM
case|:
name|p
operator|->
name|nodetype
operator|=
name|p
operator|->
name|value
operator|.
name|sym
expr_stmt|;
break|break;
case|case
name|O_LCON
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
break|break;
case|case
name|O_CCON
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_char
expr_stmt|;
break|break;
case|case
name|O_FCON
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
break|break;
case|case
name|O_SCON
case|:
name|p
operator|->
name|nodetype
operator|=
name|mkstring
argument_list|(
name|p
operator|->
name|value
operator|.
name|scon
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_INDIR
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
name|rtype
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|!=
name|PTR
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\" is not a pointer"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|p
operator|->
name|nodetype
operator|=
name|rtype
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|O_DOT
case|:
name|p
operator|->
name|nodetype
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
break|break;
case|case
name|O_RVAL
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|nodetype
operator|->
name|class
operator|==
name|PROC
name|or
name|p
operator|->
name|nodetype
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|p1
operator|->
name|op
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|sym
operator|=
name|p1
operator|->
name|value
operator|.
name|sym
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|nodetype
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|value
operator|.
name|sym
operator|->
name|class
operator|==
name|CONST
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|p1
operator|->
name|op
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|p1
operator|->
name|value
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|nodetype
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isreg
argument_list|(
name|p1
operator|->
name|value
operator|.
name|sym
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_SYM
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|sym
operator|=
name|p1
operator|->
name|value
operator|.
name|sym
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|O_INDIR
name|and
name|p1
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|s
operator|=
name|p1
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|isreg
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|p1
operator|->
name|op
operator|=
name|O_SYM
expr_stmt|;
name|dispose
argument_list|(
name|p1
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p1
operator|->
name|value
operator|.
name|sym
operator|=
name|s
expr_stmt|;
name|p1
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_COMMA
case|:
name|p
operator|->
name|nodetype
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|nodetype
expr_stmt|;
break|break;
case|case
name|O_CALLPROC
case|:
case|case
name|O_CALL
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|rtype
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|O_TYPERENAME
case|:
name|p
operator|->
name|nodetype
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|->
name|nodetype
expr_stmt|;
break|break;
case|case
name|O_ITOF
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
break|break;
case|case
name|O_NEG
case|:
name|s
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
name|not
name|compatible
argument_list|(
name|s
argument_list|,
name|t_int
argument_list|)
condition|)
block|{
if|if
condition|(
name|not
name|compatible
argument_list|(
name|s
argument_list|,
name|t_real
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\" is improper type"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|O_NEGF
expr_stmt|;
block|}
block|}
name|p
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
break|break;
case|case
name|O_ADD
case|:
case|case
name|O_SUB
case|:
case|case
name|O_MUL
case|:
name|binaryop
argument_list|(
name|p
argument_list|,
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LT
case|:
case|case
name|O_LE
case|:
case|case
name|O_GT
case|:
case|case
name|O_GE
case|:
case|case
name|O_EQ
case|:
case|case
name|O_NE
case|:
name|binaryop
argument_list|(
name|p
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_DIVF
case|:
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|)
argument_list|,
name|t_real
argument_list|,
name|O_ITOF
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|)
argument_list|,
name|t_real
argument_list|,
name|O_ITOF
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
break|break;
case|case
name|O_DIV
case|:
case|case
name|O_MOD
case|:
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|)
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|)
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
break|break;
case|case
name|O_AND
case|:
case|case
name|O_OR
case|:
name|chkboolean
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|chkboolean
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_boolean
expr_stmt|;
break|break;
case|case
name|O_QLINE
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|nodetype
operator|=
name|nil
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a binary arithmetic or relational operator.  * Convert from integer to real if necessary.  */
end_comment

begin_function
name|private
name|binaryop
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
name|Node
name|p
decl_stmt|;
name|Symbol
name|t
decl_stmt|;
block|{
name|Node
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|Boolean
name|t1real
decl_stmt|,
name|t2real
decl_stmt|;
name|Symbol
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|p2
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
name|t1
operator|=
name|rtype
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t2
operator|=
name|rtype
argument_list|(
name|p2
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t1real
operator|=
name|compatible
argument_list|(
name|t1
argument_list|,
name|t_real
argument_list|)
expr_stmt|;
name|t2real
operator|=
name|compatible
argument_list|(
name|t2
argument_list|,
name|t_real
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1real
name|or
name|t2real
condition|)
block|{
name|p
operator|->
name|op
operator|=
call|(
name|Operator
call|)
argument_list|(
name|ord
argument_list|(
name|p
operator|->
name|op
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|t1real
condition|)
block|{
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|=
name|build
argument_list|(
name|O_ITOF
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|t2real
condition|)
block|{
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|=
name|build
argument_list|(
name|O_ITOF
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|integer
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"operation not defined on \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
argument_list|(
name|p2
operator|->
name|nodetype
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|integer
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"operation not defined on \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|nil
condition|)
block|{
name|p
operator|->
name|nodetype
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert a tree to a type via a conversion operator;  * if this isn't possible generate an error.  */
end_comment

begin_function
name|private
name|convert
parameter_list|(
name|tp
parameter_list|,
name|typeto
parameter_list|,
name|op
parameter_list|)
name|Node
modifier|*
name|tp
decl_stmt|;
name|Symbol
name|typeto
decl_stmt|;
name|Operator
name|op
decl_stmt|;
block|{
name|Node
name|tree
decl_stmt|;
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
name|tree
operator|=
operator|*
name|tp
expr_stmt|;
name|s
operator|=
name|rtype
argument_list|(
name|tree
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|typeto
argument_list|)
expr_stmt|;
if|if
condition|(
name|compatible
argument_list|(
argument|t
argument_list|,
argument|t_real
argument_list|)
name|and
name|compatible
argument_list|(
name|s
argument_list|,
name|t_int
argument_list|)
condition|)
block|{
comment|/* we can convert int => floating but not the reverse */
name|tree
operator|=
name|build
argument_list|(
name|op
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|compatible
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": illegal type in operation"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|tree
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct a node for the dot operator.  *  * If the left operand is not a record, but rather a procedure  * or function, then we interpret the "." as referencing an  * "invisible" variable; i.e. a variable within a dynamically  * active block but not within the static scope of the current procedure.  */
end_comment

begin_function
name|public
name|Node
name|dot
parameter_list|(
name|record
parameter_list|,
name|fieldname
parameter_list|)
name|Node
name|record
decl_stmt|;
name|Name
name|fieldname
decl_stmt|;
block|{
specifier|register
name|Node
name|rec
decl_stmt|,
name|p
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
name|rec
operator|=
name|record
expr_stmt|;
if|if
condition|(
name|isblock
argument_list|(
name|rec
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|find
argument_list|(
argument|s
argument_list|,
argument|fieldname
argument_list|)
name|where
name|s
operator|->
name|block
operator|==
name|rec
operator|->
name|nodetype
name|and
name|s
operator|->
name|class
operator|!=
name|FIELD
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" is not defined in "
argument_list|,
name|ident
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stderr
argument_list|,
name|rec
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|new
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_SYM
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|sym
operator|=
name|s
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|rec
expr_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|PTR
condition|)
block|{
name|s
operator|=
name|findfield
argument_list|(
name|fieldname
argument_list|,
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|findfield
argument_list|(
name|fieldname
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" is not a field in "
argument_list|,
name|ident
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|rec
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|class
operator|!=
name|PTR
name|or
name|isreg
argument_list|(
name|rec
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|p
operator|=
name|unrval
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|nodetype
operator|=
name|t_addr
expr_stmt|;
name|p
operator|=
name|build
argument_list|(
name|O_DOT
argument_list|,
name|p
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|build
argument_list|(
name|O_RVAL
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a tree corresponding to an array reference and do the  * error checking.  */
end_comment

begin_function
name|public
name|Node
name|subscript
parameter_list|(
name|a
parameter_list|,
name|slist
parameter_list|)
name|Node
name|a
decl_stmt|,
name|slist
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|Node
name|p
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|a
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|language
operator|==
name|nil
name|or
name|t
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
name|p
operator|=
call|(
name|Node
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
argument_list|,
name|L_BUILDAREF
argument_list|)
argument_list|)
argument_list|(
name|a
argument_list|,
name|slist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
call|(
name|Node
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|t
operator|->
name|language
argument_list|,
name|L_BUILDAREF
argument_list|)
argument_list|)
argument_list|(
name|a
argument_list|,
name|slist
argument_list|)
expr_stmt|;
block|}
return|return
name|build
argument_list|(
name|O_RVAL
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a subscript index.  */
end_comment

begin_function
name|public
name|int
name|evalindex
parameter_list|(
name|s
parameter_list|,
name|base
parameter_list|,
name|i
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|Address
name|base
decl_stmt|;
name|long
name|i
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|int
name|r
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|language
operator|==
name|nil
name|or
name|t
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
name|r
operator|=
operator|(
operator|(
operator|*
name|language_op
argument_list|(
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
argument_list|,
name|L_EVALAREF
argument_list|)
operator|)
operator|(
name|s
operator|,
name|base
operator|,
name|i
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
operator|(
operator|(
operator|*
name|language_op
argument_list|(
name|t
operator|->
name|language
argument_list|,
name|L_EVALAREF
argument_list|)
operator|)
operator|(
name|s
operator|,
name|base
operator|,
name|i
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a tree is boolean-valued, if not it's an error.  */
end_comment

begin_function
name|public
name|chkboolean
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Node
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|nodetype
operator|!=
name|t_boolean
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", expected boolean expression"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct a node for the type of a string.  */
end_comment

begin_function
name|private
name|Symbol
name|mkstring
parameter_list|(
name|str
parameter_list|)
name|String
name|str
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|ARRAY
argument_list|,
name|t_char
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|chain
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|RANGE
argument_list|,
name|t_int
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|chain
operator|->
name|language
operator|=
name|s
operator|->
name|language
expr_stmt|;
name|s
operator|->
name|chain
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|chain
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the space allocated for a string type.  */
end_comment

begin_function
name|public
name|unmkstring
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|dispose
argument_list|(
name|s
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out the "current" variable or function being referred to  * by the name n.  */
end_comment

begin_decl_stmt
name|private
name|boolean
name|stwhich
argument_list|()
decl_stmt|,
name|dynwhich
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|Symbol
name|which
parameter_list|(
name|n
parameter_list|)
name|Name
name|n
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|lookup
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not defined"
argument_list|,
name|ident
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|stwhich
argument_list|(
argument|&s
argument_list|)
name|and
name|isambiguous
argument_list|(
argument|s
argument_list|)
name|and
name|not
name|dynwhich
argument_list|(
operator|&
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[using "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Static search.  */
end_comment

begin_function
name|private
name|boolean
name|stwhich
parameter_list|(
name|var_s
parameter_list|)
name|Symbol
modifier|*
name|var_s
decl_stmt|;
block|{
name|Name
name|n
decl_stmt|;
comment|/* name of desired symbol */
name|Symbol
name|s
decl_stmt|;
comment|/* iteration variable for symbols with name n */
name|Symbol
name|f
decl_stmt|;
comment|/* iteration variable for blocks containing s */
name|integer
name|count
decl_stmt|;
comment|/* number of levels from s->block to curfunc */
name|Symbol
name|t
decl_stmt|;
comment|/* current best answer for stwhich(n) */
name|integer
name|mincount
decl_stmt|;
comment|/* relative level for current best answer (t) */
name|boolean
name|b
decl_stmt|;
comment|/* return value, true if symbol found */
name|s
operator|=
operator|*
name|var_s
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|name
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
name|mincount
operator|=
literal|10000
expr_stmt|;
comment|/* force first match to set mincount */
do|do
block|{
if|if
condition|(
name|s
operator|->
name|name
operator|==
name|n
name|and
name|s
operator|->
name|class
operator|!=
name|FIELD
name|and
name|s
operator|->
name|class
operator|!=
name|TAG
condition|)
block|{
name|f
operator|=
name|curfunc
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|nil
name|and
name|f
operator|!=
name|s
operator|->
name|block
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|block
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|nil
name|and
name|count
operator|<
name|mincount
condition|)
block|{
name|t
operator|=
name|s
expr_stmt|;
name|mincount
operator|=
name|count
expr_stmt|;
name|b
operator|=
name|true
expr_stmt|;
block|}
block|}
name|s
operator|=
name|s
operator|->
name|next_sym
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|nil
condition|)
do|;
if|if
condition|(
name|mincount
operator|!=
literal|10000
condition|)
block|{
operator|*
name|var_s
operator|=
name|t
expr_stmt|;
name|b
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Dynamic search.  */
end_comment

begin_function
name|private
name|boolean
name|dynwhich
parameter_list|(
name|var_s
parameter_list|)
name|Symbol
modifier|*
name|var_s
decl_stmt|;
block|{
name|Name
name|n
decl_stmt|;
comment|/* name of desired symbol */
name|Symbol
name|s
decl_stmt|;
comment|/* iteration variable for possible symbols */
name|Symbol
name|f
decl_stmt|;
comment|/* iteration variable for active functions */
name|Frame
name|frp
decl_stmt|;
comment|/* frame associated with stack walk */
name|boolean
name|b
decl_stmt|;
comment|/* return value */
name|f
operator|=
name|curfunc
expr_stmt|;
name|frp
operator|=
name|curfuncframe
argument_list|()
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|var_s
operator|)
operator|->
name|name
expr_stmt|;
name|b
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|frp
operator|!=
name|nil
condition|)
block|{
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|frp
operator|!=
name|nil
condition|)
block|{
name|s
operator|=
operator|*
name|var_s
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|nil
name|and
argument_list|(
argument|s->name != n or s->block != f or 		    s->class == FIELD or s->class == TAG
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|next_sym
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|nil
condition|)
block|{
operator|*
name|var_s
operator|=
name|s
expr_stmt|;
name|b
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|f
operator|==
name|program
condition|)
block|{
break|break;
block|}
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Find the symbol that has the same name and scope as the  * given symbol but is of the given field.  Return nil if there is none.  */
end_comment

begin_function
name|public
name|Symbol
name|findfield
parameter_list|(
name|fieldname
parameter_list|,
name|record
parameter_list|)
name|Name
name|fieldname
decl_stmt|;
name|Symbol
name|record
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|record
argument_list|)
operator|->
name|chain
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|nil
name|and
name|t
operator|->
name|name
operator|!=
name|fieldname
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|public
name|Boolean
name|getbound
parameter_list|(
name|s
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|,
name|valp
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|int
name|off
decl_stmt|;
name|Rangetype
name|type
decl_stmt|;
name|int
modifier|*
name|valp
decl_stmt|;
block|{
name|Frame
name|frp
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Symbol
name|cur
decl_stmt|;
if|if
condition|(
name|not
name|isactive
argument_list|(
name|s
operator|->
name|block
argument_list|)
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
name|cur
operator|=
name|s
operator|->
name|block
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|nil
name|and
name|cur
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
comment|/* WHY*/
name|cur
operator|=
name|cur
operator|->
name|block
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|==
name|nil
condition|)
block|{
name|cur
operator|=
name|whatblock
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|frp
operator|=
name|findframe
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|R_TEMP
condition|)
name|addr
operator|=
name|locals_base
argument_list|(
name|frp
argument_list|)
operator|+
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|R_ARG
condition|)
name|addr
operator|=
name|args_base
argument_list|(
name|frp
argument_list|)
operator|+
name|off
expr_stmt|;
else|else
return|return
operator|(
name|false
operator|)
return|;
name|dread
argument_list|(
name|valp
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

end_unit

