begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)setup.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - routines to read a.out and core files at startup  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<machine/machparam.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|exec
name|filhdr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* NB. the following works only with letter (alpha) variables */
end_comment

begin_define
define|#
directive|define
name|setavar
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
value|(var[(name) - 'a' + 10] = (value))
end_define

begin_macro
name|setsym
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|int
name|strsize
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|off_t
name|loc
decl_stmt|,
name|dbase
decl_stmt|;
name|txtmap
operator|.
name|ufd
operator|=
name|symfile
operator|.
name|fd
operator|=
name|getfile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|symfile
operator|.
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
operator|||
name|N_BADMAG
argument_list|(
name|filhdr
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|)
expr_stmt|;
name|txtmap
operator|.
name|m1
operator|.
name|e
operator|=
operator|-
operator|(
name|addr_t
operator|)
literal|1
expr_stmt|;
return|return;
block|}
name|loc
operator|=
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
expr_stmt|;
name|txtmap
operator|.
name|m1
operator|.
name|f
operator|=
name|txtmap
operator|.
name|m2
operator|.
name|f
operator|=
name|N_TXTOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|filhdr
operator|.
name|a_magic
condition|)
block|{
case|case
name|OMAGIC
case|:
comment|/* text map 1 is empty; map 2 goes from 0 to loc */
name|txtmap
operator|.
name|m2
operator|.
name|b
operator|=
name|dbase
operator|=
literal|0
expr_stmt|;
name|txtmap
operator|.
name|m2
operator|.
name|e
operator|=
name|loc
expr_stmt|;
break|break;
case|case
name|ZMAGIC
case|:
case|case
name|NMAGIC
case|:
comment|/* text map 1 maps text segment, map 2 maps data */
name|txtmap
operator|.
name|m1
operator|.
name|e
operator|=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|txtmap
operator|.
name|m2
operator|.
name|b
operator|=
name|dbase
operator|=
name|roundup
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|CLBYTES
argument_list|)
expr_stmt|;
name|txtmap
operator|.
name|m2
operator|.
name|e
operator|=
name|dbase
operator|+
name|filhdr
operator|.
name|a_data
expr_stmt|;
name|txtmap
operator|.
name|m2
operator|.
name|f
operator|+=
name|txtmap
operator|.
name|m1
operator|.
name|e
expr_stmt|;
break|break;
block|}
comment|/* save data segment base in variable b */
name|setavar
argument_list|(
literal|'b'
argument_list|,
name|dbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_syms
operator|!=
literal|0
condition|)
block|{
name|loc
operator|=
name|N_SYMOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
goto|goto
name|nospace
goto|;
name|esymtab
operator|=
operator|&
name|symtab
index|[
name|filhdr
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|symfile
operator|.
name|fd
argument_list|,
name|loc
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
define|#
directive|define
name|rd
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|if (read(symfile.fd, (char *)(a), (int)(n)) != (n)) \ 		goto readerr
name|rd
argument_list|(
name|symtab
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|rd
argument_list|(
operator|&
name|strsize
argument_list|,
sizeof|sizeof
argument_list|(
name|strsize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * offsets in the string table are relative to the offset 		 * of the number we just read; we adjust for it here. 		 */
name|strsize
operator|-=
sizeof|sizeof
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strtab
operator|=
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|strsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nospace
goto|;
name|rd
argument_list|(
name|strtab
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|esymtab
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|n_un
operator|.
name|n_strx
operator|==
literal|0
condition|)
continue|continue;
name|sp
operator|->
name|n_un
operator|.
name|n_strx
operator|-=
sizeof|sizeof
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|sp
operator|->
name|n_un
operator|.
name|n_strx
operator|>=
name|strsize
condition|)
block|{
name|adbprintf
argument_list|(
literal|"bad string index %D in symtab\n"
argument_list|,
operator|(
name|expr_t
operator|)
name|sp
operator|->
name|n_un
operator|.
name|n_strx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|strtab
operator|+
name|sp
operator|->
name|n_un
operator|.
name|n_strx
expr_stmt|;
block|}
undef|#
directive|undef
name|rd
block|}
if|if
condition|(
name|INKERNEL
argument_list|(
name|filhdr
operator|.
name|a_entry
argument_list|)
condition|)
block|{
name|txtmap
operator|.
name|m1
operator|.
name|b
operator|+=
name|KERNTEXTOFF
expr_stmt|;
name|txtmap
operator|.
name|m1
operator|.
name|e
operator|+=
name|KERNTEXTOFF
expr_stmt|;
name|txtmap
operator|.
name|m2
operator|.
name|b
operator|+=
name|KERNTEXTOFF
expr_stmt|;
name|txtmap
operator|.
name|m2
operator|.
name|e
operator|+=
name|KERNTEXTOFF
expr_stmt|;
block|}
return|return;
name|readerr
label|:
name|prints
argument_list|(
literal|"Error reading symbol|string table (old format a.out?)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|nospace
label|:
name|prints
argument_list|(
literal|"Not enough space for symbol|string table\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_macro
name|setcore
argument_list|()
end_macro

begin_block
block|{
name|off_t
name|stacksize
decl_stmt|;
name|datmap
operator|.
name|m1
operator|.
name|e
operator|=
operator|-
operator|(
name|addr_t
operator|)
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|datmap
operator|.
name|ufd
operator|=
name|corefile
operator|.
name|fd
operator|=
name|getfile
argument_list|(
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|kernel
operator|&&
name|INKERNEL
argument_list|(
name|filhdr
operator|.
name|a_entry
argument_list|)
operator|&&
name|getkcore
argument_list|()
condition|)
block|{
name|kcore
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|read
argument_list|(
name|corefile
operator|.
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
operator|!=
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|||
operator|!
name|udot
argument_list|()
condition|)
block|{
name|adbprintf
argument_list|(
literal|"not core file = %s\n"
argument_list|,
name|corefile
operator|.
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|signo
operator|=
name|u
operator|.
name|u_sig
expr_stmt|;
name|sigcode
operator|=
name|u
operator|.
name|u_code
expr_stmt|;
name|filhdr
operator|.
name|a_text
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_tsize
argument_list|)
expr_stmt|;
name|filhdr
operator|.
name|a_data
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_dsize
argument_list|)
expr_stmt|;
name|stacksize
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_ssize
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|filhdr
operator|.
name|a_magic
condition|)
block|{
case|case
name|OMAGIC
case|:
name|datmap
operator|.
name|m1
operator|.
name|b
operator|=
literal|0
expr_stmt|;
name|datmap
operator|.
name|m1
operator|.
name|e
operator|=
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
expr_stmt|;
name|datmap
operator|.
name|m2
operator|.
name|f
operator|=
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|+
name|datmap
operator|.
name|m1
operator|.
name|e
expr_stmt|;
break|break;
case|case
name|NMAGIC
case|:
case|case
name|ZMAGIC
case|:
name|datmap
operator|.
name|m1
operator|.
name|b
operator|=
name|roundup
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|CLBYTES
argument_list|)
expr_stmt|;
name|datmap
operator|.
name|m1
operator|.
name|e
operator|=
name|datmap
operator|.
name|m1
operator|.
name|b
operator|+
name|filhdr
operator|.
name|a_data
expr_stmt|;
name|datmap
operator|.
name|m2
operator|.
name|f
operator|=
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|+
name|filhdr
operator|.
name|a_data
expr_stmt|;
break|break;
block|}
comment|/* save (possibly new) data segment base, and save stack size */
name|setavar
argument_list|(
literal|'b'
argument_list|,
name|datmap
operator|.
name|m1
operator|.
name|b
argument_list|)
expr_stmt|;
name|setavar
argument_list|(
literal|'s'
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|datmap
operator|.
name|m1
operator|.
name|f
operator|=
name|ctob
argument_list|(
name|UPAGES
argument_list|)
expr_stmt|;
name|datmap
operator|.
name|m2
operator|.
name|b
operator|=
name|KERNBASE
operator|-
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|-
name|stacksize
expr_stmt|;
name|datmap
operator|.
name|m2
operator|.
name|e
operator|=
name|KERNBASE
operator|-
name|ctob
argument_list|(
name|UPAGES
argument_list|)
expr_stmt|;
name|ret
label|:
name|u
operator|.
name|u_ar0
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|)
expr_stmt|;
comment|/* XXX */
name|setavar
argument_list|(
literal|'d'
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|setavar
argument_list|(
literal|'e'
argument_list|,
name|filhdr
operator|.
name|a_entry
argument_list|)
expr_stmt|;
name|setavar
argument_list|(
literal|'m'
argument_list|,
name|filhdr
operator|.
name|a_magic
argument_list|)
expr_stmt|;
name|setavar
argument_list|(
literal|'t'
argument_list|,
name|filhdr
operator|.
name|a_text
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

