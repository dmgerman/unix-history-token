begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)expr.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - expression parser  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|BADSYM
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "symbol not found" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|BADVAR
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "bad variable" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|BADSYN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "syntax error" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|NOCFN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "c routine not found" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|NOADR
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "address expected" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|BADLOC
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "automatic variable not found" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|NOPCS
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "no process" */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|xxxsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last symbol found due to expression */
end_comment

begin_comment
comment|/* change this name back to cursym AFTER testing!... */
end_comment

begin_decl_stmt
name|struct
name|activation
name|curframe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current stack frame (for local vars) */
end_comment

begin_comment
comment|/*   * This file implements a small recursive descent expression parser.  * The syntax is (in YACC terms):  *  *	expr	: expr1  *		|		(empty)  *		;  *  *	expr1	: term  *		| term dyadic expr1  *		;  *  *	dyadic	: '+'		(addition)  *		| '-'		(subtraction)  *		| '#'		(roundup)  *		| '*'		(multiplication)  *		| '%'		(division)  *		| '&'		(bitwise and)  *		| '|'		(bitwise or)  *		;  *  *	term	: item  *		| monadic term  *		| '(' expr ')'  *		;  *  *	monadic	: '*'		(contents of core, or SP_DATA)  *		| '@'		(contents of a.out, or SP_INSTR)  *		| '-'		(negation)  *		| '~'		(bitwise not)  *		| '#'		(logical not)  *		;  *  *	item	: number	(current radix; 0o,0t,0x; or float)  *		| name		(value from symbol table)  *		| rtn '.' name	(address of name in routine rtn)  *		| rtn '.'	(???)  *		| '.' name	(???)  *		| '.'		(value of dot)  *		| '+'		(dot + current increment)  *		| '^'		(dot - current increment)  *		| '"'		(last address typed)  *		| '<' var	(value of variable var)  *		| '<' register	(value in register)  *		| '\'' ch '\''	(character(s))  *		;  *  * The empty string handling is actually done in `item', but callers  * can simply assume that expr() returns 1 if it finds an expression,  * or 0 if not, and that rexpr() errors out if there is no expression.  *  * The routines symchar() and getsym() handle `name's and `rtn's.  * The routine getnum(), with helper getfloat(), handles `number's.  */
end_comment

begin_comment
comment|/* flags for symchar() */
end_comment

begin_define
define|#
directive|define
name|SYMCH_READ
value|1
end_define

begin_comment
comment|/* call readchar() first */
end_comment

begin_define
define|#
directive|define
name|SYMCH_DIGITS
value|2
end_define

begin_comment
comment|/* allow digits */
end_comment

begin_comment
comment|/*  * Return true if the next (how& SYMCH_READ) or current character  * is a symbol character; allow digits if (how& SYMCH_DIGITS).  */
end_comment

begin_function
specifier|static
name|int
name|symchar
parameter_list|(
name|how
parameter_list|)
name|int
name|how
decl_stmt|;
block|{
if|if
condition|(
name|how
operator|&
name|SYMCH_READ
condition|)
operator|(
name|void
operator|)
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastc
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|readchar
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|lastc
argument_list|)
operator|||
name|lastc
operator|==
literal|'_'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|how
operator|&
name|SYMCH_DIGITS
operator|)
operator|&&
name|isdigit
argument_list|(
name|lastc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a symbol into the given buffer.  The first character is  * assumed already to have been read.  */
end_comment

begin_expr_stmt
specifier|static
name|getsym
argument_list|(
name|symbuf
argument_list|,
name|symlen
argument_list|)
specifier|register
name|char
operator|*
name|symbuf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|symlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
do|do
block|{
if|if
condition|(
operator|--
name|symlen
operator|>
literal|0
condition|)
operator|*
name|symbuf
operator|++
operator|=
name|lastc
expr_stmt|;
block|}
do|while
condition|(
name|symchar
argument_list|(
name|SYMCH_READ
operator||
name|SYMCH_DIGITS
argument_list|)
condition|)
do|;
operator|*
name|symbuf
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read a number.  The converted value is stored in expv.  * The caller has already determined that there is at least one digit.  */
end_comment

begin_expr_stmt
specifier|static
name|getnum
argument_list|()
block|{
specifier|register
name|int
name|base
block|,
name|c
block|;
name|expv
operator|=
literal|0
block|;
if|if
condition|(
operator|(
name|base
operator|=
name|radix
operator|)
operator|<
literal|0
condition|)
name|base
operator|=
operator|-
name|base
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lastc
operator|==
literal|'0'
condition|)
block|{
switch|switch
condition|(
name|readchar
argument_list|()
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|base
operator|=
literal|16
expr_stmt|;
operator|(
name|void
operator|)
name|readchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|base
operator|=
literal|10
expr_stmt|;
operator|(
name|void
operator|)
name|readchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|base
operator|=
literal|8
expr_stmt|;
operator|(
name|void
operator|)
name|readchar
argument_list|()
expr_stmt|;
block|}
block|}
end_if

begin_for
for|for
control|(
name|c
operator|=
name|lastc
init|;
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|readchar
argument_list|()
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
break|break;
else|else
name|c
operator|-=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|10
else|:
literal|'a'
operator|-
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
name|error
argument_list|(
name|BADSYN
argument_list|)
expr_stmt|;
comment|/* since expv is unsigned, the following cannot overflow */
name|expv
operator|=
name|expv
operator|*
name|base
operator|+
name|c
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|lastc
operator|==
literal|'.'
operator|&&
operator|(
name|base
operator|==
literal|10
operator|||
name|expv
operator|==
literal|0
operator|)
condition|)
name|getfloat
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|unreadc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Read a float.  The integer part is already in expv.  Set expv  * to the integer bit pattern that corresponds to the float.  *  * The following routine could be improved, but at least it will  * not crash on input such as 0.999999999999999999999999999999,  * as did the original.  */
end_comment

begin_expr_stmt
unit|getfloat
operator|(
operator|)
block|{
specifier|register
name|int
name|i
block|;
specifier|register
name|char
operator|*
name|p
block|;
comment|/* THE FOLLOWING ASSUMES sizeof(float)==sizeof(expr_t) */
comment|/* PERHAPS THIS SHOULD BE MOVED TO MACHINE DEPENDENT CODE */
expr|union
block|{
name|float
name|r
block|;
name|expr_t
name|e
block|; 	}
name|gross
block|;
comment|/* end machine dependent */
name|char
name|hackbuf
index|[
literal|50
index|]
block|;
name|double
name|atof
argument_list|()
block|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|hackbuf
argument_list|)
operator|,
name|p
operator|=
name|hackbuf
init|;
name|isdigit
argument_list|(
name|readchar
argument_list|()
argument_list|)
condition|;
control|)
if|if
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|lastc
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gross
operator|.
name|r
operator|=
name|expv
operator|+
name|atof
argument_list|(
name|hackbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|expv
operator|=
name|gross
operator|.
name|e
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * item : number | name [ '.' local ] | '.' local | '.' | '+' | '^' | '"' |  *	  '<' var | '<' register | '\'' char(s) '\'' ;  *  * item returns 1 if it finds an item, or 0 if it resolves to  * the empty string.  */
end_comment

begin_function
unit|static
name|int
name|item
parameter_list|(
name|allownil
parameter_list|)
name|int
name|allownil
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|reglist
modifier|*
name|reg
decl_stmt|;
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|getnum
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|symchar
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|ev_name
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|symchar
argument_list|(
name|SYMCH_READ
argument_list|)
condition|)
name|ev_local
argument_list|()
expr_stmt|;
comment|/* SHOULD RESET xxxsym FIRST? */
else|else
name|expv
operator|=
name|dot
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'"'
case|:
name|expv
operator|=
name|ditto
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'+'
case|:
name|expv
operator|=
name|inkdot
argument_list|(
name|dotinc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'^'
case|:
name|expv
operator|=
name|inkdot
argument_list|(
operator|-
name|dotinc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'<'
case|:
if|if
condition|(
operator|(
name|reg
operator|=
name|reglookup
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|expv
operator|=
name|getreg
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|varlookup
argument_list|(
name|rdc
argument_list|()
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|expv
operator|=
name|var
index|[
name|i
index|]
expr_stmt|;
else|else
name|error
argument_list|(
name|BADVAR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'\''
case|:
name|i
operator|=
sizeof|sizeof
argument_list|(
name|expr_t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
for|for
control|(
name|expv
operator|=
literal|0
init|;
condition|;
name|expv
operator|=
operator|(
name|expv
operator|<<
name|NBBY
operator|)
operator||
name|c
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|()
operator|)
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|()
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
break|break;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
name|BADSYN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|allownil
condition|)
name|error
argument_list|(
name|NOADR
argument_list|)
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term : item | monadic_op term | '(' expr ')' ;  */
end_comment

begin_macro
name|term
argument_list|(
argument|allownil
argument_list|)
end_macro

begin_decl_stmt
name|int
name|allownil
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|readchar
argument_list|()
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'@'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|adbread
argument_list|(
name|lastc
operator|==
literal|'@'
condition|?
name|SP_INSTR
else|:
name|SP_DATA
argument_list|,
operator|(
name|addr_t
operator|)
name|expv
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|expv
argument_list|,
sizeof|sizeof
argument_list|(
name|expv
argument_list|)
argument_list|)
expr_stmt|;
name|checkerr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'-'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|=
operator|-
name|expv
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'~'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|=
operator|~
name|expv
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'#'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|=
operator|!
name|expv
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'('
case|:
operator|(
name|void
operator|)
name|iexpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readchar
argument_list|()
operator|!=
literal|')'
condition|)
name|error
argument_list|(
name|BADSYN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|unreadc
argument_list|()
expr_stmt|;
return|return
operator|(
name|item
argument_list|(
name|allownil
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * expr : term | term dyadic expr | ;  * (internal version, which passes on the allow-nil flag)  */
end_comment

begin_function
specifier|static
name|int
name|iexpr
parameter_list|(
name|allownil
parameter_list|)
name|int
name|allownil
decl_stmt|;
block|{
specifier|register
name|expr_t
name|lhs
decl_stmt|,
name|t
decl_stmt|;
operator|(
name|void
operator|)
name|rdc
argument_list|()
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|term
argument_list|(
name|allownil
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|lhs
operator|=
name|expv
expr_stmt|;
switch|switch
condition|(
name|readchar
argument_list|()
condition|)
block|{
case|case
literal|'+'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|+=
name|lhs
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|=
name|lhs
operator|-
name|expv
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expv
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"# by 0"
argument_list|)
expr_stmt|;
comment|/* roundup(lhs, expv), but careful about overflow */
name|t
operator|=
name|lhs
operator|/
name|expv
expr_stmt|;
name|t
operator|*=
name|expv
expr_stmt|;
name|expv
operator|=
name|t
operator|==
name|lhs
condition|?
name|t
else|:
name|t
operator|+
name|expv
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|*=
name|lhs
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|=
name|lhs
operator|/
name|expv
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator|&=
name|lhs
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
operator|(
name|void
operator|)
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expv
operator||=
name|lhs
expr_stmt|;
break|break;
default|default:
name|unreadc
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|oexpr
parameter_list|()
block|{
return|return
operator|(
name|iexpr
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|expr_t
name|rexpr
parameter_list|()
block|{
operator|(
name|void
operator|)
name|iexpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|expv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a name, or a name '.' localname.  */
end_comment

begin_expr_stmt
specifier|static
name|ev_name
argument_list|()
block|{ 	struct
name|nlist
operator|*
name|symp
block|;
name|char
name|symbuf
index|[
name|SYMLEN
index|]
block|;
comment|/* name [ . localname ] */
name|getsym
argument_list|(
name|symbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
argument_list|)
block|;
if|if
condition|(
name|lastc
operator|==
literal|'.'
condition|)
comment|/* name . local */
name|find_frame
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|symp
operator|=
name|lookup
argument_list|(
name|symbuf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|expv
operator|=
operator|(
name|xxxsym
operator|=
name|symp
operator|)
operator|->
name|n_value
expr_stmt|;
else|else
name|error
argument_list|(
name|BADSYM
argument_list|)
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Backtrack through the call stack to find the symbol in symbuf.  * Save the result, and if there is another name, look for it within  * that frame.  Otherwise the value of the expression is the address  * of the found frame.  */
end_comment

begin_macro
unit|static
name|find_frame
argument_list|(
argument|symbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|symbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|activation
name|a
decl_stmt|;
name|addr_t
name|dummy
decl_stmt|;
comment|/* for findsym() to scribble on */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|error
argument_list|(
name|NOPCS
argument_list|)
expr_stmt|;
for|for
control|(
name|a_init
argument_list|(
operator|&
name|a
argument_list|)
init|;
name|a
operator|.
name|a_valid
condition|;
name|a_back
argument_list|(
operator|&
name|a
argument_list|)
control|)
block|{
name|checkerr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|xxxsym
operator|=
name|findsym
argument_list|(
name|a
operator|.
name|a_pc
argument_list|,
name|SP_INSTR
argument_list|,
operator|&
name|dummy
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|eqsym
argument_list|(
name|xxxsym
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|symbuf
argument_list|,
literal|'_'
argument_list|)
condition|)
block|{
name|curframe
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|symchar
argument_list|(
name|SYMCH_READ
argument_list|)
condition|)
name|ev_local
argument_list|()
expr_stmt|;
else|else
name|expv
operator|=
name|a
operator|.
name|a_fp
expr_stmt|;
return|return;
block|}
block|}
name|error
argument_list|(
name|NOCFN
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * Linear search (ugh) for a symbol in the current stack frame.  */
end_comment

begin_expr_stmt
specifier|static
name|ev_local
argument_list|()
block|{
specifier|register
expr|struct
name|nlist
operator|*
name|sp
block|;
specifier|register
name|char
operator|*
name|a
block|,
operator|*
name|b
block|;
name|char
name|symbuf
index|[
name|SYMLEN
index|]
block|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|error
argument_list|(
name|NOPCS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|curframe
operator|.
name|a_valid
operator|||
operator|(
name|sp
operator|=
name|xxxsym
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|NOCFN
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|getsym
argument_list|(
name|symbuf
argument_list|,
name|SYMLEN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|sp
operator|=
name|nextlocal
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Local and parameter symbols (as generated by .stabs) 		 * end with ':', not '\0'; here we allow both. 		 */
if|if
condition|(
operator|*
operator|(
name|a
operator|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|)
operator|!=
operator|*
operator|(
name|b
operator|=
name|symbuf
operator|)
condition|)
continue|continue;
while|while
condition|(
operator|*
name|a
operator|==
operator|*
name|b
operator|++
condition|)
if|if
condition|(
operator|*
name|a
operator|++
operator|==
literal|0
operator|||
operator|*
name|a
operator|==
literal|':'
condition|)
block|{
name|expv
operator|=
name|eval_localsym
argument_list|(
name|sp
argument_list|,
operator|&
name|curframe
argument_list|)
expr_stmt|;
name|xxxsym
operator|=
name|sp
expr_stmt|;
comment|/* ??? */
return|return;
block|}
block|}
end_while

begin_expr_stmt
name|error
argument_list|(
name|BADLOC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|inkdot
end_ifndef

begin_comment
comment|/*  * Function version of inkdot().  Compute the new dot, and check for  * address wrap-around.  */
end_comment

begin_macro
unit|addr_t
name|inkdot
argument_list|(
argument|incr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|incr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|addr_t
name|newdot
init|=
name|dot
operator|+
name|incr
decl_stmt|;
if|if
condition|(
name|ADDRESS_WRAP
argument_list|(
name|dot
argument_list|,
name|newdot
argument_list|)
condition|)
name|error
argument_list|(
name|ADWRAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|newdot
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

