begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)main.c	4.12 (Berkeley) 90/03/26"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"defs"
end_include

begin_comment
comment|/* command make to update programs. Flags:	'd'  print out debugging comments 	'p'  print out a version of the input graph 	's'  silent mode--don't print out commands 	'f'  the next argument is the name of the description file; 	     "makefile" is the default 	'i'  ignore error codes from the shell 	'S'  stop after any command fails (normally do parallel work) 	'n'   don't issue, just print, commands 	't'   touch (update time of) files but don't issue command 	'q'   don't do anything, but check if object is up to date; 	      returns exit code 0 if up to date, -1 if not 	'e'  environment variables have precedence over makefiles */
end_comment

begin_decl_stmt
name|struct
name|nameblock
modifier|*
name|mainname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nameblock
modifier|*
name|firstname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lineblock
modifier|*
name|sufflist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|varblock
modifier|*
name|firstvar
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pattern
modifier|*
name|firstpat
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dirhdr
modifier|*
name|firstod
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|int
name|sigivalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sigqvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waitpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbgflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prtrflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|silflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noexflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keepgoing
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noruleflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|touchflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|questflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndocoms
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ignerr
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default is to stop on error */
end_comment

begin_decl_stmt
name|int
name|okdel
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doenvlast
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inarglist
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|pwb
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|">"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other systems -- pick what you want */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other systems -- pick what you want */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nopdir
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|junkname
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|funny
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|options
index|[
literal|26
operator|+
literal|1
index|]
init|=
block|{
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|nameblock
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|descset
decl_stmt|,
name|nfargs
decl_stmt|;
name|TIMETYPE
name|tjunk
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|static
name|char
name|onechar
index|[
literal|2
index|]
init|=
literal|"X"
decl_stmt|;
ifdef|#
directive|ifdef
name|unix
name|int
name|intrupt
parameter_list|()
function_decl|;
endif|#
directive|endif
name|char
modifier|*
name|op
init|=
name|options
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|METERFILE
name|meter
argument_list|(
name|METERFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|descset
operator|=
literal|0
expr_stmt|;
name|funny
index|[
literal|'\0'
index|]
operator|=
operator|(
name|META
operator||
name|TERMINAL
operator|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|"=|^();&<>*?[]:$`'\"\\\n"
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
name|funny
index|[
operator|*
name|s
index|]
operator||=
name|META
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|"\n\t :;&>|"
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
name|funny
index|[
operator|*
name|s
index|]
operator||=
name|TERMINAL
expr_stmt|;
name|inarglist
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
name|eqsign
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|setvar
argument_list|(
literal|"$"
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|inarglist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
operator|(
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|j
control|)
block|{
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|dbgflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|prtrflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|silflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignerr
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|keepgoing
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keepgoing
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noexflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|noruleflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|touchflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|questflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|op
operator|--
expr_stmt|;
comment|/* don't pass this one */
if|if
condition|(
name|i
operator|>=
name|argc
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"No description argument after -f flag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rddescf
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
name|fatal1
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|descset
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|doenvlast
operator|=
name|YES
expr_stmt|;
break|break;
default|default:
name|onechar
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* to make lint happy */
name|fatal1
argument_list|(
literal|"Unknown flag argument %s"
argument_list|,
name|onechar
argument_list|)
expr_stmt|;
block|}
block|}
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|options
operator|=
literal|'\0'
expr_stmt|;
name|setvar
argument_list|(
literal|"MFLAGS"
argument_list|,
name|options
argument_list|)
expr_stmt|;
comment|/* MFLAGS=options to make */
name|setvar
argument_list|(
literal|"MACHINE"
argument_list|,
name|MACHINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|descset
condition|)
block|{
if|if
condition|(
name|rddescf
argument_list|(
literal|"makefile"
argument_list|)
condition|)
name|rddescf
argument_list|(
literal|"Makefile"
argument_list|)
expr_stmt|;
name|rddescf
argument_list|(
literal|".depend"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doenvlast
operator|==
name|YES
condition|)
name|readenv
argument_list|()
expr_stmt|;
if|if
condition|(
name|prtrflag
condition|)
name|printdesc
argument_list|(
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|srchname
argument_list|(
literal|".IGNORE"
argument_list|)
condition|)
operator|++
name|ignerr
expr_stmt|;
if|if
condition|(
name|srchname
argument_list|(
literal|".SILENT"
argument_list|)
condition|)
name|silflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|srchname
argument_list|(
literal|".SUFFIXES"
argument_list|)
condition|)
name|sufflist
operator|=
name|p
operator|->
name|linep
expr_stmt|;
if|if
condition|(
operator|!
name|sufflist
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No suffix list.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|unix
name|sigivalue
operator|=
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|&
literal|01
expr_stmt|;
name|sigqvalue
operator|=
operator|(
name|int
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|&
literal|01
expr_stmt|;
name|enbint
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nfargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|s
operator|=
name|argv
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|srchname
argument_list|(
name|s
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|makename
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|++
name|nfargs
expr_stmt|;
name|doname
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|tjunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbgflag
condition|)
name|printdesc
argument_list|(
name|YES
argument_list|)
expr_stmt|;
block|}
comment|/* If no file arguments have been encountered, make the first name encountered that doesn't start with a dot */
if|if
condition|(
name|nfargs
operator|==
literal|0
condition|)
if|if
condition|(
name|mainname
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"No arguments or description file"
argument_list|)
expr_stmt|;
else|else
block|{
name|doname
argument_list|(
name|mainname
argument_list|,
literal|0
argument_list|,
operator|&
name|tjunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbgflag
condition|)
name|printdesc
argument_list|(
name|YES
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_macro
name|intrupt
argument_list|()
end_macro

begin_block
block|{
name|struct
name|varblock
modifier|*
name|varptr
parameter_list|()
function_decl|;
name|char
modifier|*
name|p
decl_stmt|;
name|TIMETYPE
name|exists
parameter_list|()
function_decl|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|okdel
operator|&&
operator|!
name|noexflag
operator|&&
operator|!
name|touchflag
operator|&&
operator|(
name|p
operator|=
name|varptr
argument_list|(
literal|"@"
argument_list|)
operator|->
name|varval
operator|)
operator|&&
operator|(
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
operator|&&
operator|!
name|isprecious
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n***  %s removed."
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|junkname
index|[
literal|0
index|]
condition|)
name|unlink
argument_list|(
name|junkname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|isprecious
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lineblock
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|depblock
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|nameblock
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|np
operator|=
name|srchname
argument_list|(
literal|".PRECIOUS"
argument_list|)
condition|)
for|for
control|(
name|lp
operator|=
name|np
operator|->
name|linep
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|nxtlineblock
control|)
for|for
control|(
name|dp
operator|=
name|lp
operator|->
name|depp
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|nxtdepblock
control|)
if|if
condition|(
operator|!
name|unequal
argument_list|(
name|p
argument_list|,
name|dp
operator|->
name|depname
operator|->
name|namep
argument_list|)
condition|)
return|return
operator|(
name|YES
operator|)
return|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_function_decl
name|enbint
function_decl|(
name|k
function_decl|)
name|int
argument_list|(
argument|*k
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|sigivalue
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigqvalue
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|builtin
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|linesptr
init|=
name|builtin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|firstrd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|rddescf
argument_list|(
argument|descfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|descfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|k
decl_stmt|;
comment|/* read and parse description */
if|if
condition|(
operator|!
name|firstrd
operator|++
condition|)
block|{
if|if
condition|(
operator|!
name|noruleflag
condition|)
name|rdd1
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|doenvlast
operator|==
name|NO
condition|)
name|readenv
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|pwb
block|{
name|char
modifier|*
name|nlog
decl_stmt|,
name|s
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|nlog
operator|=
name|logdir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|fopen
argument_list|(
name|concat
argument_list|(
name|nlog
argument_list|,
literal|"/makecomm"
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|rdd1
argument_list|(
name|k
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|k
operator|=
name|fopen
argument_list|(
name|concat
argument_list|(
name|nlog
argument_list|,
literal|"/Makecomm"
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|rdd1
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|fopen
argument_list|(
literal|"makecomm"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|rdd1
argument_list|(
name|k
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|k
operator|=
name|fopen
argument_list|(
literal|"Makecomm"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|rdd1
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|unequal
argument_list|(
name|descfile
argument_list|,
literal|"-"
argument_list|)
condition|)
return|return
operator|(
name|rdd1
argument_list|(
name|stdin
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|k
operator|=
name|fopen
argument_list|(
name|descfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rdd1
argument_list|(
name|k
argument_list|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rdd1
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|yylineno
decl_stmt|;
specifier|extern
name|char
modifier|*
name|zznextc
decl_stmt|;
name|fin
operator|=
name|k
expr_stmt|;
name|yylineno
operator|=
literal|0
expr_stmt|;
name|zznextc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"Description file error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|!=
name|NULL
operator|&&
name|fin
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|printdesc
argument_list|(
argument|prntflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|prntflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|nameblock
modifier|*
name|p
decl_stmt|;
name|struct
name|depblock
modifier|*
name|dp
decl_stmt|;
name|struct
name|varblock
modifier|*
name|vp
decl_stmt|;
name|struct
name|dirhdr
modifier|*
name|od
decl_stmt|;
name|struct
name|shblock
modifier|*
name|sp
decl_stmt|;
name|struct
name|lineblock
modifier|*
name|lp
decl_stmt|;
ifdef|#
directive|ifdef
name|unix
if|if
condition|(
name|prntflag
condition|)
block|{
name|printf
argument_list|(
literal|"Open directories:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|od
operator|=
name|firstod
init|;
name|od
condition|;
name|od
operator|=
name|od
operator|->
name|nxtopendir
control|)
name|printf
argument_list|(
literal|"\t%d: %s\n"
argument_list|,
name|dirfd
argument_list|(
name|od
operator|->
name|dirfc
argument_list|)
argument_list|,
name|od
operator|->
name|dirn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|firstvar
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Macros:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|firstvar
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxtvarblock
control|)
name|printf
argument_list|(
literal|"\t%s = %s\n"
argument_list|,
name|vp
operator|->
name|varname
argument_list|,
name|vp
operator|->
name|varval
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|firstname
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nxtnameblock
control|)
block|{
name|printf
argument_list|(
literal|"\n\n%s"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|linep
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prntflag
condition|)
name|printf
argument_list|(
literal|"  done=%d"
argument_list|,
name|p
operator|->
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|mainname
condition|)
name|printf
argument_list|(
literal|"  (MAIN NAME)"
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|p
operator|->
name|linep
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|nxtlineblock
control|)
block|{
if|if
condition|(
name|dp
operator|=
name|lp
operator|->
name|depp
condition|)
block|{
name|printf
argument_list|(
literal|"\n depends on:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|nxtdepblock
control|)
if|if
condition|(
name|dp
operator|->
name|depname
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|dp
operator|->
name|depname
operator|->
name|namep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|=
name|lp
operator|->
name|shp
condition|)
block|{
name|printf
argument_list|(
literal|"\n commands:\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|!=
literal|0
condition|;
name|sp
operator|=
name|sp
operator|->
name|nxtshblock
control|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|sp
operator|->
name|shbp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|readenv
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|environ
init|;
operator|*
name|ep
condition|;
operator|++
name|ep
control|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|ep
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|eqsign
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_block

end_unit

