begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	sub.c  	support procedures  	the following procedures end up reading the passwd file 	or the passwdf file and are to be avoided.  	getpwuid(uid) 	getpwnam(sn) 	PwdCurrent() 	getenv("HOME")		maybe if hget, hgethome don't work 	SnFromUid(uid)		maybe if hashed passwd stuff doesn't work 	SnCurrent()		maybe if getlogin fails calls SnFromUid(uid) 	getpwf() 	passwdent(uid,sn) */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
name|int
name|debugflg
init|=
name|DBV
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag */
end_comment

begin_decl_stmt
name|char
name|local
init|=
name|LOCAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the machine we're on */
end_comment

begin_decl_stmt
name|char
name|netcmd
index|[]
init|=
name|NETCMD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resfile
index|[]
init|=
name|RESFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|senddir
index|[]
init|=
name|SENDDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Bsh
index|[]
init|=
name|BINSH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shomedir
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	passwdent()  	Read the password file looking for current user's entry. 	Fill in the status structure. 	Has the (dangerous) side effect of giving a value to getenv("HOME"). */
end_comment

begin_macro
name|passwdent
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|u
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|pwd
operator|=
name|PwdCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"Bad uid/username\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|status
operator|.
name|localname
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|status
operator|.
name|muid
operator|=
name|guid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|status
operator|.
name|mgid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|pwd
operator|->
name|pw_gecos
index|[
literal|0
index|]
argument_list|)
condition|)
name|status
operator|.
name|jobno
operator|=
name|atoi
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
else|else
name|status
operator|.
name|jobno
operator|=
literal|32767
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|dir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shomedir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
comment|/* side effect */
name|u
operator|=
name|pwd
operator|->
name|pw_shell
expr_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|u
operator|=
name|Bsh
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|loginshell
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	promptlogin(mchto)  	ask user for login and passwd on mchto. 	make sure status.localname has a value before calling 	this.  One way is to call passwdent(), another is to 	strcpy(status.localname,SnCurrent()). */
end_comment

begin_macro
name|promptlogin
argument_list|(
argument|mchto
argument_list|)
end_macro

begin_decl_stmt
name|char
name|mchto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mch
decl_stmt|;
name|FILE
modifier|*
name|wf
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
condition|)
block|{
name|wf
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
condition|)
block|{
name|printf
argument_list|(
literal|"Name (%s:%s): "
argument_list|,
name|longname
argument_list|(
name|mchto
argument_list|)
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|wf
argument_list|)
operator|!=
name|buf
condition|)
block|{
name|perror
argument_list|(
literal|"fgets"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|c
operator|>
literal|0
condition|?
name|c
operator|-
literal|1
else|:
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|10
condition|)
block|{
name|err
argument_list|(
literal|"Login name too long.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FMemberSCh
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"Login names don't have blanks in them.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
name|mch
operator|=
name|MchSFromAddr
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mch
operator|!=
name|local
operator|&&
name|mch
operator|!=
name|mchto
condition|)
block|{
name|err
argument_list|(
literal|"Must specify login name on %s machine\n"
argument_list|,
name|longname
argument_list|(
name|mchto
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Password (%s:%s):"
argument_list|,
name|longname
argument_list|(
name|mchto
argument_list|)
argument_list|,
name|status
operator|.
name|login
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|getpass
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|wf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
name|status
operator|.
name|force
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* determine through machine */
end_comment

begin_macro
name|gothru
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
literal|'a'
case|:
name|i
operator|=
name|configA
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|i
operator|=
name|configB
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|i
operator|=
name|configC
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|i
operator|=
name|configD
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|i
operator|=
name|configE
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|i
operator|=
name|configF
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|i
operator|=
name|configI
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|i
operator|=
name|configJ
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|i
operator|=
name|configM
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|i
operator|=
name|configO
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|i
operator|=
name|configQ
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|i
operator|=
name|configS
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|i
operator|=
name|configV
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|i
operator|=
name|configY
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|i
operator|=
name|configZ
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	harg(string,pargc,pargv)  	A curious procedure which takes a pointer to an argc, and a  	pointer to an argv, and parses them so that the 	argument following the flag is copied into string. 	pargv[0] must be the flag argument. 	handles both 		-my 	and 		-m y 	for the net command. */
end_comment

begin_macro
name|harg
argument_list|(
argument|ans
argument_list|,
argument|pargc
argument_list|,
argument|pargv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ans
decl_stmt|,
modifier|*
name|pargc
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pargv
operator|)
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
comment|/* no space */
name|strcpy
argument_list|(
name|ans
argument_list|,
operator|(
operator|*
name|pargv
operator|)
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* space, get next arg */
name|strcpy
argument_list|(
name|ans
argument_list|,
operator|(
operator|*
name|pargv
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pargc
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|pargv
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* prints out commands before executing them */
end_comment

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|mexecl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debugflg
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|err
argument_list|(
literal|"%s "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|,
name|p
index|[
literal|8
index|]
argument_list|,
name|p
index|[
literal|9
index|]
argument_list|,
name|p
index|[
literal|10
index|]
argument_list|,
name|p
index|[
literal|11
index|]
argument_list|,
name|p
index|[
literal|12
index|]
argument_list|,
name|p
index|[
literal|13
index|]
argument_list|,
name|p
index|[
literal|14
index|]
argument_list|,
name|p
index|[
literal|15
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prints out commands before executing them */
end_comment

begin_expr_stmt
name|mexecv
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debugflg
condition|)
block|{
name|err
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|err
argument_list|(
literal|"%s "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|execv
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS0*/
end_comment

begin_comment
comment|/* fills in -l - -p from commands like rcp */
end_comment

begin_comment
comment|/* must be called with at least two arguments */
end_comment

begin_macro
name|kexecl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|a
index|[
literal|20
index|]
decl_stmt|,
name|i
init|=
literal|2
decl_stmt|,
name|j
init|=
literal|2
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|s
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
name|a
index|[
name|i
operator|++
index|]
operator|=
name|status
operator|.
name|login
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-p"
expr_stmt|;
name|a
index|[
name|i
operator|++
index|]
operator|=
name|status
operator|.
name|mpasswd
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|nonotify
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-b"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|force
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-f"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|quiet
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-q"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|nowrite
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-n"
expr_stmt|;
while|while
condition|(
name|p
index|[
name|j
index|]
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
name|p
index|[
name|j
operator|++
index|]
expr_stmt|;
name|a
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mexecl
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|,
name|a
index|[
literal|11
index|]
argument_list|,
name|a
index|[
literal|12
index|]
argument_list|,
name|a
index|[
literal|13
index|]
argument_list|,
name|a
index|[
literal|14
index|]
argument_list|,
name|a
index|[
literal|15
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	MchSFromAddr(sn,addr)  	take an address of the form "mach:username" 	and return mch as the 1 char code of "mach" and 	in sn put "username". 	If addr has no colon in it, return mch==local, sn==addr. */
end_comment

begin_macro
name|MchSFromAddr
argument_list|(
argument|sn
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sn
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fcolon
init|=
literal|0
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|mch
decl_stmt|,
name|stemp
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* assume addr is a local address */
name|strcpy
argument_list|(
name|stemp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|s
operator|=
name|stemp
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
name|fcolon
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fcolon
operator|!=
literal|1
condition|)
block|{
comment|/* sn better be the right size for addr */
name|mch
operator|=
name|local
expr_stmt|;
name|strcpy
argument_list|(
name|sn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|mch
operator|)
return|;
block|}
comment|/* addr has a colon in it, s pts to name */
name|mch
operator|=
name|lookup
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sn
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mch
operator|)
return|;
block|}
end_block

begin_comment
comment|/* returns a single character for machine S */
end_comment

begin_expr_stmt
name|lookup
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
else|:
operator|*
name|s
operator|)
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|bigname
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|streql
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|bigname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|t
operator|->
name|lname
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* returns a long name (string) for single character machine c */
end_comment

begin_function
name|char
modifier|*
name|longname
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|tt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|bigname
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|t
operator|->
name|lname
condition|)
return|return
operator|(
name|t
operator|->
name|bigname
operator|)
return|;
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|debug
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|,
argument|o
argument_list|,
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|debugflg
condition|)
block|{
name|printf
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	FMemberSCh(s,ch)  	return 1 if ch is a character in string s. 	0 otherwise. */
end_comment

begin_expr_stmt
name|FMemberSCh
argument_list|(
name|s
argument_list|,
name|ch
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|ch
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* return a static string with the form "X hrs X mins X secs" */
end_comment

begin_comment
comment|/* t is # of secs */
end_comment

begin_function
name|char
modifier|*
name|comptime
parameter_list|(
name|t
parameter_list|)
name|long
name|t
decl_stmt|;
block|{
specifier|static
name|char
name|str
index|[
literal|30
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|long
name|w
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|t
operator|/
literal|3600L
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0L
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld hr "
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|%
literal|3600L
expr_stmt|;
name|w
operator|=
name|t
operator|/
literal|60L
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0L
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld min "
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|%
literal|60L
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld sec"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 	parseparmlist(string)  	parses variable parameter lists in string, 	as defined in genparmlist in net.c */
end_comment

begin_macro
name|parseparmlist
argument_list|(
argument|parmlist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|parmlist
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|parmlist
operator|&&
operator|*
name|parmlist
operator|!=
literal|'('
condition|)
name|parmlist
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	PwdCurrent()  	Read the password file and return pwd to 	entry for current user. 	Return NULL if error.  	This code is a little screwed up because of the conventions 	regarding the state of the utmp file after someone su's-- 	either to root or to another person. 	The final decision was to return getpwuid(getuid) if 	the machine has one login name per userid, 	and if there are multiple login names per userid, to 	search the passwd file for the getlogin() name and return 	the passwd file entry for that. 	If there is no utmp entry, just use the userid. 	This means that people who su on machine with multiple 	user-id's will get the passwd entry for the account recorded 	in the utmp file, not their current userid. */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|PwdCurrent
parameter_list|()
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
specifier|register
name|char
modifier|*
name|sn
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTNAMS
name|sn
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
operator|&&
name|sn
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|sn
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
block|{
name|pwd
operator|=
name|getpwnam
argument_list|(
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pwd
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|getpwuid
argument_list|(
name|uidmask
argument_list|(
name|getuid
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 	SnCurrent()  	Return the name of the current user. 	If not in the /etc/utmp file, will read the passwd file. 	Returns NULL if error. 	Note that detached processes on V7 have getlogin() return 	a pointer to a null string, not NULL. */
end_comment

begin_function
name|char
modifier|*
name|SnCurrent
parameter_list|()
block|{
specifier|static
name|char
name|snBuf
index|[
name|NS
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|sn
decl_stmt|;
name|sn
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
operator|||
name|sn
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|sn
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|sn
operator|=
name|SnFromUid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|snBuf
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|sn
operator|=
name|snBuf
expr_stmt|;
block|}
return|return
operator|(
name|sn
operator|)
return|;
block|}
end_function

begin_comment
comment|/* just like strcmp except upper- and lower-case are ignored */
end_comment

begin_macro
name|streql
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
operator|*
name|s2
condition|)
block|{
name|a
operator|=
name|isupper
argument_list|(
operator|*
name|s1
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s1
argument_list|)
else|:
operator|*
name|s1
expr_stmt|;
name|b
operator|=
name|isupper
argument_list|(
operator|*
name|s2
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s2
argument_list|)
else|:
operator|*
name|s2
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s1
operator|++
operator|,
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|s1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* VARARGS0 */
end_comment

begin_macro
name|err
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|,
argument|o
argument_list|,
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

