begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998-2000 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* This is a variation on dtoa.c that converts arbitary binary    floating-point formats to and from decimal notation.  It uses    double-precision arithmetic internally, so there are still    various #ifdefs that adapt the calculations to the native    double-precision arithmetic (any of IEEE, VAX D_floating,    or IBM mainframe arithmetic).     Please send bug reports to David M. Gay (dmg at acm dot org,    with " at " changed at "@" and " dot " changed to ".").  */
end_comment

begin_comment
comment|/* On a machine with IEEE extended-precision registers, it is  * necessary to specify double-precision (53-bit) rounding precision  * before invoking strtod or dtoa.  If the machine uses (the equivalent  * of) Intel 80x87 arithmetic, the call  *	_control87(PC_53, MCW_PC);  * does this with many compilers.  Whether this or another call is  * appropriate depends on the compiler; for this to work, it may be  * necessary to #include "float.h" or another system-dependent header  * file.  */
end_comment

begin_comment
comment|/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.  *  * This strtod returns a nearest machine number to the input decimal  * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are  * broken by the IEEE round-even rule.  Otherwise ties are broken by  * biased rounding (add half and chop).  *  * Inspired loosely by William D. Clinger's paper "How to Read Floating  * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 112-126].  *  * Modifications:  *  *	1. We only require IEEE, IBM, or VAX double-precision  *		arithmetic (not IEEE double-extended).  *	2. We get by with floating-point arithmetic in a case that  *		Clinger missed -- when we're computing d * 10^n  *		for a small integer d and the integer n is not too  *		much larger than 22 (the maximum integer k for which  *		we can represent 10^k exactly), we may be able to  *		compute (d*10^k) * 10^(e-k) with just one roundoff.  *	3. Rather than a bit-at-a-time adjustment of the binary  *		result in the hard case, we use floating-point  *		arithmetic to determine the adjustment to within  *		one bit; only in really hard cases do we need to  *		compute a second residual.  *	4. Because of 3., we don't need a large table of powers of 10  *		for ten-to-e (just some small tables, e.g. of 10^k  *		for 0<= k<= 22).  */
end_comment

begin_comment
comment|/*  * #define IEEE_8087 for IEEE-arithmetic machines where the least  *	significant byte has the lowest address.  * #define IEEE_MC68k for IEEE-arithmetic machines where the most  *	significant byte has the lowest address.  * #define Long int on machines with 32-bit ints and 64-bit longs.  * #define Sudden_Underflow for IEEE-format machines without gradual  *	underflow (i.e., that flush to zero on underflow).  * #define IBM for IBM mainframe-style floating-point arithmetic.  * #define VAX for VAX-style floating-point arithmetic (D_floating).  * #define No_leftright to omit left-right logic in fast floating-point  *	computation of dtoa.  * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.  * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines  *	that use extended-precision instructions to compute rounded  *	products and quotients) with IBM.  * #define ROUND_BIASED for IEEE-format with biased rounding.  * #define Inaccurate_Divide for IEEE-format with correctly rounded  *	products but inaccurate quotients, e.g., for Intel i860.  * #define NO_LONG_LONG on machines that do not have a "long long"  *	integer type (of>= 64 bits).  On such machines, you can  *	#define Just_16 to store 16 bits per 32-bit Long when doing  *	high-precision integer arithmetic.  Whether this speeds things  *	up or slows things down depends on the machine and the number  *	being converted.  If long long is available and the name is  *	something other than "long long", #define Llong to be the name,  *	and if "unsigned Llong" does not work as an unsigned version of  *	Llong, #define #ULLong to be the corresponding unsigned type.  * #define KR_headers for old-style C function headers.  * #define Bad_float_h if your system lacks a float.h or if it does not  *	define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,  *	FLT_RADIX, FLT_ROUNDS, and DBL_MAX.  * #define MALLOC your_malloc, where your_malloc(n) acts like malloc(n)  *	if memory is available and otherwise does something you deem  *	appropriate.  If MALLOC is undefined, malloc will be invoked  *	directly -- and assumed always to succeed.  * #define Omit_Private_Memory to omit logic (added Jan. 1998) for making  *	memory allocations from a private pool of memory when possible.  *	When used, the private pool is PRIVATE_MEM bytes long:  2304 bytes,  *	unless #defined to be a different length.  This default length  *	suffices to get rid of MALLOC calls except for unusual cases,  *	such as decimal-to-binary conversion of a very long string of  *	digits.  When converting IEEE double precision values, the  *	longest string gdtoa can return is about 751 bytes long.  For  *	conversions by strtod of strings of 800 digits and all gdtoa  *	conversions of IEEE doubles in single-threaded executions with  *	8-byte pointers, PRIVATE_MEM>= 7400 appears to suffice; with  *	4-byte pointers, PRIVATE_MEM>= 7112 appears adequate.  * #define INFNAN_CHECK on IEEE systems to cause strtod to check for  *	Infinity and NaN (case insensitively).  *	When INFNAN_CHECK is #defined and No_Hex_NaN is not #defined,  *	strtodg also accepts (case insensitively) strings of the form  *	NaN(x), where x is a string of hexadecimal digits and spaces;  *	if there is only one string of hexadecimal digits, it is taken  *	for the fraction bits of the resulting NaN; if there are two or  *	more strings of hexadecimal digits, each string is assigned  *	to the next available sequence of 32-bit words of fractions  *	bits (starting with the most significant), right-aligned in  *	each sequence.  * #define MULTIPLE_THREADS if the system offers preemptively scheduled  *	multiple threads.  In this case, you must provide (or suitably  *	#define) two locks, acquired by ACQUIRE_DTOA_LOCK(n) and freed  *	by FREE_DTOA_LOCK(n) for n = 0 or 1.  (The second lock, accessed  *	in pow5mult, ensures lazy evaluation of only one copy of high  *	powers of 5; omitting this lock would introduce a small  *	probability of wasting memory, but would otherwise be harmless.)  *	You must also invoke freedtoa(s) to free the value s returned by  *	dtoa.  You may do so whether or not MULTIPLE_THREADS is #defined.  * #define IMPRECISE_INEXACT if you do not care about the setting of  *	the STRTOG_Inexact bits in the special case of doing IEEE double  *	precision conversions (which could also be done by the strtog in  *	dtoa.c).  * #define NO_HEX_FP to disable recognition of C9x's hexadecimal  *	floating-point constants.  * #define -DNO_ERRNO to suppress setting errno (in strtod.c and  *	strtodg.c).  * #define NO_STRING_H to use private versions of memcpy.  *	On some K&R systems, it may also be necessary to  *	#define DECLARE_SIZE_T in this case.  * #define YES_ALIAS to permit aliasing certain double values with  *	arrays of ULongs.  This leads to slightly better code with  *	some compilers and was always used prior to 19990916, but it  *	is not strictly legal and can cause trouble with aggressively  *	optimizing compilers (e.g., gcc 2.95.1 under -O2).  * #define USE_LOCALE to use the current locale's decimal_point value.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDTOAIMP_H_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|GDTOAIMP_H_INCLUDED
end_define

begin_include
include|#
directive|include
file|"gdtoa.h"
end_include

begin_include
include|#
directive|include
file|"gd_qnan.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_define
define|#
directive|define
name|Bug
parameter_list|(
name|x
parameter_list|)
value|{fprintf(stderr, "%s\n", x); exit(1);}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"stdlib.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_define
define|#
directive|define
name|Char
value|char
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Char
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC
end_ifdef

begin_decl_stmt
specifier|extern
name|Char
modifier|*
name|MALLOC
name|ANSI
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MALLOC
value|malloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|IEEE_Arith
end_undef

begin_undef
undef|#
directive|undef
name|Avoid_Underflow
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_MC68k
end_ifdef

begin_define
define|#
directive|define
name|IEEE_Arith
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_8087
end_ifdef

begin_define
define|#
directive|define
name|IEEE_Arith
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|Bad_float_h
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_define
define|#
directive|define
name|DBL_DIG
value|15
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|308
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|1024
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|2
end_define

begin_define
define|#
directive|define
name|DBL_MAX
value|1.7976931348623157e+308
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_define
define|#
directive|define
name|DBL_DIG
value|16
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|75
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|63
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|16
end_define

begin_define
define|#
directive|define
name|DBL_MAX
value|7.2370055773322621e+75
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_define
define|#
directive|define
name|DBL_DIG
value|16
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|38
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|127
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|2
end_define

begin_define
define|#
directive|define
name|DBL_MAX
value|1.7014118346046923e+38
end_define

begin_define
define|#
directive|define
name|n_bigtens
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|LONG_MAX
value|2147483647
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ifndef Bad_float_h */
end_comment

begin_include
include|#
directive|include
file|"float.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bad_float_h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_define
define|#
directive|define
name|Scale_Bit
value|0x10
end_define

begin_define
define|#
directive|define
name|n_bigtens
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_define
define|#
directive|define
name|n_bigtens
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_define
define|#
directive|define
name|n_bigtens
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__MATH_H__
end_ifndef

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IEEE_8087
argument_list|)
operator|+
name|defined
argument_list|(
name|IEEE_MC68k
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
operator|+
name|defined
argument_list|(
name|IBM
argument_list|)
operator|!=
literal|1
name|Exactly
name|one
name|of
name|IEEE_8087
decl_stmt|,
name|IEEE_MC68k
decl_stmt|,
name|VAX
decl_stmt|,
name|or
name|IBM
name|should
name|be
name|defined
operator|.
endif|#
directive|endif
decl|typedef union
block|{
name|double
name|d
decl_stmt|;
name|ULong
name|L
index|[
literal|2
index|]
decl_stmt|;
block|}
name|U
expr_stmt|;
ifdef|#
directive|ifdef
name|YES_ALIAS
define|#
directive|define
name|dval
parameter_list|(
name|x
parameter_list|)
value|x
ifdef|#
directive|ifdef
name|IEEE_8087
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[1]
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[0]
else|#
directive|else
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[0]
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[1]
endif|#
directive|endif
else|#
directive|else
comment|/* !YES_ALIAS */
ifdef|#
directive|ifdef
name|IEEE_8087
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((U*)&x)->L[1]
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((U*)&x)->L[0]
else|#
directive|else
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((U*)&x)->L[0]
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((U*)&x)->L[1]
endif|#
directive|endif
define|#
directive|define
name|dval
parameter_list|(
name|x
parameter_list|)
value|((U*)&x)->d
endif|#
directive|endif
comment|/* YES_ALIAS */
comment|/* The following definition of Storeinc is appropriate for MIPS processors.  * An alternative that might be better on some machines is  * #define Storeinc(a,b,c) (*a++ = b<< 16 | c& 0xffff)  */
if|#
directive|if
name|defined
argument_list|(
name|IEEE_8087
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(((unsigned short *)a)[1] = (unsigned short)b, \ ((unsigned short *)a)[0] = (unsigned short)c, a++)
else|#
directive|else
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(((unsigned short *)a)[0] = (unsigned short)b, \ ((unsigned short *)a)[1] = (unsigned short)c, a++)
endif|#
directive|endif
comment|/* #define P DBL_MANT_DIG */
comment|/* Ten_pmax = floor(P*log(2)/log(5)) */
comment|/* Bletch = (highest power of 2< DBL_MAX_10_EXP) / 16 */
comment|/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
comment|/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
ifdef|#
directive|ifdef
name|IEEE_Arith
define|#
directive|define
name|Exp_shift
value|20
define|#
directive|define
name|Exp_shift1
value|20
define|#
directive|define
name|Exp_msk1
value|0x100000
define|#
directive|define
name|Exp_msk11
value|0x100000
define|#
directive|define
name|Exp_mask
value|0x7ff00000
define|#
directive|define
name|P
value|53
define|#
directive|define
name|Bias
value|1023
define|#
directive|define
name|Emin
value|(-1022)
define|#
directive|define
name|Exp_1
value|0x3ff00000
define|#
directive|define
name|Exp_11
value|0x3ff00000
define|#
directive|define
name|Ebits
value|11
define|#
directive|define
name|Frac_mask
value|0xfffff
define|#
directive|define
name|Frac_mask1
value|0xfffff
define|#
directive|define
name|Ten_pmax
value|22
define|#
directive|define
name|Bletch
value|0x10
define|#
directive|define
name|Bndry_mask
value|0xfffff
define|#
directive|define
name|Bndry_mask1
value|0xfffff
define|#
directive|define
name|LSB
value|1
define|#
directive|define
name|Sign_bit
value|0x80000000
define|#
directive|define
name|Log2P
value|1
define|#
directive|define
name|Tiny0
value|0
define|#
directive|define
name|Tiny1
value|1
define|#
directive|define
name|Quick_max
value|14
define|#
directive|define
name|Int_max
value|14
ifndef|#
directive|ifndef
name|Flt_Rounds
ifdef|#
directive|ifdef
name|FLT_ROUNDS
define|#
directive|define
name|Flt_Rounds
value|FLT_ROUNDS
else|#
directive|else
define|#
directive|define
name|Flt_Rounds
value|1
endif|#
directive|endif
endif|#
directive|endif
comment|/*Flt_Rounds*/
else|#
directive|else
comment|/* ifndef IEEE_Arith */
undef|#
directive|undef
name|Sudden_Underflow
define|#
directive|define
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
undef|#
directive|undef
name|Flt_Rounds
define|#
directive|define
name|Flt_Rounds
value|0
define|#
directive|define
name|Exp_shift
value|24
define|#
directive|define
name|Exp_shift1
value|24
define|#
directive|define
name|Exp_msk1
value|0x1000000
define|#
directive|define
name|Exp_msk11
value|0x1000000
define|#
directive|define
name|Exp_mask
value|0x7f000000
define|#
directive|define
name|P
value|14
define|#
directive|define
name|Bias
value|65
define|#
directive|define
name|Exp_1
value|0x41000000
define|#
directive|define
name|Exp_11
value|0x41000000
define|#
directive|define
name|Ebits
value|8
comment|/* exponent has 7 bits, but 8 is the right value in b2d */
define|#
directive|define
name|Frac_mask
value|0xffffff
define|#
directive|define
name|Frac_mask1
value|0xffffff
define|#
directive|define
name|Bletch
value|4
define|#
directive|define
name|Ten_pmax
value|22
define|#
directive|define
name|Bndry_mask
value|0xefffff
define|#
directive|define
name|Bndry_mask1
value|0xffffff
define|#
directive|define
name|LSB
value|1
define|#
directive|define
name|Sign_bit
value|0x80000000
define|#
directive|define
name|Log2P
value|4
define|#
directive|define
name|Tiny0
value|0x100000
define|#
directive|define
name|Tiny1
value|0
define|#
directive|define
name|Quick_max
value|14
define|#
directive|define
name|Int_max
value|15
else|#
directive|else
comment|/* VAX */
undef|#
directive|undef
name|Flt_Rounds
define|#
directive|define
name|Flt_Rounds
value|1
define|#
directive|define
name|Exp_shift
value|23
define|#
directive|define
name|Exp_shift1
value|7
define|#
directive|define
name|Exp_msk1
value|0x80
define|#
directive|define
name|Exp_msk11
value|0x800000
define|#
directive|define
name|Exp_mask
value|0x7f80
define|#
directive|define
name|P
value|56
define|#
directive|define
name|Bias
value|129
define|#
directive|define
name|Exp_1
value|0x40800000
define|#
directive|define
name|Exp_11
value|0x4080
define|#
directive|define
name|Ebits
value|8
define|#
directive|define
name|Frac_mask
value|0x7fffff
define|#
directive|define
name|Frac_mask1
value|0xffff007f
define|#
directive|define
name|Ten_pmax
value|24
define|#
directive|define
name|Bletch
value|2
define|#
directive|define
name|Bndry_mask
value|0xffff007f
define|#
directive|define
name|Bndry_mask1
value|0xffff007f
define|#
directive|define
name|LSB
value|0x10000
define|#
directive|define
name|Sign_bit
value|0x8000
define|#
directive|define
name|Log2P
value|1
define|#
directive|define
name|Tiny0
value|0x80
define|#
directive|define
name|Tiny1
value|0
define|#
directive|define
name|Quick_max
value|15
define|#
directive|define
name|Int_max
value|15
endif|#
directive|endif
comment|/* IBM, VAX */
endif|#
directive|endif
comment|/* IEEE_Arith */
ifndef|#
directive|ifndef
name|IEEE_Arith
define|#
directive|define
name|ROUND_BIASED
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RND_PRODQUOT
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_prod(a, b)
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_quot(a, b)
ifdef|#
directive|ifdef
name|KR_headers
specifier|extern
name|double
name|rnd_prod
argument_list|()
decl_stmt|,
name|rnd_quot
argument_list|()
decl_stmt|;
else|#
directive|else
specifier|extern
name|double
name|rnd_prod
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|,
name|rnd_quot
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a *= b
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a /= b
endif|#
directive|endif
define|#
directive|define
name|Big0
value|(Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
define|#
directive|define
name|Big1
value|0xffffffff
undef|#
directive|undef
name|Pack_16
ifndef|#
directive|ifndef
name|Pack_32
define|#
directive|define
name|Pack_32
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_LONG_LONG
undef|#
directive|undef
name|ULLong
ifdef|#
directive|ifdef
name|Just_16
undef|#
directive|undef
name|Pack_32
define|#
directive|define
name|Pack_16
comment|/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.  * This makes some inner loops simpler and sometimes saves work  * during multiplications, but it often seems to make things slightly  * slower.  Hence the default is now to store 32 bits per Long.  */
endif|#
directive|endif
else|#
directive|else
comment|/* long long available */
ifndef|#
directive|ifndef
name|Llong
define|#
directive|define
name|Llong
value|long long
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ULLong
define|#
directive|define
name|ULLong
value|unsigned Llong
endif|#
directive|endif
endif|#
directive|endif
comment|/* NO_LONG_LONG */
ifdef|#
directive|ifdef
name|Pack_32
define|#
directive|define
name|ULbits
value|32
define|#
directive|define
name|kshift
value|5
define|#
directive|define
name|kmask
value|31
define|#
directive|define
name|ALL_ON
value|0xffffffff
else|#
directive|else
define|#
directive|define
name|ULbits
value|16
define|#
directive|define
name|kshift
value|4
define|#
directive|define
name|kmask
value|15
define|#
directive|define
name|ALL_ON
value|0xffff
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MULTIPLE_THREADS
define|#
directive|define
name|ACQUIRE_DTOA_LOCK
parameter_list|(
name|n
parameter_list|)
comment|/*nothing*/
define|#
directive|define
name|FREE_DTOA_LOCK
parameter_list|(
name|n
parameter_list|)
comment|/*nothing*/
endif|#
directive|endif
define|#
directive|define
name|Kmax
value|15
struct|struct
name|Bigint
block|{
name|struct
name|Bigint
modifier|*
name|next
decl_stmt|;
name|int
name|k
decl_stmt|,
name|maxwds
decl_stmt|,
name|sign
decl_stmt|,
name|wds
decl_stmt|;
name|ULong
name|x
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|Bigint
name|Bigint
typedef|;
ifdef|#
directive|ifdef
name|NO_STRING_H
ifdef|#
directive|ifdef
name|DECLARE_SIZE_T
typedef|typedef
name|unsigned
name|int
name|size_t
typedef|;
endif|#
directive|endif
specifier|extern
name|void
name|memcpy_D2A
name|ANSI
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|Bcopy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|memcpy_D2A(&x->sign,&y->sign,y->wds*sizeof(ULong) + 2*sizeof(int))
else|#
directive|else
comment|/* !NO_STRING_H */
define|#
directive|define
name|Bcopy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|memcpy(&x->sign,&y->sign,y->wds*sizeof(ULong) + 2*sizeof(int))
endif|#
directive|endif
comment|/* NO_STRING_H */
define|#
directive|define
name|Balloc
value|Balloc_D2A
define|#
directive|define
name|Bfree
value|Bfree_D2A
define|#
directive|define
name|ULtoQ
value|ULtoQ_D2A
define|#
directive|define
name|ULtof
value|ULtof_D2A
define|#
directive|define
name|ULtod
value|ULtod_D2A
define|#
directive|define
name|ULtodd
value|ULtodd_D2A
define|#
directive|define
name|ULtox
value|ULtox_D2A
define|#
directive|define
name|ULtoxL
value|ULtoxL_D2A
define|#
directive|define
name|any_on
value|any_on_D2A
define|#
directive|define
name|b2d
value|b2d_D2A
define|#
directive|define
name|bigtens
value|bigtens_D2A
define|#
directive|define
name|cmp
value|cmp_D2A
define|#
directive|define
name|copybits
value|copybits_D2A
define|#
directive|define
name|d2b
value|d2b_D2A
define|#
directive|define
name|decrement
value|decrement_D2A
define|#
directive|define
name|diff
value|diff_D2A
define|#
directive|define
name|dtoa_result
value|dtoa_result_D2A
define|#
directive|define
name|g__fmt
value|g__fmt_D2A
define|#
directive|define
name|gethex
value|gethex_D2A
define|#
directive|define
name|hexdig
value|hexdig_D2A
define|#
directive|define
name|hexnan
value|hexnan_D2A
define|#
directive|define
name|hi0bits
parameter_list|(
name|x
parameter_list|)
value|hi0bits_D2A((ULong)(x))
define|#
directive|define
name|i2b
value|i2b_D2A
define|#
directive|define
name|increment
value|increment_D2A
define|#
directive|define
name|lo0bits
value|lo0bits_D2A
define|#
directive|define
name|lshift
value|lshift_D2A
define|#
directive|define
name|match
value|match_D2A
define|#
directive|define
name|mult
value|mult_D2A
define|#
directive|define
name|multadd
value|multadd_D2A
define|#
directive|define
name|nrv_alloc
value|nrv_alloc_D2A
define|#
directive|define
name|pow5mult
value|pow5mult_D2A
define|#
directive|define
name|quorem
value|quorem_D2A
define|#
directive|define
name|ratio
value|ratio_D2A
define|#
directive|define
name|rshift
value|rshift_D2A
define|#
directive|define
name|rv_alloc
value|rv_alloc_D2A
define|#
directive|define
name|s2b
value|s2b_D2A
define|#
directive|define
name|set_ones
value|set_ones_D2A
define|#
directive|define
name|strcp
value|strcp_D2A
define|#
directive|define
name|strtoIg
value|strtoIg_D2A
define|#
directive|define
name|sum
value|sum_D2A
define|#
directive|define
name|tens
value|tens_D2A
define|#
directive|define
name|tinytens
value|tinytens_D2A
define|#
directive|define
name|tinytens
value|tinytens_D2A
define|#
directive|define
name|trailz
value|trailz_D2A
define|#
directive|define
name|ulp
value|ulp_D2A
specifier|extern
name|char
modifier|*
name|dtoa_result
decl_stmt|;
specifier|extern
name|CONST
name|double
name|bigtens
index|[]
decl_stmt|,
name|tens
index|[]
decl_stmt|,
name|tinytens
index|[]
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|hexdig
index|[]
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|Balloc
name|ANSI
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|Bfree
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|ULtof
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|,
name|ULong
operator|*
operator|,
name|Long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|ULtod
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|,
name|ULong
operator|*
operator|,
name|Long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|ULtodd
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|,
name|ULong
operator|*
operator|,
name|Long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|ULtoQ
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|,
name|ULong
operator|*
operator|,
name|Long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|ULtox
name|ANSI
argument_list|(
operator|(
name|UShort
operator|*
operator|,
name|ULong
operator|*
operator|,
name|Long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|ULtoxL
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|,
name|ULong
operator|*
operator|,
name|Long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|ULong
name|any_on
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|b2d
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|cmp
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|copybits
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|,
name|int
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|d2b
name|ANSI
argument_list|(
operator|(
name|double
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|decrement
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|diff
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|dtoa
name|ANSI
argument_list|(
operator|(
name|double
name|d
operator|,
name|int
name|mode
operator|,
name|int
name|ndigits
operator|,
name|int
operator|*
name|decpt
operator|,
name|int
operator|*
name|sign
operator|,
name|char
operator|*
operator|*
name|rve
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|g__fmt
name|ANSI
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|ULong
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|gethex
name|ANSI
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|*
operator|,
name|FPI
operator|*
operator|,
name|Long
operator|*
operator|,
name|Bigint
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|hexdig_init_D2A
parameter_list|(
name|Void
parameter_list|)
function_decl|;
specifier|extern
name|int
name|hexnan
name|ANSI
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|*
operator|,
name|FPI
operator|*
operator|,
name|ULong
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|hi0bits_D2A
name|ANSI
argument_list|(
operator|(
name|ULong
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|i2b
name|ANSI
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|increment
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|lo0bits
name|ANSI
argument_list|(
operator|(
name|ULong
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|lshift
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|match
name|ANSI
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|mult
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|multadd
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|nrv_alloc
name|ANSI
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|pow5mult
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|quorem
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|ratio
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rshift
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rv_alloc
name|ANSI
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|s2b
name|ANSI
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|ULong
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|set_ones
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strcp
name|ANSI
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|strtoIg
name|ANSI
argument_list|(
operator|(
name|CONST
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|FPI
operator|*
operator|,
name|Long
operator|*
operator|,
name|Bigint
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|strtod
name|ANSI
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s00
operator|,
name|char
operator|*
operator|*
name|se
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Bigint
modifier|*
name|sum
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|,
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|trailz
name|ANSI
argument_list|(
operator|(
name|Bigint
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|ulp
name|ANSI
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * NAN_WORD0 and NAN_WORD1 are only referenced in strtod.c.  Prior to  * 20050115, they used to be hard-wired here (to 0x7ff80000 and 0,  * respectively), but now are determined by compiling and running  * qnan.c to generate gd_qnan.h, which specifies d_QNAN0 and d_QNAN1.  * Formerly gdtoaimp.h recommended supplying suitable -DNAN_WORD0=...  * and -DNAN_WORD1=...  values if necessary.  This should still work.  * (On HP Series 700/800 machines, -DNAN_WORD0=0x7ff40000 works.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_MC68k
end_ifdef

begin_define
define|#
directive|define
name|_0
value|0
end_define

begin_define
define|#
directive|define
name|_1
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NAN_WORD0
end_ifndef

begin_define
define|#
directive|define
name|NAN_WORD0
value|d_QNAN0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAN_WORD1
end_ifndef

begin_define
define|#
directive|define
name|NAN_WORD1
value|d_QNAN1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_0
value|1
end_define

begin_define
define|#
directive|define
name|_1
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NAN_WORD0
end_ifndef

begin_define
define|#
directive|define
name|NAN_WORD0
value|d_QNAN1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAN_WORD1
end_ifndef

begin_define
define|#
directive|define
name|NAN_WORD1
value|d_QNAN0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|INFNAN_CHECK
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|SI
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|Sudden_Underflow
end_ifdef

begin_define
define|#
directive|define
name|SI
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SI
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GDTOAIMP_H_INCLUDED */
end_comment

end_unit

