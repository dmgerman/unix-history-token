begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2015  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Primitives for displaying the file on the screen,  * scrolling either forward or backward.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_decl_stmt
name|public
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|squished
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|no_back_scroll
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|forw_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|same_pos_bell
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|top_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|plusoption
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|forw_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|back_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ignore_eoi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|clear_bg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|final_attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|oldbot
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_decl_stmt
specifier|extern
name|int
name|size_linebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hilite_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|status_col
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TAGS
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tagoption
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Sound the bell to indicate user is trying to move past end of file.  */
end_comment

begin_function
specifier|static
name|void
name|eof_bell
parameter_list|()
block|{
if|if
condition|(
name|quiet
operator|==
name|NOT_QUIET
condition|)
name|bell
argument_list|()
expr_stmt|;
else|else
name|vbell
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the end of file is currently displayed.  */
end_comment

begin_function
name|public
name|int
name|eof_displayed
parameter_list|()
block|{
name|POSITION
name|pos
decl_stmt|;
if|if
condition|(
name|ignore_eoi
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ch_length
argument_list|()
operator|==
name|NULL_POSITION
condition|)
comment|/* 		 * If the file length is not known, 		 * we can't possibly be displaying EOF. 		 */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the bottom line is empty, we are at EOF. 	 * If the bottom line ends at the file length, 	 * we must be just at EOF. 	 */
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
return|return
operator|(
name|pos
operator|==
name|NULL_POSITION
operator|||
name|pos
operator|==
name|ch_length
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the entire file is currently displayed.  */
end_comment

begin_function
name|public
name|int
name|entire_file_displayed
parameter_list|()
block|{
name|POSITION
name|pos
decl_stmt|;
comment|/* Make sure last line of file is displayed. */
if|if
condition|(
operator|!
name|eof_displayed
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure first line of file is displayed. */
name|pos
operator|=
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pos
operator|==
name|NULL_POSITION
operator|||
name|pos
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the screen is "squished", repaint it.  * "Squished" means the first displayed line is not at the top  * of the screen; this can happen when we display a short file  * for the first time.  */
end_comment

begin_function
name|public
name|void
name|squish_check
parameter_list|()
block|{
if|if
condition|(
operator|!
name|squished
condition|)
return|return;
name|squished
operator|=
literal|0
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n lines, scrolling forward,   * starting at position pos in the input file.  * "force" means display the n lines even if we hit end of file.  * "only_last" means display only the last screenful if n> screen size.  * "nblank" is the number of blank lines to draw before the first  *   real line.  If nblank> 0, the pos must be NULL_POSITION.  *   The first real line after the blanks will start at ch_zero().  */
end_comment

begin_function
name|public
name|void
name|forw
parameter_list|(
name|n
parameter_list|,
name|pos
parameter_list|,
name|force
parameter_list|,
name|only_last
parameter_list|,
name|nblank
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|only_last
decl_stmt|;
name|int
name|nblank
decl_stmt|;
block|{
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|do_repaint
decl_stmt|;
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
name|squish_check
argument_list|()
expr_stmt|;
comment|/* 	 * do_repaint tells us not to display anything till the end,  	 * then just repaint the entire screen. 	 * We repaint if we are supposed to display only the last  	 * screenful and the request is for more than a screenful. 	 * Also if the request exceeds the forward scroll limit 	 * (but not if the request is for exactly a screenful, since 	 * repainting itself involves scrolling forward a screenful). 	 */
name|do_repaint
operator|=
operator|(
name|only_last
operator|&&
name|n
operator|>
name|sc_height
operator|-
literal|1
operator|)
operator|||
operator|(
name|forw_scroll
operator|>=
literal|0
operator|&&
name|n
operator|>
name|forw_scroll
operator|&&
name|n
operator|!=
name|sc_height
operator|-
literal|1
operator|)
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
operator|||
name|is_filtering
argument_list|()
operator|||
name|status_col
condition|)
block|{
name|prep_hilite
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
literal|4
operator|*
name|size_linebuf
argument_list|,
name|ignore_eoi
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|=
name|next_unfiltered
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|do_repaint
condition|)
block|{
if|if
condition|(
name|top_scroll
operator|&&
name|n
operator|>=
name|sc_height
operator|-
literal|1
operator|&&
name|pos
operator|!=
name|ch_length
argument_list|()
condition|)
block|{
comment|/* 			 * Start a new screen. 			 * {{ This is not really desirable if we happen 			 *    to hit eof in the middle of this screen, 			 *    but we don't yet know if that will happen. }} 			 */
name|pos_clear
argument_list|()
expr_stmt|;
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|home
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|!=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
operator|||
name|empty_screen
argument_list|()
condition|)
block|{
comment|/* 			 * This is not contiguous with what is 			 * currently displayed.  Clear the screen image  			 * (position table) and start a new screen. 			 */
name|pos_clear
argument_list|()
expr_stmt|;
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|top_scroll
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|home
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|first_time
condition|)
block|{
name|putstr
argument_list|(
literal|"...skipping...\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Read the next line of input. 		 */
if|if
condition|(
name|nblank
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Still drawing blanks; don't get a line  			 * from the file yet. 			 * If this is the last blank line, get ready to 			 * read a line starting at ch_zero() next time. 			 */
if|if
condition|(
operator|--
name|nblank
operator|==
literal|0
condition|)
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * Get the next line from the file. 			 */
name|pos
operator|=
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
name|pos
operator|=
name|next_unfiltered
argument_list|(
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 				 * End of file: stop here unless the top line  				 * is still empty, or "force" is true. 				 * Even if force is true, stop when the last 				 * line in the file reaches the top of screen. 				 */
if|if
condition|(
operator|!
name|force
operator|&&
name|position
argument_list|(
name|TOP
argument_list|)
operator|!=
name|NULL_POSITION
condition|)
break|break;
if|if
condition|(
operator|!
name|empty_lines
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|empty_lines
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|empty_lines
argument_list|(
literal|2
argument_list|,
name|sc_height
operator|-
literal|1
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 		 * Add the position of the next line to the position table. 		 * Display the current line on the screen. 		 */
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
name|do_repaint
condition|)
continue|continue;
comment|/* 		 * If this is the first screen displayed and 		 * we hit an early EOF (i.e. before the requested 		 * number of lines), we "squish" the display down 		 * at the bottom of the screen. 		 * But don't do this if a + option or a -t option 		 * was given.  These options can cause us to 		 * start the display after the beginning of the file, 		 * and it is not appropriate to squish in that case. 		 */
if|if
condition|(
name|first_time
operator|&&
name|pos
operator|==
name|NULL_POSITION
operator|&&
operator|!
name|top_scroll
operator|&&
if|#
directive|if
name|TAGS
name|tagoption
operator|==
name|NULL
operator|&&
endif|#
directive|endif
operator|!
name|plusoption
condition|)
block|{
name|squished
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|put_line
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* {{  		 * Can't call clear_eol here.  The cursor might be at end of line 		 * on an ignaw terminal, so clear_eol would clear the last char 		 * of the current line instead of all of the next line. 		 * If we really need to do this on clear_bg terminals, we need 		 * to find a better way. 		 * }} 		 */
block|if (clear_bg&& apply_at_specials(final_attr) != AT_NORMAL) 		{
comment|/* 			 * Writing the last character on the last line 			 * of the display may have scrolled the screen. 			 * If we were in standout mode, clear_bg terminals  			 * will fill the new line with the standout color. 			 * Now we're in normal mode again, so clear the line. 			 */
block|clear_eol(); 		}
endif|#
directive|endif
name|forw_prompt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nlines
operator|==
literal|0
operator|&&
name|same_pos_bell
condition|)
name|eof_bell
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|do_repaint
condition|)
name|repaint
argument_list|()
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|currline
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n lines, scrolling backward.  */
end_comment

begin_function
name|public
name|void
name|back
parameter_list|(
name|n
parameter_list|,
name|pos
parameter_list|,
name|force
parameter_list|,
name|only_last
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|do_repaint
decl_stmt|;
name|squish_check
argument_list|()
expr_stmt|;
name|do_repaint
operator|=
operator|(
name|n
operator|>
name|get_back_scroll
argument_list|()
operator|||
operator|(
name|only_last
operator|&&
name|n
operator|>
name|sc_height
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
operator|||
name|is_filtering
argument_list|()
operator|||
name|status_col
condition|)
block|{
name|prep_hilite
argument_list|(
operator|(
name|pos
operator|<
literal|3
operator|*
name|size_linebuf
operator|)
condition|?
literal|0
else|:
name|pos
operator|-
literal|3
operator|*
name|size_linebuf
argument_list|,
name|pos
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Get the previous line of input. 		 */
if|#
directive|if
name|HILITE_SEARCH
name|pos
operator|=
name|prev_unfiltered
argument_list|(
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pos
operator|=
name|back_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * Beginning of file: stop here unless "force" is true. 			 */
if|if
condition|(
operator|!
name|force
condition|)
break|break;
block|}
comment|/* 		 * Add the position of the previous line to the position table. 		 * Display the line on the screen. 		 */
name|add_back_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|do_repaint
condition|)
block|{
name|home
argument_list|()
expr_stmt|;
name|add_line
argument_list|()
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nlines
operator|==
literal|0
operator|&&
name|same_pos_bell
condition|)
name|eof_bell
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|do_repaint
condition|)
name|repaint
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|oldbot
condition|)
name|lower_left
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|currline
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n more lines, forward.  * Start just after the line currently displayed at the bottom of the screen.  */
end_comment

begin_function
name|public
name|void
name|forward
parameter_list|(
name|n
parameter_list|,
name|force
parameter_list|,
name|only_last
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
if|if
condition|(
name|get_quit_at_eof
argument_list|()
operator|&&
name|eof_displayed
argument_list|()
operator|&&
operator|!
operator|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
operator|)
condition|)
block|{
comment|/* 		 * If the -e flag is set and we're trying to go 		 * forward from end-of-file, go on to the next file. 		 */
if|if
condition|(
name|edit_next
argument_list|(
literal|1
argument_list|)
condition|)
name|quit
argument_list|(
name|QUIT_OK
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
operator|&&
operator|(
operator|!
name|force
operator|||
name|empty_lines
argument_list|(
literal|2
argument_list|,
name|sc_height
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ignore_eoi
condition|)
block|{
comment|/* 			 * ignore_eoi is to support A_F_FOREVER. 			 * Back up until there is a line at the bottom 			 * of the screen. 			 */
if|if
condition|(
name|empty_screen
argument_list|()
condition|)
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
else|else
block|{
do|do
block|{
name|back
argument_list|(
literal|1
argument_list|,
name|position
argument_list|(
name|TOP
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
do|;
block|}
block|}
else|else
block|{
name|eof_bell
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|forw
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
name|force
argument_list|,
name|only_last
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n more lines, backward.  * Start just before the line currently displayed at the top of the screen.  */
end_comment

begin_function
name|public
name|void
name|backward
parameter_list|(
name|n
parameter_list|,
name|force
parameter_list|,
name|only_last
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
operator|&&
operator|(
operator|!
name|force
operator|||
name|position
argument_list|(
name|BOTTOM
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eof_bell
argument_list|()
expr_stmt|;
return|return;
block|}
name|back
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
name|force
argument_list|,
name|only_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the backwards scroll limit.  * Must call this function instead of just using the value of  * back_scroll, because the default case depends on sc_height and  * top_scroll, as well as back_scroll.  */
end_comment

begin_function
name|public
name|int
name|get_back_scroll
parameter_list|()
block|{
if|if
condition|(
name|no_back_scroll
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|back_scroll
operator|>=
literal|0
condition|)
return|return
operator|(
name|back_scroll
operator|)
return|;
if|if
condition|(
name|top_scroll
condition|)
return|return
operator|(
name|sc_height
operator|-
literal|2
operator|)
return|;
return|return
operator|(
literal|10000
operator|)
return|;
comment|/* infinity */
block|}
end_function

end_unit

