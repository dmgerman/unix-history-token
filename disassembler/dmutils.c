begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************  *  * Module Name: dmutils - AML disassembler utilities  *  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2012, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|"accommon.h"
end_include

begin_include
include|#
directive|include
file|"amlcode.h"
end_include

begin_include
include|#
directive|include
file|"acdisasm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_ASL_COMPILER
end_ifdef

begin_include
include|#
directive|include
file|<acnamesp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DISASSEMBLER
end_ifdef

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_CA_DEBUGGER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dmutils"
argument_list|)
end_macro

begin_comment
comment|/* Data used in keeping track of fields */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|const char                      *AcpiGbl_FENames[] = {     "skip",     "?access?" };
comment|/* FE = Field Element */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Operators for Match() */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|AcpiGbl_MatchOps
index|[]
init|=
block|{
literal|"MTR"
block|,
literal|"MEQ"
block|,
literal|"MLE"
block|,
literal|"MLT"
block|,
literal|"MGE"
block|,
literal|"MGT"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Access type decoding */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|AcpiGbl_AccessTypes
index|[]
init|=
block|{
literal|"AnyAcc"
block|,
literal|"ByteAcc"
block|,
literal|"WordAcc"
block|,
literal|"DWordAcc"
block|,
literal|"QWordAcc"
block|,
literal|"BufferAcc"
block|,
literal|"InvalidAccType"
block|,
literal|"InvalidAccType"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lock rule decoding */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|AcpiGbl_LockRule
index|[]
init|=
block|{
literal|"NoLock"
block|,
literal|"Lock"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Update rule decoding */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|AcpiGbl_UpdateRules
index|[]
init|=
block|{
literal|"Preserve"
block|,
literal|"WriteAsOnes"
block|,
literal|"WriteAsZeros"
block|,
literal|"InvalidUpdateRule"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings used to decode resource descriptors */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|AcpiGbl_WordDecode
index|[]
init|=
block|{
literal|"Memory"
block|,
literal|"IO"
block|,
literal|"BusNumber"
block|,
literal|"UnknownResourceType"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|AcpiGbl_IrqDecode
index|[]
init|=
block|{
literal|"IRQNoFlags"
block|,
literal|"IRQ"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmDecodeAttribute  *  * PARAMETERS:  Attribute       - Attribute field of AccessAs keyword  *  * RETURN:      None  *  * DESCRIPTION: Decode the AccessAs attribute byte. (Mostly SMBus and  *              GenericSerialBus stuff.)  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmDecodeAttribute
parameter_list|(
name|UINT8
name|Attribute
parameter_list|)
block|{
switch|switch
condition|(
name|Attribute
condition|)
block|{
case|case
name|AML_FIELD_ATTRIB_QUICK
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribQuick"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_SEND_RCV
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribSendReceive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_BYTE
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribByte"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_WORD
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribWord"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_BLOCK
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribBlock"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_MULTIBYTE
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribBytes"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_WORD_CALL
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribProcessCall"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_BLOCK_CALL
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribBlockProcessCall"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_RAW_BYTES
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribRawBytes"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AML_FIELD_ATTRIB_RAW_PROCESS
case|:
name|AcpiOsPrintf
argument_list|(
literal|"AttribRawProcessBytes"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* A ByteConst is allowed by the grammar */
name|AcpiOsPrintf
argument_list|(
literal|"0x%2.2X"
argument_list|,
name|Attribute
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmIndent  *  * PARAMETERS:  Level               - Current source code indentation level  *  * RETURN:      None  *  * DESCRIPTION: Indent 4 spaces per indentation level.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmIndent
parameter_list|(
name|UINT32
name|Level
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Level
condition|)
block|{
return|return;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"%*.s"
argument_list|,
name|ACPI_MUL_4
argument_list|(
name|Level
argument_list|)
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmCommaIfListMember  *  * PARAMETERS:  Op              - Current operator/operand  *  * RETURN:      TRUE if a comma was inserted  *  * DESCRIPTION: Insert a comma if this Op is a member of an argument list.  *  ******************************************************************************/
end_comment

begin_function
name|BOOLEAN
name|AcpiDmCommaIfListMember
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|Common
operator|.
name|Next
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|AcpiDmListType
argument_list|(
name|Op
operator|->
name|Common
operator|.
name|Parent
argument_list|)
operator|&
name|BLOCK_COMMA_LIST
condition|)
block|{
comment|/* Check for a NULL target operand */
if|if
condition|(
operator|(
name|Op
operator|->
name|Common
operator|.
name|Next
operator|->
name|Common
operator|.
name|AmlOpcode
operator|==
name|AML_INT_NAMEPATH_OP
operator|)
operator|&&
operator|(
operator|!
name|Op
operator|->
name|Common
operator|.
name|Next
operator|->
name|Common
operator|.
name|Value
operator|.
name|String
operator|)
condition|)
block|{
comment|/*              * To handle the Divide() case where there are two optional              * targets, look ahead one more op.  If null, this null target              * is the one and only target -- no comma needed.  Otherwise,              * we need a comma to prepare for the next target.              */
if|if
condition|(
operator|!
name|Op
operator|->
name|Common
operator|.
name|Next
operator|->
name|Common
operator|.
name|Next
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|(
name|Op
operator|->
name|Common
operator|.
name|DisasmFlags
operator|&
name|ACPI_PARSEOP_PARAMLIST
operator|)
operator|&&
operator|(
operator|!
operator|(
name|Op
operator|->
name|Common
operator|.
name|Next
operator|->
name|Common
operator|.
name|DisasmFlags
operator|&
name|ACPI_PARSEOP_PARAMLIST
operator|)
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Op
operator|->
name|Common
operator|.
name|DisasmFlags
operator|&
name|ACPI_PARSEOP_PARAMLIST
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Common
operator|.
name|Next
operator|->
name|Common
operator|.
name|DisasmFlags
operator|&
name|ACPI_PARSEOP_PARAMLIST
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmCommaIfFieldMember  *  * PARAMETERS:  Op              - Current operator/operand  *  * RETURN:      None  *  * DESCRIPTION: Insert a comma if this Op is a member of a Field argument list.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmCommaIfFieldMember
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
name|Op
operator|->
name|Common
operator|.
name|Next
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

