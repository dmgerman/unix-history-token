begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Wrapper for decompressing XZ-compressed kernel, initramfs, and initrd  *  * Author: Lasse Collin<lasse.collin@tukaani.org>  *  * This file has been put into the public domain.  * You can do whatever you want with this file.  */
end_comment

begin_comment
comment|/*  * Important notes about in-place decompression  *  * At least on x86, the kernel is decompressed in place: the compressed data  * is placed to the end of the output buffer, and the decompressor overwrites  * most of the compressed data. There must be enough safety margin to  * guarantee that the write position is always behind the read position.  *  * The safety margin for XZ with LZMA2 or BCJ+LZMA2 is calculated below.  * Note that the margin with XZ is bigger than with Deflate (gzip)!  *  * The worst case for in-place decompression is that the beginning of  * the file is compressed extremely well, and the rest of the file is  * uncompressible. Thus, we must look for worst-case expansion when the  * compressor is encoding uncompressible data.  *  * The structure of the .xz file in case of a compresed kernel is as follows.  * Sizes (as bytes) of the fields are in parenthesis.  *  *    Stream Header (12)  *    Block Header:  *      Block Header (8-12)  *      Compressed Data (N)  *      Block Padding (0-3)  *      CRC32 (4)  *    Index (8-20)  *    Stream Footer (12)  *  * Normally there is exactly one Block, but let's assume that there are  * 2-4 Blocks just in case. Because Stream Header and also Block Header  * of the first Block don't make the decompressor produce any uncompressed  * data, we can ignore them from our calculations. Block Headers of possible  * additional Blocks have to be taken into account still. With these  * assumptions, it is safe to assume that the total header overhead is  * less than 128 bytes.  *  * Compressed Data contains LZMA2 or BCJ+LZMA2 encoded data. Since BCJ  * doesn't change the size of the data, it is enough to calculate the  * safety margin for LZMA2.  *  * LZMA2 stores the data in chunks. Each chunk has a header whose size is  * a maximum of 6 bytes, but to get round 2^n numbers, let's assume that  * the maximum chunk header size is 8 bytes. After the chunk header, there  * may be up to 64 KiB of actual payload in the chunk. Often the payload is  * quite a bit smaller though; to be safe, let's assume that an average  * chunk has only 32 KiB of payload.  *  * The maximum uncompressed size of the payload is 2 MiB. The minimum  * uncompressed size of the payload is in practice never less than the  * payload size itself. The LZMA2 format would allow uncompressed size  * to be less than the payload size, but no sane compressor creates such  * files. LZMA2 supports storing uncompressible data in uncompressed form,  * so there's never a need to create payloads whose uncompressed size is  * smaller than the compressed size.  *  * The assumption, that the uncompressed size of the payload is never  * smaller than the payload itself, is valid only when talking about  * the payload as a whole. It is possible that the payload has parts where  * the decompressor consumes more input than it produces output. Calculating  * the worst case for this would be tricky. Instead of trying to do that,  * let's simply make sure that the decompressor never overwrites any bytes  * of the payload which it is currently reading.  *  * Now we have enough information to calculate the safety margin. We need  *   - 128 bytes for the .xz file format headers;  *   - 8 bytes per every 32 KiB of uncompressed size (one LZMA2 chunk header  *     per chunk, each chunk having average payload size of 32 KiB); and  *   - 64 KiB (biggest possible LZMA2 chunk payload size) to make sure that  *     the decompressor never overwrites anything from the LZMA2 chunk  *     payload it is currently reading.  *  * We get the following formula:  *  *    safety_margin = 128 + uncompressed_size * 8 / 32768 + 65536  *                  = 128 + (uncompressed_size>> 12) + 65536  *  * For comparison, according to arch/x86/boot/compressed/misc.c, the  * equivalent formula for Deflate is this:  *  *    safety_margin = 18 + (uncompressed_size>> 12) + 32768  *  * Thus, when updating Deflate-only in-place kernel decompressor to  * support XZ, the fixed overhead has to be increased from 18+32768 bytes  * to 128+65536 bytes.  */
end_comment

begin_comment
comment|/*  * STATIC is defined to "static" if we are being built for kernel  * decompression (pre-boot code).<linux/decompress/mm.h> will define  * STATIC to empty if it wasn't already defined. Since we will need to  * know later if we are being used for kernel decompression, we define  * XZ_PREBOOT here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC
end_ifdef

begin_define
define|#
directive|define
name|XZ_PREBOOT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL__
end_ifdef

begin_include
include|#
directive|include
file|<linux/decompress/mm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XZ_EXTERN
value|STATIC
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|XZ_PREBOOT
end_ifndef

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/xz.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Use the internal CRC32 code instead of kernel's CRC32 module, which  * is not available in early phase of booting.  */
end_comment

begin_define
define|#
directive|define
name|XZ_INTERNAL_CRC32
value|1
end_define

begin_comment
comment|/*  * For boot time use, we enable only the BCJ filter of the current  * architecture or none if no BCJ filter is available for the architecture.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_X86
end_ifdef

begin_define
define|#
directive|define
name|XZ_DEC_X86
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PPC
end_ifdef

begin_define
define|#
directive|define
name|XZ_DEC_POWERPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_ARM
end_ifdef

begin_define
define|#
directive|define
name|XZ_DEC_ARM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_IA64
end_ifdef

begin_define
define|#
directive|define
name|XZ_DEC_IA64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_SPARC
end_ifdef

begin_define
define|#
directive|define
name|XZ_DEC_SPARC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This will get the basic headers so that memeq() and others  * can be defined.  */
end_comment

begin_include
include|#
directive|include
file|"xz/xz_private.h"
end_include

begin_comment
comment|/*  * Replace the normal allocation functions with the versions from  *<linux/decompress/mm.h>. vfree() needs to support vfree(NULL)  * when XZ_DYNALLOC is used, but the pre-boot free() doesn't support it.  * Workaround it here because the other decompressors don't need it.  */
end_comment

begin_undef
undef|#
directive|undef
name|kmalloc
end_undef

begin_undef
undef|#
directive|undef
name|kfree
end_undef

begin_undef
undef|#
directive|undef
name|vmalloc
end_undef

begin_undef
undef|#
directive|undef
name|vfree
end_undef

begin_define
define|#
directive|define
name|kmalloc
parameter_list|(
name|size
parameter_list|,
name|flags
parameter_list|)
value|malloc(size)
end_define

begin_define
define|#
directive|define
name|kfree
parameter_list|(
name|ptr
parameter_list|)
value|free(ptr)
end_define

begin_define
define|#
directive|define
name|vmalloc
parameter_list|(
name|size
parameter_list|)
value|malloc(size)
end_define

begin_define
define|#
directive|define
name|vfree
parameter_list|(
name|ptr
parameter_list|)
value|do { if (ptr != NULL) free(ptr); } while (0)
end_define

begin_comment
comment|/*  * FIXME: Not all basic memory functions are provided in architecture-specific  * files (yet). We define our own versions here for now, but this should be  * only a temporary solution.  *  * memeq and memzero are not used much and any remotely sane implementation  * is fast enough. memcpy/memmove speed matters in multi-call mode, but  * the kernel image is decompressed in single-call mode, in which only  * memcpy speed can matter and only if there is a lot of uncompressible data  * (LZMA2 stores uncompressible chunks in uncompressed form). Thus, the  * functions below should just be kept small; it's probably not worth  * optimizing for speed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|memeq
end_ifndef

begin_function
specifier|static
name|bool
name|memeq
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|x
init|=
name|a
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|y
init|=
name|b
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|x
index|[
name|i
index|]
operator|!=
name|y
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|memzero
end_ifndef

begin_function
specifier|static
name|void
name|memzero
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|b
init|=
name|buf
decl_stmt|;
name|uint8_t
modifier|*
name|e
init|=
name|b
operator|+
name|size
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|e
condition|)
operator|*
name|b
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|memmove
end_ifndef

begin_comment
comment|/* Not static to avoid a conflict with the prototype in the Linux headers. */
end_comment

begin_function
name|void
modifier|*
name|memmove
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|d
init|=
name|dest
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|s
init|=
name|src
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|<
name|s
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|d
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|>
name|s
condition|)
block|{
name|i
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|d
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Since we need memmove anyway, would use it as memcpy too.  * Commented out for now to avoid breaking things.  */
end_comment

begin_comment
comment|/* #ifndef memcpy #	define memcpy memmove #endif */
end_comment

begin_include
include|#
directive|include
file|"xz/xz_crc32.c"
end_include

begin_include
include|#
directive|include
file|"xz/xz_dec_stream.c"
end_include

begin_include
include|#
directive|include
file|"xz/xz_dec_lzma2.c"
end_include

begin_include
include|#
directive|include
file|"xz/xz_dec_bcj.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XZ_PREBOOT */
end_comment

begin_comment
comment|/* Size of the input and output buffers in multi-call mode */
end_comment

begin_define
define|#
directive|define
name|XZ_IOBUF_SIZE
value|4096
end_define

begin_comment
comment|/*  * This function implements the API defined in<linux/decompress/generic.h>.  *  * This wrapper will automatically choose single-call or multi-call mode  * of the native XZ decoder API. The single-call mode can be used only when  * both input and output buffers are available as a single chunk, i.e. when  * fill() and flush() won't be used.  */
end_comment

begin_function
name|STATIC
name|int
name|INIT
name|unxz
parameter_list|(
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|int
name|in_size
parameter_list|,
name|int
function_decl|(
modifier|*
name|fill
function_decl|)
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|flush
function_decl|)
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|,
name|int
modifier|*
name|in_used
parameter_list|,
name|void
function_decl|(
modifier|*
name|error
function_decl|)
parameter_list|(
name|char
modifier|*
name|x
parameter_list|)
parameter_list|)
block|{
name|struct
name|xz_buf
name|b
decl_stmt|;
name|struct
name|xz_dec
modifier|*
name|s
decl_stmt|;
name|enum
name|xz_ret
name|ret
decl_stmt|;
name|bool
name|must_free_in
init|=
name|false
decl_stmt|;
if|#
directive|if
name|XZ_INTERNAL_CRC32
name|xz_crc32_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|in_used
operator|!=
name|NULL
condition|)
operator|*
name|in_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fill
operator|==
name|NULL
operator|&&
name|flush
operator|==
name|NULL
condition|)
name|s
operator|=
name|xz_dec_init
argument_list|(
name|XZ_SINGLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|xz_dec_init
argument_list|(
name|XZ_DYNALLOC
argument_list|,
operator|(
name|uint32_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|error_alloc_state
goto|;
if|if
condition|(
name|flush
operator|==
name|NULL
condition|)
block|{
name|b
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|b
operator|.
name|out_size
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|out_size
operator|=
name|XZ_IOBUF_SIZE
expr_stmt|;
name|b
operator|.
name|out
operator|=
name|malloc
argument_list|(
name|XZ_IOBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|out
operator|==
name|NULL
condition|)
goto|goto
name|error_alloc_out
goto|;
block|}
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|must_free_in
operator|=
name|true
expr_stmt|;
name|in
operator|=
name|malloc
argument_list|(
name|XZ_IOBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
goto|goto
name|error_alloc_in
goto|;
block|}
name|b
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|b
operator|.
name|in_pos
operator|=
literal|0
expr_stmt|;
name|b
operator|.
name|in_size
operator|=
name|in_size
expr_stmt|;
name|b
operator|.
name|out_pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fill
operator|==
name|NULL
operator|&&
name|flush
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|xz_dec_run
argument_list|(
name|s
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|b
operator|.
name|in_pos
operator|==
name|b
operator|.
name|in_size
operator|&&
name|fill
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|in_used
operator|!=
name|NULL
condition|)
operator|*
name|in_used
operator|+=
name|b
operator|.
name|in_pos
expr_stmt|;
name|b
operator|.
name|in_pos
operator|=
literal|0
expr_stmt|;
name|in_size
operator|=
name|fill
argument_list|(
name|in
argument_list|,
name|XZ_IOBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_size
operator|<
literal|0
condition|)
block|{
comment|/* 					 * This isn't an optimal error code 					 * but it probably isn't worth making 					 * a new one either. 					 */
name|ret
operator|=
name|XZ_BUF_ERROR
expr_stmt|;
break|break;
block|}
name|b
operator|.
name|in_size
operator|=
name|in_size
expr_stmt|;
block|}
name|ret
operator|=
name|xz_dec_run
argument_list|(
name|s
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|!=
name|NULL
operator|&&
operator|(
name|b
operator|.
name|out_pos
operator|==
name|b
operator|.
name|out_size
operator|||
operator|(
name|ret
operator|!=
name|XZ_OK
operator|&&
name|b
operator|.
name|out_pos
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 				 * Setting ret here may hide an error 				 * returned by xz_dec_run(), but probably 				 * it's not too bad. 				 */
if|if
condition|(
name|flush
argument_list|(
name|b
operator|.
name|out
argument_list|,
name|b
operator|.
name|out_pos
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|b
operator|.
name|out_pos
condition|)
name|ret
operator|=
name|XZ_BUF_ERROR
expr_stmt|;
name|b
operator|.
name|out_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ret
operator|==
name|XZ_OK
condition|)
do|;
if|if
condition|(
name|must_free_in
condition|)
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|b
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_used
operator|!=
name|NULL
condition|)
operator|*
name|in_used
operator|+=
name|b
operator|.
name|in_pos
expr_stmt|;
name|xz_dec_end
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|XZ_STREAM_END
case|:
return|return
literal|0
return|;
case|case
name|XZ_MEM_ERROR
case|:
comment|/* This can occur only in multi-call mode. */
name|error
argument_list|(
literal|"XZ decompressor ran out of memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XZ_FORMAT_ERROR
case|:
name|error
argument_list|(
literal|"Input is not in the XZ format (wrong magic bytes)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XZ_OPTIONS_ERROR
case|:
name|error
argument_list|(
literal|"Input was encoded with settings that are not "
literal|"supported by this XZ decoder"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XZ_DATA_ERROR
case|:
case|case
name|XZ_BUF_ERROR
case|:
name|error
argument_list|(
literal|"XZ-compressed data is corrupt"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bug in the XZ decompressor"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|-
literal|1
return|;
name|error_alloc_in
label|:
if|if
condition|(
name|flush
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|b
operator|.
name|out
argument_list|)
expr_stmt|;
name|error_alloc_out
label|:
name|xz_dec_end
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error_alloc_state
label|:
name|error
argument_list|(
literal|"XZ decompressor ran out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This macro is used by architecture-specific files to decompress  * the kernel image.  */
end_comment

begin_define
define|#
directive|define
name|decompress
value|unxz
end_define

end_unit

