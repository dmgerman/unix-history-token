begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: ah_osdep.c,v 1.3 2008/11/10 04:08:05 sam Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EXPORT_SYMTAB
end_ifndef

begin_define
define|#
directive|define
name|EXPORT_SYMTAB
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<linux/config.h>
end_include

begin_include
include|#
directive|include
file|<linux/version.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/init.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<linux/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<linux/proc_fs.h>
end_include

begin_include
include|#
directive|include
file|<asm/io.h>
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__MOD_INC_USE_COUNT
end_ifndef

begin_define
define|#
directive|define
name|AH_MOD_INC_USE_COUNT
parameter_list|(
name|_m
parameter_list|)
define|\
value|if (!try_module_get(_m)) {					\ 		printk(KERN_WARNING "try_module_get failed\n");		\ 		return NULL;						\ 	}
end_define

begin_define
define|#
directive|define
name|AH_MOD_DEC_USE_COUNT
parameter_list|(
name|_m
parameter_list|)
value|module_put(_m)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AH_MOD_INC_USE_COUNT
parameter_list|(
name|_m
parameter_list|)
value|MOD_INC_USE_COUNT
end_define

begin_define
define|#
directive|define
name|AH_MOD_DEC_USE_COUNT
parameter_list|(
name|_m
parameter_list|)
value|MOD_DEC_USE_COUNT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ath_hal_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|ath_hal_dma_beacon_response_time
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in TU's */
end_comment

begin_decl_stmt
name|int
name|ath_hal_sw_beacon_response_time
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in TU's */
end_comment

begin_decl_stmt
name|int
name|ath_hal_additional_swba_backoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in TU's */
end_comment

begin_function
name|struct
name|ath_hal
modifier|*
name|_ath_hal_attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|HAL_SOFTC
name|sc
parameter_list|,
name|HAL_BUS_TAG
name|t
parameter_list|,
name|HAL_BUS_HANDLE
name|h
parameter_list|,
name|void
modifier|*
name|s
parameter_list|)
block|{
name|HAL_STATUS
name|status
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|ath_hal_attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|t
argument_list|,
name|h
argument_list|,
operator|&
name|status
argument_list|)
decl_stmt|;
operator|*
operator|(
name|HAL_STATUS
operator|*
operator|)
name|s
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|ah
condition|)
name|AH_MOD_INC_USE_COUNT
argument_list|(
name|THIS_MODULE
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
block|}
end_function

begin_function
name|void
name|ath_hal_detach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
call|(
modifier|*
name|ah
operator|->
name|ah_detach
call|)
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|AH_MOD_DEC_USE_COUNT
argument_list|(
name|THIS_MODULE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print/log message support.  */
end_comment

begin_function
name|void
name|__ahdecl
name|ath_hal_vprintf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* XXX */
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__ahdecl
name|ath_hal_printf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ath_hal_vprintf
argument_list|(
name|ah
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_printf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Format an Ethernet MAC for printing.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|__ahdecl
name|ath_hal_ether_sprintf
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
specifier|static
name|char
name|etherbuf
index|[
literal|18
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|etherbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbuf
argument_list|)
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
name|etherbuf
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AH_ASSERT
end_ifdef

begin_function
name|void
name|__ahdecl
name|ath_hal_assert_failed
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|printk
argument_list|(
literal|"Atheros HAL assertion failure: %s: line %u: %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ath_hal_assert"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_ASSERT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG_ALQ
end_ifdef

begin_comment
comment|/*  * ALQ register tracing support.  *  * Setting hw.ath.hal.alq=1 enables tracing of all register reads and  * writes to the file /tmp/ath_hal.log.  The file format is a simple  * fixed-size array of records.  When done logging set hw.ath.hal.alq=0  * and then decode the file with the ardecode program (that is part of the  * HAL).  If you start+stop tracing the data will be appended to an  * existing file.  *  * NB: doesn't handle multiple devices properly; only one DEVICE record  *     is emitted and the different devices are not identified.  */
end_comment

begin_include
include|#
directive|include
file|"alq/alq.h"
end_include

begin_include
include|#
directive|include
file|"ah_decode.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|alq
modifier|*
name|ath_hal_alq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_hal_alq_emitdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need to emit DEVICE record */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|ath_hal_alq_lost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of lost records */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ath_hal_logfile
init|=
literal|"/tmp/ath_hal.log"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|ath_hal_alq_qsize
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ath_hal_setlogging
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_NET_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|error
operator|=
name|alq_open
argument_list|(
operator|&
name|ath_hal_alq
argument_list|,
name|ath_hal_logfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|athregrec
argument_list|)
argument_list|,
name|ath_hal_alq_qsize
argument_list|)
expr_stmt|;
name|ath_hal_alq_lost
operator|=
literal|0
expr_stmt|;
name|ath_hal_alq_emitdev
operator|=
literal|1
expr_stmt|;
name|printk
argument_list|(
literal|"ath_hal: logging to %s %s\n"
argument_list|,
name|ath_hal_logfile
argument_list|,
name|error
operator|==
literal|0
condition|?
literal|"enabled"
else|:
literal|"could not be setup"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ath_hal_alq
condition|)
name|alq_close
argument_list|(
name|ath_hal_alq
argument_list|)
expr_stmt|;
name|ath_hal_alq
operator|=
name|NULL
expr_stmt|;
name|printk
argument_list|(
literal|"ath_hal: logging disabled\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Deal with the sysctl handler api changing.  */
end_comment

begin_if
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|8
argument_list|)
end_if

begin_define
define|#
directive|define
name|AH_SYSCTL_ARGS_DECL
define|\
value|ctl_table *ctl, int write, struct file *filp, void *buffer, \ 		size_t *lenp
end_define

begin_define
define|#
directive|define
name|AH_SYSCTL_ARGS
value|ctl, write, filp, buffer, lenp
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LINUX_VERSION_CODE>= KERNEL_VERSION(2,6,8) */
end_comment

begin_define
define|#
directive|define
name|AH_SYSCTL_ARGS_DECL
define|\
value|ctl_table *ctl, int write, struct file *filp, void *buffer,\ 		size_t *lenp, loff_t *ppos
end_define

begin_define
define|#
directive|define
name|AH_SYSCTL_ARGS
value|ctl, write, filp, buffer, lenp, ppos
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sysctl_hw_ath_hal_log
parameter_list|(
name|AH_SYSCTL_ARGS_DECL
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|enable
decl_stmt|;
name|ctl
operator|->
name|data
operator|=
operator|&
name|enable
expr_stmt|;
name|ctl
operator|->
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|enable
argument_list|)
expr_stmt|;
name|enable
operator|=
operator|(
name|ath_hal_alq
operator|!=
name|NULL
operator|)
expr_stmt|;
name|error
operator|=
name|proc_dointvec
argument_list|(
name|AH_SYSCTL_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|write
condition|)
return|return
name|error
return|;
else|else
return|return
name|ath_hal_setlogging
argument_list|(
name|enable
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ale
modifier|*
name|ath_hal_alq_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ale
modifier|*
name|ale
decl_stmt|;
if|if
condition|(
name|ath_hal_alq_emitdev
condition|)
block|{
name|ale
operator|=
name|alq_get
argument_list|(
name|ath_hal_alq
argument_list|,
name|ALQ_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ale
condition|)
block|{
name|struct
name|athregrec
modifier|*
name|r
init|=
operator|(
expr|struct
name|athregrec
operator|*
operator|)
name|ale
operator|->
name|ae_data
decl_stmt|;
name|r
operator|->
name|op
operator|=
name|OP_DEVICE
expr_stmt|;
name|r
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|val
operator|=
name|ah
operator|->
name|ah_devid
expr_stmt|;
name|alq_post
argument_list|(
name|ath_hal_alq
argument_list|,
name|ale
argument_list|)
expr_stmt|;
name|ath_hal_alq_emitdev
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ath_hal_alq_lost
operator|++
expr_stmt|;
block|}
name|ale
operator|=
name|alq_get
argument_list|(
name|ath_hal_alq
argument_list|,
name|ALQ_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ale
condition|)
name|ath_hal_alq_lost
operator|++
expr_stmt|;
return|return
name|ale
return|;
block|}
end_function

begin_function
name|void
name|__ahdecl
name|ath_hal_reg_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|ath_hal_alq
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ale
modifier|*
name|ale
decl_stmt|;
name|local_irq_save
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ale
operator|=
name|ath_hal_alq_get
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ale
condition|)
block|{
name|struct
name|athregrec
modifier|*
name|r
init|=
operator|(
expr|struct
name|athregrec
operator|*
operator|)
name|ale
operator|->
name|ae_data
decl_stmt|;
name|r
operator|->
name|op
operator|=
name|OP_WRITE
expr_stmt|;
name|r
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|r
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|alq_post
argument_list|(
name|ath_hal_alq
argument_list|,
name|ale
argument_list|)
expr_stmt|;
block|}
name|local_irq_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|_OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_reg_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|uint32_t
name|__ahdecl
name|ath_hal_reg_read
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|_OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_alq
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ale
modifier|*
name|ale
decl_stmt|;
name|local_irq_save
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ale
operator|=
name|ath_hal_alq_get
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ale
condition|)
block|{
name|struct
name|athregrec
modifier|*
name|r
init|=
operator|(
expr|struct
name|athregrec
operator|*
operator|)
name|ale
operator|->
name|ae_data
decl_stmt|;
name|r
operator|->
name|op
operator|=
name|OP_READ
expr_stmt|;
name|r
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|r
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|alq_post
argument_list|(
name|ath_hal_alq
argument_list|,
name|ale
argument_list|)
expr_stmt|;
block|}
name|local_irq_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_reg_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|__ahdecl
name|OS_MARK
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|id
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
if|if
condition|(
name|ath_hal_alq
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ale
modifier|*
name|ale
decl_stmt|;
name|local_irq_save
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ale
operator|=
name|ath_hal_alq_get
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ale
condition|)
block|{
name|struct
name|athregrec
modifier|*
name|r
init|=
operator|(
expr|struct
name|athregrec
operator|*
operator|)
name|ale
operator|->
name|ae_data
decl_stmt|;
name|r
operator|->
name|op
operator|=
name|OP_MARK
expr_stmt|;
name|r
operator|->
name|reg
operator|=
name|id
expr_stmt|;
name|r
operator|->
name|val
operator|=
name|v
expr_stmt|;
name|alq_post
argument_list|(
name|ath_hal_alq
argument_list|,
name|ale
argument_list|)
expr_stmt|;
block|}
name|local_irq_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|OS_MARK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|AH_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|AH_REGOPS_FUNC
argument_list|)
end_elif

begin_comment
comment|/*  * Memory-mapped device register read/write.  These are here  * as routines when debugging support is enabled and/or when  * explicitly configured to use function calls.  The latter is  * for architectures that might need to do something before  * referencing memory (e.g. remap an i/o window).  *  * NB: see the comments in ah_osdep.h about byte-swapping register  *     reads and writes to understand what's going on below.  */
end_comment

begin_function
name|void
name|__ahdecl
name|ath_hal_reg_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
if|if
condition|(
name|ath_hal_debug
operator|>
literal|1
condition|)
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"WRITE 0x%x<= 0x%x\n"
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_reg_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|uint32_t
name|__ahdecl
name|ath_hal_reg_read
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|reg
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|_OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_DEBUG
if|if
condition|(
name|ath_hal_debug
operator|>
literal|1
condition|)
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"READ 0x%x => 0x%x\n"
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|val
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_reg_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_DEBUG || AH_REGOPS_FUNC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_function
name|void
name|__ahdecl
name|HALDEBUG
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|ath_hal_debug
condition|)
block|{
name|__va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ath_hal_vprintf
argument_list|(
name|ah
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|__ahdecl
name|HALDEBUGn
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|ath_hal_debug
operator|>=
name|level
condition|)
block|{
name|__va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ath_hal_vprintf
argument_list|(
name|ah
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_DEBUG */
end_comment

begin_comment
comment|/*  * Delay n microseconds.  */
end_comment

begin_function
name|void
name|__ahdecl
name|ath_hal_delay
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|udelay
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|__ahdecl
name|ath_hal_getuptime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
operator|(
name|jiffies
operator|/
name|HZ
operator|)
operator|*
literal|1000
operator|)
operator|+
operator|(
name|jiffies
operator|%
name|HZ
operator|)
operator|*
operator|(
literal|1000
operator|/
name|HZ
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_getuptime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocate/free memory.  */
end_comment

begin_function
name|void
modifier|*
name|__ahdecl
name|ath_hal_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|kmalloc
argument_list|(
name|size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|OS_MEMZERO
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|__ahdecl
name|ath_hal_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|kfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__ahdecl
name|ath_hal_memzero
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_memzero
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
modifier|*
name|__ahdecl
name|ath_hal_memcpy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_memcpy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|__ahdecl
name|ath_hal_memcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
name|memcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_memcmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_SYSCTL
end_ifdef

begin_enum
enum|enum
block|{
name|DEV_ATH
init|=
literal|9
block|,
comment|/* XXX must match driver */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|CTL_AUTO
value|-2
end_define

begin_comment
comment|/* cannot be CTL_ANY or CTL_NONE */
end_comment

begin_decl_stmt
specifier|static
name|ctl_table
name|ath_hal_sysctls
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"debug"
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|data
operator|=
operator|&
name|ath_hal_debug
block|,
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|ath_hal_debug
argument_list|)
block|,
operator|.
name|proc_handler
operator|=
name|proc_dointvec
block|}
block|,
endif|#
directive|endif
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"dma_beacon_response_time"
block|,
operator|.
name|data
operator|=
operator|&
name|ath_hal_dma_beacon_response_time
block|,
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|ath_hal_dma_beacon_response_time
argument_list|)
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|proc_handler
operator|=
name|proc_dointvec
block|}
block|,
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"sw_beacon_response_time"
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|data
operator|=
operator|&
name|ath_hal_sw_beacon_response_time
block|,
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|ath_hal_sw_beacon_response_time
argument_list|)
block|,
operator|.
name|proc_handler
operator|=
name|proc_dointvec
block|}
block|,
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"swba_backoff"
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|data
operator|=
operator|&
name|ath_hal_additional_swba_backoff
block|,
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|ath_hal_additional_swba_backoff
argument_list|)
block|,
operator|.
name|proc_handler
operator|=
name|proc_dointvec
block|}
block|,
ifdef|#
directive|ifdef
name|AH_DEBUG_ALQ
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"alq"
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|proc_handler
operator|=
name|sysctl_hw_ath_hal_log
block|}
block|,
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"alq_size"
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|data
operator|=
operator|&
name|ath_hal_alq_qsize
block|,
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|ath_hal_alq_qsize
argument_list|)
block|,
operator|.
name|proc_handler
operator|=
name|proc_dointvec
block|}
block|,
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"alq_lost"
block|,
operator|.
name|mode
operator|=
literal|0644
block|,
operator|.
name|data
operator|=
operator|&
name|ath_hal_alq_lost
block|,
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|ath_hal_alq_lost
argument_list|)
block|,
operator|.
name|proc_handler
operator|=
name|proc_dointvec
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ctl_table
name|ath_hal_table
index|[]
init|=
block|{
block|{
operator|.
name|ctl_name
operator|=
name|CTL_AUTO
block|,
operator|.
name|procname
operator|=
literal|"hal"
block|,
operator|.
name|mode
operator|=
literal|0555
block|,
operator|.
name|child
operator|=
name|ath_hal_sysctls
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ctl_table
name|ath_ath_table
index|[]
init|=
block|{
block|{
operator|.
name|ctl_name
operator|=
name|DEV_ATH
block|,
operator|.
name|procname
operator|=
literal|"ath"
block|,
operator|.
name|mode
operator|=
literal|0555
block|,
operator|.
name|child
operator|=
name|ath_hal_table
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ctl_table
name|ath_root_table
index|[]
init|=
block|{
block|{
operator|.
name|ctl_name
operator|=
name|CTL_DEV
block|,
operator|.
name|procname
operator|=
literal|"dev"
block|,
operator|.
name|mode
operator|=
literal|0555
block|,
operator|.
name|child
operator|=
name|ath_ath_table
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_table_header
modifier|*
name|ath_hal_sysctl_header
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ath_hal_sysctl_register
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|ath_hal_sysctl_header
operator|=
name|register_sysctl_table
argument_list|(
name|ath_root_table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ath_hal_sysctl_unregister
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ath_hal_sysctl_header
condition|)
name|unregister_sysctl_table
argument_list|(
name|ath_hal_sysctl_header
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_SYSCTL */
end_comment

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dev_info
init|=
literal|"ath_hal"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Errno Consulting, Sam Leffler"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Atheros Hardware Access Layer (HAL)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_SUPPORTED_DEVICE
argument_list|(
literal|"Atheros WLAN devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MODULE_LICENSE
end_ifdef

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Proprietary"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_probe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|_ath_hal_attach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_detach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_init_channels
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_getwirelessmodes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_computetxtime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_mhz2ieee
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ath_hal_process_noisefloor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|__init
name|init_ath_hal
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: %s ("
argument_list|,
name|dev_info
argument_list|,
name|ath_hal_version
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ath_hal_buildopts
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|printk
argument_list|(
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|ath_hal_buildopts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
name|printk
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_SYSCTL
name|ath_hal_sysctl_register
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|init_ath_hal
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|__exit
name|exit_ath_hal
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_SYSCTL
name|ath_hal_sysctl_unregister
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: driver unloaded\n"
argument_list|,
name|dev_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_exit
argument_list|(
name|exit_ath_hal
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

