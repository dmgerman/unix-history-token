begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* test/heartbeat_test.c */
end_comment

begin_comment
comment|/*  * Unit test for TLS heartbeats.  *  * Acts as a regression test against the Heartbleed bug (CVE-2014-0160).  *  * Author:  Mike Bland (mbland@acm.org, http://mike-bland.com/)  * Date:    2014-04-12  * License: Creative Commons Attribution 4.0 International (CC By 4.0)  *          http://creativecommons.org/licenses/by/4.0/deed.en_US  *  * OUTPUT  * ------  * The program returns zero on success. It will print a message with a count  * of the number of failed tests and return nonzero if any tests fail.  *  * It will print the contents of the request and response buffers for each  * failing test. In a "fixed" version, all the tests should pass and there  * should be no output.  *  * In a "bleeding" version, you'll see:  *  *   test_dtls1_heartbleed failed:  *     expected payload len: 0  *     received: 1024  *   sent 26 characters  *     "HEARTBLEED                "  *   received 1024 characters  *     "HEARTBLEED                \xde\xad\xbe\xef..."  *   ** test_dtls1_heartbleed failed **  *  * The contents of the returned buffer in the failing test will depend on the  * contents of memory on your machine.  *  * MORE INFORMATION  * ----------------  * http://mike-bland.com/2014/04/12/heartbleed.html  * http://mike-bland.com/tags/heartbleed.html  */
end_comment

begin_define
define|#
directive|define
name|OPENSSL_UNIT_TEST
end_define

begin_include
include|#
directive|include
file|"../test/testutil.h"
end_include

begin_include
include|#
directive|include
file|"../ssl/ssl_locl.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_HEARTBEATS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_UNIT_TEST
argument_list|)
end_if

begin_comment
comment|/* As per https://tools.ietf.org/html/rfc6520#section-4 */
end_comment

begin_define
define|#
directive|define
name|MIN_PADDING_SIZE
value|16
end_define

begin_comment
comment|/* Maximum number of payload characters to print as test output */
end_comment

begin_define
define|#
directive|define
name|MAX_PRINTABLE_CHARACTERS
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
name|heartbeat_test_fixture
block|{
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|SSL
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|test_case_name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|process_heartbeat
function_decl|)
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
function_decl|;
name|unsigned
name|char
modifier|*
name|payload
decl_stmt|;
name|int
name|sent_payload_len
decl_stmt|;
name|int
name|expected_return_value
decl_stmt|;
name|int
name|return_payload_offset
decl_stmt|;
name|int
name|expected_payload_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected_return_payload
decl_stmt|;
block|}
name|HEARTBEAT_TEST_FIXTURE
typedef|;
end_typedef

begin_function
specifier|static
name|HEARTBEAT_TEST_FIXTURE
name|set_up
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|test_case_name
parameter_list|,
specifier|const
name|SSL_METHOD
modifier|*
name|meth
parameter_list|)
block|{
name|HEARTBEAT_TEST_FIXTURE
name|fixture
decl_stmt|;
name|int
name|setup_ok
init|=
literal|1
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fixture
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fixture
argument_list|)
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|test_case_name
operator|=
name|test_case_name
expr_stmt|;
name|fixture
operator|.
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|meth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixture
operator|.
name|ctx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to allocate SSL_CTX for test: %s\n"
argument_list|,
name|test_case_name
argument_list|)
expr_stmt|;
name|setup_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fixture
operator|.
name|s
operator|=
name|SSL_new
argument_list|(
name|fixture
operator|.
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixture
operator|.
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to allocate SSL for test: %s\n"
argument_list|,
name|test_case_name
argument_list|)
expr_stmt|;
name|setup_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|ssl_init_wbio_buffer
argument_list|(
name|fixture
operator|.
name|s
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to set up wbio buffer for test: %s\n"
argument_list|,
name|test_case_name
argument_list|)
expr_stmt|;
name|setup_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|ssl3_setup_buffers
argument_list|(
name|fixture
operator|.
name|s
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to setup buffers for test: %s\n"
argument_list|,
name|test_case_name
argument_list|)
expr_stmt|;
name|setup_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear the memory for the return buffer, since this isn't automatically 	 * zeroed in opt mode and will cause spurious test failures that will change 	 * with each execution. 	 */
name|memset
argument_list|(
name|fixture
operator|.
name|s
operator|->
name|s3
operator|->
name|wbuf
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|fixture
operator|.
name|s
operator|->
name|s3
operator|->
name|wbuf
operator|.
name|len
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
operator|!
name|setup_ok
condition|)
block|{
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|fixture
return|;
block|}
end_function

begin_function
specifier|static
name|HEARTBEAT_TEST_FIXTURE
name|set_up_dtls
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|test_case_name
parameter_list|)
block|{
name|HEARTBEAT_TEST_FIXTURE
name|fixture
init|=
name|set_up
argument_list|(
name|test_case_name
argument_list|,
name|DTLSv1_server_method
argument_list|()
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|process_heartbeat
operator|=
name|dtls1_process_heartbeat
expr_stmt|;
comment|/* As per dtls1_get_record(), skipping the following from the beginning of 	 * the returned heartbeat message: 	 * type-1 byte; version-2 bytes; sequence number-8 bytes; length-2 bytes 	 * 	 * And then skipping the 1-byte type encoded by process_heartbeat for 	 * a total of 14 bytes, at which point we can grab the length and the 	 * payload we seek. 	 */
name|fixture
operator|.
name|return_payload_offset
operator|=
literal|14
expr_stmt|;
return|return
name|fixture
return|;
block|}
end_function

begin_comment
comment|/* Needed by ssl3_write_bytes() */
end_comment

begin_function
specifier|static
name|int
name|dummy_handshake
parameter_list|(
name|SSL
modifier|*
name|s
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|HEARTBEAT_TEST_FIXTURE
name|set_up_tls
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|test_case_name
parameter_list|)
block|{
name|HEARTBEAT_TEST_FIXTURE
name|fixture
init|=
name|set_up
argument_list|(
name|test_case_name
argument_list|,
name|TLSv1_server_method
argument_list|()
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|process_heartbeat
operator|=
name|tls1_process_heartbeat
expr_stmt|;
name|fixture
operator|.
name|s
operator|->
name|handshake_func
operator|=
name|dummy_handshake
expr_stmt|;
comment|/* As per do_ssl3_write(), skipping the following from the beginning of 	 * the returned heartbeat message: 	 * type-1 byte; version-2 bytes; length-2 bytes 	 * 	 * And then skipping the 1-byte type encoded by process_heartbeat for 	 * a total of 6 bytes, at which point we can grab the length and the payload 	 * we seek. 	 */
name|fixture
operator|.
name|return_payload_offset
operator|=
literal|6
expr_stmt|;
return|return
name|fixture
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tear_down
parameter_list|(
name|HEARTBEAT_TEST_FIXTURE
name|fixture
parameter_list|)
block|{
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|fixture
operator|.
name|s
argument_list|)
expr_stmt|;
name|SSL_CTX_free
argument_list|(
name|fixture
operator|.
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_payload
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|prefix
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|payload
parameter_list|,
specifier|const
name|int
name|n
parameter_list|)
block|{
specifier|const
name|int
name|end
init|=
name|n
operator|<
name|MAX_PRINTABLE_CHARACTERS
condition|?
name|n
else|:
name|MAX_PRINTABLE_CHARACTERS
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"%s %d character%s"
argument_list|,
name|prefix
argument_list|,
name|n
argument_list|,
name|n
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|n
condition|)
name|printf
argument_list|(
literal|" (first %d shown)"
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  \""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|end
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|unsigned
name|char
name|c
init|=
name|payload
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\x%02x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|execute_heartbeat
parameter_list|(
name|HEARTBEAT_TEST_FIXTURE
name|fixture
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|SSL
modifier|*
name|s
init|=
name|fixture
operator|.
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|payload
init|=
name|fixture
operator|.
name|payload
decl_stmt|;
name|unsigned
name|char
name|sent_buf
index|[
name|MAX_PRINTABLE_CHARACTERS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|return_value
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|actual_payload_len
decl_stmt|;
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|data
operator|=
name|payload
expr_stmt|;
name|s
operator|->
name|s3
operator|->
name|rrec
operator|.
name|length
operator|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|payload
argument_list|)
expr_stmt|;
operator|*
name|payload
operator|++
operator|=
name|TLS1_HB_REQUEST
expr_stmt|;
name|s2n
argument_list|(
name|fixture
operator|.
name|sent_payload_len
argument_list|,
name|payload
argument_list|)
expr_stmt|;
comment|/* Make a local copy of the request, since it gets overwritten at some 	 * point */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sent_buf
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|sent_buf
argument_list|)
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|fixture
operator|.
name|process_heartbeat
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_value
operator|!=
name|fixture
operator|.
name|expected_return_value
condition|)
block|{
name|printf
argument_list|(
literal|"%s failed: expected return value %d, received %d\n"
argument_list|,
name|fixture
operator|.
name|test_case_name
argument_list|,
name|fixture
operator|.
name|expected_return_value
argument_list|,
name|return_value
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If there is any byte alignment, it will be stored in wbuf.offset. */
name|p
operator|=
operator|&
operator|(
name|s
operator|->
name|s3
operator|->
name|wbuf
operator|.
name|buf
index|[
name|fixture
operator|.
name|return_payload_offset
operator|+
name|s
operator|->
name|s3
operator|->
name|wbuf
operator|.
name|offset
index|]
operator|)
expr_stmt|;
name|actual_payload_len
operator|=
literal|0
expr_stmt|;
name|n2s
argument_list|(
name|p
argument_list|,
name|actual_payload_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_payload_len
operator|!=
name|fixture
operator|.
name|expected_payload_len
condition|)
block|{
name|printf
argument_list|(
literal|"%s failed:\n  expected payload len: %d\n  received: %d\n"
argument_list|,
name|fixture
operator|.
name|test_case_name
argument_list|,
name|fixture
operator|.
name|expected_payload_len
argument_list|,
name|actual_payload_len
argument_list|)
expr_stmt|;
name|print_payload
argument_list|(
literal|"sent"
argument_list|,
name|sent_buf
argument_list|,
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sent_buf
argument_list|)
argument_list|)
expr_stmt|;
name|print_payload
argument_list|(
literal|"received"
argument_list|,
name|p
argument_list|,
name|actual_payload_len
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|actual_payload
init|=
name|BUF_strndup
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
name|actual_payload_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|actual_payload
argument_list|,
name|fixture
operator|.
name|expected_return_payload
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s failed:\n  expected payload: \"%s\"\n  received: \"%s\"\n"
argument_list|,
name|fixture
operator|.
name|test_case_name
argument_list|,
name|fixture
operator|.
name|expected_return_payload
argument_list|,
name|actual_payload
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|actual_payload
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"** %s failed **\n--------\n"
argument_list|,
name|fixture
operator|.
name|test_case_name
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|honest_payload_size
parameter_list|(
name|unsigned
name|char
name|payload_buf
index|[]
parameter_list|)
block|{
comment|/* Omit three-byte pad at the beginning for type and payload length */
return|return
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|payload_buf
index|[
literal|3
index|]
argument_list|)
operator|-
name|MIN_PADDING_SIZE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SETUP_HEARTBEAT_TEST_FIXTURE
parameter_list|(
name|type
parameter_list|)
define|\
value|SETUP_TEST_FIXTURE(HEARTBEAT_TEST_FIXTURE, set_up_##type)
end_define

begin_define
define|#
directive|define
name|EXECUTE_HEARTBEAT_TEST
parameter_list|()
define|\
value|EXECUTE_TEST(execute_heartbeat, tear_down)
end_define

begin_function
specifier|static
name|int
name|test_dtls1_not_bleeding
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
comment|/* Three-byte pad at the beginning for type and payload length */
name|unsigned
name|char
name|payload_buf
index|[]
init|=
literal|"   Not bleeding, sixteen spaces of padding"
literal|"                "
decl_stmt|;
specifier|const
name|int
name|payload_buf_len
init|=
name|honest_payload_size
argument_list|(
name|payload_buf
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|"Not bleeding, sixteen spaces of padding"
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_dtls1_not_bleeding_empty_payload
parameter_list|()
block|{
name|int
name|payload_buf_len
decl_stmt|;
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
comment|/* Three-byte pad at the beginning for type and payload length, plus a NUL 	 * at the end */
name|unsigned
name|char
name|payload_buf
index|[
literal|4
operator|+
name|MIN_PADDING_SIZE
index|]
decl_stmt|;
name|memset
argument_list|(
name|payload_buf
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
argument_list|)
expr_stmt|;
name|payload_buf
index|[
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|payload_buf_len
operator|=
name|honest_payload_size
argument_list|(
name|payload_buf
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_dtls1_heartbleed
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
comment|/* Three-byte pad at the beginning for type and payload length */
name|unsigned
name|char
name|payload_buf
index|[]
init|=
literal|"   HEARTBLEED                "
decl_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|MAX_PRINTABLE_CHARACTERS
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_dtls1_heartbleed_empty_payload
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
comment|/* Excluding the NUL at the end, one byte short of type + payload length + 	 * minimum padding */
name|unsigned
name|char
name|payload_buf
index|[
name|MIN_PADDING_SIZE
operator|+
literal|3
index|]
decl_stmt|;
name|memset
argument_list|(
name|payload_buf
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
argument_list|)
expr_stmt|;
name|payload_buf
index|[
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|MAX_PRINTABLE_CHARACTERS
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_dtls1_heartbleed_excessive_plaintext_length
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
comment|/* Excluding the NUL at the end, one byte in excess of maximum allowed 	 * heartbeat message length */
name|unsigned
name|char
name|payload_buf
index|[
name|SSL3_RT_MAX_PLAIN_LENGTH
operator|+
literal|2
index|]
decl_stmt|;
name|memset
argument_list|(
name|payload_buf
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
argument_list|)
expr_stmt|;
name|payload_buf
index|[
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|honest_payload_size
argument_list|(
name|payload_buf
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_tls1_not_bleeding
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|tls
argument_list|)
expr_stmt|;
comment|/* Three-byte pad at the beginning for type and payload length */
name|unsigned
name|char
name|payload_buf
index|[]
init|=
literal|"   Not bleeding, sixteen spaces of padding"
literal|"                "
decl_stmt|;
specifier|const
name|int
name|payload_buf_len
init|=
name|honest_payload_size
argument_list|(
name|payload_buf
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|"Not bleeding, sixteen spaces of padding"
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_tls1_not_bleeding_empty_payload
parameter_list|()
block|{
name|int
name|payload_buf_len
decl_stmt|;
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|tls
argument_list|)
expr_stmt|;
comment|/* Three-byte pad at the beginning for type and payload length, plus a NUL 	 * at the end */
name|unsigned
name|char
name|payload_buf
index|[
literal|4
operator|+
name|MIN_PADDING_SIZE
index|]
decl_stmt|;
name|memset
argument_list|(
name|payload_buf
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
argument_list|)
expr_stmt|;
name|payload_buf
index|[
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|payload_buf_len
operator|=
name|honest_payload_size
argument_list|(
name|payload_buf
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
name|payload_buf_len
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_tls1_heartbleed
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|tls
argument_list|)
expr_stmt|;
comment|/* Three-byte pad at the beginning for type and payload length */
name|unsigned
name|char
name|payload_buf
index|[]
init|=
literal|"   HEARTBLEED                "
decl_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|MAX_PRINTABLE_CHARACTERS
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_tls1_heartbleed_empty_payload
parameter_list|()
block|{
name|SETUP_HEARTBEAT_TEST_FIXTURE
argument_list|(
name|tls
argument_list|)
expr_stmt|;
comment|/* Excluding the NUL at the end, one byte short of type + payload length + 	 * minimum padding */
name|unsigned
name|char
name|payload_buf
index|[
name|MIN_PADDING_SIZE
operator|+
literal|3
index|]
decl_stmt|;
name|memset
argument_list|(
name|payload_buf
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
argument_list|)
expr_stmt|;
name|payload_buf
index|[
sizeof|sizeof
argument_list|(
name|payload_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fixture
operator|.
name|payload
operator|=
operator|&
name|payload_buf
index|[
literal|0
index|]
expr_stmt|;
name|fixture
operator|.
name|sent_payload_len
operator|=
name|MAX_PRINTABLE_CHARACTERS
expr_stmt|;
name|fixture
operator|.
name|expected_return_value
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_payload_len
operator|=
literal|0
expr_stmt|;
name|fixture
operator|.
name|expected_return_payload
operator|=
literal|""
expr_stmt|;
name|EXECUTE_HEARTBEAT_TEST
argument_list|()
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|EXECUTE_HEARTBEAT_TEST
end_undef

begin_undef
undef|#
directive|undef
name|SETUP_HEARTBEAT_TEST_FIXTURE
end_undef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|num_failed
decl_stmt|;
name|SSL_library_init
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|num_failed
operator|=
name|test_dtls1_not_bleeding
argument_list|()
operator|+
name|test_dtls1_not_bleeding_empty_payload
argument_list|()
operator|+
name|test_dtls1_heartbleed
argument_list|()
operator|+
name|test_dtls1_heartbleed_empty_payload
argument_list|()
operator|+
comment|/* The following test causes an assertion failure at 	     * ssl/d1_pkt.c:dtls1_write_bytes() in versions prior to 1.0.1g: */
operator|(
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x1000107fL
condition|?
name|test_dtls1_heartbleed_excessive_plaintext_length
argument_list|()
else|:
literal|0
operator|)
operator|+
name|test_tls1_not_bleeding
argument_list|()
operator|+
name|test_tls1_not_bleeding_empty_payload
argument_list|()
operator|+
name|test_tls1_heartbleed
argument_list|()
operator|+
name|test_tls1_heartbleed_empty_payload
argument_list|()
operator|+
literal|0
expr_stmt|;
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_failed
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%d test%s failed\n"
argument_list|,
name|num_failed
argument_list|,
name|num_failed
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* OPENSSL_NO_HEARTBEATS*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_HEARTBEATS */
end_comment

end_unit

