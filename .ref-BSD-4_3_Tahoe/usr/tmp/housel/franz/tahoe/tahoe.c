begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * 	tahoe.c  * tahoe specific functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_macro
name|mmuladd
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm ("emul	4(fp),8(fp),12(fp),r0");
asm|asm ("ediv	16(fp),r0,r2,r0");
block|}
end_block

begin_macro
name|Imuldiv
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|)
end_macro

begin_block
block|{
asm|asm("	emul	4(fp),8(fp),12(fp),r0");
asm|asm("	ediv	16(fp),r0,*20(fp),*24(fp)");
block|}
end_block

begin_function
name|lispval
name|Lpolyev
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|double
modifier|*
name|handy
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
name|Keepxs
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Lpolyev - Unimplemented or inappropriate CCI function"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|count
operator|=
literal|2
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|-
operator|(
name|int
operator|)
name|lbot
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|8
condition|)
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
name|base
operator|=
name|handy
operator|=
operator|(
name|double
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|type
operator|=
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|DOUB
operator|&&
name|type
operator|!=
name|INT
condition|)
name|argp
operator|->
name|val
operator|=
operator|(
name|lispval
operator|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"%%machine-polyev:non-real arg"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|73
argument_list|,
name|lbot
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
block|}
else|else
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|r
expr_stmt|;
block|}
name|count
operator|=
name|count
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
asm|asm("polyd	(r9),r11,8(r9)");
asm|asm("movd	r0,(r9)");
endif|#
directive|endif
name|result
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|result
operator|->
name|r
operator|=
operator|*
name|base
expr_stmt|;
name|Freexs
argument_list|()
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrot
parameter_list|()
block|{
specifier|register
name|val
expr_stmt|;
specifier|register
name|unsigned
name|long
name|mask2
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|long
name|rot
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"rot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"Non ints to rot"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|mylbot
operator|->
name|val
argument_list|,
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|mylbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|rot
operator|&
literal|0x3f
expr_stmt|;
comment|/* bring it down below one byte in size */
name|mask2
operator|>>=
name|rot
expr_stmt|;
name|mask2
operator|^=
operator|-
literal|1
expr_stmt|;
name|mask2
operator|&=
name|val
expr_stmt|;
name|mask2
operator|>>=
operator|(
literal|32
operator|-
name|rot
operator|)
expr_stmt|;
name|val
operator|<<=
name|rot
expr_stmt|;
name|val
operator||=
name|mask2
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"tahoeframe.h"
end_include

begin_comment
comment|/* new version of showstack, 	We will set fp to point where the register fp points. 	Then fp+2 = saved ap 	     fp+4 = saved pc 	     fp+3 = saved fp 	     ap+1 = first arg 	If we find that the saved pc is somewhere in the routine eval,    then we print the first argument to that eval frame. This is done    by looking one beyond the saved ap. */
end_comment

begin_function
name|lispval
name|Lshostk
parameter_list|()
block|{
name|lispval
name|isho
parameter_list|()
function_decl|;
return|return
operator|(
name|isho
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lispval
name|isho
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|struct
name|machframe
modifier|*
name|myfp
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* this must be the first local */
name|int
name|virgin
init|=
literal|1
decl_stmt|;
name|lispval
name|linterp
parameter_list|()
function_decl|;
name|lispval
name|_qfuncl
argument_list|()
decl_stmt|,
name|tynames
argument_list|()
decl_stmt|;
comment|/* locations in qfuncl */
specifier|extern
name|int
name|plevel
decl_stmt|,
name|plength
decl_stmt|;
name|error
argument_list|(
literal|"C coded showstack - Unimplemented or inappropriate CCI function"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plevel
operator|=
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plevel
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlength
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plength
operator|=
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plength
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Forms in evaluation:\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Backtrace:\n\n"
argument_list|)
expr_stmt|;
name|myfp
operator|=
operator|(
expr|struct
name|machframe
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* point to current frame */
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|myfp
operator|->
name|pc
operator|>
name|eval
operator|&&
comment|/* interpreted code */
name|myfp
operator|->
name|pc
operator|<
name|popnames
operator|)
operator|||
operator|(
name|myfp
operator|->
name|pc
operator|>
name|Lfuncal
operator|&&
comment|/* compiled code */
name|myfp
operator|->
name|pc
operator|<
name|linterp
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|vax
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|myfp
operator|->
name|ap
index|[
literal|0
index|]
operator|)
operator|==
literal|1
condition|)
comment|/* only if arg given */
block|{
name|handy
operator|=
operator|(
name|myfp
operator|->
name|ap
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|1
condition|)
name|printr
argument_list|(
name|handy
argument_list|,
name|stdout
argument_list|)
operator|,
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|virgin
condition|)
name|virgin
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" -- "
argument_list|)
expr_stmt|;
name|printr
argument_list|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|?
name|handy
operator|->
name|d
operator|.
name|car
else|:
name|handy
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
break|break;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  *	(baktrace)  *  * baktrace will print the names of all functions being evaluated  * from the current one (baktrace) down to the first one.  * currently it only prints the function name.  Planned is a  * list of local variables in all stack frames.  * written by jkf.  *  */
end_comment

begin_function
name|lispval
name|Lbaktrace
parameter_list|()
block|{
name|isho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * (int:showstack 'stack_pointer)  * return  *   nil if at the end of the stack or illegal  *   ( expresssion . next_stack_pointer) otherwise  *   where expression is something passed to eval  * very tahoe specific  */
end_comment

begin_function
name|lispval
name|LIshowstack
parameter_list|()
block|{
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* must be the first local variable */
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|machframe
modifier|*
name|myfp
decl_stmt|;
name|lispval
name|retval
decl_stmt|,
name|Lfuncal
argument_list|()
decl_stmt|,
name|Ifuncal
argument_list|()
decl_stmt|;
name|lispval
function_decl|(
modifier|*
name|pc
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"int:showstack"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|&&
operator|(
name|handy
operator|!=
name|nil
operator|)
condition|)
name|error
argument_list|(
literal|"int:showstack non fixnum arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
asm|asm("movab	-8(fp),r11");
comment|/* only way I could think of */
else|else
name|myfp
operator|=
operator|(
expr|struct
name|machframe
operator|*
operator|)
name|handy
operator|->
name|i
expr_stmt|;
comment|/* if((int ***)myfp<=&fp) error("int:showstack illegal stack value",FALSE); */
while|while
condition|(
name|myfp
operator|>
literal|0
condition|)
block|{
comment|/*fprintf(stderr, "myfp=%x pc=%x fp=%x removed=%d\n", myfp, myfp->pc, 			myfp->fp, myfp->removed); 	fflush(stderr);*/
if|if
condition|(
operator|(
name|pc
operator|>=
name|eval
operator|&&
comment|/* interpreted code */
name|pc
operator|<
name|popnames
operator|)
operator|||
operator|(
name|pc
operator|>=
name|Ifuncal
operator|&&
comment|/* compiled code */
name|pc
operator|<
name|Lfuncal
operator|)
condition|)
block|{
if|if
condition|(
name|myfp
operator|->
name|removed
operator|==
literal|8
condition|)
comment|/* only if arg given */
block|{
name|handy
operator|=
call|(
name|lispval
call|)
argument_list|(
name|myfp
operator|->
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* arg to eval */
name|protect
argument_list|(
name|retval
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|->
name|d
operator|.
name|car
operator|=
name|handy
expr_stmt|;
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
name|myfp
operator|=
literal|0
expr_stmt|;
comment|/* end of frames */
else|else
name|myfp
operator|=
operator|(
expr|struct
name|machframe
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|myfp
operator|->
name|fp
operator|-
literal|8
operator|)
expr_stmt|;
name|retval
operator|->
name|d
operator|.
name|cdr
operator|=
name|inewint
argument_list|(
name|myfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
name|myfp
operator|=
literal|0
expr_stmt|;
comment|/* end of frames */
else|else
block|{
name|pc
operator|=
name|myfp
operator|->
name|pc
expr_stmt|;
name|myfp
operator|=
operator|(
expr|struct
name|machframe
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|myfp
operator|->
name|fp
operator|-
literal|8
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/*  * this code is very similar to ftolsp.  * if it gets revised, so should this.  */
end_comment

begin_function
name|lispval
name|dothunk
parameter_list|(
name|func
parameter_list|,
name|count
parameter_list|,
name|arglist
parameter_list|)
name|lispval
name|func
decl_stmt|;
name|long
name|count
decl_stmt|;
specifier|register
name|long
modifier|*
name|arglist
decl_stmt|;
block|{
name|lispval
name|save
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
if|if
condition|(
name|errp
operator|->
name|class
operator|==
name|F_TO_FORT
condition|)
name|np
operator|=
name|errp
operator|->
name|svnp
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_TO_LISP
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|func
expr_stmt|;
name|arglist
operator|++
expr_stmt|;
comment|/* this is a vaxism, we'll compensate elsewhere */
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
name|np
operator|++
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|*
name|arglist
operator|++
argument_list|)
expr_stmt|;
name|save
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_comment
comment|/* _thcpy: 	movl	(sp),r0 	pushl	ap 	pushl	(r0)+ 	pushl	(r0)+ 	calls	$3,_dothunk 	ret */
end_comment

begin_comment
comment|/*  * This is thunkmodel: 	.word	0 	movl	r0,r0 	callf	$4,_thunkstack1 	.long	0<count> 	.long	0<func>  */
end_comment

begin_function_decl
specifier|extern
name|lispval
name|thunkstack1
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|thunk
block|{
name|short
name|mask
decl_stmt|;
name|char
name|nop
index|[
literal|3
index|]
decl_stmt|;
name|char
name|callf
index|[
literal|3
index|]
decl_stmt|;
name|lispval
function_decl|(
modifier|*
name|stack1
function_decl|)
parameter_list|()
function_decl|;
name|long
name|count
decl_stmt|;
name|lispval
name|func
decl_stmt|;
block|}
name|thunkmodel
init|=
block|{
literal|0
block|,
block|{
literal|0xd
block|,
literal|0x50
block|,
literal|0x50
block|}
block|,
block|{
literal|0xfe
block|,
literal|0x4
block|,
literal|0x9f
block|}
block|,
name|thunkstack1
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|sixwords
index|[]
init|=
literal|"01234567890123456789012"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trailing 0! */
end_comment

begin_function
name|lispval
name|Lmkcth
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|struct
name|thunk
modifier|*
name|th
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"make-c-thunk"
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|thunk
operator|*
operator|)
name|pinewstr
argument_list|(
name|sixwords
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|thunk
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|th
operator|)
operator||
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
operator|*
name|th
operator|=
name|thunkmodel
expr_stmt|;
name|th
operator|->
name|func
operator|=
name|mylbot
operator|->
name|val
expr_stmt|;
name|th
operator|->
name|count
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|th
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This removes the frame from the stack for the thunk  * and retrieves various data.  (Actually merges it into  * its own stack frame).  */
end_comment

begin_function
name|lispval
name|thunkstack1
parameter_list|(
name|retfromthunk
parameter_list|)
block|{
specifier|register
name|int
modifier|*
name|handy
decl_stmt|,
modifier|*
name|midthunk
decl_stmt|;
name|int
modifier|*
name|arglist
decl_stmt|;
name|lispval
name|func
decl_stmt|;
name|int
name|count
decl_stmt|;
name|handy
operator|=
operator|&
name|retfromthunk
expr_stmt|;
name|arglist
operator|=
name|handy
operator|+
literal|2
expr_stmt|;
comment|/* should be +3, first is taken as 					   vax arglist count and ignored */
name|handy
index|[
operator|-
literal|1
index|]
operator|=
name|handy
index|[
literal|2
index|]
expr_stmt|;
comment|/* unlink frame */
name|midthunk
operator|=
operator|(
name|int
operator|*
operator|)
name|handy
index|[
operator|-
literal|3
index|]
expr_stmt|;
comment|/* our oldpc points to mid thunk */
name|handy
index|[
operator|-
literal|3
index|]
operator|=
name|retfromthunk
expr_stmt|;
name|handy
index|[
operator|-
literal|2
index|]
operator|+=
operator|(
literal|8
operator|+
name|handy
index|[
literal|1
index|]
operator|)
expr_stmt|;
comment|/* save mask for thunk is 0, 					   adjust bytes to remove from us  */
name|count
operator|=
operator|*
name|midthunk
expr_stmt|;
name|func
operator|=
operator|(
name|lispval
operator|)
name|midthunk
index|[
literal|1
index|]
expr_stmt|;
comment|/* you could even merge this in and avoid another callf! */
return|return
operator|(
name|dothunk
argument_list|(
name|func
argument_list|,
name|count
argument_list|,
name|arglist
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

