begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * All recipients should regard themselves as participants in an ongoing  * research project and hence should feel obligated to report their  * experiences (good or bad) with these elementary function codes, using  * the sendbug(8) program, to the authors.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)atan2.c	5.3 (Berkeley) 6/30/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* ATAN2(Y,X)  * RETURN ARG (X+iY)  * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)  * CODED IN C BY K.C. NG, 1/8/85;   * REVISED BY K.C. NG on 2/7/85, 2/13/85, 3/7/85, 3/30/85, 6/29/85.  *  * Required system supported functions :  *	copysign(x,y)  *	scalb(x,y)  *	logb(x)  *	  * Method :  *	1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).  *	2. Reduce x to positive by (if x and y are unexceptional):   *		ARG (x+iy) = arctan(y/x)   	   ... if x> 0,  *		ARG (x+iy) = pi - arctan[y/(-x)]   ... if x< 0,  *	3. According to the integer k=4t+0.25 truncated , t=y/x, the argument   *	   is further reduced to one of the following intervals and the   *	   arctangent of y/x is evaluated by the corresponding formula:  *  *         [0,7/16]	   atan(y/x) = t - t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)  *	   [7/16,11/16]    atan(y/x) = atan(1/2) + atan( (y-x/2)/(x+y/2) )  *	   [11/16.19/16]   atan(y/x) = atan( 1 ) + atan( (y-x)/(x+y) )  *	   [19/16,39/16]   atan(y/x) = atan(3/2) + atan( (y-1.5x)/(x+1.5y) )  *	   [39/16,INF]     atan(y/x) = atan(INF) + atan( -x/y )  *  * Special cases:  * Notations: atan2(y,x) == ARG (x+iy) == ARG(x,y).  *  *	ARG( NAN , (anything) ) is NaN;  *	ARG( (anything), NaN ) is NaN;  *	ARG(+(anything but NaN), +-0) is +-0  ;  *	ARG(-(anything but NaN), +-0) is +-PI ;  *	ARG( 0, +-(anything but 0 and NaN) ) is +-PI/2;  *	ARG( +INF,+-(anything but INF and NaN) ) is +-0 ;  *	ARG( -INF,+-(anything but INF and NaN) ) is +-PI;  *	ARG( +INF,+-INF ) is +-PI/4 ;  *	ARG( -INF,+-INF ) is +-3PI/4;  *	ARG( (anything but,0,NaN, and INF),+-INF ) is +-PI/2;  *  * Accuracy:  *	atan2(y,x) returns (PI/pi) * the exact ARG (x+iy) nearly rounded,   *	where  *  *	in decimal:  *		pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *	in hexadecimal:  *		pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18	error=.276ulps  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2    error=.206ulps  *	  *	In a test run with 356,000 random argument on [-1,1] * [-1,1] on a  *	VAX, the maximum observed error was 1.41 ulps (units of the last place)  *	compared with (PI/pi)*(the exact ARG(x+iy)).  *  * Note:  *	We use machine PI (the true pi rounded) in place of the actual  *	value of pi for all the trig and inverse trig functions. In general,   *	if trig is one of sin, cos, tan, then computed trig(y) returns the   *	exact trig(y*pi/PI) nearly rounded; correspondingly, computed arctrig   *	returns the exact arctrig(y)*PI/pi nearly rounded. These guarantee the   *	trig functions have period PI, and trig(arctrig(x)) returns x for  *	all critical values x.  *	  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_comment
comment|/* VAX D format */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|_0x
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0x
comment|/**/
value|A
comment|/**/
value|B
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* vax */
end_comment

begin_define
define|#
directive|define
name|_0x
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0x
comment|/**/
value|B
comment|/**/
value|A
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vax */
end_comment

begin_comment
comment|/*static double */
end_comment

begin_comment
comment|/*athfhi =  4.6364760900080611433E-1    , /*Hex  2^ -1   *  .ED63382B0DDA7B */
end_comment

begin_comment
comment|/*athflo =  1.9338828231967579916E-19   , /*Hex  2^-62   *  .E450059CFE92C0 */
end_comment

begin_comment
comment|/*PIo4   =  7.8539816339744830676E-1    , /*Hex  2^  0   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*at1fhi =  9.8279372324732906796E-1    , /*Hex  2^  0   *  .FB985E940FB4D9 */
end_comment

begin_comment
comment|/*at1flo = -3.5540295636764633916E-18   , /*Hex  2^-57   * -.831EDC34D6EAEA */
end_comment

begin_comment
comment|/*PIo2   =  1.5707963267948966135E0     , /*Hex  2^  1   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*PI     =  3.1415926535897932270E0     , /*Hex  2^  2   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*a1     =  3.3333333333333473730E-1    , /*Hex  2^ -1   *  .AAAAAAAAAAAB75 */
end_comment

begin_comment
comment|/*a2     = -2.0000000000017730678E-1    , /*Hex  2^ -2   * -.CCCCCCCCCD946E */
end_comment

begin_comment
comment|/*a3     =  1.4285714286694640301E-1    , /*Hex  2^ -2   *  .92492492744262 */
end_comment

begin_comment
comment|/*a4     = -1.1111111135032672795E-1    , /*Hex  2^ -3   * -.E38E38EBC66292 */
end_comment

begin_comment
comment|/*a5     =  9.0909091380563043783E-2    , /*Hex  2^ -3   *  .BA2E8BB31BD70C */
end_comment

begin_comment
comment|/*a6     = -7.6922954286089459397E-2    , /*Hex  2^ -3   * -.9D89C827C37F18 */
end_comment

begin_comment
comment|/*a7     =  6.6663180891693915586E-2    , /*Hex  2^ -3   *  .8886B4AE379E58 */
end_comment

begin_comment
comment|/*a8     = -5.8772703698290408927E-2    , /*Hex  2^ -4   * -.F0BBA58481A942 */
end_comment

begin_comment
comment|/*a9     =  5.2170707402812969804E-2    , /*Hex  2^ -4   *  .D5B0F3A1AB13AB */
end_comment

begin_comment
comment|/*a10    = -4.4895863157820361210E-2    , /*Hex  2^ -4   * -.B7E4B97FD1048F */
end_comment

begin_comment
comment|/*a11    =  3.3006147437343875094E-2    , /*Hex  2^ -4   *  .8731743CF72D87 */
end_comment

begin_comment
comment|/*a12    = -1.4614844866464185439E-2    ; /*Hex  2^ -6   * -.EF731A2F3476D9 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|athfhix
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|6338
argument_list|,
literal|3fed
argument_list|)
block|,
name|_0x
argument_list|(
argument|da7b
argument_list|,
literal|2b0d
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|athfhi
value|(*(double *)athfhix)
end_define

begin_decl_stmt
specifier|static
name|long
name|athflox
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|5005
argument_list|,
literal|2164
argument_list|)
block|,
name|_0x
argument_list|(
literal|92c0
argument_list|,
literal|9cfe
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|athflo
value|(*(double *)athflox)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIo4x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|4049
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PIo4
value|(*(double *)PIo4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|at1fhix
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|985e
argument_list|,
literal|407b
argument_list|)
block|,
name|_0x
argument_list|(
argument|b4d9
argument_list|,
literal|940f
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|at1fhi
value|(*(double *)at1fhix)
end_define

begin_decl_stmt
specifier|static
name|long
name|at1flox
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|1edc
argument_list|,
name|a383
argument_list|)
block|,
name|_0x
argument_list|(
argument|eaea
argument_list|,
literal|34d6
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|at1flo
value|(*(double *)at1flox)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIo2x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|40c9
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PIo2
value|(*(double *)PIo2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIx
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|4149
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI
value|(*(double *)PIx)
end_define

begin_decl_stmt
specifier|static
name|long
name|a1x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|aaaa
argument_list|,
literal|3faa
argument_list|)
block|,
name|_0x
argument_list|(
argument|ab75
argument_list|,
argument|aaaa
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a1
value|(*(double *)a1x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a2x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|cccc
argument_list|,
name|bf4c
argument_list|)
block|,
name|_0x
argument_list|(
literal|946e
argument_list|,
argument|cccd
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a2
value|(*(double *)a2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a3x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|4924
argument_list|,
literal|3f12
argument_list|)
block|,
name|_0x
argument_list|(
literal|4262
argument_list|,
literal|9274
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a3
value|(*(double *)a3x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a4x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|8e38
argument_list|,
name|bee3
argument_list|)
block|,
name|_0x
argument_list|(
literal|6292
argument_list|,
argument|ebc6
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a4
value|(*(double *)a4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a5x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|2e8b
argument_list|,
literal|3eba
argument_list|)
block|,
name|_0x
argument_list|(
argument|d70c
argument_list|,
argument|b31b
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a5
value|(*(double *)a5x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a6x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|89c8
argument_list|,
name|be9d
argument_list|)
block|,
name|_0x
argument_list|(
literal|7f18
argument_list|,
literal|27c3
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a6
value|(*(double *)a6x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a7x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|86b4
argument_list|,
literal|3e88
argument_list|)
block|,
name|_0x
argument_list|(
literal|9e58
argument_list|,
argument|ae37
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a7
value|(*(double *)a7x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a8x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|bba5
argument_list|,
name|be70
argument_list|)
block|,
name|_0x
argument_list|(
argument|a942
argument_list|,
literal|8481
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a8
value|(*(double *)a8x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a9x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|b0f3
argument_list|,
literal|3e55
argument_list|)
block|,
name|_0x
argument_list|(
literal|13ab
argument_list|,
argument|a1ab
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a9
value|(*(double *)a9x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a10x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|e4b9
argument_list|,
name|be37
argument_list|)
block|,
name|_0x
argument_list|(
literal|048f
argument_list|,
literal|7fd1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a10
value|(*(double *)a10x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a11x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|3174
argument_list|,
literal|3e07
argument_list|)
block|,
name|_0x
argument_list|(
literal|2d87
argument_list|,
literal|3cf7
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a11
value|(*(double *)a11x)
end_define

begin_decl_stmt
specifier|static
name|long
name|a12x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|731a
argument_list|,
name|bd6f
argument_list|)
block|,
name|_0x
argument_list|(
literal|76d9
argument_list|,
literal|2f34
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a12
value|(*(double *)a12x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(vax)||defined(tahoe) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|athfhi
init|=
literal|4.6364760900080609352E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -2   *  1.DAC670561BB4F */
name|athflo
init|=
literal|4.6249969567426939759E
operator|-
literal|18
decl_stmt|,
comment|/*Hex  2^-58   *  1.5543B8F253271 */
name|PIo4
init|=
literal|7.8539816339744827900E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -1   *  1.921FB54442D18 */
name|at1fhi
init|=
literal|9.8279372324732905408E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -1   *  1.F730BD281F69B */
name|at1flo
init|=
operator|-
literal|2.4407677060164810007E
operator|-
literal|17
decl_stmt|,
comment|/*Hex  2^-56   * -1.C23DFEFEAE6B5 */
name|PIo2
init|=
literal|1.5707963267948965580E0
decl_stmt|,
comment|/*Hex  2^  0   *  1.921FB54442D18 */
name|PI
init|=
literal|3.1415926535897931160E0
decl_stmt|,
comment|/*Hex  2^  1   *  1.921FB54442D18 */
name|a1
init|=
literal|3.3333333333333942106E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -2   *  1.55555555555C3 */
name|a2
init|=
operator|-
literal|1.9999999999979536924E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -3   * -1.9999999997CCD */
name|a3
init|=
literal|1.4285714278004377209E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -3   *  1.24924921EC1D7 */
name|a4
init|=
operator|-
literal|1.1111110579344973814E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -4   * -1.C71C7059AF280 */
name|a5
init|=
literal|9.0908906105474668324E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   *  1.745CE5AA35DB2 */
name|a6
init|=
operator|-
literal|7.6919217767468239799E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   * -1.3B0FA54BEC400 */
name|a7
init|=
literal|6.6614695906082474486E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   *  1.10DA924597FFF */
name|a8
init|=
operator|-
literal|5.8358371008508623523E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -5   * -1.DE125FDDBD793 */
name|a9
init|=
literal|4.9850617156082015213E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -5   *  1.9860524BDD807 */
name|a10
init|=
operator|-
literal|3.6700606902093604877E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -5   * -1.2CA6C04C6937A */
name|a11
init|=
literal|1.6438029044759730479E
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^ -6   *  1.0D52174A1BB54 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(vax)||defined(tahoe) */
end_comment

begin_function
name|double
name|atan2
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
name|double
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
specifier|static
name|double
name|zero
init|=
literal|0
decl_stmt|,
name|one
init|=
literal|1
decl_stmt|,
name|small
init|=
literal|1.0E
operator|-
literal|9
decl_stmt|,
name|big
init|=
literal|1.0E18
decl_stmt|;
name|double
name|copysign
argument_list|()
decl_stmt|,
name|logb
argument_list|()
decl_stmt|,
name|scalb
argument_list|()
decl_stmt|,
name|t
decl_stmt|,
name|z
decl_stmt|,
name|signy
decl_stmt|,
name|signx
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|int
name|finite
argument_list|()
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|vax
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|tahoe
argument_list|)
comment|/* if x or y is NAN */
if|if
condition|(
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|y
operator|!=
name|y
condition|)
return|return
operator|(
name|y
operator|)
return|;
endif|#
directive|endif
comment|/* !defined(vax)&&!defined(tahoe) */
comment|/* copy down the sign of y and x */
name|signy
operator|=
name|copysign
argument_list|(
name|one
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|signx
operator|=
name|copysign
argument_list|(
name|one
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* if x is 1.0, goto begin */
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|y
operator|=
name|copysign
argument_list|(
name|y
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|t
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|finite
argument_list|(
name|t
argument_list|)
condition|)
goto|goto
name|begin
goto|;
block|}
comment|/* when y = 0 */
if|if
condition|(
name|y
operator|==
name|zero
condition|)
return|return
operator|(
operator|(
name|signx
operator|==
name|one
operator|)
condition|?
name|y
else|:
name|copysign
argument_list|(
name|PI
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* when x = 0 */
if|if
condition|(
name|x
operator|==
name|zero
condition|)
return|return
operator|(
name|copysign
argument_list|(
name|PIo2
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* when x is INF */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
operator|!
name|finite
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|==
name|one
operator|)
condition|?
name|PIo4
else|:
literal|3
operator|*
name|PIo4
argument_list|,
name|signy
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|==
name|one
operator|)
condition|?
name|zero
else|:
name|PI
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* when y is INF */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|copysign
argument_list|(
name|PIo2
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* compute y/x */
name|x
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|y
operator|=
name|copysign
argument_list|(
name|y
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|k
operator|=
name|logb
argument_list|(
name|y
argument_list|)
operator|)
operator|-
name|logb
argument_list|(
name|x
argument_list|)
operator|)
operator|>
literal|60
condition|)
name|t
operator|=
name|big
operator|+
name|big
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|<
operator|-
literal|80
condition|)
name|t
operator|=
name|y
operator|/
name|x
expr_stmt|;
else|else
block|{
name|t
operator|=
name|y
operator|/
name|x
expr_stmt|;
name|y
operator|=
name|scalb
argument_list|(
name|y
argument_list|,
operator|-
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|scalb
argument_list|(
name|x
argument_list|,
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* begin argument reduction */
name|begin
label|:
if|if
condition|(
name|t
operator|<
literal|2.4375
condition|)
block|{
comment|/* truncate 4(t+1/16) to integer for branching */
name|k
operator|=
literal|4
operator|*
operator|(
name|t
operator|+
literal|0.0625
operator|)
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
comment|/* t is in [0,7/16] */
case|case
literal|0
case|:
case|case
literal|1
case|:
if|if
condition|(
name|t
operator|<
name|small
condition|)
block|{
name|big
operator|+
name|small
expr_stmt|;
comment|/* raise inexact flag */
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|>
name|zero
operator|)
condition|?
name|t
else|:
name|PI
operator|-
name|t
argument_list|,
name|signy
argument_list|)
operator|)
return|;
block|}
name|hi
operator|=
name|zero
expr_stmt|;
name|lo
operator|=
name|zero
expr_stmt|;
break|break;
comment|/* t is in [7/16,11/16] */
case|case
literal|2
case|:
name|hi
operator|=
name|athfhi
expr_stmt|;
name|lo
operator|=
name|athflo
expr_stmt|;
name|z
operator|=
name|x
operator|+
name|x
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|y
operator|+
name|y
operator|)
operator|-
name|x
operator|)
operator|/
operator|(
name|z
operator|+
name|y
operator|)
expr_stmt|;
break|break;
comment|/* t is in [11/16,19/16] */
case|case
literal|3
case|:
case|case
literal|4
case|:
name|hi
operator|=
name|PIo4
expr_stmt|;
name|lo
operator|=
name|zero
expr_stmt|;
name|t
operator|=
operator|(
name|y
operator|-
name|x
operator|)
operator|/
operator|(
name|x
operator|+
name|y
operator|)
expr_stmt|;
break|break;
comment|/* t is in [19/16,39/16] */
default|default:
name|hi
operator|=
name|at1fhi
expr_stmt|;
name|lo
operator|=
name|at1flo
expr_stmt|;
name|z
operator|=
name|y
operator|-
name|x
expr_stmt|;
name|y
operator|=
name|y
operator|+
name|y
operator|+
name|y
expr_stmt|;
name|t
operator|=
name|x
operator|+
name|x
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|z
operator|+
name|z
operator|)
operator|-
name|x
operator|)
operator|/
operator|(
name|t
operator|+
name|y
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* end of if (t< 2.4375) */
else|else
block|{
name|hi
operator|=
name|PIo2
expr_stmt|;
name|lo
operator|=
name|zero
expr_stmt|;
comment|/* t is in [2.4375, big] */
if|if
condition|(
name|t
operator|<=
name|big
condition|)
name|t
operator|=
operator|-
name|x
operator|/
name|y
expr_stmt|;
comment|/* t is in [big, INF] */
else|else
block|{
name|big
operator|+
name|small
expr_stmt|;
comment|/* raise inexact flag */
name|t
operator|=
name|zero
expr_stmt|;
block|}
block|}
comment|/* end of argument reduction */
comment|/* compute atan(t) for t in [-.4375, .4375] */
name|z
operator|=
name|t
operator|*
name|t
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
name|z
operator|=
name|t
operator|*
operator|(
name|z
operator|*
operator|(
name|a1
operator|+
name|z
operator|*
operator|(
name|a2
operator|+
name|z
operator|*
operator|(
name|a3
operator|+
name|z
operator|*
operator|(
name|a4
operator|+
name|z
operator|*
operator|(
name|a5
operator|+
name|z
operator|*
operator|(
name|a6
operator|+
name|z
operator|*
operator|(
name|a7
operator|+
name|z
operator|*
operator|(
name|a8
operator|+
name|z
operator|*
operator|(
name|a9
operator|+
name|z
operator|*
operator|(
name|a10
operator|+
name|z
operator|*
operator|(
name|a11
operator|+
name|z
operator|*
name|a12
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* defined(vax)||defined(tahoe) */
name|z
operator|=
name|t
operator|*
operator|(
name|z
operator|*
operator|(
name|a1
operator|+
name|z
operator|*
operator|(
name|a2
operator|+
name|z
operator|*
operator|(
name|a3
operator|+
name|z
operator|*
operator|(
name|a4
operator|+
name|z
operator|*
operator|(
name|a5
operator|+
name|z
operator|*
operator|(
name|a6
operator|+
name|z
operator|*
operator|(
name|a7
operator|+
name|z
operator|*
operator|(
name|a8
operator|+
name|z
operator|*
operator|(
name|a9
operator|+
name|z
operator|*
operator|(
name|a10
operator|+
name|z
operator|*
name|a11
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(vax)||defined(tahoe) */
name|z
operator|=
name|lo
operator|-
name|z
expr_stmt|;
name|z
operator|+=
name|t
expr_stmt|;
name|z
operator|+=
name|hi
expr_stmt|;
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|>
name|zero
operator|)
condition|?
name|z
else|:
name|PI
operator|-
name|z
argument_list|,
name|signy
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

