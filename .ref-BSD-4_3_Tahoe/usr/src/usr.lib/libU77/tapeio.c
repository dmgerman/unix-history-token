begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)tapeio.c	5.1	6/7/85  */
end_comment

begin_comment
comment|/*  * tapeio - tape device specific I/O routines  *  *	ierr = topen  (tlu, name, labelled)  *	ierr = tclose (tlu)  *	nbytes = tread  (tlu, buffer)  *	nbytes = twrite (tlu, buffer)  *	ierr = trewin (tlu)  *	ierr = tskipf (tlu, nfiles, nrecs)  *	ierr = tstate (tlu, fileno, recno, err, eof, eot, tcsr)  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MTIOCGET
end_ifndef

begin_comment
comment|/* 4.1+ defines this in ... */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../libI77/f_errno.h"
end_include

begin_define
define|#
directive|define
name|TU_NAMESIZE
value|22
end_define

begin_define
define|#
directive|define
name|TU_MAXTAPES
value|4
end_define

begin_struct
struct|struct
name|tunits
block|{
name|char
name|tu_name
index|[
name|TU_NAMESIZE
index|]
decl_stmt|;
comment|/* device name */
name|int
name|tu_fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|tu_flags
decl_stmt|;
comment|/* state flags */
name|int
name|tu_file
decl_stmt|;
comment|/* current tape file number */
name|int
name|tu_rec
decl_stmt|;
comment|/* current record number in file */
block|}
name|tunits
index|[
name|TU_MAXTAPES
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|TU_OPEN
value|0x1
end_define

begin_define
define|#
directive|define
name|TU_EOF
value|0x2
end_define

begin_define
define|#
directive|define
name|TU_ERR
value|0x4
end_define

begin_define
define|#
directive|define
name|TU_READONLY
value|0x8
end_define

begin_define
define|#
directive|define
name|TU_LABELLED
value|0x10
end_define

begin_define
define|#
directive|define
name|TU_WRITING
value|0x20
end_define

begin_define
define|#
directive|define
name|TU_EOT
value|0x40
end_define

begin_define
define|#
directive|define
name|TU_RDATA
value|0x80
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MTWEOF
end_ifdef

begin_comment
comment|/* this implies 4.1+ ... */
end_comment

begin_decl_stmt
name|struct
name|mtget
name|mtget
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* controller status */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Open a tape unit for I/O  *  * calling format:  *	integer topen, tlu  *	character*(*) devnam  *	logical labled  *	ierror = topen(tlu, devnam, labled)  * where:  *	ierror will be 0 for successful open; an error number otherwise.  *	devnam is a character string  *	labled should be .true. if the tape is labelled.  */
end_comment

begin_function
name|long
name|topen_
parameter_list|(
name|tlu
parameter_list|,
name|name
parameter_list|,
name|labelled
parameter_list|,
name|len
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
modifier|*
name|labelled
decl_stmt|;
name|long
name|len
decl_stmt|;
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
condition|)
name|tclose_
argument_list|(
name|tlu
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TU_NAMESIZE
condition|)
block|{
name|errno
operator|=
name|F_ERARG
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|g_char
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|tu
operator|->
name|tu_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tu
operator|->
name|tu_fd
operator|=
name|open
argument_list|(
name|tu
operator|->
name|tu_name
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tu
operator|->
name|tu_fd
operator|=
name|open
argument_list|(
name|tu
operator|->
name|tu_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
name|tu
operator|->
name|tu_flags
operator||=
name|TU_READONLY
expr_stmt|;
block|}
name|tu
operator|->
name|tu_flags
operator||=
name|TU_OPEN
expr_stmt|;
name|tu
operator|->
name|tu_file
operator|=
name|tu
operator|->
name|tu_rec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|labelled
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_LABELLED
expr_stmt|;
return|return
operator|(
literal|0L
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a tape unit previously opened by topen_()  *  * calling sequence:  *	integer tlu, tclose  *	ierrno = tclose(tlu)  * where:  *	tlu is a previously topened tape logical unit.  */
end_comment

begin_function
name|long
name|tclose_
parameter_list|(
name|tlu
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|;
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
operator|)
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
name|tu
operator|->
name|tu_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
return|return
operator|(
literal|0L
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read from a tape logical unit  *  * calling sequence:  *	integer tread, tlu  *	character*(*) buffer  *	ierr = tread(tlu, buffer)  */
end_comment

begin_function
name|long
name|tread_
parameter_list|(
name|tlu
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|long
name|len
decl_stmt|;
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
operator|)
condition|)
block|{
name|errno
operator|=
name|F_ERNOPEN
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_WRITING
condition|)
block|{
name|errno
operator|=
name|F_ERILLOP
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
operator|(
name|TU_EOF
operator||
name|TU_EOT
operator|)
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
if|if
condition|(
operator|(
name|nbytes
operator|=
name|read
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|,
name|buffer
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_RDATA
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|tu
operator|->
name|tu_flags
operator||=
name|TU_EOF
expr_stmt|;
if|if
condition|(
name|tu
operator|->
name|tu_rec
operator|==
literal|0
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_EOT
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_ERR
expr_stmt|;
else|else
name|tu
operator|->
name|tu_rec
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a tape logical unit  *  * calling sequence:  *	integer twrite, tlu  *	character*(*) buffer  *	ierr = twrite(tlu, buffer)  */
end_comment

begin_function
name|long
name|twrite_
parameter_list|(
name|tlu
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|long
name|len
decl_stmt|;
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|long
name|nf
decl_stmt|;
name|long
name|zero
init|=
literal|0L
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
operator|)
condition|)
block|{
name|errno
operator|=
name|F_ERNOPEN
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_READONLY
condition|)
block|{
name|errno
operator|=
name|F_ERILLOP
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_EOT
condition|)
block|{
comment|/* must backspace over last EOF */
name|nf
operator|=
operator|(
name|long
operator|)
name|tu
operator|->
name|tu_file
expr_stmt|;
comment|/* should be number to skip */
name|trewin_
argument_list|(
name|tlu
argument_list|)
expr_stmt|;
comment|/* KLUDGE!! */
name|tskipf_
argument_list|(
name|tlu
argument_list|,
operator|&
name|nf
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
block|}
name|nbytes
operator|=
name|write
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|,
name|buffer
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_ERR
expr_stmt|;
name|tu
operator|->
name|tu_rec
operator|++
expr_stmt|;
name|tu
operator|->
name|tu_flags
operator||=
name|TU_WRITING
expr_stmt|;
name|tu
operator|->
name|tu_flags
operator|&=
operator|~
operator|(
name|TU_EOF
operator||
name|TU_EOT
operator||
name|TU_RDATA
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rewind a tape device  */
end_comment

begin_function
name|long
name|trewin_
parameter_list|(
name|tlu
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|;
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
name|char
name|namebuf
index|[
name|TU_NAMESIZE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|munit
decl_stmt|;
name|int
name|rfd
decl_stmt|;
name|long
name|labelled
decl_stmt|;
name|long
name|one
init|=
literal|1L
decl_stmt|;
name|long
name|zero
init|=
literal|0L
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
operator|)
condition|)
block|{
name|errno
operator|=
name|F_ERNOPEN
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|labelled
operator|=
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_LABELLED
operator|)
expr_stmt|;
name|tclose_
argument_list|(
name|tlu
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tu
operator|->
name|tu_name
operator|,
name|q
operator|=
name|namebuf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'n'
condition|)
comment|/* norewind name */
continue|continue;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* might be norewind minor dev */
name|munit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|munit
operator|=
operator|(
literal|10
operator|*
name|munit
operator|)
operator|+
operator|(
operator|*
name|p
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|munit
operator|&
literal|03
operator|)
operator|+
literal|'0'
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* debug  printf("rewinding [%s]\n", namebuf); /* */
if|if
condition|(
operator|(
name|rfd
operator|=
name|open
argument_list|(
name|namebuf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|save_errno
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|save_errno
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
block|}
name|topen_
argument_list|(
name|tlu
argument_list|,
name|tu
operator|->
name|tu_name
argument_list|,
operator|&
name|labelled
argument_list|,
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|tu
operator|->
name|tu_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|labelled
condition|)
block|{
name|tskipf_
argument_list|(
name|tlu
argument_list|,
operator|&
name|one
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
name|tu
operator|->
name|tu_file
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|save_errno
condition|)
block|{
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
return|return
operator|(
literal|0L
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip forward files  *  * NOTE: This is a kludge, to be fixed after 4.1a  */
end_comment

begin_function
name|long
name|tskipf_
parameter_list|(
name|tlu
parameter_list|,
name|nfiles
parameter_list|,
name|nrecs
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|;
name|long
modifier|*
name|nfiles
decl_stmt|;
name|long
modifier|*
name|nrecs
decl_stmt|;
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
name|char
name|dummybuf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nf
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|int
name|nb
decl_stmt|;
name|int
name|empty
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
operator|)
condition|)
block|{
name|errno
operator|=
name|F_ERNOPEN
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_WRITING
condition|)
block|{
name|errno
operator|=
name|F_ERILLOP
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|nf
operator|=
operator|(
name|int
operator|)
operator|*
name|nfiles
expr_stmt|;
while|while
condition|(
name|nf
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_EOT
condition|)
block|{
name|errno
operator|=
name|F_ERILLOP
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_EOF
condition|)
name|tu
operator|->
name|tu_flags
operator|&=
operator|~
name|TU_EOF
expr_stmt|;
else|else
block|{
name|empty
operator|=
operator|(
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_RDATA
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|nb
operator|=
name|read
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|,
name|dummybuf
argument_list|,
sizeof|sizeof
name|dummybuf
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|empty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nb
operator|<
literal|0
condition|)
block|{
name|tu
operator|->
name|tu_flags
operator||=
name|TU_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|empty
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_EOT
expr_stmt|;
block|}
name|nf
operator|--
expr_stmt|;
name|tu
operator|->
name|tu_rec
operator|=
literal|0
expr_stmt|;
name|tu
operator|->
name|tu_flags
operator|&=
operator|~
name|TU_RDATA
expr_stmt|;
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_EOT
condition|)
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
else|else
name|tu
operator|->
name|tu_file
operator|++
expr_stmt|;
block|}
name|nr
operator|=
operator|(
name|int
operator|)
operator|*
name|nrecs
expr_stmt|;
while|while
condition|(
name|nr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tu
operator|->
name|tu_flags
operator|&
operator|(
name|TU_EOT
operator||
name|TU_EOF
operator|)
condition|)
block|{
name|errno
operator|=
name|F_ERILLOP
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|empty
operator|=
operator|(
operator|(
name|nb
operator|=
name|read
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|,
name|dummybuf
argument_list|,
sizeof|sizeof
name|dummybuf
argument_list|)
operator|)
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|nb
operator|<
literal|0
condition|)
block|{
name|tu
operator|->
name|tu_flags
operator||=
name|TU_ERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
if|if
condition|(
name|empty
condition|)
block|{
name|tu
operator|->
name|tu_flags
operator||=
name|TU_EOF
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_RDATA
operator|)
condition|)
name|tu
operator|->
name|tu_flags
operator||=
name|TU_EOT
expr_stmt|;
block|}
else|else
name|tu
operator|->
name|tu_flags
operator||=
name|TU_RDATA
expr_stmt|;
name|nr
operator|--
expr_stmt|;
name|tu
operator|->
name|tu_rec
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0L
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return status of tape channel  */
end_comment

begin_function
name|long
name|tstate_
parameter_list|(
name|tlu
parameter_list|,
name|fileno
parameter_list|,
name|recno
parameter_list|,
name|err
parameter_list|,
name|eof
parameter_list|,
name|eot
parameter_list|,
name|tcsr
parameter_list|)
name|long
modifier|*
name|tlu
decl_stmt|,
decl|*
name|fileno
decl_stmt|,
modifier|*
name|recno
decl_stmt|,
modifier|*
name|err
decl_stmt|,
modifier|*
name|eof
decl_stmt|,
modifier|*
name|eot
decl_stmt|,
modifier|*
name|tcsr
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|tunits
modifier|*
name|tu
decl_stmt|;
name|int
name|csr
decl_stmt|;
if|if
condition|(
operator|*
name|tlu
operator|<
literal|0
operator|||
operator|*
name|tlu
operator|>=
name|TU_MAXTAPES
condition|)
block|{
name|errno
operator|=
name|F_ERUNIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
name|tu
operator|=
operator|&
name|tunits
index|[
operator|*
name|tlu
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_OPEN
operator|)
condition|)
block|{
name|errno
operator|=
name|F_ERNOPEN
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
operator|*
name|fileno
operator|=
operator|(
name|long
operator|)
name|tu
operator|->
name|tu_file
expr_stmt|;
operator|*
name|recno
operator|=
operator|(
name|long
operator|)
name|tu
operator|->
name|tu_rec
expr_stmt|;
operator|*
name|err
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_ERR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|eof
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_EOF
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|eot
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|tu
operator|->
name|tu_flags
operator|&
name|TU_EOT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MTWEOF
comment|/* implies 4.1+ system */
name|ioctl
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|,
name|MTIOCGET
argument_list|,
operator|&
name|mtget
argument_list|)
expr_stmt|;
operator|*
name|tcsr
operator|=
operator|(
name|long
operator|)
name|mtget
operator|.
name|mt_dsreg
operator|&
literal|0xffff
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|tu
operator|->
name|tu_fd
argument_list|,
name|MTIOCGET
argument_list|,
operator|&
name|csr
argument_list|)
expr_stmt|;
operator|*
name|tcsr
operator|=
operator|(
name|long
operator|)
name|csr
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0L
operator|)
return|;
block|}
end_block

end_unit

