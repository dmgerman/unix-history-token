begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)f77.c	5.3 (Berkeley) 1/7/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * f77.c  *  * Driver program for the 4.2 BSD f77 compiler.  *  * University of Utah CS Dept modification history:  *  * $Log:	f77.c,v $  * Revision 5.4  85/12/17  19:12:14  donn  * Dynamically allocate buffer; add lint fixes.  *   * Revision 5.3  85/11/25  00:00:02  donn  * 4.3 beta  *   * Revision 5.2  85/08/10  05:16:14  donn  * Ifdeffed 66 code, added -r8 flag.  From Jerry Berkman.  *   * Revision 5.1  85/08/10  03:32:12  donn  * 4.3 alpha  *   * Revision 1.14  85/03/01  00:07:57  donn  * Portability fix from Ralph Campbell.  *   * Revision 1.13  85/02/12  19:31:47  donn  * Use CATNAME to get the name of a concatenation command instead of  * explicitly running 'cat' -- you can get the wrong 'cat' the old way!  *   * Revision 1.12  85/01/14  06:42:30  donn  * Changed to call the peephole optimizer with the '-f' flag, so that  * floating point moves are translated to integer moves.  *   * Revision 1.11  85/01/14  04:38:59  donn  * Jerry's change to pass -O to f1 so it knows whether the peephole optimizer  * will be run.  This is necessary in order to handle movf/movl translation.  *   * Revision 1.10  85/01/14  03:59:12  donn  * Added Jerry Berkman's fix for the '-q' flag.  *   * Revision 1.9  84/11/09  01:51:26  donn  * Cosmetic change to stupid() suggested by John McCarthy at Memorial  * University, St. Johns.  *   * Revision 1.8  84/09/14  16:02:34  donn  * Added changes to notice when people do 'f77 -c foo.f -o bar.o' and tell  * them why it doesn't do what they think it does.  *   * Revision 1.7  84/08/24  21:08:31  donn  * Added call to setrlimit() to prevent core dumps when not debugging.  * Reorganized the include file arrangment somewhat.  *   * Revision 1.6  84/08/24  20:20:24  donn  * Changed stupidity check on Jerry Berkman's suggestion -- now it balks if  * the load file exists and has a sensitive suffix.  *   * Revision 1.5  84/08/15  18:56:44  donn  * Added test for -O combined with -g, suggested by Raleigh Romine.  To keep  * things simple, if both are specified then the second in the list is thrown  * out and the user is warned.  *   * Revision 1.4  84/08/05  21:33:15  donn  * Added stupidity check -- f77 won't load on a file that it's asked to  * compile as well.  *   * Revision 1.3  84/08/04  22:58:24  donn  * Improved error reporting -- we now explain why we died and what we did.  * Only works on 4.2.  Added at the instigation of Jerry Berkman.  *   * Revision 1.2  84/07/28  13:11:24  donn  * Added Ralph Campbell's changes to reduce offsets to data.  *   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xxxvers
index|[]
init|=
literal|"\n@(#) F77 DRIVER, VERSION 4.2,   1984 JULY 28\n"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIGPROF
end_ifdef

begin_comment
comment|/*  * Some 4.2 BSD capabilities.  */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_define
define|#
directive|define
name|NOCORE
value|1
end_define

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_define
define|#
directive|define
name|PSIGNAL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_include
include|#
directive|include
file|"machdefs.h"
end_include

begin_include
include|#
directive|include
file|"drivedefs.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_decl_stmt
specifier|static
name|FILEP
name|diagfile
init|=
block|{
name|stderr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigivalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigqvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sighvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigtvalue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass1name
init|=
name|PASS1NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass2name
init|=
name|PASS2NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pass2opt
init|=
name|PASS2OPT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|asmname
init|=
name|ASMNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ldname
init|=
name|LDNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|footname
init|=
name|FOOTNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|proffoot
init|=
name|PROFFOOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|macroname
init|=
literal|"m4"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shellname
init|=
literal|"/bin/sh"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cppname
init|=
literal|"/lib/cpp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aoutname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temppref
init|=
name|TEMPPREF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|infname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|textfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|asmfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|asmpass2
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|initfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sortfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|prepfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|objfdefault
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|optzfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|setfname
index|[
literal|44
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fflags
index|[
literal|50
index|]
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|f2flags
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cflags
index|[
literal|50
index|]
init|=
literal|"-c"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TARGET
operator|==
name|GCOS
end_if

begin_decl_stmt
specifier|static
name|char
name|eflags
index|[
literal|30
index|]
init|=
literal|"system=gcos "
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|eflags
index|[
literal|30
index|]
init|=
literal|"system=unix "
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|rflags
index|[
literal|30
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lflag
index|[
literal|3
index|]
init|=
literal|"-x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fflagp
init|=
name|fflags
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|f2flagp
init|=
name|f2flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eflagp
init|=
name|eflags
operator|+
literal|12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rflagp
init|=
name|rflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cppflags
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|cppargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|loadargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|loadp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|erred
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|loadflag
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|saveasmflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|profileflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|optimflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|debugflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|verbose
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|fortonly
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|macroflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|sdbflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flag
name|namesflag
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TARGET
operator|==
name|PDP11
end_if

begin_decl_stmt
specifier|static
name|flag
name|nofloating
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ncpp
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|c
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|setdoto
argument_list|()
decl_stmt|,
modifier|*
name|lastchar
argument_list|()
decl_stmt|,
modifier|*
name|lastfield
argument_list|()
decl_stmt|,
modifier|*
name|copys
argument_list|()
decl_stmt|,
modifier|*
name|argvtos
argument_list|()
decl_stmt|;
name|ptr
name|ckalloc
parameter_list|()
function_decl|;
name|char
modifier|*
name|strcat
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|fortfile
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|intrupt
parameter_list|()
function_decl|;
name|int
name|new_aoutname
init|=
name|NO
decl_stmt|;
name|sigivalue
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|sigqvalue
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|sighvalue
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|sigtvalue
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
name|enbint
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|crfnames
argument_list|()
expr_stmt|;
name|cppargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cppargs
argument_list|)
argument_list|)
expr_stmt|;
name|loadargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|argc
operator|+
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|loadargs
argument_list|)
argument_list|)
expr_stmt|;
name|loadargs
index|[
literal|1
index|]
operator|=
literal|"-X"
expr_stmt|;
name|loadargs
index|[
literal|2
index|]
operator|=
literal|"-u"
expr_stmt|;
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|VAX
name|loadargs
index|[
literal|3
index|]
operator|=
literal|"_MAIN_"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HERE
operator|==
name|INTERDATA
name|loadargs
index|[
literal|3
index|]
operator|=
literal|"main"
expr_stmt|;
endif|#
directive|endif
name|loadp
operator|=
name|loadargs
operator|+
literal|4
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|50
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|n
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|s
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'T'
case|:
comment|/* use special passes */
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'1'
case|:
name|pass1name
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'2'
case|:
name|pass2name
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'p'
case|:
name|pass2opt
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'a'
case|:
name|asmname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'l'
case|:
name|ldname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'F'
case|:
name|footname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'m'
case|:
name|macroname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'t'
case|:
name|temppref
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
default|default:
name|fatali
argument_list|(
literal|"bad option -T%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ONLY66
case|case
literal|'6'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'6'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag 6%c\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
case|case
literal|'w'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|copyfflag
label|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'1'
case|:
case|case
literal|'C'
case|:
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|sdbflag
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-O and -g are incompatible; -O ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|optimflag
operator|=
name|YES
expr_stmt|;
operator|*
name|f2flagp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|f2flagp
operator|++
operator|=
literal|'O'
expr_stmt|;
operator|*
name|f2flagp
operator|++
operator|=
literal|' '
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
operator|*
name|loadp
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
literal|"-d"
expr_stmt|;
endif|#
directive|endif
operator|*
name|fflagp
operator|++
operator|=
literal|'O'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
operator|*
name|fflagp
operator|++
operator|=
literal|'N'
expr_stmt|;
if|if
condition|(
name|oneof
argument_list|(
operator|*
operator|++
name|s
argument_list|,
literal|"qxscn"
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag -N%c\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'X'
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'4'
condition|)
operator|++
name|s
expr_stmt|;
name|macroflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -S"
argument_list|)
expr_stmt|;
name|saveasmflag
operator|=
name|YES
expr_stmt|;
case|case
literal|'c'
case|:
if|if
condition|(
name|new_aoutname
operator|==
name|YES
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-c prevents loading, -o %s ignored\n"
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
name|new_aoutname
operator|=
name|NO
expr_stmt|;
block|}
name|loadflag
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|YES
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\nBerkeley F77, version %s\n"
argument_list|,
name|VERSIONNUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debugflag
operator|=
name|YES
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'d'
expr_stmt|;
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|','
condition|)
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'X'
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'M'
case|:
operator|*
name|loadp
operator|++
operator|=
literal|"-M"
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|optimflag
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-g and -O are incompatible; -g ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -g"
argument_list|)
expr_stmt|;
name|sdbflag
operator|=
name|YES
expr_stmt|;
goto|goto
name|copyfflag
goto|;
case|case
literal|'p'
case|:
name|profileflag
operator|=
name|YES
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cflags
argument_list|,
literal|" -p"
argument_list|)
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
literal|'p'
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'g'
condition|)
block|{
name|proffoot
operator|=
name|GPRFFOOT
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|namesflag
operator|=
name|NO
expr_stmt|;
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"onetrip"
argument_list|)
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|endfor
goto|;
block|}
name|new_aoutname
operator|=
name|YES
expr_stmt|;
name|aoutname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
if|if
condition|(
name|loadflag
operator|==
name|NO
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-c prevents loading, -o %s ignored\n"
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
name|new_aoutname
operator|=
name|NO
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
case|case
literal|'f'
case|:
name|nofloating
operator|=
name|YES
expr_stmt|;
name|pass2name
operator|=
name|NOFLPASS2
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'F'
case|:
name|fortonly
operator|=
name|YES
expr_stmt|;
name|loadflag
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'I'
case|:
name|cppargs
index|[
name|ncpp
operator|++
index|]
operator|=
operator|*
name|argv
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'i'
case|:
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'2'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'4'
operator|)
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|fflagp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"invalid flag -i%c\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'r'
case|:
comment|/* -r8 - double the precision */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|s
operator|++
expr_stmt|;
goto|goto
name|copyfflag
goto|;
block|}
else|else
block|{
operator|*
name|loadp
operator|++
operator|=
literal|"-r"
expr_stmt|;
break|break;
block|}
case|case
literal|'l'
case|:
comment|/* letter ell--library */
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
name|s
operator|-
literal|1
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'E'
case|:
comment|/* EFL flag argument */
while|while
condition|(
operator|*
name|eflagp
operator|++
operator|=
operator|*
operator|++
name|s
condition|)
empty_stmt|;
operator|*
name|eflagp
operator|++
operator|=
literal|' '
expr_stmt|;
goto|goto
name|endfor
goto|;
case|case
literal|'R'
case|:
while|while
condition|(
operator|*
name|rflagp
operator|++
operator|=
operator|*
operator|++
name|s
condition|)
empty_stmt|;
operator|*
name|rflagp
operator|++
operator|=
literal|' '
expr_stmt|;
goto|goto
name|endfor
goto|;
default|default:
name|lflag
index|[
literal|1
index|]
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|loadp
operator|++
operator|=
name|copys
argument_list|(
name|lflag
argument_list|)
expr_stmt|;
break|break;
block|}
name|endfor
label|:
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOCORE
if|if
condition|(
operator|!
name|debugflag
condition|)
block|{
name|struct
name|rlimit
name|r
decl_stmt|;
name|r
operator|.
name|rlim_cur
operator|=
name|r
operator|.
name|rlim_max
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|NOCORE
operator|*
name|fflagp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ncpp
operator|>
literal|0
condition|)
name|cppflags
operator|=
name|argvtos
argument_list|(
name|ncpp
argument_list|,
name|cppargs
argument_list|)
expr_stmt|;
name|loadargs
index|[
literal|0
index|]
operator|=
name|ldname
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
if|if
condition|(
name|nofloating
condition|)
operator|*
name|loadp
operator|++
operator|=
operator|(
name|profileflag
condition|?
name|NOFLPROF
else|:
name|NOFLFOOT
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|loadp
operator|++
operator|=
operator|(
name|profileflag
condition|?
name|proffoot
else|:
name|footname
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|c
operator|=
name|dotchar
argument_list|(
name|infname
operator|=
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* Ratfor file */
case|case
literal|'e'
case|:
comment|/* EFL file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|fortfile
expr_stmt|;
name|t
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|)
empty_stmt|;
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|macroflag
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s>%s"
argument_list|,
name|macroname
argument_list|,
name|infname
argument_list|,
name|prepfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
block|{
name|rmf
argument_list|(
name|prepfname
argument_list|)
expr_stmt|;
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|infname
operator|=
name|prepfname
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"efl %s %s>%s"
argument_list|,
name|eflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"ratfor %s %s>%s"
argument_list|,
name|rflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|macroflag
condition|)
name|rmf
argument_list|(
name|infname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fortonly
condition|)
block|{
name|infname
operator|=
name|argv
index|[
name|i
index|]
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|lastchar
argument_list|(
name|infname
argument_list|)
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* C preprocessor -> Fortran file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|fortfile
expr_stmt|;
name|t
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|)
empty_stmt|;
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|'f'
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s>%s"
argument_list|,
name|cppname
argument_list|,
name|cppflags
argument_list|,
name|infname
argument_list|,
name|fortfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|sys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fortonly
condition|)
block|{
name|infname
operator|=
name|argv
index|[
name|i
index|]
operator|=
name|lastfield
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|lastchar
argument_list|(
name|infname
argument_list|)
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
name|rmf
argument_list|(
name|fortfile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* Fortran file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|dofort
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* C file */
case|case
literal|'s'
case|:
comment|/* Assembler file */
if|if
condition|(
name|unreadable
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|erred
operator|=
name|YES
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|VAX
if|if
condition|(
name|namesflag
operator|==
name|YES
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"cc %s %s"
argument_list|,
name|cflags
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|nodup
argument_list|(
name|t
operator|=
name|setdoto
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|nodup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|loadp
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-o"
argument_list|)
condition|)
block|{
name|aoutname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|new_aoutname
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|loadflag
operator|==
name|NO
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"-c prevents loading, -o %s ignored\n"
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
name|new_aoutname
operator|=
name|NO
expr_stmt|;
block|}
block|}
else|else
operator|*
name|loadp
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|loadflag
operator|&&
name|stupid
argument_list|(
name|aoutname
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|loadflag
operator|&&
operator|!
name|erred
condition|)
name|doload
argument_list|(
name|loadargs
argument_list|,
name|loadp
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|erred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * argvtos() copies a list of arguments contained in an array of character  * strings to a single dynamically allocated string. Each argument is  * separated by one blank space. Returns a pointer to the string or null  * if out of memory.  */
end_comment

begin_define
define|#
directive|define
name|SBUFINCR
value|1024
end_define

begin_define
define|#
directive|define
name|SBUFMAX
value|10240
end_define

begin_function
name|char
modifier|*
name|argvtos
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string pointer */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* string buffer pointer */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
comment|/* increase size of storage */
name|char
modifier|*
name|sbuf
decl_stmt|;
comment|/* string buffer */
name|int
name|nbytes
decl_stmt|;
comment|/* bytes of memory required */
name|int
name|nu
decl_stmt|;
comment|/* no. of SBUFINCR units required */
name|int
name|sbufsize
decl_stmt|;
comment|/* current size of sbuf */
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* string length */
name|sbufsize
operator|=
name|SBUFINCR
expr_stmt|;
if|if
condition|(
operator|(
name|sbuf
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|sbufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"out of memory (argvtos)"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
operator|++
name|argv
control|)
block|{
if|if
condition|(
operator|(
name|nbytes
operator|=
operator|(
name|i
operator|+
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
literal|1
operator|-
name|sbufsize
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
name|nu
operator|=
operator|(
name|nbytes
operator|+
name|SBUFINCR
operator|-
literal|1
operator|)
operator|/
name|SBUFINCR
expr_stmt|;
name|sbufsize
operator|+=
name|nu
operator|*
name|SBUFINCR
expr_stmt|;
if|if
condition|(
name|sbufsize
operator|>
name|SBUFMAX
condition|)
block|{
name|fatal
argument_list|(
literal|"argument length exceeded (argvtos)"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|sbuf
operator|=
name|realloc
argument_list|(
name|sbuf
argument_list|,
operator|(
name|unsigned
operator|)
name|sbufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"out of memory (argvtos)"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
for|for
control|(
name|s
operator|=
operator|*
name|argv
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
name|sbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|sbuf
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|sbuf
index|[
operator|--
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|sbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|dofort
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retcode
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
name|infname
operator|=
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s %s %s"
argument_list|,
name|pass1name
argument_list|,
name|fflags
argument_list|,
name|s
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|textfname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
goto|goto
name|error
goto|;
case|case
literal|0
case|:
break|break;
default|default:
goto|goto
name|comperror
goto|;
block|}
if|if
condition|(
name|dopass2
argument_list|()
condition|)
goto|goto
name|comperror
goto|;
name|doasm
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|ret
label|:
name|rmf
argument_list|(
name|asmfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|initfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|textfname
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
name|error
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\nError.  No assembly.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
name|comperror
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\ncompiler error.\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|2
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_block

begin_macro
name|dopass2
argument_list|()
end_macro

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"PASS2."
argument_list|)
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|DMR
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s - %s"
argument_list|,
name|pass2name
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sys
argument_list|(
name|buff
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|FAMILY
operator|==
name|PCC
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -A%s<%s>%s"
argument_list|,
name|pass2name
argument_list|,
name|setfname
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s>%s"
argument_list|,
name|pass2name
argument_list|,
name|f2flags
argument_list|,
name|textfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|sys
argument_list|(
name|buff
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|doasm
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|lastc
decl_stmt|;
name|char
modifier|*
name|obj
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|lastchar
argument_list|()
decl_stmt|,
modifier|*
name|setdoto
argument_list|()
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|s
operator|=
name|objfdefault
expr_stmt|;
name|lastc
operator|=
name|lastchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|obj
operator|=
name|setdoto
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
ifdef|#
directive|ifdef
name|PASS2OPT
if|if
condition|(
name|optimflag
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -f %s %s"
argument_list|,
name|pass2opt
argument_list|,
name|asmpass2
argument_list|,
name|optzfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|rmf
argument_list|(
name|optzfname
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"mv %s %s"
argument_list|,
name|optzfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"can't rename optimizer output file"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|saveasmflag
condition|)
block|{
operator|*
name|lastc
operator|=
literal|'s'
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s %s>%s"
argument_list|,
name|CATNAME
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|setfname
argument_list|,
name|asmpass2
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|TARGET
operator|==
name|VAX
if|if
condition|(
name|sdbflag
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s>%s"
argument_list|,
name|CATNAME
argument_list|,
name|asmfname
argument_list|,
name|asmpass2
argument_list|,
name|initfname
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s>%s"
argument_list|,
name|CATNAME
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|asmpass2
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s %s>%s"
argument_list|,
name|CATNAME
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|asmpass2
argument_list|,
name|obj
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"can't concatenate assembly files"
argument_list|)
expr_stmt|;
operator|*
name|lastc
operator|=
literal|'o'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"  ASM."
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -o %s %s %s %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|,
name|initfname
argument_list|,
name|setfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* vax assembler currently accepts only one input file */
if|if
condition|(
name|sdbflag
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s>>%s"
argument_list|,
name|CATNAME
argument_list|,
name|asmpass2
argument_list|,
name|initfname
argument_list|,
name|asmfname
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %s %s>>%s"
argument_list|,
name|CATNAME
argument_list|,
name|initfname
argument_list|,
name|asmpass2
argument_list|,
name|asmfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"can't concatenate assembly files"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UCBVAXASM
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -J -o %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -o %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|PDP11
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -u -o %s %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|!=
name|INTERDATA
operator|&&
name|TARGET
operator|!=
name|PDP11
operator|&&
name|TARGET
operator|!=
name|VAX
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s -o %s %s %s"
argument_list|,
name|asmname
argument_list|,
name|obj
argument_list|,
name|asmfname
argument_list|,
name|asmpass2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sys
argument_list|(
name|buff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"assembler error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|&&
name|TARGET
operator|!=
name|PDP11
name|rmf
argument_list|(
name|obj
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rmf
argument_list|(
name|asmpass2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doload
argument_list|(
name|v0
argument_list|,
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v0
index|[]
operator|,
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|waitpid
decl_stmt|;
if|if
condition|(
name|sdbflag
condition|)
operator|*
name|v
operator|++
operator|=
literal|"-lg"
expr_stmt|;
if|if
condition|(
name|profileflag
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p_liblist
init|;
operator|*
name|p
condition|;
operator|*
name|v
operator|++
operator|=
operator|*
name|p
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|liblist
init|;
operator|*
name|p
condition|;
operator|*
name|v
operator|++
operator|=
operator|*
name|p
operator|++
control|)
empty_stmt|;
block|}
operator|*
name|v
operator|++
operator|=
literal|"-o"
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|aoutname
expr_stmt|;
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"LOAD."
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
condition|)
block|{
for|for
control|(
name|p
operator|=
name|v0
init|;
name|p
operator|<
name|v
condition|;
operator|++
name|p
control|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s "
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HERE
operator|==
name|PDP11
operator|||
name|HERE
operator|==
name|INTERDATA
operator|||
name|HERE
operator|==
name|VAX
if|if
condition|(
operator|(
name|waitpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|enbint
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|ldname
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|fatalstr
argument_list|(
literal|"couldn't load %s"
argument_list|,
name|ldname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|await
argument_list|(
name|waitpid
argument_list|)
condition|)
name|erred
operator|=
name|YES
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HERE
operator|==
name|INTERDATA
if|if
condition|(
name|optimflag
condition|)
block|{
name|char
name|buff1
index|[
literal|100
index|]
decl_stmt|,
name|buff2
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff1
argument_list|,
literal|"nopt %s -o junk.%d"
argument_list|,
name|aoutname
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff2
argument_list|,
literal|"mv junk.%d %s"
argument_list|,
name|pid
argument_list|,
name|aoutname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
argument_list|(
name|buff1
argument_list|)
operator|||
name|sys
argument_list|(
name|buff2
argument_list|)
condition|)
name|err
argument_list|(
literal|"bad optimization"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Process control and Shell-simulating routines */
end_comment

begin_macro
name|sys
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|100
index|]
decl_stmt|,
name|path
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|inname
decl_stmt|,
modifier|*
name|outname
decl_stmt|;
name|int
name|append
decl_stmt|;
name|int
name|waitpid
decl_stmt|;
name|int
name|argc
decl_stmt|;
if|if
condition|(
name|debugflag
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|inname
operator|=
name|NULL
expr_stmt|;
name|outname
operator|=
name|NULL
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|shellname
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|++
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'<'
condition|)
name|inname
operator|=
name|t
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|append
operator|=
name|YES
expr_stmt|;
name|outname
operator|=
name|t
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|append
operator|=
name|NO
expr_stmt|;
name|outname
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
operator|&&
operator|*
name|t
operator|!=
literal|'\0'
condition|)
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|++
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
comment|/* no command */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|path
expr_stmt|;
name|t
operator|=
literal|"/usr/bin/"
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
for|for
control|(
name|t
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|waitpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inname
condition|)
if|if
condition|(
name|freopen
argument_list|(
name|inname
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|fatalstr
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
condition|)
if|if
condition|(
name|freopen
argument_list|(
name|outname
argument_list|,
operator|(
name|append
condition|?
literal|"a"
else|:
literal|"w"
operator|)
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|fatalstr
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|enbint
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
name|texec
argument_list|(
name|path
operator|+
literal|9
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* command */
name|texec
argument_list|(
name|path
operator|+
literal|4
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*  /bin/command */
name|texec
argument_list|(
name|path
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* /usr/bin/command */
name|fatalstr
argument_list|(
literal|"Cannot load %s"
argument_list|,
name|path
operator|+
literal|9
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|await
argument_list|(
name|waitpid
argument_list|)
operator|)
return|;
block|}
end_block

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_comment
comment|/* modified version from the Shell */
end_comment

begin_macro
name|texec
argument_list|(
argument|f
argument_list|,
argument|av
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|execv
argument_list|(
name|f
argument_list|,
name|av
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
name|av
index|[
literal|1
index|]
operator|=
name|f
expr_stmt|;
name|execv
argument_list|(
name|shellname
argument_list|,
name|av
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"No shell!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
name|fatalstr
argument_list|(
literal|"%s: too large"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|recurs
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|recurs
operator|==
name|NO
condition|)
block|{
name|recurs
operator|=
name|YES
expr_stmt|;
name|rmfiles
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
name|enbint
function_decl|(
name|k
function_decl|)
name|int
argument_list|(
argument|*k
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|sigivalue
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigqvalue
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sighvalue
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtvalue
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|intrupt
argument_list|()
end_macro

begin_block
block|{
name|done
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|PSIGNAL
end_ifdef

begin_comment
comment|/*  * Fancy 4.2 BSD signal printing stuff.  */
end_comment

begin_decl_stmt
name|char
name|harmless
index|[
name|NSIG
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|await
argument_list|(
argument|waitpid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|waitpid
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PSIGNAL
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
name|union
name|wait
name|status
decl_stmt|;
else|#
directive|else
else|PSIGNAL
name|int
name|status
decl_stmt|;
endif|#
directive|endif
endif|PSIGNAL
name|int
name|w
decl_stmt|;
name|enbint
argument_list|(
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|waitpid
condition|)
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"bad wait code"
argument_list|)
expr_stmt|;
name|enbint
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PSIGNAL
if|if
condition|(
name|status
operator|.
name|w_termsig
condition|)
block|{
name|debugflag
operator|=
literal|0
expr_stmt|;
comment|/* Prevent us from dumping core ourselves */
if|if
condition|(
name|status
operator|.
name|w_termsig
operator|!=
name|SIGINT
operator|&&
name|status
operator|.
name|w_termsig
operator|<
name|NSIG
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s%s\n"
argument_list|,
name|sys_siglist
index|[
name|status
operator|.
name|w_termsig
index|]
argument_list|,
name|status
operator|.
name|w_coredump
condition|?
literal|" -- core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|w_termsig
operator|<
name|NSIG
operator|&&
operator|!
name|harmless
index|[
name|status
operator|.
name|w_termsig
index|]
condition|)
name|fatal
argument_list|(
literal|"see a system manager"
argument_list|)
expr_stmt|;
else|else
name|done
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|.
name|w_retcode
operator|)
return|;
else|#
directive|else
else|PSIGNAL
if|if
condition|(
name|status
operator|&
literal|0377
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|SIGINT
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Termination code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|>>
literal|8
operator|)
return|;
endif|#
directive|endif
endif|PSIGNAL
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* File Name and File Manipulation Routines */
end_comment

begin_expr_stmt
name|unreadable
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Error: Cannot read file %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|stupid
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|c
operator|=
name|dotchar
argument_list|(
name|s
argument_list|)
operator|)
operator|&&
name|index
argument_list|(
literal|"focsreF"
argument_list|,
name|c
argument_list|)
operator|&&
name|access
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Loading on %s would destroy it\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_macro
name|clf
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|FILEP
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"writing error"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|rmfiles
argument_list|()
end_macro

begin_block
block|{
name|rmf
argument_list|(
name|textfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|asmfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|initfname
argument_list|)
expr_stmt|;
name|rmf
argument_list|(
name|asmpass2
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|INTERDATA
name|rmf
argument_list|(
name|setfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* return -1 if file does not exist, 0 if it is of zero length    and 1 if of positive length */
end_comment

begin_macro
name|content
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VERSION6
struct|struct
name|stat
block|{
name|char
name|cjunk
index|[
literal|9
index|]
decl_stmt|;
name|char
name|size0
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|int
name|ijunk
index|[
literal|12
index|]
decl_stmt|;
block|}
name|buf
struct|;
else|#
directive|else
name|struct
name|stat
name|buf
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|VERSION6
return|return
operator|(
name|buf
operator|.
name|size0
operator|||
name|buf
operator|.
name|size1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|buf
operator|.
name|st_size
operator|>
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|crfnames
argument_list|()
end_macro

begin_block
block|{
name|fname
argument_list|(
name|textfname
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|asmfname
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|asmpass2
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|initfname
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|sortfname
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|objfdefault
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|prepfname
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|optzfname
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
name|fname
argument_list|(
name|setfname
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rmf
argument_list|(
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|fn
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* if(!debugflag&& fn!=NULL&& *fn!='\0') */
if|if
condition|(
name|fn
operator|!=
name|NULL
operator|&&
operator|*
name|fn
operator|!=
literal|'\0'
condition|)
name|unlink
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|fname
parameter_list|(
name|name
parameter_list|,
name|suff
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|suff
decl_stmt|;
end_function

begin_block
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"/tmp/%s%d.%s"
argument_list|,
name|temppref
argument_list|,
name|pid
argument_list|,
name|suff
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dotchar
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|s
index|[
literal|1
index|]
operator|)
return|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|lastfield
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
name|t
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|lastchar
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
operator|++
name|s
expr_stmt|;
return|return
operator|(
name|s
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|setdoto
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
operator|*
name|lastchar
argument_list|(
name|s
argument_list|)
operator|=
literal|'o'
expr_stmt|;
return|return
operator|(
name|lastfield
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|badfile
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fatalstr
argument_list|(
literal|"cannot open intermediate file %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|ckalloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|ptr
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
if|if
condition|(
name|p
operator|=
operator|(
name|ptr
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|char
modifier|*
name|copyn
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|copys
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|copyn
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|oneof
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|YES
operator|)
return|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_macro
name|nodup
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|loadargs
init|;
name|p
operator|<
name|loadp
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fatal
argument_list|(
argument|t
argument_list|)
name|char
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Compiler error in file %s: %s\n"
argument_list|,
name|infname
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
condition|)
name|abort
argument_list|()
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fatali
argument_list|(
argument|t
argument_list|,
argument|d
argument_list|)
name|char
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fatalstr
argument_list|(
argument|t
argument_list|,
argument|s
argument_list|)
name|char
operator|*
name|t
operator|,
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|err
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Error in file %s: %s\n"
argument_list|,
name|infname
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

