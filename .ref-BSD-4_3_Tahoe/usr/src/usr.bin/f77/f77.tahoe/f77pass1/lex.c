begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lex.c	5.1 (Berkeley) 6/7/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * lex.c  *  * Lexical scanner routines for the f77 compiler, pass 1, 4.2 BSD.  *  * University of Utah CS Dept modification history:  *  * $Log:	lex.c,v $  * Revision 1.2  84/10/27  02:20:09  donn  * Fixed bug where the input file and the name field of the include file  * structure shared -- when the input file name was freed, the include file  * name got stomped on, leading to peculiar error messages.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tokdefs.h"
end_include

begin_define
define|#
directive|define
name|BLANK
value|' '
end_define

begin_define
define|#
directive|define
name|MYQUOTE
value|(2)
end_define

begin_define
define|#
directive|define
name|SEOF
value|0
end_define

begin_comment
comment|/* card types */
end_comment

begin_define
define|#
directive|define
name|STEOF
value|1
end_define

begin_define
define|#
directive|define
name|STINITIAL
value|2
end_define

begin_define
define|#
directive|define
name|STCONTINUE
value|3
end_define

begin_comment
comment|/* lex states */
end_comment

begin_define
define|#
directive|define
name|NEWSTMT
value|1
end_define

begin_define
define|#
directive|define
name|FIRSTTOKEN
value|2
end_define

begin_define
define|#
directive|define
name|OTHERTOKEN
value|3
end_define

begin_define
define|#
directive|define
name|RETEOS
value|4
end_define

begin_decl_stmt
name|LOCAL
name|int
name|stkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|lastend
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|yystno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|intonly
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|int
name|stno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|int
name|nxtstno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|parlev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|expcom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|expeql
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|nextch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|lastch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|nextcd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|endcd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|prevlin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|thislin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|lexstate
init|=
name|NEWSTMT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
name|s
index|[
literal|1390
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|send
init|=
name|s
operator|+
literal|20
operator|*
literal|66
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|nincl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|newname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Inclfile
block|{
name|struct
name|Inclfile
modifier|*
name|inclnext
decl_stmt|;
name|FILEP
name|inclfp
decl_stmt|;
name|char
modifier|*
name|inclname
decl_stmt|;
name|int
name|incllno
decl_stmt|;
name|char
modifier|*
name|incllinp
decl_stmt|;
name|int
name|incllen
decl_stmt|;
name|int
name|inclcode
decl_stmt|;
name|ftnint
name|inclstno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|LOCAL
name|struct
name|Inclfile
modifier|*
name|inclp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Keylist
block|{
name|char
modifier|*
name|keyname
decl_stmt|;
name|int
name|keyval
decl_stmt|;
name|char
name|notinf66
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Punctlist
block|{
name|char
name|punchar
decl_stmt|;
name|int
name|punval
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Fmtlist
block|{
name|char
name|fmtchar
decl_stmt|;
name|int
name|fmtval
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Dotlist
block|{
name|char
modifier|*
name|dotname
decl_stmt|;
name|int
name|dotval
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|LOCAL
name|struct
name|Keylist
modifier|*
name|keystart
index|[
literal|26
index|]
decl_stmt|,
modifier|*
name|keyend
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|inilex
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nincl
operator|=
literal|0
expr_stmt|;
name|inclp
operator|=
name|NULL
expr_stmt|;
name|doinclude
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|lexstate
operator|=
name|NEWSTMT
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_comment
comment|/* throw away the rest of the current line */
end_comment

begin_macro
name|flline
argument_list|()
end_macro

begin_block
block|{
name|lexstate
operator|=
name|RETEOS
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|lexline
parameter_list|(
name|n
parameter_list|)
name|int
modifier|*
name|n
decl_stmt|;
block|{
operator|*
name|n
operator|=
operator|(
name|lastch
operator|-
name|nextch
operator|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|nextch
operator|)
return|;
block|}
end_function

begin_macro
name|doinclude
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILEP
name|fp
decl_stmt|;
name|struct
name|Inclfile
modifier|*
name|t
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|lastslash
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|inclp
condition|)
block|{
name|inclp
operator|->
name|incllno
operator|=
name|thislin
expr_stmt|;
name|inclp
operator|->
name|inclcode
operator|=
name|code
expr_stmt|;
name|inclp
operator|->
name|inclstno
operator|=
name|nxtstno
expr_stmt|;
if|if
condition|(
name|nextcd
condition|)
name|inclp
operator|->
name|incllinp
operator|=
name|copyn
argument_list|(
name|inclp
operator|->
name|incllen
operator|=
name|endcd
operator|-
name|nextcd
argument_list|,
name|nextcd
argument_list|)
expr_stmt|;
else|else
name|inclp
operator|->
name|incllinp
operator|=
literal|0
expr_stmt|;
block|}
name|nextcd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|++
name|nincl
operator|>=
name|MAXINCLUDES
condition|)
name|fatal
argument_list|(
literal|"includes nested too deep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|inclp
operator|==
name|NULL
condition|)
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
block|{
name|lastslash
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|s
operator|=
name|inclp
operator|->
name|inclname
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
name|lastslash
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|lastslash
condition|)
block|{
operator|*
name|lastslash
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s"
argument_list|,
name|inclp
operator|->
name|inclname
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|lastslash
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"/usr/include/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
name|name
operator|=
name|copys
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
block|{
name|t
operator|=
name|inclp
expr_stmt|;
name|inclp
operator|=
name|ALLOC
argument_list|(
name|Inclfile
argument_list|)
expr_stmt|;
name|inclp
operator|->
name|inclnext
operator|=
name|t
expr_stmt|;
name|prevlin
operator|=
name|thislin
operator|=
literal|0
expr_stmt|;
name|inclp
operator|->
name|inclname
operator|=
name|name
expr_stmt|;
name|infname
operator|=
name|copys
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|infile
operator|=
name|inclp
operator|->
name|inclfp
operator|=
name|fp
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Cannot open file %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|popinclude
parameter_list|()
block|{
name|struct
name|Inclfile
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
name|infile
operator|!=
name|stdin
condition|)
name|clf
argument_list|(
operator|&
name|infile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
operator|--
name|nincl
expr_stmt|;
name|t
operator|=
name|inclp
operator|->
name|inclnext
expr_stmt|;
name|free
argument_list|(
name|inclp
operator|->
name|inclname
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|inclp
argument_list|)
expr_stmt|;
name|inclp
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|inclp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|infile
operator|=
name|inclp
operator|->
name|inclfp
expr_stmt|;
name|infname
operator|=
name|copys
argument_list|(
name|inclp
operator|->
name|inclname
argument_list|)
expr_stmt|;
name|prevlin
operator|=
name|thislin
operator|=
name|inclp
operator|->
name|incllno
expr_stmt|;
name|code
operator|=
name|inclp
operator|->
name|inclcode
expr_stmt|;
name|stno
operator|=
name|nxtstno
operator|=
name|inclp
operator|->
name|inclstno
expr_stmt|;
if|if
condition|(
name|inclp
operator|->
name|incllinp
condition|)
block|{
name|endcd
operator|=
name|nextcd
operator|=
name|s
expr_stmt|;
name|k
operator|=
name|inclp
operator|->
name|incllen
expr_stmt|;
name|p
operator|=
name|inclp
operator|->
name|incllinp
expr_stmt|;
while|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
operator|*
name|endcd
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|inclp
operator|->
name|incllinp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|nextcd
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_function

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|tokno
decl_stmt|;
switch|switch
condition|(
name|lexstate
condition|)
block|{
case|case
name|NEWSTMT
case|:
comment|/* need a new statement */
if|if
condition|(
name|getcds
argument_list|()
operator|==
name|STEOF
condition|)
return|return
operator|(
name|SEOF
operator|)
return|;
name|lastend
operator|=
name|stkey
operator|==
name|SEND
expr_stmt|;
name|crunch
argument_list|()
expr_stmt|;
name|tokno
operator|=
literal|0
expr_stmt|;
name|lexstate
operator|=
name|FIRSTTOKEN
expr_stmt|;
name|yystno
operator|=
name|stno
expr_stmt|;
name|stno
operator|=
name|nxtstno
expr_stmt|;
name|toklen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|SLABEL
operator|)
return|;
name|first
label|:
case|case
name|FIRSTTOKEN
case|:
comment|/* first step on a statement */
name|analyz
argument_list|()
expr_stmt|;
name|lexstate
operator|=
name|OTHERTOKEN
expr_stmt|;
name|tokno
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|stkey
operator|)
return|;
case|case
name|OTHERTOKEN
case|:
comment|/* return next token */
if|if
condition|(
name|nextch
operator|>
name|lastch
condition|)
goto|goto
name|reteos
goto|;
operator|++
name|tokno
expr_stmt|;
if|if
condition|(
operator|(
name|stkey
operator|==
name|SLOGIF
operator|||
name|stkey
operator|==
name|SELSEIF
operator|)
operator|&&
name|parlev
operator|==
literal|0
operator|&&
name|tokno
operator|>
literal|3
condition|)
goto|goto
name|first
goto|;
if|if
condition|(
name|stkey
operator|==
name|SASSIGN
operator|&&
name|tokno
operator|==
literal|3
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|nextch
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|STO
operator|)
return|;
block|}
return|return
operator|(
name|gettok
argument_list|()
operator|)
return|;
name|reteos
label|:
case|case
name|RETEOS
case|:
name|lexstate
operator|=
name|NEWSTMT
expr_stmt|;
return|return
operator|(
name|SEOS
operator|)
return|;
block|}
name|fatali
argument_list|(
literal|"impossible lexstate %d"
argument_list|,
name|lexstate
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|getcds
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|newname
condition|)
block|{
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
name|infname
operator|=
name|newname
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
block|}
name|top
label|:
if|if
condition|(
name|nextcd
operator|==
name|NULL
condition|)
block|{
name|code
operator|=
name|getcd
argument_list|(
name|nextcd
operator|=
name|s
argument_list|)
expr_stmt|;
name|stno
operator|=
name|nxtstno
expr_stmt|;
if|if
condition|(
name|newname
condition|)
block|{
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
name|infname
operator|=
name|newname
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
block|}
name|prevlin
operator|=
name|thislin
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|STEOF
condition|)
if|if
condition|(
name|popinclude
argument_list|()
condition|)
goto|goto
name|top
goto|;
else|else
return|return
operator|(
name|STEOF
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|STCONTINUE
condition|)
block|{
if|if
condition|(
name|newname
condition|)
block|{
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
name|infname
operator|=
name|newname
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
block|}
name|lineno
operator|=
name|thislin
expr_stmt|;
name|err
argument_list|(
literal|"illegal continuation card ignored"
argument_list|)
expr_stmt|;
name|nextcd
operator|=
name|NULL
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|nextcd
operator|>
name|s
condition|)
block|{
name|q
operator|=
name|nextcd
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|endcd
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|endcd
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|nextcd
operator|=
name|endcd
init|;
name|nextcd
operator|+
literal|66
operator|<=
name|send
operator|&&
operator|(
name|code
operator|=
name|getcd
argument_list|(
name|nextcd
argument_list|)
operator|)
operator|==
name|STCONTINUE
condition|;
name|nextcd
operator|=
name|endcd
control|)
empty_stmt|;
name|nextch
operator|=
name|s
expr_stmt|;
name|lastch
operator|=
name|nextcd
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextcd
operator|>=
name|send
condition|)
name|nextcd
operator|=
name|NULL
expr_stmt|;
name|lineno
operator|=
name|prevlin
expr_stmt|;
name|prevlin
operator|=
name|thislin
expr_stmt|;
return|return
operator|(
name|STINITIAL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|getcd
parameter_list|(
name|b
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|bend
decl_stmt|;
name|int
name|speclin
decl_stmt|;
specifier|static
name|char
name|a
index|[
literal|6
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|aend
init|=
name|a
operator|+
literal|6
decl_stmt|;
name|int
name|num
decl_stmt|;
name|top
label|:
name|endcd
operator|=
name|b
expr_stmt|;
name|bend
operator|=
name|b
operator|+
literal|66
expr_stmt|;
name|speclin
operator|=
name|NO
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|==
literal|'&'
condition|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|BLANK
expr_stmt|;
name|a
index|[
literal|5
index|]
operator|=
literal|'x'
expr_stmt|;
name|speclin
operator|=
name|YES
expr_stmt|;
name|bend
operator|=
name|send
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
operator|||
name|c
operator|==
literal|'C'
operator|||
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
operator|++
name|thislin
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
name|BLANK
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|num
operator|=
literal|10
operator|*
name|num
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|thislin
operator|=
name|num
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|==
name|BLANK
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|char
name|fname
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|fname
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|fname
index|[
name|len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|newname
condition|)
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|newname
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
comment|/* a tab in columns 1-6 skips to column 7 */
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|aend
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|aend
condition|)
operator|*
name|p
operator|++
operator|=
name|BLANK
expr_stmt|;
name|speclin
operator|=
name|YES
expr_stmt|;
name|bend
operator|=
name|send
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|aend
condition|)
operator|*
name|p
operator|++
operator|=
name|BLANK
expr_stmt|;
if|if
condition|(
operator|!
name|speclin
condition|)
while|while
condition|(
name|endcd
operator|<
name|bend
condition|)
operator|*
name|endcd
operator|++
operator|=
name|BLANK
expr_stmt|;
block|}
else|else
block|{
comment|/* read body of line */
while|while
condition|(
name|endcd
operator|<
name|bend
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
operator|*
name|endcd
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|speclin
condition|)
while|while
condition|(
name|endcd
operator|<
name|bend
condition|)
operator|*
name|endcd
operator|++
operator|=
name|BLANK
expr_stmt|;
block|}
operator|++
name|thislin
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|a
index|[
literal|5
index|]
argument_list|)
operator|&&
name|a
index|[
literal|5
index|]
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|STCONTINUE
operator|)
return|;
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|aend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|initline
goto|;
for|for
control|(
name|p
operator|=
name|b
init|;
name|p
operator|<
name|endcd
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|initline
goto|;
goto|goto
name|top
goto|;
name|initline
label|:
name|nxtstno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|a
operator|+
literal|5
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|nxtstno
operator|=
literal|10
operator|*
name|nxtstno
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|newname
condition|)
block|{
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
name|infname
operator|=
name|newname
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
block|}
name|lineno
operator|=
name|thislin
expr_stmt|;
name|err
argument_list|(
literal|"nondigit in statement number field"
argument_list|)
expr_stmt|;
name|nxtstno
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|STINITIAL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|crunch
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|j0
decl_stmt|,
modifier|*
name|j1
decl_stmt|,
modifier|*
name|prvstr
decl_stmt|;
name|int
name|ten
decl_stmt|,
name|nh
decl_stmt|,
name|quote
decl_stmt|;
comment|/* i is the next input character to be looked at j is the next output character */
name|parlev
operator|=
literal|0
expr_stmt|;
name|expcom
operator|=
literal|0
expr_stmt|;
comment|/* exposed ','s */
name|expeql
operator|=
literal|0
expr_stmt|;
comment|/* exposed equal signs */
name|j
operator|=
name|s
expr_stmt|;
name|prvstr
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
name|s
init|;
name|i
operator|<=
name|lastch
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|i
operator|==
literal|'\''
operator|||
operator|*
name|i
operator|==
literal|'"'
condition|)
block|{
name|quote
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|j
operator|=
name|MYQUOTE
expr_stmt|;
comment|/* special marker */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
name|lastch
condition|)
block|{
name|err
argument_list|(
literal|"unbalanced quotes; closing quote supplied"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|i
operator|==
name|quote
condition|)
if|if
condition|(
name|i
operator|<
name|lastch
operator|&&
name|i
index|[
literal|1
index|]
operator|==
name|quote
condition|)
operator|++
name|i
expr_stmt|;
else|else
break|break;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|'\\'
operator|&&
name|i
operator|<
name|lastch
condition|)
switch|switch
condition|(
operator|*
operator|++
name|i
condition|)
block|{
case|case
literal|'t'
case|:
operator|*
name|i
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|i
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|i
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|i
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|i
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
operator|*
name|i
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
operator|++
name|j
operator|=
operator|*
name|i
expr_stmt|;
block|}
name|j
index|[
literal|1
index|]
operator|=
name|MYQUOTE
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
name|prvstr
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|i
operator|==
literal|'h'
operator|||
operator|*
name|i
operator|==
literal|'H'
operator|)
operator|&&
name|j
operator|>
name|prvstr
condition|)
comment|/* test for Hollerith strings */
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|j
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|copychar
goto|;
name|nh
operator|=
name|j
index|[
operator|-
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|ten
operator|=
literal|10
expr_stmt|;
name|j1
operator|=
name|prvstr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j1
operator|<
name|j
operator|-
literal|5
condition|)
name|j1
operator|=
name|j
operator|-
literal|5
expr_stmt|;
for|for
control|(
name|j0
operator|=
name|j
operator|-
literal|2
init|;
name|j0
operator|>
name|j1
condition|;
operator|--
name|j0
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|j0
argument_list|)
condition|)
break|break;
name|nh
operator|+=
name|ten
operator|*
operator|(
operator|*
name|j0
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ten
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|j0
operator|<=
name|j1
condition|)
goto|goto
name|copychar
goto|;
comment|/* a hollerith must be preceded by a punctuation mark.    '*' is possible only as repetition factor in a data statement    not, in particular, in character*2h */
if|if
condition|(
operator|!
operator|(
operator|*
name|j0
operator|==
literal|'*'
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|*
name|j0
operator|!=
literal|'/'
operator|&&
operator|*
name|j0
operator|!=
literal|'('
operator|&&
operator|*
name|j0
operator|!=
literal|','
operator|&&
operator|*
name|j0
operator|!=
literal|'='
operator|&&
operator|*
name|j0
operator|!=
literal|'.'
condition|)
goto|goto
name|copychar
goto|;
if|if
condition|(
name|i
operator|+
name|nh
operator|>
name|lastch
condition|)
block|{
name|erri
argument_list|(
literal|"%dH too big"
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|nh
operator|=
name|lastch
operator|-
name|i
expr_stmt|;
block|}
name|j0
index|[
literal|1
index|]
operator|=
name|MYQUOTE
expr_stmt|;
comment|/* special marker */
name|j
operator|=
name|j0
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|nh
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|i
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|i
condition|)
block|{
case|case
literal|'t'
case|:
operator|*
name|i
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|i
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|i
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|i
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
operator|*
name|i
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
operator|++
name|j
operator|=
operator|*
name|i
expr_stmt|;
block|}
name|j
index|[
literal|1
index|]
operator|=
name|MYQUOTE
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
name|prvstr
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|i
operator|==
literal|'('
condition|)
operator|++
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|')'
condition|)
operator|--
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
name|parlev
operator|==
literal|0
condition|)
if|if
condition|(
operator|*
name|i
operator|==
literal|'='
condition|)
name|expeql
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|','
condition|)
name|expcom
operator|=
literal|1
expr_stmt|;
name|copychar
label|:
comment|/*not a string or space -- copy, shifting case if necessary */
if|if
condition|(
name|shiftcase
operator|&&
name|isupper
argument_list|(
operator|*
name|i
argument_list|)
condition|)
operator|*
name|j
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
else|else
operator|*
name|j
operator|++
operator|=
operator|*
name|i
expr_stmt|;
block|}
block|}
name|lastch
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|nextch
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|analyz
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|parlev
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"unbalanced parentheses, statement skipped"
argument_list|)
expr_stmt|;
name|stkey
operator|=
name|SUNKNOWN
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nextch
operator|+
literal|2
operator|<=
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|nextch
index|[
literal|2
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* assignment or if statement -- look at character after balancing paren */
name|parlev
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nextch
operator|+
literal|3
init|;
name|i
operator|<=
name|lastch
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
operator|(
name|MYQUOTE
operator|)
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|i
operator|!=
name|MYQUOTE
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|'('
condition|)
operator|++
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|--
name|parlev
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|lastch
condition|)
name|stkey
operator|=
name|SLOGIF
expr_stmt|;
elseif|else
if|if
condition|(
name|i
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|stkey
operator|=
name|SLET
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|i
index|[
literal|1
index|]
argument_list|)
condition|)
name|stkey
operator|=
name|SARITHIF
expr_stmt|;
else|else
name|stkey
operator|=
name|SLOGIF
expr_stmt|;
if|if
condition|(
name|stkey
operator|!=
name|SLET
condition|)
name|nextch
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expeql
condition|)
comment|/* may be an assignment */
block|{
if|if
condition|(
name|expcom
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|stkey
operator|=
name|SDO
expr_stmt|;
name|nextch
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|stkey
operator|=
name|SLET
expr_stmt|;
block|}
comment|/* otherwise search for keyword */
else|else
block|{
name|stkey
operator|=
name|getkwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|stkey
operator|==
name|SGOTO
operator|&&
name|lastch
operator|>=
name|nextch
condition|)
if|if
condition|(
name|nextch
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
name|stkey
operator|=
name|SCOMPGOTO
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|nextch
index|[
literal|0
index|]
argument_list|)
condition|)
name|stkey
operator|=
name|SASGOTO
expr_stmt|;
block|}
name|parlev
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|getkwd
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
specifier|register
name|struct
name|Keylist
modifier|*
name|pk
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|nextch
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|SUNKNOWN
operator|)
return|;
name|k
operator|=
name|nextch
index|[
literal|0
index|]
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|pk
operator|=
name|keystart
index|[
name|k
index|]
condition|)
for|for
control|(
name|pend
operator|=
name|keyend
index|[
name|k
index|]
init|;
name|pk
operator|<=
name|pend
condition|;
operator|++
name|pk
control|)
block|{
name|i
operator|=
name|pk
operator|->
name|keyname
expr_stmt|;
name|j
operator|=
name|nextch
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|i
operator|==
operator|*
operator|++
name|j
operator|&&
operator|*
name|i
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|i
operator|==
literal|'\0'
operator|&&
name|j
operator|<=
name|lastch
operator|+
literal|1
condition|)
block|{
name|nextch
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|no66flag
operator|&&
name|pk
operator|->
name|notinf66
condition|)
name|errstr
argument_list|(
literal|"Not a Fortran 66 keyword: %s"
argument_list|,
name|pk
operator|->
name|keyname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pk
operator|->
name|keyval
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SUNKNOWN
operator|)
return|;
block|}
end_function

begin_macro
name|initkey
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|struct
name|Keylist
name|keys
index|[]
decl_stmt|;
specifier|register
name|struct
name|Keylist
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
operator|++
name|i
control|)
name|keystart
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|keys
init|;
name|p
operator|->
name|keyname
condition|;
operator|++
name|p
control|)
block|{
name|j
operator|=
name|p
operator|->
name|keyname
index|[
literal|0
index|]
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|keystart
index|[
name|j
index|]
operator|==
name|NULL
condition|)
name|keystart
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
name|keyend
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|gettok
parameter_list|()
block|{
name|int
name|havdot
decl_stmt|,
name|havexp
decl_stmt|,
name|havdbl
decl_stmt|;
name|int
name|radix
decl_stmt|,
name|val
decl_stmt|;
specifier|extern
name|struct
name|Punctlist
name|puncts
index|[]
decl_stmt|;
name|struct
name|Punctlist
modifier|*
name|pp
decl_stmt|;
specifier|extern
name|struct
name|Fmtlist
name|fmts
index|[]
decl_stmt|;
specifier|extern
name|struct
name|Dotlist
name|dots
index|[]
decl_stmt|;
name|struct
name|Dotlist
modifier|*
name|pd
decl_stmt|;
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|n1
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|nextch
operator|==
operator|(
name|MYQUOTE
operator|)
condition|)
block|{
operator|++
name|nextch
expr_stmt|;
name|p
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|*
name|nextch
operator|!=
name|MYQUOTE
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
operator|++
name|nextch
expr_stmt|;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|SHOLLERITH
operator|)
return|;
block|}
comment|/* 	if(stkey == SFORMAT) 		{ 		for(pf = fmts; pf->fmtchar; ++pf) 			{ 			if(*nextch == pf->fmtchar) 				{ 				++nextch; 				if(pf->fmtval == SLPAR) 					++parlev; 				else if(pf->fmtval == SRPAR) 					--parlev; 				return(pf->fmtval); 				} 			} 		if( isdigit(*nextch) ) 			{ 			p = token; 			*p++ = *nextch++; 			while(nextch<=lastch&& isdigit(*nextch) ) 				*p++ = *nextch++; 			toklen = p - token; 			*p = '\0'; 			if(nextch<=lastch&& *nextch=='p') 				{ 				++nextch; 				return(SSCALE); 				} 			else	return(SICON); 			} 		if( isalpha(*nextch) ) 			{ 			p = token; 			*p++ = *nextch++; 			while(nextch<=lastch&& 				(*nextch=='.' || isdigit(*nextch) || isalpha(*nextch) )) 					*p++ = *nextch++; 			toklen = p - token; 			*p = '\0'; 			return(SFIELD); 			} 		goto badchar; 		} /* Not a format statement */
if|if
condition|(
name|needkwd
condition|)
block|{
name|needkwd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getkwd
argument_list|()
operator|)
return|;
block|}
for|for
control|(
name|pp
operator|=
name|puncts
init|;
name|pp
operator|->
name|punchar
condition|;
operator|++
name|pp
control|)
if|if
condition|(
operator|*
name|nextch
operator|==
name|pp
operator|->
name|punchar
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|nextch
operator|==
literal|'*'
operator|||
operator|*
name|nextch
operator|==
literal|'/'
operator|)
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
name|nextch
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'*'
condition|)
name|val
operator|=
name|SPOWER
expr_stmt|;
else|else
name|val
operator|=
name|SCONCAT
expr_stmt|;
name|nextch
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|pp
operator|->
name|punval
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|SLPAR
condition|)
operator|++
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|SRPAR
condition|)
operator|--
name|parlev
expr_stmt|;
operator|++
name|nextch
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'.'
condition|)
if|if
condition|(
name|nextch
operator|>=
name|lastch
condition|)
goto|goto
name|badchar
goto|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|nextch
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|numconst
goto|;
else|else
block|{
for|for
control|(
name|pd
operator|=
name|dots
init|;
operator|(
name|j
operator|=
name|pd
operator|->
name|dotname
operator|)
condition|;
operator|++
name|pd
control|)
block|{
for|for
control|(
name|i
operator|=
name|nextch
operator|+
literal|1
init|;
name|i
operator|<=
name|lastch
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|!=
operator|*
name|j
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|i
operator|!=
literal|'.'
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|nextch
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|pd
operator|->
name|dotval
operator|)
return|;
block|}
block|}
goto|goto
name|badchar
goto|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|nextch
argument_list|)
condition|)
block|{
name|p
operator|=
name|token
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
while|while
condition|(
name|nextch
operator|<=
name|lastch
condition|)
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|nextch
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|nextch
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
else|else
break|break;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inioctl
operator|&&
name|nextch
operator|<=
name|lastch
operator|&&
operator|*
name|nextch
operator|==
literal|'='
condition|)
block|{
operator|++
name|nextch
expr_stmt|;
return|return
operator|(
name|SNAMEEQ
operator|)
return|;
block|}
if|if
condition|(
name|toklen
operator|>
literal|8
operator|&&
name|eqn
argument_list|(
literal|8
argument_list|,
name|token
argument_list|,
literal|"function"
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|token
index|[
literal|8
index|]
argument_list|)
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|nextch
index|[
literal|1
index|]
operator|==
literal|')'
operator||
name|isalpha
argument_list|(
name|nextch
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|nextch
operator|-=
operator|(
name|toklen
operator|-
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|SFUNCTION
operator|)
return|;
block|}
if|if
condition|(
name|toklen
operator|>
name|VL
condition|)
block|{
name|char
name|buff
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"name %s too long, truncated to %d"
argument_list|,
name|token
argument_list|,
name|VL
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|toklen
operator|=
name|VL
expr_stmt|;
name|token
index|[
name|VL
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|toklen
operator|==
literal|1
operator|&&
operator|*
name|nextch
operator|==
name|MYQUOTE
condition|)
block|{
switch|switch
condition|(
name|token
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|radix
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|radix
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|radix
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
literal|"bad bit identifier"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNAME
operator|)
return|;
block|}
operator|++
name|nextch
expr_stmt|;
for|for
control|(
name|p
operator|=
name|token
init|;
operator|*
name|nextch
operator|!=
name|MYQUOTE
condition|;
control|)
if|if
condition|(
operator|*
name|nextch
operator|==
name|BLANK
operator|||
operator|*
name|nextch
operator|==
literal|'\t'
condition|)
name|nextch
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|nextch
argument_list|)
condition|)
operator|*
name|nextch
operator|=
name|tolower
argument_list|(
operator|*
name|nextch
argument_list|)
expr_stmt|;
if|if
condition|(
name|hextoi
argument_list|(
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
argument_list|)
operator|>=
name|radix
condition|)
block|{
name|err
argument_list|(
literal|"invalid binary character"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|nextch
expr_stmt|;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
return|return
operator|(
name|radix
operator|==
literal|16
condition|?
name|SHEXCON
else|:
operator|(
name|radix
operator|==
literal|8
condition|?
name|SOCTCON
else|:
name|SBITCON
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|SNAME
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|nextch
argument_list|)
condition|)
goto|goto
name|badchar
goto|;
name|numconst
label|:
name|havdot
operator|=
name|NO
expr_stmt|;
name|havexp
operator|=
name|NO
expr_stmt|;
name|havdbl
operator|=
name|NO
expr_stmt|;
for|for
control|(
name|n1
operator|=
name|nextch
init|;
name|nextch
operator|<=
name|lastch
condition|;
operator|++
name|nextch
control|)
block|{
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'.'
condition|)
if|if
condition|(
name|havdot
condition|)
break|break;
elseif|else
if|if
condition|(
name|nextch
operator|+
literal|2
operator|<=
name|lastch
operator|&&
name|isalpha
argument_list|(
name|nextch
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|nextch
index|[
literal|2
index|]
argument_list|)
condition|)
break|break;
else|else
name|havdot
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|intonly
operator|&&
operator|(
operator|*
name|nextch
operator|==
literal|'d'
operator|||
operator|*
name|nextch
operator|==
literal|'e'
operator|)
condition|)
block|{
name|p
operator|=
name|nextch
expr_stmt|;
name|havexp
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'d'
condition|)
name|havdbl
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|nextch
operator|<
name|lastch
condition|)
if|if
condition|(
name|nextch
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|nextch
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
operator|++
name|nextch
expr_stmt|;
if|if
condition|(
operator|(
name|nextch
operator|>=
name|lastch
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
operator|++
name|nextch
argument_list|)
condition|)
block|{
name|nextch
operator|=
name|p
expr_stmt|;
name|havdbl
operator|=
name|havexp
operator|=
name|NO
expr_stmt|;
break|break;
block|}
for|for
control|(
operator|++
name|nextch
init|;
name|nextch
operator|<=
name|lastch
operator|&&
name|isdigit
argument_list|(
operator|*
name|nextch
argument_list|)
condition|;
operator|++
name|nextch
control|)
empty_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|nextch
argument_list|)
condition|)
break|break;
block|}
name|p
operator|=
name|token
expr_stmt|;
name|i
operator|=
name|n1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nextch
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|i
operator|++
expr_stmt|;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|havdbl
condition|)
return|return
operator|(
name|SDCON
operator|)
return|;
if|if
condition|(
name|havdot
operator|||
name|havexp
condition|)
return|return
operator|(
name|SRCON
operator|)
return|;
return|return
operator|(
name|SICON
operator|)
return|;
name|badchar
label|:
name|s
index|[
literal|0
index|]
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
return|return
operator|(
name|SUNKNOWN
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* KEYWORD AND SPECIAL CHARACTER TABLES */
end_comment

begin_decl_stmt
name|struct
name|Punctlist
name|puncts
index|[ ]
init|=
block|{
literal|'('
block|,
name|SLPAR
block|,
literal|')'
block|,
name|SRPAR
block|,
literal|'='
block|,
name|SEQUALS
block|,
literal|','
block|,
name|SCOMMA
block|,
literal|'+'
block|,
name|SPLUS
block|,
literal|'-'
block|,
name|SMINUS
block|,
literal|'*'
block|,
name|SSTAR
block|,
literal|'/'
block|,
name|SSLASH
block|,
literal|'$'
block|,
name|SCURRENCY
block|,
literal|':'
block|,
name|SCOLON
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LOCAL struct Fmtlist  fmts[ ] = 	{ 	'(', SLPAR, 	')', SRPAR, 	'/', SSLASH, 	',', SCOMMA, 	'-', SMINUS, 	':', SCOLON, 	0, 0 } ; */
end_comment

begin_decl_stmt
name|LOCAL
name|struct
name|Dotlist
name|dots
index|[ ]
init|=
block|{
literal|"and."
block|,
name|SAND
block|,
literal|"or."
block|,
name|SOR
block|,
literal|"not."
block|,
name|SNOT
block|,
literal|"true."
block|,
name|STRUE
block|,
literal|"false."
block|,
name|SFALSE
block|,
literal|"eq."
block|,
name|SEQ
block|,
literal|"ne."
block|,
name|SNE
block|,
literal|"lt."
block|,
name|SLT
block|,
literal|"le."
block|,
name|SLE
block|,
literal|"gt."
block|,
name|SGT
block|,
literal|"ge."
block|,
name|SGE
block|,
literal|"neqv."
block|,
name|SNEQV
block|,
literal|"eqv."
block|,
name|SEQV
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|struct
name|Keylist
name|keys
index|[ ]
init|=
block|{
block|{
literal|"assign"
block|,
name|SASSIGN
block|}
block|,
block|{
literal|"automatic"
block|,
name|SAUTOMATIC
block|,
name|YES
block|}
block|,
block|{
literal|"backspace"
block|,
name|SBACKSPACE
block|}
block|,
block|{
literal|"blockdata"
block|,
name|SBLOCK
block|}
block|,
block|{
literal|"call"
block|,
name|SCALL
block|}
block|,
block|{
literal|"character"
block|,
name|SCHARACTER
block|,
name|YES
block|}
block|,
block|{
literal|"close"
block|,
name|SCLOSE
block|,
name|YES
block|}
block|,
block|{
literal|"common"
block|,
name|SCOMMON
block|}
block|,
block|{
literal|"complex"
block|,
name|SCOMPLEX
block|}
block|,
block|{
literal|"continue"
block|,
name|SCONTINUE
block|}
block|,
block|{
literal|"data"
block|,
name|SDATA
block|}
block|,
block|{
literal|"dimension"
block|,
name|SDIMENSION
block|}
block|,
block|{
literal|"doubleprecision"
block|,
name|SDOUBLE
block|}
block|,
block|{
literal|"doublecomplex"
block|,
name|SDCOMPLEX
block|,
name|YES
block|}
block|,
block|{
literal|"elseif"
block|,
name|SELSEIF
block|,
name|YES
block|}
block|,
block|{
literal|"else"
block|,
name|SELSE
block|,
name|YES
block|}
block|,
block|{
literal|"endfile"
block|,
name|SENDFILE
block|}
block|,
block|{
literal|"endif"
block|,
name|SENDIF
block|,
name|YES
block|}
block|,
block|{
literal|"end"
block|,
name|SEND
block|}
block|,
block|{
literal|"entry"
block|,
name|SENTRY
block|,
name|YES
block|}
block|,
block|{
literal|"equivalence"
block|,
name|SEQUIV
block|}
block|,
block|{
literal|"external"
block|,
name|SEXTERNAL
block|}
block|,
block|{
literal|"format"
block|,
name|SFORMAT
block|}
block|,
block|{
literal|"function"
block|,
name|SFUNCTION
block|}
block|,
block|{
literal|"goto"
block|,
name|SGOTO
block|}
block|,
block|{
literal|"implicit"
block|,
name|SIMPLICIT
block|,
name|YES
block|}
block|,
block|{
literal|"include"
block|,
name|SINCLUDE
block|,
name|YES
block|}
block|,
block|{
literal|"inquire"
block|,
name|SINQUIRE
block|,
name|YES
block|}
block|,
block|{
literal|"intrinsic"
block|,
name|SINTRINSIC
block|,
name|YES
block|}
block|,
block|{
literal|"integer"
block|,
name|SINTEGER
block|}
block|,
block|{
literal|"logical"
block|,
name|SLOGICAL
block|}
block|,
ifdef|#
directive|ifdef
name|NAMELIST
block|{
literal|"namelist"
block|,
name|SNAMELIST
block|,
name|YES
block|}
block|,
endif|#
directive|endif
block|{
literal|"none"
block|,
name|SUNDEFINED
block|,
name|YES
block|}
block|,
block|{
literal|"open"
block|,
name|SOPEN
block|,
name|YES
block|}
block|,
block|{
literal|"parameter"
block|,
name|SPARAM
block|,
name|YES
block|}
block|,
block|{
literal|"pause"
block|,
name|SPAUSE
block|}
block|,
block|{
literal|"print"
block|,
name|SPRINT
block|}
block|,
block|{
literal|"program"
block|,
name|SPROGRAM
block|,
name|YES
block|}
block|,
block|{
literal|"punch"
block|,
name|SPUNCH
block|,
name|YES
block|}
block|,
block|{
literal|"read"
block|,
name|SREAD
block|}
block|,
block|{
literal|"real"
block|,
name|SREAL
block|}
block|,
block|{
literal|"return"
block|,
name|SRETURN
block|}
block|,
block|{
literal|"rewind"
block|,
name|SREWIND
block|}
block|,
block|{
literal|"save"
block|,
name|SSAVE
block|,
name|YES
block|}
block|,
block|{
literal|"static"
block|,
name|SSTATIC
block|,
name|YES
block|}
block|,
block|{
literal|"stop"
block|,
name|SSTOP
block|}
block|,
block|{
literal|"subroutine"
block|,
name|SSUBROUTINE
block|}
block|,
block|{
literal|"then"
block|,
name|STHEN
block|,
name|YES
block|}
block|,
block|{
literal|"undefined"
block|,
name|SUNDEFINED
block|,
name|YES
block|}
block|,
block|{
literal|"write"
block|,
name|SWRITE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

