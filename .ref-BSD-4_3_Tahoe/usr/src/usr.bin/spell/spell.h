begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)spell.h	4.1	12/18/82	*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|unix
end_ifndef

begin_define
define|#
directive|define
name|SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|TABSIZE
value|(int)(400000/(1<<SHIFT))
end_define

begin_decl_stmt
name|int
modifier|*
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*honeywell loader deficiency*/
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Tolower
parameter_list|(
name|c
parameter_list|)
value|(isupper(c)?tolower(c):c)
end_define

begin_comment
comment|/* ugh!!! */
end_comment

begin_define
define|#
directive|define
name|SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|TABSIZE
value|25000
end_define

begin_comment
comment|/*(int)(400000/(1<<shift))--pdp11 compiler deficiency*/
end_comment

begin_decl_stmt
name|short
name|tab
index|[
name|TABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|long
name|p
index|[]
init|=
block|{
literal|399871
block|,
literal|399887
block|,
literal|399899
block|,
literal|399911
block|,
literal|399913
block|,
literal|399937
block|,
literal|399941
block|,
literal|399953
block|,
literal|399979
block|,
literal|399983
block|,
literal|399989
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NP
value|(sizeof(p)/sizeof(p[0]))
end_define

begin_define
define|#
directive|define
name|NW
value|30
end_define

begin_comment
comment|/* * Hash table for spelling checker has n bits. * Each word w is hashed by k different (modular) hash functions, hi. * The bits hi(w), i=1..k, are set for words in the dictionary. * Assuming independence, the probability that no word of a d-word * dictionary sets a particular bit is given by the Poisson formula * P = exp(-y)*y**0/0!, where y=d*k/n. * The probability that a random string is recognized as a word is then * (1-P)**k.  For given n and d this is minimum when y=log(2), P=1/2, * whence one finds, for example, that a 25000-word dictionary in a * 400000-bit table works best with k=11. */
end_comment

begin_decl_stmt
name|long
name|pow2
index|[
name|NP
index|]
index|[
name|NW
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|prime
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|h
decl_stmt|;
specifier|register
name|long
modifier|*
name|lp
decl_stmt|;
ifndef|#
directive|ifndef
name|unix
if|if
condition|(
operator|(
name|tab
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|,
name|TABSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"ri"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|,
name|TABSIZE
argument_list|,
name|f
argument_list|)
operator|!=
name|TABSIZE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NP
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
operator|*
operator|(
name|lp
operator|=
name|pow2
index|[
name|i
index|]
operator|)
operator|=
literal|1
operator|<<
literal|14
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NW
condition|;
name|j
operator|++
control|)
name|h
operator|=
operator|*
operator|++
name|lp
operator|=
operator|(
name|h
operator|<<
literal|7
operator|)
operator|%
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|get
parameter_list|(
name|h
parameter_list|)
value|(tab[h>>SHIFT]&(1<<((int)h&((1<<SHIFT)-1))))
end_define

begin_define
define|#
directive|define
name|set
parameter_list|(
name|h
parameter_list|)
value|tab[h>>SHIFT] |= 1<<((int)h&((1<<SHIFT)-1))
end_define

end_unit

