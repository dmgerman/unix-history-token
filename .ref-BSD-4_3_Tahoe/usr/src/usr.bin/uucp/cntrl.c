begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cntrl.c	5.12	(Berkeley) 5/4/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"uust.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|turntime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|willturn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|HaveSentHup
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Proto
block|{
name|char
name|P_id
decl_stmt|;
name|int
function_decl|(
modifier|*
name|P_turnon
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_rdmsg
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_wrmsg
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_rddata
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_wrdata
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|P_turnoff
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|gturnon
argument_list|()
decl_stmt|,
name|gturnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|grdmsg
argument_list|()
decl_stmt|,
name|grddata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gwrmsg
argument_list|()
decl_stmt|,
name|gwrdata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|imsg
argument_list|()
decl_stmt|,
name|omsg
argument_list|()
decl_stmt|,
name|nullf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCPIP
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|twrmsg
argument_list|()
decl_stmt|,
name|trdmsg
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|twrdata
argument_list|()
decl_stmt|,
name|trddata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|TCPIP
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PAD
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|fturnon
argument_list|()
decl_stmt|,
name|fturnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|frdmsg
argument_list|()
decl_stmt|,
name|frddata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fwrmsg
argument_list|()
decl_stmt|,
name|fwrdata
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|PAD
end_endif

begin_decl_stmt
name|struct
name|Proto
name|Ptbl
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|TCPIP
literal|'t'
block|,
name|nullf
block|,
name|trdmsg
block|,
name|twrmsg
block|,
name|trddata
block|,
name|twrdata
block|,
name|nullf
block|,
endif|#
directive|endif
endif|TCPIP
ifdef|#
directive|ifdef
name|PAD
literal|'f'
block|,
name|fturnon
block|,
name|frdmsg
block|,
name|fwrmsg
block|,
name|frddata
block|,
name|fwrdata
block|,
name|fturnoff
block|,
endif|#
directive|endif
endif|PAD
literal|'g'
block|,
name|gturnon
block|,
name|grdmsg
block|,
name|gwrmsg
block|,
name|grddata
block|,
name|gwrdata
block|,
name|gturnoff
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|Imsg
function_decl|)
parameter_list|()
init|=
name|imsg
operator|,
parameter_list|(
function_decl|*Omsg
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
operator|=
name|omsg
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|Rdmsg
function_decl|)
parameter_list|()
init|=
name|imsg
operator|,
parameter_list|(
function_decl|*Rddata
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|Wrmsg
function_decl|)
parameter_list|()
init|=
name|omsg
operator|,
parameter_list|(
function_decl|*Wrdata
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|Turnon
function_decl|)
parameter_list|()
init|=
name|nullf
operator|,
parameter_list|(
function_decl|*Turnoff
end_function_decl

begin_expr_stmt
unit|)
operator|(
operator|)
operator|=
name|nullf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|timeb
name|Now
decl_stmt|,
name|LastTurned
decl_stmt|,
name|LastCheckedNoLogin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|YES
init|=
literal|"Y"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|NO
init|=
literal|"N"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TransferSucceeded
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  failure messages  */
end_comment

begin_define
define|#
directive|define
name|EM_MAX
value|6
end_define

begin_define
define|#
directive|define
name|EM_LOCACC
value|"N1"
end_define

begin_comment
comment|/* local access to file denied */
end_comment

begin_define
define|#
directive|define
name|EM_RMTACC
value|"N2"
end_define

begin_comment
comment|/* remote access to file/path denied */
end_comment

begin_define
define|#
directive|define
name|EM_BADUUCP
value|"N3"
end_define

begin_comment
comment|/* a bad uucp command was generated */
end_comment

begin_define
define|#
directive|define
name|EM_NOTMP
value|"N4"
end_define

begin_comment
comment|/* remote error - can't create temp */
end_comment

begin_define
define|#
directive|define
name|EM_RMTCP
value|"N5"
end_define

begin_comment
comment|/* can't copy to remote directory - file in public */
end_comment

begin_define
define|#
directive|define
name|EM_LOCCP
value|"N6"
end_define

begin_comment
comment|/* can't copy on local system */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Em_msg
index|[]
init|=
block|{
literal|"COPY FAILED (reason not given by remote)"
block|,
literal|"local access to file denied"
block|,
literal|"remote access to path/file denied"
block|,
literal|"system error - bad uucp command generated"
block|,
literal|"remote system can't create temp file"
block|,
literal|"can't copy to file/directory - file left in PUBDIR/user/file"
block|,
literal|"can't copy to file/directory on local system  - file left in PUBDIR/user/file"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XUUCP
value|'X'
end_define

begin_comment
comment|/* execute uucp (string) */
end_comment

begin_define
define|#
directive|define
name|SLTPTCL
value|'P'
end_define

begin_comment
comment|/* select protocol  (string)  */
end_comment

begin_define
define|#
directive|define
name|USEPTCL
value|'U'
end_define

begin_comment
comment|/* use protocol (character) */
end_comment

begin_define
define|#
directive|define
name|RCVFILE
value|'R'
end_define

begin_comment
comment|/* receive file (string) */
end_comment

begin_define
define|#
directive|define
name|SNDFILE
value|'S'
end_define

begin_comment
comment|/* send file (string) */
end_comment

begin_define
define|#
directive|define
name|RQSTCMPT
value|'C'
end_define

begin_comment
comment|/* request complete (string - yes | no) */
end_comment

begin_define
define|#
directive|define
name|HUP
value|'H'
end_define

begin_comment
comment|/* ready to hangup (string - yes | no) */
end_comment

begin_define
define|#
directive|define
name|RESET
value|'X'
end_define

begin_comment
comment|/* reset line modes */
end_comment

begin_define
define|#
directive|define
name|W_TYPE
value|wrkvec[0]
end_define

begin_define
define|#
directive|define
name|W_FILE1
value|wrkvec[1]
end_define

begin_define
define|#
directive|define
name|W_FILE2
value|wrkvec[2]
end_define

begin_define
define|#
directive|define
name|W_USER
value|wrkvec[3]
end_define

begin_define
define|#
directive|define
name|W_OPTNS
value|wrkvec[4]
end_define

begin_define
define|#
directive|define
name|W_DFILE
value|wrkvec[5]
end_define

begin_define
define|#
directive|define
name|W_MODE
value|wrkvec[6]
end_define

begin_define
define|#
directive|define
name|W_NUSER
value|wrkvec[7]
end_define

begin_define
define|#
directive|define
name|XFRRATE
value|35000L
end_define

begin_define
define|#
directive|define
name|RMESG
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|if (rmesg(m, s, n) != 0) {(*Turnoff)(); return FAIL;} else
end_define

begin_define
define|#
directive|define
name|RAMESG
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|if (rmesg('\0', s, n) != 0) {(*Turnoff)(); return FAIL;} else
end_define

begin_define
define|#
directive|define
name|WMESG
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|)
value|if(wmesg(m, s) != 0) {(*Turnoff)(); return FAIL;} else
end_define

begin_decl_stmt
name|char
name|Wfile
index|[
name|MAXFULLNAME
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Dfile
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To avoid a huge backlog of X. files, start uuxqt every so often.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nXfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of X files since last uuxqt start */
end_comment

begin_decl_stmt
specifier|static
name|char
name|send_or_receive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|stbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	cntrl  -  this routine will execute the conversation  *	between the two machines after both programs are  *	running.  *  *	return codes  *		SUCCESS - ok  *		FAIL - failed  */
end_comment

begin_macro
name|cntrl
argument_list|(
argument|role
argument_list|,
argument|wkpre
argument_list|)
end_macro

begin_decl_stmt
name|int
name|role
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|wkpre
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|msg
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|rqstr
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|filemode
decl_stmt|;
name|char
name|filename
index|[
name|MAXFULLNAME
index|]
decl_stmt|,
name|wrktype
decl_stmt|,
modifier|*
name|wrkvec
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
type|(
modifier|*
name|Rdmsg
decl_stmt|)(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
call|(
modifier|*
name|Wrmsg
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|lastpart
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|i
decl_stmt|,
name|narg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mailopt
decl_stmt|,
name|ntfyopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ret
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pnum
decl_stmt|,
name|tmpnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ReverseRole
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pnum
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Wfile
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|willturn
operator|=
name|turntime
operator|>
literal|0
expr_stmt|;
end_expr_stmt

begin_label
name|remaster
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_expr_stmt
name|time
argument_list|(
operator|&
name|LastTurned
operator|.
name|time
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LastTurned
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
else|!USG
end_else

begin_expr_stmt
name|ftime
argument_list|(
operator|&
name|LastTurned
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|!USG
end_endif

begin_expr_stmt
name|send_or_receive
operator|=
name|RESET
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|HaveSentHup
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_label
name|top
label|:
end_label

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|wrkvec
operator|/
sizeof|sizeof
name|wrkvec
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|wrkvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"*** TOP ***  -  role=%s\n"
argument_list|,
name|role
condition|?
literal|"MASTER"
else|:
literal|"SLAVE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setproctitle
argument_list|(
literal|"%s: %s"
argument_list|,
name|Rmtname
argument_list|,
name|role
condition|?
literal|"MASTER"
else|:
literal|"SLAVE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setupline
argument_list|(
name|RESET
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Now
operator|.
name|time
operator|>
operator|(
name|LastCheckedNoLogin
operator|.
name|time
operator|+
literal|60
operator|)
condition|)
block|{
name|LastCheckedNoLogin
operator|=
name|Now
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|NOLOGIN
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logent
argument_list|(
name|NOLOGIN
argument_list|,
literal|"UUCICO SHUTDOWN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Debug
operator|>
literal|4
condition|)
name|logent
argument_list|(
literal|"DEBUGGING"
argument_list|,
literal|"continuing anyway"
argument_list|)
expr_stmt|;
else|else
block|{
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
block|}
block|}
end_if

begin_if
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
comment|/* get work */
if|if
condition|(
name|ReverseRole
operator|||
operator|(
name|narg
operator|=
name|gtwvec
argument_list|(
name|Wfile
argument_list|,
name|Spool
argument_list|,
name|wkpre
argument_list|,
name|wrkvec
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ReverseRole
operator|=
literal|0
expr_stmt|;
name|WMESG
argument_list|(
name|HUP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
name|wrktype
operator|=
name|W_TYPE
index|[
literal|0
index|]
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|narg
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|msg
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|wrkvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrktype
operator|==
name|XUUCP
condition|)
block|{
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"X %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUEST"
argument_list|)
expr_stmt|;
goto|goto
name|sendmsg
goto|;
block|}
name|mailopt
operator|=
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|ntfyopt
operator|=
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'n'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|narg
operator|<
literal|5
operator|||
name|W_TYPE
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|bnp
decl_stmt|;
name|bnp
operator|=
name|rindex
argument_list|(
name|Wfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s/%s"
argument_list|,
name|CORRUPT
argument_list|,
name|bnp
condition|?
name|bnp
operator|+
literal|1
else|:
name|Wfile
argument_list|)
expr_stmt|;
name|xmv
argument_list|(
name|Wfile
argument_list|,
name|rqstr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s CORRUPTED: %d args"
argument_list|,
name|Wfile
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|Wfile
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|sprintf
argument_list|(
name|User
argument_list|,
literal|"%.9s"
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"(%s %s %s %s)"
argument_list|,
name|W_TYPE
argument_list|,
name|W_FILE1
argument_list|,
name|W_FILE2
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrktype
operator|==
name|SNDFILE
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
name|i
operator|=
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"expfile type - %d, "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|chkpth
argument_list|(
name|User
argument_list|,
literal|""
argument_list|,
name|filename
argument_list|)
condition|)
goto|goto
name|e_access
goto|;
name|strcpy
argument_list|(
name|Dfile
argument_list|,
name|W_DFILE
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'c'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|Dfile
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*  can not read data file  */
name|logent
argument_list|(
literal|"CAN'T READ DATA"
argument_list|,
name|_FAILED
argument_list|)
expr_stmt|;
name|TransferSucceeded
operator|=
literal|1
expr_stmt|;
comment|/* else will keep sending */
name|USRF
argument_list|(
name|USR_LOCACC
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
name|lnotify
argument_list|(
name|User
argument_list|,
name|filename
argument_list|,
literal|"can't access"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* if file exists but is not generally readable... */
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|ANYREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|e_access
label|:
empty_stmt|;
comment|/*  access denied  */
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|TransferSucceeded
operator|=
literal|1
expr_stmt|;
comment|/* else will keep sending */
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"ACCESS"
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
name|USR_LOCACC
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|W_DFILE
argument_list|)
expr_stmt|;
name|lnotify
argument_list|(
name|User
argument_list|,
name|filename
argument_list|,
literal|"access denied"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|setupline
argument_list|(
name|SNDFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrktype
operator|==
name|RCVFILE
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE2
argument_list|)
expr_stmt|;
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkpth
argument_list|(
name|User
argument_list|,
literal|""
argument_list|,
name|filename
argument_list|)
operator|||
name|chkperm
argument_list|(
name|filename
argument_list|,
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'d'
argument_list|)
argument_list|)
condition|)
block|{
comment|/*  access denied  */
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"ACCESS"
argument_list|)
expr_stmt|;
name|TransferSucceeded
operator|=
literal|1
expr_stmt|;
comment|/* else will keep trying */
name|USRF
argument_list|(
name|USR_LOCACC
argument_list|)
expr_stmt|;
name|lnotify
argument_list|(
name|User
argument_list|,
name|filename
argument_list|,
literal|"access denied"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|sprintf
argument_list|(
name|Dfile
argument_list|,
literal|"%s/TM.%05d.%03d"
argument_list|,
name|Spool
argument_list|,
name|pnum
argument_list|,
name|tmpnum
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|Dfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*  can not create temp  */
name|logent
argument_list|(
literal|"CAN'T CREATE TM"
argument_list|,
name|_FAILED
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
name|USR_LNOTMP
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|setupline
argument_list|(
name|RCVFILE
argument_list|)
expr_stmt|;
block|}
name|sendmsg
label|:
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wrktype - %c\n"
argument_list|,
name|wrktype
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|wrktype
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|wrktype
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
end_if

begin_comment
comment|/* role is slave */
end_comment

begin_expr_stmt
name|RAMESG
argument_list|(
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|willturn
operator|<
literal|0
condition|)
name|willturn
operator|=
name|msg
index|[
literal|0
index|]
operator|==
name|HUP
expr_stmt|;
end_if

begin_label
name|process
label|:
end_label

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"PROCESS: msg - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|msg
index|[
literal|0
index|]
condition|)
block|{
case|case
name|RQSTCMPT
case|:
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"RQSTCMPT:\n"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|USRF
argument_list|(
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|Em_msg
index|[
name|i
index|]
argument_list|,
literal|"REQUEST FAILED"
argument_list|)
expr_stmt|;
name|TransferSucceeded
operator|=
literal|1
expr_stmt|;
comment|/* He had his chance */
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
name|USRF
argument_list|(
name|USR_COK
argument_list|)
expr_stmt|;
name|TransferSucceeded
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|W_FILE1
argument_list|,
name|Rmtname
argument_list|,
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|2
index|]
operator|==
literal|'M'
operator|&&
name|role
operator|==
name|MASTER
condition|)
block|{
specifier|extern
name|int
name|Nfiles
decl_stmt|;
name|WMESG
argument_list|(
name|HUP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|Rmtname
argument_list|,
literal|"TURNAROUND"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|time
argument_list|(
operator|&
name|LastTurned
operator|.
name|time
argument_list|)
expr_stmt|;
name|LastTurned
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|!USG
name|ftime
argument_list|(
operator|&
name|LastTurned
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!USG
name|Nfiles
operator|=
literal|0
expr_stmt|;
comment|/* force rescan of queue for work */
goto|goto
name|process
goto|;
block|}
goto|goto
name|top
goto|;
case|case
name|HUP
case|:
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"HUP:\n"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|HaveSentHup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
name|Rdmsg
operator|=
name|Imsg
expr_stmt|;
name|Wrmsg
operator|=
name|Omsg
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
if|if
condition|(
name|role
operator|!=
name|MASTER
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - HUP"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|role
operator|=
name|SLAVE
expr_stmt|;
goto|goto
name|remaster
goto|;
block|}
comment|/* get work */
if|if
condition|(
operator|!
name|iswrk
argument_list|(
name|Wfile
argument_list|,
literal|"chk"
argument_list|,
name|Spool
argument_list|,
name|wkpre
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
name|WMESG
argument_list|(
name|HUP
argument_list|,
name|NO
argument_list|)
expr_stmt|;
comment|/* 		 * want to create an orphan uuxqt, 		 * so a double-fork is needed. 		 */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|xuuxqt
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|role
operator|=
name|MASTER
expr_stmt|;
goto|goto
name|remaster
goto|;
case|case
name|XUUCP
case|:
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
goto|goto
name|top
goto|;
block|}
comment|/*  slave part  */
name|i
operator|=
name|getargs
argument_list|(
name|msg
argument_list|,
name|wrkvec
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|filename
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|W_FILE2
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|i
operator|<
literal|3
condition|)
block|{
name|WMESG
argument_list|(
name|XUUCP
argument_list|,
name|NO
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkpth
argument_list|(
literal|""
argument_list|,
name|Rmtname
argument_list|,
name|filename
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|XUUCP
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"XUUCP DENIED"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
name|USR_XUUCP
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s %s"
argument_list|,
name|filename
argument_list|,
name|W_FILE2
argument_list|)
expr_stmt|;
name|xuucp
argument_list|(
name|rqstr
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|XUUCP
argument_list|,
name|YES
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|SNDFILE
case|:
comment|/*  MASTER section of SNDFILE  */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
literal|"SNDFILE:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|logent
argument_list|(
name|Em_msg
index|[
name|i
index|]
argument_list|,
literal|"REQUEST FAILED"
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
comment|/* dont send him files he can't save */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|msg
index|[
literal|1
index|]
argument_list|,
name|EM_NOTMP
argument_list|)
operator|==
literal|0
condition|)
block|{
name|WMESG
argument_list|(
name|HUP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|W_FILE1
argument_list|,
name|Rmtname
argument_list|,
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|!=
name|MASTER
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - SN"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|unlinkdf
argument_list|(
name|W_DFILE
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
comment|/* send file */
if|if
condition|(
name|role
operator|!=
name|MASTER
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - SY"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stat(%s) failed: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
name|stbuf
operator|.
name|st_size
operator|/
name|XFRRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_or_receive
operator|!=
name|SNDFILE
condition|)
block|{
name|send_or_receive
operator|=
name|SNDFILE
expr_stmt|;
name|systat
argument_list|(
name|Rmtname
argument_list|,
name|SS_INPROGRESS
argument_list|,
literal|"SENDING"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
call|(
modifier|*
name|Wrdata
call|)
argument_list|(
name|fp
argument_list|,
name|Ofn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
block|{
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
name|USRF
argument_list|(
name|USR_CFAIL
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|RMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|msg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|W_DFILE
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
comment|/*  SLAVE section of SNDFILE  */
if|if
condition|(
name|role
operator|!=
name|SLAVE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - SLAVE"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* request to receive file */
comment|/* check permissions */
name|i
operator|=
name|getargs
argument_list|(
name|msg
argument_list|,
name|wrkvec
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
block|{
name|char
modifier|*
name|bnp
decl_stmt|;
name|bnp
operator|=
name|rindex
argument_list|(
name|Wfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s/%s"
argument_list|,
name|CORRUPT
argument_list|,
name|bnp
condition|?
name|bnp
operator|+
literal|1
else|:
name|Wfile
argument_list|)
expr_stmt|;
name|xmv
argument_list|(
name|Wfile
argument_list|,
name|rqstr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s CORRUPTED: %d args"
argument_list|,
name|Wfile
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Wfile
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"(%s %s %s %s)"
argument_list|,
name|W_TYPE
argument_list|,
name|W_FILE1
argument_list|,
name|W_FILE2
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUESTED"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"msg - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE2
argument_list|)
expr_stmt|;
comment|/* Run uuxqt occasionally */
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
name|XQTPRE
condition|)
block|{
if|if
condition|(
operator|++
name|nXfiles
operator|>
literal|10
condition|)
block|{
name|nXfiles
operator|=
literal|0
expr_stmt|;
comment|/* 				 * want to create an orphan uuxqt, 				 * so a double-fork is needed. 				 */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|xuuxqt
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* expand filename, i is set to 0 if this is 		 * is a vanilla spool file, so no stat(II)s are needed */
name|i
operator|=
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"expfile type - %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chkpth
argument_list|(
literal|""
argument_list|,
name|Rmtname
argument_list|,
name|filename
argument_list|)
operator|||
name|chkperm
argument_list|(
name|filename
argument_list|,
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'d'
argument_list|)
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|SNDFILE
argument_list|,
name|EM_RMTACC
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"PERMISSION"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|isdir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|lastpart
argument_list|(
name|W_FILE1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|User
argument_list|,
literal|"%.9s"
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"chkpth ok Rmtname - %s\n"
argument_list|,
name|Rmtname
argument_list|)
expr_stmt|;
comment|/* speed things up by OKing file before 		 * creating TM file.  If the TM file cannot be created, 		 * then the conversation bombs, but that seems reasonable, 		 * as there are probably serious problems then. 		 */
name|WMESG
argument_list|(
name|SNDFILE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Dfile
argument_list|,
literal|"%s/TM.%05d.%03d"
argument_list|,
name|Spool
argument_list|,
name|pnum
argument_list|,
name|tmpnum
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|Dfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*			WMESG(SNDFILE, EM_NOTMP);*/
name|logent
argument_list|(
literal|"CAN'T OPEN"
argument_list|,
literal|"TM FILE"
argument_list|)
expr_stmt|;
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|send_or_receive
operator|!=
name|RCVFILE
condition|)
block|{
name|send_or_receive
operator|=
name|RCVFILE
expr_stmt|;
name|systat
argument_list|(
name|Rmtname
argument_list|,
name|SS_INPROGRESS
argument_list|,
literal|"RECEIVING"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
call|(
modifier|*
name|Rddata
call|)
argument_list|(
name|Ifn
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|ret
operator|=
name|FAIL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* copy to user directory */
name|ntfyopt
operator|=
name|index
argument_list|(
name|W_OPTNS
argument_list|,
literal|'n'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|status
operator|=
name|xmv
argument_list|(
name|Dfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|willturn
operator|&&
name|Now
operator|.
name|time
operator|>
operator|(
name|LastTurned
operator|.
name|time
operator|+
name|turntime
operator|)
operator|&&
name|iswrk
argument_list|(
name|Wfile
argument_list|,
literal|"chk"
argument_list|,
name|Spool
argument_list|,
name|wkpre
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|status
condition|?
name|EM_RMTCP
else|:
literal|"YM"
argument_list|)
expr_stmt|;
name|willturn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|WMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|status
condition|?
name|EM_RMTCP
else|:
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* vanilla file, nothing to do */
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|W_MODE
operator|==
literal|0
operator|||
name|sscanf
argument_list|(
name|W_MODE
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|filemode
argument_list|)
operator|!=
literal|1
condition|)
name|filemode
operator|=
name|BASEMODE
expr_stmt|;
name|chmod
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|(
name|filemode
operator||
name|BASEMODE
operator|)
operator|&
literal|0777
argument_list|)
expr_stmt|;
name|arrived
argument_list|(
name|ntfyopt
argument_list|,
name|filename
argument_list|,
name|W_NUSER
argument_list|,
name|Rmtname
argument_list|,
name|User
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logent
argument_list|(
name|_FAILED
argument_list|,
literal|"COPY"
argument_list|)
expr_stmt|;
name|status
operator|=
name|putinpub
argument_list|(
name|filename
argument_list|,
name|Dfile
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"->PUBDIR %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|arrived
argument_list|(
name|ntfyopt
argument_list|,
name|filename
argument_list|,
name|W_NUSER
argument_list|,
name|Rmtname
argument_list|,
name|User
argument_list|)
expr_stmt|;
block|}
goto|goto
name|top
goto|;
case|case
name|RCVFILE
case|:
comment|/*  MASTER section of RCVFILE  */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
literal|"RCVFILE:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|logent
argument_list|(
name|Em_msg
index|[
name|i
index|]
argument_list|,
literal|"REQUEST FAILED"
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|W_FILE1
argument_list|,
name|Rmtname
argument_list|,
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|!=
name|MASTER
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - RN"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
comment|/* receive file */
if|if
condition|(
name|role
operator|!=
name|MASTER
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - RY"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|send_or_receive
operator|!=
name|RCVFILE
condition|)
block|{
name|send_or_receive
operator|=
name|RCVFILE
expr_stmt|;
name|systat
argument_list|(
name|Rmtname
argument_list|,
name|SS_INPROGRESS
argument_list|,
literal|"RECEIVING"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
call|(
modifier|*
name|Rddata
call|)
argument_list|(
name|Ifn
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|ret
operator|=
name|FAIL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
block|{
name|unlinkdf
argument_list|(
name|Dfile
argument_list|)
expr_stmt|;
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
name|USRF
argument_list|(
name|USR_CFAIL
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* copy to user directory */
if|if
condition|(
name|isdir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|lastpart
argument_list|(
name|W_FILE1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|xmv
argument_list|(
name|Dfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|status
condition|?
name|EM_RMTCP
else|:
name|YES
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|mailopt
argument_list|,
name|W_USER
argument_list|,
name|filename
argument_list|,
name|Rmtname
argument_list|,
name|status
condition|?
name|EM_LOCCP
else|:
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|sscanf
argument_list|(
operator|&
name|msg
index|[
literal|2
index|]
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|filemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|<=
literal|0
condition|)
name|filemode
operator|=
name|BASEMODE
expr_stmt|;
name|chmod
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|(
name|filemode
operator||
name|BASEMODE
operator|)
operator|&
literal|0777
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
name|USR_COK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logent
argument_list|(
name|_FAILED
argument_list|,
literal|"COPY"
argument_list|)
expr_stmt|;
name|putinpub
argument_list|(
name|filename
argument_list|,
name|Dfile
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
name|USRF
argument_list|(
name|USR_LOCCP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
index|[
name|strlen
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'M'
condition|)
block|{
specifier|extern
name|int
name|Nfiles
decl_stmt|;
name|WMESG
argument_list|(
name|HUP
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|HUP
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|Rmtname
argument_list|,
literal|"TURNAROUND"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|time
argument_list|(
operator|&
name|LastTurned
operator|.
name|time
argument_list|)
expr_stmt|;
name|LastTurned
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|!USG
name|ftime
argument_list|(
operator|&
name|LastTurned
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!USG
name|Nfiles
operator|=
literal|0
expr_stmt|;
comment|/* force rescan of queue for work */
goto|goto
name|process
goto|;
block|}
goto|goto
name|top
goto|;
block|}
comment|/*  SLAVE section of RCVFILE  */
if|if
condition|(
name|role
operator|!=
name|SLAVE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Wrong Role - SLAVE RCV"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* request to send file */
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"(%s)"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|rqstr
argument_list|,
literal|"REQUESTED"
argument_list|)
expr_stmt|;
comment|/* check permissions */
name|i
operator|=
name|getargs
argument_list|(
name|msg
argument_list|,
name|wrkvec
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|char
modifier|*
name|bnp
decl_stmt|;
name|bnp
operator|=
name|rindex
argument_list|(
name|Wfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rqstr
argument_list|,
literal|"%s/%s"
argument_list|,
name|CORRUPT
argument_list|,
name|bnp
condition|?
name|bnp
operator|+
literal|1
else|:
name|Wfile
argument_list|)
expr_stmt|;
name|xmv
argument_list|(
name|Wfile
argument_list|,
name|rqstr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s CORRUPTED: %d args"
argument_list|,
name|Wfile
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Wfile
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"msg - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"W_FILE1 - %s\n"
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|W_FILE1
argument_list|)
expr_stmt|;
name|expfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|lastpart
argument_list|(
name|W_FILE2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|User
argument_list|,
literal|"%.9s"
argument_list|,
name|W_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkpth
argument_list|(
literal|""
argument_list|,
name|Rmtname
argument_list|,
name|filename
argument_list|)
operator|||
name|anyread
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|WMESG
argument_list|(
name|RCVFILE
argument_list|,
name|EM_RMTACC
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DENIED"
argument_list|,
literal|"PERMISSION"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"chkpth ok Rmtname - %s\n"
argument_list|,
name|Rmtname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|subfile
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|WMESG
argument_list|(
name|RCVFILE
argument_list|,
name|EM_RMTACC
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"CAN'T OPEN"
argument_list|,
literal|"DENIED"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/*  ok to send file */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stat(%s) failed: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
name|stbuf
operator|.
name|st_size
operator|/
name|XFRRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|willturn
operator|&&
name|Now
operator|.
name|time
operator|>
operator|(
name|LastTurned
operator|.
name|time
operator|+
name|turntime
operator|)
operator|&&
name|iswrk
argument_list|(
name|Wfile
argument_list|,
literal|"chk"
argument_list|,
name|Spool
argument_list|,
name|wkpre
argument_list|)
condition|)
block|{
name|willturn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s %o%s"
argument_list|,
name|YES
argument_list|,
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_mode
operator|&
literal|0777
argument_list|,
name|willturn
operator|<
literal|0
condition|?
literal|" M"
else|:
literal|""
argument_list|)
expr_stmt|;
name|WMESG
argument_list|(
name|RCVFILE
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_or_receive
operator|!=
name|SNDFILE
condition|)
block|{
name|send_or_receive
operator|=
name|SNDFILE
expr_stmt|;
name|systat
argument_list|(
name|Rmtname
argument_list|,
name|SS_INPROGRESS
argument_list|,
literal|"SENDING"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
call|(
modifier|*
name|Wrdata
call|)
argument_list|(
name|fp
argument_list|,
name|Ofn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SUCCESS
condition|)
block|{
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|RMESG
argument_list|(
name|RQSTCMPT
argument_list|,
name|msg
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
end_switch

begin_expr_stmt
call|(
modifier|*
name|Turnoff
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|FAIL
return|;
end_return

begin_comment
unit|}
comment|/*  *	read message 'c'. try 'n' times  *  *	return code:  SUCCESS  |  FAIL  */
end_comment

begin_expr_stmt
unit|rmesg
operator|(
name|c
operator|,
name|msg
operator|,
name|n
operator|)
specifier|register
name|char
operator|*
name|msg
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"rmesg - '%c' "
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
call|(
modifier|*
name|Rdmsg
call|)
argument_list|(
name|msg
argument_list|,
name|Ifn
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
if|if
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|str
argument_list|,
literal|"PATIENCE"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got FAIL\n"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"expected '%c' got FAIL (%d)"
argument_list|,
name|c
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"expected ANY got FAIL (%d)"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|str
argument_list|,
literal|"BAD READ"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|msg
index|[
literal|0
index|]
operator|!=
name|c
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"expected '%c' got %s"
argument_list|,
name|c
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|str
argument_list|,
literal|"BAD READ"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_block

begin_comment
comment|/*  *	write a message (type m)  *  *	return codes: SUCCESS - ok | FAIL - ng  */
end_comment

begin_expr_stmt
name|wmesg
argument_list|(
name|m
argument_list|,
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
name|m
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wmesg '%c' "
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|Wrmsg
call|)
argument_list|(
name|m
argument_list|,
name|s
argument_list|,
name|Ofn
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  *	mail results of command  *  *	return codes:  none  */
end_comment

begin_macro
name|notify
argument_list|(
argument|mailopt
argument_list|,
argument|user
argument_list|,
argument|file
argument_list|,
argument|sys
argument_list|,
argument|msgcode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|sys
decl_stmt|,
modifier|*
name|msgcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|mailopt
operator|&&
operator|*
name|msgcode
operator|==
literal|'Y'
condition|)
return|return;
if|if
condition|(
operator|*
name|msgcode
operator|==
literal|'Y'
condition|)
name|msg
operator|=
literal|"copy succeeded"
expr_stmt|;
else|else
block|{
name|i
operator|=
name|atoi
argument_list|(
name|msgcode
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
name|EM_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|Em_msg
index|[
name|i
index|]
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"file %s!%s -- %s\n"
argument_list|,
name|sys
argument_list|,
name|file
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|mailst
argument_list|(
name|user
argument_list|,
name|str
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  *	local notify  *  *	return code - none  */
end_comment

begin_macro
name|lnotify
argument_list|(
argument|user
argument_list|,
argument|file
argument_list|,
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|mbuf
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|mbuf
argument_list|,
literal|"file %s!%s -- %s\n"
argument_list|,
name|Myname
argument_list|,
name|file
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|mailst
argument_list|(
name|user
argument_list|,
name|mbuf
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_decl_stmt
name|char
name|UsingProtocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	converse with the remote machine, agree upon a protocol (if possible)  *	and start the protocol.  *  *	return codes:  *		SUCCESS - successful protocol selection  *		FAIL - can't find common or open failed  */
end_comment

begin_macro
name|startup
argument_list|(
argument|role
argument_list|)
end_macro

begin_decl_stmt
name|int
name|role
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
type|(
modifier|*
name|Rdmsg
decl_stmt|)(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
call|(
modifier|*
name|Wrmsg
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|blptcl
argument_list|()
decl_stmt|,
name|fptcl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|msg
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|str
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Rdmsg
operator|=
name|Imsg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Wrmsg
operator|=
name|Omsg
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|role
operator|==
name|MASTER
condition|)
block|{
name|RMESG
argument_list|(
name|SLTPTCL
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
index|[
literal|0
index|]
operator|=
name|fptcl
argument_list|(
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no protocol match */
name|WMESG
argument_list|(
name|USEPTCL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|WMESG
argument_list|(
name|USEPTCL
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|stptcl
argument_list|(
name|str
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FAIL
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"protocol %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|UsingProtocol
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
name|WMESG
argument_list|(
name|SLTPTCL
argument_list|,
name|blptcl
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|RMESG
argument_list|(
name|USEPTCL
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|stptcl
argument_list|(
operator|&
name|msg
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FAIL
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Protocol %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|UsingProtocol
operator|=
name|msg
index|[
literal|1
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_if

begin_comment
unit|}
comment|/*  *	choose a protocol from the input string (str) and return the it  *  *	return codes:  *		'\0'  -  no acceptable protocol  *		any character  -  the chosen protocol  */
end_comment

begin_expr_stmt
unit|char
name|fptcl
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Proto
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
name|LineType
index|[]
decl_stmt|;
for|for
control|(
name|p
operator|=
name|Ptbl
init|;
name|p
operator|->
name|P_id
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|TCPIP
comment|/* Only use 't' on TCP/IP */
if|if
condition|(
name|p
operator|->
name|P_id
operator|==
literal|'t'
operator|&&
name|strcmp
argument_list|(
literal|"TCP"
argument_list|,
name|LineType
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
endif|TCPIP
ifdef|#
directive|ifdef
name|PAD
comment|/* only use 'f' protocol on PAD */
if|if
condition|(
name|p
operator|->
name|P_id
operator|==
literal|'f'
operator|&&
name|strcmp
argument_list|(
literal|"PAD"
argument_list|,
name|LineType
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
endif|PAD
if|if
condition|(
name|index
argument_list|(
name|str
argument_list|,
name|p
operator|->
name|P_id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
name|p
operator|->
name|P_id
return|;
block|}
block|}
return|return
literal|'\0'
return|;
block|}
end_block

begin_comment
comment|/*  *	build a string of the letters of the available protocols   */
end_comment

begin_function
name|char
modifier|*
name|blptcl
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|struct
name|Proto
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|p
operator|=
name|Ptbl
operator|,
name|s
operator|=
name|str
init|;
operator|(
operator|*
name|s
operator|++
operator|=
name|p
operator|->
name|P_id
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/*  *	this routine will set up the six routines  *	(Rdmsg, Wrmsg, Rddata, Wrdata, Turnon, Turnoff) for the  *	desired protocol.  *  *	return codes:  *		SUCCESS - ok  *		FAIL - no find or failed to open  *  */
end_comment

begin_expr_stmt
name|stptcl
argument_list|(
name|c
argument_list|)
specifier|register
name|char
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Proto
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|Ptbl
init|;
name|p
operator|->
name|P_id
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
name|p
operator|->
name|P_id
condition|)
block|{
comment|/* found protocol - set routines */
name|Rdmsg
operator|=
name|p
operator|->
name|P_rdmsg
expr_stmt|;
name|Wrmsg
operator|=
name|p
operator|->
name|P_wrmsg
expr_stmt|;
name|Rddata
operator|=
name|p
operator|->
name|P_rddata
expr_stmt|;
name|Wrdata
operator|=
name|p
operator|->
name|P_wrdata
expr_stmt|;
name|Turnon
operator|=
name|p
operator|->
name|P_turnon
expr_stmt|;
name|Turnoff
operator|=
name|p
operator|->
name|P_turnoff
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|Turnon
call|)
argument_list|()
operator|!=
name|SUCCESS
condition|)
return|return
name|FAIL
return|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Proto started %c\n"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Proto start-fail %c\n"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_block

begin_comment
comment|/*  *	put file in public place. if successful, filename is modified  *  *	return code  SUCCESS | FAIL  */
end_comment

begin_expr_stmt
name|putinpub
argument_list|(
name|file
argument_list|,
name|tmp
argument_list|,
name|user
argument_list|)
specifier|register
name|char
operator|*
name|file
operator|,
operator|*
name|tmp
operator|,
operator|*
name|user
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|fullname
index|[
name|MAXFULLNAME
index|]
decl_stmt|;
name|char
modifier|*
name|lastpart
parameter_list|()
function_decl|;
name|int
name|status
decl_stmt|;
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s/%s/"
argument_list|,
name|PUBDIR
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdirs
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* can not make directories */
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot mkdirs(%s)\n"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|strcat
argument_list|(
name|fullname
argument_list|,
name|lastpart
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xmv
argument_list|(
name|tmp
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|file
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|subfile
argument_list|(
name|fullname
argument_list|)
argument_list|,
name|BASEMODE
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*  *	unlink D. file  *  *	return code - none  */
end_comment

begin_expr_stmt
name|unlinkdf
argument_list|(
name|file
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|>
literal|6
condition|)
name|unlink
argument_list|(
name|subfile
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  *	notify receiver of arrived file  *  *	return code - none  */
end_comment

begin_macro
name|arrived
argument_list|(
argument|opt
argument_list|,
argument|file
argument_list|,
argument|nuser
argument_list|,
argument|rmtsys
argument_list|,
argument|rmtuser
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|nuser
decl_stmt|,
modifier|*
name|rmtsys
decl_stmt|,
modifier|*
name|rmtuser
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|mbuf
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
return|return;
name|sprintf
argument_list|(
name|mbuf
argument_list|,
literal|"%s from %s!%s arrived\n"
argument_list|,
name|file
argument_list|,
name|rmtsys
argument_list|,
name|rmtuser
argument_list|)
expr_stmt|;
name|mailst
argument_list|(
name|nuser
argument_list|,
name|mbuf
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|nullf
argument_list|()
end_macro

begin_block
block|{
return|return
name|SUCCESS
return|;
block|}
end_block

end_unit

