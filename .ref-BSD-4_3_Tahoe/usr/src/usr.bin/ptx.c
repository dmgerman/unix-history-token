begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ptx.c	4.3 (Berkeley) 12/2/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*	permuted title index 	ptx [-t] [-i ignore] [-o only] [-w num] [-f] [input] [output] 	Ptx reads the input file and permutes on words in it. 	It excludes all words in the ignore file. 	Alternately it includes words in the only file. 	if neither is given it excludes the words in /usr/lib/eign.  	The width of the output line can be changed to num 	characters.  If omitted 72 is default unless troff than 100. 	the -f flag tells the program to fold the output 	the -t flag says the output is for troff and the 	output is then wider.  	*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|DEFLTX
value|"/usr/lib/eign"
end_define

begin_define
define|#
directive|define
name|TILDE
value|0177
end_define

begin_define
define|#
directive|define
name|SORT
value|"/usr/bin/sort"
end_define

begin_define
define|#
directive|define
name|N
value|30
end_define

begin_define
define|#
directive|define
name|MAX
value|N*BUFSIZ
end_define

begin_define
define|#
directive|define
name|LMAX
value|200
end_define

begin_define
define|#
directive|define
name|MAXT
value|2048
end_define

begin_define
define|#
directive|define
name|MASK
value|03777
end_define

begin_define
define|#
directive|define
name|SET
value|1
end_define

begin_define
define|#
directive|define
name|isabreak
parameter_list|(
name|c
parameter_list|)
value|(btable[c])
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|mktemp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getline
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hasht
index|[
name|MAXT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
name|LMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|btable
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ignore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|only
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|llen
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gap
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gutter
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mlen
init|=
name|LMAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|halflen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strtbufp
decl_stmt|,
modifier|*
name|endbufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|empty
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inptr
init|=
name|stdin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outptr
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sortfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output of sort program */
end_comment

begin_decl_stmt
name|char
name|nofold
index|[]
init|=
block|{
literal|'-'
block|,
literal|'d'
block|,
literal|'t'
block|,
name|TILDE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fold
index|[]
init|=
block|{
literal|'-'
block|,
literal|'d'
block|,
literal|'f'
block|,
literal|'t'
block|,
name|TILDE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sortopt
init|=
name|nofold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sortptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*contains user supplied break chars */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|bptr
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|pend
decl_stmt|;
extern|extern onintr(
block|)
function|;
end_function

begin_decl_stmt
name|char
modifier|*
name|xfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|xptr
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onintr
argument_list|)
operator|==
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
operator|==
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*	argument decoding	*/
end_comment

begin_expr_stmt
name|xfile
operator|=
name|DEFLTX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|argv
operator|++
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
block|{
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|sortopt
operator|=
name|fold
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|wlen
operator|++
expr_stmt|;
name|llen
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|llen
operator|==
literal|0
condition|)
name|diag
argument_list|(
literal|"Wrong width:"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|llen
operator|>
name|LMAX
condition|)
block|{
name|llen
operator|=
name|LMAX
expr_stmt|;
name|msg
argument_list|(
literal|"Lines truncated to 200 chars."
argument_list|,
name|empty
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'t'
case|:
if|if
condition|(
name|wlen
operator|==
literal|0
condition|)
name|llen
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|gap
operator|=
name|gutter
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|only
condition|)
name|diag
argument_list|(
literal|"Only file already given."
argument_list|,
name|empty
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|ignore
operator|++
expr_stmt|;
name|xfile
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|ignore
condition|)
name|diag
argument_list|(
literal|"Ignore file already given"
argument_list|,
name|empty
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|only
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|xfile
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|bfile
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
block|}
break|break;
default|default:
name|msg
argument_list|(
literal|"Illegal argument:"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
end_while

begin_if
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
name|diag
argument_list|(
literal|"Too many filenames"
argument_list|,
name|empty
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|infile
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|outfile
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|outptr
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Cannot open output file:"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|infile
operator|=
operator|*
name|argv
expr_stmt|;
name|outfile
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Default breaks of blank, tab and newline */
end_comment

begin_expr_stmt
name|btable
index|[
literal|' '
index|]
operator|=
name|SET
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|btable
index|[
literal|'\t'
index|]
operator|=
name|SET
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|btable
index|[
literal|'\n'
index|]
operator|=
name|SET
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bfile
condition|)
block|{
if|if
condition|(
operator|(
name|bptr
operator|=
name|fopen
argument_list|(
name|bfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Cannot open break char file"
argument_list|,
name|bfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|bptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|btable
index|[
name|c
index|]
operator|=
name|SET
expr_stmt|;
block|}
end_if

begin_comment
comment|/*	Allocate space for a buffer.  If only or ignore file present 	read it into buffer. Else read in default ignore file 	and put resulting words in buffer. 	*/
end_comment

begin_if
if|if
condition|(
operator|(
name|strtbufp
operator|=
name|calloc
argument_list|(
name|N
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Out of memory space"
argument_list|,
name|empty
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|bufp
operator|=
name|strtbufp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|endbufp
operator|=
name|strtbufp
operator|+
name|MAX
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|xptr
operator|=
name|fopen
argument_list|(
name|xfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Cannot open  file"
argument_list|,
name|xfile
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
name|bufp
operator|<
name|endbufp
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|xptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|isabreak
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|storeh
argument_list|(
name|hash
argument_list|(
name|strtbufp
argument_list|,
name|bufp
argument_list|)
argument_list|,
name|strtbufp
argument_list|)
condition|)
name|diag
argument_list|(
literal|"Too many words"
argument_list|,
name|xfile
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|strtbufp
operator|=
name|bufp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bufp
operator|++
operator|=
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
block|}
block|}
end_while

begin_if
if|if
condition|(
name|bufp
operator|>=
name|endbufp
condition|)
name|diag
argument_list|(
literal|"Too many words in file"
argument_list|,
name|xfile
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|endbufp
operator|=
operator|--
name|bufp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* open output file for sorting */
end_comment

begin_expr_stmt
name|sortfile
operator|=
name|mktemp
argument_list|(
literal|"/tmp/ptxsXXXXX"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|sortptr
operator|=
name|fopen
argument_list|(
name|sortfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Cannot open output for sorting:"
argument_list|,
name|sortfile
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/*	get a line of data and compare each word for 	inclusion or exclusion in the sort phase */
end_comment

begin_if
if|if
condition|(
name|infile
operator|!=
literal|0
operator|&&
operator|(
name|inptr
operator|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Cannot open data: "
argument_list|,
name|infile
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
name|pend
operator|=
name|getline
argument_list|()
condition|)
name|cmpline
argument_list|(
name|pend
argument_list|)
expr_stmt|;
end_while

begin_expr_stmt
name|fclose
argument_list|(
name|sortptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* cannot fork */
name|diag
argument_list|(
literal|"Cannot fork"
argument_list|,
name|empty
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* child */
name|execl
argument_list|(
name|SORT
argument_list|,
name|SORT
argument_list|,
name|sortopt
argument_list|,
literal|"+0"
argument_list|,
literal|"-1"
argument_list|,
literal|"+1"
argument_list|,
name|sortfile
argument_list|,
literal|"-o"
argument_list|,
name|sortfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
comment|/* parent */
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
block|}
end_switch

begin_expr_stmt
name|getsort
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|sortfile
condition|)
name|unlink
argument_list|(
name|sortfile
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  msg
operator|(
name|s
operator|,
name|arg
operator|)
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|s
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|diag
argument_list|(
argument|s
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|msg
argument_list|(
name|s
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|getline
parameter_list|()
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|linep
decl_stmt|;
name|char
modifier|*
name|endlinep
decl_stmt|;
name|endlinep
operator|=
name|line
operator|+
name|mlen
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
comment|/* Throw away leading white space */
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|inptr
argument_list|)
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|inptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
if|if
condition|(
name|linep
operator|<
name|endlinep
condition|)
operator|*
name|linep
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|--
name|linep
argument_list|)
condition|)
empty_stmt|;
operator|*
operator|++
name|linep
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|linep
operator|)
return|;
default|default:
if|if
condition|(
name|linep
operator|<
name|endlinep
condition|)
operator|*
name|linep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|cmpline
argument_list|(
argument|pend
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pend
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pstrt
decl_stmt|,
modifier|*
name|pchar
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
modifier|*
name|hp
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|pchar
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
while|while
condition|(
name|pchar
operator|<
name|pend
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|pchar
argument_list|)
condition|)
name|pchar
operator|++
expr_stmt|;
while|while
condition|(
name|pchar
operator|<
name|pend
condition|)
block|{
comment|/* eliminate white space */
if|if
condition|(
name|isabreak
argument_list|(
operator|*
name|pchar
operator|++
argument_list|)
condition|)
continue|continue;
name|pstrt
operator|=
operator|--
name|pchar
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|isabreak
argument_list|(
operator|*
name|pchar
argument_list|)
condition|)
block|{
name|hp
operator|=
operator|&
name|hasht
index|[
name|hash
argument_list|(
name|pstrt
argument_list|,
name|pchar
argument_list|)
index|]
expr_stmt|;
name|pchar
operator|--
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|hp
operator|++
condition|)
block|{
if|if
condition|(
name|hp
operator|==
operator|&
name|hasht
index|[
name|MAXT
index|]
condition|)
name|hp
operator|=
name|hasht
expr_stmt|;
comment|/* possible match */
if|if
condition|(
name|cmpword
argument_list|(
name|pstrt
argument_list|,
name|pchar
argument_list|,
name|cp
argument_list|)
condition|)
block|{
comment|/* exact match */
if|if
condition|(
operator|!
name|ignore
operator|&&
name|only
condition|)
name|putline
argument_list|(
name|pstrt
argument_list|,
name|pend
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* no match */
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|ignore
operator|||
operator|!
name|only
condition|)
name|putline
argument_list|(
name|pstrt
argument_list|,
name|pend
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|pchar
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cmpword
argument_list|(
argument|cpp
argument_list|,
argument|pend
argument_list|,
argument|hpp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cpp
decl_stmt|,
modifier|*
name|pend
decl_stmt|,
modifier|*
name|hpp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|hpp
operator|!=
literal|'\0'
condition|)
block|{
name|c
operator|=
operator|*
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
operator|!=
operator|*
name|hpp
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|--
name|cpp
operator|==
name|pend
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|putline
argument_list|(
argument|strt
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|strt
decl_stmt|,
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|strt
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|sortptr
argument_list|)
expr_stmt|;
comment|/* Add extra blank before TILDE to sort correctly 	   with -fd option */
name|putc
argument_list|(
literal|' '
argument_list|,
name|sortptr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|TILDE
argument_list|,
name|sortptr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
init|;
name|cp
operator|<
name|strt
condition|;
name|cp
operator|++
control|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|sortptr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|sortptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getsort
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|tilde
decl_stmt|,
modifier|*
name|linep
decl_stmt|,
modifier|*
name|ref
decl_stmt|;
name|char
modifier|*
name|p1a
decl_stmt|,
modifier|*
name|p1b
decl_stmt|,
modifier|*
name|p2a
decl_stmt|,
modifier|*
name|p2b
decl_stmt|,
modifier|*
name|p3a
decl_stmt|,
modifier|*
name|p3b
decl_stmt|,
modifier|*
name|p4a
decl_stmt|,
modifier|*
name|p4b
decl_stmt|;
name|int
name|w
decl_stmt|;
name|char
modifier|*
name|rtrim
argument_list|()
decl_stmt|,
modifier|*
name|ltrim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|sortptr
operator|=
name|fopen
argument_list|(
name|sortfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|diag
argument_list|(
literal|"Cannot open sorted data:"
argument_list|,
name|sortfile
argument_list|)
expr_stmt|;
name|halflen
operator|=
operator|(
name|llen
operator|-
name|gutter
operator|)
operator|/
literal|2
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|sortptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TILDE
case|:
name|tilde
operator|=
name|linep
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
while|while
condition|(
name|isspace
argument_list|(
name|linep
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|linep
operator|--
expr_stmt|;
name|ref
operator|=
name|tilde
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
while|while
condition|(
name|ref
operator|<
name|linep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ref
argument_list|)
condition|)
name|ref
operator|++
expr_stmt|;
operator|*
name|ref
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* the -1 is an overly conservative test to leave 		   space for the / that signifies truncation*/
name|p3b
operator|=
name|rtrim
argument_list|(
name|p3a
operator|=
name|line
argument_list|,
name|tilde
argument_list|,
name|halflen
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p3b
operator|-
name|p3a
operator|>
name|halflen
operator|-
literal|1
condition|)
name|p3b
operator|=
name|p3a
operator|+
name|halflen
operator|-
literal|1
expr_stmt|;
name|p2a
operator|=
name|ltrim
argument_list|(
name|ref
argument_list|,
name|p2b
operator|=
name|linep
argument_list|,
name|halflen
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2b
operator|-
name|p2a
operator|>
name|halflen
operator|-
literal|1
condition|)
name|p2a
operator|=
name|p2b
operator|-
name|halflen
operator|-
literal|1
expr_stmt|;
name|p1b
operator|=
name|rtrim
argument_list|(
name|p1a
operator|=
name|p3b
operator|+
operator|(
name|isspace
argument_list|(
name|p3b
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|)
argument_list|,
name|tilde
argument_list|,
name|w
operator|=
name|halflen
operator|-
operator|(
name|p2b
operator|-
name|p2a
operator|)
operator|-
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1b
operator|-
name|p1a
operator|>
name|w
condition|)
name|p1b
operator|=
name|p1a
expr_stmt|;
name|p4a
operator|=
name|ltrim
argument_list|(
name|ref
argument_list|,
name|p4b
operator|=
name|p2a
operator|-
operator|(
name|isspace
argument_list|(
name|p2a
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|)
argument_list|,
name|w
operator|=
name|halflen
operator|-
operator|(
name|p3b
operator|-
name|p3a
operator|)
operator|-
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p4b
operator|-
name|p4a
operator|>
name|w
condition|)
name|p4a
operator|=
name|p4b
expr_stmt|;
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|".xx \""
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p1a
argument_list|,
name|p1b
argument_list|)
expr_stmt|;
comment|/* tilde-1 to account for extra space before TILDE */
if|if
condition|(
name|p1b
operator|!=
operator|(
name|tilde
operator|-
literal|1
operator|)
operator|&&
name|p1a
operator|!=
name|p1b
condition|)
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|p4a
operator|==
name|p4b
operator|&&
name|p2a
operator|!=
name|ref
operator|&&
name|p2a
operator|!=
name|p2b
condition|)
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p2a
argument_list|,
name|p2b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p3a
argument_list|,
name|p3b
argument_list|)
expr_stmt|;
comment|/* ++p3b to account for extra blank after TILDE */
comment|/* ++p3b to account for extra space before TILDE */
if|if
condition|(
name|p1a
operator|==
name|p1b
operator|&&
operator|++
name|p3b
operator|!=
name|tilde
condition|)
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1a
operator|==
name|p1b
operator|&&
name|p4a
operator|!=
name|ref
operator|&&
name|p4a
operator|!=
name|p4b
condition|)
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p4a
argument_list|,
name|p4b
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"\" %s\n"
argument_list|,
name|tilde
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outptr
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
comment|/* put double " for "  */
operator|*
name|linep
operator|++
operator|=
name|c
expr_stmt|;
default|default:
operator|*
name|linep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|rtrim
parameter_list|(
name|a
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|b
operator|=
name|c
expr_stmt|;
for|for
control|(
name|x
operator|=
name|a
operator|+
literal|1
init|;
name|x
operator|<=
name|c
operator|&&
name|x
operator|-
name|a
operator|<=
name|d
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|(
name|x
operator|==
name|c
operator|||
name|isspace
argument_list|(
name|x
index|[
literal|0
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|x
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|b
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|b
operator|<
name|c
operator|&&
operator|!
name|isspace
argument_list|(
name|b
index|[
literal|0
index|]
argument_list|)
condition|)
name|b
operator|++
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|ltrim
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|c
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|a
operator|=
name|c
expr_stmt|;
for|for
control|(
name|x
operator|=
name|b
operator|-
literal|1
init|;
name|x
operator|>=
name|c
operator|&&
name|b
operator|-
name|x
operator|<=
name|d
condition|;
name|x
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|x
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|x
operator|==
name|c
operator|||
name|isspace
argument_list|(
name|x
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|a
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|a
operator|>
name|c
operator|&&
operator|!
name|isspace
argument_list|(
name|a
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|a
operator|--
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_block

begin_macro
name|putout
argument_list|(
argument|strt
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|strt
decl_stmt|,
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strt
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strt
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
block|{
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|outptr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|sortfile
condition|)
name|unlink
argument_list|(
name|sortfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hash
argument_list|(
argument|strtp
argument_list|,
argument|endp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|strtp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Return zero hash number for single letter words */
if|if
condition|(
operator|(
name|endp
operator|-
name|strtp
operator|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|=
name|strtp
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|j
operator|=
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
name|i
operator|=
name|i
operator|*
name|j
expr_stmt|;
name|cp
operator|=
operator|--
name|endp
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|--
expr_stmt|;
name|k
operator|=
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|j
operator|=
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
name|j
operator|=
name|k
operator|*
name|j
expr_stmt|;
name|k
operator|=
operator|(
name|i
operator|^
operator|(
name|j
operator|>>
literal|2
operator|)
operator|)
operator|&
name|MASK
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_macro
name|storeh
argument_list|(
argument|num
argument_list|,
argument|strtp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strtp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|MAXT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hasht
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|hasht
index|[
name|i
index|]
operator|=
name|strtp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hasht
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|hasht
index|[
name|i
index|]
operator|=
name|strtp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

