begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)deroff.c	4.7	(Berkeley)	88/04/24"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  *	Deroff command -- strip troff, eqn, and Tbl sequences from  *	a file.  Has two flags argument, -w, to cause output one word per line  *	rather than in the original format.  *	-mm (or -ms) causes the corresponding macro's to be interpreted  *	so that just sentences are output  *	-ml  also gets rid of lists.  *	Deroff follows .so and .nx commands, removes contents of macro  *	definitions, equations (both .EQ ... .EN and $...$),  *	Tbl command sequences, and Troff backslash constructions.  *  *	All input is through the Cget macro;  *	the most recently read character is in c.  *  *	Modified by Robert Henry to process -me and -man macros.  */
end_comment

begin_define
define|#
directive|define
name|Cget
value|( (c=getc(infile)) == EOF ? eof() : ((c==ldelim)&&(filesp==files) ? skeqn() : c) )
end_define

begin_define
define|#
directive|define
name|C1get
value|( (c=getc(infile)) == EOF ? eof() :  c)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|C
value|_C()
end_define

begin_define
define|#
directive|define
name|C1
value|_C1()
end_define

begin_else
else|#
directive|else
else|not DEBUG
end_else

begin_define
define|#
directive|define
name|C
value|Cget
end_define

begin_define
define|#
directive|define
name|C1
value|C1get
end_define

begin_endif
endif|#
directive|endif
endif|not DEBUG
end_endif

begin_define
define|#
directive|define
name|SKIP
value|while(C != '\n')
end_define

begin_define
define|#
directive|define
name|SKIP_TO_COM
value|SKIP; SKIP; pc=c; while(C != '.' || pc != '\n' || C> 'Z')pc=c
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|MS
value|0
end_define

begin_comment
comment|/* -ms */
end_comment

begin_define
define|#
directive|define
name|MM
value|1
end_define

begin_comment
comment|/* -mm */
end_comment

begin_define
define|#
directive|define
name|ME
value|2
end_define

begin_comment
comment|/* -me */
end_comment

begin_define
define|#
directive|define
name|MA
value|3
end_define

begin_comment
comment|/* -man */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|mactab
index|[]
init|=
block|{
literal|"-ms"
block|,
literal|"-mm"
block|,
literal|"-me"
block|,
literal|"-ma"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_define
define|#
directive|define
name|ONE
value|1
end_define

begin_define
define|#
directive|define
name|TWO
value|2
end_define

begin_define
define|#
directive|define
name|NOCHAR
value|-2
end_define

begin_define
define|#
directive|define
name|SPECIAL
value|0
end_define

begin_define
define|#
directive|define
name|APOS
value|1
end_define

begin_define
define|#
directive|define
name|PUNCT
value|2
end_define

begin_define
define|#
directive|define
name|DIGIT
value|3
end_define

begin_define
define|#
directive|define
name|LETTER
value|4
end_define

begin_decl_stmt
name|int
name|wordflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* processing a source written using a mac package */
end_comment

begin_decl_stmt
name|int
name|mac
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which package */
end_comment

begin_decl_stmt
name|int
name|disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inmacro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keepblock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keep blocks of text; normally false when msflag */
end_comment

begin_decl_stmt
name|char
name|chars
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPECIAL, PUNCT, APOS, DIGIT, or LETTER */
end_comment

begin_decl_stmt
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ldelim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rdelim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fname
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|files
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|filesp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|opn
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *	Flags for matching conditions other than  *	the macro name  */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|FNEST
value|1
end_define

begin_comment
comment|/* no nested files */
end_comment

begin_define
define|#
directive|define
name|NOMAC
value|2
end_define

begin_comment
comment|/* no macro */
end_comment

begin_define
define|#
directive|define
name|MAC
value|3
end_define

begin_comment
comment|/* macro */
end_comment

begin_define
define|#
directive|define
name|PARAG
value|4
end_define

begin_comment
comment|/* in a paragraph */
end_comment

begin_define
define|#
directive|define
name|MSF
value|5
end_define

begin_comment
comment|/* msflag is on */
end_comment

begin_define
define|#
directive|define
name|NBLK
value|6
end_define

begin_comment
comment|/* set if no blocks to be kept */
end_comment

begin_comment
comment|/*  *	Return codes from macro minions, determine where to jump,  *	how to repeat/reprocess text  */
end_comment

begin_define
define|#
directive|define
name|COMX
value|1
end_define

begin_comment
comment|/* goto comx */
end_comment

begin_define
define|#
directive|define
name|COM
value|2
end_define

begin_comment
comment|/* goto com */
end_comment

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
specifier|register
name|optchar
expr_stmt|;
name|FILE
modifier|*
name|opn
parameter_list|()
function_decl|;
name|int
name|kflag
init|=
name|NO
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|wordflag
operator|=
name|NO
expr_stmt|;
name|msflag
operator|=
name|NO
expr_stmt|;
name|mac
operator|=
name|ME
expr_stmt|;
name|disp
operator|=
name|NO
expr_stmt|;
name|parag
operator|=
name|NO
expr_stmt|;
name|inmacro
operator|=
name|NO
expr_stmt|;
name|intable
operator|=
name|NO
expr_stmt|;
name|ldelim
operator|=
name|NOCHAR
expr_stmt|;
name|rdelim
operator|=
name|NOCHAR
expr_stmt|;
name|keepblock
operator|=
name|YES
expr_stmt|;
for|for
control|(
name|argc
operator|=
name|ac
operator|-
literal|1
operator|,
name|argv
operator|=
name|av
operator|+
literal|1
init|;
operator|(
operator|(
name|argc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
operator|)
condition|;
operator|--
name|argc
operator|,
operator|++
name|argv
control|)
block|{
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'p'
case|:
name|parag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|kflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wordflag
operator|=
name|YES
expr_stmt|;
name|kflag
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|msflag
operator|=
name|YES
expr_stmt|;
name|keepblock
operator|=
name|NO
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'m'
case|:
name|mac
operator|=
name|MM
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mac
operator|=
name|MS
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|mac
operator|=
name|ME
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|mac
operator|=
name|MA
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|disp
operator|=
name|YES
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|kflag
condition|)
name|keepblock
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|errflg
condition|)
name|fatal
argument_list|(
literal|"usage: deroff [ -w ] [ -k] [ -m (a e m s l) ] [ file ] ... \n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"msflag = %d, mac = %s, keepblock = %d, disp = %d\n"
argument_list|,
name|msflag
argument_list|,
name|mactab
index|[
name|mac
index|]
argument_list|,
name|keepblock
argument_list|,
name|disp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|infile
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|infile
operator|=
name|opn
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
name|files
index|[
literal|0
index|]
operator|=
name|infile
expr_stmt|;
name|filesp
operator|=
operator|&
name|files
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
operator|++
name|i
control|)
name|chars
index|[
name|i
index|]
operator|=
name|LETTER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
control|)
name|chars
index|[
name|i
index|]
operator|=
name|LETTER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
operator|++
name|i
control|)
name|chars
index|[
name|i
index|]
operator|=
name|DIGIT
expr_stmt|;
name|chars
index|[
literal|'\''
index|]
operator|=
name|APOS
expr_stmt|;
name|chars
index|[
literal|'&'
index|]
operator|=
name|APOS
expr_stmt|;
name|chars
index|[
literal|'.'
index|]
operator|=
name|PUNCT
expr_stmt|;
name|chars
index|[
literal|','
index|]
operator|=
name|PUNCT
expr_stmt|;
name|chars
index|[
literal|';'
index|]
operator|=
name|PUNCT
expr_stmt|;
name|chars
index|[
literal|'?'
index|]
operator|=
name|PUNCT
expr_stmt|;
name|chars
index|[
literal|':'
index|]
operator|=
name|PUNCT
expr_stmt|;
name|work
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|skeqn
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
name|rdelim
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|c
operator|=
name|eof
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'"'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|c
operator|=
name|eof
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
name|eof
argument_list|()
expr_stmt|;
if|if
condition|(
name|msflag
condition|)
return|return
operator|(
name|c
operator|=
literal|'x'
operator|)
return|;
return|return
operator|(
name|c
operator|=
literal|' '
operator|)
return|;
block|}
end_block

begin_function
name|FILE
modifier|*
name|opn
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Deroff: "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_macro
name|eof
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|infile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesp
operator|>
name|files
condition|)
name|infile
operator|=
operator|*
operator|--
name|filesp
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|infile
operator|=
name|opn
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
else|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|C
operator|)
return|;
block|}
end_block

begin_macro
name|getfname
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
struct|struct
name|chain
block|{
name|struct
name|chain
modifier|*
name|nextp
decl_stmt|;
name|char
modifier|*
name|datap
decl_stmt|;
block|}
modifier|*
name|chainblock
struct|;
specifier|register
name|struct
name|chain
modifier|*
name|q
decl_stmt|;
specifier|static
name|struct
name|chain
modifier|*
name|namechain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|copys
parameter_list|()
function_decl|;
while|while
condition|(
name|C
operator|==
literal|' '
condition|)
empty_stmt|;
for|for
control|(
name|p
operator|=
name|fname
init|;
operator|(
operator|*
name|p
operator|=
name|c
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\\'
condition|;
operator|++
name|p
control|)
name|C
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|C
expr_stmt|;
comment|/* see if this name has already been used */
for|for
control|(
name|q
operator|=
name|namechain
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fname
argument_list|,
name|q
operator|->
name|datap
argument_list|)
condition|)
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|q
operator|=
operator|(
expr|struct
name|chain
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chainblock
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|nextp
operator|=
name|namechain
expr_stmt|;
name|q
operator|->
name|datap
operator|=
name|copys
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|namechain
operator|=
name|q
expr_stmt|;
block|}
end_block

begin_macro
name|fatal
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Deroff: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|textline
argument_list|(
argument|str
argument_list|,
argument|constant
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|constant
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|wordflag
condition|)
block|{
name|msputwords
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|puts
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|work
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|C
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLDEBUG
name|printf
argument_list|(
literal|"Starting work with `%c'\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FULLDEBUG
if|if
condition|(
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|comline
argument_list|()
expr_stmt|;
else|else
name|regline
argument_list|(
name|textline
argument_list|,
name|TWO
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|regline
argument_list|(
argument|pfunc
argument_list|,
argument|constant
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|constant
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|lp
operator|=
literal|' '
expr_stmt|;
name|backsl
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|intable
operator|&&
name|c
operator|==
literal|'T'
condition|)
block|{
operator|*
operator|++
name|lp
operator|=
name|C
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
condition|)
block|{
name|lp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
operator|*
name|lp
operator|=
name|C
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
operator|++
name|lp
operator|=
name|C
expr_stmt|;
block|}
block|}
operator|*
name|lp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
call|(
modifier|*
name|pfunc
call|)
argument_list|(
name|line
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|macro
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|msflag
condition|)
block|{
do|do
block|{
name|SKIP
expr_stmt|;
block|}
do|while
condition|(
name|C
operator|!=
literal|'.'
operator|||
name|C
operator|!=
literal|'.'
operator|||
name|C
operator|==
literal|'.'
condition|)
do|;
comment|/* look for  .. */
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|SKIP
expr_stmt|;
return|return;
block|}
name|SKIP
expr_stmt|;
name|inmacro
operator|=
name|YES
expr_stmt|;
block|}
end_block

begin_macro
name|tbl
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|C
operator|!=
literal|'.'
condition|)
empty_stmt|;
name|SKIP
expr_stmt|;
name|intable
operator|=
name|YES
expr_stmt|;
block|}
end_block

begin_macro
name|stbl
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|C
operator|!=
literal|'.'
condition|)
empty_stmt|;
name|SKIP_TO_COM
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'T'
operator|||
name|C
operator|!=
literal|'E'
condition|)
block|{
name|SKIP
expr_stmt|;
name|pc
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|C
operator|!=
literal|'.'
operator|||
name|pc
operator|!=
literal|'\n'
operator|||
name|C
operator|!=
literal|'T'
operator|||
name|C
operator|!=
literal|'E'
condition|)
name|pc
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|eqn
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
specifier|register
name|int
name|dflg
decl_stmt|;
name|char
name|last
decl_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
name|dflg
operator|=
literal|1
expr_stmt|;
name|SKIP
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|C1
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'\''
condition|)
block|{
while|while
condition|(
name|C1
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'E'
operator|&&
name|C1
operator|==
literal|'N'
condition|)
block|{
name|SKIP
expr_stmt|;
if|if
condition|(
name|msflag
operator|&&
name|dflg
condition|)
block|{
name|putchar
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
comment|/* look for delim */
block|{
if|if
condition|(
name|C1
operator|==
literal|'e'
operator|&&
name|C1
operator|==
literal|'l'
condition|)
if|if
condition|(
name|C1
operator|==
literal|'i'
operator|&&
name|C1
operator|==
literal|'m'
condition|)
block|{
while|while
condition|(
name|C1
operator|==
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|c1
operator|=
name|c
operator|)
operator|==
literal|'\n'
operator|||
operator|(
name|c2
operator|=
name|C1
operator|)
operator|==
literal|'\n'
operator|||
operator|(
name|c1
operator|==
literal|'o'
operator|&&
name|c2
operator|==
literal|'f'
operator|&&
name|C1
operator|==
literal|'f'
operator|)
condition|)
block|{
name|ldelim
operator|=
name|NOCHAR
expr_stmt|;
name|rdelim
operator|=
name|NOCHAR
expr_stmt|;
block|}
else|else
block|{
name|ldelim
operator|=
name|c1
expr_stmt|;
name|rdelim
operator|=
name|c2
expr_stmt|;
block|}
block|}
name|dflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|C1
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|chars
index|[
name|c
index|]
operator|==
name|PUNCT
condition|)
name|last
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|last
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|backsl
argument_list|()
end_macro

begin_comment
comment|/* skip over a complete backslash construction */
end_comment

begin_block
block|{
name|int
name|bdelim
decl_stmt|;
name|sw
label|:
switch|switch
condition|(
name|C
condition|)
block|{
case|case
literal|'"'
case|:
name|SKIP
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
if|if
condition|(
name|C
operator|==
literal|'\\'
condition|)
name|backsl
argument_list|()
expr_stmt|;
else|else
block|{
while|while
condition|(
name|C
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
empty_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'0'
expr_stmt|;
block|}
operator|--
name|lp
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
case|case
literal|'n'
case|:
case|case
literal|'*'
case|:
if|if
condition|(
name|C
operator|!=
literal|'('
condition|)
return|return;
case|case
literal|'('
case|:
if|if
condition|(
name|msflag
condition|)
block|{
if|if
condition|(
name|C
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|C
operator|==
literal|'m'
condition|)
block|{
operator|*
name|lp
operator|=
literal|'-'
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|C
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|C
operator|!=
literal|'\n'
condition|)
name|C
expr_stmt|;
return|return;
case|case
literal|'$'
case|:
name|C
expr_stmt|;
comment|/* discard argument number */
return|return;
case|case
literal|'b'
case|:
case|case
literal|'x'
case|:
case|case
literal|'v'
case|:
case|case
literal|'h'
case|:
case|case
literal|'w'
case|:
case|case
literal|'o'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
operator|(
name|bdelim
operator|=
name|C
operator|)
operator|==
literal|'\n'
condition|)
return|return;
while|while
condition|(
name|C
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|bdelim
condition|)
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|backsl
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'\\'
case|:
if|if
condition|(
name|inmacro
condition|)
goto|goto
name|sw
goto|;
default|default:
return|return;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|copys
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|t0
decl_stmt|;
if|if
condition|(
operator|(
name|t0
operator|=
name|t
operator|=
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Cannot allocate memory"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|t0
operator|)
return|;
block|}
end_function

begin_macro
name|sce
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|char
name|a
index|[
literal|10
index|]
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|a
init|;
name|C
operator|!=
literal|'\n'
condition|;
name|ap
operator|++
control|)
block|{
operator|*
name|ap
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|ap
operator|==
operator|&
name|a
index|[
literal|9
index|]
condition|)
block|{
name|SKIP
expr_stmt|;
name|ap
operator|=
name|a
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ap
operator|!=
name|a
condition|)
name|n
operator|=
name|atoi
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
name|C
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|C
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|C
operator|==
literal|'e'
condition|)
block|{
while|while
condition|(
name|C
operator|==
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|SKIP
expr_stmt|;
break|break;
block|}
else|else
name|SKIP
expr_stmt|;
block|}
else|else
name|SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'P'
operator|||
name|C
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|SKIP
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|SKIP
expr_stmt|;
block|}
else|else
block|{
name|SKIP
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|refer
argument_list|(
argument|c1
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|c2
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|'\n'
condition|)
name|SKIP
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|C
operator|!=
literal|'.'
condition|)
name|SKIP
expr_stmt|;
else|else
block|{
if|if
condition|(
name|C
operator|!=
literal|']'
condition|)
name|SKIP
expr_stmt|;
else|else
block|{
while|while
condition|(
name|C
operator|!=
literal|'\n'
condition|)
name|c2
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|chars
index|[
name|c2
index|]
operator|==
name|PUNCT
condition|)
name|putchar
argument_list|(
name|c2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|inpic
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
name|SKIP
expr_stmt|;
name|p1
operator|=
name|line
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c1
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|C
operator|==
literal|'.'
operator|&&
name|c1
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|C
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
else|else
block|{
name|SKIP
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|C
operator|!=
literal|'E'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
else|else
block|{
name|SKIP
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
continue|continue;
block|}
block|}
name|SKIP
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
block|{
while|while
condition|(
name|C
operator|!=
literal|'\"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|C
operator|==
literal|'\"'
condition|)
continue|continue;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|backsl
argument_list|()
expr_stmt|;
block|}
else|else
operator|*
name|p1
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p1
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|p1
operator|!=
name|line
condition|)
block|{
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|wordflag
condition|)
name|msputwords
argument_list|(
name|NO
argument_list|)
expr_stmt|;
else|else
block|{
name|puts
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|_C1
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|C1get
operator|)
return|;
block|}
end_block

begin_macro
name|_C
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|Cget
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *	Macro processing  *  *	Macro table definitions  */
end_comment

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_typedef
typedef|typedef
name|int
name|pacmac
typedef|;
end_typedef

begin_comment
comment|/* compressed macro name */
end_comment

begin_decl_stmt
name|int
name|argconcat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* concat arguments together (-me only) */
end_comment

begin_define
define|#
directive|define
name|tomac
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
value|((((c1)& 0xFF)<< 8) | ((c2)& 0xFF))
end_define

begin_define
define|#
directive|define
name|frommac
parameter_list|(
name|src
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
value|(((c1)=((src)>>8)&0xFF),((c2) =(src)&0xFF))
end_define

begin_struct
struct|struct
name|mactab
block|{
name|int
name|condition
decl_stmt|;
name|pacmac
name|macname
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mactab
name|troffmactab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|ppmactab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|msmactab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|mmmactab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|memactab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|manmactab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	macro table initialization  */
end_comment

begin_define
define|#
directive|define
name|M
parameter_list|(
name|cond
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|,
name|func
parameter_list|)
value|{cond, tomac(c1, c2), func}
end_define

begin_comment
comment|/*  *	Put out a macro line, using ms and mm conventions.  */
end_comment

begin_expr_stmt
name|msputmac
argument_list|(
name|s
argument_list|,
name|constant
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|constant
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|found
expr_stmt|;
name|int
name|last
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wordflag
condition|)
block|{
name|msputwords
argument_list|(
name|YES
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|!=
literal|' '
operator|&&
operator|*
name|t
operator|!=
literal|'\t'
operator|&&
operator|*
name|t
operator|!=
literal|'\0'
condition|;
operator|++
name|t
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\"'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|>
name|s
operator|+
name|constant
operator|&&
name|chars
index|[
name|s
index|[
literal|0
index|]
index|]
operator|==
name|LETTER
operator|&&
name|chars
index|[
name|s
index|[
literal|1
index|]
index|]
operator|==
name|LETTER
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|t
condition|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\"'
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|last
operator|=
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
operator|&&
name|chars
index|[
name|s
index|[
literal|0
index|]
index|]
operator|==
name|PUNCT
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
block|{
name|last
operator|=
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|msflag
operator|&&
name|chars
index|[
name|last
index|]
operator|==
name|PUNCT
condition|)
block|{
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	put out words (for the -w option) with ms and mm conventions  */
end_comment

begin_macro
name|msputwords
argument_list|(
argument|macline
argument_list|)
end_macro

begin_decl_stmt
name|int
name|macline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is this is a macro line */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nlet
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|line
init|;
condition|;
control|)
block|{
comment|/* 		 *	skip initial specials ampersands and apostrophes 		 */
while|while
condition|(
name|chars
index|[
operator|*
name|p1
index|]
operator|<
name|DIGIT
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|'\0'
condition|)
return|return;
name|nlet
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p1
init|;
operator|(
name|i
operator|=
name|chars
index|[
operator|*
name|p
index|]
operator|)
operator|!=
name|SPECIAL
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|i
operator|==
name|LETTER
condition|)
operator|++
name|nlet
expr_stmt|;
if|if
condition|(
name|nlet
operator|>
literal|1
operator|&&
name|chars
index|[
name|p1
index|[
literal|0
index|]
index|]
operator|==
name|LETTER
condition|)
block|{
comment|/* 			 *	delete trailing ampersands and apostrophes 			 */
while|while
condition|(
operator|(
name|i
operator|=
name|chars
index|[
name|p
index|[
operator|-
literal|1
index|]
index|]
operator|)
operator|==
name|PUNCT
operator|||
name|i
operator|==
name|APOS
condition|)
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|p
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	put out a macro using the me conventions  */
end_comment

begin_define
define|#
directive|define
name|SKIPBLANK
parameter_list|(
name|cp
parameter_list|)
value|while(*cp == ' ' || *cp == '\t') { cp++; }
end_define

begin_define
define|#
directive|define
name|SKIPNONBLANK
parameter_list|(
name|cp
parameter_list|)
value|while(*cp !=' '&& *cp !='\cp'&& *cp !='\0') { cp++; }
end_define

begin_macro
name|meputmac
argument_list|(
argument|cp
argument_list|,
argument|constant
argument_list|)
end_macro

begin_decl_stmt
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|constant
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|int
name|last
decl_stmt|;
name|int
name|inquote
decl_stmt|;
if|if
condition|(
name|wordflag
condition|)
block|{
name|meputwords
argument_list|(
name|YES
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|argno
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|argno
operator|++
control|)
block|{
name|SKIPBLANK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|inquote
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|inquote
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|np
operator|=
name|cp
init|;
operator|*
name|np
condition|;
name|np
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|np
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
if|if
condition|(
name|inquote
condition|)
block|{
continue|continue;
block|}
else|else
block|{
goto|goto
name|endarg
goto|;
block|}
case|case
literal|'"'
case|:
if|if
condition|(
name|inquote
operator|&&
name|np
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
name|strcpy
argument_list|(
name|np
argument_list|,
name|np
operator|+
literal|1
argument_list|)
expr_stmt|;
name|np
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|np
operator|=
literal|' '
expr_stmt|;
comment|/* bye bye " */
goto|goto
name|endarg
goto|;
block|}
default|default:
continue|continue;
block|}
block|}
name|endarg
label|:
empty_stmt|;
comment|/* 		 *	cp points at the first char in the arg 		 *	np points one beyond the last char in the arg 		 */
if|if
condition|(
operator|(
name|argconcat
operator|==
literal|0
operator|)
operator|||
operator|(
name|argconcat
operator|!=
name|argno
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FULLDEBUG
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"[%d,%d: "
argument_list|,
name|argno
argument_list|,
name|np
operator|-
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cp
init|;
name|p
operator|<
name|np
condition|;
name|p
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|FULLDEBUG
comment|/* 		 *	Determine if the argument merits being printed 		 * 		 *	constant is the cut off point below which something 		 *	is not a word. 		 */
if|if
condition|(
operator|(
operator|(
name|np
operator|-
name|cp
operator|)
operator|>
name|constant
operator|)
operator|&&
operator|(
name|inquote
operator|||
operator|(
name|chars
index|[
name|cp
index|[
literal|0
index|]
index|]
operator|==
name|LETTER
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|cp
init|;
name|cp
operator|<
name|np
condition|;
name|cp
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|np
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
operator|&&
operator|(
name|np
operator|-
name|cp
operator|==
literal|1
operator|)
operator|&&
name|chars
index|[
operator|*
name|cp
index|]
operator|==
name|PUNCT
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|np
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|cp
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|msflag
operator|&&
name|chars
index|[
name|last
index|]
operator|==
name|PUNCT
condition|)
name|putchar
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	put out words (for the -w option) with ms and mm conventions  */
end_comment

begin_macro
name|meputwords
argument_list|(
argument|macline
argument_list|)
end_macro

begin_decl_stmt
name|int
name|macline
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|msputwords
argument_list|(
name|macline
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  *	Skip over a nested set of macros  *  *	Possible arguments to noblock are:  *  *	fi	end of unfilled text  *	PE	pic ending  *	DE	display ending  *  *	for ms and mm only:  *		KE	keep ending  *  *		NE	undocumented match to NS (for mm?)  *		LE	mm only: matches RL or *L (for lists)  *  *	for me:  *		([lqbzcdf]  */
end_comment

begin_macro
name|noblock
argument_list|(
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
name|a1
decl_stmt|,
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
specifier|register
name|int
name|eqnf
decl_stmt|;
name|int
name|lct
decl_stmt|;
name|lct
operator|=
literal|0
expr_stmt|;
name|eqnf
operator|=
literal|1
expr_stmt|;
name|SKIP
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|C
operator|!=
literal|'.'
condition|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
else|else
name|SKIP
expr_stmt|;
if|if
condition|(
operator|(
name|c1
operator|=
name|C
operator|)
operator|==
literal|'\n'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|c2
operator|=
name|C
operator|)
operator|==
literal|'\n'
condition|)
continue|continue;
if|if
condition|(
name|c1
operator|==
name|a1
operator|&&
name|c2
operator|==
name|a2
condition|)
block|{
name|SKIP
expr_stmt|;
if|if
condition|(
name|lct
operator|!=
literal|0
condition|)
block|{
name|lct
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|eqnf
condition|)
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|a1
operator|==
literal|'L'
operator|&&
name|c2
operator|==
literal|'L'
condition|)
block|{
name|lct
operator|++
expr_stmt|;
name|SKIP
expr_stmt|;
block|}
comment|/* 		 *	equations (EQ) nested within a display 		 */
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'E'
operator|&&
name|c2
operator|==
literal|'Q'
condition|)
block|{
if|if
condition|(
operator|(
name|mac
operator|==
name|ME
operator|&&
name|a1
operator|==
literal|')'
operator|)
operator|||
operator|(
name|mac
operator|!=
name|ME
operator|&&
name|a1
operator|==
literal|'D'
operator|)
condition|)
block|{
name|eqn
argument_list|()
expr_stmt|;
name|eqnf
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 *	turning on filling is done by the paragraphing 		 *	macros 		 */
elseif|else
if|if
condition|(
name|a1
operator|==
literal|'f'
condition|)
block|{
comment|/* .fi */
if|if
condition|(
operator|(
name|mac
operator|==
name|ME
operator|&&
operator|(
name|c2
operator|==
literal|'h'
operator|||
name|c2
operator|==
literal|'p'
operator|)
operator|)
operator|||
operator|(
name|mac
operator|!=
name|ME
operator|&&
operator|(
name|c1
operator|==
literal|'P'
operator|||
name|c2
operator|==
literal|'P'
operator|)
operator|)
condition|)
block|{
name|SKIP
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|SKIP
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|EQ
argument_list|()
end_macro

begin_block
block|{
name|eqn
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|domacro
argument_list|()
end_macro

begin_block
block|{
name|macro
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|PS
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
name|C
init|;
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|;
name|C
control|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
comment|/* ".PS< file" -- don't expect a .PE */
name|SKIP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|msflag
condition|)
block|{
name|inpic
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|noblock
argument_list|(
literal|'P'
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|skip
argument_list|()
end_macro

begin_block
block|{
name|SKIP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|intbl
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|msflag
condition|)
block|{
name|stbl
argument_list|()
expr_stmt|;
block|}
else|else
name|tbl
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|outtbl
argument_list|()
end_macro

begin_block
block|{
name|intable
operator|=
name|NO
expr_stmt|;
block|}
end_block

begin_macro
name|so
argument_list|()
end_macro

begin_block
block|{
name|getfname
argument_list|()
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
condition|)
name|infile
operator|=
operator|*
operator|++
name|filesp
operator|=
name|opn
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nx
argument_list|()
end_macro

begin_block
block|{
name|getfname
argument_list|()
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
operator|*
name|filesp
operator|=
name|opn
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|skiptocom
argument_list|()
end_macro

begin_block
block|{
name|SKIP_TO_COM
expr_stmt|;
return|return
operator|(
name|COMX
operator|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|frommac
argument_list|(
name|c12
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".%c%c"
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
while|while
condition|(
name|C
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|AU
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|mac
operator|==
name|MM
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|SKIP_TO_COM
expr_stmt|;
return|return
operator|(
name|COMX
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|SH
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|frommac
argument_list|(
name|c12
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|parag
condition|)
block|{
name|printf
argument_list|(
literal|".%c%c"
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
while|while
condition|(
name|C
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|C
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|C
operator|==
literal|'.'
condition|)
return|return
operator|(
name|COM
operator|)
return|;
name|putchar
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
else|else
block|{
name|SKIP_TO_COM
expr_stmt|;
return|return
operator|(
name|COMX
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|UX
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|wordflag
condition|)
name|printf
argument_list|(
literal|"UNIX\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"UNIX "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|MMHU
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|frommac
argument_list|(
name|c12
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|parag
condition|)
block|{
name|printf
argument_list|(
literal|".%c%c"
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
while|while
condition|(
name|C
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SKIP
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|mesnblock
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|frommac
argument_list|(
name|c12
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|noblock
argument_list|(
literal|')'
argument_list|,
name|c2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|mssnblock
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|frommac
argument_list|(
name|c12
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|noblock
argument_list|(
name|c1
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nf
argument_list|()
end_macro

begin_block
block|{
name|noblock
argument_list|(
literal|'f'
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ce
argument_list|()
end_macro

begin_block
block|{
name|sce
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|meip
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|parag
condition|)
name|mepp
argument_list|(
name|c12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wordflag
condition|)
comment|/* save the tag */
name|regline
argument_list|(
name|meputmac
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
else|else
block|{
name|SKIP
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	only called for -me .pp or .sh, when parag is on  */
end_comment

begin_macro
name|mepp
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PP
argument_list|(
name|c12
argument_list|)
expr_stmt|;
comment|/* eats the line */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*   *	Start of a section heading; output the section name if doing words  */
end_comment

begin_macro
name|mesh
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|parag
condition|)
name|mepp
argument_list|(
name|c12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wordflag
condition|)
name|defcomline
argument_list|(
name|c12
argument_list|)
expr_stmt|;
else|else
block|{
name|SKIP
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	process a font setting  */
end_comment

begin_macro
name|mefont
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|argconcat
operator|=
literal|1
expr_stmt|;
name|defcomline
argument_list|(
name|c12
argument_list|)
expr_stmt|;
name|argconcat
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|manfont
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|mefont
argument_list|(
name|c12
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|manpp
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|mepp
argument_list|(
name|c12
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|defcomline
argument_list|(
argument|c12
argument_list|)
end_macro

begin_decl_stmt
name|pacmac
name|c12
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|frommac
argument_list|(
name|c12
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|msflag
operator|&&
name|mac
operator|==
name|MM
operator|&&
name|c2
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|disp
operator|||
name|c1
operator|==
literal|'R'
condition|)
block|{
name|noblock
argument_list|(
literal|'L'
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SKIP
expr_stmt|;
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'.'
operator|&&
name|c2
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|msflag
condition|)
block|{
name|SKIP
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|C
operator|==
literal|'.'
condition|)
comment|/*VOID*/
empty_stmt|;
block|}
operator|++
name|inmacro
expr_stmt|;
comment|/* 	 *	Process the arguments to the macro 	 */
switch|switch
condition|(
name|mac
condition|)
block|{
default|default:
case|case
name|MM
case|:
case|case
name|MS
case|:
if|if
condition|(
name|c1
operator|<=
literal|'Z'
operator|&&
name|msflag
condition|)
name|regline
argument_list|(
name|msputmac
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
else|else
name|regline
argument_list|(
name|msputmac
argument_list|,
name|TWO
argument_list|)
expr_stmt|;
break|break;
case|case
name|ME
case|:
name|regline
argument_list|(
name|meputmac
argument_list|,
name|ONE
argument_list|)
expr_stmt|;
break|break;
block|}
operator|--
name|inmacro
expr_stmt|;
block|}
end_block

begin_macro
name|comline
argument_list|()
end_macro

begin_block
block|{
name|reg
name|int
name|c1
decl_stmt|;
name|reg
name|int
name|c2
decl_stmt|;
name|pacmac
name|c12
decl_stmt|;
name|reg
name|int
name|mid
decl_stmt|;
name|int
name|lb
decl_stmt|,
name|ub
decl_stmt|;
name|int
name|hit
decl_stmt|;
specifier|static
name|int
name|tabsize
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|mactab
modifier|*
name|mactab
init|=
operator|(
expr|struct
name|mactab
operator|*
operator|)
literal|0
decl_stmt|;
name|reg
name|struct
name|mactab
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|mactab
operator|==
literal|0
condition|)
block|{
name|buildtab
argument_list|(
operator|&
name|mactab
argument_list|,
operator|&
name|tabsize
argument_list|)
expr_stmt|;
block|}
name|com
label|:
while|while
condition|(
name|C
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|comx
label|:
if|if
condition|(
operator|(
name|c1
operator|=
name|c
operator|)
operator|==
literal|'\n'
condition|)
return|return;
name|c2
operator|=
name|C
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'.'
operator|&&
name|c2
operator|!=
literal|'.'
condition|)
name|inmacro
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|msflag
operator|&&
name|c1
operator|==
literal|'['
condition|)
block|{
name|refer
argument_list|(
name|c2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parag
operator|&&
name|mac
operator|==
name|MM
operator|&&
name|c1
operator|==
literal|'P'
operator|&&
name|c2
operator|==
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|".P\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c2
operator|==
literal|'\n'
condition|)
return|return;
comment|/* 	 *	Single letter macro 	 */
if|if
condition|(
name|mac
operator|==
name|ME
operator|&&
operator|(
name|c2
operator|==
literal|' '
operator|||
name|c2
operator|==
literal|'\t'
operator|)
condition|)
name|c2
operator|=
literal|' '
expr_stmt|;
name|c12
operator|=
name|tomac
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
comment|/* 	 *	binary search through the table of macros 	 */
name|lb
operator|=
literal|0
expr_stmt|;
name|ub
operator|=
name|tabsize
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lb
operator|<=
name|ub
condition|)
block|{
name|mid
operator|=
operator|(
name|ub
operator|+
name|lb
operator|)
operator|/
literal|2
expr_stmt|;
name|mp
operator|=
operator|&
name|mactab
index|[
name|mid
index|]
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|macname
operator|<
name|c12
condition|)
name|lb
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mp
operator|->
name|macname
operator|>
name|c12
condition|)
name|ub
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|hit
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLDEBUG
name|printf
argument_list|(
literal|"preliminary hit macro %c%c "
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FULLDEBUG
switch|switch
condition|(
name|mp
operator|->
name|condition
condition|)
block|{
case|case
name|NONE
case|:
name|hit
operator|=
name|YES
expr_stmt|;
break|break;
case|case
name|FNEST
case|:
name|hit
operator|=
operator|(
name|filesp
operator|==
name|files
operator|)
expr_stmt|;
break|break;
case|case
name|NOMAC
case|:
name|hit
operator|=
operator|!
name|inmacro
expr_stmt|;
break|break;
case|case
name|MAC
case|:
name|hit
operator|=
name|inmacro
expr_stmt|;
break|break;
case|case
name|PARAG
case|:
name|hit
operator|=
name|parag
expr_stmt|;
break|break;
case|case
name|NBLK
case|:
name|hit
operator|=
operator|!
name|keepblock
expr_stmt|;
break|break;
default|default:
name|hit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hit
condition|)
block|{
ifdef|#
directive|ifdef
name|FULLDEBUG
name|printf
argument_list|(
literal|"MATCH\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FULLDEBUG
switch|switch
condition|(
operator|(
operator|*
operator|(
name|mp
operator|->
name|func
operator|)
operator|)
operator|(
name|c12
operator|)
condition|)
block|{
default|default:
return|return;
case|case
name|COMX
case|:
goto|goto
name|comx
goto|;
case|case
name|COM
case|:
goto|goto
name|com
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|FULLDEBUG
name|printf
argument_list|(
literal|"FAIL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FULLDEBUG
break|break;
block|}
block|}
name|defcomline
argument_list|(
name|c12
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|macsort
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|struct
name|mactab
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|p1
operator|->
name|macname
operator|-
name|p2
operator|->
name|macname
operator|)
return|;
block|}
end_block

begin_function
name|int
name|sizetab
parameter_list|(
name|mp
parameter_list|)
name|reg
name|struct
name|mactab
modifier|*
name|mp
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
for|for
control|(
init|;
name|mp
operator|->
name|macname
condition|;
name|mp
operator|++
operator|,
name|i
operator|++
control|)
comment|/*VOID*/
empty_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mactab
modifier|*
name|macfill
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|reg
name|struct
name|mactab
modifier|*
name|dst
decl_stmt|;
name|reg
name|struct
name|mactab
modifier|*
name|src
decl_stmt|;
block|{
if|if
condition|(
name|src
condition|)
block|{
while|while
condition|(
name|src
operator|->
name|macname
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_macro
name|buildtab
argument_list|(
argument|r_back
argument_list|,
argument|r_size
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mactab
modifier|*
modifier|*
name|r_back
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|r_size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|size
decl_stmt|;
name|struct
name|mactab
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|struct
name|mactab
modifier|*
name|back
decl_stmt|;
name|size
operator|=
name|sizetab
argument_list|(
name|troffmactab
argument_list|)
expr_stmt|;
name|size
operator|+=
name|sizetab
argument_list|(
name|ppmactab
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
operator|=
operator|(
expr|struct
name|mactab
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|msflag
condition|)
block|{
switch|switch
condition|(
name|mac
condition|)
block|{
case|case
name|ME
case|:
name|p1
operator|=
name|memactab
expr_stmt|;
break|break;
case|case
name|MM
case|:
name|p1
operator|=
name|msmactab
expr_stmt|;
name|p2
operator|=
name|mmmactab
expr_stmt|;
break|break;
case|case
name|MS
case|:
name|p1
operator|=
name|msmactab
expr_stmt|;
break|break;
case|case
name|MA
case|:
name|p1
operator|=
name|manmactab
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|size
operator|+=
name|sizetab
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|size
operator|+=
name|sizetab
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|back
operator|=
operator|(
expr|struct
name|mactab
operator|*
operator|)
name|calloc
argument_list|(
name|size
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mactab
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|macfill
argument_list|(
name|back
argument_list|,
name|troffmactab
argument_list|)
expr_stmt|;
name|p
operator|=
name|macfill
argument_list|(
name|p
argument_list|,
name|ppmactab
argument_list|)
expr_stmt|;
name|p
operator|=
name|macfill
argument_list|(
name|p
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|p
operator|=
name|macfill
argument_list|(
name|p
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|back
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mactab
argument_list|)
argument_list|,
name|macsort
argument_list|)
expr_stmt|;
operator|*
name|r_size
operator|=
name|size
expr_stmt|;
operator|*
name|r_back
operator|=
name|back
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	troff commands  */
end_comment

begin_decl_stmt
name|struct
name|mactab
name|troffmactab
index|[]
init|=
block|{
name|M
argument_list|(
name|NONE
argument_list|,
literal|'\\'
argument_list|,
literal|'"'
argument_list|,
name|skip
argument_list|)
block|,
comment|/* comment */
name|M
argument_list|(
name|NOMAC
argument_list|,
literal|'d'
argument_list|,
literal|'e'
argument_list|,
name|domacro
argument_list|)
block|,
comment|/* define */
name|M
argument_list|(
name|NOMAC
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|,
name|domacro
argument_list|)
block|,
comment|/* ignore till .. */
name|M
argument_list|(
name|NOMAC
argument_list|,
literal|'a'
argument_list|,
literal|'m'
argument_list|,
name|domacro
argument_list|)
block|,
comment|/* append macro */
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'n'
argument_list|,
literal|'f'
argument_list|,
name|nf
argument_list|)
block|,
comment|/* filled */
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'c'
argument_list|,
literal|'e'
argument_list|,
name|ce
argument_list|)
block|,
comment|/* centered */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'s'
argument_list|,
literal|'o'
argument_list|,
name|so
argument_list|)
block|,
comment|/* source a file */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'n'
argument_list|,
literal|'x'
argument_list|,
name|nx
argument_list|)
block|,
comment|/* go to next file */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'t'
argument_list|,
literal|'m'
argument_list|,
name|skip
argument_list|)
block|,
comment|/* print string on tty */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'h'
argument_list|,
literal|'w'
argument_list|,
name|skip
argument_list|)
block|,
comment|/* exception hyphen words */
name|M
argument_list|(
argument|NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Preprocessor output  */
end_comment

begin_decl_stmt
name|struct
name|mactab
name|ppmactab
index|[]
init|=
block|{
name|M
argument_list|(
name|FNEST
argument_list|,
literal|'E'
argument_list|,
literal|'Q'
argument_list|,
name|EQ
argument_list|)
block|,
comment|/* equation starting */
name|M
argument_list|(
name|FNEST
argument_list|,
literal|'T'
argument_list|,
literal|'S'
argument_list|,
name|intbl
argument_list|)
block|,
comment|/* table starting */
name|M
argument_list|(
name|FNEST
argument_list|,
literal|'T'
argument_list|,
literal|'C'
argument_list|,
name|intbl
argument_list|)
block|,
comment|/* alternative table? */
name|M
argument_list|(
name|FNEST
argument_list|,
literal|'T'
argument_list|,
literal|'&'
argument_list|,
name|intbl
argument_list|)
block|,
comment|/* table reformatting */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'T'
argument_list|,
literal|'E'
argument_list|,
name|outtbl
argument_list|)
block|,
comment|/* table ending */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'P'
argument_list|,
literal|'S'
argument_list|,
name|PS
argument_list|)
block|,
comment|/* picture starting */
name|M
argument_list|(
argument|NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Particular to ms and mm  */
end_comment

begin_decl_stmt
name|struct
name|mactab
name|msmactab
index|[]
init|=
block|{
name|M
argument_list|(
name|NONE
argument_list|,
literal|'T'
argument_list|,
literal|'L'
argument_list|,
name|skiptocom
argument_list|)
block|,
comment|/* title follows */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'F'
argument_list|,
literal|'S'
argument_list|,
name|skiptocom
argument_list|)
block|,
comment|/* start footnote */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'O'
argument_list|,
literal|'K'
argument_list|,
name|skiptocom
argument_list|)
block|,
comment|/* Other kws */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'N'
argument_list|,
literal|'R'
argument_list|,
name|skip
argument_list|)
block|,
comment|/* undocumented */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'N'
argument_list|,
literal|'D'
argument_list|,
name|skip
argument_list|)
block|,
comment|/* use supplied date */
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'P'
argument_list|,
literal|'P'
argument_list|,
name|PP
argument_list|)
block|,
comment|/* begin parag */
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'I'
argument_list|,
literal|'P'
argument_list|,
name|PP
argument_list|)
block|,
comment|/* begin indent parag, tag x */
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'L'
argument_list|,
literal|'P'
argument_list|,
name|PP
argument_list|)
block|,
comment|/* left blocked parag */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'A'
argument_list|,
literal|'U'
argument_list|,
name|AU
argument_list|)
block|,
comment|/* author */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'A'
argument_list|,
literal|'I'
argument_list|,
name|AU
argument_list|)
block|,
comment|/* authors institution */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'S'
argument_list|,
literal|'H'
argument_list|,
name|SH
argument_list|)
block|,
comment|/* section heading */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'S'
argument_list|,
literal|'N'
argument_list|,
name|SH
argument_list|)
block|,
comment|/* undocumented */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'U'
argument_list|,
literal|'X'
argument_list|,
name|UX
argument_list|)
block|,
comment|/* unix */
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'D'
argument_list|,
literal|'S'
argument_list|,
name|mssnblock
argument_list|)
block|,
comment|/* start display text */
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'K'
argument_list|,
literal|'S'
argument_list|,
name|mssnblock
argument_list|)
block|,
comment|/* start keep */
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'K'
argument_list|,
literal|'F'
argument_list|,
name|mssnblock
argument_list|)
block|,
comment|/* start float keep */
name|M
argument_list|(
argument|NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|mmmactab
index|[]
init|=
block|{
name|M
argument_list|(
name|NONE
argument_list|,
literal|'H'
argument_list|,
literal|' '
argument_list|,
name|MMHU
argument_list|)
block|,
comment|/* -mm ? */
name|M
argument_list|(
name|NONE
argument_list|,
literal|'H'
argument_list|,
literal|'U'
argument_list|,
name|MMHU
argument_list|)
block|,
comment|/* -mm ? */
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'P'
argument_list|,
literal|' '
argument_list|,
name|PP
argument_list|)
block|,
comment|/* paragraph for -mm */
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'N'
argument_list|,
literal|'S'
argument_list|,
name|mssnblock
argument_list|)
block|,
comment|/* undocumented */
name|M
argument_list|(
argument|NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|memactab
index|[]
init|=
block|{
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'p'
argument_list|,
literal|'p'
argument_list|,
name|mepp
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'l'
argument_list|,
literal|'p'
argument_list|,
name|mepp
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'n'
argument_list|,
literal|'p'
argument_list|,
name|mepp
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'i'
argument_list|,
literal|'p'
argument_list|,
name|meip
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'s'
argument_list|,
literal|'h'
argument_list|,
name|mesh
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'u'
argument_list|,
literal|'h'
argument_list|,
name|mesh
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'l'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'q'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'b'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'z'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'c'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'d'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'f'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NBLK
argument_list|,
literal|'('
argument_list|,
literal|'x'
argument_list|,
name|mesnblock
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'r'
argument_list|,
literal|' '
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'i'
argument_list|,
literal|' '
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'b'
argument_list|,
literal|' '
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'u'
argument_list|,
literal|' '
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'q'
argument_list|,
literal|' '
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'r'
argument_list|,
literal|'b'
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'b'
argument_list|,
literal|'i'
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
name|NONE
argument_list|,
literal|'b'
argument_list|,
literal|'x'
argument_list|,
name|mefont
argument_list|)
block|,
name|M
argument_list|(
argument|NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mactab
name|manmactab
index|[]
init|=
block|{
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'B'
argument_list|,
literal|'I'
argument_list|,
name|manfont
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'B'
argument_list|,
literal|'R'
argument_list|,
name|manfont
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'I'
argument_list|,
literal|'B'
argument_list|,
name|manfont
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'I'
argument_list|,
literal|'R'
argument_list|,
name|manfont
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'R'
argument_list|,
literal|'B'
argument_list|,
name|manfont
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'R'
argument_list|,
literal|'I'
argument_list|,
name|manfont
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'P'
argument_list|,
literal|'P'
argument_list|,
name|manpp
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'L'
argument_list|,
literal|'P'
argument_list|,
name|manpp
argument_list|)
block|,
name|M
argument_list|(
name|PARAG
argument_list|,
literal|'H'
argument_list|,
literal|'P'
argument_list|,
name|manpp
argument_list|)
block|,
name|M
argument_list|(
argument|NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

