begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)at.c	5.5 (Berkeley) 1/18/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  *	Synopsis:	at [-s] [-c] [-m] time [filename]  *						  *   *  *	Execute commands at a later date.  *  *  *	Modifications by:	Steve Wall  *				Computer Systems Research Group  *				University of California @ Berkeley  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|HOUR
value|100
end_define

begin_comment
comment|/* 1 hour (using military time) */
end_comment

begin_define
define|#
directive|define
name|HALFDAY
value|(12 * HOUR)
end_define

begin_comment
comment|/* half a day (12 hours) */
end_comment

begin_define
define|#
directive|define
name|FULLDAY
value|(24 * HOUR)
end_define

begin_comment
comment|/* a full day (24 hours) */
end_comment

begin_define
define|#
directive|define
name|WEEK
value|1
end_define

begin_comment
comment|/* day requested is 'week' */
end_comment

begin_define
define|#
directive|define
name|DAY
value|2
end_define

begin_comment
comment|/* day requested is a weekday */
end_comment

begin_define
define|#
directive|define
name|MONTH
value|3
end_define

begin_comment
comment|/* day requested is a month */
end_comment

begin_define
define|#
directive|define
name|BOURNE
value|"/bin/sh"
end_define

begin_comment
comment|/* run commands with Bourne shell*/
end_comment

begin_define
define|#
directive|define
name|CSHELL
value|"/bin/csh"
end_define

begin_comment
comment|/* run commands with C shell */
end_comment

begin_define
define|#
directive|define
name|NODATEFOUND
value|-1
end_define

begin_comment
comment|/* no date was given on command line */
end_comment

begin_define
define|#
directive|define
name|ATDIR
value|"/usr/spool/at"
end_define

begin_comment
comment|/* spooling area */
end_comment

begin_define
define|#
directive|define
name|LINSIZ
value|256
end_define

begin_comment
comment|/* length of input buffer */
end_comment

begin_comment
comment|/*  * A table to identify potential command line values for "time".   *  * We need this so that we can do some decent error checking on the   * command line arguments. (This was inspired by the old "at", which   * accepted "at 900 jan 55" as valid input and other small bugs.  */
end_comment

begin_struct
struct|struct
name|datetypes
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|dates_info
index|[
literal|22
index|]
init|=
block|{
block|{
name|DAY
block|,
literal|"sunday"
block|}
block|,
block|{
name|DAY
block|,
literal|"monday"
block|}
block|,
block|{
name|DAY
block|,
literal|"tuesday"
block|}
block|,
block|{
name|DAY
block|,
literal|"wednesday"
block|}
block|,
block|{
name|DAY
block|,
literal|"thursday"
block|}
block|,
block|{
name|DAY
block|,
literal|"friday"
block|}
block|,
block|{
name|DAY
block|,
literal|"saturday"
block|}
block|,
block|{
name|MONTH
block|,
literal|"january"
block|}
block|,
block|{
name|MONTH
block|,
literal|"february"
block|}
block|,
block|{
name|MONTH
block|,
literal|"march"
block|}
block|,
block|{
name|MONTH
block|,
literal|"april"
block|}
block|,
block|{
name|MONTH
block|,
literal|"may"
block|}
block|,
block|{
name|MONTH
block|,
literal|"june"
block|}
block|,
block|{
name|MONTH
block|,
literal|"july"
block|}
block|,
block|{
name|MONTH
block|,
literal|"august"
block|}
block|,
block|{
name|MONTH
block|,
literal|"september"
block|}
block|,
block|{
name|MONTH
block|,
literal|"october"
block|}
block|,
block|{
name|MONTH
block|,
literal|"november"
block|}
block|,
block|{
name|MONTH
block|,
literal|"december"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Months of the year.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|months
index|[
literal|13
index|]
init|=
block|{
literal|"jan"
block|,
literal|"feb"
block|,
literal|"mar"
block|,
literal|"apr"
block|,
literal|"may"
block|,
literal|"jun"
block|,
literal|"jul"
block|,
literal|"aug"
block|,
literal|"sep"
block|,
literal|"oct"
block|,
literal|"nov"
block|,
literal|"dec"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A table of the number of days in each month of the year.  *  *	yeartable[0] -- normal year  *	yeartable[1] -- leap year  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|yeartable
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|,
block|{
literal|0
block|,
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure holding the relevant values needed to create a spoolfile.  * "attime" will contain the info about when a job is to be run, and  * "nowtime" will contain info about what time the "at" command is in-  * voked.  */
end_comment

begin_struct
struct|struct
name|times
block|{
name|int
name|year
decl_stmt|;
comment|/* year that job is to be run */
name|int
name|yday
decl_stmt|;
comment|/* day of year that job is to be run */
name|int
name|mon
decl_stmt|;
comment|/* month of year that job is to be run*/
name|int
name|mday
decl_stmt|;
comment|/* day of month that job is to be run */
name|int
name|wday
decl_stmt|;
comment|/* day of week that job is to be run */
name|int
name|hour
decl_stmt|;
comment|/* hour of day that job is to be run */
name|int
name|min
decl_stmt|;
comment|/* min. of hour that job is to be run */
block|}
name|attime
struct|,
name|nowtime
struct|;
end_struct

begin_decl_stmt
name|char
name|atfile
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of spoolfile "yy.ddd.hhhh.??" */
end_comment

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get info on user's environment */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user's environment */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|spoolfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spool file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|inputfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file ("stdin" or "filename") */
end_comment

begin_function_decl
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* used to get current directory info */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
comment|/* scratch variable */
name|int
name|usage
parameter_list|()
function_decl|;
comment|/* print usage info and exit */
name|int
name|cleanup
parameter_list|()
function_decl|;
comment|/* do cleanup on an interrupt signal */
name|int
name|dateindex
init|=
name|NODATEFOUND
decl_stmt|;
comment|/* if a day is specified, what option 					   is it? (mon day, week, dayofweek) */
name|char
modifier|*
name|shell
init|=
name|BOURNE
decl_stmt|;
comment|/* what shell do we use to run job? */
name|int
name|shflag
init|=
literal|0
decl_stmt|;
comment|/* override the current shell and run 					   job using the Bourne Shell */
name|int
name|cshflag
init|=
literal|0
decl_stmt|;
comment|/* override the current shell and run  					   job using the Cshell */
name|int
name|mailflag
init|=
literal|0
decl_stmt|;
comment|/* send mail after a job has been run?*/
name|int
name|standardin
init|=
literal|0
decl_stmt|;
comment|/* are we reading from stardard input */
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* scratch pointer */
name|char
name|line
index|[
name|LINSIZ
index|]
decl_stmt|;
comment|/* a line from input file */
name|char
name|pwbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* the current working directory */
name|char
modifier|*
name|jobfile
init|=
literal|"stdin"
decl_stmt|;
comment|/* file containing job to be run */
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
comment|/* get the login name of a user */
name|int
name|pid
decl_stmt|;
comment|/* For forking for security reasons */
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
comment|/* 	 * Interpret command line flags if they exist. 	 */
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|argv
condition|)
switch|switch
condition|(
operator|*
operator|(
operator|*
name|argv
operator|)
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
name|cshflag
operator|++
expr_stmt|;
name|shell
operator|=
name|CSHELL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|shflag
operator|++
expr_stmt|;
name|shell
operator|=
name|BOURNE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mailflag
operator|++
expr_stmt|;
break|break;
default|default	 :
name|usage
argument_list|()
expr_stmt|;
block|}
operator|--
name|argc
operator|,
operator|++
name|argv
expr_stmt|;
block|}
if|if
condition|(
name|shflag
operator|&&
name|cshflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ambiguous shell request.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the time it is when "at" is invoked. We set both nowtime and  	 * attime to this value so that as we interpret the time the job is to 	 * be run we can compare the two values to determine such things as 	 * whether of not the job should be run the same day the "at" command 	 * is given, whether a job is to be run next year, etc. 	 */
name|getnowtime
argument_list|(
operator|&
name|nowtime
argument_list|,
operator|&
name|attime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printit
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* 	 * Interpret argv[1] and create the time of day that the job is to 	 * be run. This is the same function that was used in the old "at" 	 */
name|maketime
argument_list|(
operator|&
name|attime
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\n\nAFTER MAKETIME\n"
argument_list|)
expr_stmt|;
name|printit
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If argv[(2)] exists, this is a request to run a job on a certain 	 * day of year or a certain day of week. 	 * 	 * We send  argv to the function "getdateindex" which returns the  	 * index value of the requested day in the table "dates_info"  	 * (see line 50 for table). If 'getdateindex" returns a NODATEFOUND,  	 * then the requested day format was not found in the table (usually  	 * this means that the argument is a "filename"). If the requested  	 * day is found, we continue to process command line arguments. 	 */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dateindex
operator|=
name|getdateindex
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|!=
name|NODATEFOUND
condition|)
block|{
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
comment|/* 			 * Determine the day of year that the job will be run 			 * depending on the value of argv. 			 */
name|makedayofyear
argument_list|(
name|dateindex
argument_list|,
operator|&
name|argv
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we get to this point and "dateindex" is set to NODATEFOUND, 	 * then we are dealing with a request with only a "time" specified 	 * (i.e. at 400p) and perhaps 'week' specified (i.e. at 400p week). 	 * If 'week' is specified, we just set excecution for 7 days in the 	 * future. Otherwise, we need to check to see if the requested time  	 * has already passed for the current day. If it has, then we add  	 * one to the day of year that the job will be executed. 	 */
if|if
condition|(
name|dateindex
operator|==
name|NODATEFOUND
condition|)
block|{
name|int
name|daysinyear
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"week"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|attime
operator|.
name|yday
operator|+=
literal|7
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istomorrow
argument_list|()
condition|)
operator|++
name|attime
operator|.
name|yday
expr_stmt|;
name|daysinyear
operator|=
name|isleap
argument_list|(
name|attime
operator|.
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
if|if
condition|(
name|attime
operator|.
name|yday
operator|>=
name|daysinyear
condition|)
block|{
name|attime
operator|.
name|yday
operator|-=
name|daysinyear
expr_stmt|;
operator|++
name|attime
operator|.
name|year
expr_stmt|;
block|}
block|}
comment|/* 	 * If no more arguments exist, then we are reading 	 * from standard input. Thus, we set the standard 	 * input flag (++standardin). 	 */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
operator|++
name|standardin
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\n\nAFTER ADDDAYS\n"
argument_list|)
expr_stmt|;
name|printit
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Start off assuming we're going to read from standard input, 	 * but if a filename has been given to read from, we will open it 	 * later. 	 */
name|inputfile
operator|=
name|stdin
expr_stmt|;
comment|/* 	 * Create the filename for the spoolfile. 	 */
name|makeatfile
argument_list|(
name|atfile
argument_list|,
name|attime
operator|.
name|year
argument_list|,
name|attime
operator|.
name|yday
argument_list|,
name|attime
operator|.
name|hour
argument_list|,
name|attime
operator|.
name|min
argument_list|)
expr_stmt|;
comment|/* 	 * Open the spoolfile for writing. 	 */
if|if
condition|(
operator|(
name|spoolfile
operator|=
name|fopen
argument_list|(
name|atfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|atfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make the file not world readable. 	 */
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|spoolfile
argument_list|)
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
comment|/* 	 * The protection mechanism works like this: 	 * We are running ruid=user, euid=spool owner.  So far we have been 	 * messing around in the spool directory, so we needed to run 	 * as the owner of the spool directory. 	 * We now need to switch to the user's effective uid 	 * to simplify permission checking.  However, we fork first, 	 * so that we can clean up if interrupted. 	 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
condition|)
block|{
name|int
name|wpid
decl_stmt|,
name|status
decl_stmt|;
comment|/* 		 * We are the parent. If the kid has problems, 		 * cleanup the spool directory. 		 */
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpid
operator|!=
name|pid
operator|||
name|status
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The kid should have alread flushed the buffers. 		 */
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Exit on interrupt. 	 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* 	 * We are the kid, give up special permissions. 	 */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * Open the input file with the user's permissions. 	 */
if|if
condition|(
operator|!
name|standardin
condition|)
block|{
name|jobfile
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|inputfile
operator|=
name|fopen
argument_list|(
name|jobfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|jobfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Determine what shell we should use to run the job. If the user 	 * didn't explicitly request that his/her current shell be over- 	 * ridden (shflag of cshflag) then we use the current shell. 	 */
if|if
condition|(
operator|(
operator|!
name|shflag
operator|)
operator|&&
operator|(
operator|!
name|cshflag
operator|)
operator|&&
operator|(
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|shell
operator|=
literal|"$SHELL"
expr_stmt|;
comment|/* 	 * Put some standard information at the top of the spoolfile. 	 * This info is used by the other "at"-oriented programs (atq, 	 * atrm, atrun). 	 */
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"# owner: %.127s\n"
argument_list|,
name|getname
argument_list|(
name|getuid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"# jobname: %.127s\n"
argument_list|,
name|jobfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"# shell: sh\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"# notify by mail: %s\n"
argument_list|,
operator|(
name|mailflag
operator|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the modes for any files created by the job being run. 	 */
name|c
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"umask %.1o\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Get the current working directory so we know what directory to  	 * run the job from. 	 */
if|if
condition|(
name|getwd
argument_list|(
name|pwbuf
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"at: can't get working directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"cd %s\n"
argument_list|,
name|pwbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the user's environment to the spoolfile. 	 */
if|if
condition|(
name|environ
condition|)
block|{
name|copyenvironment
argument_list|(
operator|&
name|spoolfile
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put in a line to run the proper shell using the rest of 	 * the file as input.  Note that 'exec'ing the shell will 	 * cause sh() to leave a /tmp/sh### file around.  This line 	 * depends on the shells allowing EOF to end tagged input.  The 	 * quotes also guarantee a quoting of the lines before EOF. 	 */
name|fprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"%s<< 'QAZWSXEDCRFVTGBYHNUJMIKOLP'\n"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have all the files set up, we can start reading in 	 * the job. 	 */
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LINSIZ
argument_list|,
name|inputfile
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|line
argument_list|,
name|spoolfile
argument_list|)
expr_stmt|;
comment|/* 	 * Close all files and change the mode of the spoolfile. 	 */
name|fclose
argument_list|(
name|inputfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|spoolfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy the user's environment to the spoolfile in the syntax of the  * Bourne shell.  After the environment is set up, the proper shell  * will be invoked.  */
end_comment

begin_macro
name|copyenvironment
argument_list|(
argument|spoolfile
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|spoolfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* scratch pointer */
name|char
modifier|*
modifier|*
name|environptr
init|=
name|environ
decl_stmt|;
comment|/* pointer to an environment setting */
while|while
condition|(
operator|*
name|environptr
condition|)
block|{
name|tmp
operator|=
operator|*
name|environptr
expr_stmt|;
comment|/* 		 * We don't want the termcap or terminal entry so skip them. 		 */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|tmp
argument_list|,
literal|"TERM="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|tmp
argument_list|,
literal|"TERMCAP="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|++
name|environptr
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Set up the proper syntax. 		 */
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|'='
condition|)
name|fputc
argument_list|(
operator|*
name|tmp
operator|++
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'='
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
operator|++
name|tmp
expr_stmt|;
comment|/* 		 * Now copy the entry. 		 */
while|while
condition|(
operator|*
name|tmp
condition|)
block|{
if|if
condition|(
operator|*
name|tmp
operator|==
literal|'\''
condition|)
name|fputs
argument_list|(
literal|"'\\''"
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tmp
operator|==
literal|'\n'
condition|)
name|fputs
argument_list|(
literal|"\\"
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
operator|*
name|tmp
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
operator|++
name|tmp
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\''
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
comment|/* 		 * We need to "export" environment settings. 		 */
name|fprintf
argument_list|(
operator|*
name|spoolfile
argument_list|,
literal|"\nexport "
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|*
name|environptr
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|'='
condition|)
name|fputc
argument_list|(
operator|*
name|tmp
operator|++
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
operator|*
name|spoolfile
argument_list|)
expr_stmt|;
operator|++
name|environptr
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * Create the filename for the spoolfile. The format is "yy.ddd.mmmm.??"  * where "yy" is the year the job will be run, "ddd" the day of year,   * "mmmm" the hour and minute, and "??" a scratch value used to dis-  * tinguish between two files that are to be run at the same time.  */
end_comment

begin_macro
name|makeatfile
argument_list|(
argument|atfile
argument_list|,
argument|year
argument_list|,
argument|dayofyear
argument_list|,
argument|hour
argument_list|,
argument|minute
argument_list|)
end_macro

begin_decl_stmt
name|int
name|year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hour
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minute
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dayofyear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|atfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* scratch variable */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|+=
literal|53
control|)
block|{
name|sprintf
argument_list|(
name|atfile
argument_list|,
literal|"%s/%02d.%03d.%02d%02d.%02d"
argument_list|,
name|ATDIR
argument_list|,
name|year
argument_list|,
name|dayofyear
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
operator|(
name|getpid
argument_list|()
operator|+
name|i
operator|)
operator|%
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure that the file name that we've created is unique. 		 */
if|if
condition|(
name|access
argument_list|(
name|atfile
argument_list|,
name|F_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Has the requested time already passed for the currrent day? If so, we  * will run the job "tomorrow".  */
end_comment

begin_macro
name|istomorrow
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|attime
operator|.
name|hour
operator|<
name|nowtime
operator|.
name|hour
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|attime
operator|.
name|hour
operator|==
name|nowtime
operator|.
name|hour
operator|)
operator|&&
operator|(
name|attime
operator|.
name|min
operator|<
name|nowtime
operator|.
name|min
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Debugging wreckage.  */
end_comment

begin_macro
name|printit
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"YEAR\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|year
argument_list|,
name|attime
operator|.
name|year
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"YDAY\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|yday
argument_list|,
name|attime
operator|.
name|yday
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MON\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|mon
argument_list|,
name|attime
operator|.
name|mon
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MONDAY\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|mday
argument_list|,
name|attime
operator|.
name|mday
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WDAY\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|wday
argument_list|,
name|attime
operator|.
name|wday
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"HOUR\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|hour
argument_list|,
name|attime
operator|.
name|hour
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MIN\tnowtime: %d\tattime: %d\n"
argument_list|,
name|nowtime
operator|.
name|min
argument_list|,
name|attime
operator|.
name|min
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Calculate the day of year that the job will be executed.  * The av,ac arguments are ptrs to argv,argc; updated as necessary.  */
end_comment

begin_macro
name|makedayofyear
argument_list|(
argument|dateindex
argument_list|,
argument|av
argument_list|,
argument|ac
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dateindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ac
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|argv
init|=
operator|*
name|av
decl_stmt|;
comment|/* imitate argc,argv and update args at end */
name|int
name|argc
init|=
operator|*
name|ac
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* scratch pointer */
name|struct
name|datetypes
modifier|*
name|daterequested
decl_stmt|;
comment|/* pointer to information about 						   the type of date option 						   we're dealing with */
name|daterequested
operator|=
operator|&
name|dates_info
index|[
name|dateindex
index|]
expr_stmt|;
comment|/* 	 * If we're dealing with a day of week, determine the number of days 	 * in the future the next day of this type will fall on. Add this 	 * value to "attime.yday". 	 */
if|if
condition|(
name|daterequested
operator|->
name|type
operator|==
name|DAY
condition|)
block|{
if|if
condition|(
name|attime
operator|.
name|wday
operator|<
name|dateindex
condition|)
name|attime
operator|.
name|yday
operator|+=
name|dateindex
operator|-
name|attime
operator|.
name|wday
expr_stmt|;
elseif|else
if|if
condition|(
name|attime
operator|.
name|wday
operator|>
name|dateindex
condition|)
name|attime
operator|.
name|yday
operator|+=
operator|(
literal|7
operator|-
name|attime
operator|.
name|wday
operator|)
operator|+
name|dateindex
expr_stmt|;
else|else
name|attime
operator|.
name|yday
operator|+=
literal|7
expr_stmt|;
block|}
comment|/* 	 * If we're dealing with a month and day of month, determine the 	 * day of year that this date will fall on. 	 */
if|if
condition|(
name|daterequested
operator|->
name|type
operator|==
name|MONTH
condition|)
block|{
comment|/* 		 * If a day of month isn't specified, print a message 		 * and exit. 		 */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"day of month not specified.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Scan the day of month value and make sure that it 		 * has no characters in it. If characters are found or 		 * the day requested is zero, print a message and exit. 		 */
name|ptr
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\": illegal day of month\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set the month of year and day of month values. Since 		 * the first 7 values in our dateinfo table do not deal 		 * with month names, we subtract 7 from the month of year 		 * value. 		 */
name|attime
operator|.
name|mon
operator|=
operator|(
name|dateindex
operator|-
literal|7
operator|)
expr_stmt|;
name|attime
operator|.
name|mday
operator|=
operator|(
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 		 * Test the day of month value to make sure that the 		 * value is legal. 		 */
if|if
condition|(
operator|(
name|attime
operator|.
name|mday
operator|+
literal|1
operator|)
operator|>
name|yeartable
index|[
name|isleap
argument_list|(
name|attime
operator|.
name|year
argument_list|)
index|]
index|[
name|attime
operator|.
name|mon
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\": illegal day of month\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Finally, we determine the day of year. 		 */
name|attime
operator|.
name|yday
operator|=
operator|(
name|countdays
argument_list|()
operator|)
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
comment|/* 	 * If 'week' is specified, add 7 to the day of year. 	 */
if|if
condition|(
operator|(
name|argc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"week"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|attime
operator|.
name|yday
operator|+=
literal|7
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
comment|/* 	 * Now that all that is done, see if the requested execution time 	 * has already passed for this year, and if it has, set execution 	 * for next year. 	 */
if|if
condition|(
name|isnextyear
argument_list|()
condition|)
operator|++
name|attime
operator|.
name|year
expr_stmt|;
comment|/* 	 * Finally, reflect the updated argc,argv to the caller 	 */
operator|*
name|av
operator|=
name|argv
expr_stmt|;
operator|*
name|ac
operator|=
name|argc
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Should the job be run next year? We check for the following situations:  *  *	1) the requested time has already passed for the current year.   *	2) the day of year is greater than the number of days in the year.   *  * If either of these tests succeed, we increment "attime.year" by 1.   * If #2 is true, we also subtract the number of days in the current year  * from "attime.yday". #2 can only occur if someone specifies a job to  * be run "tomorrow" on Dec. 31 or if they specify a job to be run a  * 'week' later and the date is at least Dec. 24. (I think so anyway)  */
end_comment

begin_macro
name|isnextyear
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|daysinyear
expr_stmt|;
if|if
condition|(
name|attime
operator|.
name|yday
operator|<
name|nowtime
operator|.
name|yday
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|attime
operator|.
name|yday
operator|==
name|nowtime
operator|.
name|yday
operator|)
operator|&&
operator|(
name|attime
operator|.
name|hour
operator|<
name|nowtime
operator|.
name|hour
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|daysinyear
operator|=
name|isleap
argument_list|(
name|attime
operator|.
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
if|if
condition|(
name|attime
operator|.
name|yday
operator|>=
name|daysinyear
condition|)
block|{
name|attime
operator|.
name|yday
operator|-=
name|daysinyear
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|attime
operator|.
name|yday
operator|>
operator|(
name|isleap
argument_list|(
name|attime
operator|.
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
operator|)
condition|)
block|{
name|attime
operator|.
name|yday
operator|-=
operator|(
name|isleap
argument_list|(
name|attime
operator|.
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Determine the day of year given a month and day of month value.  */
end_comment

begin_macro
name|countdays
argument_list|()
end_macro

begin_block
block|{
name|int
name|leap
decl_stmt|;
comment|/* are we dealing with a leap year? */
name|int
name|dayofyear
decl_stmt|;
comment|/* the day of year after conversion */
name|int
name|monthofyear
decl_stmt|;
comment|/* the month of year that we are 					   dealing with */
comment|/* 	 * Are we dealing with a leap year? 	 */
name|leap
operator|=
name|isleap
argument_list|(
name|attime
operator|.
name|year
argument_list|)
expr_stmt|;
name|monthofyear
operator|=
name|attime
operator|.
name|mon
expr_stmt|;
name|dayofyear
operator|=
name|attime
operator|.
name|mday
expr_stmt|;
comment|/* 	 * Determine the day of year. 	 */
while|while
condition|(
name|monthofyear
operator|>
literal|0
condition|)
name|dayofyear
operator|+=
name|yeartable
index|[
name|leap
index|]
index|[
name|monthofyear
operator|--
index|]
expr_stmt|;
return|return
operator|(
name|dayofyear
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Is a year a leap year?  */
end_comment

begin_macro
name|isleap
argument_list|(
argument|year
argument_list|)
end_macro

begin_decl_stmt
name|int
name|year
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|year
operator|%
literal|4
operator|==
literal|0
operator|&&
name|year
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
name|year
operator|%
literal|100
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getdateindex
argument_list|(
argument|date
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|date
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|datetypes
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|dates_info
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|dates_info
init|;
name|ptr
operator|->
name|type
operator|!=
literal|0
condition|;
name|ptr
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isprefix
argument_list|(
name|date
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
name|NODATEFOUND
operator|)
return|;
block|}
end_block

begin_macro
name|isprefix
argument_list|(
argument|prefix
argument_list|,
argument|fullname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|fullname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|ptr1
decl_stmt|;
name|ptr
operator|=
name|prefix
expr_stmt|;
name|ptr1
operator|=
name|fullname
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
name|ch
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
operator|*
name|ptr1
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|ptr
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getnowtime
argument_list|(
argument|nowtime
argument_list|,
argument|attime
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|times
modifier|*
name|nowtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|times
modifier|*
name|attime
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tm
modifier|*
name|now
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|struct
name|timezone
name|zone
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|zone
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|now
operator|=
name|localtime
argument_list|(
operator|&
name|time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|attime
operator|->
name|year
operator|=
name|nowtime
operator|->
name|year
operator|=
name|now
operator|->
name|tm_year
expr_stmt|;
name|attime
operator|->
name|yday
operator|=
name|nowtime
operator|->
name|yday
operator|=
name|now
operator|->
name|tm_yday
expr_stmt|;
name|attime
operator|->
name|mon
operator|=
name|nowtime
operator|->
name|mon
operator|=
name|now
operator|->
name|tm_mon
expr_stmt|;
name|attime
operator|->
name|mday
operator|=
name|nowtime
operator|->
name|mday
operator|=
name|now
operator|->
name|tm_mday
expr_stmt|;
name|attime
operator|->
name|wday
operator|=
name|nowtime
operator|->
name|wday
operator|=
name|now
operator|->
name|tm_wday
expr_stmt|;
name|attime
operator|->
name|hour
operator|=
name|nowtime
operator|->
name|hour
operator|=
name|now
operator|->
name|tm_hour
expr_stmt|;
name|attime
operator|->
name|min
operator|=
name|nowtime
operator|->
name|min
operator|=
name|now
operator|->
name|tm_min
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This is the same routine used in the old "at", so I won't bother  * commenting it. It'll give you an idea of what the code looked  * like when I got it.  */
end_comment

begin_macro
name|maketime
argument_list|(
argument|attime
argument_list|,
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|times
modifier|*
name|attime
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|-
name|ptr
operator|<
literal|3
condition|)
name|val
operator|*=
name|HOUR
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|':'
case|:
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|val
operator|+=
operator|(
literal|10
operator|*
operator|*
name|p
operator|+
name|p
index|[
literal|1
index|]
operator|-
literal|11
operator|*
literal|'0'
operator|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad time format:\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|val
operator|>=
name|HALFDAY
operator|+
name|HOUR
condition|)
name|val
operator|=
name|FULLDAY
operator|+
literal|1
expr_stmt|;
comment|/* illegal */
if|if
condition|(
name|val
operator|>=
name|HALFDAY
operator|&&
name|val
operator|<
operator|(
name|HALFDAY
operator|+
name|HOUR
operator|)
condition|)
name|val
operator|-=
name|HALFDAY
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
name|val
operator|>=
name|HALFDAY
operator|+
name|HOUR
condition|)
name|val
operator|=
name|FULLDAY
operator|+
literal|1
expr_stmt|;
comment|/* illegal */
if|if
condition|(
name|val
operator|<
name|HALFDAY
condition|)
name|val
operator|+=
name|HALFDAY
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|)
operator|||
operator|(
name|val
operator|==
name|HALFDAY
operator|)
condition|)
name|val
operator|=
name|HALFDAY
expr_stmt|;
else|else
name|val
operator|=
name|FULLDAY
operator|+
literal|1
expr_stmt|;
comment|/* illegal */
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|)
operator|||
operator|(
name|val
operator|==
name|HALFDAY
operator|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
else|else
name|val
operator|=
name|FULLDAY
operator|+
literal|1
expr_stmt|;
comment|/* illegal */
break|break;
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
comment|/* 24 hour time */
if|if
condition|(
name|val
operator|==
name|FULLDAY
condition|)
name|val
operator|-=
name|FULLDAY
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad time format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>=
name|FULLDAY
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"time out of range\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|%
name|HOUR
operator|>=
literal|60
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"illegal minute field\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|attime
operator|->
name|hour
operator|=
name|val
operator|/
name|HOUR
expr_stmt|;
name|attime
operator|->
name|min
operator|=
name|val
operator|%
name|HOUR
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the full login name of a person using his/her user id.  */
end_comment

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|uid
parameter_list|)
name|int
name|uid
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwdinfo
decl_stmt|;
comment|/* password info structure */
name|char
modifier|*
name|logname
decl_stmt|,
modifier|*
name|getlogin
argument_list|()
decl_stmt|;
name|logname
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|logname
operator|==
name|NULL
operator|||
operator|(
name|pwdinfo
operator|=
name|getpwnam
argument_list|(
name|logname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|pwdinfo
operator|->
name|pw_uid
operator|!=
name|uid
condition|)
name|pwdinfo
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwdinfo
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no name for uid %d?\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pwdinfo
operator|->
name|pw_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do general cleanup.  */
end_comment

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|unlink
argument_list|(
name|atfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|atfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print usage info and exit.  */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: at [-csm] time [date] [filename]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

