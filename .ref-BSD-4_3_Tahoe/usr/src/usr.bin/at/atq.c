begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)atq.c	5.1 (Berkeley) 6/6/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  *  *	Synopsis:  atq [ -c ] [ -n ] [ name ... ]  *  *  *	Print the queue of files waiting to be executed. These files   *	were created by using the "at" command and are located in the   *	directory "/usr/spool/at".  *  *  *	Author: Steve Wall  *		Computer Systems Research Group  *		University of California @ Berkeley  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|ATDIR
value|"/usr/spool/at"
end_define

begin_comment
comment|/* spooling area */
end_comment

begin_define
define|#
directive|define
name|LASTFILE
value|"/usr/spool/at/lasttimedone"
end_define

begin_comment
comment|/* update time record  							   file */
end_comment

begin_comment
comment|/*  * Months of the year  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mthnames
index|[
literal|12
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numentries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries in spooling area */
end_comment

begin_decl_stmt
name|int
name|namewanted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only print jobs belonging to a  					   certain person */
end_comment

begin_decl_stmt
name|struct
name|direct
modifier|*
modifier|*
name|queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the queue itself */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|cflag
init|=
literal|0
decl_stmt|;
comment|/* print in order of creation time */
name|int
name|nflag
init|=
literal|0
decl_stmt|;
comment|/* just print the number of jobs in  					   queue */
name|int
name|usage
parameter_list|()
function_decl|;
comment|/* print usage info and exit */
name|int
name|creation
parameter_list|()
function_decl|;
comment|/* sort jobs by date of creation */
name|int
name|alphasort
parameter_list|()
function_decl|;
comment|/* sort jobs by date of execution */
name|int
name|filewanted
parameter_list|()
function_decl|;
comment|/* should a file be included in queue?*/
name|int
name|printqueue
parameter_list|()
function_decl|;
comment|/* print the queue */
name|int
name|countfiles
parameter_list|()
function_decl|;
comment|/* count the number of files in queue 					   for a given person */
name|char
modifier|*
modifier|*
name|namelist
decl_stmt|;
comment|/* array of specific name(s) requested*/
operator|--
name|argc
operator|,
operator|++
name|argv
expr_stmt|;
comment|/* 	 * Interpret command line flags if they exist. 	 */
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|argv
condition|)
switch|switch
condition|(
operator|*
operator|(
operator|*
name|argv
operator|)
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
name|cflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
break|break;
default|default	 :
name|usage
argument_list|()
expr_stmt|;
block|}
operator|--
name|argc
operator|,
operator|++
name|argv
expr_stmt|;
block|}
comment|/* 	 * If a certain name (or names) is requested, set a pointer to the 	 * beginning of the list. 	 */
if|if
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
operator|++
name|namewanted
expr_stmt|;
name|namelist
operator|=
name|argv
expr_stmt|;
block|}
comment|/* 	 * Move to the spooling area and scan the directory, placing the 	 * files in the queue structure. The queue comes back sorted by 	 * execution time or creation time. 	 */
if|if
condition|(
name|chdir
argument_list|(
name|ATDIR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ATDIR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|numentries
operator|=
name|scandir
argument_list|(
literal|"."
argument_list|,
operator|&
name|queue
argument_list|,
name|filewanted
argument_list|,
operator|(
name|cflag
operator|)
condition|?
name|creation
else|:
name|alphasort
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|ATDIR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Either print a message stating: 	 * 	 *	1) that the spooling area is empty. 	 *	2) the number of jobs in the spooling area. 	 *	3) the number of jobs in the spooling area belonging to  	 *	   a certain person. 	 *	4) that the person requested doesn't have any files in the 	 *	   spooling area. 	 * 	 * or send the queue off to "printqueue" for printing. 	 * 	 * This whole process might seem a bit elaborate, but it's worthwhile 	 * to print some informative messages for the user. 	 * 	 */
if|if
condition|(
operator|(
name|numentries
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|nflag
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"no files in queue.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nflag
condition|)
block|{
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
operator|(
name|namewanted
operator|)
condition|?
name|countfiles
argument_list|(
name|namelist
argument_list|)
else|:
name|numentries
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|namewanted
operator|)
operator|&&
operator|(
name|countfiles
argument_list|(
name|namelist
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"no files for %s.\n"
argument_list|,
operator|(
name|argc
operator|==
literal|1
operator|)
condition|?
operator|*
name|argv
else|:
literal|"specified users"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|printqueue
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Count the number of jobs in the spooling area owned by a certain person(s).  */
end_comment

begin_macro
name|countfiles
argument_list|(
argument|namelist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|namelist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* for loop index */
name|int
name|entryfound
decl_stmt|;
comment|/* found file owned by user(s)*/
name|int
name|numfiles
init|=
literal|0
decl_stmt|;
comment|/* number of files owned by a 						   certain person(s) */
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
comment|/* scratch pointer */
comment|/* 	 * For each file in the queue, see if the user(s) own the file. We 	 * have to use "entryfound" (rather than simply incrementing "numfiles") 	 * so that if a person's name appears twice on the command line we  	 * don't double the number of files owned by him/her. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numentries
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|namelist
expr_stmt|;
name|entryfound
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
name|isowner
argument_list|(
operator|*
name|ptr
argument_list|,
name|queue
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
condition|)
operator|++
name|entryfound
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|entryfound
condition|)
operator|++
name|numfiles
expr_stmt|;
block|}
return|return
operator|(
name|numfiles
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the queue. If only jobs belonging to a certain person(s) are requested,  * only print jobs that belong to that person(s).  */
end_comment

begin_macro
name|printqueue
argument_list|(
argument|namelist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|namelist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* for loop index */
name|int
name|rank
init|=
literal|1
decl_stmt|;
comment|/* rank of a job */
name|int
name|entryfound
decl_stmt|;
comment|/* found file owned by user(s)*/
name|int
name|printrank
parameter_list|()
function_decl|;
comment|/* print the rank of a job */
name|int
name|plastrun
parameter_list|()
function_decl|;
comment|/* print the last time the  						   spooling area was updated */
name|int
name|powner
parameter_list|()
function_decl|;
comment|/* print the name of the owner 						   of the job */
name|int
name|getid
parameter_list|()
function_decl|;
comment|/* get uid of a person */
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
comment|/* scratch pointer */
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* buffer for file stats */
comment|/* 	 * Print the time the spooling area was last modified and the header 	 * for the queue. 	 */
name|plastrun
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" Rank	  Execution Date     Owner     Job #   Job Name\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Print the queue. If a certain name(s) was requested, print only jobs 	 * belonging to that person(s), otherwise print the entire queue. 	 * Once again, we have to use "entryfound" (rather than simply  	 * comparing each command line argument) so that if a person's name  	 * appears twice we don't print each file owned by him/her twice. 	 * 	 * 	 * "printrank", "printdate", and "printjobname" all take existing  	 * data and display it in a friendly manner. 	 * 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|stat
argument_list|(
name|queue
index|[
name|i
index|]
operator|->
name|d_name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|namewanted
condition|)
block|{
name|ptr
operator|=
name|namelist
expr_stmt|;
name|entryfound
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
name|isowner
argument_list|(
operator|*
name|ptr
argument_list|,
name|queue
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
condition|)
operator|++
name|entryfound
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entryfound
condition|)
continue|continue;
block|}
name|printrank
argument_list|(
name|rank
operator|++
argument_list|)
expr_stmt|;
name|printdate
argument_list|(
name|queue
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|powner
argument_list|(
name|queue
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|stbuf
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|printjobname
argument_list|(
name|queue
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
operator|++
name|ptr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * See if "name" owns "job".  */
end_comment

begin_macro
name|isowner
argument_list|(
argument|name
argument_list|,
argument|job
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|job
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
comment|/* buffer for 1st line of spoolfile  					   header */
name|FILE
modifier|*
name|infile
decl_stmt|;
comment|/* I/O stream to spoolfile */
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|job
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't open spoolfile"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"# owner: %s\n"
argument_list|,
name|buf
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the owner of the job. This is stored on the first line of the  * spoolfile. If we run into trouble getting the name, we'll just print "???".  */
end_comment

begin_macro
name|powner
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|owner
index|[
literal|80
index|]
decl_stmt|;
comment|/* the owner */
name|FILE
modifier|*
name|infile
decl_stmt|;
comment|/* I/O stream to spoolfile */
comment|/* 	 * Open the job file and grab the first line. 	 */
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%-10.9s"
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"# owner: %s"
argument_list|,
name|owner
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%-10.9s"
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-10.9s"
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the uid of a person using his/her login name. Return -1 if no  * such account name exists.  */
end_comment

begin_macro
name|getid
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|pwdinfo
decl_stmt|;
comment|/* password info structure */
if|if
condition|(
operator|(
name|pwdinfo
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|pwdinfo
operator|->
name|pw_uid
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the time the spooling area was updated.  */
end_comment

begin_macro
name|plastrun
argument_list|()
end_macro

begin_block
block|{
name|struct
name|timeval
name|now
decl_stmt|;
comment|/* time it is right now */
name|struct
name|timezone
name|zone
decl_stmt|;
comment|/* NOT USED */
name|struct
name|tm
modifier|*
name|loc
decl_stmt|;
comment|/* detail of time it is right */
name|u_long
name|lasttime
decl_stmt|;
comment|/* last update time in seconds 						   since 1/1/70 */
name|FILE
modifier|*
name|last
decl_stmt|;
comment|/* file where last update hour 						   is stored */
comment|/* 	 * Open the file where the last update time is stored, and grab the 	 * last update hour. The update time is measured in seconds since 	 * 1/1/70. 	 */
if|if
condition|(
operator|(
name|last
operator|=
name|fopen
argument_list|(
name|LASTFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|LASTFILE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fscanf
argument_list|(
name|last
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|u_long
operator|)
operator|&
name|lasttime
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* 	 * Get a broken down representation of the last update time. 	 */
name|loc
operator|=
name|localtime
argument_list|(
operator|&
name|lasttime
argument_list|)
expr_stmt|;
comment|/* 	 * Print the time that the spooling area was last updated. 	 */
name|printf
argument_list|(
literal|"\n LAST EXECUTION TIME: %s "
argument_list|,
name|mthnames
index|[
name|loc
operator|->
name|tm_mon
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d, 19%d "
argument_list|,
name|loc
operator|->
name|tm_mday
argument_list|,
name|loc
operator|->
name|tm_year
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"at %d:%02d\n\n"
argument_list|,
name|loc
operator|->
name|tm_hour
argument_list|,
name|loc
operator|->
name|tm_min
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the rank of a job. (I've got to admit it, I stole it from "lpq")  */
end_comment

begin_expr_stmt
specifier|static
name|printrank
argument_list|(
argument|n
argument_list|)
block|{
specifier|static
name|char
operator|*
name|r
index|[]
operator|=
block|{
literal|"th"
block|,
literal|"st"
block|,
literal|"nd"
block|,
literal|"rd"
block|,
literal|"th"
block|,
literal|"th"
block|,
literal|"th"
block|,
literal|"th"
block|,
literal|"th"
block|,
literal|"th"
block|}
block|;
if|if
condition|(
operator|(
name|n
operator|/
literal|10
operator|)
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"%3d%-5s"
argument_list|,
name|n
argument_list|,
literal|"th"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%3d%-5s"
argument_list|,
name|n
argument_list|,
name|r
index|[
name|n
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Print the date that a job is to be executed. This takes some manipulation   * of the file name.  */
end_comment

begin_macro
name|printdate
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|yday
init|=
literal|0
decl_stmt|;
comment|/* day of year file will be  						   executed */
name|int
name|min
init|=
literal|0
decl_stmt|;
comment|/* min. file will be executed */
name|int
name|hour
init|=
literal|0
decl_stmt|;
comment|/* hour file will be executed */
name|int
name|day
init|=
literal|0
decl_stmt|;
comment|/* day file will be executed */
name|int
name|month
init|=
literal|0
decl_stmt|;
comment|/* month file will be executed*/
name|int
name|year
init|=
literal|0
decl_stmt|;
comment|/* year file will be executed */
name|int
name|get_mth_day
parameter_list|()
function_decl|;
comment|/* convert a day of year to a 						   month and day of month */
name|char
name|date
index|[
literal|18
index|]
decl_stmt|;
comment|/* reformatted execution date */
comment|/* 	 * Pick off the necessary info from the file name and convert the day 	 * of year to a month and day of month. 	 */
name|sscanf
argument_list|(
name|filename
argument_list|,
literal|"%2d.%3d.%2d%2d"
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|yday
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|min
argument_list|)
expr_stmt|;
name|get_mth_day
argument_list|(
name|year
argument_list|,
name|yday
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
comment|/* 	 * Format the execution date of a job. 	 */
name|sprintf
argument_list|(
name|date
argument_list|,
literal|"%3s %2d, 19%2d %02d:%02d"
argument_list|,
name|mthnames
index|[
name|month
index|]
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|hour
argument_list|,
name|min
argument_list|)
expr_stmt|;
comment|/* 	 * Print the date the job will be executed. 	 */
name|printf
argument_list|(
literal|"%-21.18s"
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Given a day of the year, calculate the month and day of month.  */
end_comment

begin_macro
name|get_mth_day
argument_list|(
argument|year
argument_list|,
argument|dayofyear
argument_list|,
argument|month
argument_list|,
argument|day
argument_list|)
end_macro

begin_decl_stmt
name|int
name|year
decl_stmt|,
name|dayofyear
decl_stmt|,
modifier|*
name|month
decl_stmt|,
modifier|*
name|day
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* for loop index */
name|int
name|leap
decl_stmt|;
comment|/* are we dealing with a leap 						   year? */
comment|/* Table of the number of days  						   in each month of the year.  						     dofy_tab[1] -- regular year 						     dofy_tab[2] -- leap year  									      */
specifier|static
name|int
name|dofy_tab
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|,
block|{
literal|0
block|,
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|, 	}
decl_stmt|;
comment|/* 	 * Are we dealing with a leap year? 	 */
name|leap
operator|=
operator|(
operator|(
name|year
operator|%
literal|4
operator|==
literal|0
operator|&&
name|year
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
name|year
operator|%
literal|100
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Calculate the month of the year and day of the month. 	 */
while|while
condition|(
name|dayofyear
operator|>=
name|dofy_tab
index|[
name|leap
index|]
index|[
name|i
index|]
condition|)
block|{
name|dayofyear
operator|-=
name|dofy_tab
index|[
name|leap
index|]
index|[
name|i
operator|++
index|]
expr_stmt|;
operator|++
operator|(
operator|*
name|month
operator|)
expr_stmt|;
block|}
operator|*
name|day
operator|=
operator|(
name|dayofyear
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print a job name. If the old "at" has been used to create the spoolfile,  * the three line header that the new version of "at" puts in the spoolfile.  * Thus, we just print "???".  */
end_comment

begin_macro
name|printjobname
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* scratch pointer */
name|char
name|jobname
index|[
literal|80
index|]
decl_stmt|;
comment|/* the job name */
name|FILE
modifier|*
name|filename
decl_stmt|;
comment|/* job file in spooling area */
comment|/* 	 * Open the job file and grab the second line. 	 */
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filename
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%.27s\n"
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We'll yank the first line into the buffer temporarily. 	 */
name|fgets
argument_list|(
name|jobname
argument_list|,
literal|80
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* 	 * Now get the job name. 	 */
if|if
condition|(
name|fscanf
argument_list|(
name|filename
argument_list|,
literal|"# jobname: %s"
argument_list|,
name|jobname
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%.27s\n"
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|fclose
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 	 * Put a pointer at the begining of the line and remove the basename 	 * from the job file. 	 */
name|ptr
operator|=
name|jobname
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|jobname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|ptr
expr_stmt|;
else|else
name|ptr
operator|=
name|jobname
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|>
literal|23
condition|)
name|printf
argument_list|(
literal|"%.23s ...\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%.27s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do we want to include a file in the queue? (used by "scandir") We are looking  * for files with following syntax: yy.ddd.hhhh. so the test is made to see if   * the file name has three dots in it. This test will suffice since the only  * other files in /usr/spool/at don't have any dots in their name.  */
end_comment

begin_macro
name|filewanted
argument_list|(
argument|direntry
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|direct
modifier|*
name|direntry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|numdot
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|direntry
operator|->
name|d_name
expr_stmt|;
while|while
condition|(
operator|*
name|filename
condition|)
name|numdot
operator|+=
operator|(
operator|*
operator|(
name|filename
operator|++
operator|)
operator|==
literal|'.'
operator|)
expr_stmt|;
return|return
operator|(
name|numdot
operator|==
literal|3
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Sort files by time of creation. (used by "scandir")  */
end_comment

begin_macro
name|creation
argument_list|(
argument|d1
argument_list|,
argument|d2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|direct
modifier|*
modifier|*
name|d1
decl_stmt|,
modifier|*
modifier|*
name|d2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf1
decl_stmt|,
name|stbuf2
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|(
operator|*
name|d1
operator|)
operator|->
name|d_name
argument_list|,
operator|&
name|stbuf1
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
operator|(
operator|*
name|d2
operator|)
operator|->
name|d_name
argument_list|,
operator|&
name|stbuf2
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|stbuf1
operator|.
name|st_ctime
operator|<
name|stbuf2
operator|.
name|st_ctime
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print usage info and exit.  */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:	atq [-c] [-n] [name ...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

