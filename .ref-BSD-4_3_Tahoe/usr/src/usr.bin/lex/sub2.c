begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sub2.c	4.2 (Berkeley) 1/12/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ldefs.c"
end_include

begin_macro
name|cfoll
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|name
index|[
name|v
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|NCH
condition|)
name|i
operator|=
literal|1
expr_stmt|;
comment|/* character */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
case|case
name|RSTR
case|:
case|case
name|RCCL
case|:
case|case
name|RNCCL
case|:
case|case
name|RNULLS
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tptr
condition|;
name|j
operator|++
control|)
name|tmpstat
index|[
name|j
index|]
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|follow
argument_list|(
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PP
name|padd
argument_list|(
name|foll
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* packing version */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PP
name|add
argument_list|(
name|foll
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* no packing version */
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|RSTR
condition|)
name|cfoll
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|RCCL
operator|||
name|i
operator|==
name|RNCCL
condition|)
block|{
comment|/* compress ccl list */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NCH
condition|;
name|j
operator|++
control|)
name|symbol
index|[
name|j
index|]
operator|=
operator|(
name|i
operator|==
name|RNCCL
operator|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|left
index|[
name|v
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|symbol
index|[
operator|*
name|p
operator|++
index|]
operator|=
operator|(
name|i
operator|==
name|RCCL
operator|)
expr_stmt|;
name|p
operator|=
name|pcptr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NCH
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|symbol
index|[
name|j
index|]
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|p
operator|+
name|k
operator|<
name|pcptr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|cindex
index|[
name|j
index|]
operator|==
operator|*
operator|(
name|p
operator|+
name|k
operator|)
condition|)
break|break;
if|if
condition|(
name|p
operator|+
name|k
operator|>=
name|pcptr
condition|)
operator|*
name|pcptr
operator|++
operator|=
name|cindex
index|[
name|j
index|]
expr_stmt|;
block|}
operator|*
name|pcptr
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcptr
operator|>
name|pchar
operator|+
name|pchlen
condition|)
name|error
argument_list|(
literal|"Too many packed character classes"
argument_list|)
expr_stmt|;
name|left
index|[
name|v
index|]
operator|=
operator|(
name|int
operator|)
name|p
expr_stmt|;
name|name
index|[
name|v
index|]
operator|=
name|RCCL
expr_stmt|;
comment|/* RNCCL eliminated */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|*
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"ccl %d: %d"
argument_list|,
name|v
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|printf
argument_list|(
literal|", %d"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|CARAT
case|:
name|cfoll
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
case|case
name|QUEST
case|:
case|case
name|RSCON
case|:
name|cfoll
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAR
case|:
case|case
name|RCAT
case|:
case|case
name|DIV
case|:
case|case
name|RNEWE
case|:
name|cfoll
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
name|cfoll
argument_list|(
name|right
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|FINAL
case|:
case|case
name|S1FINAL
case|:
case|case
name|S2FINAL
case|:
break|break;
default|default:
name|warning
argument_list|(
literal|"bad switch cfoll %d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|pfoll
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* print sets of chars which may follow positions */
name|printf
argument_list|(
literal|"pos\tchars\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tptr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|foll
index|[
name|i
index|]
condition|)
block|{
name|j
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%d:\t%d"
argument_list|,
name|i
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|2
init|;
name|k
operator|<=
name|j
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|", %d"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|add
argument_list|(
argument|array
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ctemp
decl_stmt|;
name|temp
operator|=
name|nxtpos
expr_stmt|;
name|ctemp
operator|=
name|tmpstat
expr_stmt|;
name|array
index|[
name|n
index|]
operator|=
name|nxtpos
expr_stmt|;
comment|/* note no packing is done in positions */
operator|*
name|temp
operator|++
operator|=
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tptr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ctemp
index|[
name|i
index|]
operator|==
name|TRUE
condition|)
operator|*
name|temp
operator|++
operator|=
name|i
expr_stmt|;
name|nxtpos
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|nxtpos
operator|>=
name|positions
operator|+
name|maxpos
condition|)
name|error
argument_list|(
literal|"Too many positions %s"
argument_list|,
operator|(
name|maxpos
operator|==
name|MAXPOS
condition|?
literal|"\nTry using %p num"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|follow
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|>=
name|tptr
operator|-
literal|1
condition|)
return|return;
name|p
operator|=
name|parent
index|[
name|v
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|name
index|[
name|p
index|]
condition|)
block|{
comment|/* will not be CHAR RNULLS FINAL S1FINAL S2FINAL RCCL RNCCL */
case|case
name|RSTR
case|:
if|if
condition|(
name|tmpstat
index|[
name|p
index|]
operator|==
name|FALSE
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|tmpstat
index|[
name|p
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
name|first
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAR
case|:
case|case
name|QUEST
case|:
case|case
name|RNEWE
case|:
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCAT
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|v
operator|==
name|left
index|[
name|p
index|]
condition|)
block|{
if|if
condition|(
name|nullstr
index|[
name|right
index|[
name|p
index|]
index|]
condition|)
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|first
argument_list|(
name|right
index|[
name|p
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSCON
case|:
case|case
name|CARAT
case|:
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|warning
argument_list|(
literal|"bad switch follow %d"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_block

begin_macro
name|first
argument_list|(
argument|v
argument_list|)
end_macro

begin_comment
comment|/* calculate set of positions with v as root which can be active initially */
end_comment

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|name
index|[
name|v
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|NCH
condition|)
name|i
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
case|case
name|RCCL
case|:
case|case
name|RNCCL
case|:
case|case
name|RNULLS
case|:
case|case
name|FINAL
case|:
case|case
name|S1FINAL
case|:
case|case
name|S2FINAL
case|:
if|if
condition|(
name|tmpstat
index|[
name|v
index|]
operator|==
name|FALSE
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|tmpstat
index|[
name|v
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|BAR
case|:
case|case
name|RNEWE
case|:
name|first
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
name|first
argument_list|(
name|right
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CARAT
case|:
if|if
condition|(
name|stnum
operator|%
literal|2
operator|==
literal|1
condition|)
name|first
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSCON
case|:
name|i
operator|=
name|stnum
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|right
index|[
name|v
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|i
condition|)
block|{
name|first
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|STAR
case|:
case|case
name|QUEST
case|:
case|case
name|PLUS
case|:
case|case
name|RSTR
case|:
name|first
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCAT
case|:
case|case
name|DIV
case|:
name|first
argument_list|(
name|left
index|[
name|v
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullstr
index|[
name|left
index|[
name|v
index|]
index|]
condition|)
name|first
argument_list|(
name|right
index|[
name|v
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|warning
argument_list|(
literal|"bad switch first %d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_block

begin_macro
name|cgoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
name|int
name|npos
decl_stmt|,
name|curpos
decl_stmt|,
name|n
decl_stmt|;
name|int
name|tryit
decl_stmt|;
name|char
name|tch
index|[
name|NCH
index|]
decl_stmt|;
name|int
name|tst
index|[
name|NCH
index|]
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* generate initial state, for each start condition */
if|if
condition|(
name|ratfor
condition|)
block|{
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"blockdata\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"common /Lvstop/ vstop\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"define Svstop %d\n"
argument_list|,
name|nstates
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"integer vstop(Svstop)\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"int yyvstop[] ={\n0,\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|stnum
operator|<
literal|2
operator|||
name|stnum
operator|/
literal|2
operator|<
name|sptr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tptr
condition|;
name|i
operator|++
control|)
name|tmpstat
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tptr
operator|>
literal|0
condition|)
name|first
argument_list|(
name|tptr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|state
argument_list|,
name|stnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|stnum
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|sname
index|[
name|stnum
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
name|pstate
argument_list|(
name|stnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stnum
operator|++
expr_stmt|;
block|}
name|stnum
operator|--
expr_stmt|;
comment|/* even stnum = might not be at line begin */
comment|/* odd stnum  = must be at line begin */
comment|/* even states can occur anywhere, odd states only at line begin */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|stnum
condition|;
name|s
operator|++
control|)
block|{
name|tryit
operator|=
name|FALSE
expr_stmt|;
name|cpackflg
index|[
name|s
index|]
operator|=
name|FALSE
expr_stmt|;
name|sfall
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|acompute
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
name|symbol
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|npos
operator|=
operator|*
name|state
index|[
name|s
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|npos
condition|;
name|i
operator|++
control|)
block|{
name|curpos
operator|=
operator|*
operator|(
name|state
index|[
name|s
index|]
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|curpos
index|]
operator|<
name|NCH
condition|)
name|symbol
index|[
name|name
index|[
name|curpos
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
else|else
switch|switch
condition|(
name|name
index|[
name|curpos
index|]
condition|)
block|{
case|case
name|RCCL
case|:
name|tryit
operator|=
name|TRUE
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|left
index|[
name|curpos
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NCH
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cindex
index|[
name|j
index|]
operator|==
operator|*
name|q
condition|)
name|symbol
index|[
name|j
index|]
operator|=
name|TRUE
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|RSTR
case|:
name|symbol
index|[
name|right
index|[
name|curpos
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|RNULLS
case|:
case|case
name|FINAL
case|:
case|case
name|S1FINAL
case|:
case|case
name|S2FINAL
case|:
break|break;
default|default:
name|warning
argument_list|(
literal|"bad switch cgoto %d state %d"
argument_list|,
name|curpos
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"State %d transitions on:\n\t"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|charc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|symbol
index|[
name|i
index|]
condition|)
name|allprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|charc
operator|>
name|LINESIZE
condition|)
block|{
name|charc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* for each char, calculate next state */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|symbol
index|[
name|i
index|]
condition|)
block|{
name|nextstate
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* executed for each state, transition pair */
name|xstate
operator|=
name|notin
argument_list|(
name|stnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|xstate
operator|==
operator|-
literal|2
condition|)
name|warning
argument_list|(
literal|"bad state  %d %o"
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xstate
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|stnum
operator|>=
name|nstates
condition|)
name|error
argument_list|(
literal|"Too many states %s"
argument_list|,
operator|(
name|nstates
operator|==
name|NSTATES
condition|?
literal|"\nTry using %n num"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|state
argument_list|,
operator|++
name|stnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|pstate
argument_list|(
name|stnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tch
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|tst
index|[
name|n
operator|++
index|]
operator|=
name|stnum
expr_stmt|;
block|}
else|else
block|{
comment|/* xstate>= 0 ==> state exists */
name|tch
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|tst
index|[
name|n
operator|++
index|]
operator|=
name|xstate
expr_stmt|;
block|}
block|}
block|}
name|tch
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|tst
index|[
name|n
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* pack transitions into permanent array */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|packtrans
argument_list|(
name|s
argument_list|,
name|tch
argument_list|,
name|tst
argument_list|,
name|n
argument_list|,
name|tryit
argument_list|)
expr_stmt|;
else|else
name|gotof
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|ratfor
condition|?
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"end\n"
argument_list|)
else|:
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0};\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*	Beware -- 70% of total CPU time is spent in this subroutine - 		if you don't believe me - try it yourself ! */
end_comment

begin_macro
name|nextstate
argument_list|(
argument|s
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|,
modifier|*
name|newpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|tz
decl_stmt|;
name|int
modifier|*
name|pos
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|f
decl_stmt|,
name|num
decl_stmt|,
name|curpos
decl_stmt|,
name|number
decl_stmt|;
comment|/* state to goto from state s on char c */
name|num
operator|=
operator|*
name|state
index|[
name|s
index|]
expr_stmt|;
name|temp
operator|=
name|tmpstat
expr_stmt|;
name|pos
operator|=
name|state
index|[
name|s
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|curpos
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
name|j
operator|=
name|name
index|[
name|curpos
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|NCH
operator|&&
name|j
operator|==
name|c
operator|||
name|j
operator|==
name|RSTR
operator|&&
name|c
operator|==
name|right
index|[
name|curpos
index|]
operator|||
name|j
operator|==
name|RCCL
operator|&&
name|member
argument_list|(
name|c
argument_list|,
name|left
index|[
name|curpos
index|]
argument_list|)
condition|)
block|{
name|f
operator|=
name|foll
index|[
name|curpos
index|]
expr_stmt|;
name|number
operator|=
operator|*
name|f
expr_stmt|;
name|newpos
operator|=
name|f
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
control|)
name|temp
index|[
operator|*
name|newpos
operator|++
index|]
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|j
operator|=
literal|0
expr_stmt|;
name|tz
operator|=
name|temp
operator|+
name|tptr
expr_stmt|;
while|while
condition|(
name|temp
operator|<
name|tz
condition|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
literal|2
condition|)
block|{
name|j
operator|++
expr_stmt|;
operator|*
name|temp
operator|++
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|temp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|count
operator|=
name|j
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|notin
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* see if tmpstat occurs previously */
specifier|register
name|int
modifier|*
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|temp
operator|=
name|tmpstat
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* for each state */
name|j
operator|=
name|state
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|==
operator|*
name|j
operator|++
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|count
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|temp
index|[
operator|*
name|j
operator|++
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|count
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|packtrans
argument_list|(
argument|st
argument_list|,
argument|tch
argument_list|,
argument|tst
argument_list|,
argument|cnt
argument_list|,
argument|tryit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|st
decl_stmt|,
modifier|*
name|tst
decl_stmt|,
name|cnt
decl_stmt|,
name|tryit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tch
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* pack transitions into nchar, nexts */
comment|/* nchar is terminated by '\0', nexts uses cnt, followed by elements */
comment|/* gotof[st] = index into nchr, nexts for state st */
comment|/* sfall[st] =  t implies t is fall back state for st */
comment|/*	        == -1 implies no fall back */
name|int
name|cmin
decl_stmt|,
name|cval
decl_stmt|,
name|tcnt
decl_stmt|,
name|diff
decl_stmt|,
name|p
decl_stmt|,
modifier|*
name|ast
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|ach
decl_stmt|;
name|int
name|go
index|[
name|NCH
index|]
decl_stmt|,
name|temp
index|[
name|NCH
index|]
decl_stmt|,
name|c
decl_stmt|;
name|int
name|swork
index|[
name|NCH
index|]
decl_stmt|;
name|char
name|cwork
index|[
name|NCH
index|]
decl_stmt|;
name|int
name|upper
decl_stmt|;
name|rcount
operator|+=
name|cnt
expr_stmt|;
name|cmin
operator|=
operator|-
literal|1
expr_stmt|;
name|cval
operator|=
name|NCH
expr_stmt|;
name|ast
operator|=
name|tst
expr_stmt|;
name|ach
operator|=
name|tch
expr_stmt|;
comment|/* try to pack transitions using ccl's */
if|if
condition|(
operator|!
name|optim
condition|)
goto|goto
name|nopack
goto|;
comment|/* skip all compaction */
if|if
condition|(
name|tryit
condition|)
block|{
comment|/* ccl's used */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
block|{
name|go
index|[
name|i
index|]
operator|=
name|temp
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|symbol
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|go
index|[
name|tch
index|[
name|i
index|]
index|]
operator|=
name|tst
index|[
name|i
index|]
expr_stmt|;
name|symbol
index|[
name|tch
index|[
name|i
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|match
index|[
name|tch
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|go
index|[
name|c
index|]
operator|!=
name|tst
index|[
name|i
index|]
operator|||
name|c
operator|==
name|tch
index|[
name|i
index|]
condition|)
name|temp
index|[
name|tch
index|[
name|i
index|]
index|]
operator|=
name|tst
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* fill in error entries */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol
index|[
name|i
index|]
condition|)
name|temp
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* error trans */
comment|/* count them */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|temp
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|cnt
condition|)
block|{
comment|/* compress by char */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"use compression  %d,  %d vs %d\n"
argument_list|,
name|st
argument_list|,
name|k
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|temp
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|cwork
index|[
name|k
index|]
operator|=
name|i
expr_stmt|;
name|swork
index|[
name|k
operator|++
index|]
operator|=
operator|(
name|temp
index|[
name|i
index|]
operator|==
operator|-
literal|2
condition|?
operator|-
literal|1
else|:
name|temp
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
name|cwork
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PC
name|ach
operator|=
name|cwork
expr_stmt|;
name|ast
operator|=
name|swork
expr_stmt|;
name|cnt
operator|=
name|k
expr_stmt|;
name|cpackflg
index|[
name|st
index|]
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|st
condition|;
name|i
operator|++
control|)
block|{
comment|/* get most similar state */
comment|/* reject state with more transitions, state already represented by a third state, 					and state which is compressed by char if ours is not to be */
if|if
condition|(
name|sfall
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cpackflg
index|[
name|st
index|]
operator|==
literal|1
condition|)
if|if
condition|(
operator|!
operator|(
name|cpackflg
index|[
name|i
index|]
operator|==
literal|1
operator|)
condition|)
continue|continue;
name|p
operator|=
name|gotof
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|-
literal|1
condition|)
comment|/* no transitions */
continue|continue;
name|tcnt
operator|=
name|nexts
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|tcnt
operator|>
name|cnt
condition|)
continue|continue;
name|diff
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
name|p
operator|+
name|tcnt
expr_stmt|;
while|while
condition|(
name|ach
index|[
name|j
index|]
operator|&&
name|p
operator|<
name|upper
condition|)
block|{
while|while
condition|(
name|ach
index|[
name|j
index|]
operator|<
name|nchar
index|[
name|p
index|]
operator|&&
name|ach
index|[
name|j
index|]
condition|)
block|{
name|diff
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ach
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ach
index|[
name|j
index|]
operator|>
name|nchar
index|[
name|p
index|]
condition|)
block|{
name|diff
operator|=
name|NCH
expr_stmt|;
break|break;
block|}
comment|/* ach[j] == nchar[p] */
if|if
condition|(
name|ast
index|[
name|j
index|]
operator|!=
name|nexts
index|[
operator|++
name|p
index|]
operator|||
name|ast
index|[
name|j
index|]
operator|==
operator|-
literal|1
operator|||
operator|(
name|cpackflg
index|[
name|st
index|]
operator|&&
name|ach
index|[
name|j
index|]
operator|!=
name|match
index|[
name|ach
index|[
name|j
index|]
index|]
operator|)
condition|)
name|diff
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ach
index|[
name|j
index|]
condition|)
block|{
name|diff
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|upper
condition|)
name|diff
operator|=
name|NCH
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|cval
operator|&&
name|diff
operator|<
name|tcnt
condition|)
block|{
name|cval
operator|=
name|diff
expr_stmt|;
name|cmin
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|cval
operator|==
literal|0
condition|)
break|break;
block|}
block|}
comment|/* cmin = state "most like" state st */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"select st %d for st %d diff %d\n"
argument_list|,
name|cmin
argument_list|,
name|st
argument_list|,
name|cval
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PS
if|if
condition|(
name|cmin
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* if we can use st cmin */
name|gotof
index|[
name|st
index|]
operator|=
name|nptr
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|sfall
index|[
name|st
index|]
operator|=
name|cmin
expr_stmt|;
name|p
operator|=
name|gotof
index|[
name|cmin
index|]
operator|+
literal|1
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ach
index|[
name|j
index|]
condition|)
block|{
comment|/* if cmin has a transition on c, then so will st */
comment|/* st may be "larger" than cmin, however */
while|while
condition|(
name|ach
index|[
name|j
index|]
operator|<
name|nchar
index|[
name|p
operator|-
literal|1
index|]
operator|&&
name|ach
index|[
name|j
index|]
condition|)
block|{
name|k
operator|++
expr_stmt|;
name|nchar
index|[
name|nptr
index|]
operator|=
name|ach
index|[
name|j
index|]
expr_stmt|;
name|nexts
index|[
operator|++
name|nptr
index|]
operator|=
name|ast
index|[
name|j
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nchar
index|[
name|p
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ach
index|[
name|j
index|]
operator|>
name|nchar
index|[
name|p
operator|-
literal|1
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"bad transition %d %d"
argument_list|,
name|st
argument_list|,
name|cmin
argument_list|)
expr_stmt|;
goto|goto
name|nopack
goto|;
block|}
comment|/* ach[j] == nchar[p-1] */
if|if
condition|(
name|ast
index|[
name|j
index|]
operator|!=
name|nexts
index|[
name|p
index|]
operator|||
name|ast
index|[
name|j
index|]
operator|==
operator|-
literal|1
operator|||
operator|(
name|cpackflg
index|[
name|st
index|]
operator|&&
name|ach
index|[
name|j
index|]
operator|!=
name|match
index|[
name|ach
index|[
name|j
index|]
index|]
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
name|nchar
index|[
name|nptr
index|]
operator|=
name|ach
index|[
name|j
index|]
expr_stmt|;
name|nexts
index|[
operator|++
name|nptr
index|]
operator|=
name|ast
index|[
name|j
index|]
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ach
index|[
name|j
index|]
condition|)
block|{
name|nchar
index|[
name|nptr
index|]
operator|=
name|ach
index|[
name|j
index|]
expr_stmt|;
name|nexts
index|[
operator|++
name|nptr
index|]
operator|=
name|ast
index|[
name|j
operator|++
index|]
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|nexts
index|[
name|gotof
index|[
name|st
index|]
index|]
operator|=
name|cnt
operator|=
name|k
expr_stmt|;
name|nchar
index|[
name|nptr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|nopack
label|:
comment|/* stick it in */
name|gotof
index|[
name|st
index|]
operator|=
name|nptr
expr_stmt|;
name|nexts
index|[
name|nptr
index|]
operator|=
name|cnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|nchar
index|[
name|nptr
index|]
operator|=
name|ach
index|[
name|i
index|]
expr_stmt|;
name|nexts
index|[
operator|++
name|nptr
index|]
operator|=
name|ast
index|[
name|i
index|]
expr_stmt|;
block|}
name|nchar
index|[
name|nptr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PS
block|}
endif|#
directive|endif
if|if
condition|(
name|cnt
operator|<
literal|1
condition|)
block|{
name|gotof
index|[
name|st
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nptr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nptr
operator|>
name|ntrans
condition|)
name|error
argument_list|(
literal|"Too many transitions %s"
argument_list|,
operator|(
name|ntrans
operator|==
name|NTRANS
condition|?
literal|"\nTry using %a num"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|pstate
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"State %d:\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|state
index|[
name|s
index|]
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"%4d"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|", %4d"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|30
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|member
argument_list|(
argument|d
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|c
operator|=
name|d
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|c
operator|=
name|cindex
index|[
name|c
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|stprt
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|p
decl_stmt|,
name|t
decl_stmt|;
name|printf
argument_list|(
literal|"State %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* print actions, if any */
name|t
operator|=
name|atable
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|" final"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpackflg
index|[
name|i
index|]
operator|==
name|TRUE
condition|)
name|printf
argument_list|(
literal|"backup char in use\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfall
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"fall back state %d\n"
argument_list|,
name|sfall
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|gotof
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|-
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"(%d transitions)\n"
argument_list|,
name|nexts
index|[
name|p
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|nchar
index|[
name|p
index|]
condition|)
block|{
name|charc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nexts
index|[
name|p
operator|+
literal|1
index|]
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%d\t"
argument_list|,
name|nexts
index|[
name|p
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"err\t"
argument_list|)
expr_stmt|;
name|allprint
argument_list|(
name|nchar
index|[
name|p
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|nexts
index|[
name|p
index|]
operator|==
name|nexts
index|[
name|p
operator|+
literal|1
index|]
operator|&&
name|nchar
index|[
name|p
index|]
condition|)
block|{
if|if
condition|(
name|charc
operator|>
name|LINESIZE
condition|)
block|{
name|charc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|allprint
argument_list|(
name|nchar
index|[
name|p
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|acompute
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* compute action list = set of poss. actions */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|m
decl_stmt|;
name|int
name|temp
index|[
literal|300
index|]
decl_stmt|,
name|k
decl_stmt|,
name|neg
index|[
literal|300
index|]
decl_stmt|,
name|n
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|state
index|[
name|s
index|]
expr_stmt|;
name|cnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|300
condition|)
name|error
argument_list|(
literal|"Too many positions for one state - acompute"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
operator|*
name|p
index|]
operator|==
name|FINAL
condition|)
name|temp
index|[
name|k
operator|++
index|]
operator|=
name|left
index|[
operator|*
name|p
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
operator|*
name|p
index|]
operator|==
name|S1FINAL
condition|)
block|{
name|temp
index|[
name|k
operator|++
index|]
operator|=
name|left
index|[
operator|*
name|p
index|]
expr_stmt|;
if|if
condition|(
name|left
index|[
operator|*
name|p
index|]
operator|>
name|NACTIONS
condition|)
name|error
argument_list|(
literal|"Too many right contexts"
argument_list|)
expr_stmt|;
name|extra
index|[
name|left
index|[
operator|*
name|p
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
operator|*
name|p
index|]
operator|==
name|S2FINAL
condition|)
name|neg
index|[
name|n
operator|++
index|]
operator|=
name|left
index|[
operator|*
name|p
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|atable
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|1
operator|&&
name|n
operator|<
literal|1
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"final %d actions:"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sort action list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|temp
index|[
name|j
index|]
operator|<
name|temp
index|[
name|i
index|]
condition|)
block|{
name|m
operator|=
name|temp
index|[
name|j
index|]
expr_stmt|;
name|temp
index|[
name|j
index|]
operator|=
name|temp
index|[
name|i
index|]
expr_stmt|;
name|temp
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
comment|/* remove dups */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|temp
index|[
name|i
index|]
operator|==
name|temp
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|temp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* copy to permanent quarters */
name|atable
index|[
name|s
index|]
operator|=
name|aptr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|ratfor
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"/* actions for state %d */"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|temp
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ratfor
condition|?
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"data vstop(%d)/%d/\n"
argument_list|,
name|aptr
argument_list|,
name|temp
index|[
name|i
index|]
argument_list|)
else|:
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%d,\n"
argument_list|,
name|temp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|temp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|aptr
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* copy fall back actions - all neg */
name|ratfor
condition|?
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"data vstop(%d)/%d/\n"
argument_list|,
name|aptr
argument_list|,
name|neg
index|[
name|i
index|]
argument_list|)
else|:
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%d,\n"
argument_list|,
name|neg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|aptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|neg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ratfor
condition|?
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"data vstop (%d)/0/\n"
argument_list|,
name|aptr
argument_list|)
else|:
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,\n"
argument_list|)
expr_stmt|;
name|aptr
operator|++
expr_stmt|;
return|return;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|pccl
argument_list|()
end_macro

begin_block
block|{
comment|/* print character class sets */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"char class intersection\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
control|)
block|{
name|charc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"class %d:\n\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NCH
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cindex
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|allprint
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|charc
operator|>
name|LINESIZE
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|charc
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|charc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"match:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
block|{
name|allprint
argument_list|(
name|match
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|charc
operator|>
name|LINESIZE
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|charc
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|mkmatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tab
index|[
name|NCH
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
control|)
name|tab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tab
index|[
name|cindex
index|[
name|i
index|]
index|]
operator|==
literal|0
condition|)
name|tab
index|[
name|cindex
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|/* tab[i] = principal char for new ccl i */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
name|match
index|[
name|i
index|]
operator|=
name|tab
index|[
name|cindex
index|[
name|i
index|]
index|]
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|layout
argument_list|()
end_macro

begin_block
block|{
comment|/* format and output final program's tables */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|top
decl_stmt|,
name|bot
decl_stmt|,
name|startup
decl_stmt|,
name|omin
decl_stmt|;
name|startup
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outsize
condition|;
name|i
operator|++
control|)
name|verify
index|[
name|i
index|]
operator|=
name|advance
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|omin
operator|=
literal|0
expr_stmt|;
name|yytop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|stnum
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each state */
name|j
operator|=
name|gotof
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
block|{
name|stoff
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|bot
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|nchar
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|top
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"State %d: (layout)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bot
init|;
name|j
operator|<=
name|top
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  %o"
argument_list|,
name|nchar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|10
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|verify
index|[
name|omin
operator|+
name|ZCH
index|]
condition|)
name|omin
operator|++
expr_stmt|;
name|startup
operator|=
name|omin
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bot,top %d, %d startup begins %d\n"
argument_list|,
name|bot
argument_list|,
name|top
argument_list|,
name|startup
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chset
condition|)
block|{
do|do
block|{
operator|++
name|startup
expr_stmt|;
if|if
condition|(
name|startup
operator|>
name|outsize
operator|-
name|ZCH
condition|)
name|error
argument_list|(
literal|"output table overflow"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bot
init|;
name|j
operator|<=
name|top
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|startup
operator|+
name|ctable
index|[
name|nchar
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|verify
index|[
name|k
index|]
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|j
operator|<=
name|top
condition|)
do|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|" startup will be %d\n"
argument_list|,
name|startup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* have found place */
for|for
control|(
name|j
operator|=
name|bot
init|;
name|j
operator|<=
name|top
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|startup
operator|+
name|ctable
index|[
name|nchar
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ctable
index|[
name|nchar
index|[
name|j
index|]
index|]
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"j %d nchar %d ctable.nch %d\n"
argument_list|,
name|j
argument_list|,
name|nchar
index|[
name|j
index|]
argument_list|,
name|ctable
index|[
name|nchar
index|[
name|k
index|]
index|]
argument_list|)
expr_stmt|;
name|verify
index|[
name|k
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* state number + 1*/
name|advance
index|[
name|k
index|]
operator|=
name|nexts
index|[
name|j
operator|+
literal|1
index|]
operator|+
literal|1
expr_stmt|;
comment|/* state number + 1*/
if|if
condition|(
name|yytop
operator|<
name|k
condition|)
name|yytop
operator|=
name|k
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
operator|++
name|startup
expr_stmt|;
if|if
condition|(
name|startup
operator|>
name|outsize
operator|-
name|ZCH
condition|)
name|error
argument_list|(
literal|"output table overflow"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bot
init|;
name|j
operator|<=
name|top
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|startup
operator|+
name|nchar
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|verify
index|[
name|k
index|]
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|j
operator|<=
name|top
condition|)
do|;
comment|/* have found place */
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|" startup going to be %d\n"
argument_list|,
name|startup
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
name|bot
init|;
name|j
operator|<=
name|top
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|startup
operator|+
name|nchar
index|[
name|j
index|]
expr_stmt|;
name|verify
index|[
name|k
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* state number + 1*/
name|advance
index|[
name|k
index|]
operator|=
name|nexts
index|[
name|j
operator|+
literal|1
index|]
operator|+
literal|1
expr_stmt|;
comment|/* state number + 1*/
if|if
condition|(
name|yytop
operator|<
name|k
condition|)
name|yytop
operator|=
name|k
expr_stmt|;
block|}
block|}
name|stoff
index|[
name|i
index|]
operator|=
name|startup
expr_stmt|;
block|}
comment|/* stoff[i] = offset into verify, advance for trans for state i */
comment|/* put out yywork */
if|if
condition|(
name|ratfor
condition|)
block|{
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"define YYTOPVAL %d\n"
argument_list|,
name|yytop
argument_list|)
expr_stmt|;
name|rprint
argument_list|(
name|verify
argument_list|,
literal|"verif"
argument_list|,
name|yytop
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rprint
argument_list|(
name|advance
argument_list|,
literal|"advan"
argument_list|,
name|yytop
operator|+
literal|1
argument_list|)
expr_stmt|;
name|shiftr
argument_list|(
name|stoff
argument_list|,
name|stnum
argument_list|)
expr_stmt|;
name|rprint
argument_list|(
name|stoff
argument_list|,
literal|"stoff"
argument_list|,
name|stnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|shiftr
argument_list|(
name|sfall
argument_list|,
name|stnum
argument_list|)
expr_stmt|;
name|upone
argument_list|(
name|sfall
argument_list|,
name|stnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rprint
argument_list|(
name|sfall
argument_list|,
literal|"sfall"
argument_list|,
name|stnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bprint
argument_list|(
name|extra
argument_list|,
literal|"extra"
argument_list|,
name|casecount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bprint
argument_list|(
name|match
argument_list|,
literal|"match"
argument_list|,
name|NCH
argument_list|)
expr_stmt|;
name|shiftr
argument_list|(
name|atable
argument_list|,
name|stnum
argument_list|)
expr_stmt|;
name|rprint
argument_list|(
name|atable
argument_list|,
literal|"atable"
argument_list|,
name|stnum
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"# define YYTYPE %s\n"
argument_list|,
name|stnum
operator|+
literal|1
operator|>
name|NCH
condition|?
literal|"int"
else|:
literal|"char"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"struct yywork { YYTYPE verify, advance; } yycrank[] ={\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|yytop
condition|;
name|i
operator|+=
literal|4
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|verify
index|[
name|k
index|]
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%d,%d,\t"
argument_list|,
name|verify
index|[
name|k
index|]
argument_list|,
name|advance
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,0,\t"
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,0};\n"
argument_list|)
expr_stmt|;
comment|/* put out yysvec */
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"struct yysvf yysvec[] ={\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,\t0,\t0,\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|stnum
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each state */
if|if
condition|(
name|cpackflg
index|[
name|i
index|]
condition|)
name|stoff
index|[
name|i
index|]
operator|=
operator|-
name|stoff
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"yycrank+%d,\t"
argument_list|,
name|stoff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfall
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"yysvec+%d,\t"
argument_list|,
name|sfall
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* state + 1 */
else|else
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,\t\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|atable
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"yyvstop+%d,"
argument_list|,
name|atable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,\t"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"\t\t/* state %d */"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0,\t0,\t0};\n"
argument_list|)
expr_stmt|;
comment|/* put out yymatch */
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"struct yywork *yytop = yycrank+%d;\n"
argument_list|,
name|yytop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"struct yysvf *yybgin = yysvec+1;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optim
condition|)
block|{
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"char yymatch[] ={\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chset
operator|==
literal|0
condition|)
comment|/* no chset, put out in normal order */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|+=
literal|8
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|int
name|fbch
decl_stmt|;
name|fbch
operator|=
name|match
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
if|if
condition|(
name|printable
argument_list|(
name|fbch
argument_list|)
operator|&&
name|fbch
operator|!=
literal|'\''
operator|&&
name|fbch
operator|!=
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"'%c' ,"
argument_list|,
name|fbch
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0%-3o,"
argument_list|,
name|fbch
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
modifier|*
name|fbarr
decl_stmt|;
name|fbarr
operator|=
operator|(
name|int
operator|*
operator|)
name|myalloc
argument_list|(
literal|2
operator|*
name|NCH
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fbarr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbarr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No space for char table reverse"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZCH
condition|;
name|i
operator|++
control|)
name|fbarr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
name|fbarr
index|[
name|ctable
index|[
name|i
index|]
index|]
operator|=
name|ctable
index|[
name|match
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZCH
condition|;
name|i
operator|+=
literal|8
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0%-3o,"
argument_list|,
name|fbarr
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|cfree
argument_list|(
name|fbarr
argument_list|,
literal|2
operator|*
name|NCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0};\n"
argument_list|)
expr_stmt|;
block|}
comment|/* put out yyextra */
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"char yyextra[] ={\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|casecount
condition|;
name|i
operator|+=
literal|8
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%d,"
argument_list|,
name|i
operator|+
name|j
operator|<
name|NACTIONS
condition|?
name|extra
index|[
name|i
operator|+
name|j
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"0};\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|rprint
argument_list|(
argument|a
argument_list|,
argument|s
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|a
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"block data\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"common /L%s/ %s\n"
argument_list|,
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"define S%s %d\n"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"integer %s (S%s)\n"
argument_list|,
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"data "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s (%d)/%d/"
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
operator|(
name|i
operator|%
literal|8
operator|&&
name|i
operator|<
name|n
operator|)
condition|?
literal|", "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"end\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|shiftr
argument_list|(
argument|a
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|upone
argument_list|(
argument|a
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
name|a
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|bprint
argument_list|(
argument|a
argument_list|,
argument|s
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"block data\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"common /L%s/ %s\n"
argument_list|,
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"define S%s %d\n"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"integer %s (S%s)\n"
argument_list|,
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"data %s (%d)/%d/"
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|n
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|", %s (%d)/%d/"
argument_list|,
name|s
argument_list|,
name|k
argument_list|,
name|a
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"end\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|PP
end_ifdef

begin_macro
name|padd
argument_list|(
argument|array
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
name|k
decl_stmt|;
name|array
index|[
name|n
index|]
operator|=
name|nxtpos
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
operator|*
name|nxtpos
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|tptr
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|&&
operator|*
name|j
operator|++
operator|==
name|count
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|count
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|tmpstat
index|[
operator|*
name|j
operator|++
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|count
condition|)
block|{
name|array
index|[
name|n
index|]
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
block|}
block|}
name|add
argument_list|(
name|array
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

