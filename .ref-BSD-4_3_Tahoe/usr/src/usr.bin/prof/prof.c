begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)prof.c	4.4 (Berkeley) 3/24/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * prof  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_typedef
typedef|typedef
name|short
name|UNIT
typedef|;
end_typedef

begin_comment
comment|/* unit of profiling */
end_comment

begin_define
define|#
directive|define
name|PCFUDGE
value|11
end_define

begin_define
define|#
directive|define
name|A_OUTNAME
value|"a.out"
end_define

begin_define
define|#
directive|define
name|MON_OUTNAME
value|"mon.out"
end_define

begin_define
define|#
directive|define
name|MON_SUMNAME
value|"mon.sum"
end_define

begin_comment
comment|/*  * The symbol table;  * for each external in the specified file we gather  * its address, the number of calls and compute its share of cpu time.  */
end_comment

begin_struct
struct|struct
name|nl
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|value
decl_stmt|;
name|float
name|time
decl_stmt|;
name|long
name|ncall
decl_stmt|;
block|}
modifier|*
name|nl
struct|;
end_struct

begin_decl_stmt
name|int
name|nname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|npe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The header on the mon.out file.  * Mon.out consists of one of these headers, an array of ncount  * cnt structures (as below) and then an array of samples  * representing the discretized program counter values.  */
end_comment

begin_struct
struct|struct
name|hdr
block|{
name|UNIT
modifier|*
name|lowpc
decl_stmt|,
modifier|*
name|highpc
decl_stmt|;
name|int
name|ncount
decl_stmt|;
block|}
name|h
struct|;
end_struct

begin_comment
comment|/*  * Each counter has an address and a number of calls.  */
end_comment

begin_struct
struct|struct
name|cnt
block|{
name|unsigned
name|cvalue
decl_stmt|;
name|long
name|cncall
decl_stmt|;
block|}
modifier|*
name|cbuf
struct|;
end_struct

begin_comment
comment|/*  * Each discretized pc sample has  * a count of the number of samples in its range  */
end_comment

begin_decl_stmt
name|unsigned
name|UNIT
modifier|*
name|samples
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|pfile
decl_stmt|,
modifier|*
name|nfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* range profiled */
end_comment

begin_decl_stmt
name|double
name|ransca
decl_stmt|,
name|ranoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scaling for blowing up plots */
end_comment

begin_decl_stmt
name|unsigned
name|sampbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes of samples */
end_comment

begin_decl_stmt
name|int
name|nsamples
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of samples */
end_comment

begin_decl_stmt
name|double
name|totime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total time for all routines */
end_comment

begin_decl_stmt
name|double
name|maxtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum time of any routine (for plot) */
end_comment

begin_decl_stmt
name|double
name|scale
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scale factor converting samples to pc 				   values: each sample covers scale bytes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|strtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string table in core */
end_comment

begin_decl_stmt
name|off_t
name|ssiz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the string table */
end_comment

begin_decl_stmt
name|struct
name|exec
name|xbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exec header of a.out */
end_comment

begin_decl_stmt
name|int
name|aflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|namfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timcmp
argument_list|()
decl_stmt|,
name|valcmp
argument_list|()
decl_stmt|,
name|cntcmp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|lowpct
decl_stmt|,
name|highpct
decl_stmt|;
comment|/* 	 * Use highpct and lowpc as percentages, temporarily 	 * for graphing options involving blow-up 	 */
name|lowpct
operator|=
operator|-
literal|1
expr_stmt|;
name|highpct
operator|=
operator|-
literal|1
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|!=
literal|0
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
operator|*
name|argv
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'l'
condition|)
name|lflg
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'a'
condition|)
name|aflg
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'n'
condition|)
name|nflg
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'z'
condition|)
name|zflg
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'v'
condition|)
name|vflg
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'s'
condition|)
name|sflag
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|argv
operator|<=
literal|'9'
condition|)
block|{
name|int
name|i
init|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|lowpct
operator|==
operator|-
literal|1
condition|)
name|lowpct
operator|=
name|i
expr_stmt|;
else|else
name|highpct
operator|=
name|i
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
operator|!=
literal|0
condition|)
block|{
name|namfil
operator|=
operator|*
name|argv
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
else|else
block|{
name|namfil
operator|=
name|A_OUTNAME
expr_stmt|;
block|}
if|if
condition|(
name|lowpct
operator|>=
literal|100
condition|)
name|lowpct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|highpct
operator|<=
name|lowpct
operator|||
name|highpct
operator|>
literal|100
condition|)
name|highpct
operator|=
literal|100
expr_stmt|;
name|ransca
operator|=
literal|100.
operator|/
operator|(
name|highpct
operator|-
name|lowpct
operator|)
expr_stmt|;
name|ranoff
operator|=
literal|2040.
operator|+
literal|40.8
operator|*
name|lowpc
operator|*
name|ransca
expr_stmt|;
comment|/* 		 *	get information about a.out file. 		 */
name|getnfile
argument_list|()
expr_stmt|;
comment|/* 		 *	get information about mon.out file(s). 		 */
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
block|{
name|getpfile
argument_list|(
name|MON_OUTNAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|getpfile
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|argv
operator|!=
literal|0
condition|)
do|;
block|}
name|asgnsamples
argument_list|()
expr_stmt|;
comment|/* assign samples to procedures */
ifdef|#
directive|ifdef
name|plot
if|if
condition|(
name|vflg
condition|)
name|plotprof
argument_list|()
expr_stmt|;
comment|/* a plotted or ... */
else|else
endif|#
directive|endif
name|printprof
argument_list|()
expr_stmt|;
comment|/* a printed profile */
if|if
condition|(
name|sflag
operator|!=
literal|0
condition|)
block|{
name|putprof
argument_list|()
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|printprof
argument_list|()
end_macro

begin_block
block|{
name|double
name|time
decl_stmt|,
name|actime
decl_stmt|,
name|hz
decl_stmt|;
name|actime
operator|=
literal|0
expr_stmt|;
name|hz
operator|=
name|hertz
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" %%time  cumsecs  #call  ms/call  name\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflg
condition|)
name|qsort
argument_list|(
name|nl
argument_list|,
name|nname
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nl
argument_list|)
argument_list|,
name|timcmp
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nl
init|;
name|np
operator|<
name|npe
operator|-
literal|1
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|zflg
operator|==
literal|0
operator|&&
name|np
operator|->
name|time
operator|==
literal|0
operator|&&
name|np
operator|->
name|ncall
operator|==
literal|0
condition|)
continue|continue;
name|time
operator|=
name|np
operator|->
name|time
operator|/
name|totime
expr_stmt|;
name|actime
operator|+=
name|np
operator|->
name|time
expr_stmt|;
name|printf
argument_list|(
literal|"%6.1f%9.2f"
argument_list|,
literal|100
operator|*
name|time
argument_list|,
name|actime
operator|/
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ncall
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%7ld %8.2f"
argument_list|,
name|np
operator|->
name|ncall
argument_list|,
operator|(
name|np
operator|->
name|time
operator|*
literal|1000
operator|/
name|hz
operator|)
operator|/
name|np
operator|->
name|ncall
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%7.7s %8.8s"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Set up string and symbol tables from a.out.  * On return symbol table is sorted by value.  */
end_comment

begin_macro
name|getnfile
argument_list|()
end_macro

begin_block
block|{
name|nfile
operator|=
name|fopen
argument_list|(
name|namfil
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|namfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|fread
argument_list|(
operator|&
name|xbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|xbuf
argument_list|)
argument_list|,
name|nfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|xbuf
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad format\n"
argument_list|,
name|namfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|getstrtab
argument_list|()
expr_stmt|;
name|getsymtab
argument_list|()
expr_stmt|;
name|qsort
argument_list|(
name|nl
argument_list|,
name|nname
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nl
argument_list|)
argument_list|,
name|valcmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getstrtab
argument_list|()
end_macro

begin_block
block|{
name|fseek
argument_list|(
name|nfile
argument_list|,
name|N_SYMOFF
argument_list|(
name|xbuf
argument_list|)
operator|+
name|xbuf
operator|.
name|a_syms
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|ssiz
argument_list|,
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|,
literal|1
argument_list|,
name|nfile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no string table (old format?)\n"
argument_list|,
name|namfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|ssiz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no room for %d bytes of string table"
argument_list|,
name|namfil
argument_list|,
name|ssiz
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|strtab
operator|+
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|,
name|ssiz
operator|-
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|,
literal|1
argument_list|,
name|nfile
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error reading string table\n"
argument_list|,
name|namfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Read in symbol table  */
end_comment

begin_macro
name|getsymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* pass1 - count symbols */
name|fseek
argument_list|(
name|nfile
argument_list|,
name|N_SYMOFF
argument_list|(
name|xbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nname
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xbuf
operator|.
name|a_syms
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
control|)
block|{
name|struct
name|nlist
name|nbuf
decl_stmt|;
name|fread
argument_list|(
operator|&
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
literal|1
argument_list|,
name|nfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
operator|.
name|n_type
operator|!=
name|N_TEXT
operator|&&
name|nbuf
operator|.
name|n_type
operator|!=
name|N_TEXT
operator|+
name|N_EXT
condition|)
continue|continue;
if|if
condition|(
name|aflg
operator|==
literal|0
operator|&&
name|nbuf
operator|.
name|n_type
operator|!=
name|N_TEXT
operator|+
name|N_EXT
condition|)
continue|continue;
name|nname
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nname
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no symbols\n"
argument_list|,
name|namfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|nl
operator|=
operator|(
expr|struct
name|nl
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|nname
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"prof: No room for %d bytes of symbol table\n"
argument_list|,
operator|(
name|nname
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
comment|/* pass2 - read symbols */
name|fseek
argument_list|(
name|nfile
argument_list|,
name|N_SYMOFF
argument_list|(
name|xbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|npe
operator|=
name|nl
expr_stmt|;
name|nname
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xbuf
operator|.
name|a_syms
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
control|)
block|{
name|struct
name|nlist
name|nbuf
decl_stmt|;
name|fread
argument_list|(
operator|&
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
literal|1
argument_list|,
name|nfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
operator|.
name|n_type
operator|!=
name|N_TEXT
operator|&&
name|nbuf
operator|.
name|n_type
operator|!=
name|N_TEXT
operator|+
name|N_EXT
condition|)
continue|continue;
if|if
condition|(
name|aflg
operator|==
literal|0
operator|&&
name|nbuf
operator|.
name|n_type
operator|!=
name|N_TEXT
operator|+
name|N_EXT
condition|)
continue|continue;
name|npe
operator|->
name|value
operator|=
name|nbuf
operator|.
name|n_value
operator|/
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
expr_stmt|;
name|npe
operator|->
name|name
operator|=
name|strtab
operator|+
name|nbuf
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|npe
operator|++
expr_stmt|;
name|nname
operator|++
expr_stmt|;
block|}
name|npe
operator|->
name|value
operator|=
operator|-
literal|1
expr_stmt|;
name|npe
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * information from a mon.out file is in two parts:  * the counters of how many times each procedure was called,  * if it was called at all;  * and an array of sampling hits within pc ranges.  * the counters must be dealt with on a file-by-file basis,  * since which procedures are represented may vary.  * the samples ranges are fixed, but must be summed across  * files, and then distributed among procedures, because  * of the wierd way the plotting is done.  */
end_comment

begin_macro
name|getpfile
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|openpfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|readcntrs
argument_list|()
expr_stmt|;
name|asgncntrs
argument_list|()
expr_stmt|;
comment|/* assign counts to procedures */
name|readsamples
argument_list|()
expr_stmt|;
name|closepfile
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|openpfile
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
operator|(
name|pfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|fstat
argument_list|(
name|fileno
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|lowpc
operator|=
name|h
operator|.
name|lowpc
operator|-
operator|(
name|UNIT
operator|*
operator|)
literal|0
expr_stmt|;
name|highpc
operator|=
name|h
operator|.
name|highpc
operator|-
operator|(
name|UNIT
operator|*
operator|)
literal|0
expr_stmt|;
name|sampbytes
operator|=
name|stb
operator|.
name|st_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|hdr
argument_list|)
operator|-
name|h
operator|.
name|ncount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
expr_stmt|;
name|nsamples
operator|=
name|sampbytes
operator|/
expr|sizeof
operator|(
name|unsigned
name|UNIT
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|closepfile
argument_list|()
end_macro

begin_block
block|{
name|fclose
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|readcntrs
argument_list|()
end_macro

begin_block
block|{
name|struct
name|cnt
modifier|*
name|kp
decl_stmt|;
name|cbuf
operator|=
operator|(
expr|struct
name|cnt
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|h
operator|.
name|ncount
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbuf
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"prof: No room for %d bytes of count buffer\n"
argument_list|,
operator|(
name|h
operator|.
name|ncount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fread
argument_list|(
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
argument_list|,
name|h
operator|.
name|ncount
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
comment|/* eliminate zero counters and scale counter pc values */
if|if
condition|(
name|h
operator|.
name|ncount
condition|)
block|{
name|kp
operator|=
operator|&
name|cbuf
index|[
name|h
operator|.
name|ncount
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|kp
operator|->
name|cvalue
operator|==
literal|0
condition|)
block|{
name|h
operator|.
name|ncount
operator|=
name|kp
operator|-
name|cbuf
expr_stmt|;
operator|++
name|kp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kp
operator|==
name|cbuf
condition|)
block|{
name|h
operator|.
name|ncount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|--
name|kp
expr_stmt|;
block|}
for|for
control|(
init|;
operator|--
name|kp
operator|>=
name|cbuf
condition|;
control|)
name|kp
operator|->
name|cvalue
operator|/=
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* sort counters */
name|qsort
argument_list|(
name|cbuf
argument_list|,
name|h
operator|.
name|ncount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
argument_list|,
name|cntcmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Assign counters to the procedures to which they belong  */
end_comment

begin_macro
name|asgncntrs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|cnt
modifier|*
name|kp
decl_stmt|;
name|kp
operator|=
operator|&
name|cbuf
index|[
name|h
operator|.
name|ncount
operator|-
literal|1
index|]
expr_stmt|;
name|np
operator|=
name|npe
expr_stmt|;
while|while
condition|(
operator|--
name|np
operator|>=
name|nl
condition|)
block|{
if|if
condition|(
name|kp
operator|<
name|cbuf
operator|||
name|np
operator|->
name|value
operator|>
name|kp
operator|->
name|cvalue
condition|)
continue|continue;
comment|/* skip ``static'' functions */
while|while
condition|(
name|kp
operator|>=
name|cbuf
operator|&&
name|kp
operator|->
name|cvalue
operator|>
name|np
operator|->
name|value
operator|+
name|PCFUDGE
condition|)
operator|--
name|kp
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|cvalue
operator|>=
name|np
operator|->
name|value
condition|)
block|{
name|np
operator|->
name|ncall
operator|+=
name|kp
operator|->
name|cncall
expr_stmt|;
operator|--
name|kp
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|readsamples
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|unsigned
name|UNIT
name|sample
decl_stmt|;
name|int
name|totalt
decl_stmt|;
if|if
condition|(
name|samples
operator|==
literal|0
condition|)
block|{
name|samples
operator|=
operator|(
name|unsigned
name|UNIT
operator|*
operator|)
name|calloc
argument_list|(
name|sampbytes
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|UNIT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"prof: No room for %d sample pc's\n"
argument_list|,
name|sampbytes
operator|/
expr|sizeof
operator|(
name|unsigned
name|UNIT
operator|)
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|fread
argument_list|(
operator|&
name|sample
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|UNIT
operator|)
argument_list|,
literal|1
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|pfile
argument_list|)
condition|)
break|break;
name|samples
index|[
name|i
index|]
operator|+=
name|sample
expr_stmt|;
name|totalt
operator|+=
name|sample
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|nsamples
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"prof: unexpected EOF after reading %d/%d samples\n"
argument_list|,
operator|--
name|i
argument_list|,
name|nsamples
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Assign samples to the procedures to which they belong.  */
end_comment

begin_macro
name|asgnsamples
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|j
expr_stmt|;
name|unsigned
name|UNIT
name|ccnt
decl_stmt|;
name|double
name|time
decl_stmt|;
name|unsigned
name|pcl
decl_stmt|,
name|pch
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|overlap
decl_stmt|;
comment|/* read samples and assign to namelist symbols */
name|scale
operator|=
name|highpc
operator|-
name|lowpc
expr_stmt|;
name|scale
operator|/=
name|nsamples
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsamples
condition|;
name|i
operator|++
control|)
block|{
name|ccnt
operator|=
name|samples
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ccnt
operator|==
literal|0
condition|)
continue|continue;
name|pcl
operator|=
name|lowpc
operator|+
name|scale
operator|*
name|i
expr_stmt|;
name|pch
operator|=
name|lowpc
operator|+
name|scale
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|time
operator|=
name|ccnt
expr_stmt|;
name|totime
operator|+=
name|time
expr_stmt|;
if|if
condition|(
name|time
operator|>
name|maxtime
condition|)
name|maxtime
operator|=
name|time
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nname
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pch
operator|<
name|nl
index|[
name|j
index|]
operator|.
name|value
condition|)
break|break;
if|if
condition|(
name|pcl
operator|>=
name|nl
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|value
condition|)
continue|continue;
name|overlap
operator|=
operator|(
name|min
argument_list|(
name|pch
argument_list|,
name|nl
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|value
argument_list|)
operator|-
name|max
argument_list|(
name|pcl
argument_list|,
name|nl
index|[
name|j
index|]
operator|.
name|value
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|overlap
operator|>
literal|0
condition|)
name|nl
index|[
name|j
index|]
operator|.
name|time
operator|+=
name|overlap
operator|*
name|time
operator|/
name|scale
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totime
operator|==
literal|0.0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No time accumulated\n"
argument_list|)
expr_stmt|;
comment|/* 		done();  */
name|totime
operator|=
literal|1.0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * dump what you have out to a mon.out style file.  */
end_comment

begin_macro
name|putprof
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|sfile
decl_stmt|;
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
name|struct
name|cnt
name|kp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sfile
operator|=
name|fopen
argument_list|(
name|MON_SUMNAME
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|MON_SUMNAME
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * build a new header. 	 * h.lowpc and h.highpc are already fine. 	 * fix h.ncount to count non-zero calls, 	 * and the one zero call which marks the end. 	 */
name|h
operator|.
name|ncount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nl
init|;
name|np
operator|<
name|npe
operator|-
literal|1
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|ncall
operator|>
literal|0
condition|)
name|h
operator|.
name|ncount
operator|++
expr_stmt|;
name|h
operator|.
name|ncount
operator|++
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sfile
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nl
init|;
name|np
operator|<
name|npe
operator|-
literal|1
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|np
operator|->
name|ncall
operator|>
literal|0
condition|)
block|{
name|kp
operator|.
name|cvalue
operator|=
name|np
operator|->
name|value
operator|*
expr|sizeof
operator|(
name|unsigned
name|UNIT
operator|)
expr_stmt|;
name|kp
operator|.
name|cncall
operator|=
name|np
operator|->
name|ncall
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|kp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sfile
argument_list|)
expr_stmt|;
block|}
block|}
name|kp
operator|.
name|cvalue
operator|=
literal|0
expr_stmt|;
name|kp
operator|.
name|cncall
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|kp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sfile
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|samples
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|UNIT
operator|)
argument_list|,
name|nsamples
argument_list|,
name|sfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|sfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	discover the tick frequency of the machine  *	if something goes wrong, we return 1.  */
end_comment

begin_macro
name|hertz
argument_list|()
end_macro

begin_block
block|{
name|struct
name|itimerval
name|tim
decl_stmt|;
name|tim
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tim
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|1
expr_stmt|;
name|tim
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tim
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|tim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
literal|0
argument_list|,
operator|&
name|tim
argument_list|)
expr_stmt|;
if|if
condition|(
name|tim
operator|.
name|it_interval
operator|.
name|tv_usec
operator|<
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|1000000
operator|/
name|tim
operator|.
name|it_interval
operator|.
name|tv_usec
operator|)
return|;
block|}
end_block

begin_macro
name|min
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|(
name|a
operator|)
return|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|max
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
operator|(
name|a
operator|)
return|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|valcmp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p1
operator|->
name|value
operator|-
name|p2
operator|->
name|value
operator|)
return|;
block|}
end_block

begin_macro
name|timcmp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|d
decl_stmt|;
if|if
condition|(
name|nflg
operator|&&
name|p2
operator|->
name|ncall
operator|!=
name|p1
operator|->
name|ncall
condition|)
return|return
operator|(
name|p2
operator|->
name|ncall
operator|-
name|p1
operator|->
name|ncall
operator|)
return|;
name|d
operator|=
name|p2
operator|->
name|time
operator|-
name|p1
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0.0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|p1
operator|->
name|name
argument_list|,
name|p2
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|cntcmp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cnt
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p1
operator|->
name|cvalue
operator|-
name|p2
operator|->
name|cvalue
operator|)
return|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|plot
if|if
condition|(
name|vflg
condition|)
block|{
name|point
argument_list|(
literal|0
argument_list|,
operator|-
literal|2040
argument_list|)
expr_stmt|;
name|closepl
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|plot
end_ifdef

begin_macro
name|plotprof
argument_list|()
end_macro

begin_block
block|{
name|double
name|time
decl_stmt|,
name|lastx
decl_stmt|,
name|lasty
decl_stmt|,
name|lastsx
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|openpl
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|space
argument_list|(
operator|-
literal|2048
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2048
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|line
argument_list|(
operator|-
literal|2040
argument_list|,
operator|-
literal|2040
argument_list|,
operator|-
literal|2040
argument_list|,
literal|2040
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|0
argument_list|,
literal|2040
argument_list|,
literal|0
argument_list|,
operator|-
literal|2040
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
name|line
argument_list|(
operator|-
literal|2040
argument_list|,
literal|2040
operator|-
name|i
operator|*
literal|408
argument_list|,
literal|0
argument_list|,
literal|2040
operator|-
name|i
operator|*
literal|408
argument_list|)
expr_stmt|;
name|lastx
operator|=
literal|0.
expr_stmt|;
name|lasty
operator|=
name|ranoff
expr_stmt|;
name|scale
operator|=
operator|(
literal|4080.
operator|*
name|ransca
operator|)
operator|/
operator|(
name|sampbytes
operator|/
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
operator|)
expr_stmt|;
name|lastsx
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsamples
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|UNIT
name|ccnt
decl_stmt|;
name|double
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|ccnt
operator|=
name|samples
index|[
name|i
index|]
expr_stmt|;
name|time
operator|=
name|ccnt
expr_stmt|;
name|tx
operator|=
name|lastsx
expr_stmt|;
name|ty
operator|=
name|lasty
expr_stmt|;
name|lastsx
operator|-=
literal|2000.
operator|*
name|time
operator|/
name|totime
expr_stmt|;
name|lasty
operator|-=
name|scale
expr_stmt|;
if|if
condition|(
name|lasty
operator|>=
operator|-
literal|2040.
operator|&&
name|ty
operator|<=
literal|2040.
condition|)
block|{
name|line
argument_list|(
operator|(
name|int
operator|)
name|tx
argument_list|,
operator|(
name|int
operator|)
name|ty
argument_list|,
operator|(
name|int
operator|)
name|lastsx
argument_list|,
operator|(
name|int
operator|)
name|lasty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccnt
operator|!=
literal|0
operator|||
name|lastx
operator|!=
literal|0.0
condition|)
block|{
name|tx
operator|=
name|lastx
expr_stmt|;
name|lastx
operator|=
operator|-
name|time
operator|*
literal|2000.
operator|/
name|maxtime
expr_stmt|;
name|ty
operator|+=
name|scale
operator|/
literal|2
expr_stmt|;
name|line
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|ty
argument_list|,
operator|(
name|int
operator|)
name|tx
argument_list|,
operator|(
name|int
operator|)
name|ty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|scale
operator|=
operator|(
literal|4080.
operator|*
name|ransca
operator|)
operator|/
operator|(
name|highpc
operator|-
name|lowpc
operator|)
expr_stmt|;
name|lastx
operator|=
literal|50.
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nl
init|;
name|np
operator|<
name|npe
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|np
operator|->
name|value
operator|<
name|lowpc
condition|)
continue|continue;
if|if
condition|(
name|np
operator|->
name|value
operator|>=
name|highpc
condition|)
continue|continue;
if|if
condition|(
name|zflg
operator|==
literal|0
operator|&&
name|np
operator|->
name|time
operator|==
literal|0
operator|&&
name|np
operator|->
name|ncall
operator|==
literal|0
condition|)
continue|continue;
name|time
operator|=
name|np
operator|->
name|time
operator|/
name|totime
expr_stmt|;
name|lasty
operator|=
name|ranoff
operator|-
operator|(
name|np
operator|->
name|value
operator|-
name|lowpc
operator|)
operator|*
name|scale
expr_stmt|;
if|if
condition|(
name|lasty
operator|>=
operator|-
literal|2040.
operator|&&
name|lasty
operator|<=
literal|2040.
condition|)
block|{
name|char
name|bufl
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|namp
decl_stmt|;
specifier|register
name|j
expr_stmt|;
name|line
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|lasty
argument_list|,
literal|50
argument_list|,
operator|(
name|int
operator|)
name|lasty
argument_list|)
expr_stmt|;
name|line
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lastx
operator|-
literal|50
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|lasty
argument_list|,
operator|(
name|int
operator|)
name|lastx
argument_list|,
operator|(
name|int
operator|)
name|lasty
argument_list|)
expr_stmt|;
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lastx
operator|+
literal|30
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lasty
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bufl
argument_list|,
literal|"%s"
argument_list|,
name|np
operator|->
name|name
operator|+
operator|(
name|np
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|bufl
argument_list|)
expr_stmt|;
block|}
name|lastx
operator|+=
literal|500.
expr_stmt|;
if|if
condition|(
name|lastx
operator|>
literal|2000.
condition|)
name|lastx
operator|=
literal|50.
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

