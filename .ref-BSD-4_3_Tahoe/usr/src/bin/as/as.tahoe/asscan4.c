begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asscan4.c 4.4 6/30/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"asscanl.h"
end_include

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|NUMSIZE
value|128
end_define

begin_comment
comment|/* how many characters long a number can be */
end_comment

begin_define
define|#
directive|define
name|FLTCHAR
parameter_list|(
name|x
parameter_list|)
value|(INCHARSET((x),(DIGIT|SIGN|FLOATEXP|POINT)))
end_define

begin_decl_stmt
specifier|static
name|char
name|numbuf
index|[
name|NUMSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BACK
parameter_list|(
name|backval
parameter_list|)
value|intval = backval; goto stuffback;
end_define

begin_function
name|int
name|number
parameter_list|(
name|ch
parameter_list|)
name|reg
name|int
name|ch
decl_stmt|;
block|{
name|int
name|radix
decl_stmt|;
name|int
name|digit
decl_stmt|;
comment|/* part of number being constructed */
name|reg
name|int
name|intval
decl_stmt|;
comment|/* number being constructed */
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
name|reg
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|reg
name|int
name|inbufcnt
decl_stmt|;
name|char
name|ch1
decl_stmt|;
name|Bignum
name|floatnumber
parameter_list|()
function_decl|;
name|Ovf
name|overflow
decl_stmt|;
comment|/* overflow flag */
name|int
name|maxstrlg
decl_stmt|;
name|MEMTOREGBUF
expr_stmt|;
name|cp
operator|=
name|numbuf
expr_stmt|;
name|radix
operator|=
literal|10
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'0'
case|:
switch|switch
condition|(
name|ch
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'b'
case|:
name|yylval
operator|=
operator|-
literal|1
expr_stmt|;
name|BACK
argument_list|(
name|BFINT
argument_list|)
expr_stmt|;
case|case
literal|'f'
case|:
comment|/* 			 * Check if it is a local label by peeking ahead 			 */
name|ch1
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FLTCHAR
argument_list|(
name|ch1
argument_list|)
condition|)
block|{
name|yylval
operator|=
literal|1
expr_stmt|;
name|BACK
argument_list|(
name|BFINT
argument_list|)
expr_stmt|;
block|}
comment|/*FALLTHROUGH*/
case|case
literal|'F'
case|:
name|ch
operator|=
literal|'f'
expr_stmt|;
goto|goto
name|floatnum
goto|;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|ch
operator|=
literal|'d'
expr_stmt|;
goto|goto
name|floatnum
goto|;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|ch
operator|=
literal|'0'
expr_stmt|;
name|radix
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|radix
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
comment|/* single 0 */
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|intval
operator|=
literal|0
expr_stmt|;
goto|goto
name|smallnum
goto|;
block|}
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
switch|switch
condition|(
name|ch1
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'f'
case|:
name|yylval
operator|=
operator|(
operator|(
name|ch
operator|-
literal|'0'
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|BACK
argument_list|(
name|BFINT
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|yylval
operator|=
operator|-
operator|(
operator|(
name|ch
operator|-
literal|'0'
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|BACK
argument_list|(
name|BFINT
argument_list|)
expr_stmt|;
default|default:
name|ungetc
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
comment|/* put back non zero */
block|}
name|radix
operator|=
literal|10
expr_stmt|;
break|break;
block|}
name|intval
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	There is a character in ch that must be used to 	 *	cons up the number; we can't ungetc it 	 */
do|do
block|{
name|digit
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|8
case|:
name|intval
operator|<<=
literal|3
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|intval
operator|*=
literal|10
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|intval
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|HEXLDIGIT
argument_list|)
condition|)
block|{
name|digit
operator|=
operator|(
name|ch
operator|-
literal|'a'
operator|)
operator|+
literal|10
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|HEXUDIGIT
argument_list|)
condition|)
block|{
name|digit
operator|=
operator|(
name|ch
operator|-
literal|'A'
operator|)
operator|+
literal|10
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
name|ch
expr_stmt|;
comment|/* 		 *	Build a negative number, then negate it 		 */
name|intval
operator|-=
name|digit
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|radix
operator|!=
literal|16
condition|)
break|break;
if|if
condition|(
operator|!
name|INCHARSET
argument_list|(
name|ch
argument_list|,
operator|(
name|HEXLDIGIT
operator||
name|HEXUDIGIT
operator|)
argument_list|)
condition|)
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|maxstrlg
operator|=
name|cp
operator|-
name|numbuf
expr_stmt|;
comment|/* 	 *	See if the number is too large for our previous calculation 	 */
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|16
case|:
if|if
condition|(
name|maxstrlg
operator|>
literal|8
condition|)
goto|goto
name|bignum
goto|;
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|maxstrlg
operator|>=
literal|10
condition|)
goto|goto
name|bignum
goto|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|maxstrlg
operator|>
literal|11
condition|)
goto|goto
name|bignum
goto|;
if|if
condition|(
name|maxstrlg
operator|==
literal|11
operator|&&
name|numbuf
index|[
literal|0
index|]
operator|>
literal|3
condition|)
goto|goto
name|bignum
goto|;
break|break;
block|}
comment|/* 	 *	Negate the number 	 */
name|smallnum
label|:
empty_stmt|;
name|yylval
operator|=
operator|-
name|intval
expr_stmt|;
name|BACK
argument_list|(
name|INT
argument_list|)
expr_stmt|;
name|bignum
label|:
empty_stmt|;
name|yybignum
operator|=
name|as_atoi
argument_list|(
name|numbuf
argument_list|,
name|radix
argument_list|,
operator|&
name|overflow
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|BIGNUM
argument_list|)
expr_stmt|;
name|floatnum
label|:
empty_stmt|;
name|REGTOMEMBUF
expr_stmt|;
name|yybignum
operator|=
name|floatnumber
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|BIGNUM
operator|)
return|;
name|stuffback
label|:
empty_stmt|;
name|REGTOMEMBUF
expr_stmt|;
return|return
operator|(
name|intval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TOOLONG
define|\
value|if (cp ==&numbuf[NUMSIZE]){ \ 		if (passno == 2) \ 			yywarning(toolong); \ 			goto process; \ 	}
end_define

begin_define
define|#
directive|define
name|scanit
parameter_list|(
name|sign
parameter_list|)
define|\
value|REGTOMEMBUF; \ 	error |= scanint(sign,&cp); \ 	MEMTOREGBUF; \ 	ch = getchar(); \ 	TOOLONG;
end_define

begin_function
name|Bignum
name|floatnumber
parameter_list|(
name|fltradix
parameter_list|)
name|int
name|fltradix
decl_stmt|;
block|{
name|int
name|tag
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|toolong
init|=
literal|"Floating number too long."
decl_stmt|;
name|char
modifier|*
name|prologue
init|=
literal|"Floating 0%c conflicts with exponent %c; choose %c"
decl_stmt|;
comment|/* 		 *	This is not implemented yet: 		 *	overflow is set on floating overflow. 		 */
name|Ovf
name|overflow
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fractOK
decl_stmt|;
name|reg
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|reg
name|int
name|inbufcnt
decl_stmt|;
name|MEMTOREGBUF
expr_stmt|;
name|cp
operator|=
name|numbuf
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|fractOK
operator|=
literal|0
expr_stmt|;
name|scanit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|POINT
argument_list|)
condition|)
block|{
name|fractOK
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|scanit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|FLOATEXP
argument_list|)
condition|)
block|{
name|fractOK
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|fltradix
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|yywarning
argument_list|(
name|prologue
argument_list|,
name|fltradix
argument_list|,
name|ch
argument_list|,
name|fltradix
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fltradix
condition|)
block|{
case|case
literal|'d'
case|:
name|tag
operator|=
name|TYPD
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'e'
expr_stmt|;
comment|/* will be read by atof() */
break|break;
case|case
literal|'f'
case|:
name|tag
operator|=
name|TYPF
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'e'
expr_stmt|;
comment|/* will be read by atof() */
break|break;
default|default:
break|break;
block|}
name|scanit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
name|fractOK
operator|==
literal|0
condition|)
block|{
name|yyerror
argument_list|(
literal|"Badly formatted floating point number."
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
name|process
label|:
empty_stmt|;
name|REGTOMEMBUF
expr_stmt|;
return|return
operator|(
name|as_atof
argument_list|(
name|numbuf
argument_list|,
name|tag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Scan an optionally signed integer, putting back the lookahead  *	character when finished scanning.  */
end_comment

begin_function
name|int
name|scanint
parameter_list|(
name|signOK
parameter_list|,
name|dstcpp
parameter_list|)
name|int
name|signOK
decl_stmt|;
name|char
modifier|*
modifier|*
name|dstcpp
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|back
init|=
literal|0
decl_stmt|;
name|reg
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|reg
name|int
name|inbufcnt
decl_stmt|;
name|MEMTOREGBUF
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SIGN
argument_list|)
condition|)
block|{
if|if
condition|(
name|signOK
operator|&&
operator|!
name|back
condition|)
operator|*
operator|(
operator|(
operator|*
name|dstcpp
operator|)
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
else|else
name|back
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
operator|*
operator|(
operator|(
operator|*
name|dstcpp
operator|)
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|REGTOMEMBUF
expr_stmt|;
return|return
operator|(
name|back
operator|)
return|;
block|}
end_function

end_unit

