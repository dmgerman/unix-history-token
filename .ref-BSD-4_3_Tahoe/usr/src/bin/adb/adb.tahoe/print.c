begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)print.c	1.2 (Berkeley) 7/25/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|MSG
name|LONGFIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|NOTOPEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|BADMOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|txtmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|datmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|lastframe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|callpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|maxoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol management */
end_comment

begin_decl_stmt
name|ADDR
name|localval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* breakpoints */
end_comment

begin_decl_stmt
name|BKPTR
name|bkpthead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REGLIST
name|reglist
index|[]
init|=
block|{
literal|"p2lr"
block|,
name|P2LR
block|,
operator|&
name|pcb
operator|.
name|pcb_p2lr
block|,
literal|"p2br"
block|,
name|P2BR
block|,
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_p2br
block|,
literal|"p0lr"
block|,
name|P0LR
block|,
operator|&
name|pcb
operator|.
name|pcb_p0lr
block|,
literal|"p0br"
block|,
name|P0BR
block|,
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_p0br
block|,
literal|"ksp"
block|,
name|KSP
block|,
operator|&
name|pcb
operator|.
name|pcb_ksp
block|,
literal|"hfs"
block|,
name|HFS
block|,
operator|&
name|pcb
operator|.
name|pcb_hfs
block|,
literal|"psl"
block|,
name|PSL
block|,
operator|&
name|pcb
operator|.
name|pcb_psl
block|,
literal|"pc"
block|,
name|PC
block|,
operator|&
name|pcb
operator|.
name|pcb_pc
block|,
literal|"ach"
block|,
name|ACHI
block|,
operator|&
name|pcb
operator|.
name|pcb_ach
block|,
literal|"acl"
block|,
name|ACLO
block|,
operator|&
name|pcb
operator|.
name|pcb_acl
block|,
literal|"usp"
block|,
name|USP
block|,
operator|&
name|pcb
operator|.
name|pcb_usp
block|,
literal|"fp"
block|,
name|FP
block|,
operator|&
name|pcb
operator|.
name|pcb_fp
block|,
literal|"r12"
block|,
name|R12
block|,
operator|&
name|pcb
operator|.
name|pcb_r12
block|,
literal|"r11"
block|,
name|R11
block|,
operator|&
name|pcb
operator|.
name|pcb_r11
block|,
literal|"r10"
block|,
name|R10
block|,
operator|&
name|pcb
operator|.
name|pcb_r10
block|,
literal|"r9"
block|,
name|R9
block|,
operator|&
name|pcb
operator|.
name|pcb_r9
block|,
literal|"r8"
block|,
name|R8
block|,
operator|&
name|pcb
operator|.
name|pcb_r8
block|,
literal|"r7"
block|,
name|R7
block|,
operator|&
name|pcb
operator|.
name|pcb_r7
block|,
literal|"r6"
block|,
name|R6
block|,
operator|&
name|pcb
operator|.
name|pcb_r6
block|,
literal|"r5"
block|,
name|R5
block|,
operator|&
name|pcb
operator|.
name|pcb_r5
block|,
literal|"r4"
block|,
name|R4
block|,
operator|&
name|pcb
operator|.
name|pcb_r4
block|,
literal|"r3"
block|,
name|R3
block|,
operator|&
name|pcb
operator|.
name|pcb_r3
block|,
literal|"r2"
block|,
name|R2
block|,
operator|&
name|pcb
operator|.
name|pcb_r2
block|,
literal|"r1"
block|,
name|R1
block|,
operator|&
name|pcb
operator|.
name|pcb_r1
block|,
literal|"r0"
block|,
name|R0
block|,
operator|&
name|pcb
operator|.
name|pcb_r0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fcor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|sigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|var
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|symfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|corfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|adrval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|adrflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|cntval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|cntflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|signals
index|[]
init|=
block|{
literal|""
block|,
literal|"hangup"
block|,
literal|"interrupt"
block|,
literal|"quit"
block|,
literal|"illegal instruction"
block|,
literal|"trace/BPT"
block|,
literal|"IOT"
block|,
literal|"EMT"
block|,
literal|"floating exception"
block|,
literal|"killed"
block|,
literal|"bus error"
block|,
literal|"memory fault"
block|,
literal|"bad system call"
block|,
literal|"broken pipe"
block|,
literal|"alarm call"
block|,
literal|"terminated"
block|,
literal|"signal 16"
block|,
literal|"stop (signal)"
block|,
literal|"stop (tty)"
block|,
literal|"continue (signal)"
block|,
literal|"child termination"
block|,
literal|"stop (tty input)"
block|,
literal|"stop (tty output)"
block|,
literal|"input available (signal)"
block|,
literal|"cpu timelimit"
block|,
literal|"file sizelimit"
block|,
literal|"signal 26"
block|,
literal|"signal 27"
block|,
literal|"signal 28"
block|,
literal|"signal 29"
block|,
literal|"signal 30"
block|,
literal|"signal 31"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* general printing routines ($) */
end_comment

begin_macro
name|printtrace
argument_list|(
argument|modif
argument_list|)
end_macro

begin_block
block|{
name|REG
name|narg
decl_stmt|,
name|i
decl_stmt|;
name|REG
name|BKPTR
name|bkptr
decl_stmt|;
name|REG
name|ADDR
name|word
decl_stmt|;
name|REG
name|STRING
name|comptr
decl_stmt|;
name|REG
name|ADDR
name|argp
decl_stmt|,
name|frame
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|INT
name|stack
decl_stmt|,
name|ntramp
decl_stmt|;
name|IF
name|cntflg
operator|==
literal|0
name|THEN
name|cntval
operator|=
operator|-
literal|1
expr_stmt|;
name|FI
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'<'
case|:
name|IF
name|cntval
operator|==
literal|0
name|THEN
name|WHILE
name|readchar
argument_list|()
operator|!=
name|EOR
name|DO
name|OD
name|lp
operator|--
expr_stmt|;
break|break;
name|FI
name|IF
name|rdc
argument_list|()
operator|==
literal|'<'
name|THEN
name|stack
operator|=
literal|1
expr_stmt|;
name|ELSE
name|stack
init|=
literal|0
decl_stmt|;
name|lp
operator|--
expr_stmt|;
name|FI
comment|/* fall through */
case|case
literal|'>'
case|:
block|{
name|CHAR
name|file
index|[
literal|64
index|]
decl_stmt|;
name|CHAR
name|Ifile
index|[
literal|128
index|]
decl_stmt|;
specifier|extern
name|CHAR
modifier|*
name|Ipath
decl_stmt|;
name|INT
name|index
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|iclose
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ELSE
name|oclose
parameter_list|()
function_decl|;
name|FI
name|IF
name|rdc
argument_list|()
operator|!=
name|EOR
name|THEN
name|REP
name|file
index|[
name|index
operator|++
index|]
operator|=
name|lastc
expr_stmt|;
name|IF
name|index
operator|>=
literal|63
name|THEN
name|error
argument_list|(
name|LONGFIL
argument_list|)
expr_stmt|;
name|FI
name|PER
name|readchar
argument_list|()
operator|!=
name|EOR
name|DONE
name|file
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|IF
name|Ipath
name|THEN
name|strcpy
argument_list|(
name|Ifile
argument_list|,
name|Ipath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Ifile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Ifile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|FI
name|infile
init|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|IF
name|infile
operator|<
literal|0
operator|&&
operator|(
name|infile
operator|=
name|open
argument_list|(
name|Ifile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
name|THEN
name|infile
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|NOTOPEN
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|cntflg
name|THEN
name|var
index|[
literal|9
index|]
init|=
name|cntval
decl_stmt|;
name|ELSE
name|var
index|[
literal|9
index|]
init|=
literal|1
decl_stmt|;
name|FI
name|FI
name|ELSE
name|outfile
init|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|IF
name|outfile
operator|<
literal|0
name|THEN
name|outfile
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EDDT
name|ELSE
name|lseek
argument_list|(
name|outfile
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FI
name|FI
name|ELSE
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|iclose
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FI
name|FI
name|lp
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|IF
name|kernel
operator|==
literal|0
name|THEN
name|printf
argument_list|(
literal|"not debugging kernel\n"
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|adrflg
name|THEN
name|int
name|pte
init|=
name|access
argument_list|(
name|RD
argument_list|,
name|dot
argument_list|,
name|DSP
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|masterpcbb
operator|=
operator|(
name|pte
operator|&
name|PG_PFNUM
operator|)
operator|*
name|NBPG
expr_stmt|;
name|FI
name|getpcb
parameter_list|()
function_decl|;
name|FI
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|adrflg
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adrval
operator|>=
literal|2
operator|&&
name|adrval
operator|<=
literal|16
operator|||
name|adrval
operator|<=
operator|-
literal|2
operator|&&
name|adrval
operator|>=
operator|-
literal|16
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"illegal radix %d base ten"
argument_list|,
name|radix
argument_list|)
expr_stmt|;
break|break;
block|}
name|radix
operator|=
name|adrval
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"radix=%d base ten"
argument_list|,
name|radix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'%'
case|:
name|done
argument_list|()
expr_stmt|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|maxpos
operator|=
operator|(
name|adrflg
condition|?
name|adrval
else|:
name|MAXPOS
operator|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|maxoff
operator|=
operator|(
name|adrflg
condition|?
name|adrval
else|:
name|MAXOFF
operator|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|printf
argument_list|(
literal|"variables\n"
argument_list|)
expr_stmt|;
name|FOR
name|i
init|=
literal|0
decl_stmt|;
name|i
operator|<=
literal|35
expr_stmt|;
name|i
operator|++
name|DO
name|IF
name|var
index|[
name|i
index|]
name|THEN
name|printc
argument_list|(
operator|(
name|i
operator|<=
literal|9
condition|?
literal|'0'
else|:
literal|'a'
operator|-
literal|10
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = %R\n"
argument_list|,
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FI
name|OD
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|printmap
argument_list|(
literal|"? map"
argument_list|,
operator|&
name|txtmap
argument_list|)
expr_stmt|;
name|printmap
argument_list|(
literal|"/ map"
argument_list|,
operator|&
name|datmap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|'?'
case|:
name|IF
name|pid
name|THEN
name|printf
argument_list|(
literal|"pcs id = %d\n"
argument_list|,
name|pid
argument_list|)
decl_stmt|;
name|ELSE
name|printf
argument_list|(
literal|"no process\n"
argument_list|)
decl_stmt|;
name|FI
name|sigprint
parameter_list|()
function_decl|;
name|flushbuf
argument_list|()
expr_stmt|;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|printregs
argument_list|(
name|modif
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|IF
name|adrflg
name|THEN
name|frame
init|=
name|adrval
decl_stmt|;
name|callpc
operator|=
name|get
argument_list|(
name|frame
operator|-
literal|8
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|ELIF
name|kcore
name|THEN
name|frame
init|=
name|pcb
operator|.
name|pcb_fp
decl_stmt|;
name|callpc
operator|=
name|pcb
operator|.
name|pcb_pc
expr_stmt|;
name|ELSE
name|frame
init|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
call|(
name|ADDR
call|)
argument_list|(
operator|&
name|u
argument_list|)
operator|)
operator|+
name|FP
operator|)
decl_stmt|;
name|callpc
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
call|(
name|ADDR
call|)
argument_list|(
operator|&
name|u
argument_list|)
operator|)
operator|+
name|PC
operator|)
expr_stmt|;
name|FI
name|lastframe
init|=
literal|0
decl_stmt|;
name|ntramp
operator|=
literal|0
expr_stmt|;
name|WHILE
name|cntval
operator|--
name|ANDF
name|frame
operator|!=
literal|0
name|DO
name|char
operator|*
name|name
expr_stmt|;
name|chkerr
argument_list|()
expr_stmt|;
comment|/* check for pc in pcb (signal trampoline code) */
if|if
condition|(
name|MAXSTOR
operator|<
name|callpc
operator|&&
name|callpc
operator|<
name|MAXSTOR
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
condition|)
block|{
name|name
operator|=
literal|"sigtramp"
expr_stmt|;
name|ntramp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ntramp
operator|=
literal|0
expr_stmt|;
name|findsym
argument_list|(
name|callpc
argument_list|,
name|ISYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|&&
operator|!
name|strcmp
argument_list|(
name|cursym
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
literal|"start"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cursym
condition|)
name|name
operator|=
name|cursym
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s("
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|narg
operator|=
operator|(
operator|(
name|get
argument_list|(
name|frame
operator|-
literal|4
argument_list|,
name|DSP
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
name|argp
operator|=
name|frame
expr_stmt|;
name|IF
name|ntramp
operator|!=
literal|1
name|THEN
name|LOOP
name|IF
name|narg
operator|==
literal|0
name|THEN
break|break;
name|FI
name|printf
argument_list|(
literal|"%R"
argument_list|,
name|get
argument_list|(
name|argp
operator|+=
literal|4
argument_list|,
name|DSP
argument_list|)
argument_list|)
decl_stmt|;
name|IF
operator|--
name|narg
operator|!=
literal|0
name|THEN
name|printc
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|FI
name|POOL
name|FI
name|printf
argument_list|(
literal|") at "
argument_list|)
decl_stmt|;
name|psymoff
argument_list|(
name|callpc
argument_list|,
name|ISYM
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|IF
name|modif
operator|==
literal|'C'
name|THEN
name|WHILE
name|localsym
argument_list|(
argument|frame
argument_list|,
argument|argp
argument_list|)
name|DO
name|word
operator|=
name|get
argument_list|(
name|localval
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8t%s:%10t"
argument_list|,
name|cursym
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|IF
name|errflg
name|THEN
name|printf
argument_list|(
literal|"?\n"
argument_list|)
decl_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|ELSE
name|printf
argument_list|(
literal|"%R\n"
argument_list|,
name|word
argument_list|)
decl_stmt|;
name|FI
name|OD
name|FI
if|if
condition|(
name|ntramp
operator|!=
literal|1
condition|)
block|{
name|callpc
operator|=
name|get
argument_list|(
name|frame
operator|-
literal|8
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|lastframe
operator|=
name|frame
expr_stmt|;
name|frame
operator|=
name|get
argument_list|(
name|frame
argument_list|,
name|DSP
argument_list|)
operator|&
name|ALIGN
expr_stmt|;
block|}
else|else
name|callpc
operator|=
name|get
argument_list|(
name|lastframe
operator|+
literal|44
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|IF
operator|!
name|adrflg
name|ANDF
operator|!
name|INSTACK
argument_list|(
argument|frame
argument_list|)
name|THEN
break|break;
name|FI
name|OD
break|break;
comment|/*print externals*/
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|esymtab
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
name|ORF
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
condition|)
name|printf
argument_list|(
literal|"%s:%12t%R\n"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|get
argument_list|(
name|sp
operator|->
name|n_value
argument_list|,
name|DSP
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*print breakpoints*/
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|printf
argument_list|(
literal|"breakpoints\ncount%8tbkpt%24tcommand\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bkptr
operator|=
name|bkpthead
init|;
name|bkptr
condition|;
name|bkptr
operator|=
name|bkptr
operator|->
name|nxtbkpt
control|)
if|if
condition|(
name|bkptr
operator|->
name|flag
condition|)
block|{
name|printf
argument_list|(
literal|"%-8.8d"
argument_list|,
name|bkptr
operator|->
name|count
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
name|bkptr
operator|->
name|loc
argument_list|,
name|ISYM
argument_list|,
literal|"%24t"
argument_list|)
expr_stmt|;
name|comptr
operator|=
name|bkptr
operator|->
name|comm
expr_stmt|;
name|WHILE
modifier|*
name|comptr
name|DO
name|printc
argument_list|(
operator|*
name|comptr
operator|++
argument_list|)
decl_stmt|;
name|OD
block|}
break|break;
default|default:
name|error
argument_list|(
name|BADMOD
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|printmap
argument_list|(
argument|s
argument_list|,
argument|amap
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REG
name|MAP
modifier|*
name|amap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|file
decl_stmt|;
name|file
operator|=
name|amap
operator|->
name|ufd
expr_stmt|;
name|printf
argument_list|(
literal|"%s%12t`%s'\n"
argument_list|,
name|s
argument_list|,
operator|(
name|file
operator|<
literal|0
condition|?
literal|"-"
else|:
operator|(
name|file
operator|==
name|fcor
condition|?
name|corfil
else|:
name|symfil
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b1 = %-16R"
argument_list|,
name|amap
operator|->
name|b1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"e1 = %-16R"
argument_list|,
name|amap
operator|->
name|e1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f1 = %-16R"
argument_list|,
name|amap
operator|->
name|f1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nb2 = %-16R"
argument_list|,
name|amap
operator|->
name|b2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"e2 = %-16R"
argument_list|,
name|amap
operator|->
name|e2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f2 = %-16R"
argument_list|,
name|amap
operator|->
name|f2
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|printregs
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|REG
name|REGPTR
name|p
decl_stmt|;
name|ADDR
name|v
decl_stmt|;
name|FOR
name|p
init|=
name|reglist
decl_stmt|;
name|p
operator|->
name|rname
expr_stmt|;
name|p
operator|++
name|DO
if|if
condition|(
name|c
operator|!=
literal|'R'
operator|&&
name|p
operator|->
name|roffs
operator|!=
name|PSL
condition|)
continue|continue;
name|c
operator|=
literal|'R'
expr_stmt|;
name|v
operator|=
name|kcore
condition|?
operator|*
name|p
operator|->
name|rkern
else|:
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|p
operator|->
name|roffs
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%6t%R %16t"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|valpr
argument_list|(
name|v
argument_list|,
operator|(
name|p
operator|->
name|roffs
operator|==
name|PC
condition|?
name|ISYM
else|:
name|DSYM
operator|)
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
name|OD
name|printpc
parameter_list|()
function_decl|;
block|}
end_block

begin_macro
name|getreg
argument_list|(
argument|regnam
argument_list|)
end_macro

begin_block
block|{
name|REG
name|REGPTR
name|p
decl_stmt|;
name|REG
name|STRING
name|regptr
decl_stmt|;
name|CHAR
modifier|*
name|olp
decl_stmt|;
name|olp
operator|=
name|lp
expr_stmt|;
name|FOR
name|p
init|=
name|reglist
decl_stmt|;
name|p
operator|->
name|rname
expr_stmt|;
name|p
operator|++
name|DO
name|regptr
operator|=
name|p
operator|->
name|rname
expr_stmt|;
name|IF
argument_list|(
argument|regnam == *regptr++
argument_list|)
name|THEN
name|WHILE
operator|*
name|regptr
name|DO
name|IF
name|readchar
argument_list|()
operator|!=
operator|*
name|regptr
operator|++
name|THEN
operator|--
name|regptr
expr_stmt|;
break|break;
name|FI
name|OD
name|IF
modifier|*
name|regptr
name|THEN
name|lp
init|=
name|olp
decl_stmt|;
name|ELSE
return|return
operator|(
name|kcore
condition|?
operator|(
name|int
operator|)
name|p
operator|->
name|rkern
else|:
name|p
operator|->
name|roffs
operator|)
return|;
name|FI
name|FI
name|OD
name|lp
init|=
name|olp
decl_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|printpc
argument_list|()
end_macro

begin_block
block|{
name|dot
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
call|(
name|ADDR
call|)
argument_list|(
operator|&
name|u
argument_list|)
operator|)
operator|+
name|PC
operator|)
expr_stmt|;
name|psymoff
argument_list|(
name|dot
argument_list|,
name|ISYM
argument_list|,
literal|":%16t"
argument_list|)
expr_stmt|;
name|printins
argument_list|(
name|ISP
argument_list|,
name|chkget
argument_list|(
name|dot
argument_list|,
name|ISP
argument_list|)
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|illinames
index|[]
init|=
block|{
literal|"reserved addressing fault"
block|,
literal|"priviliged instruction fault"
block|,
literal|"reserved operand fault"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fpenames
index|[]
init|=
block|{
literal|0
block|,
literal|"integer overflow trap"
block|,
literal|"integer divide by zero trap"
block|,
comment|/* not valid 	"floating overflow trap", 	"floating/decimal divide by zero trap", 	"floating underflow trap", 	"decimal overflow trap", 	"subscript out of range trap", 	"floating overflow fault", 	"floating divide by zero fault", 	"floating undeflow fault" */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|sigprint
argument_list|()
end_macro

begin_block
block|{
name|IF
argument_list|(
argument|signo>=
literal|0
argument_list|)
name|ANDF
argument_list|(
argument|signo<sizeof signals/sizeof signals[
literal|0
argument|]
argument_list|)
name|THEN
name|printf
parameter_list|(
name|signals
index|[
name|signo
index|]
parameter_list|)
function_decl|;
name|FI
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGFPE
case|:
name|IF
argument_list|(
argument|sigcode>
literal|0
argument|&& 		    sigcode< sizeof fpenames / sizeof fpenames[
literal|0
argument|]
argument_list|)
name|THEN
name|printf
argument_list|(
literal|" ("
argument_list|)
decl_stmt|;
name|printf
argument_list|(
name|fpenames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
name|printc
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|FI
break|break;
case|case
name|SIGILL
case|:
name|IF
argument_list|(
argument|sigcode>=
literal|0
argument|&& 		    sigcode< sizeof illinames / sizeof illinames[
literal|0
argument|]
argument_list|)
name|THEN
name|printf
argument_list|(
literal|" ("
argument_list|)
decl_stmt|;
name|printf
argument_list|(
name|illinames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
name|printc
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|FI
break|break;
block|}
block|}
end_block

end_unit

