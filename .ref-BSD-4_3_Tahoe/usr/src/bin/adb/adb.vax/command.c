begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)command.c	4.6 10/13/84"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|MSG
name|BADEQ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|NOMATCH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|BADVAR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|BADCOM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|txtmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|datmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|executing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fcor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|mkfault
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|lastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|eqformat
index|[
literal|512
index|]
init|=
literal|"z"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|stformat
index|[
literal|512
index|]
init|=
literal|"X\"= \"^i"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|ditto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|dotinc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|lastcom
init|=
literal|'='
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|var
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|locval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|locmsk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|expv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|adrval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|adrflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|cntval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|cntflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command decoding */
end_comment

begin_macro
name|command
argument_list|(
argument|buf
argument_list|,
argument|defcom
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|defcom
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INT
name|itype
decl_stmt|,
name|ptype
decl_stmt|,
name|modifier
decl_stmt|,
name|regptr
decl_stmt|;
name|BOOL
name|longpr
decl_stmt|,
name|eqcom
decl_stmt|;
name|CHAR
name|wformat
index|[
literal|1
index|]
decl_stmt|;
name|CHAR
name|savc
decl_stmt|;
name|L_INT
name|w
decl_stmt|,
name|savdot
decl_stmt|;
name|STRING
name|savlp
init|=
name|lp
decl_stmt|;
name|IF
name|buf
name|THEN
name|IF
operator|*
name|buf
operator|==
name|EOR
name|THEN
return|return
operator|(
name|FALSE
operator|)
return|;
name|ELSE
name|lp
init|=
name|buf
decl_stmt|;
name|FI
name|FI
name|REP
name|IF
name|adrflg
init|=
name|expr
argument_list|(
literal|0
argument_list|)
name|THEN
name|dot
operator|=
name|expv
decl_stmt|;
name|ditto
operator|=
name|dot
expr_stmt|;
name|FI
name|adrval
init|=
name|dot
decl_stmt|;
name|IF
name|rdc
argument_list|()
operator|==
literal|','
name|ANDF
name|expr
argument_list|(
literal|0
argument_list|)
name|THEN
name|cntflg
operator|=
name|TRUE
expr_stmt|;
name|cntval
operator|=
name|expv
expr_stmt|;
name|ELSE
name|cntflg
init|=
name|FALSE
decl_stmt|;
name|cntval
operator|=
literal|1
expr_stmt|;
name|lp
operator|--
expr_stmt|;
name|FI
name|IF
operator|!
name|eol
argument_list|(
argument|rdc()
argument_list|)
name|THEN
name|lastcom
operator|=
name|lastc
expr_stmt|;
name|ELSE
name|IF
name|adrflg
operator|==
literal|0
name|THEN
name|dot
operator|=
name|inkdot
argument_list|(
name|dotinc
argument_list|)
expr_stmt|;
name|FI
name|lp
operator|--
expr_stmt|;
name|lastcom
operator|=
name|defcom
expr_stmt|;
name|FI
switch|switch
condition|(
name|lastcom
operator|&
name|STRIP
condition|)
block|{
case|case
literal|'/'
case|:
name|itype
operator|=
name|DSP
expr_stmt|;
name|ptype
operator|=
name|DSYM
expr_stmt|;
goto|goto
name|trystar
goto|;
case|case
literal|'='
case|:
name|itype
operator|=
name|NSP
expr_stmt|;
name|ptype
operator|=
literal|0
expr_stmt|;
goto|goto
name|trypr
goto|;
case|case
literal|'?'
case|:
name|itype
operator|=
name|ISP
expr_stmt|;
name|ptype
operator|=
name|ISYM
expr_stmt|;
goto|goto
name|trystar
goto|;
name|trystar
label|:
name|IF
name|rdc
argument_list|()
operator|==
literal|'*'
name|THEN
name|lastcom
operator||=
name|QUOTE
expr_stmt|;
name|ELSE
name|lp
operator|--
expr_stmt|;
name|FI
name|IF
name|lastcom
operator|&
name|QUOTE
name|THEN
name|itype
operator||=
name|STAR
expr_stmt|;
name|ptype
operator|=
operator|(
name|DSYM
operator|+
name|ISYM
operator|)
operator|-
name|ptype
expr_stmt|;
name|FI
name|trypr
range|:
name|longpr
operator|=
name|FALSE
decl_stmt|;
name|eqcom
operator|=
name|lastcom
operator|==
literal|'='
expr_stmt|;
switch|switch
condition|(
name|rdc
argument_list|()
condition|)
block|{
case|case
literal|'m'
case|:
block|{
comment|/*reset map data*/
name|INT
name|fcount
decl_stmt|;
name|MAP
modifier|*
name|smap
decl_stmt|;
name|UNION
block|{
name|MAP
modifier|*
name|m
decl_stmt|;
name|L_INT
modifier|*
name|mp
decl_stmt|;
block|}
name|amap
expr_stmt|;
name|IF
name|eqcom
name|THEN
name|error
parameter_list|(
name|BADEQ
parameter_list|)
function_decl|;
name|FI
name|smap
init|=
operator|(
name|itype
operator|&
name|DSP
condition|?
operator|&
name|datmap
else|:
operator|&
name|txtmap
operator|)
decl_stmt|;
name|amap
operator|.
name|m
operator|=
name|smap
expr_stmt|;
name|fcount
operator|=
literal|3
expr_stmt|;
name|IF
name|itype
operator|&
name|STAR
name|THEN
name|amap
operator|.
name|mp
operator|+=
literal|3
expr_stmt|;
name|FI
name|WHILE
name|fcount
operator|--
name|ANDF
name|expr
argument_list|(
literal|0
argument_list|)
name|DO
operator|*
operator|(
name|amap
operator|.
name|mp
operator|)
operator|++
operator|=
name|expv
expr_stmt|;
name|OD
name|IF
name|rdc
argument_list|()
operator|==
literal|'?'
name|THEN
name|smap
operator|->
name|ufd
operator|=
name|fsym
expr_stmt|;
name|ELIF
name|lastc
operator|==
literal|'/'
name|THEN
name|smap
operator|->
name|ufd
operator|=
name|fcor
expr_stmt|;
name|ELSE
name|lp
operator|--
expr_stmt|;
name|FI
block|}
break|break;
case|case
literal|'L'
case|:
name|longpr
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'l'
case|:
comment|/*search for exp*/
name|IF
name|eqcom
name|THEN
name|error
parameter_list|(
name|BADEQ
parameter_list|)
function_decl|;
name|FI
name|dotinc
init|=
operator|(
name|longpr
condition|?
literal|4
else|:
literal|2
operator|)
decl_stmt|;
name|savdot
operator|=
name|dot
expr_stmt|;
name|expr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|locval
operator|=
name|expv
expr_stmt|;
name|IF
name|expr
argument_list|(
literal|0
argument_list|)
name|THEN
name|locmsk
init|=
name|expv
decl_stmt|;
name|ELSE
name|locmsk
init|=
operator|-
literal|1L
decl_stmt|;
name|FI
name|IF
operator|!
name|longpr
name|THEN
name|locmsk
operator|&=
literal|0xFFFF
expr_stmt|;
name|locval
operator|&=
literal|0xFFFF
expr_stmt|;
name|FI
name|LOOP
name|w
init|=
name|get
argument_list|(
name|dot
argument_list|,
name|itype
argument_list|)
decl_stmt|;
name|IF
name|errflg
name|ORF
name|mkfault
name|ORF
argument_list|(
name|w
operator|&
name|locmsk
argument_list|)
decl|==
name|locval
name|THEN
decl|break
decl_stmt|;
name|FI
name|dot
init|=
name|inkdot
argument_list|(
name|dotinc
argument_list|)
decl_stmt|;
name|POOL
name|IF
name|errflg
name|THEN
name|dot
init|=
name|savdot
decl_stmt|;
name|errflg
operator|=
name|NOMATCH
expr_stmt|;
name|FI
name|psymoff
argument_list|(
name|dot
argument_list|,
name|ptype
argument_list|,
literal|""
argument_list|)
decl_stmt|;
break|break;
case|case
literal|'W'
case|:
name|longpr
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'w'
case|:
name|IF
name|eqcom
name|THEN
name|error
parameter_list|(
name|BADEQ
parameter_list|)
function_decl|;
name|FI
name|wformat
index|[
literal|0
index|]
init|=
name|lastc
decl_stmt|;
name|expr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|REP
name|savdot
init|=
name|dot
decl_stmt|;
name|psymoff
argument_list|(
name|dot
argument_list|,
name|ptype
argument_list|,
literal|":%16t"
argument_list|)
expr_stmt|;
name|exform
argument_list|(
literal|1
argument_list|,
name|wformat
argument_list|,
name|itype
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
name|savdot
expr_stmt|;
name|IF
name|longpr
name|THEN
name|put
parameter_list|(
name|dot
parameter_list|,
name|itype
parameter_list|,
name|expv
parameter_list|)
function_decl|;
name|ELSE
name|put
argument_list|(
name|dot
argument_list|,
name|itype
argument_list|,
name|itol
argument_list|(
name|get
argument_list|(
name|dot
operator|+
literal|2
argument_list|,
name|itype
argument_list|)
argument_list|,
name|expv
argument_list|)
argument_list|)
decl_stmt|;
name|FI
name|savdot
init|=
name|dot
decl_stmt|;
name|printf
argument_list|(
literal|"=%8t"
argument_list|)
expr_stmt|;
name|exform
argument_list|(
literal|1
argument_list|,
name|wformat
argument_list|,
name|itype
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|PER
name|expr
argument_list|(
literal|0
argument_list|)
name|ANDF
name|errflg
decl|==0
name|DONE
name|dot
init|=
name|savdot
decl_stmt|;
name|chkerr
argument_list|()
expr_stmt|;
break|break;
default|default:
name|lp
operator|--
expr_stmt|;
name|getformat
argument_list|(
name|eqcom
condition|?
name|eqformat
else|:
name|stformat
argument_list|)
expr_stmt|;
name|IF
operator|!
name|eqcom
name|THEN
name|psymoff
argument_list|(
name|dot
argument_list|,
name|ptype
argument_list|,
literal|":%16t"
argument_list|)
expr_stmt|;
name|FI
name|scanform
argument_list|(
name|cntval
argument_list|,
operator|(
name|eqcom
condition|?
name|eqformat
else|:
name|stformat
operator|)
argument_list|,
name|itype
argument_list|,
name|ptype
argument_list|)
decl_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
name|lastcom
operator|=
literal|0
expr_stmt|;
name|savc
operator|=
name|rdc
argument_list|()
expr_stmt|;
name|IF
name|regptr
init|=
name|getreg
argument_list|(
argument|savc
argument_list|)
name|THEN
name|IF
name|kcore
name|THEN
operator|*
operator|(
name|int
operator|*
operator|)
name|regptr
operator|=
name|dot
decl_stmt|;
name|ELSE
argument_list|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|regptr
operator|)
operator|=
name|dot
argument_list|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|pid
argument_list|,
name|regptr
argument_list|,
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|regptr
operator|)
argument_list|)
argument_list|;
name|FI
name|ELIF
argument_list|(
name|modifier
operator|=
name|varchk
argument_list|(
name|savc
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
name|THEN
name|var
index|[
name|modifier
index|]
operator|=
name|dot
argument_list|;
name|ELSE
name|error
argument_list|(
name|BADVAR
argument_list|)
argument_list|;
name|FI
break|break;
case|case
literal|'!'
case|:
name|lastcom
operator|=
literal|0
expr_stmt|;
name|shell
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|lastcom
operator|=
literal|0
expr_stmt|;
name|printtrace
argument_list|(
name|nextchar
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|IF
operator|!
name|executing
name|THEN
name|executing
operator|=
name|TRUE
expr_stmt|;
name|subpcs
argument_list|(
name|nextchar
argument_list|()
argument_list|)
expr_stmt|;
name|executing
operator|=
name|FALSE
expr_stmt|;
name|lastcom
operator|=
literal|0
expr_stmt|;
name|FI
break|break;
case|case
literal|0
case|:
name|prints
argument_list|(
name|DBNAME
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|BADCOM
argument_list|)
expr_stmt|;
block|}
name|flushbuf
argument_list|()
expr_stmt|;
name|PER
name|rdc
argument_list|()
operator|==
literal|';'
name|DONE
name|IF
name|buf
name|THEN
name|lp
operator|=
name|savlp
expr_stmt|;
name|ELSE
name|lp
operator|--
expr_stmt|;
name|FI
return|return
operator|(
name|adrflg
name|ANDF
name|dot
operator|!=
literal|0
operator|)
return|;
block|}
end_block

end_unit

