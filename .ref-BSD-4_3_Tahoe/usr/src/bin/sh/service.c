begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)service.c	4.5 4/24/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_function_decl
name|PROC
name|VOID
name|gsort
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ARGMK
value|01
end_define

begin_decl_stmt
name|INT
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|sysmsg
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|num_sysmsg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fault handling */
end_comment

begin_define
define|#
directive|define
name|ENOMEM
value|12
end_define

begin_define
define|#
directive|define
name|ENOEXEC
value|8
end_define

begin_define
define|#
directive|define
name|E2BIG
value|7
end_define

begin_define
define|#
directive|define
name|ENOENT
value|2
end_define

begin_define
define|#
directive|define
name|ETXTBSY
value|26
end_define

begin_comment
comment|/* service routines for `execute' */
end_comment

begin_function
name|VOID
name|initio
parameter_list|(
name|iop
parameter_list|)
name|IOPTR
name|iop
decl_stmt|;
block|{
name|REG
name|STRING
name|ion
decl_stmt|;
name|REG
name|INT
name|iof
decl_stmt|,
name|fd
decl_stmt|;
name|IF
name|iop
name|THEN
name|iof
init|=
name|iop
operator|->
name|iofile
decl_stmt|;
name|ion
operator|=
name|mactrim
argument_list|(
name|iop
operator|->
name|ioname
argument_list|)
expr_stmt|;
name|IF
modifier|*
name|ion
name|ANDF
argument_list|(
name|flags
operator|&
name|noexec
argument_list|)
decl|==0
name|THEN
name|IF
name|iof
modifier|&
name|IODOC
name|THEN
name|subst
argument_list|(
name|chkopen
argument_list|(
name|ion
argument_list|)
argument_list|,
operator|(
name|fd
operator|=
name|tmpfil
argument_list|()
operator|)
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|chkopen
argument_list|(
name|tmpout
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpout
argument_list|)
expr_stmt|;
name|ELIF
name|iof
modifier|&
name|IOMOV
name|THEN
name|IF
name|eq
argument_list|(
name|minus
argument_list|,
name|ion
argument_list|)
name|THEN
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|close
argument_list|(
name|iof
operator|&
name|IOUFD
argument_list|)
expr_stmt|;
name|ELIF
argument_list|(
name|fd
operator|=
name|stoi
argument_list|(
name|ion
argument_list|)
argument_list|)
operator|>=
name|USERIO
name|THEN
name|failed
argument_list|(
name|ion
argument_list|,
name|badfile
argument_list|)
expr_stmt|;
name|ELSE
name|fd
init|=
name|dup
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|FI
name|ELIF
argument_list|(
name|iof
operator|&
name|IOPUT
argument_list|)
decl|==0
name|THEN
name|fd
init|=
name|chkopen
argument_list|(
name|ion
argument_list|)
decl_stmt|;
name|ELIF
name|flags
modifier|&
name|rshflg
name|THEN
name|failed
argument_list|(
name|ion
argument_list|,
name|restricted
argument_list|)
decl_stmt|;
name|ELIF
name|iof
modifier|&
name|IOAPP
name|ANDF
argument_list|(
name|fd
operator|=
name|open
argument_list|(
name|ion
argument_list|,
literal|1
argument_list|)
argument_list|)
decl|>=0
name|THEN
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|ELSE
name|fd
init|=
name|create
argument_list|(
name|ion
argument_list|)
decl_stmt|;
name|FI
name|IF
name|fd
operator|>=
literal|0
name|THEN
name|rename
argument_list|(
name|fd
argument_list|,
name|iof
operator|&
name|IOUFD
argument_list|)
expr_stmt|;
name|FI
name|FI
name|initio
argument_list|(
name|iop
operator|->
name|ionxt
argument_list|)
decl_stmt|;
name|FI
block|}
end_function

begin_function
name|STRING
name|getpath
parameter_list|(
name|s
parameter_list|)
name|STRING
name|s
decl_stmt|;
block|{
name|REG
name|STRING
name|path
decl_stmt|;
name|IF
name|any
argument_list|(
literal|'/'
argument_list|,
name|s
argument_list|)
name|THEN
name|IF
name|flags
modifier|&
name|rshflg
name|THEN
name|failed
argument_list|(
name|s
argument_list|,
name|restricted
argument_list|)
decl_stmt|;
name|ELSE
return|return
operator|(
name|nullstr
operator|)
return|;
name|FI
name|ELIF
argument_list|(
name|path
operator|=
name|pathnod
operator|.
name|namval
argument_list|)
decl|==0
name|THEN
decl|return
argument_list|(
name|defpath
argument_list|)
decl_stmt|;
name|ELSE
return|return
operator|(
name|cpystak
argument_list|(
name|path
argument_list|)
operator|)
return|;
name|FI
block|}
end_function

begin_function
name|INT
name|pathopen
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
name|REG
name|STRING
name|path
decl_stmt|,
name|name
decl_stmt|;
block|{
name|REG
name|UFD
name|f
decl_stmt|;
name|REP
name|path
init|=
name|catpath
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|PER
argument_list|(
name|f
operator|=
name|open
argument_list|(
name|curstak
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
name|ANDF
name|path
name|DONE
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
name|STRING
name|catpath
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
name|REG
name|STRING
name|path
decl_stmt|;
name|STRING
name|name
decl_stmt|;
block|{
comment|/* leaves result on top of stack */
name|REG
name|STRING
name|scanp
init|=
name|path
decl_stmt|,
name|argp
init|=
name|locstak
argument_list|()
decl_stmt|;
name|WHILE
operator|*
name|scanp
name|ANDF
operator|*
name|scanp
operator|!=
name|COLON
name|DO
operator|*
name|argp
operator|++
operator|=
operator|*
name|scanp
operator|++
name|OD
name|IF
name|scanp
operator|!=
name|path
name|THEN
operator|*
name|argp
operator|++
operator|=
literal|'/'
name|FI
name|IF
operator|*
name|scanp
operator|==
name|COLON
name|THEN
name|scanp
operator|++
name|FI
name|path
operator|=
operator|(
operator|*
name|scanp
condition|?
name|scanp
else|:
literal|0
operator|)
expr_stmt|;
name|scanp
operator|=
name|name
expr_stmt|;
name|WHILE
argument_list|(
argument|*argp++ = *scanp++
argument_list|)
name|DONE
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|LOCAL
name|STRING
name|xecmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|STRING
modifier|*
name|xecenv
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|execa
parameter_list|(
name|at
parameter_list|)
name|STRING
name|at
index|[]
decl_stmt|;
block|{
name|REG
name|STRING
name|path
decl_stmt|;
name|REG
name|STRING
modifier|*
name|t
init|=
name|at
decl_stmt|;
name|IF
argument_list|(
name|flags
operator|&
name|noexec
argument_list|)
operator|==
literal|0
name|THEN
name|xecmsg
operator|=
name|notfound
expr_stmt|;
name|path
operator|=
name|getpath
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
name|namscan
argument_list|(
name|exname
argument_list|)
expr_stmt|;
name|xecenv
operator|=
name|setenv
argument_list|()
expr_stmt|;
name|WHILE
name|path
init|=
name|execs
argument_list|(
argument|path
argument_list|,
argument|t
argument_list|)
name|DONE
name|failed
argument_list|(
operator|*
name|t
argument_list|,
name|xecmsg
argument_list|)
decl_stmt|;
name|FI
block|}
end_function

begin_function
name|LOCAL
name|STRING
name|execs
parameter_list|(
name|ap
parameter_list|,
name|t
parameter_list|)
name|STRING
name|ap
decl_stmt|;
name|REG
name|STRING
name|t
index|[]
decl_stmt|;
block|{
name|REG
name|STRING
name|p
decl_stmt|,
name|prefix
decl_stmt|;
name|prefix
operator|=
name|catpath
argument_list|(
name|ap
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|p
operator|=
name|curstak
argument_list|()
argument_list|)
expr_stmt|;
name|sigchk
argument_list|()
expr_stmt|;
name|execve
argument_list|(
name|p
argument_list|,
operator|&
name|t
index|[
literal|0
index|]
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
name|SWITCH
name|errno
name|IN
case|case
name|ENOEXEC
case|:
name|flags
operator|=
literal|0
expr_stmt|;
name|comdiv
operator|=
literal|0
expr_stmt|;
name|ioset
operator|=
literal|0
expr_stmt|;
name|clearup
argument_list|()
expr_stmt|;
comment|/* remove open files and for loop junk */
name|IF
name|input
name|THEN
name|close
argument_list|(
name|input
argument_list|)
name|FI
name|close
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|output
operator|=
literal|2
expr_stmt|;
name|input
operator|=
name|chkopen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* band aid to get csh... 2/26/79 */
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|input
argument_list|)
condition|)
block|{
name|read
argument_list|(
name|input
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|gocsh
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|input
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set up new args */
name|setargs
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|subshell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
name|ENOMEM
case|:
name|failed
argument_list|(
name|p
argument_list|,
name|toobig
argument_list|)
expr_stmt|;
case|case
name|E2BIG
case|:
name|failed
argument_list|(
name|p
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
case|case
name|ETXTBSY
case|:
name|failed
argument_list|(
name|p
argument_list|,
name|txtbsy
argument_list|)
expr_stmt|;
default|default:
name|xecmsg
operator|=
name|badexec
expr_stmt|;
case|case
name|ENOENT
case|:
return|return
operator|(
name|prefix
operator|)
return|;
name|ENDSW
block|}
end_function

begin_expr_stmt
name|gocsh
argument_list|(
name|t
argument_list|,
name|cp
argument_list|,
name|xecenv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|t
operator|,
operator|*
name|cp
operator|,
operator|*
operator|*
name|xecenv
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|newt
index|[
literal|1000
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|newt
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|t
index|[
name|i
index|]
expr_stmt|;
name|newt
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|newt
index|[
literal|0
index|]
operator|=
literal|"/bin/csh"
expr_stmt|;
name|newt
index|[
literal|1
index|]
operator|=
name|cp
expr_stmt|;
name|execve
argument_list|(
literal|"/bin/csh"
argument_list|,
name|newt
argument_list|,
name|xecenv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* for processes to be waited for */
end_comment

begin_define
define|#
directive|define
name|MAXP
value|20
end_define

begin_decl_stmt
name|LOCAL
name|INT
name|pwlist
index|[
name|MAXP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|INT
name|pwc
decl_stmt|;
end_decl_stmt

begin_macro
name|postclr
argument_list|()
end_macro

begin_block
block|{
name|REG
name|INT
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
name|WHILE
name|pw
operator|<=
operator|&
name|pwlist
index|[
name|pwc
index|]
name|DO
operator|*
name|pw
operator|++
operator|=
literal|0
name|OD
name|pwc
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|VOID
name|post
parameter_list|(
name|pcsid
parameter_list|)
name|INT
name|pcsid
decl_stmt|;
block|{
name|REG
name|INT
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
name|IF
name|pcsid
name|THEN
name|WHILE
operator|*
name|pw
name|DO
name|pw
operator|++
name|OD
name|IF
name|pwc
operator|>=
name|MAXP
operator|-
literal|1
name|THEN
name|pw
operator|--
expr_stmt|;
name|ELSE
name|pwc
operator|++
expr_stmt|;
name|FI
modifier|*
name|pw
init|=
name|pcsid
decl_stmt|;
name|FI
block|}
end_function

begin_function
name|VOID
name|await
parameter_list|(
name|i
parameter_list|)
name|INT
name|i
decl_stmt|;
block|{
name|INT
name|rc
init|=
literal|0
decl_stmt|,
name|wx
init|=
literal|0
decl_stmt|;
name|INT
name|w
decl_stmt|;
name|INT
name|ipwc
init|=
name|pwc
decl_stmt|;
name|post
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|WHILE
name|pwc
name|DO
name|REG
name|INT
name|p
decl_stmt|;
name|REG
name|INT
name|sig
decl_stmt|;
name|INT
name|w_hi
decl_stmt|;
name|BEGIN
name|REG
name|INT
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
name|IF
name|setjmp
argument_list|(
name|INTbuf
argument_list|)
decl|== 0
name|THEN
name|trapjmp
index|[
name|INTR
index|]
init|=
literal|1
decl_stmt|;
name|p
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
name|ELSE
name|p
init|=
operator|-
literal|1
decl_stmt|;
name|FI
name|trapjmp
index|[
name|INTR
index|]
init|=
literal|0
decl_stmt|;
name|WHILE
name|pw
operator|<=
operator|&
name|pwlist
index|[
name|ipwc
index|]
name|DO
name|IF
operator|*
name|pw
operator|==
name|p
name|THEN
operator|*
name|pw
operator|=
literal|0
expr_stmt|;
name|pwc
operator|--
expr_stmt|;
name|ELSE
name|pw
operator|++
expr_stmt|;
name|FI
name|OD
name|END
name|IF
name|p
operator|==
operator|-
literal|1
name|THEN
continue|continue
name|FI
name|w_hi
continue|= (
name|w
continue|>>8
block|)
function|&LOBYTE;
end_function

begin_decl_stmt
name|IF
name|sig
init|=
name|w
operator|&
literal|0177
name|THEN
name|IF
name|sig
operator|==
literal|0177
comment|/* ptrace! return */
name|THEN
name|prs
argument_list|(
literal|"ptrace: "
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|sig
operator|=
name|w_hi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FI
name|IF
name|sig
operator|<
name|num_sysmsg
name|ANDF
name|sysmsg
index|[
name|sig
index|]
name|THEN
name|IF
name|i
operator|!=
name|p
name|ORF
argument_list|(
name|flags
operator|&
name|prompt
argument_list|)
operator|==
literal|0
name|THEN
name|prp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|prn
argument_list|(
name|p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|blank
argument_list|()
end_macro

begin_function_decl
name|FI
name|prs
parameter_list|(
name|sysmsg
index|[
name|sig
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|IF
name|w
operator|&
literal|0200
name|THEN
name|prs
argument_list|(
argument|coredump
argument_list|)
name|FI
name|FI
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FI
name|IF
name|rc
operator|==
literal|0
name|THEN
name|rc
operator|=
operator|(
name|sig
condition|?
name|sig
operator||
name|SIGFLG
else|:
name|w_hi
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FI
name|wx
operator||=
name|w
expr_stmt|;
end_expr_stmt

begin_function_decl
name|OD
name|IF
name|wx
name|ANDF
name|flags
modifier|&
name|errflg
name|THEN
name|exitsh
parameter_list|(
name|rc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|FI
name|exitval
init|=
name|rc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|exitset
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  BOOL
name|nosubst
expr_stmt|;
end_expr_stmt

begin_macro
name|trim
argument_list|(
argument|at
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|at
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|STRING
name|p
decl_stmt|;
name|REG
name|CHAR
name|c
decl_stmt|;
name|REG
name|CHAR
name|q
init|=
literal|0
decl_stmt|;
name|IF
name|p
init|=
name|at
name|THEN
name|WHILE
name|c
operator|=
operator|*
name|p
name|DO
operator|*
name|p
operator|++
operator|=
name|c
operator|&
name|STRIP
decl_stmt|;
name|q
operator||=
name|c
name|OD
name|FI
name|nosubst
operator|=
name|q
operator|&
name|QUOTE
expr_stmt|;
block|}
end_block

begin_function
name|STRING
name|mactrim
parameter_list|(
name|s
parameter_list|)
name|STRING
name|s
decl_stmt|;
block|{
name|REG
name|STRING
name|t
init|=
name|macro
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|trim
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|STRING
modifier|*
name|scan
parameter_list|(
name|argn
parameter_list|)
name|INT
name|argn
decl_stmt|;
block|{
name|REG
name|ARGPTR
name|argp
init|=
name|Rcheat
argument_list|(
name|gchain
argument_list|)
operator|&
operator|~
name|ARGMK
decl_stmt|;
name|REG
name|STRING
modifier|*
name|comargn
decl_stmt|,
modifier|*
name|comargm
decl_stmt|;
name|comargn
operator|=
name|getstak
argument_list|(
name|BYTESPERWORD
operator|*
name|argn
operator|+
name|BYTESPERWORD
argument_list|)
expr_stmt|;
name|comargm
operator|=
name|comargn
operator|+=
name|argn
expr_stmt|;
operator|*
name|comargn
operator|=
name|ENDARGS
expr_stmt|;
name|WHILE
name|argp
name|DO
operator|*
operator|--
name|comargn
operator|=
name|argp
operator|->
name|argval
expr_stmt|;
name|IF
name|argp
init|=
name|argp
operator|->
name|argnxt
name|THEN
name|trim
argument_list|(
operator|*
name|comargn
argument_list|)
decl_stmt|;
name|FI
name|IF
name|argp
operator|==
literal|0
name|ORF
name|Rcheat
argument_list|(
name|argp
argument_list|)
operator|&
name|ARGMK
name|THEN
name|gsort
argument_list|(
name|comargn
argument_list|,
name|comargm
argument_list|)
expr_stmt|;
name|comargm
operator|=
name|comargn
expr_stmt|;
name|FI
comment|/* Lcheat(argp)&= ~ARGMK; */
name|argp
init|=
name|Rcheat
argument_list|(
name|argp
argument_list|)
operator|&
operator|~
name|ARGMK
decl_stmt|;
name|OD
return|return
operator|(
name|comargn
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|LOCAL
name|VOID
name|gsort
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
name|STRING
name|from
index|[]
decl_stmt|,
name|to
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INT
name|k
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
name|REG
name|INT
name|i
decl_stmt|,
name|j
decl_stmt|;
name|IF
argument_list|(
name|n
operator|=
name|to
operator|-
name|from
argument_list|)
operator|<=
literal|1
name|THEN
return|return
name|FI
name|FOR
name|j
operator|=
literal|1
return|;
name|j
operator|<=
name|n
expr_stmt|;
name|j
operator|*=
literal|2
name|DONE
name|FOR
name|m
operator|=
literal|2
operator|*
name|j
operator|-
literal|1
expr_stmt|;
name|m
operator|/=
literal|2
expr_stmt|;
name|DO
name|k
init|=
name|n
operator|-
name|m
decl_stmt|;
name|FOR
name|j
init|=
literal|0
decl_stmt|;
name|j
operator|<
name|k
expr_stmt|;
name|j
operator|++
name|DO
name|FOR
name|i
operator|=
name|j
expr_stmt|;
name|i
operator|>=
literal|0
expr_stmt|;
name|i
operator|-=
name|m
name|DO
name|REG
name|STRING
operator|*
name|fromi
expr_stmt|;
name|fromi
operator|=
operator|&
name|from
index|[
name|i
index|]
expr_stmt|;
name|IF
name|cf
argument_list|(
name|fromi
index|[
name|m
index|]
argument_list|,
name|fromi
index|[
literal|0
index|]
argument_list|)
decl|>0
name|THEN
decl|break
decl_stmt|;
name|ELSE
name|STRING
name|s
decl_stmt|;
name|s
operator|=
name|fromi
index|[
name|m
index|]
expr_stmt|;
name|fromi
index|[
name|m
index|]
operator|=
name|fromi
index|[
literal|0
index|]
expr_stmt|;
name|fromi
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|FI
name|OD
name|OD
name|OD
block|}
end_block

begin_comment
comment|/* Argument list generation */
end_comment

begin_function
name|INT
name|getarg
parameter_list|(
name|ac
parameter_list|)
name|COMPTR
name|ac
decl_stmt|;
block|{
name|REG
name|ARGPTR
name|argp
decl_stmt|;
name|REG
name|INT
name|count
init|=
literal|0
decl_stmt|;
name|REG
name|COMPTR
name|c
decl_stmt|;
name|IF
name|c
init|=
name|ac
name|THEN
name|argp
operator|=
name|c
operator|->
name|comarg
decl_stmt|;
name|WHILE
name|argp
name|DO
name|count
operator|+=
name|split
argument_list|(
name|macro
argument_list|(
name|argp
operator|->
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|argp
operator|=
name|argp
operator|->
name|argnxt
expr_stmt|;
name|OD
name|FI
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|INT
name|split
parameter_list|(
name|s
parameter_list|)
name|REG
name|STRING
name|s
decl_stmt|;
block|{
name|REG
name|STRING
name|argp
decl_stmt|;
name|REG
name|INT
name|c
decl_stmt|;
name|INT
name|count
init|=
literal|0
decl_stmt|;
name|LOOP
name|sigchk
parameter_list|()
function_decl|;
name|argp
operator|=
name|locstak
argument_list|()
operator|+
name|BYTESPERWORD
expr_stmt|;
name|WHILE
argument_list|(
argument|c = *s++
argument_list|,
argument|!any(c,ifsnod.namval)&& c
argument_list|)
name|DO
operator|*
name|argp
operator|++
operator|=
name|c
name|OD
name|IF
name|argp
operator|==
name|staktop
operator|+
name|BYTESPERWORD
name|THEN
name|IF
name|c
name|THEN
continue|continue;
name|ELSE
return|return
operator|(
name|count
operator|)
return|;
name|FI
name|ELIF
name|c
operator|==
literal|0
name|THEN
name|s
operator|--
expr_stmt|;
name|FI
name|IF
name|c
init|=
name|expand
argument_list|(
argument|((ARGPTR)(argp=endstak(argp)))->argval
argument_list|,
literal|0
argument_list|)
name|THEN
name|count
operator|+=
name|c
decl_stmt|;
name|ELSE
comment|/* assign(&fngnod, argp->argval); */
name|makearg
argument_list|(
name|argp
argument_list|)
decl_stmt|;
name|count
operator|++
expr_stmt|;
name|FI
name|Lcheat
argument_list|(
name|gchain
argument_list|)
decl||=
name|ARGMK
decl_stmt|;
name|POOL
block|}
end_function

end_unit

