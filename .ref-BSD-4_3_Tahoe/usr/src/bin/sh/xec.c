begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)xec.c	4.6 4/24/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_decl_stmt
name|LOCAL
name|INT
name|parent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYSTAB
name|commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========	command execution	========*/
end_comment

begin_macro
name|execute
argument_list|(
argument|argt
argument_list|,
argument|execflg
argument_list|,
argument|pf1
argument_list|,
argument|pf2
argument_list|)
end_macro

begin_decl_stmt
name|TREPTR
name|argt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
modifier|*
name|pf1
decl_stmt|,
modifier|*
name|pf2
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* `stakbot' is preserved by this routine */
name|REG
name|TREPTR
name|t
decl_stmt|;
name|STKPTR
name|sav
init|=
name|savstak
argument_list|()
decl_stmt|;
name|sigchk
argument_list|()
expr_stmt|;
name|IF
argument_list|(
argument|t=argt
argument_list|)
name|ANDF
name|execbrk
operator|==
literal|0
name|THEN
name|REG
name|INT
name|treeflgs
expr_stmt|;
name|INT
name|oldexit
decl_stmt|,
name|type
decl_stmt|;
name|REG
name|STRING
modifier|*
name|com
decl_stmt|;
name|treeflgs
operator|=
name|t
operator|->
name|tretyp
expr_stmt|;
name|type
operator|=
name|treeflgs
operator|&
name|COMMSK
expr_stmt|;
name|oldexit
operator|=
name|exitval
expr_stmt|;
name|exitval
operator|=
literal|0
expr_stmt|;
name|SWITCH
name|type
name|IN
case|case
name|TCOM
case|:
name|BEGIN
name|STRING
name|a1
decl_stmt|;
name|INT
name|argn
decl_stmt|,
name|internal
decl_stmt|;
name|ARGPTR
name|schain
init|=
name|gchain
decl_stmt|;
name|IOPTR
name|io
init|=
name|t
operator|->
name|treio
operator|.
name|treio
decl_stmt|;
name|gchain
operator|=
literal|0
expr_stmt|;
name|argn
operator|=
name|getarg
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|com
operator|=
name|scan
argument_list|(
name|argn
argument_list|)
expr_stmt|;
name|a1
operator|=
name|com
index|[
literal|1
index|]
expr_stmt|;
name|gchain
operator|=
name|schain
expr_stmt|;
name|IF
name|argn
operator|==
literal|0
name|ORF
argument_list|(
argument|internal=syslook(com[
literal|0
argument|],commands)
argument_list|)
name|THEN
name|setlist
argument_list|(
name|t
operator|->
name|comnod
operator|.
name|comset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FI
name|IF
name|argn
name|ANDF
argument_list|(
name|flags
operator|&
name|noexec
argument_list|)
decl|==0
name|THEN
comment|/* print command if execpr */
name|IF
name|flags
modifier|&
name|execpr
name|THEN
name|argn
init|=
literal|0
decl_stmt|;
name|prs
argument_list|(
name|execpmsg
argument_list|)
expr_stmt|;
name|WHILE
name|com
index|[
name|argn
index|]
operator|!=
name|ENDARGS
name|DO
name|prs
argument_list|(
name|com
index|[
name|argn
operator|++
index|]
argument_list|)
expr_stmt|;
name|blank
argument_list|()
name|OD
name|newline
parameter_list|()
function_decl|;
name|FI
name|SWITCH
name|internal
name|IN
case|case
name|SYSDOT
case|:
name|IF
name|a1
name|THEN
name|REG
name|INT
name|f
decl_stmt|;
name|IF
argument_list|(
name|f
operator|=
name|pathopen
argument_list|(
name|getpath
argument_list|(
name|a1
argument_list|)
argument_list|,
name|a1
argument_list|)
argument_list|)
operator|<
literal|0
name|THEN
name|failed
argument_list|(
name|a1
argument_list|,
name|notfound
argument_list|)
expr_stmt|;
name|ELSE
name|execexp
argument_list|(
literal|0
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|FI
name|FI
break|break;
case|case
name|SYSTIMES
case|:
block|{
name|L_INT
name|t
index|[
literal|4
index|]
decl_stmt|;
name|times
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|prt
argument_list|(
name|t
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|blank
argument_list|()
expr_stmt|;
name|prt
argument_list|(
name|t
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|SYSEXIT
case|:
name|exitsh
argument_list|(
name|a1
condition|?
name|stoi
argument_list|(
name|a1
argument_list|)
else|:
name|oldexit
argument_list|)
expr_stmt|;
case|case
name|SYSNULL
case|:
name|io
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SYSCONT
case|:
name|execbrk
operator|=
operator|-
name|loopcnt
expr_stmt|;
break|break;
case|case
name|SYSBREAK
case|:
name|IF
argument_list|(
argument|execbrk=loopcnt
argument_list|)
name|ANDF
name|a1
name|THEN
name|breakcnt
init|=
name|stoi
argument_list|(
name|a1
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
name|SYSTRAP
case|:
name|IF
name|a1
name|THEN
name|BOOL
name|clear
decl_stmt|;
name|IF
argument_list|(
name|clear
operator|=
name|digit
argument_list|(
operator|*
name|a1
argument_list|)
argument_list|)
operator|==
literal|0
name|THEN
operator|++
name|com
expr_stmt|;
name|FI
name|WHILE
operator|*
operator|++
name|com
name|DO
name|INT
name|i
expr_stmt|;
name|IF
argument_list|(
name|i
operator|=
name|stoi
argument_list|(
operator|*
name|com
argument_list|)
argument_list|)
operator|>=
name|MAXTRAP
name|ORF
name|i
operator|<
name|MINTRAP
name|THEN
name|failed
argument_list|(
operator|*
name|com
argument_list|,
name|badtrap
argument_list|)
expr_stmt|;
name|ELIF
name|clear
name|THEN
name|clrsig
parameter_list|(
name|i
parameter_list|)
function_decl|;
name|ELSE
name|replace
argument_list|(
operator|&
name|trapcom
index|[
name|i
index|]
argument_list|,
name|a1
argument_list|)
decl_stmt|;
name|IF
modifier|*
name|a1
name|THEN
name|getsig
parameter_list|(
name|i
parameter_list|)
function_decl|;
name|ELSE
name|ignsig
parameter_list|(
name|i
parameter_list|)
function_decl|;
name|FI
name|FI
name|OD
name|ELSE
comment|/* print out current traps */
name|INT
name|i
decl_stmt|;
name|FOR
name|i
init|=
literal|0
decl_stmt|;
name|i
operator|<
name|MAXTRAP
expr_stmt|;
name|i
operator|++
name|DO
name|IF
name|trapcom
index|[
name|i
index|]
name|THEN
name|prn
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|colon
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|trapcom
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|FI
name|OD
name|FI
break|break;
case|case
name|SYSEXEC
case|:
name|com
operator|++
expr_stmt|;
name|initio
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|ioset
operator|=
literal|0
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|IF
name|a1
operator|==
literal|0
name|THEN
break|break
name|FI
name|case SYSLOGIN: 					flags |= forked
break|;
name|oldsigs
argument_list|()
expr_stmt|;
name|execa
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
case|case
name|SYSCD
case|:
name|IF
name|flags
modifier|&
name|rshflg
name|THEN
name|failed
parameter_list|(
name|com
index|[
literal|0
index|]
parameter_list|,
name|restricted
parameter_list|)
function_decl|;
name|ELIF
argument_list|(
argument|a1==
literal|0
argument|ANDF (a1=homenod.namval)==
literal|0
argument_list|)
name|ORF
name|chdir
argument_list|(
name|a1
argument_list|)
decl|<0
name|THEN
name|failed
argument_list|(
name|a1
argument_list|,
name|baddir
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
name|SYSSHFT
case|:
name|IF
name|dolc
operator|<
literal|1
name|THEN
name|error
argument_list|(
name|badshift
argument_list|)
expr_stmt|;
name|ELSE
name|dolv
operator|++
expr_stmt|;
name|dolc
operator|--
expr_stmt|;
name|FI
name|assnum
argument_list|(
operator|&
name|dolladr
argument_list|,
name|dolc
argument_list|)
decl_stmt|;
break|break;
case|case
name|SYSWAIT
case|:
name|await
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSREAD
case|:
name|exitval
operator|=
name|readvar
argument_list|(
operator|&
name|com
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
comment|/* 				case SYSTST: 					exitval=testcmd(com); 					break; */
case|case
name|SYSSET
case|:
name|IF
name|a1
name|THEN
name|INT
name|argc
decl_stmt|;
name|argc
operator|=
name|options
argument_list|(
name|argn
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|IF
name|argc
operator|>
literal|1
name|THEN
name|setargs
argument_list|(
name|com
operator|+
name|argn
operator|-
name|argc
argument_list|)
expr_stmt|;
name|FI
name|ELIF
name|t
operator|->
name|comnod
operator|.
name|comset
operator|==
literal|0
name|THEN
comment|/*scan name chain and print*/
name|namscan
argument_list|(
name|printnam
argument_list|)
expr_stmt|;
name|FI
break|break;
case|case
name|SYSRDONLY
case|:
name|exitval
operator|=
name|N_RDONLY
expr_stmt|;
case|case
name|SYSXPORT
case|:
name|IF
name|exitval
operator|==
literal|0
name|THEN
name|exitval
operator|=
name|N_EXPORT
expr_stmt|;
name|FI
name|IF
name|a1
name|THEN
name|WHILE
operator|*
operator|++
name|com
name|DO
name|attrib
argument_list|(
argument|lookup(*com)
argument_list|,
argument|exitval
argument_list|)
name|OD
name|ELSE
name|namscan
argument_list|(
name|printflg
argument_list|)
expr_stmt|;
name|FI
name|exitval
init|=
literal|0
decl_stmt|;
break|break;
case|case
name|SYSEVAL
case|:
name|IF
name|a1
name|THEN
name|execexp
argument_list|(
name|a1
argument_list|,
operator|&
name|com
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
name|SYSUMASK
case|:
if|if
condition|(
name|a1
condition|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|a1
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|umask
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|umask
argument_list|(
name|i
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|6
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|3
control|)
name|prc
argument_list|(
operator|(
operator|(
name|i
operator|>>
name|j
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|internal
operator|=
name|builtin
argument_list|(
name|argn
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|ENDSW
name|IF
name|internal
name|THEN
name|IF
name|io
name|THEN
name|error
argument_list|(
name|illegal
argument_list|)
name|FI
name|chktrap
argument_list|()
decl_stmt|;
break|break;
name|FI
name|ELIF
name|t
operator|->
name|treio
operator|.
name|treio
operator|==
literal|0
name|THEN
break|break;
name|FI
name|END
case|case
name|TFORK
case|:
name|IF
name|execflg
name|ANDF
argument_list|(
name|treeflgs
operator|&
operator|(
name|FAMP
operator||
name|FPOU
operator|)
argument_list|)
decl|==0
name|THEN
name|parent
init|=
literal|0
decl_stmt|;
name|ELSE
name|WHILE
argument_list|(
name|parent
operator|=
name|fork
argument_list|()
argument_list|)
decl|== -1
name|DO
name|sigchk
argument_list|()
decl_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|pause
argument_list|()
name|OD
name|FI
name|IF
name|parent
name|THEN
comment|/* This is the parent branch of fork;    */
comment|/* it may or may not wait for the child. */
name|IF
name|treeflgs
modifier|&
name|FPRS
name|ANDF
name|flags
modifier|&
name|ttyflg
name|THEN
name|prn
parameter_list|(
name|parent
parameter_list|)
function_decl|;
name|newline
argument_list|()
expr_stmt|;
name|FI
name|IF
name|treeflgs
modifier|&
name|FPCL
name|THEN
name|closepipe
argument_list|(
name|pf1
argument_list|)
name|FI
name|IF
argument_list|(
name|treeflgs
operator|&
operator|(
name|FAMP
operator||
name|FPOU
operator|)
argument_list|)
decl|==0
name|THEN
name|await
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|ELIF
argument_list|(
name|treeflgs
operator|&
name|FAMP
argument_list|)
operator|==
literal|0
name|THEN
name|post
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|ELSE
name|assnum
argument_list|(
operator|&
name|pcsadr
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|FI
name|chktrap
parameter_list|()
function_decl|;
break|break;
name|ELSE
comment|/* this is the forked branch (child) of execute */
name|flags
operator||=
name|forked
expr_stmt|;
name|iotemp
operator|=
literal|0
expr_stmt|;
name|postclr
argument_list|()
expr_stmt|;
name|settmp
argument_list|()
expr_stmt|;
comment|/* Turn off INTR and QUIT if `FINT'  */
comment|/* Reset ramaining signals to parent */
comment|/* except for those `lost' by trap   */
name|oldsigs
argument_list|()
expr_stmt|;
name|IF
name|treeflgs
modifier|&
name|FINT
name|THEN
name|signal
argument_list|(
name|INTR
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|signal
argument_list|(
name|QUIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FI
comment|/* pipe in or out */
name|IF
name|treeflgs
modifier|&
name|FPIN
name|THEN
name|rename
argument_list|(
name|pf1
index|[
name|INPIPE
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|pf1
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
name|FI
name|IF
name|treeflgs
modifier|&
name|FPOU
name|THEN
name|rename
argument_list|(
name|pf2
index|[
name|OTPIPE
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|pf2
index|[
name|INPIPE
index|]
argument_list|)
expr_stmt|;
name|FI
comment|/* default std input for& */
name|IF
name|treeflgs
operator|&
name|FINT
name|ANDF
name|ioset
operator|==
literal|0
name|THEN
name|rename
argument_list|(
name|chkopen
argument_list|(
name|devnull
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FI
comment|/* io redirection */
name|initio
parameter_list|(
name|t
operator|->
name|treio
operator|.
name|treio
parameter_list|)
function_decl|;
name|IF
name|type
operator|!=
name|TCOM
name|THEN
name|execute
argument_list|(
name|t
operator|->
name|forknod
operator|.
name|forktre
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ELIF
name|com
index|[
literal|0
index|]
operator|!=
name|ENDARGS
name|THEN
name|setlist
argument_list|(
name|t
operator|->
name|comnod
operator|.
name|comset
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
name|execa
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|FI
name|done
parameter_list|()
function_decl|;
name|FI
case|case
name|TPAR
case|:
name|rename
argument_list|(
name|dup
argument_list|(
literal|2
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|parnod
operator|.
name|partre
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
case|case
name|TFIL
case|:
name|BEGIN
name|INT
name|pv
index|[
literal|2
index|]
decl_stmt|;
name|chkpipe
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|IF
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstlef
argument_list|,
literal|0
argument_list|,
name|pf1
argument_list|,
name|pv
argument_list|)
decl|==0
name|THEN
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstrit
argument_list|,
name|execflg
argument_list|,
name|pv
argument_list|,
name|pf2
argument_list|)
decl_stmt|;
name|ELSE
name|closepipe
parameter_list|(
name|pv
parameter_list|)
function_decl|;
name|FI
name|END
break|break;
case|case
name|TLST
case|:
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstlef
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstrit
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAND
case|:
name|IF
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstlef
argument_list|,
literal|0
argument_list|)
decl|==0
name|THEN
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstrit
argument_list|,
name|execflg
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
name|TORF
case|:
name|IF
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstlef
argument_list|,
literal|0
argument_list|)
decl|!=0
name|THEN
name|execute
argument_list|(
name|t
operator|->
name|lstnod
operator|.
name|lstrit
argument_list|,
name|execflg
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
name|TFOR
case|:
name|BEGIN
name|NAMPTR
name|n
init|=
name|lookup
argument_list|(
name|t
operator|->
name|fornod
operator|.
name|fornam
argument_list|)
decl_stmt|;
name|STRING
modifier|*
name|args
decl_stmt|;
name|DOLPTR
name|argsav
init|=
literal|0
decl_stmt|;
name|IF
name|t
operator|->
name|fornod
operator|.
name|forlst
operator|==
literal|0
name|THEN
name|args
operator|=
name|dolv
operator|+
literal|1
expr_stmt|;
name|argsav
operator|=
name|useargs
argument_list|()
expr_stmt|;
name|ELSE
name|ARGPTR
name|schain
init|=
name|gchain
decl_stmt|;
name|gchain
operator|=
literal|0
expr_stmt|;
name|trim
argument_list|(
operator|(
name|args
operator|=
name|scan
argument_list|(
name|getarg
argument_list|(
name|t
operator|->
name|fornod
operator|.
name|forlst
argument_list|)
argument_list|)
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gchain
operator|=
name|schain
expr_stmt|;
name|FI
name|loopcnt
operator|++
expr_stmt|;
name|WHILE
operator|*
name|args
operator|!=
name|ENDARGS
name|ANDF
name|execbrk
operator|==
literal|0
name|DO
name|assign
argument_list|(
name|n
argument_list|,
operator|*
name|args
operator|++
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|fornod
operator|.
name|fortre
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IF
name|execbrk
operator|<
literal|0
name|THEN
name|execbrk
operator|=
literal|0
name|FI
name|OD
name|IF
name|breakcnt
name|THEN
name|breakcnt
operator|--
name|FI
name|execbrk
operator|=
name|breakcnt
expr_stmt|;
name|loopcnt
operator|--
expr_stmt|;
name|argfor
operator|=
name|freeargs
argument_list|(
name|argsav
argument_list|)
expr_stmt|;
name|END
break|break;
case|case
name|TWH
case|:
case|case
name|TUN
case|:
name|BEGIN
name|INT
name|i
init|=
literal|0
decl_stmt|,
name|saveflg
decl_stmt|;
name|saveflg
operator|=
name|flags
operator|&
name|errflg
expr_stmt|;
name|loopcnt
operator|++
expr_stmt|;
name|WHILE
name|execbrk
operator|==
literal|0
name|DO
name|flags
operator|&=
operator|~
name|errflg
expr_stmt|;
name|i
operator|=
name|execute
argument_list|(
name|t
operator|->
name|whnod
operator|.
name|whtre
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator||=
name|saveflg
expr_stmt|;
name|IF
argument_list|(
name|i
operator|==
literal|0
argument_list|)
operator|!=
operator|(
name|type
operator|==
name|TWH
operator|)
name|THEN
break|break
name|FI
name|i
break|=
name|execute
break|(
name|t
operator|->
name|whnod
operator|.
name|dotre
operator|,
break|0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|IF
name|execbrk
operator|<
literal|0
name|THEN
name|execbrk
operator|=
literal|0
name|FI
name|OD
name|IF
name|breakcnt
name|THEN
name|breakcnt
operator|--
name|FI
name|execbrk
operator|=
name|breakcnt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|loopcnt
operator|--
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|exitval
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_macro
name|END
end_macro

begin_break
break|break;
end_break

begin_case
case|case
name|TIF
case|:
end_case

begin_decl_stmt
name|BEGIN
name|INT
name|i
decl_stmt|,
name|saveflg
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|saveflg
operator|=
name|flags
operator|&
name|errflg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flags
operator|&=
operator|~
name|errflg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
name|execute
argument_list|(
name|t
operator|->
name|ifnod
operator|.
name|iftre
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flags
operator||=
name|saveflg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IF
name|i
operator|==
literal|0
name|THEN
name|execute
argument_list|(
name|t
operator|->
name|ifnod
operator|.
name|thtre
argument_list|,
name|execflg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ELSE
name|execute
parameter_list|(
name|t
operator|->
name|ifnod
operator|.
name|eltre
parameter_list|,
name|execflg
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|FI
name|END
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|TSW
case|:
end_case

begin_decl_stmt
name|BEGIN
name|REG
name|STRING
name|r
init|=
name|mactrim
argument_list|(
name|t
operator|->
name|swnod
operator|.
name|swarg
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REG
name|REGPTR
name|eg
init|=
name|t
operator|->
name|swnod
operator|.
name|swlst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WHILE
name|eg
name|DO
name|ARGPTR
name|rex
init|=
name|eg
operator|->
name|regptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WHILE
name|rex
name|DO
name|REG
name|STRING
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IF
name|gmatch
argument_list|(
name|r
argument_list|,
name|s
operator|=
name|macro
argument_list|(
name|rex
operator|->
name|argval
argument_list|)
argument_list|)
name|ORF
argument_list|(
name|trim
argument_list|(
name|s
argument_list|)
argument_list|,
name|eq
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
argument_list|)
name|THEN
name|execute
argument_list|(
name|eg
operator|->
name|regcom
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|eg
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_decl_stmt
name|ELSE
name|rex
init|=
name|rex
operator|->
name|argnxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FI
name|OD
name|IF
name|eg
name|THEN
name|eg
init|=
name|eg
operator|->
name|regnxt
name|FI
name|OD
name|END
end_decl_stmt

begin_break
break|break;
end_break

begin_function_decl
name|ENDSW
name|exitset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FI
name|sigchk
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|tdystak
argument_list|(
name|sav
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|exitval
operator|)
return|;
end_return

begin_expr_stmt
unit|}   execexp
operator|(
name|s
operator|,
name|f
operator|)
name|STRING
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|UFD
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILEBLK
name|fb
decl_stmt|;
name|push
argument_list|(
operator|&
name|fb
argument_list|)
expr_stmt|;
name|IF
name|s
name|THEN
name|estabf
parameter_list|(
name|s
parameter_list|)
function_decl|;
name|fb
operator|.
name|feval
operator|=
name|f
expr_stmt|;
name|ELIF
name|f
operator|>=
literal|0
name|THEN
name|initf
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|FI
name|execute
argument_list|(
name|cmd
argument_list|(
name|NL
argument_list|,
name|NLFLG
operator||
name|MTFLG
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

