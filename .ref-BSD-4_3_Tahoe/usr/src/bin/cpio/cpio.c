begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	Copyright (c) 1988 AT&T	*/
end_comment

begin_comment
comment|/*	  All Rights Reserved  	*/
end_comment

begin_comment
comment|/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
end_comment

begin_comment
comment|/*	The copyright notice above does not evidence any   	*/
end_comment

begin_comment
comment|/*	actual or intended publication of such source code.	*/
end_comment

begin_empty
empty|#ident	"@(#)cpio:cpio.c	1.30.1.11"
end_empty

begin_comment
comment|/*	/sccs/src/cmd/s.cpio.c 	cpio.c	1.30.1.11	1/11/86 13:46:48 	Reworked cpio which uses getopt(3) to interpret flag arguments and 	changes reels to the save file name. 	Performance and size improvements. */
end_comment

begin_comment
comment|/*	cpio	COMPILE:	cc -O cpio.c -s -i -o cpio -lgen -lerr 	cpio -- copy file collections  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_struct
struct|struct
name|utimbuf
block|{
name|time_t
name|actime
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|S_IFIFO
end_ifndef

begin_define
define|#
directive|define
name|S_IFIFO
value|010000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EQ
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(strcmp(x,y)==0)
end_define

begin_comment
comment|/* MKSHORT:  for VAX, Interdata, ...	*/
end_comment

begin_comment
comment|/* Take a 4-byte long, lv, and turn it	*/
end_comment

begin_comment
comment|/* into an array of two 2-byte shorts, v*/
end_comment

begin_define
define|#
directive|define
name|MKSHORT
parameter_list|(
name|v
parameter_list|,
name|lv
parameter_list|)
value|{U.l=1L;if(U.c[0]) U.l=lv,v[0]=U.s[1],v[1]=U.s[0]; else U.l=lv,v[0]=U.s[0],v[1]=U.s[1];}
end_define

begin_define
define|#
directive|define
name|MAGIC
value|070707
end_define

begin_comment
comment|/* cpio magic number */
end_comment

begin_define
define|#
directive|define
name|BSMAGIC
value|0143561
end_define

begin_comment
comment|/* byte-swapped cpio magic number */
end_comment

begin_define
define|#
directive|define
name|IN
value|'i'
end_define

begin_comment
comment|/* copy in */
end_comment

begin_define
define|#
directive|define
name|OUT
value|'o'
end_define

begin_comment
comment|/* copy out */
end_comment

begin_define
define|#
directive|define
name|PASS
value|'p'
end_define

begin_comment
comment|/* direct copy */
end_comment

begin_define
define|#
directive|define
name|HDRSIZE
value|(Hdr.h_name - (char *)&Hdr)
end_define

begin_comment
comment|/* header size minus filename field */
end_comment

begin_define
define|#
directive|define
name|LINKS
value|500
end_define

begin_comment
comment|/* no. of links allocated per bunch */
end_comment

begin_define
define|#
directive|define
name|CHARS
value|76
end_define

begin_comment
comment|/* ASCII header size minus filename field */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|512
end_define

begin_comment
comment|/* In u370, can't use BUFSIZ or BSIZE */
end_comment

begin_define
define|#
directive|define
name|CPIOBSZ
value|4096
end_define

begin_comment
comment|/* file read/write */
end_comment

begin_define
define|#
directive|define
name|MK_USHORT
parameter_list|(
name|a
parameter_list|)
value|(a& 00000177777)
end_define

begin_comment
comment|/* Make unsigned shorts for portable  */
end_comment

begin_comment
comment|/* header.  Hardware may only know    */
end_comment

begin_comment
comment|/* integer operations and sign extend */
end_comment

begin_comment
comment|/* the large unsigned short resulting */
end_comment

begin_comment
comment|/* in 8 rather than 6 octal char in   */
end_comment

begin_comment
comment|/* the header.			      */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|Statb
decl_stmt|,
name|Xstatb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cpio header format */
end_comment

begin_struct
specifier|static
struct|struct
name|header
block|{
name|short
name|h_magic
decl_stmt|;
name|short
name|h_dev
decl_stmt|;
name|ushort
name|h_ino
decl_stmt|;
name|ushort
name|h_mode
decl_stmt|,
name|h_uid
decl_stmt|,
name|h_gid
decl_stmt|;
name|short
name|h_nlink
decl_stmt|;
name|short
name|h_rdev
decl_stmt|;
name|short
name|h_mtime
index|[
literal|2
index|]
decl_stmt|,
name|h_namesize
decl_stmt|,
name|h_filesize
index|[
literal|2
index|]
decl_stmt|;
name|char
name|h_name
index|[
literal|256
index|]
decl_stmt|;
block|}
name|Hdr
struct|;
end_struct

begin_decl_stmt
name|char
name|Symlbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target of symbolic link */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|Bufsize
init|=
name|BUFSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default record size */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Buf
index|[
name|CPIOBSZ
index|]
decl_stmt|,
modifier|*
name|Cbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|Option
decl_stmt|,
name|Dir
decl_stmt|,
name|Uncond
decl_stmt|,
name|PassLink
decl_stmt|,
name|Rename
decl_stmt|,
name|Toc
decl_stmt|,
name|Verbose
decl_stmt|,
name|Mod_time
decl_stmt|,
name|Acc_time
decl_stmt|,
name|Cflag
decl_stmt|,
name|fflag
decl_stmt|,
name|Swap
decl_stmt|,
name|byteswap
decl_stmt|,
name|halfswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Ifile
decl_stmt|,
name|Ofile
decl_stmt|,
name|Input
init|=
literal|0
decl_stmt|,
name|Output
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sBlocks: short Blocks.  Cumulative character   */
end_comment

begin_comment
comment|/* count for short reads in bread().  Encountered */
end_comment

begin_comment
comment|/* with communication lines and pipes as in:      */
end_comment

begin_comment
comment|/* split -100 cpio_archive; cat xa* | cpio -icd   */
end_comment

begin_decl_stmt
specifier|static
name|long
name|sBlocks
decl_stmt|,
name|Blocks
decl_stmt|,
name|Longfile
decl_stmt|,
name|Longtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Fullname
index|[
literal|256
index|]
decl_stmt|,
name|Name
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Pathend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|swfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eommsg
init|=
literal|"Change to part %d and press RETURN key. [q] "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|Rtty
decl_stmt|,
modifier|*
name|Wtty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ttyname
index|[]
init|=
literal|"/dev/tty"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|Pattern
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Chdr
index|[
literal|500
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|Dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ushort
name|Uid
decl_stmt|,
name|A_directory
decl_stmt|,
name|A_special
decl_stmt|,
name|A_symlink
decl_stmt|,
name|Filetype
init|=
name|S_IFMT
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern	errno;
end_extern

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|smemcpy
parameter_list|()
function_decl|;
end_function_decl

begin_union
specifier|static
union|union
block|{
name|long
name|l
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|U
union|;
end_union

begin_comment
comment|/* for VAX, Interdata, ... */
end_comment

begin_function
specifier|static
name|long
name|mklong
parameter_list|(
name|v
parameter_list|)
name|short
name|v
index|[]
decl_stmt|;
block|{
name|U
operator|.
name|l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|U
operator|.
name|c
index|[
literal|0
index|]
condition|)
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|1
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
else|else
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
return|return
name|U
operator|.
name|l
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|ct
expr_stmt|;
name|long
name|filesz
decl_stmt|;
name|int
name|symlsz
decl_stmt|;
specifier|register
name|char
modifier|*
name|fullp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|ans
decl_stmt|;
specifier|register
name|char
modifier|*
name|symlinkp
decl_stmt|;
name|short
name|select
decl_stmt|;
comment|/* set when files are selected */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
operator|||
operator|*
name|argv
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
name|usage
argument_list|()
expr_stmt|;
name|Uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ans
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aBC:ifopcdlmrSsbtuvM:6eI:O:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ans
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* reset access time */
name|Acc_time
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* change record size to 5120 bytes */
name|Bufsize
operator|=
literal|5120
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* reset buffer size to arbitrary valu 					*/
name|Bufsize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bufsize
operator|==
literal|0
condition|)
block|{
name|fperr
argument_list|(
literal|"Illegal argument to -%c, '%s'"
argument_list|,
name|ans
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|Option
operator|=
name|IN
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* copy files not matched by patterns */
name|fflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|Option
operator|=
name|OUT
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|Option
operator|=
name|PASS
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* ASCII header */
name|Cflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* create directories when needed */
name|Dir
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* link files, when necessary */
name|PassLink
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* retain mod time */
name|Mod_time
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* rename files interactively */
name|Rename
operator|++
expr_stmt|;
name|Rtty
operator|=
name|fopen
argument_list|(
name|ttyname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|Wtty
operator|=
name|fopen
argument_list|(
name|ttyname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rtty
operator|==
name|NULL
operator|||
name|Wtty
operator|==
name|NULL
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot rename (%s missing)"
argument_list|,
name|ttyname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* swap halfwords */
name|halfswap
operator|++
expr_stmt|;
name|Swap
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* swap bytes */
name|byteswap
operator|++
expr_stmt|;
name|Swap
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* swap both bytes and halfwords */
name|halfswap
operator|++
expr_stmt|;
name|byteswap
operator|++
expr_stmt|;
name|Swap
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* table of contents */
name|Toc
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* copy unconditionally */
name|Uncond
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* verbose - print out file names */
name|Verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* alternate message for end-of-media */
name|eommsg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* for old, sixth-edition files */
name|Filetype
operator|=
literal|060000
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|chkswfile
argument_list|(
name|swfile
argument_list|,
name|ans
argument_list|,
name|Option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|optarg
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot open<%s> for input"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|i
argument_list|,
name|Input
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot dup to standard input"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|swfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|chkswfile
argument_list|(
name|swfile
argument_list|,
name|ans
argument_list|,
name|Option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|optarg
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot open<%s> for output"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|i
argument_list|,
name|Output
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot dup to standard output"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|swfile
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Option
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Options must include one of -o, -i, or -p\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Option
operator|==
name|PASS
condition|)
block|{
if|if
condition|(
name|Rename
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pass and Rename cannot be used together\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Bufsize
operator|!=
name|BUFSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"`B' or `C' option is irrelevant with the '-p' option\n"
argument_list|)
expr_stmt|;
name|Bufsize
operator|=
name|BUFSIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|Cp
operator|=
name|Cbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|Bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"cpio"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
switch|switch
condition|(
name|Option
condition|)
block|{
case|case
name|OUT
case|:
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* get filename, copy header and file out */
while|while
condition|(
name|getname
argument_list|()
condition|)
block|{
if|if
condition|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
operator|==
literal|0L
condition|)
block|{
if|if
condition|(
name|Cflag
condition|)
name|bwrite
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|A_symlink
condition|)
block|{
name|symlsz
operator|=
operator|(
name|int
operator|)
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlink
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Symlbuf
argument_list|,
name|symlsz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot read symbolic link<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Symlbuf
index|[
name|symlsz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|Symlbuf
argument_list|,
name|symlsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|Ifile
operator|=
name|open
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot open<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Cflag
condition|)
name|bwrite
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
for|for
control|(
name|filesz
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
init|;
name|filesz
operator|>
literal|0
condition|;
name|filesz
operator|-=
name|CPIOBSZ
control|)
block|{
name|ct
operator|=
name|filesz
operator|>
name|CPIOBSZ
condition|?
name|CPIOBSZ
else|:
name|filesz
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|Ifile
argument_list|,
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot read %s"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bwrite
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|Ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Acc_time
condition|)
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|Statb
operator|.
name|st_atime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|Statb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
operator|&
name|utb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
comment|/* copy trailer, after all files have been copied */
name|strcpy
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|"TRAILER!!!"
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_magic
operator|=
name|MAGIC
expr_stmt|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_namesize
operator|=
name|strlen
argument_list|(
literal|"TRAILER!!!"
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|bintochar
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
block|}
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|Cbuf
argument_list|,
name|Bufsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN
case|:
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
comment|/* save patterns, if any */
name|Pattern
operator|=
name|argv
expr_stmt|;
block|}
name|pwd
argument_list|()
expr_stmt|;
name|chkhdr
argument_list|()
expr_stmt|;
while|while
condition|(
name|gethdr
argument_list|()
condition|)
block|{
if|if
condition|(
name|A_symlink
condition|)
block|{
name|symlsz
operator|=
operator|(
name|int
operator|)
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
expr_stmt|;
name|bread
argument_list|(
name|Symlbuf
argument_list|,
name|symlsz
argument_list|)
expr_stmt|;
name|Symlbuf
index|[
name|symlsz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ckname
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
operator|&&
operator|!
name|Toc
condition|)
operator|(
name|void
operator|)
name|openout
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Symlbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|select
operator|=
name|ckname
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
operator|)
operator|&&
operator|!
name|Toc
condition|)
name|Ofile
operator|=
name|openout
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|Ofile
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|filesz
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
init|;
name|filesz
operator|>
literal|0
condition|;
name|filesz
operator|-=
name|CPIOBSZ
control|)
block|{
name|ct
operator|=
name|filesz
operator|>
name|CPIOBSZ
condition|?
name|CPIOBSZ
else|:
name|filesz
expr_stmt|;
name|bread
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ofile
condition|)
block|{
if|if
condition|(
name|Swap
condition|)
name|swap
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|,
name|byteswap
argument_list|,
name|halfswap
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|Ofile
argument_list|,
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot write %s"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|Ofile
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|Ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
name|fperrno
argument_list|(
literal|"Cannot change mode of<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|select
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
if|if
condition|(
name|Toc
condition|)
name|pentry
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Toc
condition|)
name|puts
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PASS
case|:
comment|/* move files around */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fperrno
argument_list|(
literal|"Cannot write in<%s>"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|Fullname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* destination directory */
if|if
condition|(
name|stat
argument_list|(
name|Fullname
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot stat<%s>"
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Xstatb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> is not a directory"
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|Dev
operator|=
name|Xstatb
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|Fullname
index|[
name|strlen
argument_list|(
name|Fullname
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|Fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fullp
operator|=
name|Fullname
operator|+
name|strlen
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
while|while
condition|(
name|getname
argument_list|()
condition|)
block|{
if|if
condition|(
name|A_directory
operator|&&
operator|!
name|Dir
condition|)
name|fperr
argument_list|(
literal|"Use `-d' option to copy<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ckname
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
condition|)
continue|continue;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Hdr
operator|.
name|h_name
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|fullp
argument_list|,
operator|&
operator|(
name|Hdr
operator|.
name|h_name
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PassLink
operator|&&
operator|!
name|A_directory
operator|&&
name|Dev
operator|==
name|Statb
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|link
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
if|if
condition|(
name|missdir
argument_list|(
name|Fullname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory for<%s>"
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|EEXIST
case|:
if|if
condition|(
name|unlink
argument_list|(
name|Fullname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot unlink<%s>"
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|fperrno
argument_list|(
literal|"Cannot link<%s> to<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|link
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot link<%s> to<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
goto|goto
name|ckverbose
goto|;
block|}
if|if
condition|(
name|A_symlink
condition|)
block|{
name|symlsz
operator|=
operator|(
name|int
operator|)
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlink
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Symlbuf
argument_list|,
name|symlsz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot read symbolic link<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Symlbuf
index|[
name|symlsz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|openout
argument_list|(
name|Fullname
argument_list|,
name|Symlbuf
argument_list|)
condition|)
continue|continue;
name|Blocks
operator|+=
operator|(
operator|(
name|symlsz
operator|+
operator|(
name|BUFSIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|BUFSIZE
operator|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|puts
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|Ofile
operator|=
name|openout
argument_list|(
name|Fullname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|Ifile
operator|=
name|open
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot open<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ofile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|filesz
operator|=
name|Statb
operator|.
name|st_size
expr_stmt|;
for|for
control|(
init|;
name|filesz
operator|>
literal|0
condition|;
name|filesz
operator|-=
name|CPIOBSZ
control|)
block|{
name|ct
operator|=
name|filesz
operator|>
name|CPIOBSZ
condition|?
name|CPIOBSZ
else|:
name|filesz
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|Ifile
argument_list|,
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot read %s"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|write
argument_list|(
name|Ofile
argument_list|,
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot write %s"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Removed u370 ifdef which caused cpio */
comment|/* to report blocks in terms of 4096 bytes. */
name|Blocks
operator|+=
operator|(
operator|(
name|ct
operator|+
operator|(
name|BUFSIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|BUFSIZE
operator|)
expr_stmt|;
block|}
name|close
argument_list|(
name|Ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Acc_time
condition|)
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|Statb
operator|.
name|st_atime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|Statb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
operator|&
name|utb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ofile
condition|)
block|{
name|close
argument_list|(
name|Ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|Fullname
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
name|fperrno
argument_list|(
literal|"Cannot change mode of<%s>"
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|Fullname
argument_list|,
name|Statb
operator|.
name|st_atime
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|ckverbose
label|:
if|if
condition|(
name|Verbose
condition|)
name|puts
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* print number of blocks actually copied */
name|Blocks
operator|+=
operator|(
operator|(
name|sBlocks
operator|+
operator|(
name|BUFSIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|BUFSIZE
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld blocks\n"
argument_list|,
name|Blocks
operator|*
operator|(
name|Bufsize
operator|>>
literal|9
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|usage
argument_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
literal|"Usage: %s\n     %s\n     %s\n     %s\n       %s\n"
argument_list|,
literal|"cpio -o[acvB]<name-list>collection"
argument_list|,
literal|"cpio -o[acvB] -Ocollection<name-list"
argument_list|,
literal|"cpio -i[cdmrstuvfB6] [ pattern ... ]<collection"
argument_list|,
literal|"cpio -i[cdmrstuvfB6] -Icollection [ pattern ... ]"
argument_list|,
literal|"cpio -p[adlmruv] directory<name-list"
argument_list|)
block|; }
specifier|static
name|chkswfile
argument_list|(
argument|sp
argument_list|,
argument|c
argument_list|,
argument|option
argument_list|)
name|char
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|option
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|option
condition|)
block|{
name|fperr
argument_list|(
literal|"-%c must be specified before -%c option"
argument_list|,
name|c
operator|==
literal|'I'
condition|?
literal|'i'
else|:
literal|'o'
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'I'
operator|&&
name|option
operator|!=
name|IN
operator|)
operator|||
operator|(
name|c
operator|==
literal|'O'
operator|&&
name|option
operator|!=
name|OUT
operator|)
condition|)
block|{
name|fperr
argument_list|(
literal|"-%c option not permitted with -%c option"
argument_list|,
name|c
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sp
condition|)
return|return;
name|fperr
argument_list|(
literal|"No more than one -I or -O flag permitted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|getname
argument_list|()
comment|/* get file name, get info for header */
block|{
specifier|register
name|char
operator|*
name|namep
operator|=
name|Name
block|;
specifier|register
name|ushort
name|ftype
block|; 	struct
name|stat
name|Lstatb
block|;
name|long
name|tlong
block|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|gets
argument_list|(
name|namep
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|namep
operator|==
literal|'.'
operator|&&
name|namep
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|namep
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|namep
operator|==
literal|'/'
condition|)
name|namep
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|namep
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot stat<%s>"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
name|ftype
operator|=
name|Statb
operator|.
name|st_mode
operator|&
name|Filetype
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|A_directory
operator|=
operator|(
name|ftype
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|A_special
operator|=
operator|(
name|ftype
operator|==
name|S_IFBLK
operator|)
operator|||
operator|(
name|ftype
operator|==
name|S_IFCHR
operator|)
operator|||
operator|(
name|ftype
operator|==
name|S_IFIFO
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|A_symlink
operator|=
operator|(
name|ftype
operator|==
name|S_IFLNK
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_magic
operator|=
name|MAGIC
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_namesize
operator|=
name|strlen
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_uid
operator|=
name|Statb
operator|.
name|st_uid
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_gid
operator|=
name|Statb
operator|.
name|st_gid
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_dev
operator|=
name|Statb
operator|.
name|st_dev
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_ino
operator|=
name|Statb
operator|.
name|st_ino
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_mode
operator|=
name|Statb
operator|.
name|st_mode
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_nlink
operator|=
name|Statb
operator|.
name|st_nlink
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tlong
operator|=
operator|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|||
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
operator|)
condition|?
name|Statb
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
name|tlong
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Hdr
operator|.
name|h_rdev
operator|=
name|Statb
operator|.
name|st_rdev
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Cflag
condition|)
name|bintochar
argument_list|(
name|tlong
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
literal|1
return|;
end_return

begin_expr_stmt
unit|} }
specifier|static
name|bintochar
argument_list|(
argument|t
argument_list|)
comment|/* ASCII header write */
name|long
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sprintf
argument_list|(
name|Chdr
argument_list|,
literal|"%.6o%.6ho%.6ho%.6ho%.6ho%.6ho%.6ho%.6ho%.11lo%.6ho%.11lo%s"
argument_list|,
name|MAGIC
argument_list|,
name|MK_USHORT
argument_list|(
name|Statb
operator|.
name|st_dev
argument_list|)
argument_list|,
name|MK_USHORT
argument_list|(
name|Statb
operator|.
name|st_ino
argument_list|)
argument_list|,
name|Statb
operator|.
name|st_mode
argument_list|,
name|Statb
operator|.
name|st_uid
argument_list|,
name|Statb
operator|.
name|st_gid
argument_list|,
name|Statb
operator|.
name|st_nlink
argument_list|,
name|MK_USHORT
argument_list|(
name|Statb
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|,
operator|(
name|short
operator|)
name|strlen
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
operator|+
literal|1
argument_list|,
name|t
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|chartobin
argument_list|()
comment|/* ASCII header read */
block|{
name|sscanf
argument_list|(
name|Chdr
argument_list|,
literal|"%6ho%6ho%6ho%6ho%6ho%6ho%6ho%6ho%11lo%6ho%11lo"
argument_list|,
operator|&
name|Hdr
operator|.
name|h_magic
argument_list|,
operator|&
name|Hdr
operator|.
name|h_dev
argument_list|,
operator|&
name|Hdr
operator|.
name|h_ino
argument_list|,
operator|&
name|Hdr
operator|.
name|h_mode
argument_list|,
operator|&
name|Hdr
operator|.
name|h_uid
argument_list|,
operator|&
name|Hdr
operator|.
name|h_gid
argument_list|,
operator|&
name|Hdr
operator|.
name|h_nlink
argument_list|,
operator|&
name|Hdr
operator|.
name|h_rdev
argument_list|,
operator|&
name|Longtime
argument_list|,
operator|&
name|Hdr
operator|.
name|h_namesize
argument_list|,
operator|&
name|Longfile
argument_list|)
block|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
name|Longfile
argument_list|)
block|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|,
name|Longtime
argument_list|)
block|; }
comment|/*	Check the header for the magic number.  Switch modes automatically to 	match the type of header found. */
specifier|static
name|chkhdr
argument_list|()
block|{
name|bread
argument_list|(
name|Chdr
argument_list|,
name|CHARS
argument_list|)
block|;
name|chartobin
argument_list|()
block|;
if|if
condition|(
name|Hdr
operator|.
name|h_magic
operator|==
name|MAGIC
condition|)
name|Cflag
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|breread
argument_list|(
operator|&
name|Hdr
operator|.
name|h_magic
argument_list|,
sizeof|sizeof
name|Hdr
operator|.
name|h_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hdr
operator|.
name|h_magic
operator|==
name|MAGIC
operator|||
name|Hdr
operator|.
name|h_magic
operator|==
operator|(
name|short
operator|)
name|BSMAGIC
condition|)
name|Cflag
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fperr
argument_list|(
literal|"This is not a cpio file.  Bad magic number."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 	breread
operator|(
name|Chdr
operator|,
literal|0
operator|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   static
name|gethdr
argument_list|()
end_macro

begin_comment
comment|/* get file headers */
end_comment

begin_block
block|{
specifier|register
name|ushort
name|ftype
decl_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|bread
argument_list|(
name|Chdr
argument_list|,
name|CHARS
argument_list|)
expr_stmt|;
name|chartobin
argument_list|()
expr_stmt|;
block|}
else|else
name|bread
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hdr
operator|.
name|h_magic
operator|==
operator|(
name|short
operator|)
name|BSMAGIC
condition|)
name|swap
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|h_magic
operator|!=
name|MAGIC
condition|)
block|{
name|fperr
argument_list|(
literal|"Out of phase--get help"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|bread
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|"TRAILER!!!"
argument_list|)
condition|)
return|return
literal|0
return|;
name|ftype
operator|=
name|Hdr
operator|.
name|h_mode
operator|&
name|Filetype
expr_stmt|;
name|A_directory
operator|=
operator|(
name|ftype
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
name|A_special
operator|=
operator|(
name|ftype
operator|==
name|S_IFBLK
operator|)
operator|||
operator|(
name|ftype
operator|==
name|S_IFCHR
operator|)
operator|||
operator|(
name|ftype
operator|==
name|S_IFIFO
operator|)
expr_stmt|;
name|A_symlink
operator|=
operator|(
name|ftype
operator|==
name|S_IFLNK
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|ckname
argument_list|(
name|namep
argument_list|)
comment|/* check filenames with patterns given on cmd line */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
sizeof|sizeof
name|Hdr
operator|.
name|h_name
index|]
decl_stmt|;
if|if
condition|(
name|fflag
operator|^
operator|!
name|nmatch
argument_list|(
name|namep
argument_list|,
name|Pattern
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Rename
operator|&&
operator|!
name|A_directory
condition|)
block|{
comment|/* rename interactively */
name|fprintf
argument_list|(
name|Wtty
argument_list|,
literal|"Rename<%s>\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|Wtty
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|Rtty
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|Rtty
argument_list|)
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|namep
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Skipped\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Same name\n"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|namep
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|openout
argument_list|(
name|namep
argument_list|,
name|symlname
argument_list|)
comment|/* open files for writing, set all necessary info */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|symlname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|f
expr_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|ans
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|namep
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
condition|)
name|namep
operator|+=
literal|2
expr_stmt|;
name|np
operator|=
name|namep
expr_stmt|;
if|if
condition|(
name|A_directory
condition|)
block|{
if|if
condition|(
operator|!
name|Dir
operator|||
name|Rename
operator|||
name|EQ
argument_list|(
name|namep
argument_list|,
literal|"."
argument_list|)
operator|||
name|EQ
argument_list|(
name|namep
argument_list|,
literal|".."
argument_list|)
condition|)
comment|/* do not consider . or .. files */
return|return
literal|0
return|;
if|if
condition|(
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|namep
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory for<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|ret
label|:
if|if
condition|(
name|chmod
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
name|fperrno
argument_list|(
literal|"Cannot change mode of<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|Uid
operator|==
literal|0
condition|)
if|if
condition|(
name|chown
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|,
name|Hdr
operator|.
name|h_gid
argument_list|)
operator|<
literal|0
condition|)
name|fperrno
argument_list|(
literal|"Cannot change ownership of<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|namep
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|h_nlink
operator|>
literal|1
condition|)
if|if
condition|(
operator|!
name|postml
argument_list|(
name|namep
argument_list|,
name|np
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Uncond
operator|&&
operator|!
operator|(
operator|(
operator|!
operator|(
name|Xstatb
operator|.
name|st_mode
operator|&
name|S_IWRITE
operator|)
operator|||
name|A_special
operator|)
operator|&&
operator|(
name|Uid
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|namep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"cannot unlink current<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Uncond
operator|&&
operator|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
operator|<=
name|Xstatb
operator|.
name|st_mtime
operator|)
condition|)
block|{
comment|/* There's a newer or same aged version of file on destination */
name|fperr
argument_list|(
literal|"current<%s> newer or same age"
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|Option
operator|==
name|PASS
operator|&&
name|Hdr
operator|.
name|h_ino
operator|==
name|Xstatb
operator|.
name|st_ino
operator|&&
name|Hdr
operator|.
name|h_dev
operator|==
name|Xstatb
operator|.
name|st_dev
condition|)
block|{
name|fperr
argument_list|(
literal|"Attempt to pass file to self!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|A_symlink
condition|)
block|{
comment|/* try symlinking (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|symlink
argument_list|(
name|symlname
argument_list|,
name|namep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory for<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot symlink<%s> and<%s>"
argument_list|,
name|namep
argument_list|,
name|symlname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|A_special
condition|)
block|{
if|if
condition|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|Filetype
operator|)
operator|==
name|S_IFIFO
condition|)
name|Hdr
operator|.
name|h_rdev
operator|=
literal|0
expr_stmt|;
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mknod
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|,
name|Hdr
operator|.
name|h_rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory for<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot mknod<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|ret
goto|;
block|}
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|creat
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory for<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|Uid
operator|==
literal|0
condition|)
if|if
condition|(
name|chown
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|,
name|Hdr
operator|.
name|h_gid
argument_list|)
operator|<
literal|0
condition|)
name|fperrno
argument_list|(
literal|"Cannot change ownership of<%s>"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_block

begin_comment
comment|/*	Shared by bread() and breread() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nleft
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unread chars left in Cbuf */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to next char to be read from Cbuf */
end_comment

begin_comment
comment|/*	Reread the current buffer Cbuf. 	A character count, c, of 0 simply resets the pointer so next bread gets 	the same data again. */
end_comment

begin_expr_stmt
specifier|static
name|breread
argument_list|(
argument|b
argument_list|,
argument|c
argument_list|)
name|char
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ip
operator|=
name|Cbuf
expr_stmt|;
if|if
condition|(
name|nleft
condition|)
name|nleft
operator|=
name|Bufsize
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return;
name|bread
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|bread
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
specifier|register
name|char
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|rv
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|ip
decl_stmt|;
if|if
condition|(
operator|!
name|Cflag
condition|)
block|{
comment|/* round c up to an even number */
name|c
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|*=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|nleft
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|rv
operator|=
name|read
argument_list|(
name|Input
argument_list|,
name|Cbuf
argument_list|,
name|Bufsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|Input
operator|=
name|chgreel
argument_list|(
literal|0
argument_list|,
name|Input
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|Bufsize
condition|)
block|{
name|nleft
operator|=
name|Bufsize
expr_stmt|;
name|p
operator|=
name|Cbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Read error on archive"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|<
name|Bufsize
condition|)
block|{
comment|/* short read */
name|smemcpy
argument_list|(
operator|&
name|Cbuf
index|[
name|Bufsize
operator|-
name|rv
index|]
argument_list|,
name|Cbuf
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|rv
expr_stmt|;
name|p
operator|=
operator|&
name|Cbuf
index|[
name|Bufsize
operator|-
name|rv
index|]
expr_stmt|;
name|sBlocks
operator|+=
name|rv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nleft
operator|<=
name|c
condition|)
block|{
name|memcpy
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
name|c
operator|-=
name|nleft
expr_stmt|;
name|b
operator|+=
name|nleft
expr_stmt|;
name|p
operator|+=
name|nleft
expr_stmt|;
name|nleft
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|nleft
operator|-=
name|c
expr_stmt|;
name|b
operator|+=
name|c
expr_stmt|;
name|p
operator|+=
name|c
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ip
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|bwrite
argument_list|(
name|rp
argument_list|,
name|c
argument_list|)
specifier|register
name|char
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|Cp
decl_stmt|;
specifier|static
name|unsigned
name|Ccnt
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|Cleft
decl_stmt|;
specifier|register
name|int
name|rv
decl_stmt|;
if|if
condition|(
operator|!
name|Cflag
condition|)
block|{
comment|/* round c up to an even number */
name|c
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|*=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|(
name|Cleft
operator|=
name|Bufsize
operator|-
name|Ccnt
operator|)
operator|<=
name|c
condition|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|rp
argument_list|,
name|Cleft
argument_list|)
expr_stmt|;
name|rv
operator|=
name|write
argument_list|(
name|Output
argument_list|,
name|Cbuf
argument_list|,
name|Bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
operator|||
operator|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENXIO
operator|)
condition|)
block|{
name|rv
operator|=
name|eomchgreel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|Bufsize
condition|)
block|{
name|Ccnt
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|Cbuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Write error on archive"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|<
name|Bufsize
condition|)
block|{
name|Output
operator|=
name|chgreel
argument_list|(
literal|1
argument_list|,
name|Output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smemcpy
argument_list|(
name|Cbuf
argument_list|,
operator|&
name|Cbuf
index|[
name|Bufsize
operator|-
name|rv
index|]
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|Ccnt
operator|=
name|Bufsize
operator|-
name|rv
expr_stmt|;
name|cp
operator|=
operator|&
name|Cbuf
index|[
name|rv
index|]
expr_stmt|;
block|}
operator|++
name|Blocks
expr_stmt|;
name|rp
operator|+=
name|Cleft
expr_stmt|;
name|c
operator|-=
name|Cleft
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|rp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|Ccnt
operator|+=
name|c
expr_stmt|;
name|cp
operator|+=
name|c
expr_stmt|;
name|rp
operator|+=
name|c
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|Cp
operator|=
name|cp
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|reelcount
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used below and in chgreel() */
end_comment

begin_comment
comment|/*	Change reel due to reaching end-of-media. 	Keep trying to get a successful write before considering the 	change-of-reel as successful. */
end_comment

begin_function
specifier|static
name|int
name|eomchgreel
parameter_list|()
block|{
name|int
name|rv
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Output
operator|=
name|chgreel
argument_list|(
literal|1
argument_list|,
name|Output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rv
operator|=
name|write
argument_list|(
name|Output
argument_list|,
name|Cbuf
argument_list|,
name|Bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|Bufsize
condition|)
return|return
name|rv
return|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|fperrno
argument_list|(
literal|"Unable to write this medium"
argument_list|)
expr_stmt|;
else|else
name|fperr
argument_list|(
literal|"Unable to write this medium: Premature EOF"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Try again.\n"
argument_list|)
expr_stmt|;
name|reelcount
operator|--
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_expr_stmt
specifier|static
name|postml
argument_list|(
name|namep
argument_list|,
name|np
argument_list|)
comment|/* linking funtion:  Postml() is called after */
specifier|register
name|char
operator|*
name|namep
operator|,
operator|*
name|np
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* namep is created.  Postml() checks to see  */
end_comment

begin_block
block|{
comment|/* if namep should be linked to np.  If so,   */
comment|/* postml() removes the independent instance  */
specifier|register
name|i
expr_stmt|;
comment|/* of namep and links namep to np.	      */
specifier|static
struct|struct
name|ml
block|{
name|short
name|m_dev
decl_stmt|;
name|ushort
name|m_ino
decl_stmt|;
name|char
name|m_name
index|[
literal|2
index|]
decl_stmt|;
block|}
modifier|*
modifier|*
name|ml
init|=
literal|0
struct|;
specifier|register
name|struct
name|ml
modifier|*
name|mlp
decl_stmt|;
specifier|static
name|unsigned
name|mlsize
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|mlinks
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|lnamep
decl_stmt|;
name|int
name|ans
decl_stmt|;
if|if
condition|(
operator|!
name|ml
condition|)
block|{
name|mlsize
operator|=
name|LINKS
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|ml
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|mlsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ml
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlinks
operator|==
name|mlsize
condition|)
block|{
name|mlsize
operator|+=
name|LINKS
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|ml
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ml
argument_list|,
name|mlsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ml
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ml
operator|==
name|NULL
condition|)
block|{
name|fperr
argument_list|(
literal|"Out of memory for links"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mlinks
condition|;
operator|++
name|i
control|)
block|{
name|mlp
operator|=
name|ml
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mlp
operator|->
name|m_ino
operator|==
name|Hdr
operator|.
name|h_ino
operator|&&
name|mlp
operator|->
name|m_dev
operator|==
name|Hdr
operator|.
name|h_dev
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%s linked to %s\n"
argument_list|,
name|ml
index|[
name|i
index|]
operator|->
name|m_name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|Option
operator|==
name|IN
operator|&&
operator|*
operator|(
name|mlp
operator|->
name|m_name
operator|)
operator|!=
literal|'/'
condition|)
block|{
name|Fullname
index|[
name|Pathend
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|Fullname
argument_list|,
name|mlp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|lnamep
operator|=
name|Fullname
expr_stmt|;
block|}
name|lnamep
operator|=
name|mlp
operator|->
name|m_name
expr_stmt|;
comment|/* try linking (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|link
argument_list|(
name|lnamep
argument_list|,
name|namep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot create directory for<%s>"
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot link<%s>&<%s>"
argument_list|,
name|lnamep
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|set_time
argument_list|(
name|namep
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ml
index|[
name|mlinks
index|]
operator|=
operator|(
expr|struct
name|ml
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|np
argument_list|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ml
argument_list|)
argument_list|)
operator|)
condition|)
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|fperr
argument_list|(
literal|"Out of memory for links"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ml
index|[
name|mlinks
index|]
operator|->
name|m_dev
operator|=
name|Hdr
operator|.
name|h_dev
expr_stmt|;
name|ml
index|[
name|mlinks
index|]
operator|->
name|m_ino
operator|=
name|Hdr
operator|.
name|h_ino
expr_stmt|;
name|strcpy
argument_list|(
name|ml
index|[
name|mlinks
index|]
operator|->
name|m_name
argument_list|,
name|np
argument_list|)
expr_stmt|;
operator|++
name|mlinks
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|pentry
argument_list|(
name|namep
argument_list|)
comment|/* print verbose table of contents */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|short
name|lastid
init|=
operator|-
literal|1
decl_stmt|;
include|#
directive|include
file|<pwd.h>
specifier|static
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
specifier|static
name|char
name|tbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"%-7o"
argument_list|,
name|MK_USHORT
argument_list|(
name|Hdr
operator|.
name|h_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastid
operator|==
name|Hdr
operator|.
name|h_uid
condition|)
name|printf
argument_list|(
literal|"%-6s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
block|{
name|setpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pw
operator|=
name|getpwuid
argument_list|(
operator|(
name|int
operator|)
name|Hdr
operator|.
name|h_uid
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-6s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|lastid
operator|=
name|Hdr
operator|.
name|h_uid
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%-6d"
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|)
expr_stmt|;
name|lastid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%7ld "
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
argument_list|)
expr_stmt|;
name|U
operator|.
name|l
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ctime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|U
operator|.
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|" %s  %s"
argument_list|,
operator|&
name|tbuf
index|[
literal|4
index|]
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|A_symlink
condition|)
name|printf
argument_list|(
literal|" -> %s"
argument_list|,
name|Symlbuf
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* pattern matching functions */
end_comment

begin_expr_stmt
specifier|static
name|nmatch
argument_list|(
argument|s
argument_list|,
argument|pat
argument_list|)
name|char
operator|*
name|s
operator|,
operator|*
operator|*
name|pat
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|*
name|pat
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|pat
operator|==
literal|'!'
operator|&&
operator|!
name|gmatch
argument_list|(
name|s
argument_list|,
operator|*
name|pat
operator|+
literal|1
argument_list|)
operator|)
operator|||
name|gmatch
argument_list|(
name|s
argument_list|,
operator|*
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
operator|++
name|pat
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|cc
operator|,
name|ok
operator|,
name|lc
operator|,
name|scc
expr_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|ok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|ok
condition|)
return|return
operator|(
name|gmatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|ok
operator||=
operator|(
operator|(
name|lc
operator|<=
name|scc
operator|)
operator|&&
operator|(
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|ok
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|gmatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|umatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|gmatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|swap
argument_list|(
argument|buf
argument_list|,
argument|bytecount
argument_list|,
argument|bytes
argument_list|,
argument|halfwords
argument_list|)
end_macro

begin_comment
comment|/* swap halfwords, bytes or both */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytecount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes
decl_stmt|,
name|halfwords
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
specifier|register
union|union
name|swpbytes
block|{
name|short
name|shortw
decl_stmt|;
name|char
name|charv
index|[
literal|2
index|]
decl_stmt|;
block|}
modifier|*
name|pbuf
union|;
specifier|register
name|char
name|c
decl_stmt|;
name|count
operator|=
name|bytecount
expr_stmt|;
name|pbuf
operator|=
operator|(
expr|union
name|swpbytes
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|count
operator|%
sizeof|sizeof
argument_list|(
expr|union
name|swpbytes
argument_list|)
condition|)
name|pbuf
operator|->
name|charv
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|count
operator|=
operator|(
name|count
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swpbytes
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|swpbytes
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|c
operator|=
name|pbuf
operator|->
name|charv
index|[
literal|0
index|]
expr_stmt|;
name|pbuf
operator|->
name|charv
index|[
literal|0
index|]
operator|=
name|pbuf
operator|->
name|charv
index|[
literal|1
index|]
expr_stmt|;
name|pbuf
operator|->
name|charv
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|pbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|halfwords
condition|)
block|{
specifier|register
union|union
name|swphalf
block|{
name|long
name|longw
decl_stmt|;
name|short
name|shortv
index|[
literal|2
index|]
decl_stmt|;
name|char
name|charv
index|[
literal|4
index|]
decl_stmt|;
block|}
modifier|*
name|pbuf
union|;
specifier|register
name|short
name|cc
decl_stmt|;
name|count
operator|=
name|bytecount
expr_stmt|;
name|pbuf
operator|=
operator|(
expr|union
name|swphalf
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|count
operator|%
sizeof|sizeof
argument_list|(
expr|union
name|swphalf
argument_list|)
condition|)
if|if
condition|(
name|bytes
operator|&&
name|n
operator|%
literal|2
condition|)
for|for
control|(
name|i
operator|=
name|count
operator|+
literal|1
init|;
name|i
operator|<=
name|count
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swphalf
argument_list|)
operator|-
name|n
operator|)
condition|;
name|i
operator|++
control|)
name|pbuf
operator|->
name|charv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|<
name|count
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swphalf
argument_list|)
operator|-
name|n
operator|)
condition|;
name|i
operator|++
control|)
name|pbuf
operator|->
name|charv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|count
operator|=
operator|(
name|count
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swphalf
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|swphalf
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|cc
operator|=
name|pbuf
operator|->
name|shortv
index|[
literal|0
index|]
expr_stmt|;
name|pbuf
operator|->
name|shortv
index|[
literal|0
index|]
operator|=
name|pbuf
operator|->
name|shortv
index|[
literal|1
index|]
expr_stmt|;
name|pbuf
operator|->
name|shortv
index|[
literal|1
index|]
operator|=
name|cc
expr_stmt|;
operator|++
name|pbuf
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|set_time
argument_list|(
name|namep
argument_list|,
name|atime
argument_list|,
name|mtime
argument_list|)
comment|/* set access and modification times */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|time_t
name|atime
decl_stmt|,
name|mtime
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|utimbuf
name|timevec
decl_stmt|;
if|if
condition|(
operator|!
name|Mod_time
condition|)
return|return;
name|timevec
operator|.
name|actime
operator|=
name|atime
expr_stmt|;
name|timevec
operator|.
name|modtime
operator|=
name|mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|namep
argument_list|,
operator|&
name|timevec
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|chgreel
argument_list|(
argument|x
argument_list|,
argument|fl
argument_list|,
argument|rv
argument_list|)
block|{
specifier|register
name|f
block|;
name|char
name|str
index|[
name|BUFSIZ
index|]
block|; 	struct
name|stat
name|statb
block|;
name|fstat
argument_list|(
name|fl
argument_list|,
operator|&
name|statb
argument_list|)
block|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
block|{
name|fperrno
argument_list|(
literal|"Can't %s: "
argument_list|,
name|x
condition|?
literal|"write output"
else|:
literal|"read input"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|rv
operator|==
literal|0
operator|||
operator|(
name|rv
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|ENOSPC
operator|||
name|errno
operator|==
name|ENXIO
operator|)
operator|)
condition|)
name|fperr
argument_list|(
literal|"\007Reached end of medium on %s"
argument_list|,
name|x
condition|?
literal|"output"
else|:
literal|"input"
argument_list|)
expr_stmt|;
else|else
block|{
name|fperrno
argument_list|(
literal|"\007Encountered an error on %s"
argument_list|,
name|x
condition|?
literal|"output"
else|:
literal|"input"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Rtty
operator|==
name|NULL
condition|)
block|{
name|Rtty
operator|=
name|fopen
argument_list|(
name|ttyname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rtty
operator|==
name|NULL
condition|)
block|{
name|fperrno
argument_list|(
literal|"Cannot prompt (can't open %s)"
argument_list|,
name|ttyname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|close
argument_list|(
name|fl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reelcount
operator|++
expr_stmt|;
end_expr_stmt

begin_label
name|again
label|:
end_label

begin_if
if|if
condition|(
name|swfile
condition|)
block|{
name|askagain
label|:
name|fperr
argument_list|(
name|eommsg
argument_list|,
name|reelcount
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
name|str
argument_list|,
name|Rtty
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\n'
case|:
name|strcpy
argument_list|(
name|str
argument_list|,
name|swfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|askagain
goto|;
block|}
block|}
else|else
block|{
name|fperr
argument_list|(
literal|"If you want to go on, type device/file name when ready."
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
name|str
argument_list|,
name|Rtty
argument_list|)
expr_stmt|;
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|str
argument_list|,
name|x
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fperrno
argument_list|(
literal|"Can't open<%s>"
argument_list|,
name|str
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_if

begin_return
return|return
name|f
return|;
end_return

begin_expr_stmt
unit|}    static
name|missdir
argument_list|(
name|namep
argument_list|)
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|ct
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|np
operator|=
name|namep
init|;
operator|*
name|np
condition|;
operator|++
name|np
control|)
if|if
condition|(
operator|*
name|np
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|np
operator|==
name|namep
condition|)
continue|continue;
comment|/* skip over 'root slash' */
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|Dir
condition|)
block|{
if|if
condition|(
operator|(
name|ct
operator|=
name|mkdir
argument_list|(
name|namep
argument_list|,
literal|0777
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|np
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|ct
operator|)
return|;
block|}
block|}
else|else
block|{
name|fperr
argument_list|(
literal|"missing 'd' option"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|np
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|==
literal|2
condition|)
name|ct
operator|=
literal|0
expr_stmt|;
comment|/* the file already exists */
return|return
name|ct
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|pwd
argument_list|()
comment|/* get working directory */
block|{
if|if
condition|(
name|getwd
argument_list|(
name|Fullname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cpio: %s\n"
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|Pathend
operator|=
name|strlen
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fullname
index|[
name|Pathend
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fullname
index|[
name|Pathend
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* 	print message on the stderr */
end_comment

begin_macro
unit|static
name|fperr
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cpio: "
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	print message on the stderr followed by error number and meaning. */
end_comment

begin_expr_stmt
specifier|static
name|fperrno
argument_list|(
argument|va_alist
argument_list|)
name|va_dcl
block|{
name|va_list
name|args
block|;
name|char
operator|*
name|fmt
block|;
name|va_start
argument_list|(
name|args
argument_list|)
block|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cpio: "
argument_list|)
block|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
block|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
block|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
block|;
name|fflush
argument_list|(
name|stderr
argument_list|)
block|;
name|perror
argument_list|(
literal|""
argument_list|)
block|; }
comment|/*	Safe memory copy. 	Fast if the to and from strings do not overlap, 	slower but safe if they do. */
specifier|static
name|char
operator|*
name|smemcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|count
argument_list|)
specifier|register
name|char
operator|*
name|to
operator|,
operator|*
name|from
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|savedto
decl_stmt|;
if|if
condition|(
operator|&
name|to
index|[
name|count
index|]
operator|<=
name|from
operator|||
operator|&
name|from
index|[
name|count
index|]
operator|<=
name|to
condition|)
return|return
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|count
argument_list|)
return|;
if|if
condition|(
name|to
operator|==
name|from
condition|)
return|return
name|to
return|;
name|savedto
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|to
operator|<
name|from
condition|)
while|while
condition|(
name|count
operator|--
condition|)
operator|*
operator|(
name|to
operator|++
operator|)
operator|=
operator|*
operator|(
name|from
operator|++
operator|)
expr_stmt|;
else|else
block|{
name|to
operator|+=
name|count
expr_stmt|;
name|from
operator|+=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
operator|(
operator|--
name|to
operator|)
operator|=
operator|*
operator|(
operator|--
name|from
operator|)
expr_stmt|;
block|}
return|return
name|savedto
return|;
block|}
end_block

begin_function_decl
specifier|extern
name|int
name|_doprnt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
name|int
name|vfprintf
parameter_list|(
name|iop
parameter_list|,
name|format
parameter_list|,
name|ap
parameter_list|)
name|FILE
modifier|*
name|iop
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|iop
operator|->
name|_flag
operator||
name|_IOWRT
operator|)
condition|)
block|{
comment|/* if no write flag */
if|if
condition|(
name|iop
operator|->
name|_flag
operator||
name|_IORW
condition|)
block|{
comment|/* if ok, cause read-write */
name|iop
operator|->
name|_flag
operator||=
name|_IOWRT
expr_stmt|;
block|}
else|else
block|{
comment|/* else error */
return|return
name|EOF
return|;
block|}
block|}
name|count
operator|=
name|_doprnt
argument_list|(
name|format
argument_list|,
name|ap
argument_list|,
name|iop
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|iop
argument_list|)
condition|?
name|EOF
else|:
name|count
operator|)
return|;
block|}
end_function

end_unit

