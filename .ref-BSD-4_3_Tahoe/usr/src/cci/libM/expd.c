begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)exp.c	4.1/4.2 	10/31/84	CCI-CPG */
end_comment

begin_comment
comment|/*  * The double-precision 'exp' returns the exponential  * function of its floating-point argument.  *  * New version by Les Powers (3/23/85).  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * The following number 'forces' the hex value of 0x7fffffff 0xffffffff  * to be used for HUGE.  */
end_comment

begin_define
define|#
directive|define
name|HUGE
value|1.701411834604692350e+40
end_define

begin_define
define|#
directive|define
name|EXPONENT28
value|0x0e000000
end_define

begin_define
define|#
directive|define
name|EXP_SIZE0
value|12
end_define

begin_define
define|#
directive|define
name|EXP_SIZE1
value|128
end_define

begin_define
define|#
directive|define
name|EXP_SIZE2
value|256
end_define

begin_define
define|#
directive|define
name|EXP_SIZE3
value|256
end_define

begin_define
define|#
directive|define
name|EXP_SIZE4
value|256
end_define

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the natural log of the smallest number that can  * be represented with double precision format (2^-128).  */
end_comment

begin_decl_stmt
name|double
name|minf
init|=
operator|-
literal|88.7228391116729996054057115466466007136640
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the natural log of the biggest number that can  * be represented with double precision format (2^127 (1-2^-56)).  */
end_comment

begin_decl_stmt
name|double
name|maxf
init|=
literal|88.0296919311130542821106916173739672939966
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_ep0
index|[
name|EXP_SIZE0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_ep1
index|[
name|EXP_SIZE1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_ep2
index|[
name|EXP_SIZE2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_ep3
index|[
name|EXP_SIZE3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_ep4
index|[
name|EXP_SIZE4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_en0
index|[
name|EXP_SIZE0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_en1
index|[
name|EXP_SIZE1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_en2
index|[
name|EXP_SIZE2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_en3
index|[
name|EXP_SIZE3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|_en4
index|[
name|EXP_SIZE4
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|exp
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|int
name|a0
decl_stmt|;
union|union
block|{
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|unsigned
name|char
name|b0
decl_stmt|;
name|unsigned
name|char
name|b1
decl_stmt|;
name|unsigned
name|char
name|b2
decl_stmt|;
name|unsigned
name|char
name|b3
decl_stmt|;
block|}
name|b
struct|;
block|}
name|u
union|;
specifier|register
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|abs_arg
union|;
if|if
condition|(
name|arg
operator|==
literal|0.0
condition|)
return|return
operator|(
literal|1.0
operator|)
return|;
if|if
condition|(
name|arg
operator|>=
literal|0.0
condition|)
block|{
name|abs_arg
operator|.
name|d
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|abs_arg
operator|.
name|i
operator|>=
literal|0x42000000
condition|)
block|{
comment|/* if (abs_arg.i>= 8.0) */
if|if
condition|(
name|abs_arg
operator|.
name|d
operator|>
name|maxf
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
operator|(
name|HUGE
operator|)
return|;
block|}
name|a0
operator|=
name|abs_arg
operator|.
name|d
expr_stmt|;
return|return
operator|(
name|exp
argument_list|(
name|arg
operator|-
operator|(
name|a0
operator|&
literal|0x78
operator|)
argument_list|)
operator|*
name|_ep0
index|[
name|a0
operator|>>
literal|3
index|]
operator|)
return|;
block|}
name|abs_arg
operator|.
name|i
operator|+=
name|EXPONENT28
expr_stmt|;
comment|/* multiply by 2 to 28th power */
name|u
operator|.
name|i
operator|=
name|abs_arg
operator|.
name|d
expr_stmt|;
name|abs_arg
operator|.
name|d
operator|=
name|u
operator|.
name|i
expr_stmt|;
name|abs_arg
operator|.
name|i
operator|-=
name|EXPONENT28
expr_stmt|;
comment|/* divide by 2 to 28th power */
return|return
operator|(
operator|(
operator|(
name|arg
operator|-
name|abs_arg
operator|.
name|d
operator|)
operator|+
literal|1.
operator|)
operator|*
name|_ep1
index|[
name|u
operator|.
name|b
operator|.
name|b0
index|]
operator|*
name|_ep2
index|[
name|u
operator|.
name|b
operator|.
name|b1
index|]
operator|*
name|_ep3
index|[
name|u
operator|.
name|b
operator|.
name|b2
index|]
operator|*
name|_ep4
index|[
name|u
operator|.
name|b
operator|.
name|b3
index|]
operator|)
return|;
block|}
else|else
block|{
name|abs_arg
operator|.
name|d
operator|=
operator|-
name|arg
expr_stmt|;
if|if
condition|(
name|abs_arg
operator|.
name|i
operator|>=
literal|0x42000000
condition|)
block|{
if|if
condition|(
name|arg
operator|<
name|minf
condition|)
return|return
operator|(
literal|0.
operator|)
return|;
name|a0
operator|=
operator|-
name|arg
expr_stmt|;
return|return
operator|(
name|exp
argument_list|(
name|arg
operator|+
operator|(
name|a0
operator|&
literal|0x78
operator|)
argument_list|)
operator|*
name|_en0
index|[
name|a0
operator|>>
literal|3
index|]
operator|)
return|;
block|}
name|abs_arg
operator|.
name|i
operator|+=
name|EXPONENT28
expr_stmt|;
comment|/* multiply by 2 to 28th power */
name|u
operator|.
name|i
operator|=
name|abs_arg
operator|.
name|d
expr_stmt|;
name|abs_arg
operator|.
name|d
operator|=
name|u
operator|.
name|i
expr_stmt|;
name|abs_arg
operator|.
name|i
operator|-=
name|EXPONENT28
expr_stmt|;
comment|/* divide by 2 to 28th power */
return|return
operator|(
operator|(
operator|(
name|arg
operator|+
name|abs_arg
operator|.
name|d
operator|)
operator|+
literal|1.
operator|)
operator|*
name|_en1
index|[
name|u
operator|.
name|b
operator|.
name|b0
index|]
operator|*
name|_en2
index|[
name|u
operator|.
name|b
operator|.
name|b1
index|]
operator|*
name|_en3
index|[
name|u
operator|.
name|b
operator|.
name|b2
index|]
operator|*
name|_en4
index|[
name|u
operator|.
name|b
operator|.
name|b3
index|]
operator|)
return|;
block|}
block|}
end_function

end_unit

