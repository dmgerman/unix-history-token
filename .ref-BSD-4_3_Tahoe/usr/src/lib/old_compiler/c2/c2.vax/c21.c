begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)c21.c 4.19 4/27/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* char C21[] = {"@(#)c21.c 1.83 80/10/16 21:18:22 JFR"}; /* sccs ident */
end_comment

begin_comment
comment|/*  * C object code improver-- second part  */
end_comment

begin_include
include|#
directive|include
file|"c2.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|NUSE
value|6
end_define

begin_decl_stmt
name|int
name|ioflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|biti
index|[
name|NUSE
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bitsize
index|[]
init|=
block|{
comment|/* index by type codes */
literal|0
block|,
comment|/* 0	not allocated */
literal|8
block|,
comment|/* 1	BYTE */
literal|16
block|,
comment|/* 2	WORD */
literal|32
block|,
comment|/* 3	LONG */
literal|32
block|,
comment|/* 4	FFLOAT / 	64,		/* 5	DFLOAT */
literal|64
block|,
comment|/* 6	QUAD */
literal|0
block|,
comment|/* 7	OP2 */
literal|0
block|,
comment|/* 8	OP3 */
literal|0
block|,
comment|/* 9	OPB */
literal|0
block|,
comment|/* 10	OPX */
literal|64
block|,
comment|/* 11	GFLOAT */
literal|128
block|,
comment|/* 12	HFLOAT */
literal|128
comment|/* 13	OCTA */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|,
name|siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for bit field communication */
end_comment

begin_decl_stmt
name|struct
name|node
modifier|*
name|uses
index|[
name|NUSE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for backwards flow analysis */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastrand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last operand of instruction */
end_comment

begin_function_decl
name|struct
name|node
modifier|*
name|bflow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|node
modifier|*
name|bicopt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|findcon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|redun3
argument_list|(
name|p
argument_list|,
name|split
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|split
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* check for 3 addr instr which should be 2 addr */
if|if
condition|(
name|OP3
operator|==
operator|(
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&
literal|0xF
operator|)
condition|)
block|{
if|if
condition|(
name|split
condition|)
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|op
operator|==
name|ADD
operator|||
name|p
operator|->
name|op
operator|==
name|MUL
operator|||
name|p
operator|->
name|op
operator|==
name|BIS
operator|||
name|p
operator|->
name|op
operator|==
name|XOR
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|regs
index|[
name|RT1
index|]
decl_stmt|;
name|regs
index|[
name|RT1
index|]
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|regs
index|[
name|RT2
index|]
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
condition|)
block|{
name|p
operator|->
name|subop
operator|=
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator||
operator|(
name|OP2
operator|<<
literal|4
operator|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
operator|*
name|regs
index|[
name|RT3
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|bmove
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|refcount
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lastp
operator|=
operator|&
name|first
init|;
literal|0
operator|!=
operator|(
name|p
operator|=
name|p
operator|->
name|forw
operator|)
condition|;
name|lastp
operator|=
name|p
control|)
empty_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
name|clearuse
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lastp
init|;
name|p
operator|!=
operator|&
name|first
condition|;
name|p
operator|=
name|p
operator|->
name|back
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Uses:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|NUSE
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|uses
index|[
name|r
index|]
condition|)
name|printf
argument_list|(
literal|"%d: %s\n"
argument_list|,
name|r
argument_list|,
name|uses
index|[
name|r
index|]
operator|->
name|code
condition|?
name|uses
index|[
name|r
index|]
operator|->
name|code
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-\n"
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
name|OP2
operator|==
name|r
operator|&&
operator|(
name|cp1
operator|=
name|p
operator|->
name|code
operator|,
operator|*
name|cp1
operator|++
operator|)
operator|==
literal|'$'
operator|&&
operator|*
name|cp1
operator|++
operator|==
literal|'0'
operator|&&
operator|*
name|cp1
operator|++
operator|==
literal|','
operator|&&
operator|!
name|source
argument_list|(
name|cp1
argument_list|)
condition|)
block|{
comment|/* a no-op unless MUL or DIV */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MUL
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|p
operator|->
name|subop
operator|&=
literal|0xF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|DIV
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c2: zero divide\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|OP3
operator|==
name|r
operator|&&
literal|0
operator|!=
name|redun3
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|LABEL
case|:
case|case
name|DLABEL
case|:
for|for
control|(
name|r
operator|=
name|NUSE
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|uses
index|[
name|r
index|]
condition|)
name|p
operator|->
name|ref
operator|=
operator|(
expr|struct
name|node
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|p
operator|->
name|ref
operator|)
operator||
name|biti
index|[
name|r
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|CALLS
case|:
name|clearuse
argument_list|()
expr_stmt|;
goto|goto
name|std
goto|;
case|case
literal|0
case|:
comment|/* 		 * Be conservative -- if we don't know what it is, then we 		 *	assume that it can set anything. 		 */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUSE
condition|;
operator|++
name|r
control|)
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|SUB
case|:
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|!=
name|LONG
condition|)
goto|goto
name|std
goto|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
literal|"fp"
argument_list|)
operator|&&
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
comment|/* address comp. */
name|char
name|buf
index|[
name|C2_ASIZE
index|]
decl_stmt|;
name|cp2
operator|=
name|buf
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|'-'
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|--
name|cp2
expr_stmt|;
name|cp1
operator|=
literal|"(fp),"
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|--
name|cp2
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|MOVA
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'-'
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
operator|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|'$'
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|cp1
expr_stmt|;
block|}
goto|goto
name|std
goto|;
case|case
name|ADD
case|:
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|!=
name|LONG
condition|)
goto|goto
name|std
goto|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstatic
argument_list|(
name|cp1
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
name|p
operator|->
name|forw
condition|)
block|{
comment|/* address comp: 			**	addl2	$_foo,r0  \	movab	_foo[r0],bar 			**	movl	r0,bar	  / 			*/
specifier|register
name|struct
name|node
modifier|*
name|pnext
init|=
name|p
operator|->
name|forw
decl_stmt|;
name|char
name|buf
index|[
name|C2_ASIZE
index|]
decl_stmt|;
if|if
condition|(
name|pnext
operator|->
name|op
operator|==
name|MOV
operator|&&
name|pnext
operator|->
name|subop
operator|==
name|LONG
condition|)
block|{
name|cp1
operator|=
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|cp2
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|cp2
operator|--
expr_stmt|;
name|splitrand
argument_list|(
name|pnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pnext
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|MOVA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|'['
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|cp2
operator|--
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|']'
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|','
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
literal|"fp"
argument_list|)
operator|&&
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
comment|/* address comp. */
name|cp2
operator|=
name|cp1
operator|-
literal|1
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|--
name|cp2
expr_stmt|;
name|cp1
operator|=
literal|"(fp)"
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|*
operator|--
name|cp2
operator|=
literal|','
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|MOVA
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'-'
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
operator|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|SUB
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|'$'
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|cp1
expr_stmt|;
block|}
comment|/* fall thru ... */
case|case
name|CASE
case|:
default|default:
name|std
label|:
name|p
operator|=
name|bflow
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MUL
case|:
block|{
comment|/* 		** Change multiplication by constant powers of 2 to 		**	shifts. 		*/
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|ispow2
argument_list|(
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
comment|/* mull3 $1,x,y */
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP3
argument_list|)
condition|)
block|{
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
block|}
goto|goto
name|std
goto|;
case|case
literal|1
case|:
comment|/* mull2 $2,x */
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
operator|&&
operator|!
name|source
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
goto|goto
name|std
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP3
argument_list|)
operator|||
operator|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
operator|&&
operator|!
name|source
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
condition|)
name|strcpy
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
literal|"$%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ASH
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
goto|goto
name|std
goto|;
block|}
case|case
name|ASH
case|:
block|{
comment|/* address comp: 		**	ashl	$1,bar,r0  \	movl	bar,r0 		**	movab	_foo[r0]   /	movaw	_foo[r0] 		** 		**	ashl	$2,r0,r0   \	moval	_foo[r0] 		**	movab	_foo[r0]   / 		*/
specifier|register
name|struct
name|node
modifier|*
name|pf
decl_stmt|;
specifier|register
name|int
name|shfrom
decl_stmt|,
name|shto
decl_stmt|;
name|long
name|shcnt
decl_stmt|;
name|char
modifier|*
name|regfrom
decl_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|shcnt
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|1
operator|||
name|shcnt
operator|>
literal|3
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|shfrom
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|regfrom
operator|=
name|copy
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|shto
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|shto
operator|<
name|NUSE
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|uses
index|[
name|shto
index|]
operator|!=
operator|(
name|pf
operator|=
name|p
operator|->
name|forw
operator|)
condition|)
goto|goto
name|ashadd
goto|;
if|if
condition|(
name|pf
operator|->
name|op
operator|!=
name|MOVA
operator|&&
name|pf
operator|->
name|op
operator|!=
name|PUSHA
condition|)
goto|goto
name|ashadd
goto|;
if|if
condition|(
name|pf
operator|->
name|subop
operator|!=
name|BYTE
condition|)
goto|goto
name|ashadd
goto|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
goto|goto
name|std
goto|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isstatic
argument_list|(
name|cp2
argument_list|)
condition|)
goto|goto
name|std
goto|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|!=
literal|'['
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|++
operator|!=
literal|'r'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
goto|goto
name|std
goto|;
name|regnum
operator|=
operator|*
name|cp2
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp2
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
goto|goto
name|std
goto|;
name|regnum
operator|*=
literal|10
expr_stmt|;
name|regnum
operator|+=
operator|*
name|cp2
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|!=
name|shto
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|shfrom
operator|>=
literal|0
condition|)
comment|/* ashl $N,r*,r0 */
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|shfrom
operator|!=
name|shto
condition|)
block|{
name|uses
index|[
name|shto
index|]
operator|=
name|NULL
expr_stmt|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|!=
literal|'['
condition|)
empty_stmt|;
name|cp1
operator|=
name|regfrom
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|*
operator|--
name|cp2
operator|=
literal|']'
expr_stmt|;
operator|*
operator|++
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|newcode
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|RT3
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|shcnt
condition|)
block|{
case|case
literal|1
case|:
name|pf
operator|->
name|subop
operator|=
name|WORD
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pf
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pf
operator|->
name|subop
operator|=
name|QUAD
expr_stmt|;
break|break;
block|}
name|redunm
operator|++
expr_stmt|;
name|nsaddr
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
goto|goto
name|std
goto|;
block|}
name|ashadd
label|:
comment|/* at this point, RT2 and RT3 are guaranteed to be simple regs*/
if|if
condition|(
name|shcnt
operator|==
literal|1
operator|&&
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
condition|)
block|{
comment|/* 			** quickie: 			**	ashl	$1,A,A>	addl2	A,A 			*/
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|RT3
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
goto|goto
name|std
goto|;
block|}
case|case
name|EXTV
case|:
case|case
name|EXTZV
case|:
block|{
comment|/* bit tests: 		**	extv	A,$1,B,rC  \ 		**	tstl	rC>	jbc	A,B,D 		**	jeql	D	   / 		** 		** also byte- and word-size fields: 		**	extv	$n*8,$8,A,B>	cvtbl	n+A,B 		**	extv	$n*16,$16,A,B>	cvtwl	2n+A,B 		**	extzv	$n*8,$8,A,B>	movzbl	n+A,B 		**	extzv	$n*16,$16,A,B>	movzwl	2n+A,B 		*/
specifier|register
name|struct
name|node
modifier|*
name|pf
decl_stmt|;
comment|/* forward node */
specifier|register
name|struct
name|node
modifier|*
name|pn
decl_stmt|;
comment|/* next node (after pf) */
name|int
name|flen
decl_stmt|;
comment|/* field length */
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|RT2
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|flen
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT2
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|flen
operator|==
literal|1
condition|)
block|{
specifier|register
name|int
name|extreg
decl_stmt|;
comment|/* reg extracted to */
name|extreg
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|extreg
operator|<
literal|0
operator|||
name|extreg
operator|>=
name|NUSE
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|pf
operator|=
name|p
operator|->
name|forw
operator|)
operator|->
name|op
operator|!=
name|TST
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|uses
index|[
name|extreg
index|]
operator|&&
name|uses
index|[
name|extreg
index|]
operator|!=
name|pf
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|extreg
operator|!=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|pn
operator|=
name|pf
operator|->
name|forw
operator|)
operator|->
name|op
operator|!=
name|CBR
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|pn
operator|->
name|subop
operator|!=
name|JEQ
operator|&&
name|pn
operator|->
name|subop
operator|!=
name|JNE
condition|)
goto|goto
name|std
goto|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delnode
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pn
operator|->
name|subop
operator|=
operator|(
name|pn
operator|->
name|subop
operator|==
name|JEQ
operator|)
condition|?
name|JBC
else|:
name|JBS
expr_stmt|;
for|for
control|(
name|cp2
operator|=
name|p
operator|->
name|code
init|;
operator|*
name|cp2
operator|++
operator|!=
literal|','
condition|;
control|)
empty_stmt|;
for|for
control|(
name|cp1
operator|=
name|cp2
init|;
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|;
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|!=
literal|','
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|pn
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|pn
operator|->
name|pop
operator|=
name|NULL
expr_stmt|;
name|uses
index|[
name|extreg
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flen
operator|==
literal|8
operator|||
name|flen
operator|==
literal|16
condition|)
block|{
specifier|register
name|int
name|boff
decl_stmt|;
comment|/* bit offset */
specifier|register
name|int
name|coff
decl_stmt|;
comment|/* chunk (byte or word) offset*/
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|boff
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
name|coff
operator|=
name|boff
operator|/
name|flen
expr_stmt|;
if|if
condition|(
name|coff
operator|&&
operator|(
name|isreg
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|)
operator|>=
literal|0
operator|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|boff
operator|<
literal|0
operator|||
operator|(
name|boff
operator|%
name|flen
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|std
goto|;
name|p
operator|->
name|op
operator|=
operator|(
name|p
operator|->
name|op
operator|==
name|EXTV
operator|)
condition|?
name|CVT
else|:
name|MOVZ
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
operator|(
name|flen
operator|==
literal|8
condition|?
name|BYTE
else|:
name|WORD
operator|)
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
literal|"%d%s%s"
argument_list|,
operator|(
name|flen
operator|==
literal|8
condition|?
name|coff
else|:
literal|2
operator|*
name|coff
operator|)
argument_list|,
operator|(
name|regs
index|[
name|RT3
index|]
index|[
literal|0
index|]
operator|==
literal|'('
condition|?
literal|""
else|:
literal|"+"
operator|)
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT4
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|RT3
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regs
index|[
name|RT4
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|nchange
operator|++
expr_stmt|;
goto|goto
name|std
goto|;
block|}
case|case
name|CMP
case|:
block|{
comment|/* comparison to -63 to -1: 		**	cmpl	r0,$-1>	incl	r0 		**	jeql	... 		** 		**	cmpl	r0,$-63>	addl2	$63,r0 		**	jeql	... 		*/
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|regp
init|=
name|p
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|subop
operator|!=
name|JEQ
operator|&&
name|p
operator|->
name|forw
operator|->
name|subop
operator|!=
name|JNE
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
literal|"$-"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|std
goto|;
name|reg
operator|=
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|!=
literal|0
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|r
operator|>=
name|NUSE
operator|&&
name|regp
operator|->
name|op
operator|==
name|MOV
operator|&&
name|p
operator|->
name|subop
operator|==
name|regp
operator|->
name|subop
condition|)
block|{
if|if
condition|(
operator|*
name|regp
operator|->
name|code
operator|!=
literal|'r'
condition|)
goto|goto
name|std
goto|;
name|reg
operator|=
name|regp
operator|->
name|code
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|regp
operator|->
name|code
index|[
literal|2
index|]
argument_list|)
operator|||
name|reg
operator|>=
name|NUSE
operator|||
name|uses
index|[
name|reg
index|]
condition|)
goto|goto
name|std
goto|;
block|}
if|if
condition|(
name|r
operator|>=
name|NUSE
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|reg
operator|!=
name|r
condition|)
name|sprintf
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
literal|"r%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT2
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|num
operator|>
literal|63
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|INC
expr_stmt|;
name|regs
index|[
name|RT2
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|regs
index|[
name|RT1
index|]
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|regs
index|[
name|RT2
index|]
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|OP2
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|2
index|]
init|;
name|t
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|t
condition|;
name|t
operator|++
control|)
empty_stmt|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
goto|goto
name|std
goto|;
block|}
case|case
name|JSB
case|:
if|if
condition|(
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
literal|"mcount"
argument_list|)
condition|)
block|{
name|uses
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
goto|goto
name|std
goto|;
case|case
name|JBR
case|:
case|case
name|JMP
case|:
name|clearuse
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|RET
operator|||
name|p
operator|->
name|subop
operator|==
name|RSB
condition|)
block|{
name|uses
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|ref
operator|==
literal|0
condition|)
goto|goto
name|std
goto|;
comment|/* jmp (r0) */
comment|/* fall through */
case|case
name|CBR
case|:
if|if
condition|(
name|p
operator|->
name|ref
operator|->
name|ref
operator|!=
literal|0
condition|)
for|for
control|(
name|r
operator|=
name|NUSE
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|biti
index|[
name|r
index|]
operator|&
operator|(
name|int
operator|)
name|p
operator|->
name|ref
operator|->
name|ref
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
case|case
name|EROU
case|:
case|case
name|JSW
case|:
case|case
name|TEXT
case|:
case|case
name|DATA
case|:
case|case
name|BSS
case|:
case|case
name|ALIGN
case|:
case|case
name|WGEN
case|:
case|case
name|END
case|:
empty_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
operator|&
name|first
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
operator|||
name|p
operator|->
name|op
operator|==
name|DLABEL
condition|)
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
comment|/* erase our tracks */
block|}
end_block

begin_macro
name|rmove
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|int
name|r1
decl_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
operator|*
name|conloc
condition|)
block|{
name|r1
operator|=
name|conval
index|[
literal|0
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"Con %s = %d%d %s\n"
argument_list|,
name|conloc
argument_list|,
name|r1
operator|&
literal|0xF
argument_list|,
name|r1
operator|>>
literal|4
argument_list|,
name|conval
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Regs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NREG
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
condition|)
block|{
name|r1
operator|=
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%d: %d%d %s\n"
argument_list|,
name|r
argument_list|,
name|r1
operator|&
literal|0xF
argument_list|,
name|r1
operator|>>
literal|4
argument_list|,
name|regs
index|[
name|r
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"-\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|CVT
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|mov
goto|;
case|case
name|MOV
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|findrand
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|mov
label|:
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
expr_stmt|;
name|r1
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|r1
operator|>=
literal|0
condition|)
name|savereg
argument_list|(
name|r1
argument_list|,
name|regs
index|[
name|r
index|]
operator|+
literal|1
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|CVT
condition|)
name|savereg
argument_list|(
name|r
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|>=
literal|0
condition|)
name|savereg
argument_list|(
name|r1
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|CVT
condition|)
name|setcon
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
break|break;
comment|/* .rx,.wx */
case|case
name|MFPR
case|:
case|case
name|COM
case|:
case|case
name|NEG
case|:
comment|/* .rx,.wx or .rx,.rx,.wx */
case|case
name|ADD
case|:
case|case
name|SUB
case|:
case|case
name|BIC
case|:
case|case
name|BIS
case|:
case|case
name|XOR
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
case|case
name|ASH
case|:
case|case
name|MOVZ
case|:
comment|/* .rx,.rx,.rx,.wx */
case|case
name|EXTV
case|:
case|case
name|EXTZV
case|:
case|case
name|INSV
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|lastrand
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|INSV
condition|)
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* .mx or .wx */
case|case
name|CLR
case|:
case|case
name|INC
case|:
case|case
name|DEC
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|lastrand
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CLR
condition|)
if|if
condition|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|savereg
argument_list|(
name|r
argument_list|,
literal|"$0"
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
else|else
name|setcon
argument_list|(
literal|"$0"
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
break|break;
comment|/* .rx */
case|case
name|TST
case|:
case|case
name|PUSH
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT1
operator|+
literal|1
index|]
expr_stmt|;
comment|/* fool repladdr into doing 1 operand */
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|TST
operator|&&
name|equstr
argument_list|(
name|lastrand
operator|=
name|regs
index|[
name|RT1
index|]
argument_list|,
name|ccloc
operator|+
literal|1
argument_list|)
operator|&&
operator|(
operator|(
literal|0xf
operator|&
operator|(
name|ccloc
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|)
operator|==
name|p
operator|->
name|subop
operator|||
name|equtype
argument_list|(
name|ccloc
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
operator|)
operator|&&
operator|!
name|source
argument_list|(
name|lastrand
argument_list|)
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|nrtst
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
name|setcc
argument_list|(
name|lastrand
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
break|break;
comment|/* .rx,.rx,.rx */
case|case
name|PROBER
case|:
case|case
name|PROBEW
case|:
case|case
name|CASE
case|:
case|case
name|MOVC3
case|:
comment|/* .rx,.rx */
case|case
name|MTPR
case|:
case|case
name|CALLS
case|:
case|case
name|CMP
case|:
case|case
name|BIT
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* fool repladdr into doing right number of operands */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CASE
operator|||
name|p
operator|->
name|op
operator|==
name|PROBER
operator|||
name|p
operator|->
name|op
operator|==
name|PROBEW
condition|)
name|lastrand
operator|=
name|regs
index|[
name|RT4
index|]
expr_stmt|;
comment|/*		else if (p->op==CMPV || p->op==CMPZV) lastrand=regs[RT4+1]; */
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOVC3
condition|)
name|lastrand
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
else|else
name|lastrand
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CALLS
operator|||
name|p
operator|->
name|op
operator|==
name|MOVC3
condition|)
name|clearreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|BIT
condition|)
name|bitopt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CBR
case|:
if|if
condition|(
name|p
operator|->
name|subop
operator|>=
name|JBC
condition|)
block|{
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|subop
operator|<
name|JBCC
condition|)
name|lastrand
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
comment|/* 2 operands can be optimized */
else|else
name|lastrand
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
comment|/* .mb destinations lose */
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|JBR
case|:
name|redunbr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* .wx,.bb */
case|case
name|SOB
case|:
default|default:
name|clearreg
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|byondrd
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* return pointer to register which is "beyond last read/modify operand" */
if|if
condition|(
name|OP2
operator|==
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
condition|)
return|return
operator|(
name|regs
index|[
name|RT3
index|]
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|MFPR
case|:
case|case
name|JSB
case|:
case|case
name|PUSHA
case|:
case|case
name|TST
case|:
case|case
name|INC
case|:
case|case
name|DEC
case|:
case|case
name|PUSH
case|:
return|return
operator|(
name|regs
index|[
name|RT2
index|]
operator|)
return|;
case|case
name|MTPR
case|:
case|case
name|BIT
case|:
case|case
name|CMP
case|:
case|case
name|CALLS
case|:
return|return
operator|(
name|regs
index|[
name|RT3
index|]
operator|)
return|;
case|case
name|PROBER
case|:
case|case
name|PROBEW
case|:
case|case
name|CASE
case|:
case|case
name|MOVC3
case|:
return|return
operator|(
name|regs
index|[
name|RT4
index|]
operator|)
return|;
block|}
return|return
operator|(
name|lastrand
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|bflow
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
modifier|*
name|preg
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|int
name|flow
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|node
modifier|*
name|olduse
init|=
literal|0
decl_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|PUSH
operator|&&
name|p
operator|->
name|subop
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|lastrand
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
name|p
operator|->
name|forw
condition|)
block|{
if|if
condition|(
name|equtype
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|(
operator|(
name|p
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|op
operator|==
name|MOVZ
operator|)
operator|&&
literal|0xf
operator|&
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|&&
name|compat
argument_list|(
literal|0xf
operator|&
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
argument_list|,
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|int
name|r2
decl_stmt|;
if|if
condition|(
name|regs
index|[
name|r
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* send directly to destination */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|INC
operator|||
name|p
operator|->
name|op
operator|==
name|DEC
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|DEC
condition|)
name|p
operator|->
name|op
operator|=
name|SUB
expr_stmt|;
else|else
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|subop
operator|=
operator|(
name|OP2
operator|<<
literal|4
operator|)
operator|+
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
expr_stmt|;
comment|/* use 2 now, convert to 3 later */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|lastrand
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* copy reg */
name|cp1
operator|=
name|lastrand
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
block|}
name|cp1
operator|=
name|regs
index|[
name|r
index|]
operator|+
literal|1
expr_stmt|;
name|cp2
operator|=
name|lastrand
expr_stmt|;
if|if
condition|(
name|OP2
operator|==
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* use 3 operand form of instruction */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|subop
operator|+=
operator|(
name|OP3
operator|-
name|OP2
operator|)
operator|<<
literal|4
expr_stmt|;
name|lastrand
operator|=
name|cp2
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|PUSH
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|PUSHA
expr_stmt|;
operator|*
name|regs
index|[
name|RT2
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|PUSH
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|PUSH
expr_stmt|;
operator|*
name|regs
index|[
name|RT2
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
name|delnode
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|r2
operator|=
name|isreg
argument_list|(
name|lastrand
argument_list|)
operator|)
operator|&&
name|r2
operator|<
name|NUSE
condition|)
block|{
name|uses
index|[
name|r2
index|]
operator|=
name|uses
index|[
name|r
index|]
expr_stmt|;
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|redun3
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
name|flow
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|EXTV
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|EXTZV
condition|)
block|{
comment|/* superfluous fetch */
name|int
name|nmatch
decl_stmt|;
name|char
name|src
index|[
name|C2_ASIZE
index|]
decl_stmt|;
name|movit
label|:
name|cp2
operator|=
name|src
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|splitrand
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|INC
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|DEC
condition|)
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|preg
operator|=
name|regs
operator|+
name|RT1
init|;
operator|*
name|preg
operator|!=
name|lastrand
condition|;
name|preg
operator|++
control|)
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
operator|*
name|preg
argument_list|)
condition|)
block|{
name|cp2
operator|=
operator|*
name|preg
expr_stmt|;
name|cp1
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|++
name|nmatch
expr_stmt|;
block|}
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|OP2
operator|==
operator|(
name|p
operator|->
name|forw
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&&
name|equstr
argument_list|(
name|src
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
block|{
name|p
operator|->
name|forw
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|subop
operator|+=
operator|(
name|OP3
operator|-
name|OP2
operator|)
operator|<<
literal|4
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'r'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|r
operator|+
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
block|}
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|r2
operator|=
name|isreg
argument_list|(
name|src
argument_list|)
operator|)
operator|&&
name|r2
operator|<
name|NUSE
condition|)
block|{
name|uses
index|[
name|r2
index|]
operator|=
name|uses
index|[
name|r
index|]
expr_stmt|;
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|redun3
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
name|flow
operator|=
name|r
expr_stmt|;
block|}
else|else
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
operator|(
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|MOVZ
operator|)
operator|&&
name|p
operator|->
name|forw
operator|->
name|subop
operator|&
literal|0xf
comment|/* if base or index, then forget it */
operator|&&
name|compat
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|p
operator|->
name|forw
operator|->
name|subop
argument_list|)
operator|&&
operator|!
name|source
argument_list|(
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
argument_list|)
operator|&&
operator|!
name|indexa
argument_list|(
name|cp1
argument_list|)
condition|)
goto|goto
name|movit
goto|;
block|}
comment|/* adjust 'lastrand' past any 'read' or 'modify' operands. */
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* a 'write' clobbers the register. */
if|if
condition|(
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|lastrand
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|||
name|OP2
operator|==
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
comment|/* writing a dead register is useless, but watch side effects */
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ACB
case|:
case|case
name|AOBLEQ
case|:
case|case
name|AOBLSS
case|:
case|case
name|SOBGTR
case|:
case|case
name|SOBGEQ
case|:
break|break;
default|default:
if|if
condition|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
comment|/* no direct uses, check for use of condition codes */
specifier|register
name|struct
name|node
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|nonlab
argument_list|(
name|q
operator|->
name|forw
argument_list|)
operator|)
operator|->
name|combop
operator|==
name|JBR
condition|)
name|q
operator|=
name|q
operator|->
name|ref
expr_stmt|;
comment|/* cc unused, unchanged */
if|if
condition|(
name|q
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
comment|/* ... and destroyed */
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
while|while
condition|(
name|cp1
operator|=
operator|*
name|preg
operator|++
condition|)
block|{
if|if
condition|(
name|cp1
operator|==
name|lastrand
condition|)
block|{
name|redunm
operator|++
expr_stmt|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|forw
operator|)
return|;
block|}
if|if
condition|(
name|source
argument_list|(
name|cp1
argument_list|)
operator|||
name|equstr
argument_list|(
name|cp1
argument_list|,
name|lastrand
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
name|flow
operator|=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|<=
operator|(
name|r
operator|=
name|flow
operator|)
condition|)
block|{
name|olduse
operator|=
name|uses
index|[
name|r
index|]
expr_stmt|;
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|r
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* these two are here, rather than in bmove(), 		/* because I decided that it was better to go for 3-address code 		/* (save time) rather than fancy jbxx (save 1 byte) 		/* on sequences like  bisl2 $64,r0; movl r0,foo 		*/
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|BIC
condition|)
block|{
name|p
operator|=
name|bicopt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|BIS
condition|)
block|{
operator|(
name|void
operator|)
name|bixprep
argument_list|(
name|p
argument_list|,
name|JBSS
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* now look for 'read' or 'modify' (read& write) uses */
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|cp1
operator|=
operator|*
name|preg
operator|++
operator|)
condition|)
block|{
comment|/* check for  r  */
if|if
condition|(
name|lastrand
operator|!=
name|cp1
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|cp1
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|r
index|]
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
name|p
operator|->
name|subop
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASH
operator|&&
name|preg
operator|==
operator|(
name|regs
operator|+
name|RT1
operator|+
literal|1
operator|)
condition|)
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
name|BYTE
expr_stmt|;
comment|/* stupid DEC */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|||
name|p
operator|->
name|op
operator|==
name|PUSH
operator|||
name|p
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|op
operator|==
name|MOVZ
operator|||
name|p
operator|->
name|op
operator|==
name|COM
operator|||
name|p
operator|->
name|op
operator|==
name|NEG
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PUSH
condition|)
name|cp1
operator|=
literal|"-(sp)"
expr_stmt|;
else|else
block|{
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|cp1
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
name|uses
index|[
name|r
index|]
operator|=
name|olduse
expr_stmt|;
comment|/* reincarnation!! */
comment|/* as in  addl2 r0,r1;  movl r1,r0;  ret  */
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|MOV
condition|)
name|cp1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp1
condition|)
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
else|else
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* check for (r),(r)+,-(r),[r] */
do|do
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'('
operator|||
operator|*
name|cp1
operator|==
literal|'['
condition|)
block|{
comment|/* get register number */
name|char
name|t
decl_stmt|;
name|cp2
operator|=
operator|++
name|cp1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp1
operator|!=
literal|')'
operator|&&
operator|*
name|cp1
operator|!=
literal|']'
condition|)
empty_stmt|;
name|t
operator|=
operator|*
name|cp1
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|cp2
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
operator|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
operator|||
name|uses
index|[
name|r
index|]
operator|==
name|p
operator|)
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|*
operator|--
name|cp2
operator|==
literal|'['
condition|?
name|OPX
operator|<<
literal|4
else|:
name|OPB
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|cp1
condition|)
do|;
block|}
comment|/* pushax or movax possibility? */
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'$'
operator|&&
name|isstatic
argument_list|(
name|cp1
argument_list|)
operator|&&
name|natural
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|combop
operator|==
name|T
argument_list|(
name|MOV
argument_list|,
name|LONG
argument_list|)
condition|)
block|{
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
literal|0
operator|!=
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|regs
index|[
name|RT1
index|]
operator|+
literal|2
argument_list|)
operator|)
condition|)
block|{
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|p
operator|->
name|code
operator|=
operator|--
name|cp1
expr_stmt|;
block|}
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|MOVA
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|combop
operator|==
name|T
argument_list|(
name|PUSH
argument_list|,
name|LONG
argument_list|)
condition|)
block|{
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|PUSHA
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|combop
operator|&
literal|0xFFFF
operator|)
operator|==
name|T
argument_list|(
name|ADD
argument_list|,
name|U
argument_list|(
name|LONG
argument_list|,
name|OP3
argument_list|)
argument_list|)
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
condition|)
block|{
name|cp1
operator|=
name|cp2
operator|=
name|p
operator|->
name|code
expr_stmt|;
operator|++
name|cp1
expr_stmt|;
do|do
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
expr_stmt|;
do|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
do|;
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
literal|'['
expr_stmt|;
do|do
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
expr_stmt|;
do|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
do|;
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
operator|!
name|equstr
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
literal|"-(sp)"
argument_list|)
condition|)
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|MOVA
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|PUSHA
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
name|OPX
operator|<<
literal|4
expr_stmt|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|ispow2
argument_list|(
name|n
argument_list|)
specifier|register
name|long
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* -1 -> no; else -> log to base 2 */
specifier|register
name|int
name|log
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|log
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|log
operator|)
return|;
operator|++
name|log
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|log
operator|)
return|;
block|}
block|}
end_block

begin_expr_stmt
name|bitopt
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change "bitx $<power_of_2>,a" followed by JEQ or JNE 	/* into JBC or JBS.  watch out for I/O registers. (?) 	/* assumes that 'splitrand' has already been called. 	*/
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|b
decl_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
operator|||
operator|!
name|okio
argument_list|(
name|cp2
argument_list|)
operator|||
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
operator|||
name|p
operator|->
name|forw
operator|->
name|subop
operator|&
operator|-
literal|2
operator|||
literal|0
operator|>
operator|(
name|b
operator|=
name|ispow2
argument_list|(
name|getnum
argument_list|(
name|cp1
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|subop
operator|!=
name|BYTE
operator|&&
operator|!
operator|(
name|b
operator|==
literal|0
operator|&&
name|p
operator|->
name|subop
operator|==
name|LONG
operator|)
operator|&&
operator|(
name|source
argument_list|(
name|cp2
argument_list|)
operator|||
name|indexa
argument_list|(
name|cp2
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|b
operator|>=
name|bitsize
index|[
name|p
operator|->
name|subop
index|]
condition|)
block|{
comment|/* you dummy! */
if|if
condition|(
name|source
argument_list|(
name|cp2
argument_list|)
condition|)
block|{
comment|/* side effect: auto increment or decrement */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|TST
expr_stmt|;
operator|--
name|cp1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|=
operator|*
name|cp2
operator|++
condition|)
empty_stmt|;
name|regs
index|[
name|RT2
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|JEQ
condition|)
block|{
name|p
operator|->
name|combop
operator|=
name|JBR
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|nbj
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp1
operator|=
name|p
operator|->
name|forw
operator|->
name|code
condition|)
block|{
comment|/* destination is not an internal label */
name|cp2
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|subop
operator|==
name|LONG
operator|||
operator|!
operator|(
name|source
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|||
name|indexa
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* JLB optimization, ala BLISS */
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|*
operator|(
name|regs
index|[
name|RT3
index|]
operator|)
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|subop
operator|+=
name|JLBC
operator|-
name|JBC
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|>
literal|9
condition|)
operator|*
name|cp1
operator|++
operator|=
name|b
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|b
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
comment|/* $<bit_number> */
block|}
name|nbj
operator|++
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|p
operator|->
name|forw
operator|->
name|combop
operator|+
operator|(
operator|(
name|JBC
operator|-
name|JEQ
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p
operator|->
name|forw
operator|->
name|labno
expr_stmt|;
name|delnode
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|isfield
argument_list|(
name|n
argument_list|)
specifier|register
name|long
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* -1 -> no; else -> position of low bit */
specifier|register
name|int
name|p
decl_stmt|;
specifier|register
name|long
name|t
decl_stmt|;
name|t
operator|=
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator||
name|n
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
operator|(
literal|0
operator|==
name|t
operator|||
literal|0
operator|<=
name|ispow2
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|n
operator|&
literal|1
operator|)
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bixprep
argument_list|(
name|p
argument_list|,
name|bix
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* initial setup, single-bit checking for bisopt, bicopt. /* return: 0->don't bother any more; 1->worthwhile trying */
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
operator|||
literal|0
operator|>
operator|(
name|pos
operator|=
name|isfield
argument_list|(
name|f
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
argument_list|)
operator|)
operator|||
operator|!
name|okio
argument_list|(
name|cp2
argument_list|)
operator|||
name|indexa
argument_list|(
name|cp2
argument_list|)
operator|||
name|source
argument_list|(
name|cp2
argument_list|)
operator|||
operator|!
name|okio
argument_list|(
name|lastrand
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|f
operator||=
name|f
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|f
operator|==
literal|0
condition|)
name|siz
operator|=
literal|32
operator|-
name|pos
expr_stmt|;
else|else
name|siz
operator|=
name|ispow2
argument_list|(
name|f
argument_list|)
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|siz
operator|==
literal|1
operator|&&
name|pos
operator|>
literal|5
operator|&&
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|==
name|OP2
operator|&&
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|!=
name|BYTE
operator|&&
name|pos
operator|<
name|bitsize
index|[
name|p
operator|->
name|subop
operator|&
literal|0xF
index|]
condition|)
block|{
name|p
operator|->
name|ref
operator|=
name|insertl
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|CBR
operator||
operator|(
name|bix
operator|<<
literal|8
operator|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p
operator|->
name|ref
operator|->
name|labno
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|9
condition|)
block|{
operator|*
name|cp1
operator|++
operator|=
name|pos
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|pos
operator|%=
literal|10
expr_stmt|;
block|}
operator|*
name|cp1
operator|++
operator|=
name|pos
operator|+
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nbj
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|node
modifier|*
name|bicopt
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* use field operations or MOVZ if possible.  done as part of 'bflow'. */
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
name|src
index|[
name|C2_ASIZE
index|]
decl_stmt|;
name|char
name|lhssiz
decl_stmt|,
name|sop
decl_stmt|;
if|if
condition|(
operator|!
name|bixprep
argument_list|(
name|p
argument_list|,
name|JBCC
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
comment|/* the BIC isolates low order bits */
name|siz
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|LONG
operator|&&
operator|*
operator|(
name|regs
index|[
name|RT2
index|]
operator|)
operator|!=
literal|'$'
condition|)
block|{
comment|/* result of EXTZV is long */
comment|/* save source of BICL in 'src' */
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|cp2
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|back
operator|->
name|op
operator|==
name|ASH
condition|)
block|{
comment|/* try for more */
name|splitrand
argument_list|(
name|p
operator|->
name|back
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'$'
operator|&&
operator|*
operator|(
name|regs
index|[
name|RT2
index|]
operator|)
operator|!=
literal|'$'
operator|&&
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|&&
literal|0
operator|>
operator|(
name|f
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
operator|)
operator|&&
name|equstr
argument_list|(
name|src
argument_list|,
name|cp2
argument_list|)
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|cp2
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|siz
operator|-
name|f
operator|<=
literal|32
condition|)
block|{
comment|/* a good ASH */
name|pos
operator|-=
name|f
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|cp2
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|delnode
argument_list|(
name|p
operator|->
name|back
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * 'pos', 'siz' known; find out the size of the 			 * left-hand operand of what the bicl will turn into. 			 */
if|if
condition|(
name|pos
operator|==
literal|0
operator|&&
name|siz
operator|==
literal|16
condition|)
name|lhssiz
operator|=
name|WORD
expr_stmt|;
comment|/* movzwl */
else|else
name|lhssiz
operator|=
name|BYTE
expr_stmt|;
comment|/* movzbl or extzvl */
if|if
condition|(
name|p
operator|->
name|back
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|back
operator|->
name|op
operator|==
name|MOVZ
condition|)
block|{
comment|/* greedy, aren't we? */
name|splitrand
argument_list|(
name|p
operator|->
name|back
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
comment|/* 				 * If indexa(cp1) || autoid(cp1), the fold may 				 * still be OK if the CVT/MOVZ has the same 				 * size operand on its left size as what we 				 * will turn the bicl into. 				 * However, if the CVT is from a float or 				 * double, forget it! 				 */
name|sop
operator|=
name|p
operator|->
name|back
operator|->
name|subop
operator|&
literal|0xF
expr_stmt|;
comment|/* type of LHS of CVT/MOVZ */
if|if
condition|(
name|equstr
argument_list|(
name|src
argument_list|,
name|cp2
argument_list|)
operator|&&
name|okio
argument_list|(
name|cp1
argument_list|)
operator|&&
name|sop
operator|!=
name|FFLOAT
operator|&&
name|sop
operator|!=
name|DFLOAT
operator|&&
name|sop
operator|!=
name|GFLOAT
operator|&&
name|sop
operator|!=
name|HFLOAT
operator|&&
operator|(
operator|(
operator|!
name|indexa
argument_list|(
name|cp1
argument_list|)
operator|&&
operator|!
name|autoid
argument_list|(
name|cp1
argument_list|)
operator|)
operator|||
name|lhssiz
operator|==
name|sop
operator|)
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|cp2
argument_list|)
operator|)
operator|&&
name|r
operator|<
name|NUSE
operator|&&
name|bitsize
index|[
name|sop
index|]
operator|>=
operator|(
name|pos
operator|+
name|siz
operator|)
operator|&&
name|bitsize
index|[
name|p
operator|->
name|back
operator|->
name|subop
operator|>>
literal|4
index|]
operator|>=
operator|(
name|pos
operator|+
name|siz
operator|)
condition|)
block|{
comment|/* good CVT */
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp2
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|delnode
argument_list|(
name|p
operator|->
name|back
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 'pos', 'siz' known; source of field is in 'src' */
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* retrieve destination of BICL */
if|if
condition|(
operator|(
name|siz
operator|==
literal|8
operator|||
name|siz
operator|==
literal|16
operator|)
operator|&&
name|pos
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|MOVZ
argument_list|,
name|U
argument_list|(
name|lhssiz
argument_list|,
name|LONG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s,%s"
argument_list|,
name|src
argument_list|,
name|lastrand
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|EXTZV
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"$%d,$%d,%s,%s"
argument_list|,
name|pos
argument_list|,
name|siz
argument_list|,
name|src
argument_list|,
name|lastrand
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|nfield
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* end EXTZV possibility */
block|}
comment|/* end low order bits */
comment|/* unfortunately, INSV clears the condition codes, thus cannot be used */
comment|/*	else {/* see if BICL2 of positive field should be INSV $0 */
comment|/*		if (p->subop==(LONG | (OP2<<4))&& 6<=(pos+siz)) { /*			p->combop = INSV; /*			sprintf(line,"$0,$%d,$%d,%s",pos,siz,lastrand); /*			p->code = copy(line); nfield++; return(p); /*		} /*	} */
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|jumpsw
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|tp
decl_stmt|;
name|long
name|tl
decl_stmt|;
name|char
modifier|*
name|tcp
decl_stmt|;
name|int
name|ti
decl_stmt|;
name|int
name|nj
decl_stmt|;
name|ti
operator|=
literal|0
expr_stmt|;
name|nj
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
name|p
operator|->
name|seq
operator|=
operator|++
name|ti
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p1
control|)
block|{
name|p1
operator|=
name|p
operator|->
name|forw
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CBR
operator|&&
name|p1
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p
operator|->
name|ref
operator|&&
name|p1
operator|->
name|ref
operator|&&
name|abs
argument_list|(
name|p
operator|->
name|seq
operator|-
name|p
operator|->
name|ref
operator|->
name|seq
argument_list|)
operator|>
name|abs
argument_list|(
name|p1
operator|->
name|seq
operator|-
name|p1
operator|->
name|ref
operator|->
name|seq
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|p1
operator|->
name|ref
condition|)
continue|continue;
name|p
operator|->
name|subop
operator|=
name|revbr
index|[
name|p
operator|->
name|subop
index|]
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p1
operator|->
name|ref
operator|=
name|p
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|tp
expr_stmt|;
name|tl
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|labno
operator|=
name|p
operator|->
name|labno
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|tl
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
if|if
condition|(
name|p
operator|->
name|labno
operator|==
literal|0
condition|)
block|{
name|tcp
operator|=
name|p1
operator|->
name|code
expr_stmt|;
name|p1
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|tcp
expr_stmt|;
block|}
endif|#
directive|endif
name|nrevbr
operator|++
expr_stmt|;
name|nj
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nj
operator|)
return|;
block|}
end_block

begin_macro
name|addsob
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|first
init|;
operator|(
name|p1
operator|=
name|p
operator|->
name|forw
operator|)
operator|!=
literal|0
condition|;
name|p
operator|=
name|p1
control|)
block|{
if|if
condition|(
name|p
operator|->
name|combop
operator|==
name|T
argument_list|(
name|DEC
argument_list|,
name|LONG
argument_list|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|CBR
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|p
operator|->
name|seq
operator|-
name|p1
operator|->
name|ref
operator|->
name|seq
argument_list|)
operator|>
literal|8
condition|)
continue|continue;
if|if
condition|(
name|p1
operator|->
name|subop
operator|==
name|JGE
operator|||
name|p1
operator|->
name|subop
operator|==
name|JGT
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|subop
operator|==
name|JGE
condition|)
name|p
operator|->
name|combop
operator|=
name|SOBGEQ
expr_stmt|;
else|else
name|p
operator|->
name|combop
operator|=
name|SOBGTR
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
name|delnode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nsob
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|combop
operator|==
name|T
argument_list|(
name|INC
argument_list|,
name|LONG
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p1
operator|->
name|refc
operator|==
literal|1
operator|&&
name|p1
operator|->
name|forw
operator|->
name|combop
operator|==
name|T
argument_list|(
name|CMP
argument_list|,
name|LONG
argument_list|)
operator|&&
operator|(
name|p2
operator|=
name|p1
operator|->
name|forw
operator|->
name|forw
operator|)
operator|->
name|combop
operator|==
name|T
argument_list|(
name|CBR
argument_list|,
name|JLE
argument_list|)
operator|&&
operator|(
name|p3
operator|=
name|p2
operator|->
name|ref
operator|->
name|back
operator|)
operator|->
name|combop
operator|==
name|JBR
operator|&&
name|p3
operator|->
name|ref
operator|==
name|p1
operator|&&
name|p3
operator|->
name|forw
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p3
operator|->
name|forw
operator|==
name|p2
operator|->
name|ref
condition|)
block|{
comment|/* change	INC LAB: CMP	to	LAB: INC CMP */
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|forw
expr_stmt|;
comment|/* adjust beginning value by 1 */
name|p2
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p2
operator|->
name|combop
operator|=
name|T
argument_list|(
name|DEC
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|p2
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p2
operator|->
name|forw
operator|=
name|p3
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|p3
operator|->
name|back
expr_stmt|;
name|p3
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p3
operator|->
name|back
operator|=
name|p2
expr_stmt|;
name|p2
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|p2
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|->
name|combop
operator|==
name|T
argument_list|(
name|CMP
argument_list|,
name|LONG
argument_list|)
operator|&&
operator|(
name|p2
operator|=
name|p1
operator|->
name|forw
operator|)
operator|->
name|op
operator|==
name|CBR
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|abs
argument_list|(
name|p
operator|->
name|seq
operator|-
name|p2
operator|->
name|ref
operator|->
name|seq
argument_list|)
operator|>
literal|8
condition|)
block|{
comment|/* outside byte displ range */
if|if
condition|(
name|p2
operator|->
name|subop
operator|!=
name|JLE
condition|)
continue|continue;
name|p
operator|->
name|combop
operator|=
name|T
argument_list|(
name|ACB
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* limit */
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|cp1
operator|=
literal|"$1"
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* increment */
name|cp2
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* index */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p2
operator|->
name|labno
expr_stmt|;
name|delnode
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|delnode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nsob
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2
operator|->
name|subop
operator|==
name|JLE
operator|||
name|p2
operator|->
name|subop
operator|==
name|JLT
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|subop
operator|==
name|JLE
condition|)
name|p
operator|->
name|combop
operator|=
name|AOBLEQ
expr_stmt|;
else|else
name|p
operator|->
name|combop
operator|=
name|AOBLSS
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* limit */
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* index */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p2
operator|->
name|labno
expr_stmt|;
name|delnode
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|delnode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nsob
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|node
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|combop
operator|!=
name|p2
operator|->
name|combop
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|op
operator|>
literal|0
operator|&&
name|p1
operator|->
name|op
operator|<
name|MOV
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|p1
operator|->
name|combop
condition|)
block|{
case|case
name|EROU
case|:
case|case
name|JSW
case|:
case|case
name|TEXT
case|:
case|case
name|DATA
case|:
case|case
name|BSS
case|:
case|case
name|ALIGN
case|:
case|case
name|WGEN
case|:
case|case
name|END
case|:
comment|/* 		 * Consider all pseudo-ops to be unique. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|p1
operator|->
name|labno
operator|!=
name|p2
operator|->
name|labno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp1
operator|=
name|p1
operator|->
name|code
expr_stmt|;
name|cp2
operator|=
name|p2
operator|->
name|code
expr_stmt|;
if|if
condition|(
name|cp1
operator|==
literal|0
operator|&&
name|cp2
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cp1
operator|==
literal|0
operator|||
name|cp2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|cp1
operator|==
operator|*
name|cp2
operator|++
condition|)
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|delnode
end_ifndef

begin_expr_stmt
name|delnode
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|decref
end_ifndef

begin_expr_stmt
name|decref
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|&&
operator|--
name|p
operator|->
name|refc
operator|<=
literal|0
condition|)
block|{
name|nrlab
operator|++
expr_stmt|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|node
modifier|*
name|nonlab
parameter_list|(
name|ap
parameter_list|)
name|struct
name|node
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|op
operator|==
name|LABEL
condition|)
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|clearuse
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|uses
operator|+
name|NUSE
init|;
name|i
operator|>
name|uses
condition|;
control|)
operator|*
operator|--
name|i
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|clearreg
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regs
init|;
name|i
operator|<
name|regs
operator|+
name|NREG
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|*
name|i
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|*
name|i
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
name|conloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|savereg
argument_list|(
name|ai
argument_list|,
name|s
argument_list|,
name|type
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|p
operator|=
name|regs
index|[
name|ai
index|]
expr_stmt|;
if|if
condition|(
name|source
argument_list|(
name|s
argument_list|)
condition|)
comment|/* side effects in addressing */
return|return;
comment|/* if any indexing, must be parameter or local */
comment|/* indirection (as in "*-4(fp)") is ok, however */
operator|*
name|p
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
operator|||
operator|*
name|s
operator|++
operator|==
literal|'('
operator|&&
operator|*
name|s
operator|!=
literal|'a'
operator|&&
operator|*
name|s
operator|!=
literal|'f'
condition|)
block|{
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|dest
argument_list|(
name|s
argument_list|,
name|type
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|source
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* handle addressing side effects */
if|if
condition|(
operator|!
name|natural
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* wild store, everything except constants vanishes */
for|for
control|(
name|i
operator|=
name|NREG
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|'$'
condition|)
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|conloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|isreg
argument_list|(
name|s
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* if register destination, that reg is a goner */
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
literal|0xF
condition|)
block|{
case|case
name|DFLOAT
case|:
comment|/* clobber two at once */
comment|/*FALLTHROUGH*/
case|case
name|GFLOAT
case|:
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HFLOAT
case|:
comment|/* clobber four at once */
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
name|type
operator|>>
literal|4
operator|)
operator|&
literal|0xF
condition|)
block|{
case|case
name|DFLOAT
case|:
comment|/* clobber two at once */
comment|/*FALLTHROUGH*/
case|case
name|GFLOAT
case|:
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HFLOAT
case|:
comment|/* clobber four at once */
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|3
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
name|NREG
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|equstr
argument_list|(
name|s
argument_list|,
name|regs
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
condition|)
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* previous indirection through destination is invalid */
while|while
condition|(
operator|(
name|i
operator|=
name|findrand
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
comment|/* previous values of destination are invalid */
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|conloc
operator|&&
name|equstr
argument_list|(
name|conloc
argument_list|,
name|s
argument_list|)
condition|)
name|conloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|setcc
argument_list|(
name|s
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* natural destinations set condition codes */
block|}
end_block

begin_comment
comment|/* separate operands at commas, set up 'regs' and 'lastrand' */
end_comment

begin_macro
name|splitrand
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|preg
decl_stmt|;
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
if|if
condition|(
name|p1
operator|=
name|p
operator|->
name|code
condition|)
while|while
condition|(
operator|*
name|p1
condition|)
block|{
name|lastrand
operator|=
name|p2
operator|=
operator|*
name|preg
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
literal|','
operator|==
operator|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
operator|)
condition|)
block|{
operator|--
name|p2
expr_stmt|;
break|break;
block|}
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|preg
operator|<
operator|(
name|regs
operator|+
name|RT1
operator|+
literal|5
operator|)
condition|)
operator|*
operator|(
operator|*
name|preg
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|compat
argument_list|(
argument|have
argument_list|,
argument|want
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|hsrc
decl_stmt|,
name|hdst
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|want
operator|&=
literal|0xF
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* anything satisfies a wildcard want */
name|hsrc
operator|=
name|have
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|hdst
operator|=
operator|(
operator|(
name|have
operator|>>
literal|4
operator|)
operator|&
literal|0xF
operator|)
operator|)
operator|||
operator|(
name|hdst
operator|>=
name|OP2
operator|&&
name|hdst
operator|<=
name|OPX
operator|)
condition|)
name|hdst
operator|=
name|hsrc
expr_stmt|;
if|if
condition|(
name|want
operator|>=
name|FFLOAT
condition|)
return|return
operator|(
name|hdst
operator|==
name|want
operator|&&
name|hsrc
operator|==
name|want
operator|)
return|;
comment|/* FLOAT, DFLOAT not compat: rounding */
return|return
operator|(
name|hsrc
operator|>=
name|want
operator|&&
name|hdst
operator|>=
name|want
operator|&&
name|hdst
operator|<
name|FFLOAT
operator|)
return|;
block|}
end_block

begin_macro
name|equtype
argument_list|(
argument|t1
argument_list|,
argument|t2
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|compat
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|&&
name|compat
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|findrand
argument_list|(
argument|as
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regs
operator|+
name|NREG
init|;
operator|--
name|i
operator|>=
name|regs
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|i
operator|&&
name|equstr
argument_list|(
operator|*
name|i
operator|+
literal|1
argument_list|,
name|as
argument_list|)
operator|&&
name|compat
argument_list|(
operator|*
operator|*
name|i
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|i
operator|-
name|regs
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|isreg
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'r'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
return|return
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'1'
operator|&&
name|isdigit
argument_list|(
operator|*
name|s
operator|++
argument_list|)
operator|&&
operator|*
name|s
operator|==
literal|0
condition|)
return|return
operator|(
literal|10
operator|+
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|check
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|p
operator|->
name|back
operator|!=
name|lp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c2: failed internal consistency check -- help!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|p
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|source
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|ap
expr_stmt|;
name|p2
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|&&
operator|*
operator|(
name|p2
operator|-
literal|1
operator|)
operator|!=
literal|'['
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
operator|==
literal|'('
operator|||
operator|*
name|p1
operator|==
literal|'*'
operator|&&
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|p1
operator|+
literal|2
operator|)
operator|==
literal|'('
operator|||
operator|*
operator|(
name|p2
operator|-
literal|2
operator|)
operator|==
literal|'+'
condition|)
block|{
while|while
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|++
operator|!=
literal|'r'
condition|)
empty_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p1
operator|++
argument_list|)
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p1
argument_list|)
condition|)
name|regs
index|[
literal|10
operator|+
operator|*
name|p1
operator|-
literal|'0'
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
literal|10
operator|+
operator|*
name|p1
operator|-
literal|'0'
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|--
name|p1
expr_stmt|;
name|regs
index|[
operator|*
name|p1
operator|-
literal|'0'
index|]
index|[
literal|0
index|]
operator|=
name|regs
index|[
operator|*
name|p1
operator|-
literal|'0'
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|newcode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
modifier|*
name|preg
decl_stmt|;
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
name|p2
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|p1
operator|=
operator|*
name|preg
operator|++
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
operator|*
operator|(
name|p2
operator|-
literal|1
operator|)
operator|=
literal|','
expr_stmt|;
block|}
operator|*
operator|--
name|p2
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|repladdr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
expr_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
modifier|*
name|preg
decl_stmt|;
name|int
name|nrepl
decl_stmt|;
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
name|nrepl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lastrand
operator|!=
operator|(
name|p1
operator|=
operator|*
name|preg
operator|++
operator|)
condition|)
if|if
condition|(
operator|!
name|source
argument_list|(
name|p1
argument_list|)
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|findrand
argument_list|(
name|p1
argument_list|,
name|p
operator|->
name|subop
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p1
operator|++
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|9
condition|)
block|{
operator|*
name|p1
operator|++
operator|=
literal|'1'
expr_stmt|;
name|r
operator|-=
literal|10
expr_stmt|;
block|}
operator|*
name|p1
operator|++
operator|=
name|r
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
name|nrepl
operator|++
expr_stmt|;
name|nsaddr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nrepl
condition|)
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* movedat() /* { /* 	register struct node *p1, *p2; /* 	struct node *p3; /* 	register seg; /* 	struct node data; /* 	struct node *datp; /*  /* 	if (first.forw == 0) /* 		return; /* 	datp =&data; /* 	for (p1 = first.forw; p1!=0; p1 = p1->forw) { /* 		if (p1->op == DATA) { /* 			p2 = p1->forw; /* 			while (p2&& p2->op!=TEXT) /* 				p2 = p2->forw; /* 			if (p2==0) /* 				break; /* 			p3 = p1->back; /* 			p1->back->forw = p2->forw; /* 			p2->forw->back = p3; /* 			p2->forw = 0; /* 			datp->forw = p1; /* 			p1->back = datp; /* 			p1 = p3; /* 			datp = p2; /* 		} /* 	} /* 	if (data.forw) { /* 		datp->forw = first.forw; /* 		first.forw->back = datp; /* 		data.forw->back =&first; /* 		first.forw = data.forw; /* 	} /* 	seg = -1; /* 	for (p1 = first.forw; p1!=0; p1 = p1->forw) { /* 		if (p1->op==TEXT||p1->op==DATA||p1->op==BSS) { /* 			if (p1->op == seg || p1->forw&&p1->forw->op==seg) { /* 				p1->back->forw = p1->forw; /* 				p1->forw->back = p1->back; /* 				p1 = p1->back; /* 				continue; /* 			} /* 			seg = p1->op; /* 		} /* 	} /* } */
end_comment

begin_expr_stmt
name|redunbr
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap1
decl_stmt|;
name|char
modifier|*
name|ap2
decl_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
name|p
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return;
name|p1
operator|=
name|nonlab
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|TST
condition|)
block|{
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|savereg
argument_list|(
name|RT2
argument_list|,
literal|"$0"
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|CMP
condition|)
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|p1
operator|->
name|forw
operator|->
name|op
operator|==
name|CBR
condition|)
block|{
name|ap1
operator|=
name|findcon
argument_list|(
name|RT1
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
name|ap2
operator|=
name|findcon
argument_list|(
name|RT2
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|p1
operator|->
name|subop
argument_list|,
name|ap1
argument_list|,
name|ap2
argument_list|)
condition|)
block|{
name|nredunj
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
if|if
condition|(
name|p
operator|->
name|labno
operator|==
literal|0
condition|)
name|p
operator|->
name|code
operator|=
name|p1
operator|->
name|code
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|ref
condition|)
name|p
operator|->
name|ref
operator|->
name|refc
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|TST
operator|&&
name|equstr
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|ccloc
operator|+
literal|1
argument_list|)
operator|&&
name|equtype
argument_list|(
name|ccloc
index|[
literal|0
index|]
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
condition|)
block|{
name|p1
operator|=
name|insertl
argument_list|(
name|p1
operator|->
name|forw
argument_list|)
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
expr_stmt|;
name|nrtst
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|findcon
parameter_list|(
name|i
parameter_list|,
name|type
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|r
expr_stmt|;
name|p
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|p
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|compat
argument_list|(
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|regs
index|[
name|r
index|]
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|equstr
argument_list|(
name|p
argument_list|,
name|conloc
argument_list|)
condition|)
return|return
operator|(
name|conval
operator|+
literal|1
operator|)
return|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|compare
argument_list|(
argument|opc
argument_list|,
argument|acp1
argument_list|,
argument|acp2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp1
decl_stmt|,
modifier|*
name|acp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|n1
expr_stmt|;
name|int
name|n2
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|cp1
operator|=
name|acp1
expr_stmt|;
name|cp2
operator|=
name|acp2
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
operator|||
operator|*
name|cp2
operator|++
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n1
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'-'
condition|)
block|{
operator|++
name|cp2
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
block|{
name|n1
operator|*=
literal|10
expr_stmt|;
name|n1
operator|+=
operator|(
operator|*
name|cp2
operator|++
operator|-
literal|'0'
operator|)
operator|*
name|sign
expr_stmt|;
block|}
name|n2
operator|=
name|n1
expr_stmt|;
name|n1
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'-'
condition|)
block|{
operator|++
name|cp1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp1
argument_list|)
condition|)
block|{
name|n1
operator|*=
literal|10
expr_stmt|;
name|n1
operator|+=
operator|(
operator|*
name|cp1
operator|++
operator|-
literal|'0'
operator|)
operator|*
name|sign
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'+'
condition|)
name|cp1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'+'
condition|)
name|cp2
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|cp2
operator|++
condition|)
do|;
switch|switch
condition|(
name|opc
condition|)
block|{
case|case
name|JEQ
case|:
return|return
operator|(
name|n1
operator|==
name|n2
operator|)
return|;
case|case
name|JNE
case|:
return|return
operator|(
name|n1
operator|!=
name|n2
operator|)
return|;
case|case
name|JLE
case|:
return|return
operator|(
name|n1
operator|<=
name|n2
operator|)
return|;
case|case
name|JGE
case|:
return|return
operator|(
name|n1
operator|>=
name|n2
operator|)
return|;
case|case
name|JLT
case|:
return|return
operator|(
name|n1
operator|<
name|n2
operator|)
return|;
case|case
name|JGT
case|:
return|return
operator|(
name|n1
operator|>
name|n2
operator|)
return|;
case|case
name|JLO
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|<
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
case|case
name|JHI
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|>
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
case|case
name|JLOS
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|<=
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
case|case
name|JHIS
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|>=
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setcon
argument_list|(
name|cv
argument_list|,
name|cl
argument_list|,
name|type
argument_list|)
specifier|register
name|char
operator|*
name|cv
operator|,
operator|*
name|cl
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|cv
operator|!=
literal|'$'
condition|)
return|return;
if|if
condition|(
operator|!
name|natural
argument_list|(
name|cl
argument_list|)
condition|)
return|return;
name|p
operator|=
name|conloc
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|cl
operator|++
condition|)
empty_stmt|;
name|p
operator|=
name|conval
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|cv
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_expr_stmt
name|equstr
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
name|char
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
do|do
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|p2
operator|++
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|setcc
argument_list|(
argument|ap
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|!
name|natural
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|ccloc
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_expr_stmt
name|okio
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 0->probable I/O space address; 1->not */
if|if
condition|(
name|ioflag
operator|&&
operator|(
operator|!
name|natural
argument_list|(
name|p
argument_list|)
operator|||
literal|0
operator|>
name|getnum
argument_list|(
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|indexa
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 1-> uses [r] addressing mode; 0->doesn't */
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'['
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|natural
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 1->simple local, parameter, global, or register; 0->otherwise */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|&&
name|getnum
argument_list|(
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|']'
operator|||
operator|*
name|p
operator|==
literal|')'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'a'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'f'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Tell if an argument is most likely static. */
end_comment

begin_expr_stmt
name|isstatic
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'_'
operator|||
operator|*
name|cp
operator|==
literal|'L'
operator|||
operator|(
operator|*
name|cp
operator|++
operator|==
literal|'v'
operator|&&
operator|*
name|cp
operator|==
literal|'.'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|autoid
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 1-> uses autoincrement/autodecrement; 0->doesn't */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'('
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'+'
operator|&&
operator|*
operator|--
name|p
operator|==
literal|')'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

