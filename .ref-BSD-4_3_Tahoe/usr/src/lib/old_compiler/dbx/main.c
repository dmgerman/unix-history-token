begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	5.4 (Berkeley) 1/12/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: main.c,v 1.4 87/07/08 21:31:27 donn Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Debugger main routine.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"coredump.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_define
define|#
directive|define
name|isterm
parameter_list|(
name|file
parameter_list|)
value|(interactive or isatty(fileno(file)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IRIS
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|termio
name|Ttyinfo
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|sgttyb
name|sg
decl_stmt|;
comment|/* standard sgttyb structure */
name|struct
name|tchars
name|tc
decl_stmt|;
comment|/* terminal characters */
name|struct
name|ltchars
name|ltc
decl_stmt|;
comment|/* local special characters */
name|integer
name|ldisc
decl_stmt|;
comment|/* line discipline */
name|integer
name|local
decl_stmt|;
comment|/* TIOCLGET */
name|integer
name|fcflags
decl_stmt|;
comment|/* fcntl(2) F_GETFL, F_SETFL */
block|}
name|Ttyinfo
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|boolean
name|coredump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if using a core dump */
end_comment

begin_decl_stmt
name|public
name|boolean
name|runfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run program immediately */
end_comment

begin_decl_stmt
name|public
name|boolean
name|interactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* standard input IS a terminal */
end_comment

begin_decl_stmt
name|public
name|boolean
name|lexdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace scanner return values */
end_comment

begin_decl_stmt
name|public
name|boolean
name|tracebpts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace create/delete breakpoints */
end_comment

begin_decl_stmt
name|public
name|boolean
name|traceexec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace execution */
end_comment

begin_decl_stmt
name|public
name|boolean
name|tracesyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print symbols are they are read */
end_comment

begin_decl_stmt
name|public
name|boolean
name|traceblocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace blocks while reading symbols */
end_comment

begin_decl_stmt
name|public
name|boolean
name|vaddrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map addresses through page tables */
end_comment

begin_decl_stmt
name|public
name|boolean
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't print heading */
end_comment

begin_decl_stmt
name|public
name|boolean
name|autostrip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strip C++ prefixes */
end_comment

begin_decl_stmt
name|public
name|File
name|corefile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File id of core dump */
end_comment

begin_decl_stmt
name|public
name|integer
name|versionNumber
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FIRST_TIME
value|0
end_define

begin_comment
comment|/* initial value setjmp returns */
end_comment

begin_decl_stmt
name|private
name|Boolean
name|initdone
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if initialization done */
end_comment

begin_decl_stmt
name|private
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* setjmp/longjmp data */
end_comment

begin_decl_stmt
name|private
name|char
name|outbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* standard output buffer */
end_comment

begin_decl_stmt
name|private
name|char
name|namebuf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* possible name of object file */
end_comment

begin_decl_stmt
name|private
name|Ttyinfo
name|ttyinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|String
name|corename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of core file */
end_comment

begin_function_decl
name|private
name|catchintr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|char
modifier|*
modifier|*
name|scanargs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Main program.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|String
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|integer
name|versionNumber
decl_stmt|;
name|char
modifier|*
modifier|*
name|scanargs
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
operator|(
name|cmdname
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|cmdname
operator|=
operator|*
name|argv
expr_stmt|;
else|else
operator|++
name|cmdname
expr_stmt|;
name|catcherrs
argument_list|()
expr_stmt|;
name|onsyserr
argument_list|(
name|EINTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|onsyserr
argument_list|(
name|EADDRINUSE
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|onsyserr
argument_list|(
name|ENXIO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|argv
operator|=
name|scanargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|runfirst
name|and
name|not
name|quiet
condition|)
block|{
name|printheading
argument_list|()
expr_stmt|;
block|}
name|openfiles
argument_list|()
expr_stmt|;
name|language_init
argument_list|()
expr_stmt|;
name|symbols_init
argument_list|()
expr_stmt|;
name|process_init
argument_list|()
expr_stmt|;
name|optab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|runfirst
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
name|FIRST_TIME
condition|)
block|{
name|arginit
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
name|newarg
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
name|run
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
name|runfirst
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|init
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|!=
name|FIRST_TIME
condition|)
block|{
name|restoretty
argument_list|(
name|stdout
argument_list|,
operator|&
name|ttyinfo
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catchintr
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|printheading
parameter_list|()
block|{
specifier|extern
name|String
name|date
decl_stmt|;
name|printf
argument_list|(
literal|"dbx version 3.%d of %s.\nType 'help' for help.\n"
argument_list|,
name|versionNumber
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the world, including setting initial input file  * if the file exists.  */
end_comment

begin_function
name|public
name|init
parameter_list|()
block|{
name|File
name|f
decl_stmt|;
name|String
name|home
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|String
name|getenv
parameter_list|()
function_decl|;
name|savetty
argument_list|(
name|stdout
argument_list|,
operator|&
name|ttyinfo
argument_list|)
expr_stmt|;
name|enterkeywords
argument_list|()
expr_stmt|;
name|scanner_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|not
name|coredump
name|and
name|not
name|runfirst
condition|)
block|{
name|start
argument_list|(
name|nil
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"reading symbolic information ..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|readobj
argument_list|(
name|objname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|printf
argument_list|(
literal|"[using memory image in %s]\n"
argument_list|,
name|corename
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddrs
condition|)
block|{
name|coredump_getkerinfo
argument_list|()
expr_stmt|;
block|}
name|getsrcpos
argument_list|()
expr_stmt|;
name|setcurfunc
argument_list|(
name|whatblock
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setcurfunc
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
name|bpinit
argument_list|()
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|initfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|nil
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setinput
argument_list|(
name|initfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|home
operator|!=
name|nil
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|home
argument_list|,
name|initfile
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|nil
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setinput
argument_list|(
name|strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|initdone
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-initialize the world, first de-allocating all storage.  * This is necessary when the symbol information must be re-read  * from the object file when it has changed.  *  * Before "forgetting" things, we save the current tracing/breakpoint  * information to a temp file.  Then after re-creating the world,  * we read the temp file as commands.  This isn't always the right thing;  * if a procedure that was being traced is deleted, an error message  * will be generated.  *  * If the argument vector is not nil, then this is re-initialize is being  * done in preparation for running the program.  Since we want to process  * the commands in the temp file before running the program, we add the  * run command at the end of the temp file.  In this case, reinit longjmps  * back to parsing rather than returning.  */
end_comment

begin_function
name|public
name|reinit
parameter_list|(
name|argv
parameter_list|,
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|String
modifier|*
name|argv
decl_stmt|;
name|String
name|infile
decl_stmt|;
name|String
name|outfile
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
name|String
name|tmpfile
decl_stmt|;
specifier|extern
name|String
name|mktemp
parameter_list|()
function_decl|;
name|tmpfile
operator|=
name|mktemp
argument_list|(
literal|"/tmp/dbxXXXX"
argument_list|)
expr_stmt|;
name|setout
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
name|status
argument_list|()
expr_stmt|;
name|alias
argument_list|(
name|nil
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"run"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|nil
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infile
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"< %s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"> %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|unsetout
argument_list|()
expr_stmt|;
name|bpfree
argument_list|()
expr_stmt|;
name|objfree
argument_list|()
expr_stmt|;
name|symbols_init
argument_list|()
expr_stmt|;
name|process_init
argument_list|()
expr_stmt|;
name|enterkeywords
argument_list|()
expr_stmt|;
name|scanner_init
argument_list|()
expr_stmt|;
name|readobj
argument_list|(
name|objname
argument_list|)
expr_stmt|;
name|bpinit
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|setinput
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|!=
name|nil
condition|)
block|{
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_comment
comment|/*  * After a non-fatal error we skip the rest of the current input line, and  * jump back to command parsing.  */
end_comment

begin_function
name|public
name|erecover
parameter_list|()
block|{
if|if
condition|(
name|initdone
condition|)
block|{
name|gobble
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is called when an interrupt occurs.  */
end_comment

begin_function
name|private
name|catchintr
parameter_list|()
block|{
if|if
condition|(
name|isredirected
argument_list|()
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|unsetout
argument_list|()
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan the argument list.  */
end_comment

begin_function
name|private
name|char
modifier|*
modifier|*
name|scanargs
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|String
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|integer
name|optind
decl_stmt|;
name|integer
name|ch
decl_stmt|;
name|runfirst
operator|=
name|false
expr_stmt|;
name|interactive
operator|=
name|false
expr_stmt|;
name|lexdebug
operator|=
name|false
expr_stmt|;
name|tracebpts
operator|=
name|false
expr_stmt|;
name|traceexec
operator|=
name|false
expr_stmt|;
name|tracesyms
operator|=
name|false
expr_stmt|;
name|traceblocks
operator|=
name|false
expr_stmt|;
name|vaddrs
operator|=
name|false
expr_stmt|;
name|quiet
operator|=
name|false
expr_stmt|;
name|autostrip
operator|=
name|true
expr_stmt|;
name|corefile
operator|=
name|nil
expr_stmt|;
name|coredump
operator|=
name|true
expr_stmt|;
name|sourcepath
operator|=
name|list_alloc
argument_list|()
expr_stmt|;
name|list_append
argument_list|(
name|list_item
argument_list|(
literal|"."
argument_list|)
argument_list|,
name|nil
argument_list|,
name|sourcepath
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:abc:eiklnqrs"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'I'
case|:
name|list_append
argument_list|(
name|list_item
argument_list|(
name|optarg
argument_list|)
argument_list|,
name|nil
argument_list|,
name|sourcepath
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|autostrip
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|tracebpts
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|initfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|traceexec
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|vaddrs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
ifdef|#
directive|ifdef
name|LEXDEBUG
name|lexdebug
operator|=
name|true
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"\"-l\" only applicable when compiled with LEXDEBUG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'n'
case|:
name|traceblocks
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* run program before accepting commands */
name|runfirst
operator|=
name|true
expr_stmt|;
name|coredump
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|tracesyms
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fatal
argument_list|(
literal|"unknown option"
argument_list|)
expr_stmt|;
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|objname
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|argv
operator|&&
name|coredump
condition|)
block|{
name|corename
operator|=
operator|*
name|argv
expr_stmt|;
name|corefile
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|corefile
operator|==
name|nil
condition|)
name|coredump
operator|=
name|false
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|argv
name|and
name|not
name|runfirst
condition|)
block|{
name|fatal
argument_list|(
literal|"extraneous argument %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|argv
return|;
block|}
end_function

begin_function
name|private
name|openfiles
parameter_list|()
block|{
name|File
name|f
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|objname
operator|==
name|nil
name|and
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"enter object file name (default is `%s'): "
argument_list|,
name|objname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|namebuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|objname
operator|=
name|namebuf
expr_stmt|;
block|}
block|}
name|f
operator|=
name|fopen
argument_list|(
name|objname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|nil
condition|)
block|{
name|fatal
argument_list|(
literal|"can't read %s"
argument_list|,
name|objname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rindex
argument_list|(
name|objname
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|tmp
operator|=
name|strdup
argument_list|(
name|objname
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rindex
argument_list|(
name|tmp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|list_append
argument_list|(
name|list_item
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|nil
argument_list|,
name|sourcepath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coredump
name|and
name|corefile
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|vaddrs
condition|)
block|{
name|corename
operator|=
literal|"/dev/mem"
expr_stmt|;
name|corefile
operator|=
name|fopen
argument_list|(
name|corename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|corefile
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"can't open /dev/mem"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|corename
operator|=
literal|"core"
expr_stmt|;
name|corefile
operator|=
name|fopen
argument_list|(
name|corename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|corefile
operator|==
name|nil
condition|)
block|{
name|coredump
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Save/restore the state of a tty.  */
end_comment

begin_function
name|public
name|savetty
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
name|File
name|f
decl_stmt|;
name|Ttyinfo
modifier|*
name|t
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IRIS
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TCGETA
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
operator|(
name|t
operator|->
name|sg
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
operator|(
name|t
operator|->
name|tc
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
operator|(
name|t
operator|->
name|ltc
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
operator|(
name|t
operator|->
name|ldisc
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
operator|(
name|t
operator|->
name|local
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|fcflags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|fcflags
operator|&
name|FASYNC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* fprintf(stderr, "[async i/o found set -- reset]\n"); */
name|t
operator|->
name|fcflags
operator|&=
operator|~
name|FASYNC
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|public
name|restoretty
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
name|File
name|f
decl_stmt|;
name|Ttyinfo
modifier|*
name|t
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IRIS
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TCSETA
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
operator|(
name|t
operator|->
name|sg
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
operator|(
name|t
operator|->
name|tc
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
operator|(
name|t
operator|->
name|ltc
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
operator|(
name|t
operator|->
name|ldisc
operator|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
operator|(
name|t
operator|->
name|local
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|fcflags
operator|&
name|FASYNC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* fprintf(stderr, "[async i/o not set]\n"); */
name|t
operator|->
name|fcflags
operator|&=
operator|~
name|FASYNC
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|t
operator|->
name|fcflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Exit gracefully.  */
end_comment

begin_function
name|public
name|quit
parameter_list|(
name|r
parameter_list|)
name|Integer
name|r
decl_stmt|;
block|{
name|pterm
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

