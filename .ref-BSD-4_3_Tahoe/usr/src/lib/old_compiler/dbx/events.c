begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)events.c	5.3 (Berkeley) 1/12/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: events.c,v 1.3 87/07/08 18:46:02 donn Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Event/breakpoint managment.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"lists.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|Event
modifier|*
name|Event
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|Breakpoint
modifier|*
name|Breakpoint
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_define
define|#
directive|define
name|addevent
parameter_list|(
name|cond
parameter_list|,
name|cmdlist
parameter_list|)
value|event_alloc(false, cond, cmdlist)
end_define

begin_define
define|#
directive|define
name|event_once
parameter_list|(
name|cond
parameter_list|,
name|cmdlist
parameter_list|)
value|event_alloc(true, cond, cmdlist)
end_define

begin_comment
comment|/*  * When tracing variables we keep a copy of their most recent value  * and compare it to the current one each time a breakpoint occurs.  * MAXTRSIZE is the maximum size variable we allow.  */
end_comment

begin_define
define|#
directive|define
name|MAXTRSIZE
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|boolean
name|inst_tracing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|boolean
name|single_stepping
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|boolean
name|isstopped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|linesym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|procsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|pcsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|retaddrsym
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Event
block|{
name|unsigned
name|int
name|id
decl_stmt|;
name|boolean
name|temporary
decl_stmt|;
name|Node
name|condition
decl_stmt|;
name|Cmdlist
name|actions
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Breakpoint
block|{
name|Event
name|event
decl_stmt|;
name|Address
name|bpaddr
decl_stmt|;
name|Lineno
name|bpline
decl_stmt|;
name|Cmdlist
name|actions
decl_stmt|;
name|boolean
name|temporary
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|List
name|Eventlist
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|List
name|Bplist
typedef|;
end_typedef

begin_define
define|#
directive|define
name|eventlist_append
parameter_list|(
name|event
parameter_list|,
name|el
parameter_list|)
value|list_append(list_item(event), nil, el)
end_define

begin_define
define|#
directive|define
name|bplist_append
parameter_list|(
name|bp
parameter_list|,
name|bl
parameter_list|)
value|list_append(list_item(bp), nil, bl)
end_define

begin_decl_stmt
name|private
name|Eventlist
name|eventlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of active events */
end_comment

begin_decl_stmt
name|private
name|Bplist
name|bplist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of active breakpoints */
end_comment

begin_decl_stmt
name|private
name|Event
name|curevent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most recently created event */
end_comment

begin_decl_stmt
name|private
name|integer
name|eventid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* id number of current event */
end_comment

begin_decl_stmt
name|private
name|integer
name|trid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* id number of current trace */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Trcmd
block|{
name|Integer
name|trid
decl_stmt|;
name|Event
name|event
decl_stmt|;
name|Cmdlist
name|cmdlist
decl_stmt|;
block|}
typedef|*
name|Trcmd
typedef|;
end_typedef

begin_decl_stmt
name|private
name|List
name|eachline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* commands to execute after each line */
end_comment

begin_decl_stmt
name|private
name|List
name|eachinst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* commands to execute after each instruction */
end_comment

begin_function_decl
name|private
name|Breakpoint
name|bp_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize breakpoint information.  */
end_comment

begin_function
name|private
name|Symbol
name|builtinsym
parameter_list|(
name|str
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
name|String
name|str
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
name|Symbol
name|type
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|str
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|public
name|bpinit
parameter_list|()
block|{
name|linesym
operator|=
name|builtinsym
argument_list|(
literal|"$line"
argument_list|,
name|VAR
argument_list|,
name|t_int
argument_list|)
expr_stmt|;
name|procsym
operator|=
name|builtinsym
argument_list|(
literal|"$proc"
argument_list|,
name|PROC
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|pcsym
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"$pc"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsym
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"can't find $pc"
argument_list|)
expr_stmt|;
block|}
name|retaddrsym
operator|=
name|builtinsym
argument_list|(
literal|"$retaddr"
argument_list|,
name|VAR
argument_list|,
name|t_int
argument_list|)
expr_stmt|;
name|eventlist
operator|=
name|list_alloc
argument_list|()
expr_stmt|;
name|bplist
operator|=
name|list_alloc
argument_list|()
expr_stmt|;
name|eachline
operator|=
name|list_alloc
argument_list|()
expr_stmt|;
name|eachinst
operator|=
name|list_alloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap an event and do the associated commands when it occurs.  */
end_comment

begin_function
name|public
name|Event
name|event_alloc
parameter_list|(
name|istmp
parameter_list|,
name|econd
parameter_list|,
name|cmdlist
parameter_list|)
name|boolean
name|istmp
decl_stmt|;
name|Node
name|econd
decl_stmt|;
name|Cmdlist
name|cmdlist
decl_stmt|;
block|{
specifier|register
name|Event
name|e
decl_stmt|;
name|e
operator|=
name|new
argument_list|(
name|Event
argument_list|)
expr_stmt|;
operator|++
name|eventid
expr_stmt|;
name|e
operator|->
name|id
operator|=
name|eventid
expr_stmt|;
name|e
operator|->
name|temporary
operator|=
name|istmp
expr_stmt|;
name|e
operator|->
name|condition
operator|=
name|econd
expr_stmt|;
name|e
operator|->
name|actions
operator|=
name|cmdlist
expr_stmt|;
name|eventlist_append
argument_list|(
name|e
argument_list|,
name|eventlist
argument_list|)
expr_stmt|;
name|curevent
operator|=
name|e
expr_stmt|;
name|translate
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the event with the given id.  * Returns whether it's successful or not.  */
end_comment

begin_function
name|public
name|boolean
name|delevent
parameter_list|(
name|id
parameter_list|)
name|unsigned
name|int
name|id
decl_stmt|;
block|{
name|Event
name|e
decl_stmt|;
name|Breakpoint
name|bp
decl_stmt|;
name|Trcmd
name|t
decl_stmt|;
name|boolean
name|found
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
name|foreach
argument_list|(
argument|Event
argument_list|,
argument|e
argument_list|,
argument|eventlist
argument_list|)
if|if
condition|(
name|e
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|foreach
argument_list|(
argument|Breakpoint
argument_list|,
argument|bp
argument_list|,
argument|bplist
argument_list|)
if|if
condition|(
name|bp
operator|->
name|event
operator|==
name|e
condition|)
block|{
if|if
condition|(
name|tracebpts
condition|)
block|{
name|printf
argument_list|(
literal|"deleting breakpoint at 0x%x\n"
argument_list|,
name|bp
operator|->
name|bpaddr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|bplist
argument_list|)
argument_list|,
name|bplist
argument_list|)
expr_stmt|;
block|}
name|endfor
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eventlist
argument_list|)
argument_list|,
name|eventlist
argument_list|)
decl_stmt|;
break|break;
block|}
name|endfor
name|foreach
argument_list|(
name|Trcmd
argument_list|,
name|t
argument_list|,
name|eachline
argument_list|)
decl|if
argument_list|(
name|t
operator|->
name|event
operator|->
name|id
operator|==
name|id
argument_list|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|printrmtr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eachline
argument_list|)
argument_list|,
name|eachline
argument_list|)
expr_stmt|;
block|}
name|endfor
name|foreach
argument_list|(
name|Trcmd
argument_list|,
name|t
argument_list|,
name|eachinst
argument_list|)
decl|if
argument_list|(
name|t
operator|->
name|event
operator|->
name|id
operator|==
name|id
argument_list|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|printrmtr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eachinst
argument_list|)
argument_list|,
name|eachinst
argument_list|)
expr_stmt|;
block|}
name|endfor
if|if
condition|(
name|list_size
argument_list|(
name|eachinst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inst_tracing
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|list_size
argument_list|(
name|eachline
argument_list|)
operator|==
literal|0
condition|)
block|{
name|single_stepping
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Translate an event into the appropriate breakpoints and actions.  * While we're at it, turn on the breakpoints if the condition is true.  */
end_comment

begin_function
name|private
name|translate
parameter_list|(
name|e
parameter_list|)
name|Event
name|e
decl_stmt|;
block|{
name|Breakpoint
name|bp
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
name|Node
name|place
decl_stmt|;
name|Lineno
name|line
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|checkref
argument_list|(
name|e
operator|->
name|condition
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|condition
operator|->
name|op
condition|)
block|{
case|case
name|O_EQ
case|:
if|if
condition|(
name|e
operator|->
name|condition
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|s
operator|=
name|e
operator|->
name|condition
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
name|place
operator|=
name|e
operator|->
name|condition
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|linesym
condition|)
block|{
if|if
condition|(
name|place
operator|->
name|op
operator|==
name|O_QLINE
condition|)
block|{
name|line
operator|=
name|place
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|lcon
expr_stmt|;
name|addr
operator|=
name|objaddr
argument_list|(
name|line
argument_list|,
name|place
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|scon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eval
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|line
operator|=
name|pop
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|addr
operator|=
name|objaddr
argument_list|(
name|line
argument_list|,
name|cursource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|NOADDR
condition|)
block|{
if|if
condition|(
name|not
name|delevent
argument_list|(
name|e
operator|->
name|id
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"!! dbx.translate: can't undo event %d?\n"
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no executable code at line "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|bp
operator|=
name|bp_alloc
argument_list|(
name|e
argument_list|,
name|addr
argument_list|,
name|line
argument_list|,
name|e
operator|->
name|actions
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|procsym
condition|)
block|{
name|eval
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|s
operator|=
name|pop
argument_list|(
name|Symbol
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bp_alloc
argument_list|(
name|e
argument_list|,
name|codeloc
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|actions
argument_list|)
expr_stmt|;
if|if
condition|(
name|isactive
argument_list|(
argument|s
argument_list|)
name|and
name|pc
operator|!=
name|codeloc
argument_list|(
name|program
argument_list|)
condition|)
block|{
name|evalcmdlist
argument_list|(
name|e
operator|->
name|actions
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|pcsym
condition|)
block|{
name|eval
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bp_alloc
argument_list|(
name|e
argument_list|,
name|pop
argument_list|(
name|Address
argument_list|)
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|actions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|condbp
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|condbp
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * These should be handled specially. 	 * But for now I'm ignoring the problem. 	 */
case|case
name|O_AND
case|:
case|case
name|O_OR
case|:
default|default:
name|condbp
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a breakpoint for a condition that cannot be pinpointed  * to happening at a particular address, but one for which we  * must single step and check the condition after each statement.  */
end_comment

begin_function
name|private
name|condbp
parameter_list|(
name|e
parameter_list|)
name|Event
name|e
decl_stmt|;
block|{
name|Symbol
name|p
decl_stmt|;
name|Breakpoint
name|bp
decl_stmt|;
name|Cmdlist
name|actions
decl_stmt|;
name|p
operator|=
name|tcontainer
argument_list|(
name|e
operator|->
name|condition
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|p
operator|=
name|program
expr_stmt|;
block|}
name|actions
operator|=
name|buildcmdlist
argument_list|(
name|build
argument_list|(
name|O_IF
argument_list|,
name|e
operator|->
name|condition
argument_list|,
name|e
operator|->
name|actions
argument_list|)
argument_list|)
expr_stmt|;
name|actions
operator|=
name|buildcmdlist
argument_list|(
name|build
argument_list|(
name|O_TRACEON
argument_list|,
name|false
argument_list|,
name|actions
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bp_alloc
argument_list|(
name|e
argument_list|,
name|codeloc
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
name|actions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the deepest nested subprogram that still contains  * all elements in the given expression.  */
end_comment

begin_function
name|public
name|Symbol
name|tcontainer
parameter_list|(
name|exp
parameter_list|)
name|Node
name|exp
decl_stmt|;
block|{
name|Integer
name|i
decl_stmt|;
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|checkref
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|s
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|s
operator|=
name|container
argument_list|(
name|exp
operator|->
name|value
operator|.
name|sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|isleaf
argument_list|(
name|exp
operator|->
name|op
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
argument_list|(
name|exp
operator|->
name|op
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|tcontainer
argument_list|(
name|exp
operator|->
name|value
operator|.
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|s
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|u
operator|!=
name|v
name|and
name|u
operator|!=
name|nil
condition|)
block|{
name|u
operator|=
name|container
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|v
operator|=
name|container
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"bad ancestry for \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|u
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the given function can be executed at full speed.  * This can only be done if there are no breakpoints within the function.  */
end_comment

begin_function
name|public
name|boolean
name|canskip
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|Breakpoint
name|p
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|ok
operator|=
name|true
expr_stmt|;
name|foreach
argument_list|(
argument|Breakpoint
argument_list|,
argument|p
argument_list|,
argument|bplist
argument_list|)
if|if
condition|(
name|whatblock
argument_list|(
name|p
operator|->
name|bpaddr
argument_list|)
operator|==
name|f
condition|)
block|{
name|ok
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|endfor
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/*  * Print out what's currently being traced by looking at  * the currently active events.  *  * Some convolution here to translate internal representation  * of events back into something more palatable.  */
end_comment

begin_function
name|public
name|status
parameter_list|()
block|{
name|Event
name|e
decl_stmt|;
name|foreach
argument_list|(
argument|Event
argument_list|,
argument|e
argument_list|,
argument|eventlist
argument_list|)
if|if
condition|(
name|not
name|e
operator|->
name|temporary
condition|)
block|{
name|printevent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|endfor
block|}
end_function

begin_function
name|public
name|printevent
parameter_list|(
name|e
parameter_list|)
name|Event
name|e
decl_stmt|;
block|{
name|Command
name|cmd
decl_stmt|;
if|if
condition|(
name|not
name|isredirected
argument_list|()
condition|)
block|{
name|printeventid
argument_list|(
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|list_element
argument_list|(
name|Command
argument_list|,
name|list_head
argument_list|(
name|e
operator|->
name|actions
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|op
operator|==
name|O_PRINTCALL
condition|)
block|{
name|printf
argument_list|(
literal|"trace "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|cmd
operator|->
name|value
operator|.
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|list_size
argument_list|(
name|e
operator|->
name|actions
argument_list|)
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
block|}
name|foreach
argument_list|(
argument|Command
argument_list|,
argument|cmd
argument_list|,
argument|e->actions
argument_list|)
name|printcmd
argument_list|(
name|stdout
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|list_islast
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|endfor
if|if
condition|(
name|list_size
argument_list|(
name|e
operator|->
name|actions
argument_list|)
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
block|}
name|printcond
argument_list|(
name|e
operator|->
name|condition
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|printeventid
parameter_list|(
name|id
parameter_list|)
name|integer
name|id
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a condition.  */
end_comment

begin_function
name|private
name|printcond
parameter_list|(
name|cond
parameter_list|)
name|Node
name|cond
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|;
name|Node
name|place
decl_stmt|;
if|if
condition|(
name|cond
operator|->
name|op
operator|==
name|O_EQ
name|and
name|cond
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|s
operator|=
name|cond
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
name|place
operator|=
name|cond
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|procsym
condition|)
block|{
if|if
condition|(
name|place
operator|->
name|value
operator|.
name|sym
operator|!=
name|program
condition|)
block|{
name|printf
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|place
operator|->
name|value
operator|.
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|linesym
condition|)
block|{
name|printf
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|pcsym
name|or
name|s
operator|==
name|retaddrsym
condition|)
block|{
name|printf
argument_list|(
literal|"i at "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" when "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|" when "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a breakpoint to the list and return it.  */
end_comment

begin_function
name|private
name|Breakpoint
name|bp_alloc
parameter_list|(
name|e
parameter_list|,
name|addr
parameter_list|,
name|line
parameter_list|,
name|actions
parameter_list|)
name|Event
name|e
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Lineno
name|line
decl_stmt|;
name|Cmdlist
name|actions
decl_stmt|;
block|{
specifier|register
name|Breakpoint
name|p
decl_stmt|;
name|p
operator|=
name|new
argument_list|(
name|Breakpoint
argument_list|)
expr_stmt|;
name|p
operator|->
name|event
operator|=
name|e
expr_stmt|;
name|p
operator|->
name|bpaddr
operator|=
name|addr
expr_stmt|;
name|p
operator|->
name|bpline
operator|=
name|line
expr_stmt|;
name|p
operator|->
name|actions
operator|=
name|actions
expr_stmt|;
name|p
operator|->
name|temporary
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tracebpts
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"new bp at 0x%x for event ??\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"new bp at 0x%x for event %d\n"
argument_list|,
name|addr
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|bplist_append
argument_list|(
name|p
argument_list|,
name|bplist
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Free all storage in the event and breakpoint tables.  */
end_comment

begin_function
name|public
name|bpfree
parameter_list|()
block|{
specifier|register
name|Event
name|e
decl_stmt|;
name|fixbps
argument_list|()
expr_stmt|;
name|foreach
argument_list|(
argument|Event
argument_list|,
argument|e
argument_list|,
argument|eventlist
argument_list|)
if|if
condition|(
name|not
name|delevent
argument_list|(
name|e
operator|->
name|id
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"!! dbx.bpfree: can't delete event %d\n"
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eventlist
argument_list|)
argument_list|,
name|eventlist
argument_list|)
expr_stmt|;
name|endfor
block|}
end_function

begin_comment
comment|/*  * Determine if the program stopped at a known breakpoint  * and if so do the associated commands.  */
end_comment

begin_function
name|public
name|boolean
name|bpact
parameter_list|()
block|{
specifier|register
name|Breakpoint
name|p
decl_stmt|;
name|boolean
name|found
decl_stmt|;
name|integer
name|eventId
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
name|foreach
argument_list|(
argument|Breakpoint
argument_list|,
argument|p
argument_list|,
argument|bplist
argument_list|)
if|if
condition|(
name|p
operator|->
name|bpaddr
operator|==
name|pc
condition|)
block|{
if|if
condition|(
name|tracebpts
condition|)
block|{
name|printf
argument_list|(
literal|"breakpoint for event %d found at location 0x%x\n"
argument_list|,
name|p
operator|->
name|event
operator|->
name|id
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|event
operator|->
name|temporary
condition|)
block|{
if|if
condition|(
name|not
name|delevent
argument_list|(
name|p
operator|->
name|event
operator|->
name|id
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"!! dbx.bpact: can't find event %d\n"
argument_list|,
name|p
operator|->
name|event
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|evalcmdlist
argument_list|(
name|p
operator|->
name|actions
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstopped
condition|)
block|{
name|eventId
operator|=
name|p
operator|->
name|event
operator|->
name|id
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|temporary
condition|)
block|{
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|bplist
argument_list|)
argument_list|,
name|bplist
argument_list|)
expr_stmt|;
block|}
block|}
name|endfor
if|if
condition|(
name|isstopped
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
name|printeventid
argument_list|(
name|eventId
argument_list|)
expr_stmt|;
block|}
name|printstatus
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Begin single stepping and executing the given commands after each step.  * If the first argument is true step by instructions, otherwise  * step by source lines.  *  * We automatically set a breakpoint at the end of the current procedure  * to turn off the given tracing.  */
end_comment

begin_function
name|public
name|traceon
parameter_list|(
name|inst
parameter_list|,
name|event
parameter_list|,
name|cmdlist
parameter_list|)
name|boolean
name|inst
decl_stmt|;
name|Event
name|event
decl_stmt|;
name|Cmdlist
name|cmdlist
decl_stmt|;
block|{
specifier|register
name|Trcmd
name|trcmd
decl_stmt|;
name|Breakpoint
name|bp
decl_stmt|;
name|Cmdlist
name|actions
decl_stmt|;
name|Address
name|ret
decl_stmt|;
name|Event
name|e
decl_stmt|;
if|if
condition|(
name|event
operator|==
name|nil
condition|)
block|{
name|e
operator|=
name|curevent
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|event
expr_stmt|;
block|}
name|trcmd
operator|=
name|new
argument_list|(
name|Trcmd
argument_list|)
expr_stmt|;
operator|++
name|trid
expr_stmt|;
name|trcmd
operator|->
name|trid
operator|=
name|trid
expr_stmt|;
name|trcmd
operator|->
name|event
operator|=
name|e
expr_stmt|;
name|trcmd
operator|->
name|cmdlist
operator|=
name|cmdlist
expr_stmt|;
name|single_stepping
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|inst
condition|)
block|{
name|inst_tracing
operator|=
name|true
expr_stmt|;
name|list_append
argument_list|(
name|list_item
argument_list|(
name|trcmd
argument_list|)
argument_list|,
name|nil
argument_list|,
name|eachinst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list_append
argument_list|(
name|list_item
argument_list|(
name|trcmd
argument_list|)
argument_list|,
name|nil
argument_list|,
name|eachline
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|return_addr
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|actions
operator|=
name|buildcmdlist
argument_list|(
name|build
argument_list|(
name|O_TRACEOFF
argument_list|,
name|trcmd
operator|->
name|trid
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bp_alloc
argument_list|(
name|e
argument_list|,
operator|(
name|Address
operator|)
name|ret
argument_list|,
literal|0
argument_list|,
name|actions
argument_list|)
expr_stmt|;
name|bp
operator|->
name|temporary
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|tracebpts
condition|)
block|{
name|printf
argument_list|(
literal|"adding trace %d for event %d\n"
argument_list|,
name|trcmd
operator|->
name|trid
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Turn off some kind of tracing.  * Strictly an internal command, this cannot be invoked by the user.  */
end_comment

begin_function
name|public
name|traceoff
parameter_list|(
name|id
parameter_list|)
name|Integer
name|id
decl_stmt|;
block|{
specifier|register
name|Trcmd
name|t
decl_stmt|;
specifier|register
name|boolean
name|found
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
name|foreach
argument_list|(
argument|Trcmd
argument_list|,
argument|t
argument_list|,
argument|eachline
argument_list|)
if|if
condition|(
name|t
operator|->
name|trid
operator|==
name|id
condition|)
block|{
name|printrmtr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eachline
argument_list|)
argument_list|,
name|eachline
argument_list|)
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|endfor
if|if
condition|(
name|not
name|found
condition|)
block|{
name|foreach
argument_list|(
argument|Trcmd
argument_list|,
argument|t
argument_list|,
argument|eachinst
argument_list|)
if|if
condition|(
name|t
operator|->
name|event
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|printrmtr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eachinst
argument_list|)
argument_list|,
name|eachinst
argument_list|)
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|endfor
if|if
condition|(
name|not
name|found
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[internal error: trace id %d not found]\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list_size
argument_list|(
name|eachinst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inst_tracing
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|list_size
argument_list|(
name|eachline
argument_list|)
operator|==
literal|0
condition|)
block|{
name|single_stepping
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * If breakpoints are being traced, note that a Trcmd is being deleted.  */
end_comment

begin_function
name|private
name|printrmtr
parameter_list|(
name|t
parameter_list|)
name|Trcmd
name|t
decl_stmt|;
block|{
if|if
condition|(
name|tracebpts
condition|)
block|{
name|printf
argument_list|(
literal|"removing trace %d"
argument_list|,
name|t
operator|->
name|trid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|event
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|" for event %d"
argument_list|,
name|t
operator|->
name|event
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out news during single step tracing.  */
end_comment

begin_function
name|public
name|printnews
parameter_list|()
block|{
specifier|register
name|Trcmd
name|t
decl_stmt|;
name|foreach
argument_list|(
argument|Trcmd
argument_list|,
argument|t
argument_list|,
argument|eachline
argument_list|)
name|evalcmdlist
argument_list|(
name|t
operator|->
name|cmdlist
argument_list|)
expr_stmt|;
name|endfor
name|foreach
argument_list|(
name|Trcmd
argument_list|,
name|t
argument_list|,
name|eachinst
argument_list|)
name|evalcmdlist
argument_list|(
name|t
operator|->
name|cmdlist
argument_list|)
decl_stmt|;
name|endfor
name|bpact
parameter_list|()
function_decl|;
block|}
end_function

begin_comment
comment|/*  * A procedure call/return has occurred while single-stepping,  * note it if we're tracing lines.  */
end_comment

begin_function_decl
name|private
name|boolean
name|chklist
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|callnews
parameter_list|(
name|iscall
parameter_list|)
name|boolean
name|iscall
decl_stmt|;
block|{
if|if
condition|(
name|not
name|chklist
argument_list|(
name|eachline
argument_list|,
name|iscall
argument_list|)
condition|)
block|{
name|chklist
argument_list|(
name|eachinst
argument_list|,
name|iscall
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|boolean
name|chklist
parameter_list|(
name|list
parameter_list|,
name|iscall
parameter_list|)
name|List
name|list
decl_stmt|;
name|boolean
name|iscall
decl_stmt|;
block|{
specifier|register
name|Trcmd
name|t
decl_stmt|;
specifier|register
name|Command
name|cmd
decl_stmt|;
name|setcurfunc
argument_list|(
name|whatblock
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|foreach
argument_list|(
argument|Trcmd
argument_list|,
argument|t
argument_list|,
argument|list
argument_list|)
name|foreach
argument_list|(
argument|Command
argument_list|,
argument|cmd
argument_list|,
argument|t->cmdlist
argument_list|)
if|if
condition|(
name|cmd
operator|->
name|op
operator|==
name|O_PRINTSRCPOS
name|and
argument_list|(
argument|cmd->value.arg[
literal|0
argument|] == nil or cmd->value.arg[
literal|0
argument|]->op == O_QLINE
argument_list|)
condition|)
block|{
if|if
condition|(
name|iscall
condition|)
block|{
name|printentry
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printexit
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
name|endfor
name|endfor
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * List of variables being watched.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|Trinfo
modifier|*
name|Trinfo
typedef|;
end_typedef

begin_struct
struct|struct
name|Trinfo
block|{
name|Node
name|variable
decl_stmt|;
name|Address
name|traddr
decl_stmt|;
name|Symbol
name|trblock
decl_stmt|;
name|char
modifier|*
name|trvalue
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|List
name|trinfolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Find the trace information record associated with the given record.  * If there isn't one then create it and add it to the list.  */
end_comment

begin_function
name|private
name|Trinfo
name|findtrinfo
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
specifier|register
name|Trinfo
name|tp
decl_stmt|;
name|boolean
name|isnew
decl_stmt|;
name|isnew
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|trinfolist
operator|==
name|nil
condition|)
block|{
name|trinfolist
operator|=
name|list_alloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|foreach
argument_list|(
argument|Trinfo
argument_list|,
argument|tp
argument_list|,
argument|trinfolist
argument_list|)
if|if
condition|(
name|tp
operator|->
name|variable
operator|==
name|p
condition|)
block|{
name|isnew
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|endfor
block|}
if|if
condition|(
name|isnew
condition|)
block|{
if|if
condition|(
name|tracebpts
condition|)
block|{
name|printf
argument_list|(
literal|"adding trinfo for \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|new
argument_list|(
name|Trinfo
argument_list|)
expr_stmt|;
name|tp
operator|->
name|variable
operator|=
name|p
expr_stmt|;
name|tp
operator|->
name|traddr
operator|=
name|lval
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tp
operator|->
name|trvalue
operator|=
name|nil
expr_stmt|;
name|list_append
argument_list|(
name|list_item
argument_list|(
name|tp
argument_list|)
argument_list|,
name|nil
argument_list|,
name|trinfolist
argument_list|)
expr_stmt|;
block|}
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the value of a variable if it has changed since the  * last time we checked.  */
end_comment

begin_function
name|public
name|printifchanged
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
specifier|register
name|Trinfo
name|tp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|buff
index|[
name|MAXTRSIZE
index|]
decl_stmt|;
name|Filename
name|curfile
decl_stmt|;
specifier|static
name|Lineno
name|prevline
decl_stmt|;
specifier|static
name|Filename
name|prevfile
decl_stmt|;
name|tp
operator|=
name|findtrinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|size
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|dread
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|traddr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|srcfilename
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|trvalue
operator|==
name|nil
condition|)
block|{
name|tp
operator|->
name|trvalue
operator|=
name|newarr
argument_list|(
name|char
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|trvalue
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"initially (at line %d in \"%s\"):\t"
argument_list|,
name|curline
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
argument_list|(
name|tp
operator|->
name|trvalue
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mov
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|trvalue
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"after line %d in \"%s\":\t"
argument_list|,
name|prevline
argument_list|,
name|prevfile
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|prevline
operator|=
name|curline
expr_stmt|;
name|prevfile
operator|=
name|curfile
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop if the value of the given expression has changed.  */
end_comment

begin_function
name|public
name|stopifchanged
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
specifier|register
name|Trinfo
name|tp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|buff
index|[
name|MAXTRSIZE
index|]
decl_stmt|;
specifier|static
name|Lineno
name|prevline
decl_stmt|;
name|tp
operator|=
name|findtrinfo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|size
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|dread
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|traddr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|trvalue
operator|==
name|nil
condition|)
block|{
name|tp
operator|->
name|trvalue
operator|=
name|newarr
argument_list|(
name|char
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|trvalue
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
argument_list|(
name|tp
operator|->
name|trvalue
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mov
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|trvalue
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"after line %d:\t"
argument_list|,
name|prevline
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stdout
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|true
expr_stmt|;
block|}
name|prevline
operator|=
name|curline
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the tracing table.  */
end_comment

begin_function
name|public
name|trfree
parameter_list|()
block|{
specifier|register
name|Trinfo
name|tp
decl_stmt|;
name|foreach
argument_list|(
argument|Trinfo
argument_list|,
argument|tp
argument_list|,
argument|trinfolist
argument_list|)
name|dispose
argument_list|(
name|tp
operator|->
name|trvalue
argument_list|)
expr_stmt|;
name|dispose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|trinfolist
argument_list|)
argument_list|,
name|trinfolist
argument_list|)
expr_stmt|;
name|endfor
block|}
end_function

begin_comment
comment|/*  * Fix up breakpoint information before continuing execution.  *  * It's necessary to destroy events and breakpoints that were created  * temporarily and still exist because the program terminated abnormally.  */
end_comment

begin_function
name|public
name|fixbps
parameter_list|()
block|{
specifier|register
name|Event
name|e
decl_stmt|;
specifier|register
name|Trcmd
name|t
decl_stmt|;
name|single_stepping
operator|=
name|false
expr_stmt|;
name|inst_tracing
operator|=
name|false
expr_stmt|;
name|trfree
argument_list|()
expr_stmt|;
name|foreach
argument_list|(
argument|Event
argument_list|,
argument|e
argument_list|,
argument|eventlist
argument_list|)
if|if
condition|(
name|e
operator|->
name|temporary
condition|)
block|{
if|if
condition|(
name|not
name|delevent
argument_list|(
name|e
operator|->
name|id
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"!! dbx.fixbps: can't find event %d\n"
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|endfor
name|foreach
argument_list|(
name|Trcmd
argument_list|,
name|t
argument_list|,
name|eachline
argument_list|)
name|printrmtr
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eachline
argument_list|)
argument_list|,
name|eachline
argument_list|)
expr_stmt|;
name|endfor
name|foreach
argument_list|(
name|Trcmd
argument_list|,
name|t
argument_list|,
name|eachinst
argument_list|)
name|printrmtr
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|list_delete
argument_list|(
name|list_curitem
argument_list|(
name|eachinst
argument_list|)
argument_list|,
name|eachinst
argument_list|)
expr_stmt|;
name|endfor
block|}
end_function

begin_comment
comment|/*  * Set all breakpoints in object code.  */
end_comment

begin_function
name|public
name|setallbps
parameter_list|()
block|{
specifier|register
name|Breakpoint
name|p
decl_stmt|;
name|foreach
argument_list|(
argument|Breakpoint
argument_list|,
argument|p
argument_list|,
argument|bplist
argument_list|)
name|setbp
argument_list|(
name|p
operator|->
name|bpaddr
argument_list|)
expr_stmt|;
name|endfor
block|}
end_function

begin_comment
comment|/*  * Undo damage done by "setallbps".  */
end_comment

begin_function
name|public
name|unsetallbps
parameter_list|()
block|{
specifier|register
name|Breakpoint
name|p
decl_stmt|;
name|foreach
argument_list|(
argument|Breakpoint
argument_list|,
argument|p
argument_list|,
argument|bplist
argument_list|)
name|unsetbp
argument_list|(
name|p
operator|->
name|bpaddr
argument_list|)
expr_stmt|;
name|endfor
block|}
end_function

end_unit

