begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.yh"
end_include

begin_define
define|#
directive|define
name|NCPS
value|24
end_define

begin_define
define|#
directive|define
name|LIBNAME
value|"	.LIBRARY	/DB0:[C]JEQL.MLB/\n"
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|clearl
parameter_list|()
value|(*strpnt=0,fputs(strbuf,stdout),strpnt=strbuf)
end_define

begin_decl_stmt
name|FILE
modifier|*
name|tmpfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|relfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|txtfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|yytext
index|[
name|NCPS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strbuf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strpnt
init|=
name|strbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skipspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|intval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anyerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sawname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|saveit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*define yylex() (fprintf(stderr,"yylex returns %d\n",saveit=oyylex()),saveit)*/
end_comment

begin_define
define|#
directive|define
name|yylex
parameter_list|()
value|oyylex()
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|nameflag
init|=
literal|0
decl_stmt|;
name|char
name|namebuf
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|freopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|nameflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
name|freopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameflag
condition|)
block|{
specifier|register
name|char
modifier|*
name|base
init|=
operator|*
name|argv
decl_stmt|;
while|while
condition|(
operator|*
name|base
operator|++
condition|)
empty_stmt|;
comment|/* Find end */
while|while
condition|(
operator|--
name|base
operator|>=
operator|*
name|argv
operator|&&
operator|*
name|base
operator|!=
literal|'/'
condition|)
empty_stmt|;
comment|/* find last slash */
name|base
operator|++
expr_stmt|;
comment|/* set base */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
operator|&&
name|base
index|[
name|i
index|]
operator|&&
name|base
index|[
name|i
index|]
operator|!=
literal|'.'
condition|;
control|)
name|namebuf
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|base
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|base
index|[
name|i
index|]
operator|<=
literal|'z'
operator|)
condition|?
operator|(
name|base
index|[
name|i
index|]
operator|+
literal|'A'
operator|-
literal|'a'
operator|)
else|:
name|base
index|[
name|i
index|]
operator|)
expr_stmt|;
name|namebuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\t.TITLE\t%s\n"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LIBNAME
argument_list|)
expr_stmt|;
block|}
name|loop
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|NL
case|:
name|clearl
argument_list|()
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|sawname
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CM
case|:
case|case
name|SP
case|:
name|sawname
operator|=
literal|0
expr_stmt|;
case|case
name|LP
case|:
name|fixlength
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0
case|:
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|printf
argument_list|(
literal|"	.END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|fixlength
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|strpnt
decl_stmt|;
if|if
condition|(
name|sawname
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|*
operator|--
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|','
operator|&&
operator|*
name|cp
operator|!=
literal|'@'
condition|)
block|{
name|cp
index|[
literal|2
index|]
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|<=
name|strbuf
condition|)
name|yyerror
argument_list|(
literal|"Bad ( construction"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'L'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'^'
expr_stmt|;
name|strpnt
operator|+=
literal|2
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|long
name|mask
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xfffffffe
block|,
literal|0xfffffffc
block|,
literal|0xfffffff8
block|,
literal|0xfffffff0
block|,
literal|0xffffffe0
block|,
literal|0xffffffc0
block|,
literal|0xffffff80
block|,
literal|0xffffff00
block|,
literal|0xfffffe00
block|,
literal|0xfffffc00
block|,
literal|0xfffff800
block|,
literal|0xfffff000
block|,
literal|0xffffe000
block|,
literal|0xffffc000
block|,
literal|0xffff8000
block|,
literal|0xffff0000
block|,
literal|0xfffe0000
block|,
literal|0xfffc0000
block|,
literal|0xfff80000
block|,
literal|0xfff00000
block|,
literal|0xffe00000
block|,
literal|0xffc00000
block|,
literal|0xff800000
block|,
literal|0xff000000
block|,
literal|0xfe000000
block|,
literal|0xfc000000
block|,
literal|0xf8000000
block|,
literal|0xf0000000
block|,
literal|0xe0000000
block|,
literal|0xc0000000
block|,
literal|0x80000000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|type
index|[]
init|=
block|{
name|EOF
block|,
name|SP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SP
block|,
name|NL
block|,
literal|0
block|,
literal|0
block|,
name|SP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SP
block|,
literal|0
block|,
literal|0
block|,
name|SH
block|,
name|LITOP
block|,
name|REG
block|,
name|AND
block|,
name|SQ
block|,
name|LP
block|,
name|RP
block|,
name|MUL
block|,
name|PLUS
block|,
name|CM
block|,
name|MINUS
block|,
name|ALPH
block|,
name|DIV
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|COLON
block|,
name|SEMI
block|,
name|LSH
block|,
literal|0
block|,
name|RSH
block|,
literal|0
block|,
literal|0
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|LB
block|,
literal|0
block|,
name|RB
block|,
name|XOR
block|,
name|ALPH
block|,
literal|0
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
literal|0
block|,
name|IOR
block|,
literal|0
block|,
name|TILDE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|oyylex
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|val
expr_stmt|;
specifier|register
name|base
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|symtab
modifier|*
name|op
decl_stmt|;
specifier|static
name|double
name|fltval
decl_stmt|;
name|char
name|fltchr
index|[
literal|64
index|]
decl_stmt|;
name|int
name|minflag
init|=
name|FALSE
decl_stmt|;
name|loop
label|:
switch|switch
condition|(
name|yylval
operator|=
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
operator|=
name|getchar
argument_list|()
index|]
condition|)
block|{
case|case
name|SH
case|:
name|copy
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|val
operator|>
literal|0
condition|)
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|NL
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|EOF
case|:
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|ALPH
case|:
name|cp
operator|=
name|yytext
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'_'
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cp
operator|<=
operator|&
name|yytext
index|[
name|NCPS
index|]
condition|)
operator|*
name|cp
operator|++
operator|=
name|val
expr_stmt|;
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
operator|=
name|getchar
argument_list|()
index|]
operator|==
name|ALPH
operator|||
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
index|]
operator|==
name|DIG
operator|||
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
index|]
operator|==
name|LITOP
condition|)
do|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|skipspace
condition|)
for|for
control|(
init|;
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
index|]
operator|==
name|SP
condition|;
name|val
operator|=
name|getchar
argument_list|()
control|)
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|yytext
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|val
operator|=
name|NAME
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|".byte"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|IBYTE
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|".word"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|IWORD
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|".long"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ILONG
operator|)
return|;
else|else
return|return
operator|(
name|NAME
operator|)
return|;
case|case
name|MINUS
case|:
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
operator|=
name|getchar
argument_list|()
index|]
condition|)
block|{
case|case
name|LP
case|:
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|=
name|MP
operator|)
return|;
case|case
name|DIG
case|:
break|break;
default|default:
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|=
name|MINUS
operator|)
return|;
block|}
name|minflag
operator|=
name|TRUE
expr_stmt|;
case|case
name|DIG
case|:
name|intval
operator|=
name|val
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'0'
condition|)
block|{
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'x'
operator|||
name|val
operator|==
literal|'X'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|copy
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|copy
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|'d'
operator|||
name|val
operator|==
literal|'D'
operator|||
name|val
operator|==
literal|'f'
operator|||
name|val
operator|==
literal|'F'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|fltchr
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
while|while
condition|(
name|p
operator|<
operator|&
name|fltchr
index|[
literal|63
index|]
operator|&&
operator|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'.'
operator|||
name|val
operator|==
literal|'e'
operator|||
name|val
operator|==
literal|'d'
operator|||
name|val
operator|==
literal|'E'
operator|||
name|val
operator|==
literal|'D'
operator|||
name|val
operator|==
literal|'-'
operator|||
name|val
operator|==
literal|'+'
operator|||
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
index|]
operator|==
name|DIG
operator|)
condition|)
name|copy
argument_list|(
name|val
argument_list|)
operator|,
operator|*
name|p
operator|++
operator|=
name|val
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fltval
operator|=
name|atof
argument_list|(
name|fltchr
argument_list|)
expr_stmt|;
name|val
operator|=
name|FLTNUM
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
index|]
operator|!=
name|DIG
condition|)
block|{
name|copy
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT
expr_stmt|;
name|yylval
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|copy
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|copy
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|copy
argument_list|(
name|val
argument_list|)
operator|,
name|base
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|val
operator|=
name|getchar
argument_list|()
index|]
operator|==
name|DIG
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|val
operator|>=
literal|'a'
operator|&&
name|val
operator|<=
literal|'f'
operator|||
name|val
operator|>=
literal|'A'
operator|&&
name|val
operator|<=
literal|'F'
operator|)
operator|)
condition|)
block|{
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|8
condition|)
name|intval
operator|<<=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|intval
operator|*=
literal|10
expr_stmt|;
else|else
name|intval
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|'a'
operator|&&
name|val
operator|<=
literal|'f'
condition|)
name|val
operator|-=
literal|'a'
operator|-
literal|10
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>=
literal|'A'
operator|&&
name|val
operator|<=
literal|'F'
condition|)
name|val
operator|-=
literal|'A'
operator|-
literal|10
operator|-
literal|'0'
expr_stmt|;
name|intval
operator|+=
name|val
operator|-
literal|'0'
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|minflag
condition|)
name|intval
operator|=
operator|-
name|intval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MUL
case|:
name|copy
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|LITOP
case|:
name|copy
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|SQ
case|:
if|if
condition|(
operator|(
name|yylval
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
name|intval
operator|=
name|yylval
expr_stmt|;
name|sprintf
argument_list|(
name|strpnt
argument_list|,
literal|"%d"
argument_list|,
name|intval
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|strpnt
operator|<
operator|&
name|strbuf
index|[
literal|512
index|]
operator|)
operator|&&
operator|*
name|strpnt
condition|;
name|strpnt
operator|++
control|)
empty_stmt|;
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
literal|0
case|:
name|yyerror
argument_list|(
literal|"Illegal character"
argument_list|)
expr_stmt|;
name|val
operator|=
name|NOCHAR
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|SP
case|:
if|if
condition|(
name|skipspace
condition|)
block|{
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
default|default:
name|copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|ret
label|:
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|anyerrs
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Assembler:\n"
argument_list|)
expr_stmt|;
name|anyerrs
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|copy
argument_list|(
name|p
argument_list|)
specifier|register
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|>=
literal|'a'
operator|&&
name|p
operator|<=
literal|'z'
condition|)
name|p
operator|+=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|strpnt
operator|<
name|strbuf
operator|+
literal|512
condition|)
operator|*
name|strpnt
operator|++
operator|=
operator|(
name|p
operator|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

end_unit

