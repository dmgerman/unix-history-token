begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)code.c	1.6 (Berkeley) 5/31/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pass1.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_decl_stmt
name|int
name|proflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are we generating profiling code? */
end_comment

begin_decl_stmt
name|int
name|strftn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is the current function one which returns a value */
end_comment

begin_decl_stmt
name|int
name|gdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fdefflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are we within a function definition ? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STABDOT
end_ifndef

begin_decl_stmt
name|char
name|NULLNAME
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|labelno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|putstr
parameter_list|(
name|s
parameter_list|)
value|fputs((s), stdout)
end_define

begin_macro
name|branch
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* output a branch to label n */
comment|/* exception is an ordinary function branching to retlab: then, return */
if|if
condition|(
name|nerrors
condition|)
return|return;
if|if
condition|(
name|n
operator|==
name|retlab
operator|&&
operator|!
name|strftn
condition|)
block|{
specifier|register
name|TWORD
name|t
decl_stmt|;
specifier|register
name|r
expr_stmt|;
comment|/* set number of regs in assem comment field */
comment|/* so optimizers can do a better job */
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retstat
operator|&
name|RETVAL
condition|)
block|{
comment|/* the function rets a val somewhere */
name|t
operator|=
operator|(
operator|&
name|stab
index|[
name|curftn
index|]
operator|)
operator|->
name|stype
expr_stmt|;
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|++
expr_stmt|;
comment|/* it is at least one */
if|if
condition|(
name|t
operator|==
name|DOUBLE
condition|)
name|r
operator|++
expr_stmt|;
comment|/* it takes two */
block|}
else|else
comment|/* the fn does not ret a val	*/
name|r
operator|=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"	ret#%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|lastloc
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|log2tab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOG2SZ
value|9
end_define

begin_macro
name|defalign
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* cause the alignment to become a multiple of n */
name|n
operator|/=
name|SZCHAR
expr_stmt|;
if|if
condition|(
name|lastloc
operator|!=
name|PROG
operator|&&
name|n
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"	.align	%d\n"
argument_list|,
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|LOG2SZ
condition|?
name|log2tab
index|[
name|n
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|locctr
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|temp
expr_stmt|;
comment|/* l is PROG, ADATA, DATA, STRNG, ISTRNG, or STAB */
if|if
condition|(
name|l
operator|==
name|lastloc
condition|)
return|return
operator|(
name|l
operator|)
return|;
name|temp
operator|=
name|lastloc
expr_stmt|;
name|lastloc
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|nerrors
condition|)
return|return
operator|(
name|temp
operator|)
return|;
switch|switch
condition|(
name|l
condition|)
block|{
case|case
name|PROG
case|:
name|putstr
argument_list|(
literal|"	.text\n"
argument_list|)
expr_stmt|;
name|psline
argument_list|()
expr_stmt|;
break|break;
case|case
name|DATA
case|:
case|case
name|ADATA
case|:
name|putstr
argument_list|(
literal|"	.data\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|putstr
argument_list|(
literal|"	.data	1\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISTRNG
case|:
name|putstr
argument_list|(
literal|"	.data	2\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAB
case|:
name|putstr
argument_list|(
literal|"	.stab\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal location counter"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_block

begin_macro
name|deflab
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* output something to define the current position as label n */
if|if
condition|(
name|nerrors
condition|)
return|return;
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|crslab
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_macro
name|getlab
argument_list|()
end_macro

begin_block
block|{
comment|/* return a number usable for a label */
return|return
operator|(
operator|++
name|crslab
operator|)
return|;
block|}
end_block

begin_macro
name|efcode
argument_list|()
end_macro

begin_block
block|{
comment|/* code for the end of a function */
if|if
condition|(
name|strftn
condition|)
block|{
comment|/* copy output (in R2) to caller */
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|register
name|TWORD
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|stype
expr_stmt|;
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
name|i
operator|=
name|getlab
argument_list|()
expr_stmt|;
comment|/* label for return area */
ifndef|#
directive|ifndef
name|LCOMM
name|putstr
argument_list|(
literal|"	.data\n"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"	.align	2\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:	.space	%d\n"
argument_list|,
name|i
argument_list|,
name|tsize
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
operator|/
name|SZCHAR
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"	.text\n"
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|sz
init|=
name|tsize
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
operator|/
name|SZCHAR
decl_stmt|;
if|if
condition|(
name|sz
operator|%
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
condition|)
name|sz
operator|+=
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
operator|-
operator|(
name|sz
operator|%
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"	.lcomm	L%d,%d\n"
argument_list|,
name|i
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|psline
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"	movab	L%d,r1\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
name|l
operator|=
name|block
argument_list|(
name|REG
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|PTR
operator||
name|t
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
expr_stmt|;
name|l
operator|->
name|tn
operator|.
name|rval
operator|=
literal|1
expr_stmt|;
comment|/* R1 */
name|l
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
comment|/* no offset */
name|r
operator|=
name|block
argument_list|(
name|REG
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|PTR
operator||
name|t
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
comment|/* R0 */
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|buildtree
argument_list|(
argument|UNARY MUL
argument_list|,
argument|l
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|r
operator|=
name|buildtree
argument_list|(
argument|UNARY MUL
argument_list|,
argument|r
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|l
operator|=
name|buildtree
argument_list|(
name|ASSIGN
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|ecomp
argument_list|(
name|l
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	movab	L%d,r0\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* turn off strftn flag, so return sequence will be generated */
name|strftn
operator|=
literal|0
expr_stmt|;
block|}
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
name|p2bend
argument_list|()
expr_stmt|;
name|fdefflag
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
end_decl_stmt

begin_macro
name|bfcode
argument_list|(
argument|a
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* code for the beginning of a function; a is an array of 		indices in stab for the arguments; n is the number */
specifier|register
name|i
expr_stmt|;
specifier|register
name|temp
expr_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|int
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_CHAR
name|char
modifier|*
name|toreg
parameter_list|()
function_decl|;
endif|#
directive|endif
name|char
modifier|*
name|rname
parameter_list|()
function_decl|;
if|if
condition|(
name|nerrors
condition|)
return|return;
operator|(
name|void
operator|)
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
name|putstr
argument_list|(
literal|"	.align	1\n"
argument_list|)
expr_stmt|;
name|defnam
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|temp
operator|=
name|p
operator|->
name|stype
expr_stmt|;
name|temp
operator|=
name|DECREF
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|strftn
operator|=
operator|(
name|temp
operator|==
name|STRTY
operator|)
operator|||
operator|(
name|temp
operator|==
name|UNIONTY
operator|)
expr_stmt|;
name|retlab
operator|=
name|getlab
argument_list|()
expr_stmt|;
comment|/* routine prolog */
name|printf
argument_list|(
literal|"	.word	L%d\n"
argument_list|,
name|ftnno
argument_list|)
expr_stmt|;
name|ftlab1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|ftlab2
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|ftlab1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|ftlab2
argument_list|)
expr_stmt|;
if|if
condition|(
name|proflg
condition|)
block|{
comment|/* profile code */
name|i
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"	pushl	$L%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"	callf	$8,mcount\n"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"	.data\n"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"	.align	2\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:	.long	0\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"	.text\n"
argument_list|)
expr_stmt|;
name|psline
argument_list|()
expr_stmt|;
block|}
name|off
operator|=
name|ARGINIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|stab
index|[
name|a
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|REGISTER
condition|)
block|{
name|temp
operator|=
name|p
operator|->
name|offset
expr_stmt|;
comment|/* save register number */
name|p
operator|->
name|sclass
operator|=
name|PARAM
expr_stmt|;
comment|/* forget that it is a register */
name|p
operator|->
name|offset
operator|=
name|NOOFFSET
expr_stmt|;
operator|(
name|void
operator|)
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_CHAR
name|printf
argument_list|(
literal|"	%s"
argument_list|,
name|toreg
argument_list|(
name|p
operator|->
name|stype
argument_list|)
argument_list|)
block|)
empty_stmt|;
else|#
directive|else
name|putstr
argument_list|(
literal|"	movl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"	%d(fp),%s\n"
argument_list|,
name|p
operator|->
name|offset
operator|/
name|SZCHAR
argument_list|,
name|rname
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|temp
expr_stmt|;
comment|/* remember register number */
name|p
operator|->
name|sclass
operator|=
name|REGISTER
expr_stmt|;
comment|/* remember that it is a register */
ifdef|#
directive|ifdef
name|REG_CHAR
name|temp
operator|=
name|p
operator|->
name|stype
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|CHAR
operator|||
name|temp
operator|==
name|SHORT
condition|)
name|p
operator|->
name|stype
operator|=
name|INT
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|UCHAR
operator|||
name|temp
operator|==
name|USHORT
condition|)
name|p
operator|->
name|stype
operator|=
name|UNSIGNED
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|STRTY
operator|||
name|p
operator|->
name|stype
operator|==
name|UNIONTY
condition|)
block|{
name|p
operator|->
name|offset
operator|=
name|NOOFFSET
expr_stmt|;
if|if
condition|(
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|off
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"bad argument"
argument_list|)
expr_stmt|;
name|SETOFF
argument_list|(
name|off
argument_list|,
name|ALSTACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|off
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"bad argument"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_if
if|if
condition|(
name|gdebug
operator|&&
operator|!
name|nerrors
condition|)
block|{
ifdef|#
directive|ifdef
name|STABDOT
name|pstabdot
argument_list|(
name|N_SLINE
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|#
directive|else
name|pstab
argument_list|(
name|NULLNAME
argument_list|,
name|N_SLINE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,LL%d\n"
argument_list|,
name|lineno
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LL%d:\n"
argument_list|,
name|labelno
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_if

begin_expr_stmt
name|fdefflag
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  bccode
operator|(
operator|)
block|{
comment|/* called just before the first executable statment */
comment|/* by now, the automatics and register variables are allocated */
name|SETOFF
argument_list|(
name|autooff
argument_list|,
name|SZINT
argument_list|)
block|;
comment|/* set aside store area offset */
name|p2bbeg
argument_list|(
name|autooff
argument_list|,
name|regvar
argument_list|)
block|; 	}
comment|/*ARGSUSED*/
name|ejobcode
argument_list|(
argument|flag
argument_list|)
block|{
comment|/* called just before final exit */
comment|/* flag is 1 if errors, 0 if none */
block|}
ifndef|#
directive|ifndef
name|aobeg
name|aobeg
argument_list|()
block|{
comment|/* called before removing automatics from stab */
block|}
endif|#
directive|endif
endif|aobeg
ifndef|#
directive|ifndef
name|aocode
comment|/*ARGSUSED*/
name|aocode
argument_list|(
argument|p
argument_list|)
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* called when automatic p removed from stab */
block|}
end_block

begin_endif
endif|#
directive|endif
endif|aocode
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|aoend
end_ifndef

begin_macro
name|aoend
argument_list|()
end_macro

begin_block
block|{
comment|/* called after removing all automatics from stab */
block|}
end_block

begin_endif
endif|#
directive|endif
endif|aoend
end_endif

begin_expr_stmt
name|defnam
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* define the current location as the name p->sname */
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|EXTDEF
condition|)
block|{
name|printf
argument_list|(
literal|"	.globl	%s\n"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|STATIC
operator|&&
name|p
operator|->
name|slevel
operator|>
literal|1
condition|)
name|deflab
argument_list|(
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bycode
argument_list|(
argument|t
argument_list|,
argument|i
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASSTRINGS
specifier|static
name|int
name|lastoctal
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* put byte i+1 in a string */
if|if
condition|(
name|nerrors
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASSTRINGS
name|i
operator|&=
literal|077
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|putstr
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|putstr
argument_list|(
literal|"\t.ascii\t\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|'\\'
operator|||
name|t
operator|==
literal|'"'
condition|)
block|{
name|lastoctal
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\\%c"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
literal|040
operator|||
name|t
operator|>=
literal|0177
condition|)
block|{
name|lastoctal
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\\%o"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastoctal
operator|&&
literal|'0'
operator|<=
name|t
operator|&&
name|t
operator|<=
literal|'9'
condition|)
block|{
name|lastoctal
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n\t.ascii\t\"%c"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastoctal
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|077
condition|)
name|putstr
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|i
operator|&=
literal|07
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
comment|/* end of the string */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stash byte t into string */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|putstr
argument_list|(
literal|"	.byte	"
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|07
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|zecode
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* n integer words of zeros */
name|OFFSZ
name|temp
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"	.space	%d\n"
argument_list|,
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|temp
operator|=
name|n
expr_stmt|;
name|inoff
operator|+=
name|temp
operator|*
name|SZINT
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|fldal
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* return the alignment of field of type t */
name|uerror
argument_list|(
literal|"illegal field type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALINT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|fldty
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* fix up type of field p */
empty_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* print location of error  */
comment|/* c is either 'u', 'c', or 'w' */
comment|/* GCOS version */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|ftitle
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|REG_CHAR
end_ifdef

begin_comment
comment|/* tbl - toreg() returns a pointer to a char string 		  which is the correct  "register move" for the passed type   */
end_comment

begin_struct
struct|struct
name|type_move
block|{
name|TWORD
name|fromtype
decl_stmt|;
name|char
name|tostrng
index|[
literal|8
index|]
decl_stmt|;
block|}
name|toreg_strs
index|[]
init|=
block|{
name|CHAR
block|,
literal|"cvtbl"
block|,
name|SHORT
block|,
literal|"cvtwl"
block|,
name|UCHAR
block|,
literal|"movzbl"
block|,
name|USHORT
block|,
literal|"movzwl"
block|,
literal|0
block|,
literal|"movl"
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|toreg
parameter_list|(
name|type
parameter_list|)
name|TWORD
name|type
decl_stmt|;
block|{
name|struct
name|type_move
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|toreg_strs
init|;
name|p
operator|->
name|fromtype
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|fromtype
operator|==
name|type
condition|)
return|return
operator|(
name|p
operator|->
name|tostrng
operator|)
return|;
comment|/* type not found, must be a word type */
return|return
operator|(
name|p
operator|->
name|tostrng
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tbl */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BUFSTDERR
name|char
name|errbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|mainp1
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|sw
name|heapsw
index|[
name|SWITSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* heap for switches */
end_comment

begin_expr_stmt
name|genswitch
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|sw
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*	p points to an array of structures, each consisting 		of a constant value and a label. 		The first is>=0 if there is a default label; 		its value is the label number 		The entries p[1] to p[n] are the nontrivial cases 		*/
specifier|register
name|i
expr_stmt|;
specifier|register
name|CONSZ
name|j
decl_stmt|;
specifier|register
name|CONSZ
name|unsigned
name|range
decl_stmt|;
specifier|register
name|dlab
operator|,
name|swlab
expr_stmt|;
if|if
condition|(
name|nerrors
condition|)
return|return;
name|range
operator|=
name|p
index|[
name|n
index|]
operator|.
name|sval
operator|-
name|p
index|[
literal|1
index|]
operator|.
name|sval
expr_stmt|;
if|if
condition|(
name|range
operator|<=
literal|3
operator|*
name|n
operator|&&
name|n
operator|>=
literal|4
condition|)
block|{
comment|/* implement a direct switch */
name|swlab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|dlab
operator|=
name|p
operator|->
name|slab
operator|>=
literal|0
condition|?
name|p
operator|->
name|slab
else|:
name|getlab
argument_list|()
expr_stmt|;
comment|/* already in r0 */
name|putstr
argument_list|(
literal|"	casel	r0,$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
index|[
literal|1
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|",$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n	.align 1\nL%d:\n"
argument_list|,
name|swlab
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|p
index|[
literal|1
index|]
operator|.
name|sval
init|;
name|i
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"	.word	L%d-L%d\n"
argument_list|,
operator|(
name|j
operator|==
name|p
index|[
name|i
index|]
operator|.
name|sval
condition|?
operator|(
operator|(
name|j
operator|=
name|p
index|[
name|i
operator|++
index|]
operator|.
name|sval
operator|)
operator|,
name|p
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|slab
operator|)
else|:
name|dlab
operator|)
argument_list|,
name|swlab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|slab
operator|>=
literal|0
condition|)
name|branch
argument_list|(
name|dlab
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|dlab
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|>
literal|8
condition|)
block|{
comment|/* heap switch */
name|heapsw
index|[
literal|0
index|]
operator|.
name|slab
operator|=
name|dlab
operator|=
name|p
operator|->
name|slab
operator|>=
literal|0
condition|?
name|p
operator|->
name|slab
else|:
name|getlab
argument_list|()
expr_stmt|;
name|makeheap
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* build heap */
name|walkheap
argument_list|(
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* produce code */
if|if
condition|(
name|p
operator|->
name|slab
operator|>=
literal|0
condition|)
name|branch
argument_list|(
name|dlab
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|dlab
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* debugging code */
comment|/* out for the moment 	if( n>= 4 ) werror( "inefficient switch: %d, %d", n, (int) (range/n) ); 	*/
comment|/* simple switch code */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
comment|/* already in r0 */
name|putstr
argument_list|(
literal|"	cmpl	r0,$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n	jeql	L%d\n"
argument_list|,
name|p
index|[
name|i
index|]
operator|.
name|slab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|slab
operator|>=
literal|0
condition|)
name|branch
argument_list|(
name|p
operator|->
name|slab
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|makeheap
argument_list|(
name|p
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|sw
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|q
decl_stmt|;
name|q
operator|=
name|selectheap
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|heapsw
index|[
name|n
index|]
operator|=
name|p
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|q
operator|>
literal|1
condition|)
name|makeheap
argument_list|(
name|p
argument_list|,
name|q
operator|-
literal|1
argument_list|,
literal|2
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|m
condition|)
name|makeheap
argument_list|(
name|p
operator|+
name|q
argument_list|,
name|m
operator|-
name|q
argument_list|,
literal|2
operator|*
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|selectheap
argument_list|(
argument|m
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|*=
literal|2
control|)
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|>
name|m
condition|)
break|break;
name|l
operator|=
operator|(
operator|(
name|k
operator|=
name|i
operator|/
literal|2
operator|-
literal|1
operator|)
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
return|return
operator|(
name|l
operator|+
operator|(
name|m
operator|-
name|k
operator|<
name|l
condition|?
name|m
operator|-
name|k
else|:
name|l
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|walkheap
argument_list|(
argument|start
argument_list|,
argument|limit
argument_list|)
end_macro

begin_block
block|{
name|int
name|label
decl_stmt|;
if|if
condition|(
name|start
operator|>
name|limit
condition|)
return|return;
name|putstr
argument_list|(
literal|"	cmpl	r0,$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|heapsw
index|[
name|start
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n	jeql	L%d\n"
argument_list|,
name|heapsw
index|[
name|start
index|]
operator|.
name|slab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|2
operator|*
name|start
operator|)
operator|>
name|limit
condition|)
block|{
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|heapsw
index|[
literal|0
index|]
operator|.
name|slab
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
literal|2
operator|*
name|start
operator|+
literal|1
operator|)
operator|<=
name|limit
condition|)
block|{
name|label
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"	jgtr	L%d\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"	jgtr	L%d\n"
argument_list|,
name|heapsw
index|[
literal|0
index|]
operator|.
name|slab
argument_list|)
expr_stmt|;
name|walkheap
argument_list|(
literal|2
operator|*
name|start
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|2
operator|*
name|start
operator|+
literal|1
operator|)
operator|<=
name|limit
condition|)
block|{
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|walkheap
argument_list|(
literal|2
operator|*
name|start
operator|+
literal|1
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

