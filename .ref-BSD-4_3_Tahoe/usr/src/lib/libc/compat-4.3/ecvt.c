begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ecvt.c	5.1 (Berkeley) 3/15/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|LIBC_SCCS and not lint
end_endif

begin_comment
comment|/*  *	ecvt converts to decimal  *	the number of digits is specified by ndigit  *	decpt is set to the position of the decimal point  *	sign is set to 0 for positive, 1 for negative  */
end_comment

begin_function_decl
name|char
modifier|*
name|cvt
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NDIG
value|80
end_define

begin_function
name|char
modifier|*
name|ecvt
parameter_list|(
name|arg
parameter_list|,
name|ndigits
parameter_list|,
name|decpt
parameter_list|,
name|sign
parameter_list|)
name|double
name|arg
decl_stmt|;
name|int
name|ndigits
decl_stmt|,
decl|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|cvt
argument_list|(
name|arg
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|fcvt
parameter_list|(
name|arg
parameter_list|,
name|ndigits
parameter_list|,
name|decpt
parameter_list|,
name|sign
parameter_list|)
name|double
name|arg
decl_stmt|;
name|int
name|ndigits
decl_stmt|,
decl|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|cvt
argument_list|(
name|arg
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|cvt
parameter_list|(
name|arg
parameter_list|,
name|ndigits
parameter_list|,
name|decpt
parameter_list|,
name|sign
parameter_list|,
name|eflag
parameter_list|)
name|double
name|arg
decl_stmt|;
name|int
name|ndigits
decl_stmt|,
decl|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|r2
decl_stmt|;
name|double
name|fi
decl_stmt|,
name|fj
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|NDIG
index|]
decl_stmt|;
name|double
name|modf
parameter_list|()
function_decl|;
if|if
condition|(
name|ndigits
operator|<
literal|0
condition|)
name|ndigits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ndigits
operator|>=
name|NDIG
operator|-
literal|1
condition|)
name|ndigits
operator|=
name|NDIG
operator|-
literal|2
expr_stmt|;
name|r2
operator|=
literal|0
expr_stmt|;
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
block|}
name|arg
operator|=
name|modf
argument_list|(
name|arg
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|buf
index|[
name|NDIG
index|]
expr_stmt|;
comment|/* 	 * Do integer part 	 */
if|if
condition|(
name|fi
operator|!=
literal|0
condition|)
block|{
name|p1
operator|=
operator|&
name|buf
index|[
name|NDIG
index|]
expr_stmt|;
while|while
condition|(
name|fi
operator|!=
literal|0
condition|)
block|{
name|fj
operator|=
name|modf
argument_list|(
name|fi
operator|/
literal|10
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p1
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|fj
operator|+
literal|.03
operator|)
operator|*
literal|10
argument_list|)
operator|+
literal|'0'
expr_stmt|;
name|r2
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|p1
operator|<
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|fj
operator|=
name|arg
operator|*
literal|10
operator|)
operator|<
literal|1
condition|)
block|{
name|arg
operator|=
name|fj
expr_stmt|;
name|r2
operator|--
expr_stmt|;
block|}
block|}
name|p1
operator|=
operator|&
name|buf
index|[
name|ndigits
index|]
expr_stmt|;
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
name|p1
operator|+=
name|r2
expr_stmt|;
operator|*
name|decpt
operator|=
name|r2
expr_stmt|;
if|if
condition|(
name|p1
operator|<
operator|&
name|buf
index|[
literal|0
index|]
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
while|while
condition|(
name|p
operator|<=
name|p1
operator|&&
name|p
operator|<
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
block|{
name|arg
operator|*=
literal|10
expr_stmt|;
name|arg
operator|=
name|modf
argument_list|(
name|arg
argument_list|,
operator|&
name|fj
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|int
operator|)
name|fj
operator|+
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|>=
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
block|{
name|buf
index|[
name|NDIG
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
operator|*
name|p1
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>
literal|'9'
condition|)
block|{
operator|*
name|p1
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|p1
operator|>
name|buf
condition|)
operator|++
operator|*
operator|--
name|p1
expr_stmt|;
else|else
block|{
operator|*
name|p1
operator|=
literal|'1'
expr_stmt|;
operator|(
operator|*
name|decpt
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|=
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_block

end_unit

