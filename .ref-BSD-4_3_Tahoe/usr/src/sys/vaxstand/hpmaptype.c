begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)hpmaptype.c	7.8 (Berkeley) 6/14/88  */
end_comment

begin_comment
comment|/*  * RP??/RM?? drive type mapping routine.  * Used for compatibility with unlabeled disks.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_42
end_ifdef

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"../vaxmba/hpreg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxmba/mbareg.h"
end_include

begin_include
include|#
directive|include
file|"saio.h"
end_include

begin_decl_stmt
name|short
name|rp06_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|38
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|118
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm03_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|100
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|309
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm05_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|27
block|,
literal|0
block|,
literal|562
block|,
literal|589
block|,
literal|681
block|,
literal|562
block|,
literal|82
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm80_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|37
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|115
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rp07_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|235
block|,
literal|245
block|,
literal|437
block|,
literal|235
block|,
literal|52
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ml_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*short	cdc9775_off[8] = { 0, 13, 0, -1, -1, -1, 294, 66 };*/
end_comment

begin_decl_stmt
name|short
name|cdc9730_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|155
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|capricorn_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|32
block|,
literal|0
block|,
literal|668
block|,
literal|723
block|,
literal|778
block|,
literal|668
block|,
literal|98
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|eagle_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|17
block|,
literal|0
block|,
literal|391
block|,
literal|408
block|,
literal|728
block|,
literal|391
block|,
literal|87
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|fj2361_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|13
block|,
literal|0
block|,
literal|294
block|,
literal|307
block|,
literal|547
block|,
literal|294
block|,
literal|66
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|fj2361a_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|277
block|,
literal|289
block|,
literal|515
block|,
literal|277
block|,
literal|62
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hptypes is used to translate Massbus drive type and other information  * into an index in hpst.  The indices of hptypes and hpst must therefore agree.  */
end_comment

begin_decl_stmt
name|short
name|hptypes
index|[]
init|=
block|{
name|MBDT_RM03
block|,
name|MBDT_RM05
block|,
name|MBDT_RP06
block|,
name|MBDT_RM80
block|,
name|MBDT_RP05
block|,
name|MBDT_RP07
block|,
name|MBDT_ML11A
block|,
name|MBDT_ML11B
block|,
operator|-
literal|1
block|,
comment|/* 9755 */
operator|-
literal|1
block|,
comment|/* 9730 */
operator|-
literal|1
block|,
comment|/* Capricorn */
operator|-
literal|1
block|,
comment|/* Eagle */
name|MBDT_RM02
block|,
comment|/* actually something else */
operator|-
literal|1
block|,
comment|/* 9300 */
operator|-
literal|1
block|,
comment|/* 9766 */
operator|-
literal|1
block|,
comment|/* 2361 */
operator|-
literal|1
block|,
comment|/* 2361A */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st
name|hpst
index|[]
init|=
block|{
define|#
directive|define
name|HPDT_RM03
value|0
literal|32
block|,
literal|5
block|,
literal|32
operator|*
literal|5
block|,
literal|823
block|,
name|rm03_off
block|,
comment|/* RM03 */
define|#
directive|define
name|HPDT_RM05
value|1
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|823
block|,
name|rm05_off
block|,
comment|/* RM05 */
define|#
directive|define
name|HPDT_RP06
value|2
literal|22
block|,
literal|19
block|,
literal|22
operator|*
literal|19
block|,
literal|815
block|,
name|rp06_off
block|,
comment|/* RP06 */
define|#
directive|define
name|HPDT_RM80
value|3
literal|31
block|,
literal|14
block|,
literal|31
operator|*
literal|14
block|,
literal|559
block|,
name|rm80_off
block|,
comment|/* RM80 */
define|#
directive|define
name|HPDT_RP05
value|4
literal|22
block|,
literal|19
block|,
literal|22
operator|*
literal|19
block|,
literal|411
block|,
name|rp06_off
block|,
comment|/* RP05 */
define|#
directive|define
name|HPDT_RP07
value|5
literal|50
block|,
literal|32
block|,
literal|50
operator|*
literal|32
block|,
literal|630
block|,
name|rp07_off
block|,
comment|/* RP07 */
define|#
directive|define
name|HPDT_ML11A
value|6
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|ml_off
block|,
comment|/* ML11A */
define|#
directive|define
name|HPDT_ML11B
value|7
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|ml_off
block|,
comment|/* ML11B */
define|#
directive|define
name|HPDT_9775
value|8
literal|32
block|,
literal|40
block|,
literal|32
operator|*
literal|40
block|,
literal|843
block|,
name|fj2361_off
block|,
comment|/* 9775 */
define|#
directive|define
name|HPDT_9730
value|9
literal|32
block|,
literal|10
block|,
literal|32
operator|*
literal|10
block|,
literal|823
block|,
name|cdc9730_off
block|,
comment|/* 9730 */
define|#
directive|define
name|HPDT_CAP
value|10
literal|32
block|,
literal|16
block|,
literal|32
operator|*
literal|16
block|,
literal|1024
block|,
name|capricorn_off
block|,
comment|/* Ampex capricorn */
define|#
directive|define
name|HPDT_EAGLE
value|11
literal|48
block|,
literal|20
block|,
literal|48
operator|*
literal|20
block|,
literal|842
block|,
name|eagle_off
block|,
comment|/* Fuji Eagle */
define|#
directive|define
name|HPDT_RM02
value|12
literal|32
block|,
literal|5
block|,
literal|32
operator|*
literal|5
block|,
literal|823
block|,
name|rm03_off
block|,
comment|/* rm02 - not used */
define|#
directive|define
name|HPDT_9300
value|13
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|815
block|,
name|rm05_off
block|,
comment|/* Ampex 9300 */
define|#
directive|define
name|HPDT_9766
value|14
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|823
block|,
name|rm05_off
block|,
comment|/* CDC 9766 */
define|#
directive|define
name|HPDT_2361
value|15
literal|64
block|,
literal|20
block|,
literal|64
operator|*
literal|20
block|,
literal|842
block|,
name|fj2361_off
block|,
comment|/* Fuji 2361 */
define|#
directive|define
name|HPDT_2361A
literal|68
block|,
literal|20
block|,
literal|68
operator|*
literal|20
block|,
literal|842
block|,
name|fj2361a_off
block|,
comment|/* Fuji 2361a */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NTYPES
value|(sizeof(hpst) / sizeof(hpst[0]))
end_define

begin_define
define|#
directive|define
name|MASKREG
parameter_list|(
name|reg
parameter_list|)
value|((reg)&0xffff)
end_define

begin_expr_stmt
name|hpmaptype
argument_list|(
name|hpaddr
argument_list|,
name|type
argument_list|,
name|unit
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|hpdevice
operator|*
name|hpaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|st
modifier|*
name|st
decl_stmt|;
name|int
name|hpsn
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hptypes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hptypes
index|[
name|i
index|]
operator|==
name|type
condition|)
goto|goto
name|found
goto|;
name|printf
argument_list|(
literal|"unknown drive type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|found
label|:
name|type
operator|=
name|i
expr_stmt|;
comment|/* 	 * Handle SI model byte stuff when 	 * we think it's an RM03 or RM05. 	 */
if|if
condition|(
name|type
operator|==
name|HPDT_RM03
operator|||
name|type
operator|==
name|HPDT_RM05
condition|)
block|{
name|hpsn
operator|=
name|hpaddr
operator|->
name|hpsn
expr_stmt|;
if|if
condition|(
operator|(
name|hpsn
operator|&
name|SIMB_LU
operator|)
operator|==
name|unit
condition|)
switch|switch
condition|(
operator|(
name|hpsn
operator|&
name|SIMB_MB
operator|)
operator|&
operator|~
operator|(
name|SIMB_S6
operator||
name|SIRM03
operator||
name|SIRM05
operator|)
condition|)
block|{
case|case
name|SI9775D
case|:
name|type
operator|=
name|HPDT_9775
expr_stmt|;
break|break;
case|case
name|SI9730D
case|:
name|type
operator|=
name|HPDT_9730
expr_stmt|;
break|break;
case|case
name|SI9766
case|:
name|type
operator|=
name|HPDT_9766
expr_stmt|;
break|break;
case|case
name|SI9762
case|:
name|type
operator|=
name|HPDT_RM03
expr_stmt|;
break|break;
case|case
name|SICAPD
case|:
name|type
operator|=
name|HPDT_CAP
expr_stmt|;
break|break;
case|case
name|SI9751D
case|:
name|type
operator|=
name|HPDT_EAGLE
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * RM02: EMULEX controller.  Map to correct 	 * drive type by checking the holding 	 * register for the disk geometry. 	 */
if|if
condition|(
name|type
operator|==
name|HPDT_RM02
condition|)
block|{
name|int
name|nsectors
decl_stmt|,
name|ntracks
decl_stmt|,
name|ncyl
decl_stmt|;
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_NOP
expr_stmt|;
name|hpaddr
operator|->
name|hphr
operator|=
name|HPHR_MAXTRAK
expr_stmt|;
name|ntracks
operator|=
name|MASKREG
argument_list|(
name|hpaddr
operator|->
name|hphr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_NOP
expr_stmt|;
name|hpaddr
operator|->
name|hphr
operator|=
name|HPHR_MAXSECT
expr_stmt|;
name|nsectors
operator|=
name|MASKREG
argument_list|(
name|hpaddr
operator|->
name|hphr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_NOP
expr_stmt|;
name|hpaddr
operator|->
name|hphr
operator|=
name|HPHR_MAXCYL
expr_stmt|;
name|ncyl
operator|=
name|MASKREG
argument_list|(
name|hpaddr
operator|->
name|hphr
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|NTYPES
condition|;
name|type
operator|++
control|)
if|if
condition|(
name|hpst
index|[
name|type
index|]
operator|.
name|nsect
operator|==
name|nsectors
operator|&&
name|hpst
index|[
name|type
index|]
operator|.
name|ntrak
operator|==
name|ntracks
operator|&&
name|hpst
index|[
name|type
index|]
operator|.
name|ncyl
operator|==
name|ncyl
condition|)
goto|goto
name|done
goto|;
name|printf
argument_list|(
literal|"%d sectors, %d tracks, %d cyl?\n"
argument_list|,
name|nsectors
argument_list|,
name|ntracks
argument_list|,
name|ncyl
argument_list|)
expr_stmt|;
name|type
operator|=
name|HPDT_RM02
expr_stmt|;
name|done
label|:
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_DCLR
operator||
name|HP_GO
expr_stmt|;
block|}
comment|/* 	 * set up minimal disk label. 	 */
name|st
operator|=
operator|&
name|hpst
index|[
name|type
index|]
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
name|st
operator|->
name|nsect
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|st
operator|->
name|ntrak
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|st
operator|->
name|nspc
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|st
operator|->
name|ncyl
expr_stmt|;
name|lp
operator|->
name|d_secperunit
operator|=
name|st
operator|->
name|nspc
operator|*
name|st
operator|->
name|ncyl
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|st
operator|->
name|off
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_offset
operator|=
name|st
operator|->
name|off
index|[
name|i
index|]
operator|*
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|COMPAT_42
end_endif

end_unit

