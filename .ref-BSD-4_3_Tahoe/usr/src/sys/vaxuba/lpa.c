begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)lpa.c	7.1 (Berkeley) 6/5/86  */
end_comment

begin_include
include|#
directive|include
file|"lpa.h"
end_include

begin_if
if|#
directive|if
name|NLPA
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_comment
comment|/*  * LPA driver for -- Asa Romberger  *  *	open  *	write microcode  *	write dedicated mode dispatch table  *	ioctl TIOCSETP to set parameters  *		struct iocb {  *			short *baddr;	buffer address  *			short rate;	- 1,000,000 / frequency in Hz  *			short wc;	15-13 = number of buffers - 1  *					12-0 = buffer size in words  *		} iocb;  *	read - 1 character indicating buffer index  *		fill or empty buffer  * minor device number = DDCCCCCC where:  *	DD	= 00 for analog input  *		= 01 for analog output  *	CCCCCC	= channel number  */
end_comment

begin_expr_stmt
operator|*
name|define
name|NOMCODE
name|to
name|eliminate
name|the
name|microcode
name|download
name|check
operator|*
operator|/
comment|/* #define TRACELPA */
comment|/* #define NOMCODE */
ifdef|#
directive|ifdef
name|TRACELPA
define|#
directive|define
name|TRACER
parameter_list|(
name|x
parameter_list|)
value|printf(x)
define|#
directive|define
name|TRACERN
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|printf(x, d)
else|#
directive|else
define|#
directive|define
name|TRACER
parameter_list|(
name|x
parameter_list|)
define|#
directive|define
name|TRACERN
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
endif|#
directive|endif
comment|/* PRIORITY AT WHICH PROGRAM SHOULD RUN */
comment|/* THIS SHOULD EVENTUALLY  TELL UNIX THIS IS A REAL-TIME DEVICE */
define|#
directive|define
name|NICE
value|0
define|#
directive|define
name|inc
parameter_list|(
name|v
parameter_list|)
value|(sc->v = ((sc->v + 1) % sc->sc_nbuf))
define|#
directive|define
name|LPAPRI
value|(PZERO + 0)
define|#
directive|define
name|LPAUNIT
parameter_list|(
name|dev
parameter_list|)
value|0
define|#
directive|define
name|LPADEVICE
parameter_list|(
name|dev
parameter_list|)
value|(((dev)>> 6)& 03)
define|#
directive|define
name|LPACHANNEL
parameter_list|(
name|dev
parameter_list|)
value|((dev)& 077)
name|int
name|lpaprobe
argument_list|()
operator|,
name|lpaattach
argument_list|()
operator|,
name|lpaiintr
argument_list|()
operator|,
name|lpaointr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_short
name|lpastd
index|[]
init|=
block|{
literal|0170460
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|lpadinfo
index|[
name|NLPA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|lpadriver
init|=
block|{
name|lpaprobe
block|,
literal|0
block|,
name|lpaattach
block|,
literal|0
block|,
name|lpastd
block|,
literal|"lpa"
block|,
name|lpadinfo
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lpa_softc
block|{
name|int
name|sc_flag
decl_stmt|;
comment|/* flags, as defined below */
name|int
name|sc_device
decl_stmt|;
comment|/* device: 0 = analog in, 1 = analog out */
name|int
name|sc_channel
decl_stmt|;
comment|/* device channel number */
name|struct
name|buf
name|sc_ubuffer
decl_stmt|;
comment|/* user buffer header */
name|int
name|sc_ubabuf
decl_stmt|;
comment|/* uba allocation pointer for buffer */
name|int
name|sc_ubufn
decl_stmt|;
comment|/* present buffer that user is accessing */
name|int
name|sc_lbufn
decl_stmt|;
comment|/* present buffer that lpa is accessing */
name|int
name|sc_lbufnx
decl_stmt|;
comment|/* next buffer for lpa (value in ustat) */
name|int
name|sc_nbuf
decl_stmt|;
comment|/* number of buffers */
name|int
name|sc_count
decl_stmt|;
comment|/* buffer size in words */
name|short
name|sc_ustat
decl_stmt|;
comment|/* user status word */
name|struct
name|buf
name|sc_ustatbuf
decl_stmt|;
comment|/* dummy user status word buffer for ubasetup */
name|int
name|sc_ubaustat
decl_stmt|;
comment|/* uba allocation pointer for ustat */
name|struct
name|buf
modifier|*
name|sc_buffer
decl_stmt|;
comment|/* scratch buffer header */
name|int
name|sc_start
decl_stmt|;
comment|/* 0 if lpa operation has been started */
block|}
name|lpa_softc
index|[
name|NLPA
index|]
struct|;
end_struct

begin_comment
comment|/* flags for sc_flag */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|01
end_define

begin_comment
comment|/* device is open */
end_comment

begin_define
define|#
directive|define
name|MCODE
value|02
end_define

begin_comment
comment|/* microcode has been loaded */
end_comment

begin_define
define|#
directive|define
name|DMDT
value|04
end_define

begin_comment
comment|/* dedicated mode dispatch table loaded */
end_comment

begin_define
define|#
directive|define
name|STTY
value|010
end_define

begin_comment
comment|/* stty call and device initialized */
end_comment

begin_define
define|#
directive|define
name|SLEEP
value|020
end_define

begin_comment
comment|/* sleeping */
end_comment

begin_comment
comment|/* bits for ustat */
end_comment

begin_define
define|#
directive|define
name|DONE
value|0100000
end_define

begin_comment
comment|/* done */
end_comment

begin_define
define|#
directive|define
name|STOP
value|0040000
end_define

begin_comment
comment|/* stop data transfer */
end_comment

begin_define
define|#
directive|define
name|NBI
value|0003400
end_define

begin_comment
comment|/* next buffer index */
end_comment

begin_define
define|#
directive|define
name|LBI
value|0000003
end_define

begin_comment
comment|/* last buffer index */
end_comment

begin_struct
struct|struct
name|lpadevice
block|{
name|short
name|lcim
decl_stmt|;
comment|/* control in and maintenance */
name|short
name|lcos
decl_stmt|;
comment|/* control and status out */
name|short
name|lrda
decl_stmt|;
comment|/* request description array address word */
name|short
name|lms
decl_stmt|;
comment|/* maintenance status */
block|}
struct|;
end_struct

begin_comment
comment|/* control in and maintenance register bits */
end_comment

begin_define
define|#
directive|define
name|READYI
value|0000200
end_define

begin_comment
comment|/* ready in */
end_comment

begin_define
define|#
directive|define
name|IIE
value|0000100
end_define

begin_comment
comment|/* in interrupt enable */
end_comment

begin_define
define|#
directive|define
name|RDAEXT
value|0000014
end_define

begin_comment
comment|/* rda address extension */
end_comment

begin_define
define|#
directive|define
name|RDAEXTOFFSET
value|2
end_define

begin_comment
comment|/* offset of RDAEXT from right side */
end_comment

begin_define
define|#
directive|define
name|GO
value|0000001
end_define

begin_comment
comment|/* go */
end_comment

begin_define
define|#
directive|define
name|RUN
value|0100000
end_define

begin_comment
comment|/* run */
end_comment

begin_define
define|#
directive|define
name|RESET
value|0040000
end_define

begin_comment
comment|/* reset */
end_comment

begin_define
define|#
directive|define
name|CWRITE
value|0020000
end_define

begin_comment
comment|/* cram write */
end_comment

begin_define
define|#
directive|define
name|EA
value|0004000
end_define

begin_comment
comment|/* enable arbitration */
end_comment

begin_define
define|#
directive|define
name|ROMO
value|0002000
end_define

begin_comment
comment|/* rom O */
end_comment

begin_define
define|#
directive|define
name|ROMI
value|0001000
end_define

begin_comment
comment|/* rom I */
end_comment

begin_define
define|#
directive|define
name|SMICRO
value|0000400
end_define

begin_comment
comment|/* step microprocessor */
end_comment

begin_comment
comment|/* control and status out register bits */
end_comment

begin_define
define|#
directive|define
name|READYO
value|0200
end_define

begin_comment
comment|/* ready out */
end_comment

begin_define
define|#
directive|define
name|OIE
value|0100
end_define

begin_comment
comment|/* out interrupt enable */
end_comment

begin_define
define|#
directive|define
name|UINDEX
value|0007
end_define

begin_comment
comment|/* user index */
end_comment

begin_define
define|#
directive|define
name|ERROR
value|0100000
end_define

begin_comment
comment|/* error */
end_comment

begin_define
define|#
directive|define
name|ESTAT
value|0060000
end_define

begin_comment
comment|/* error status */
end_comment

begin_define
define|#
directive|define
name|ESCODE
value|0017400
end_define

begin_comment
comment|/* error sub code */
end_comment

begin_define
define|#
directive|define
name|ECODE
value|0077400
end_define

begin_comment
comment|/* error status + error sub code */
end_comment

begin_define
define|#
directive|define
name|OVERRUN
value|0243
end_define

begin_comment
comment|/* overrun error */
end_comment

begin_comment
comment|/* LPA COMMAND DESCRIPTION AREA */
end_comment

begin_comment
comment|/* INIT COMMAND */
end_comment

begin_define
define|#
directive|define
name|INIT
value|0
end_define

begin_comment
comment|/* mode */
end_comment

begin_define
define|#
directive|define
name|MCVERS
value|4
end_define

begin_comment
comment|/* microcode version */
end_comment

begin_define
define|#
directive|define
name|ACLOCKA
value|0170404
end_define

begin_comment
comment|/* LPA bus addresses */
end_comment

begin_define
define|#
directive|define
name|ACLOCKB
value|0170432
end_define

begin_define
define|#
directive|define
name|AAD1
value|0170400
end_define

begin_define
define|#
directive|define
name|AAD2
value|1
end_define

begin_comment
comment|/* 0170440 - DOES NOT EXIST */
end_comment

begin_define
define|#
directive|define
name|ADA
value|0170420
end_define

begin_define
define|#
directive|define
name|ADIO1
value|1
end_define

begin_comment
comment|/* 0167770 - DOES NOT EXIST */
end_comment

begin_define
define|#
directive|define
name|ADIO2
value|1
end_define

begin_comment
comment|/* 0167760 - DOES NOT EXIST */
end_comment

begin_define
define|#
directive|define
name|ADIO3
value|1
end_define

begin_comment
comment|/* 0167750 - DOES NOT EXIST */
end_comment

begin_define
define|#
directive|define
name|ADIO4
value|1
end_define

begin_comment
comment|/* 0167740 - DOES NOT EXIST */
end_comment

begin_define
define|#
directive|define
name|ADIO5
value|1
end_define

begin_comment
comment|/* 0167730 - DOES NOT EXIST */
end_comment

begin_comment
comment|/* CLOCK START COMMAND */
end_comment

begin_define
define|#
directive|define
name|CLOCK
value|1
end_define

begin_comment
comment|/* mode */
end_comment

begin_define
define|#
directive|define
name|CLOCKA
value|0<<4
end_define

begin_comment
comment|/* clock A */
end_comment

begin_comment
comment|/* clock status word */
end_comment

begin_define
define|#
directive|define
name|ENACTR
value|1
end_define

begin_comment
comment|/* enable counter */
end_comment

begin_define
define|#
directive|define
name|R1M
value|1<<1
end_define

begin_comment
comment|/* 1 MHz rate */
end_comment

begin_define
define|#
directive|define
name|R100K
value|2<<1
end_define

begin_comment
comment|/* 100 KHz rate */
end_comment

begin_define
define|#
directive|define
name|R10K
value|3<<1
end_define

begin_comment
comment|/* 10 KHz rate */
end_comment

begin_define
define|#
directive|define
name|R1K
value|4<<1
end_define

begin_comment
comment|/* 1 KHz rate */
end_comment

begin_define
define|#
directive|define
name|R100
value|5<<1
end_define

begin_comment
comment|/* 100 Hz rate */
end_comment

begin_define
define|#
directive|define
name|REXT
value|6<<1
end_define

begin_comment
comment|/* external rate (from st1 input) */
end_comment

begin_define
define|#
directive|define
name|R60
value|7<<1
end_define

begin_comment
comment|/* line frequency rate */
end_comment

begin_define
define|#
directive|define
name|MFIE
value|0100
end_define

begin_comment
comment|/* mode flag interrupt enable */
end_comment

begin_define
define|#
directive|define
name|MSI
value|0<<8
end_define

begin_comment
comment|/* single interval mode */
end_comment

begin_define
define|#
directive|define
name|MRI
value|1<<8
end_define

begin_comment
comment|/* repeat interval mode */
end_comment

begin_define
define|#
directive|define
name|MEET
value|2<<8
end_define

begin_comment
comment|/* external event time mode */
end_comment

begin_define
define|#
directive|define
name|MEETZ
value|3<<8
end_define

begin_comment
comment|/* external event time mode from zero base */
end_comment

begin_define
define|#
directive|define
name|ST1EC
value|020000
end_define

begin_comment
comment|/* st1 enable counter */
end_comment

begin_define
define|#
directive|define
name|ST1IE
value|040000
end_define

begin_comment
comment|/* st1 interrupt enable */
end_comment

begin_comment
comment|/* DATA TRANSFER START COMMAND */
end_comment

begin_define
define|#
directive|define
name|DTS
value|2
end_define

begin_comment
comment|/* mode */
end_comment

begin_define
define|#
directive|define
name|SCHAN
value|1<<8
end_define

begin_comment
comment|/* single channel */
end_comment

begin_macro
name|lpaprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* value result */
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
endif|#
directive|endif
comment|/* this should force an interrupt, stall, clear the lpa */
name|br
operator|=
literal|0x15
expr_stmt|;
name|cvec
operator|=
literal|0330
expr_stmt|;
name|TRACER
argument_list|(
literal|"PROBE\n"
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|lpadevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|lpaattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|upa_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{  }
end_block

begin_macro
name|lpaopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|LPAUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|lpadinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|TRACER
argument_list|(
literal|"OPEN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NLPA
operator|||
name|sc
operator|->
name|sc_flag
operator|&
name|OPEN
operator|||
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
name|RESET
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|lpaaddr
operator|->
name|lcos
operator|=
literal|0
expr_stmt|;
comment|/* clear the registers as a precaution */
name|lpaaddr
operator|->
name|lrda
operator|=
literal|0
expr_stmt|;
name|lpaaddr
operator|->
name|lms
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator|=
name|OPEN
expr_stmt|;
name|sc
operator|->
name|sc_device
operator|=
name|LPADEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_channel
operator|=
name|LPACHANNEL
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_buffer
operator|=
name|geteblk
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_buffer
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_buffer
operator|->
name|b_proc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|sc
operator|->
name|sc_ubufn
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* THIS SHOULD EVENTUALLY SPECIFY "REAL-TIME" */
name|u
operator|.
name|u_procp
operator|->
name|p_nice
operator|=
name|NICE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|lpaclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|LPAUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|lpadinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_device
operator|&&
name|sc
operator|->
name|sc_ubufn
operator|>=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flag
operator|&
name|ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_start
condition|)
name|lpacmd
argument_list|(
name|sc
operator|->
name|sc_buffer
argument_list|,
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|STOP
expr_stmt|;
operator|(
name|void
operator|)
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|STOP
condition|)
block|{
name|TRACER
argument_list|(
literal|"SLEEP\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|SLEEP
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|LPAPRI
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
name|RESET
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ubabuf
condition|)
block|{
name|ubarelse
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|sc
operator|->
name|sc_ubabuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ubabuf
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splclock
argument_list|()
expr_stmt|;
name|vsunlock
argument_list|(
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_un
operator|.
name|b_addr
argument_list|,
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_bcount
argument_list|,
operator|(
name|sc
operator|->
name|sc_device
operator|)
condition|?
name|B_READ
else|:
name|B_WRITE
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&=
operator|~
name|SPHYSIO
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ubaustat
condition|)
block|{
name|ubarelse
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|sc
operator|->
name|sc_ubaustat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ubaustat
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_buffer
condition|)
block|{
name|brelse
argument_list|(
name|sc
operator|->
name|sc_buffer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_buffer
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flag
operator|=
literal|0
expr_stmt|;
name|TRACER
argument_list|(
literal|"CLOSE\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lpawrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|LPAUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|lpadinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
name|TRACER
argument_list|(
literal|"WRITE\n"
argument_list|)
expr_stmt|;
name|f
operator|=
name|sc
operator|->
name|sc_flag
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|OPEN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|&
name|MCODE
operator|)
operator|==
literal|0
condition|)
comment|/* first write is the microcode */
return|return
operator|(
name|lpamcode
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|uio
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|&
name|DMDT
operator|)
operator|==
literal|0
condition|)
comment|/* second write is the dispatch table */
return|return
operator|(
name|lpadmdt
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
name|uio
argument_list|)
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|lpamcode
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|uio
argument_list|)
specifier|register
expr|struct
name|lpadevice
operator|*
name|lpaaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|v
decl_stmt|,
name|r
decl_stmt|;
specifier|register
name|int
name|mcaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mcaddr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|v
argument_list|,
literal|2
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|lpaaddr
operator|->
name|lcim
operator|=
literal|0
expr_stmt|;
comment|/* load microcode word */
name|lpaaddr
operator|->
name|lrda
operator|=
name|mcaddr
expr_stmt|;
name|lpaaddr
operator|->
name|lms
operator|=
name|v
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
name|ROMO
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator||=
name|CWRITE
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
literal|0
expr_stmt|;
comment|/* verify microcode word */
name|lpaaddr
operator|->
name|lrda
operator|=
name|mcaddr
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
name|ROMO
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|lpaaddr
operator|->
name|lms
operator|)
operator|!=
name|v
condition|)
block|{
comment|/* download failure */
name|printf
argument_list|(
literal|"LPA MICROCODE FAIL: exp:%o got:%o\n"
argument_list|,
name|v
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mcaddr
operator|++
expr_stmt|;
block|}
name|lpaaddr
operator|->
name|lcim
operator|=
name|RUN
operator||
name|EA
expr_stmt|;
comment|/* turn it on */
name|sc
operator|->
name|sc_flag
operator||=
name|MCODE
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator||=
name|IIE
expr_stmt|;
name|lpaaddr
operator|->
name|lcos
operator||=
name|OIE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|TRACER
argument_list|(
literal|"MCODE\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lpadmdt
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ubanum
argument_list|,
name|uio
argument_list|)
specifier|register
expr|struct
name|lpadevice
operator|*
name|lpaaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|ubanum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
operator|(
name|short
operator|*
operator|)
name|sc
operator|->
name|sc_buffer
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* INIT */
operator|*
name|p
operator|++
operator|=
operator|(
name|MCVERS
operator|<<
literal|8
operator|)
operator||
name|INIT
expr_stmt|;
comment|/* mode */
operator|*
name|p
operator|++
operator|=
name|ACLOCKA
expr_stmt|;
comment|/* LPA bus device addresses */
operator|*
name|p
operator|++
operator|=
name|ACLOCKB
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|AAD1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|AAD2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ADA
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ADIO1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ADIO2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ADIO3
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ADIO4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ADIO5
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
literal|256
argument_list|)
expr_stmt|;
comment|/* dedicated mode dispatch table */
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|n
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|n
operator|>>=
literal|1
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
while|while
condition|(
name|n
operator|++
operator|<
literal|128
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|lpacmd
argument_list|(
name|sc
operator|->
name|sc_buffer
argument_list|,
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ubanum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|DMDT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|TRACER
argument_list|(
literal|"DMDT\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lpaioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|LPAUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|lpadinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
specifier|register
name|short
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|v
decl_stmt|;
struct|struct
name|iocb
block|{
name|short
modifier|*
name|baddr
decl_stmt|;
name|short
name|rate
decl_stmt|;
name|short
name|wc
decl_stmt|;
block|}
modifier|*
name|iocb
struct|;
name|TRACER
argument_list|(
literal|"IOCTL IN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|TIOCSETP
operator|||
operator|(
name|sc
operator|->
name|sc_flag
operator|&
name|DMDT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|iocb
operator|=
operator|(
expr|struct
name|iocb
operator|*
operator|)
name|data
expr_stmt|;
name|p
operator|=
operator|(
name|short
operator|*
operator|)
name|sc
operator|->
name|sc_buffer
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* CLOCK START */
operator|*
name|p
operator|++
operator|=
name|CLOCK
operator||
name|CLOCKA
expr_stmt|;
comment|/* mode */
operator|*
name|p
operator|++
operator|=
name|ENACTR
operator||
name|R1M
operator||
name|MFIE
operator||
name|MRI
expr_stmt|;
comment|/* clock status */
operator|*
name|p
operator|=
name|iocb
operator|->
name|rate
expr_stmt|;
comment|/* clock preset */
name|lpacmd
argument_list|(
name|sc
operator|->
name|sc_buffer
argument_list|,
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|)
expr_stmt|;
name|TRACER
argument_list|(
literal|"CLOCK STARTED\n"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|short
operator|*
operator|)
name|sc
operator|->
name|sc_buffer
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* DATA TRANSFER START*/
operator|*
name|p
operator|++
operator|=
operator|(
name|sc
operator|->
name|sc_device
operator|<<
literal|7
operator|)
operator||
name|DTS
operator||
name|SCHAN
expr_stmt|;
comment|/* mode */
name|sc
operator|->
name|sc_count
operator|=
name|iocb
operator|->
name|wc
operator|&
literal|017777
expr_stmt|;
comment|/* word count per buffer */
operator|*
name|p
operator|++
operator|=
name|sc
operator|->
name|sc_count
expr_stmt|;
comment|/* user status word */
name|sc
operator|->
name|sc_ustatbuf
operator|.
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_ustat
expr_stmt|;
name|sc
operator|->
name|sc_ustatbuf
operator|.
name|b_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ustatbuf
operator|.
name|b_bcount
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|sc_ustatbuf
operator|.
name|b_proc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|sc
operator|->
name|sc_ubaustat
operator|=
name|ubasetup
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|sc
operator|->
name|sc_ustatbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v
operator|=
name|sc
operator|->
name|sc_ubaustat
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|v
operator|>>
literal|16
operator|)
operator|&
literal|03
expr_stmt|;
comment|/* into low portion of word */
name|sc
operator|->
name|sc_nbuf
operator|=
operator|(
name|iocb
operator|->
name|wc
operator|>>
literal|13
operator|)
operator|&
literal|07
expr_stmt|;
comment|/* number of buffers */
operator|*
name|p
operator|++
operator||=
name|sc
operator|->
name|sc_nbuf
operator|++
operator|<<
literal|8
expr_stmt|;
comment|/* into high portion of word */
comment|/* buffer addresses */
if|if
condition|(
name|useracc
argument_list|(
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|iocb
operator|->
name|baddr
argument_list|,
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_bcount
operator|=
name|sc
operator|->
name|sc_count
operator|*
name|sc
operator|->
name|sc_nbuf
operator|*
literal|2
argument_list|,
operator|(
name|i
operator|=
operator|(
name|sc
operator|->
name|sc_device
operator|)
condition|?
name|B_READ
else|:
name|B_WRITE
operator|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|TRACER
argument_list|(
literal|"USER BUFFER FAULT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_flags
operator|=
name|B_PHYS
operator||
name|B_BUSY
operator||
name|i
expr_stmt|;
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_proc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SPHYSIO
expr_stmt|;
name|vslock
argument_list|(
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_un
operator|.
name|b_addr
argument_list|,
name|sc
operator|->
name|sc_ubuffer
operator|.
name|b_bcount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ubabuf
operator|=
name|ubasetup
argument_list|(
name|ui
operator|->
name|ui_ubanum
argument_list|,
operator|&
name|sc
operator|->
name|sc_ubuffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v
operator|=
name|sc
operator|->
name|sc_ubabuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nbuf
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|v
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|v
operator|>>
literal|16
operator|)
operator|&
literal|03
expr_stmt|;
name|v
operator|+=
name|sc
operator|->
name|sc_count
operator|*
literal|2
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* random channel list address */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* delay */
operator|*
name|p
operator|++
operator|=
name|sc
operator|->
name|sc_channel
expr_stmt|;
comment|/* start channel, channel inc */
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* number of samples in a sequence */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* dwell */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* start word no., event mark word */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* start word mask */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* event mark mask */
name|sc
operator|->
name|sc_ustat
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
operator|(
name|sc
operator|->
name|sc_device
operator|)
condition|?
name|sc
operator|->
name|sc_nbuf
operator|+
literal|1
else|:
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_lbufn
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lbufnx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|STTY
expr_stmt|;
name|TRACER
argument_list|(
literal|"IOCTL OUT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|lparead
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|LPAUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|lpadinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|TRACER
argument_list|(
literal|"READ\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flag
operator|&
name|STTY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|ERROR
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_start
condition|)
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_start
operator|==
literal|0
condition|)
block|{
name|lpacmd
argument_list|(
name|sc
operator|->
name|sc_buffer
argument_list|,
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|)
expr_stmt|;
name|TRACER
argument_list|(
literal|"START\n"
argument_list|)
expr_stmt|;
block|}
name|inc
argument_list|(
name|sc_ubufn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_start
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_ubufn
operator|==
name|sc
operator|->
name|sc_lbufn
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|ERROR
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|TRACER
argument_list|(
literal|"SLEEP\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|SLEEP
expr_stmt|;
name|sleep
argument_list|(
name|sc
argument_list|,
name|LPAPRI
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
block|}
name|TRACERN
argument_list|(
literal|"READ %d\n"
argument_list|,
name|sc
operator|->
name|sc_ubufn
argument_list|)
expr_stmt|;
return|return
operator|(
name|uiomove
argument_list|(
operator|&
name|sc
operator|->
name|sc_ubufn
argument_list|,
literal|1
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|lpacmd
argument_list|(
name|bp
argument_list|,
name|lpaaddr
argument_list|,
name|sc
argument_list|,
name|ubanum
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|ubanum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ubareg
decl_stmt|;
name|TRACER
argument_list|(
literal|"CMD\n"
argument_list|)
expr_stmt|;
name|ubareg
operator|=
name|ubasetup
argument_list|(
name|ubanum
argument_list|,
name|bp
argument_list|,
name|UBA_NEEDBDP
argument_list|)
expr_stmt|;
name|lpawait
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|lpaaddr
operator|->
name|lrda
operator|=
name|ubareg
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|&=
operator|~
name|RDAEXT
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator||=
operator|(
operator|(
name|ubareg
operator|>>
operator|(
literal|16
operator|-
name|RDAEXTOFFSET
operator|)
operator|)
operator|&
name|RDAEXT
operator|)
operator||
name|GO
expr_stmt|;
name|lpawait
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ubarelse
argument_list|(
name|ubanum
argument_list|,
operator|&
name|ubareg
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lpawait
argument_list|(
name|lpaaddr
argument_list|,
name|sc
argument_list|)
specifier|register
expr|struct
name|lpadevice
operator|*
name|lpaaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|lpaaddr
operator|->
name|lcim
operator|&
name|READYI
operator|)
operator|==
literal|0
condition|)
block|{
name|TRACER
argument_list|(
literal|"SLEEP\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|SLEEP
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|LPAPRI
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|lpaiintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
name|TRACER
argument_list|(
literal|"{I"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|SLEEP
condition|)
block|{
name|TRACER
argument_list|(
literal|"<WAKEUP>"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator|&=
operator|~
name|SLEEP
expr_stmt|;
block|}
name|TRACER
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lpaointr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|m
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
init|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|lpadinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
init|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|int
name|spx
decl_stmt|;
name|TRACER
argument_list|(
literal|"{O"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|SLEEP
condition|)
block|{
name|TRACER
argument_list|(
literal|"<WAKEUP>"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator|&=
operator|~
name|SLEEP
expr_stmt|;
block|}
name|c
operator|=
name|lpaaddr
operator|->
name|lcos
expr_stmt|;
name|m
operator|=
name|lpaaddr
operator|->
name|lms
expr_stmt|;
name|lpaaddr
operator|->
name|lcos
operator|&=
operator|~
name|READYO
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|ERROR
condition|)
block|{
name|TRACER
argument_list|(
literal|"<ERROR>"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flag
operator|&
name|STOP
operator|)
operator|==
literal|0
operator|||
operator|(
name|c
operator|!=
name|OVERRUN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"LPA ERROR %o %o\n"
argument_list|,
name|c
argument_list|,
name|m
operator|&
literal|0177777
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|ERROR
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flag
operator|&=
operator|~
name|STOP
expr_stmt|;
name|TRACER
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|TRACERN
argument_list|(
literal|"<LPA %d>"
argument_list|,
name|sc
operator|->
name|sc_lbufnx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lbufn
operator|=
name|sc
operator|->
name|sc_lbufnx
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ubufn
operator|==
name|sc
operator|->
name|sc_lbufnx
operator|&&
name|c
operator|&
name|ECODE
condition|)
block|{
name|TRACER
argument_list|(
literal|"<STOP?>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|STOP
condition|)
return|return;
name|printf
argument_list|(
literal|"LPA OVERRUN\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|ERROR
expr_stmt|;
block|}
name|inc
argument_list|(
name|sc_lbufnx
argument_list|)
expr_stmt|;
name|TRACERN
argument_list|(
literal|"<USTAT %o>"
argument_list|,
name|sc
operator|->
name|sc_ustat
argument_list|)
expr_stmt|;
name|spx
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_ustat
operator|&=
operator|~
name|NBI
expr_stmt|;
name|sc
operator|->
name|sc_ustat
operator||=
name|sc
operator|->
name|sc_lbufnx
operator|<<
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_ustat
operator|&=
operator|~
name|DONE
expr_stmt|;
name|splx
argument_list|(
name|spx
argument_list|)
expr_stmt|;
name|TRACERN
argument_list|(
literal|"<LPAN %d>}"
argument_list|,
name|sc
operator|->
name|sc_lbufnx
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lpareset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|lpadevice
modifier|*
name|lpaaddr
decl_stmt|;
specifier|register
name|struct
name|lpa_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|TRACER
argument_list|(
literal|"LPA RESET\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NLPA
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ui
operator|=
name|lpadinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" lpa%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|lpaaddr
operator|=
operator|(
expr|struct
name|lpadevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|sc
operator|=
operator|&
name|lpa_softc
index|[
name|unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator||=
name|ERROR
expr_stmt|;
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
name|RESET
expr_stmt|;
name|lpaaddr
operator|->
name|lcim
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|SLEEP
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flag
operator|&=
operator|~
name|SLEEP
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NLPA
end_endif

end_unit

