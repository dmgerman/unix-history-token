begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)ip_input.c	7.10 (Berkeley) 6/29/88  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"in.h"
end_include

begin_include
include|#
directive|include
file|"in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"in_systm.h"
end_include

begin_include
include|#
directive|include
file|"in_var.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"ip_var.h"
end_include

begin_include
include|#
directive|include
file|"ip_icmp.h"
end_include

begin_include
include|#
directive|include
file|"tcp.h"
end_include

begin_decl_stmt
name|u_char
name|ip_protox
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipqmaxlen
init|=
name|IFQ_MAXLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_ifaddr
modifier|*
name|in_ifaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first inet address */
end_comment

begin_comment
comment|/*  * We need to save the IP options in case a protocol wants to respond  * to an incoming packet over the same route if the packet got here  * using IP source routing.  This allows connection establishment and  * maintenance when the remote end is on a network that is not known  * to us.  */
end_comment

begin_decl_stmt
name|int
name|ip_nhops
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|ip_srcrt
block|{
name|char
name|nop
decl_stmt|;
comment|/* one NOP to align */
name|char
name|srcopt
index|[
name|IPOPT_OFFSET
operator|+
literal|1
index|]
decl_stmt|;
comment|/* OPTVAL, OLEN and OFFSET */
name|struct
name|in_addr
name|route
index|[
name|MAX_IPOPTLEN
index|]
decl_stmt|;
block|}
name|ip_srcrt
struct|;
end_struct

begin_comment
comment|/*  * IP initialization: fill in IP protocol switch table.  * All protocols not implemented in kernel go to raw IP protocol handler.  */
end_comment

begin_macro
name|ip_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ip_init"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
name|ip_protox
index|[
name|i
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|inetdomain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
name|inetdomain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RAW
condition|)
name|ip_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
name|ipq
operator|.
name|next
operator|=
name|ipq
operator|.
name|prev
operator|=
operator|&
name|ipq
expr_stmt|;
name|ip_id
operator|=
name|time
operator|.
name|tv_sec
operator|&
literal|0xffff
expr_stmt|;
name|ipintrq
operator|.
name|ifq_maxlen
operator|=
name|ipqmaxlen
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|u_char
name|ipcksum
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|ip
modifier|*
name|ip_reass
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|sockaddr_in
name|ipaddr
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|route
name|ipforward_rt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ip input routine.  Checksum and byte swap header.  If fragmented  * try to reassamble.  If complete and fragment queue exists, discard.  * Process options.  Pass to next level.  */
end_comment

begin_macro
name|ipintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|s
decl_stmt|;
name|next
label|:
comment|/* 	 * Get next datagram off input queue and get IP header 	 * in first mbuf. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUEIF
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If no IP addresses have been set yet but the interfaces 	 * are receiving, can't do anything with incoming packets yet. 	 */
if|if
condition|(
name|in_ifaddr
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ipstat
operator|.
name|ips_total
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_toosmall
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* minimum header length */
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipcksum
condition|)
if|if
condition|(
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
condition|)
block|{
name|ipstat
operator|.
name|ips_badsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Convert fields to host representation. 	 */
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|<
name|hlen
condition|)
block|{
name|ipstat
operator|.
name|ips_badlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|->
name|ip_id
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
name|i
operator|=
operator|-
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
literal|0
condition|)
break|break;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_tooshort
operator|++
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|i
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_len
operator|-=
name|i
expr_stmt|;
else|else
name|m_adj
argument_list|(
name|m0
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m0
expr_stmt|;
comment|/* 	 * Process options and, if not destined for us, 	 * ship it on.  ip_dooptions returns 1 when an 	 * error was detected (causing an icmp message 	 * to be sent and the original packet to be freed). 	 */
name|ip_nhops
operator|=
literal|0
expr_stmt|;
comment|/* for source routed packets */
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
name|ip_dooptions
argument_list|(
name|ip
argument_list|,
name|ifp
argument_list|)
condition|)
goto|goto
name|next
goto|;
comment|/* 	 * Check our list of addresses, to see if the packet is for us. 	 */
for|for
control|(
name|ia
operator|=
name|in_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
define|#
directive|define
name|satosin
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
if|if
condition|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
ifdef|#
directive|ifdef
name|DIRECTED_BROADCAST
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
operator|&&
endif|#
directive|endif
operator|(
name|ia
operator|->
name|ia_ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
condition|)
block|{
name|u_long
name|t
decl_stmt|;
if|if
condition|(
name|satosin
argument_list|(
operator|&
name|ia
operator|->
name|ia_broadaddr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|ia
operator|->
name|ia_netbroadcast
operator|.
name|s_addr
condition|)
goto|goto
name|ours
goto|;
comment|/* 			 * Look for all-0's host part (old broadcast addr), 			 * either for subnet or net. 			 */
name|t
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|ia
operator|->
name|ia_subnet
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
name|t
operator|==
name|ia
operator|->
name|ia_net
condition|)
goto|goto
name|ours
goto|;
block|}
block|}
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
operator|(
name|u_long
operator|)
name|INADDR_BROADCAST
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
goto|goto
name|ours
goto|;
comment|/* 	 * Not for us; forward if possible and desirable. 	 */
name|ip_forward
argument_list|(
name|ip
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
name|ours
label|:
comment|/* 	 * If offset or IP_MF are set, must reassemble. 	 * Otherwise, nothing need be done. 	 * (We could look in the reassembly queue to see 	 * if the packet was previously fragmented, 	 * but it's not worth the time; just let them time out.) 	 */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
operator|~
name|IP_DF
condition|)
block|{
comment|/* 		 * Look for queue of fragments 		 * of this datagram. 		 */
for|for
control|(
name|fp
operator|=
name|ipq
operator|.
name|next
init|;
name|fp
operator|!=
operator|&
name|ipq
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|ip
operator|->
name|ip_id
operator|==
name|fp
operator|->
name|ipq_id
operator|&&
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_dst
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|fp
operator|->
name|ipq_p
condition|)
goto|goto
name|found
goto|;
name|fp
operator|=
literal|0
expr_stmt|;
name|found
label|:
comment|/* 		 * Adjust ip_len to not reflect header, 		 * set ip_mff if more fragments are expected, 		 * convert offset of this to bytes. 		 */
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
operator|(
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|ip
operator|)
operator|->
name|ipf_mff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|IP_MF
condition|)
operator|(
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|ip
operator|)
operator|->
name|ipf_mff
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|<<=
literal|3
expr_stmt|;
comment|/* 		 * If datagram marked as having more fragments 		 * or if this is not the first fragment, 		 * attempt reassembly; if it succeeds, proceed. 		 */
if|if
condition|(
operator|(
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|ip
operator|)
operator|->
name|ipf_mff
operator|||
name|ip
operator|->
name|ip_off
condition|)
block|{
name|ipstat
operator|.
name|ips_fragments
operator|++
expr_stmt|;
name|ip
operator|=
name|ip_reass
argument_list|(
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|ip
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
name|m
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
condition|)
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
comment|/* 	 * Switch out to protocol's input routine. 	 */
operator|(
operator|*
name|inetsw
index|[
name|ip_protox
index|[
name|ip
operator|->
name|ip_p
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
name|m
operator|,
name|ifp
operator|)
expr_stmt|;
goto|goto
name|next
goto|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
end_block

begin_comment
comment|/*  * Take incoming datagram fragment and try to  * reassemble it into whole datagram.  If a chain for  * reassembly of this datagram already exists, then it  * is given as fp; otherwise have to make a chain.  */
end_comment

begin_function
name|struct
name|ip
modifier|*
name|ip_reass
parameter_list|(
name|ip
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|struct
name|ipasfrag
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|dtom
argument_list|(
name|ip
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ipasfrag
modifier|*
name|q
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Presence of header sizes in mbufs 	 * would confuse code below. 	 */
name|m
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
comment|/* 	 * If first fragment to arrive, create a reassembly queue. 	 */
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_FTABLE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|dropfrag
goto|;
name|fp
operator|=
name|mtod
argument_list|(
name|t
argument_list|,
expr|struct
name|ipq
operator|*
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|fp
argument_list|,
operator|&
name|ipq
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ipq_ttl
operator|=
name|IPFRAGTTL
expr_stmt|;
name|fp
operator|->
name|ipq_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fp
operator|->
name|ipq_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|fp
operator|->
name|ipq_next
operator|=
name|fp
operator|->
name|ipq_prev
operator|=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
expr_stmt|;
name|fp
operator|->
name|ipq_src
operator|=
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip_src
expr_stmt|;
name|fp
operator|->
name|ipq_dst
operator|=
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip_dst
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
expr_stmt|;
goto|goto
name|insert
goto|;
block|}
comment|/* 	 * Find a segment which begins after this one does. 	 */
for|for
control|(
name|q
operator|=
name|fp
operator|->
name|ipq_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
condition|;
name|q
operator|=
name|q
operator|->
name|ipf_next
control|)
if|if
condition|(
name|q
operator|->
name|ip_off
operator|>
name|ip
operator|->
name|ip_off
condition|)
break|break;
comment|/* 	 * If there is a preceding segment, it may provide some of 	 * our data already.  If so, drop the data from the incoming 	 * segment.  If it provides all of our data, drop us. 	 */
if|if
condition|(
name|q
operator|->
name|ipf_prev
operator|!=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
condition|)
block|{
name|i
operator|=
name|q
operator|->
name|ipf_prev
operator|->
name|ip_off
operator|+
name|q
operator|->
name|ipf_prev
operator|->
name|ip_len
operator|-
name|ip
operator|->
name|ip_off
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ip
operator|->
name|ip_len
condition|)
goto|goto
name|dropfrag
goto|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * While we overlap succeeding segments trim them or, 	 * if they are completely covered, dequeue them. 	 */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
operator|&&
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|>
name|q
operator|->
name|ip_off
condition|)
block|{
name|i
operator|=
operator|(
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|)
operator|-
name|q
operator|->
name|ip_off
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|q
operator|->
name|ip_len
condition|)
block|{
name|q
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|q
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|q
operator|=
name|q
operator|->
name|ipf_next
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
operator|->
name|ipf_prev
argument_list|)
argument_list|)
expr_stmt|;
name|ip_deq
argument_list|(
name|q
operator|->
name|ipf_prev
argument_list|)
expr_stmt|;
block|}
name|insert
label|:
comment|/* 	 * Stick new segment in its place; 	 * check for complete reassembly. 	 */
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|q
operator|->
name|ipf_prev
argument_list|)
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|fp
operator|->
name|ipq_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
condition|;
name|q
operator|=
name|q
operator|->
name|ipf_next
control|)
block|{
if|if
condition|(
name|q
operator|->
name|ip_off
operator|!=
name|next
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|next
operator|+=
name|q
operator|->
name|ip_len
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|ipf_prev
operator|->
name|ipf_mff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Reassembly is complete; concatenate fragments. 	 */
name|q
operator|=
name|fp
operator|->
name|ipq_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|t
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ipf_next
expr_stmt|;
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
condition|)
block|{
name|t
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ipf_next
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create header for new ip packet by 	 * modifying header of first packet; 	 * dequeue and discard fragment reassembly header. 	 * Make header visible. 	 */
name|ip
operator|=
name|fp
operator|->
name|ipq_next
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|next
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip_src
operator|=
name|fp
operator|->
name|ipq_src
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip_dst
operator|=
name|fp
operator|->
name|ipq_dst
expr_stmt|;
name|remque
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|-=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ip
operator|)
return|;
name|dropfrag
label|:
name|ipstat
operator|.
name|ips_fragdropped
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a fragment reassembly header and all  * associated datagrams.  */
end_comment

begin_macro
name|ip_freef
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ipasfrag
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|q
operator|=
name|fp
operator|->
name|ipq_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|ipasfrag
operator|*
operator|)
name|fp
condition|;
name|q
operator|=
name|p
control|)
block|{
name|p
operator|=
name|q
operator|->
name|ipf_next
expr_stmt|;
name|ip_deq
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remque
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put an ip fragment on a reassembly chain.  * Like insque, but pointers in middle of structure.  */
end_comment

begin_expr_stmt
name|ip_enq
argument_list|(
name|p
argument_list|,
name|prev
argument_list|)
specifier|register
expr|struct
name|ipasfrag
operator|*
name|p
operator|,
operator|*
name|prev
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|ipf_prev
operator|=
name|prev
expr_stmt|;
name|p
operator|->
name|ipf_next
operator|=
name|prev
operator|->
name|ipf_next
expr_stmt|;
name|prev
operator|->
name|ipf_next
operator|->
name|ipf_prev
operator|=
name|p
expr_stmt|;
name|prev
operator|->
name|ipf_next
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * To ip_enq as remque is to insque.  */
end_comment

begin_expr_stmt
name|ip_deq
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|ipasfrag
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|ipf_prev
operator|->
name|ipf_next
operator|=
name|p
operator|->
name|ipf_next
expr_stmt|;
name|p
operator|->
name|ipf_next
operator|->
name|ipf_prev
operator|=
name|p
operator|->
name|ipf_prev
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * IP timer processing;  * if a timer expires on a reassembly  * queue, discard it.  */
end_comment

begin_macro
name|ip_slowtimo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|fp
operator|=
name|ipq
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fp
operator|!=
operator|&
name|ipq
condition|)
block|{
operator|--
name|fp
operator|->
name|ipq_ttl
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|prev
operator|->
name|ipq_ttl
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_fragtimeout
operator|++
expr_stmt|;
name|ip_freef
argument_list|(
name|fp
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Drain off all datagram fragments.  */
end_comment

begin_macro
name|ip_drain
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|ipq
operator|.
name|next
operator|!=
operator|&
name|ipq
condition|)
block|{
name|ipstat
operator|.
name|ips_fragdropped
operator|++
expr_stmt|;
name|ip_freef
argument_list|(
name|ipq
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function_decl
specifier|extern
name|struct
name|in_ifaddr
modifier|*
name|ifptoia
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|in_ifaddr
modifier|*
name|ip_rtaddr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Do option processing on a datagram,  * possibly discarding it if bad options  * are encountered.  */
end_comment

begin_expr_stmt
name|ip_dooptions
argument_list|(
name|ip
argument_list|,
name|ifp
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|optlen
decl_stmt|,
name|cnt
decl_stmt|,
name|off
decl_stmt|,
name|code
decl_stmt|,
name|type
init|=
name|ICMP_PARAMPROB
decl_stmt|;
specifier|register
name|struct
name|ip_timestamp
modifier|*
name|ipt
decl_stmt|;
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|sin
decl_stmt|;
name|n_time
name|ntime
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|cnt
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
name|IPOPT_OPTVAL
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|IPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|IPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|optlen
operator|=
name|cp
index|[
name|IPOPT_OLEN
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<=
literal|0
operator|||
name|optlen
operator|>
name|cnt
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OLEN
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
default|default:
break|break;
comment|/* 		 * Source routing with record. 		 * Find interface with current destination address. 		 * If none on this machine then drop if strictly routed, 		 * or do nothing if loosely routed. 		 * Record interface address and bring up next address 		 * component.  If strictly routed make sure next 		 * address on directly accessible net. 		 */
case|case
name|IPOPT_LSRR
case|:
case|case
name|IPOPT_SSRR
case|:
if|if
condition|(
operator|(
name|off
operator|=
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|)
operator|<
name|IPOPT_MINOFF
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ipaddr
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|ia
operator|=
operator|(
expr|struct
name|in_ifaddr
operator|*
operator|)
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt
operator|==
name|IPOPT_SSRR
condition|)
block|{
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_SRCFAIL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 				 * Loose routing, and not at next destination 				 * yet; nothing to do except forward. 				 */
break|break;
block|}
name|off
operator|--
expr_stmt|;
comment|/* 0 origin */
if|if
condition|(
name|off
operator|>
name|optlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
comment|/* 				 * End of source route.  Should be for us. 				 */
name|save_rte
argument_list|(
name|cp
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * locate outgoing interface 			 */
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|cp
operator|+
name|off
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipaddr
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|==
name|IPOPT_SSRR
operator|&&
name|in_iaonnetof
argument_list|(
name|in_netof
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ia
operator|=
name|ip_rtaddr
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_SRCFAIL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|->
name|ip_dst
operator|=
name|ipaddr
operator|.
name|sin_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|cp
operator|+
name|off
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPOPT_RR
case|:
if|if
condition|(
operator|(
name|off
operator|=
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|)
operator|<
name|IPOPT_MINOFF
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * If no space remains, ignore. 			 */
name|off
operator|--
expr_stmt|;
comment|/* 0 origin */
if|if
condition|(
name|off
operator|>
name|optlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
break|break;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipaddr
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * locate outgoing interface 			 */
if|if
condition|(
operator|(
name|ia
operator|=
name|ip_rtaddr
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|cp
operator|+
name|off
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPOPT_TS
case|:
name|code
operator|=
name|cp
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
name|ipt
operator|=
operator|(
expr|struct
name|ip_timestamp
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ipt
operator|->
name|ipt_len
operator|<
literal|5
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|>
name|ipt
operator|->
name|ipt_len
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|ipt
operator|->
name|ipt_oflw
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
break|break;
block|}
name|sin
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|cp
operator|+
name|ipt
operator|->
name|ipt_ptr
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|ipt
operator|->
name|ipt_flg
condition|)
block|{
case|case
name|IPOPT_TS_TSONLY
case|:
break|break;
case|case
name|IPOPT_TS_TSANDADDR
case|:
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|+
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|>
name|ipt
operator|->
name|ipt_len
condition|)
goto|goto
name|bad
goto|;
name|ia
operator|=
name|ifptoia
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ipt
operator|->
name|ipt_ptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPOPT_TS_PRESPEC
case|:
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|+
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|>
name|ipt
operator|->
name|ipt_len
condition|)
goto|goto
name|bad
goto|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sin
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ipaddr
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ipaddr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ipt
operator|->
name|ipt_ptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
name|ntime
operator|=
name|iptime
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ntime
argument_list|,
operator|(
name|caddr_t
operator|)
name|cp
operator|+
name|ipt
operator|->
name|ipt_ptr
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
argument_list|)
expr_stmt|;
name|ipt
operator|->
name|ipt_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|icmp_error
argument_list|(
name|ip
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Given address of next destination (final or next hop),  * return internet address info of interface to be used to get there.  */
end_comment

begin_function
name|struct
name|in_ifaddr
modifier|*
name|ip_rtaddr
parameter_list|(
name|dst
parameter_list|)
name|struct
name|in_addr
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ipforward_rt
operator|.
name|ro_dst
expr_stmt|;
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|==
literal|0
operator|||
name|dst
operator|.
name|s_addr
operator|!=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ipforward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ipforward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|dst
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|ipforward_rt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|in_ifaddr
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Find address associated with outgoing interface. 	 */
for|for
control|(
name|ia
operator|=
name|in_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
condition|)
break|break;
return|return
operator|(
name|ia
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Save incoming source route for use in replies,  * to be picked up later by ip_srcroute if the receiver is interested.  */
end_comment

begin_macro
name|save_rte
argument_list|(
argument|option
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|option
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|olen
decl_stmt|;
extern|extern ipprintfs;
name|olen
operator|=
name|option
index|[
name|IPOPT_OLEN
index|]
expr_stmt|;
if|if
condition|(
name|olen
operator|>
sizeof|sizeof
argument_list|(
name|ip_srcrt
argument_list|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"save_rte: olen %d\n"
argument_list|,
name|olen
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|option
argument_list|,
operator|(
name|caddr_t
operator|)
name|ip_srcrt
operator|.
name|srcopt
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|ip_nhops
operator|=
operator|(
name|olen
operator|-
name|IPOPT_OFFSET
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|ip_srcrt
operator|.
name|route
index|[
name|ip_nhops
operator|++
index|]
operator|=
name|dst
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Retrieve incoming source route for use in replies,  * in the same form used by setsockopt.  * The first hop is placed before the options, will be removed later.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ip_srcroute
parameter_list|()
block|{
specifier|register
name|struct
name|in_addr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|ip_nhops
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
return|;
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|ip_nhops
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|+
name|IPOPT_OFFSET
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
comment|/* 	 * First save first hop for return route 	 */
name|p
operator|=
operator|&
name|ip_srcrt
operator|.
name|route
index|[
name|ip_nhops
operator|-
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|in_addr
operator|*
argument_list|)
operator|)
operator|=
operator|*
name|p
operator|--
expr_stmt|;
comment|/* 	 * Copy option fields and padding (nop) to mbuf. 	 */
name|ip_srcrt
operator|.
name|nop
operator|=
name|IPOPT_NOP
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip_srcrt
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IPOPT_OFFSET
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|+
name|IPOPT_OFFSET
operator|+
literal|1
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Record return path as an IP source route, 	 * reversing the path (pointers are now aligned). 	 */
while|while
condition|(
name|p
operator|>=
name|ip_srcrt
operator|.
name|route
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Strip out IP options, at higher  * level protocol in the kernel.  * Second argument is buffer to which options  * will be moved, and return value is their length.  */
end_comment

begin_macro
name|ip_stripoptions
argument_list|(
argument|ip
argument_list|,
argument|mopt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mopt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|caddr_t
name|opts
decl_stmt|;
name|int
name|olen
decl_stmt|;
name|olen
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|opts
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ip
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mopt
condition|)
block|{
name|mopt
operator|->
name|m_len
operator|=
name|olen
expr_stmt|;
name|mopt
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|bcopy
argument_list|(
name|opts
argument_list|,
name|mtod
argument_list|(
name|mopt
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|m
operator|->
name|m_len
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|olen
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|opts
operator|+
name|olen
argument_list|,
name|opts
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|olen
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|u_char
name|inetctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|ENETUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ENOPROTOOPT
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IPFORWARDING
end_ifndef

begin_define
define|#
directive|define
name|IPFORWARDING
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IPSENDREDIRECTS
end_ifndef

begin_define
define|#
directive|define
name|IPSENDREDIRECTS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|ipprintfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipforwarding
init|=
name|IPFORWARDING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|in_interfaces
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipsendredirects
init|=
name|IPSENDREDIRECTS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward a packet.  If some error occurs return the sender  * an icmp packet.  Note we can't always generate a meaningful  * icmp message because icmp doesn't have a large enough repertoire  * of codes and types.  *  * If not forwarding (possibly because we have only a single external  * network), just drop the packet.  This could be confusing if ipforwarding  * was zero but some routing protocol was advancing us as a gateway  * to somewhere.  However, we must let the routing protocol deal with that.  */
end_comment

begin_expr_stmt
name|ip_forward
argument_list|(
name|ip
argument_list|,
name|ifp
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|error
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcopy
decl_stmt|;
name|struct
name|in_addr
name|dest
decl_stmt|;
name|dest
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"forward: src %x dst %x ttl %x\n"
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_ttl
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipforwarding
operator|==
literal|0
operator|||
name|in_interfaces
operator|<=
literal|1
condition|)
block|{
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|GATEWAY
name|type
operator|=
name|ICMP_UNREACH
operator|,
name|code
operator|=
name|ICMP_UNREACH_NET
expr_stmt|;
goto|goto
name|sendicmp
goto|;
else|#
directive|else
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
if|if
condition|(
name|in_canforward
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
name|IPTTLDEC
condition|)
block|{
name|type
operator|=
name|ICMP_TIMXCEED
operator|,
name|code
operator|=
name|ICMP_TIMXCEED_INTRANS
expr_stmt|;
goto|goto
name|sendicmp
goto|;
block|}
name|ip
operator|->
name|ip_ttl
operator|-=
name|IPTTLDEC
expr_stmt|;
comment|/* 	 * Save at most 64 bytes of the packet in case 	 * we need to generate an ICMP message to the src. 	 */
name|mcopy
operator|=
name|m_copy
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|0
argument_list|,
name|imin
argument_list|(
operator|(
name|int
operator|)
name|ip
operator|->
name|ip_len
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ipforward_rt
operator|.
name|ro_dst
expr_stmt|;
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|==
literal|0
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ipforward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ipforward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|ipforward_rt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If forwarding packet using same interface that it came in on, 	 * perhaps should send a redirect to sender to shortcut a hop. 	 * Only send redirect if source is sending directly to us, 	 * and if packet was not source routed (or has any options). 	 * Also, don't send redirect if forwarding using a default route 	 * or a route modfied by a redirect. 	 */
define|#
directive|define
name|satosin
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|&&
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|==
name|ifp
operator|&&
operator|(
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
operator|)
operator|==
literal|0
operator|&&
name|satosin
argument_list|(
operator|&
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_dst
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
name|ipsendredirects
operator|&&
name|ip
operator|->
name|ip_hl
operator|==
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
operator|)
condition|)
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|u_long
name|src
init|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
decl_stmt|;
name|u_long
name|dst
init|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ia
operator|=
name|ifptoia
argument_list|(
name|ifp
argument_list|)
operator|)
operator|&&
operator|(
name|src
operator|&
name|ia
operator|->
name|ia_subnetmask
operator|)
operator|==
name|ia
operator|->
name|ia_subnet
condition|)
block|{
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|dest
operator|=
name|satosin
argument_list|(
operator|&
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_gateway
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
else|else
name|dest
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
comment|/* 		     * If the destination is reached by a route to host, 		     * is on a subnet of a local net, or is directly 		     * on the attached net (!), use host redirect. 		     * (We may be the correct first hop for other subnets.) 		     */
name|type
operator|=
name|ICMP_REDIRECT
expr_stmt|;
name|code
operator|=
name|ICMP_REDIRECT_NET
expr_stmt|;
if|if
condition|(
operator|(
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
operator|)
operator|||
operator|(
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|==
literal|0
condition|)
name|code
operator|=
name|ICMP_REDIRECT_HOST
expr_stmt|;
else|else
for|for
control|(
name|ia
operator|=
name|in_ifaddr
init|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
condition|;
control|)
if|if
condition|(
operator|(
name|dst
operator|&
name|ia
operator|->
name|ia_netmask
operator|)
operator|==
name|ia
operator|->
name|ia_net
condition|)
block|{
if|if
condition|(
name|ia
operator|->
name|ia_subnetmask
operator|!=
name|ia
operator|->
name|ia_netmask
condition|)
name|code
operator|=
name|ICMP_REDIRECT_HOST
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"redirect (%d) to %x\n"
argument_list|,
name|code
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|ip_output
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ipforward_rt
argument_list|,
name|IP_FORWARDING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|type
condition|)
name|ipstat
operator|.
name|ips_redirectsent
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mcopy
condition|)
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
name|ipstat
operator|.
name|ips_forward
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mcopy
operator|==
name|NULL
condition|)
return|return;
name|ip
operator|=
name|mtod
argument_list|(
name|mcopy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* forwarded, but need redirect */
name|type
operator|=
name|ICMP_REDIRECT
expr_stmt|;
comment|/* code set above */
break|break;
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
if|if
condition|(
name|in_localaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
condition|)
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
else|else
name|code
operator|=
name|ICMP_UNREACH_NET
expr_stmt|;
break|break;
case|case
name|EMSGSIZE
case|:
name|code
operator|=
name|ICMP_UNREACH_NEEDFRAG
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|code
operator|=
name|ICMP_UNREACH_PORT
expr_stmt|;
break|break;
case|case
name|ENOBUFS
case|:
name|type
operator|=
name|ICMP_SOURCEQUENCH
expr_stmt|;
break|break;
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
break|break;
block|}
name|sendicmp
label|:
name|icmp_error
argument_list|(
name|ip
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|ifp
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

