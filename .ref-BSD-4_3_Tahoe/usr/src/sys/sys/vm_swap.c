begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)vm_swap.c	7.2 (Berkeley) 11/3/86  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"../machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_comment
comment|/*  * Swap a process in.  */
end_comment

begin_expr_stmt
name|swapin
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|xp
operator|=
name|p
operator|->
name|p_textp
condition|)
name|xlock
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_szpt
operator|=
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_ssize
operator|+
name|p
operator|->
name|p_dsize
operator|+
name|p
operator|->
name|p_tsize
operator|+
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vgetpt
argument_list|(
name|p
argument_list|,
name|memall
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|vgetu
argument_list|(
name|p
argument_list|,
name|memall
argument_list|,
name|Swapmap
argument_list|,
operator|&
name|swaputl
argument_list|,
operator|(
expr|struct
name|user
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vrelpt
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|+
name|i
operator|*
name|NBPG
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swdspt
argument_list|(
name|p
argument_list|,
operator|&
name|swaputl
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure swdspt didn't smash u. pte's 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Swapmap
index|[
name|i
index|]
operator|.
name|pg_pfnum
operator|!=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
operator|.
name|pg_pfnum
condition|)
name|panic
argument_list|(
literal|"swapin"
argument_list|)
expr_stmt|;
block|}
name|vrelswu
argument_list|(
name|p
argument_list|,
operator|&
name|swaputl
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
condition|)
block|{
name|xlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|xunlock
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_rssize
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SRUN
condition|)
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|SLOAD
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SSWAP
condition|)
block|{
name|swaputl
operator|.
name|u_pcb
operator|.
name|pcb_sswap
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|u
operator|.
name|u_ssave
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SSWAP
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_time
operator|=
literal|0
expr_stmt|;
name|multprog
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_swpin
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|nomem
label|:
if|if
condition|(
name|xp
condition|)
name|xunlock
argument_list|(
name|xp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|xswapwant
decl_stmt|,
name|xswaplock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Swap out process p.  * ds and ss are the old data size and the stack size  * of the process, and are supplied during page table  * expansion swaps.  */
end_comment

begin_expr_stmt
name|swapout
argument_list|(
name|p
argument_list|,
name|ds
argument_list|,
name|ss
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|ds
decl_stmt|,
name|ss
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|map
decl_stmt|;
specifier|register
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|rc
init|=
literal|1
decl_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
name|map
operator|=
name|Xswapmap
expr_stmt|;
name|utl
operator|=
operator|&
name|xswaputl
expr_stmt|;
if|if
condition|(
name|xswaplock
operator|&
name|s
condition|)
if|if
condition|(
operator|(
name|xswaplock
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|2
expr_stmt|;
name|map
operator|=
name|Xswap2map
expr_stmt|;
name|utl
operator|=
operator|&
name|xswap2utl
expr_stmt|;
block|}
while|while
condition|(
name|xswaplock
operator|&
name|s
condition|)
block|{
name|xswapwant
operator||=
name|s
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|map
argument_list|,
name|PSWP
argument_list|)
expr_stmt|;
block|}
name|xswaplock
operator||=
name|s
expr_stmt|;
name|uaccess
argument_list|(
name|p
argument_list|,
name|map
argument_list|,
name|utl
argument_list|)
expr_stmt|;
if|if
condition|(
name|vgetswu
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_flag
operator||=
name|SLOAD
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|+
name|i
operator|*
name|NBPG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|utl
operator|->
name|u_ru
operator|.
name|ru_nswap
operator|++
expr_stmt|;
name|utl
operator|->
name|u_odsize
operator|=
name|ds
expr_stmt|;
name|utl
operator|->
name|u_ossize
operator|=
name|ss
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|SLOCK
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_textp
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_textp
operator|->
name|x_ccount
operator|==
literal|1
condition|)
name|p
operator|->
name|p_textp
operator|->
name|x_swrss
operator|=
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
expr_stmt|;
name|xdetach
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_swrss
operator|=
name|p
operator|->
name|p_rssize
expr_stmt|;
name|vsswap
argument_list|(
name|p
argument_list|,
name|dptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|CDATA
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|ds
argument_list|,
operator|&
name|utl
operator|->
name|u_dmap
argument_list|)
expr_stmt|;
name|vsswap
argument_list|(
name|p
argument_list|,
name|sptopte
argument_list|(
name|p
argument_list|,
name|CLSIZE
operator|-
literal|1
argument_list|)
argument_list|,
name|CSTACK
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|ss
argument_list|,
operator|&
name|utl
operator|->
name|u_smap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_rssize
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"swapout rssize"
argument_list|)
expr_stmt|;
name|swdspt
argument_list|(
name|p
argument_list|,
name|utl
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * If freeing the user structure and kernel stack 	 * for the current process, have to run a bit longer 	 * using the pages which are about to be freed... 	 * vrelu will then block memory allocation by raising ipl. 	 */
name|vrelu
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_stat
operator|!=
name|SRUN
operator|||
name|p
operator|!=
name|u
operator|.
name|u_procp
operator|)
condition|)
name|panic
argument_list|(
literal|"swapout"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SLOAD
expr_stmt|;
name|vrelpt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SLOCK
expr_stmt|;
name|p
operator|->
name|p_time
operator|=
literal|0
expr_stmt|;
name|multprog
operator|--
expr_stmt|;
name|cnt
operator|.
name|v_swpout
operator|++
expr_stmt|;
if|if
condition|(
name|runout
condition|)
block|{
name|runout
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|runout
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|xswaplock
operator|&=
operator|~
name|s
expr_stmt|;
if|if
condition|(
name|xswapwant
operator|&
name|s
condition|)
block|{
name|xswapwant
operator|&=
operator|~
name|s
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|map
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Swap the data and stack page tables in or out.  * Only hard thing is swapping out when new pt size is different than old.  * If we are growing new pt pages, then we must spread pages with 2 swaps.  * If we are shrinking pt pages, then we must merge stack pte's into last  * data page so as not to lose them (and also do two swaps).  */
end_comment

begin_expr_stmt
name|swdspt
argument_list|(
name|p
argument_list|,
name|utl
argument_list|,
name|rdwri
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|szpt
decl_stmt|,
name|tsz
decl_stmt|,
name|ssz
decl_stmt|;
name|int
name|tdlast
decl_stmt|,
name|slast
decl_stmt|,
name|tdsz
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|szpt
operator|=
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_tsize
operator|+
name|p
operator|->
name|p_dsize
operator|+
name|p
operator|->
name|p_ssize
operator|+
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
name|tsz
operator|=
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
expr_stmt|;
if|if
condition|(
name|szpt
operator|==
name|p
operator|->
name|p_szpt
condition|)
block|{
name|swptstat
operator|.
name|pteasy
operator|++
expr_stmt|;
name|swpt
argument_list|(
name|rdwri
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|tsz
argument_list|,
operator|(
name|p
operator|->
name|p_szpt
operator|-
name|tsz
operator|)
operator|*
name|NBPG
operator|-
name|UPAGES
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|check
goto|;
block|}
if|if
condition|(
name|szpt
operator|<
name|p
operator|->
name|p_szpt
condition|)
name|swptstat
operator|.
name|ptshrink
operator|++
expr_stmt|;
else|else
name|swptstat
operator|.
name|ptexpand
operator|++
expr_stmt|;
name|ssz
operator|=
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|utl
operator|->
name|u_ossize
operator|+
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|szpt
operator|<
name|p
operator|->
name|p_szpt
operator|&&
name|utl
operator|->
name|u_odsize
operator|&&
operator|(
name|utl
operator|->
name|u_ossize
operator|+
name|UPAGES
operator|)
condition|)
block|{
comment|/* 		 * Page tables shrinking... see if last text+data and 		 * last stack page must be merged... if so, copy 		 * stack pte's from last stack page to end of last 		 * data page, and decrease size of stack pt to be swapped. 		 */
name|tdlast
operator|=
operator|(
name|p
operator|->
name|p_tsize
operator|+
name|utl
operator|->
name|u_odsize
operator|)
operator|%
operator|(
name|NPTEPG
operator|*
name|CLSIZE
operator|)
expr_stmt|;
name|slast
operator|=
operator|(
name|utl
operator|->
name|u_ossize
operator|+
name|UPAGES
operator|)
operator|%
operator|(
name|NPTEPG
operator|*
name|CLSIZE
operator|)
expr_stmt|;
if|if
condition|(
name|tdlast
operator|&&
name|slast
operator|&&
name|tdlast
operator|+
name|slast
operator|<=
operator|(
name|NPTEPG
operator|*
name|CLSIZE
operator|)
condition|)
block|{
name|swptstat
operator|.
name|ptpack
operator|++
expr_stmt|;
name|tdsz
operator|=
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_tsize
operator|+
name|utl
operator|->
name|u_odsize
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sptopte
argument_list|(
name|p
argument_list|,
name|utl
operator|->
name|u_ossize
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|p_p0br
index|[
name|tdsz
operator|*
name|NPTEPG
operator|-
name|slast
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|slast
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ssz
operator|-=
name|CLSIZE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ssz
condition|)
name|swpt
argument_list|(
name|rdwri
argument_list|,
name|p
argument_list|,
name|szpt
operator|-
name|ssz
operator|-
name|tsz
argument_list|,
name|p
operator|->
name|p_szpt
operator|-
name|ssz
argument_list|,
name|ssz
operator|*
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
name|utl
operator|->
name|u_odsize
condition|)
name|swpt
argument_list|(
name|rdwri
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|tsz
argument_list|,
call|(
name|int
call|)
argument_list|(
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_tsize
operator|+
name|utl
operator|->
name|u_odsize
argument_list|)
argument_list|)
operator|-
name|tsz
argument_list|)
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|check
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|utl
operator|->
name|u_odsize
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|dptopte
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|uncache
argument_list|(
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MMAP
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|&&
name|pte
operator|->
name|pg_fod
condition|)
comment|/* mapped page */
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|||
name|pte
operator|->
name|pg_fod
operator|==
literal|0
operator|&&
operator|(
name|pte
operator|->
name|pg_pfnum
operator|||
name|pte
operator|->
name|pg_m
operator|)
condition|)
name|panic
argument_list|(
literal|"swdspt"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|utl
operator|->
name|u_ossize
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|sptopte
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|uncache
argument_list|(
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MMAP
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|&&
name|pte
operator|->
name|pg_fod
condition|)
comment|/* mapped page */
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|||
name|pte
operator|->
name|pg_fod
operator|==
literal|0
operator|&&
operator|(
name|pte
operator|->
name|pg_pfnum
operator|||
name|pte
operator|->
name|pg_m
operator|)
condition|)
name|panic
argument_list|(
literal|"swdspt"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Swap a section of the page tables.  * Errors are handled at a lower level (by doing a panic).  */
end_comment

begin_macro
name|swpt
argument_list|(
argument|rdwri
argument_list|,
argument|p
argument_list|,
argument|doff
argument_list|,
argument|a
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rdwri
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doff
decl_stmt|,
name|a
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|swap
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_swaddr
operator|+
name|ctod
argument_list|(
name|UPAGES
argument_list|)
operator|+
name|ctod
argument_list|(
name|doff
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|p_p0br
index|[
name|a
operator|*
name|NPTEPG
index|]
argument_list|,
name|n
argument_list|,
name|rdwri
argument_list|,
name|B_PAGET
argument_list|,
name|swapdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

