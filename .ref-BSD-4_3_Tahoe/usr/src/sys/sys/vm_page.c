begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)vm_page.c	7.7 (Berkeley) 8/23/87  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"trace.h"
end_include

begin_include
include|#
directive|include
file|"../machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../machine/reg.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_define
define|#
directive|define
name|REFBIT
end_define

begin_if
if|#
directive|if
name|CLSIZE
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|uncachecl
parameter_list|(
name|pte
parameter_list|)
value|uncache(pte)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CLSIZE
operator|==
literal|2
end_if

begin_define
define|#
directive|define
name|uncachecl
parameter_list|(
name|pte
parameter_list|)
value|uncache(pte), uncache((pte)+1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CLSIZE
operator|>
literal|2
end_if

begin_define
define|#
directive|define
name|uncachecl
parameter_list|(
name|pte
parameter_list|)
value|{ \ 	register ii; \ 	for (ii = 0; ii< CLSIZE; ii++) \ 		uncache((pte) + ii); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
else|tahoe
end_else

begin_define
define|#
directive|define
name|uncachecl
parameter_list|(
name|pte
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nohash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle a page fault.  *  * Basic outline  *	If page is allocated, but just not valid:  *		Wait if intransit, else just revalidate  *		Done  *	Compute<dev,bn> from which page operation would take place  *	If page is text page, and filling from file system or swap space:  *		If in free list cache, reattach it and then done  *	Allocate memory for page in  *		If block here, restart because we could have swapped, etc.  *	Lock process from swapping for duration  *	Update pte's to reflect that page is intransit.  *	If page is zero fill on demand:  *		Clear pages and flush free list cache of stale cacheing  *		for this swap page (e.g. before initializing again due  *		to 407/410 exec).  *	If page is fill from file and in buffer cache:  *		Copy the page from the buffer cache.  *	If not a fill on demand:  *		Determine swap address and cluster to page in  *	Do the swap to bring the page in  *	Instrument the pagein  *	After swap validate the required new page  *	Leave prepaged pages reclaimable (not valid)  *	Update shared copies of text page tables  *	Complete bookkeeping on pages brought in:  *		No longer intransit  *		Hash text pages into core hash structure  *		Unlock pages (modulo raw i/o requirements)  *		Flush translation buffer  *	Process pagein is done  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|pgtrace
parameter_list|(
name|e
parameter_list|)
value|trace(e,v,u.u_procp->p_pid)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|pgtrace
parameter_list|(
name|e
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|preptofree
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send pre-paged pages to free list */
end_comment

begin_macro
name|pagein
argument_list|(
argument|virtaddr
argument_list|,
argument|dlyu
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|virtaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dlyu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
name|v
decl_stmt|;
name|unsigned
name|pf
decl_stmt|;
name|int
name|type
decl_stmt|,
name|fileno
decl_stmt|;
name|struct
name|pte
name|opte
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|klsize
decl_stmt|;
name|unsigned
name|vsave
decl_stmt|;
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|,
name|bncache
decl_stmt|,
name|bnswap
decl_stmt|;
name|int
name|si
decl_stmt|,
name|sk
decl_stmt|;
name|int
name|swerror
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PGINPROF
name|int
name|otime
decl_stmt|,
name|olbolt
decl_stmt|,
name|oicr
decl_stmt|,
name|s
decl_stmt|;
name|long
name|a
decl_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|otime
operator|=
name|time
operator|,
name|olbolt
operator|=
name|lbolt
operator|,
name|oicr
operator|=
name|mfpr
argument_list|(
name|ICR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_faults
operator|++
expr_stmt|;
comment|/* 	 * Classify faulted page into a segment and get a pte 	 * for the faulted page. 	 */
name|vsave
operator|=
name|v
operator|=
name|clbase
argument_list|(
name|btop
argument_list|(
name|virtaddr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
if|if
condition|(
name|isatsv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
name|type
operator|=
name|CTEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|isassv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
name|type
operator|=
name|CSTACK
expr_stmt|;
else|else
name|type
operator|=
name|CDATA
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|panic
argument_list|(
literal|"pagein"
argument_list|)
expr_stmt|;
comment|/* 	 * If page is reclaimable, reclaim it. 	 * If page is text and intransit, sleep while it is intransit, 	 * If it is valid after the sleep, we are done. 	 * Otherwise we have to start checking again, since page could 	 * even be reclaimable now (we may have swapped for a long time). 	 */
name|restart
label|:
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|==
literal|0
operator|&&
name|pte
operator|->
name|pg_pfnum
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|CTEXT
operator|&&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
condition|)
block|{
name|pgtrace
argument_list|(
name|TR_INTRANS
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_textp
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pgtrace
argument_list|(
name|TR_EINTRANS
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
block|{
name|valid
label|:
if|if
condition|(
name|dlyu
condition|)
block|{
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
condition|)
block|{
name|c
operator|->
name|c_want
operator|=
literal|1
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|c
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|c
operator|->
name|c_lock
operator|=
literal|1
expr_stmt|;
block|}
name|newptes
argument_list|(
name|pte
argument_list|,
name|v
argument_list|,
name|CLSIZE
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_intrans
operator|++
expr_stmt|;
return|return;
block|}
goto|goto
name|restart
goto|;
block|}
comment|/* 		 * If page is in the free list, then take 		 * it back into the resident set, updating 		 * the size recorded for the resident set. 		 */
name|si
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_free
condition|)
block|{
name|pgtrace
argument_list|(
name|TR_FRECLAIM
argument_list|)
expr_stmt|;
name|munlink
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_pgfrec
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
else|else
name|p
operator|->
name|p_rssize
operator|+=
name|CLSIZE
expr_stmt|;
block|}
else|else
name|pgtrace
argument_list|(
name|TR_RECLAIM
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|uncachecl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_m
argument_list|)
condition|)
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_ru
operator|.
name|ru_minflt
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_pgrec
operator|++
expr_stmt|;
if|if
condition|(
name|dlyu
condition|)
block|{
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
condition|)
block|{
name|c
operator|->
name|c_want
operator|=
literal|1
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|c
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|c
operator|->
name|c_lock
operator|=
literal|1
expr_stmt|;
block|}
name|newptes
argument_list|(
name|pte
argument_list|,
name|v
argument_list|,
name|CLSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PGINPROF
name|a
operator|=
name|vmtime
argument_list|(
name|otime
argument_list|,
name|olbolt
argument_list|,
name|oicr
argument_list|)
expr_stmt|;
name|rectime
operator|+=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
name|vmfltmon
argument_list|(
name|rmon
argument_list|,
name|a
argument_list|,
name|rmonmin
argument_list|,
name|rres
argument_list|,
name|NRMON
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|PGINPROF
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *<dev,bn> is where data comes from/goes to. 	 *<dev,bncache> is where data is cached from/to. 	 *<swapdev,bnswap> is where data will eventually go. 	 */
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|==
literal|0
condition|)
block|{
name|fileno
operator|=
operator|-
literal|1
expr_stmt|;
name|bnswap
operator|=
name|bncache
operator|=
name|bn
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
name|dev
operator|=
name|swapdev
expr_stmt|;
block|}
else|else
block|{
name|fileno
operator|=
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_fileno
expr_stmt|;
name|bn
operator|=
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_blkno
expr_stmt|;
name|bnswap
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
operator|==
name|PG_FTEXT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_textp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pagein PG_FTEXT"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|p
operator|->
name|p_textp
operator|->
name|x_iptr
operator|->
name|i_dev
expr_stmt|;
name|bncache
operator|=
name|bn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileno
operator|==
name|PG_FZERO
condition|)
block|{
name|dev
operator|=
name|swapdev
expr_stmt|;
name|bncache
operator|=
name|bnswap
expr_stmt|;
block|}
block|}
name|klsize
operator|=
literal|1
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
comment|/* 	 * Check for text detached but in free list. 	 * This can happen only if the page is filling 	 * from a inode or from the swap device, (e.g. not when reading 	 * in 407/410 execs to a zero fill page.) 	 * Honor lock bit to avoid races with pageouts. 	 */
if|if
condition|(
name|type
operator|==
name|CTEXT
operator|&&
name|fileno
operator|!=
name|PG_FZERO
operator|&&
operator|!
name|nohash
condition|)
block|{
name|si
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|mfind
argument_list|(
name|dev
argument_list|,
name|bncache
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_lock
operator|==
literal|0
condition|)
break|break;
name|MLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|MUNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_type
operator|!=
name|CTEXT
operator|||
name|c
operator|->
name|c_gone
operator|==
literal|0
operator|||
name|c
operator|->
name|c_free
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pagein mfind"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
comment|/* 			 * Following code mimics memall(). 			 */
name|munlink
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pf
operator|=
name|cmtopg
argument_list|(
name|c
operator|-
name|cmap
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|pf
operator|++
expr_stmt|;
name|pte
operator|->
name|pg_prot
operator|=
name|opte
operator|.
name|pg_prot
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
name|pte
operator|-=
name|CLSIZE
expr_stmt|;
name|c
operator|->
name|c_free
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|c_gone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_intrans
operator|||
name|c
operator|->
name|c_want
condition|)
name|panic
argument_list|(
literal|"pagein intrans|want"
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_page
operator|!=
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pagein c_page chgd"
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_textp
operator|-
operator|&
name|text
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|swapdev
condition|)
block|{
name|cnt
operator|.
name|v_xsfrec
operator|++
expr_stmt|;
name|pgtrace
argument_list|(
name|TR_XSFREC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|.
name|v_xifrec
operator|++
expr_stmt|;
name|pgtrace
argument_list|(
name|TR_XIFREC
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|.
name|v_pgrec
operator|++
expr_stmt|;
name|u
operator|.
name|u_ru
operator|.
name|ru_minflt
operator|++
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|swapdev
condition|)
block|{
name|munhash
argument_list|(
name|swapdev
argument_list|,
name|bnswap
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|si
argument_list|)
expr_stmt|;
goto|goto
name|skipswap
goto|;
block|}
name|splx
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wasn't reclaimable or reattachable. 	 * Have to prepare to bring the page in. 	 * We allocate the page before locking so we will 	 * be swappable if there is no free memory. 	 * If we block we have to start over, since anything 	 * could have happened. 	 */
name|sk
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* lock memalls from here into kluster */
if|if
condition|(
name|freemem
operator|<
name|CLSIZE
operator|*
name|KLMAX
condition|)
block|{
name|pgtrace
argument_list|(
name|TR_WAITMEM
argument_list|)
expr_stmt|;
while|while
condition|(
name|freemem
operator|<
name|CLSIZE
operator|*
name|KLMAX
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|freemem
argument_list|,
name|PSWP
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pgtrace
argument_list|(
name|TR_EWAITMEM
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|sk
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
goto|goto
name|valid
goto|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Now can get memory and committed to bringing in the page. 	 * Lock this process, get a page, 	 * construct the new pte, and increment 	 * the (process or text) resident set size. 	 */
name|p
operator|->
name|p_flag
operator||=
name|SPAGE
expr_stmt|;
if|if
condition|(
name|memall
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pagein memall"
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_prot
operator|=
name|opte
operator|.
name|pg_prot
expr_stmt|;
name|pf
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_intrans
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
block|{
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|p_rssize
operator|+=
name|CLSIZE
expr_stmt|;
comment|/* 	 * Two cases: either fill on demand (zero, or from file or text) 	 * or from swap space. 	 */
if|if
condition|(
name|opte
operator|.
name|pg_fod
condition|)
block|{
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fileno
operator|==
name|PG_FZERO
operator|||
name|fileno
operator|==
name|PG_FTEXT
condition|)
block|{
comment|/* 			 * Flush any previous text page use of this 			 * swap device block. 			 */
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
name|munhash
argument_list|(
name|swapdev
argument_list|,
name|bnswap
argument_list|)
expr_stmt|;
comment|/* 			 * If zero fill, short-circuit hard work 			 * by just clearing pages. 			 */
if|if
condition|(
name|fileno
operator|==
name|PG_FZERO
condition|)
block|{
name|pgtrace
argument_list|(
name|TR_ZFOD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLSIZE
condition|;
name|i
operator|++
control|)
block|{
name|clearseg
argument_list|(
name|pf
operator|+
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
operator|(
name|int
operator|)
name|virtaddr
operator|+
name|i
operator|*
name|NBPG
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|type
operator|!=
name|CTEXT
condition|)
name|cnt
operator|.
name|v_zfod
operator|+=
name|CLSIZE
expr_stmt|;
name|splx
argument_list|(
name|sk
argument_list|)
expr_stmt|;
goto|goto
name|skipswap
goto|;
block|}
name|pgtrace
argument_list|(
name|TR_EXFOD
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_exfod
operator|+=
name|CLSIZE
expr_stmt|;
block|}
comment|/* 		 * Fill from inode.  Try to find adjacent 		 * pages to bring in also. 		 */
name|v
operator|=
name|fodkluster
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
name|pte
argument_list|,
operator|&
name|klsize
argument_list|,
name|dev
argument_list|,
operator|&
name|bn
argument_list|)
expr_stmt|;
name|bncache
operator|=
name|bn
expr_stmt|;
name|splx
argument_list|(
name|sk
argument_list|)
expr_stmt|;
comment|/* 		 * Blocks of an executable may still be in the buffer 		 * cache, so we explicitly flush them out to disk 		 * so that the proper data will be paged in. 		 */
name|blkflush
argument_list|(
name|dev
argument_list|,
name|bn
argument_list|,
operator|(
name|long
operator|)
name|klsize
operator|*
name|CLSIZE
operator|*
name|NBPG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|type
operator|!=
name|CTEXT
condition|)
name|trace
argument_list|(
name|TR_XFODMISS
argument_list|,
name|dev
argument_list|,
name|bn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|opte
operator|.
name|pg_pfnum
condition|)
name|panic
argument_list|(
literal|"pagein pfnum"
argument_list|)
expr_stmt|;
name|pgtrace
argument_list|(
name|TR_SWAPIN
argument_list|)
expr_stmt|;
comment|/* 		 * Fill from swap area.  Try to find adjacent 		 * pages to bring in also. 		 */
name|v
operator|=
name|kluster
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
name|pte
argument_list|,
name|B_READ
argument_list|,
operator|&
name|klsize
argument_list|,
operator|(
name|type
operator|==
name|CTEXT
operator|)
condition|?
name|kltxt
else|:
operator|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SSEQL
operator|)
condition|?
name|klseql
else|:
name|klin
operator|)
argument_list|,
name|bn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|sk
argument_list|)
expr_stmt|;
comment|/* THIS COULD BE COMPUTED INCREMENTALLY... */
name|bncache
operator|=
name|bn
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
block|}
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|swerror
operator|=
name|swap
argument_list|(
name|p
argument_list|,
name|bn
argument_list|,
name|ptob
argument_list|(
name|v
argument_list|)
argument_list|,
name|klsize
operator|*
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_PGIN
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|trace
argument_list|(
name|TR_PGINDONE
argument_list|,
name|vsave
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Instrumentation. 	 */
name|u
operator|.
name|u_ru
operator|.
name|ru_majflt
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_pgin
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_pgpgin
operator|+=
name|klsize
operator|*
name|CLSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|PGINPROF
name|a
operator|=
name|vmtime
argument_list|(
name|otime
argument_list|,
name|olbolt
argument_list|,
name|oicr
argument_list|)
operator|/
literal|100
expr_stmt|;
name|pgintime
operator|+=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
name|vmfltmon
argument_list|(
name|pmon
argument_list|,
name|a
argument_list|,
name|pmonmin
argument_list|,
name|pres
argument_list|,
name|NPMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|skipswap
label|:
comment|/* 	 * Fix page table entries. 	 * 	 * Only page requested in is validated, and rest of pages 	 * can be ``reclaimed''.  This allows system to reclaim prepaged pages 	 * quickly if they are not used and memory is tight. 	 */
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|vsave
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|REFBIT
comment|/* 	 * Start with the page used so that pageout doesn't free it  	 * immediately. 	 */
name|pte
operator|->
name|pg_u
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
block|{
if|if
condition|(
name|swerror
operator|==
literal|0
condition|)
block|{
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|vsave
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|opte
operator|.
name|pg_fod
condition|)
name|p
operator|->
name|p_textp
operator|->
name|x_flag
operator||=
name|XWRIT
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_textp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Memall returned page(s) locked.  Unlock all 	 * pages in cluster.  If locking pages for raw i/o 	 * leave the page which was required to be paged in locked, 	 * but still unlock others. 	 * If text pages, hash into the cmap situation table. 	 */
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klsize
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
name|c
operator|->
name|c_intrans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
operator|&&
name|c
operator|->
name|c_blkno
operator|==
literal|0
operator|&&
name|bncache
operator|&&
operator|!
name|nohash
operator|&&
operator|!
name|swerror
condition|)
block|{
name|mhash
argument_list|(
name|c
argument_list|,
name|dev
argument_list|,
name|bncache
argument_list|)
expr_stmt|;
name|bncache
operator|+=
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
name|vsave
operator|||
operator|!
name|dlyu
condition|)
name|MUNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|vsave
operator|&&
name|type
operator|!=
name|CTEXT
operator|&&
name|preptofree
operator|&&
name|opte
operator|.
name|pg_fod
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Throw pre-paged data/stack pages at the 			 * bottom of the free list; leave pg_u clear. 			 */
name|p
operator|->
name|p_rssize
operator|-=
name|CLSIZE
expr_stmt|;
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFBIT
comment|/* 		 * Text pages paged-in and allocated during the kluster 		 * must be validated, as they are now in the resident set. 		 */
if|if
condition|(
name|v
operator|!=
name|vsave
operator|&&
name|type
operator|==
name|CTEXT
condition|)
block|{
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|newptes
argument_list|(
name|pte
argument_list|,
name|v
argument_list|,
name|CLSIZE
argument_list|)
expr_stmt|;
name|v
operator|+=
name|CLSIZE
expr_stmt|;
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
block|}
comment|/* 	 * All done. 	 */
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SPAGE
expr_stmt|;
comment|/* 	 * If process is declared fifo, memory is tight, 	 * and this was a data page-in, free memory 	 * klsdist pagein clusters away from the current fault. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SSEQL
operator|)
operator|&&
name|freemem
operator|<
name|lotsfree
operator|&&
name|type
operator|==
name|CDATA
condition|)
block|{
name|int
name|k
init|=
operator|(
name|vtodp
argument_list|(
name|p
argument_list|,
name|vsave
argument_list|)
operator|/
name|CLSIZE
operator|)
operator|/
name|klseql
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|vsave
operator|>
name|u
operator|.
name|u_vsave
condition|)
name|k
operator|-=
name|klsdist
expr_stmt|;
else|else
name|k
operator|+=
name|klsdist
expr_stmt|;
name|dpageout
argument_list|(
name|p
argument_list|,
name|k
operator|*
name|klseql
operator|*
name|CLSIZE
argument_list|,
name|klout
operator|*
name|CLSIZE
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_vsave
operator|=
name|vsave
expr_stmt|;
else|#
directive|else
name|dpageout
argument_list|(
name|p
argument_list|,
operator|(
name|k
operator|-
name|klsdist
operator|)
operator|*
name|klseql
operator|*
name|CLSIZE
argument_list|,
name|klout
operator|*
name|CLSIZE
argument_list|)
expr_stmt|;
name|dpageout
argument_list|(
name|p
argument_list|,
operator|(
name|k
operator|+
name|klsdist
operator|)
operator|*
name|klseql
operator|*
name|CLSIZE
argument_list|,
name|klout
operator|*
name|CLSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * Take away n pages of data space  * starting at data page dp.  * Used to take pages away from sequential processes.  * Mimics pieces of code in pageout() below.  */
end_comment

begin_macro
name|dpageout
argument_list|(
argument|p
argument_list|,
argument|dp
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dp
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|klsize
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|unsigned
name|v
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
if|if
condition|(
name|dp
operator|<
literal|0
condition|)
block|{
name|n
operator|+=
name|dp
expr_stmt|;
name|dp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|+
name|n
operator|>
name|p
operator|->
name|p_dsize
condition|)
name|n
operator|=
name|p
operator|->
name|p_dsize
operator|-
name|dp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
name|CLSIZE
operator|,
name|dp
operator|+=
name|CLSIZE
control|)
block|{
name|pte
operator|=
name|dptopte
argument_list|(
name|p
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|||
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
continue|continue;
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
operator|||
name|c
operator|->
name|c_free
condition|)
continue|continue;
name|uncachecl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
block|{
name|pte
operator|->
name|pg_v
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_m
argument_list|)
condition|)
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirtycl
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|bswlist
operator|.
name|av_forw
operator|==
name|NULL
condition|)
continue|continue;
name|MLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_m
operator|=
literal|0
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_poip
operator|++
expr_stmt|;
name|v
operator|=
name|kluster
argument_list|(
name|p
argument_list|,
name|dptov
argument_list|(
name|p
argument_list|,
name|dp
argument_list|)
argument_list|,
name|pte
argument_list|,
name|B_WRITE
argument_list|,
operator|&
name|klsize
argument_list|,
name|klout
argument_list|,
operator|(
name|daddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* THIS ASSUMES THAT p == u.u_procp */
name|daddr
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|swap
argument_list|(
name|p
argument_list|,
name|daddr
argument_list|,
name|ptob
argument_list|(
name|v
argument_list|)
argument_list|,
name|klsize
operator|*
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|B_WRITE
argument_list|,
name|B_DIRTY
argument_list|,
name|swapdev
argument_list|,
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|c_gone
operator|==
literal|0
condition|)
name|p
operator|->
name|p_rssize
operator|-=
name|CLSIZE
expr_stmt|;
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_seqfree
operator|+=
name|CLSIZE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|unsigned
name|maxdmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|maxtsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Setup the paging constants for the clock algorithm.  * Called after the system is initialized and the amount of memory  * and number of paging devices is known.  *  * Threshold constants are defined in ../machine/vmparam.h.  */
end_comment

begin_macro
name|vminit
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 * Lotsfree is threshold where paging daemon turns on. 	 */
if|if
condition|(
name|lotsfree
operator|==
literal|0
condition|)
block|{
name|lotsfree
operator|=
name|LOTSFREE
operator|/
name|NBPG
expr_stmt|;
if|if
condition|(
name|lotsfree
operator|>
name|LOOPPAGES
operator|/
name|LOTSFREEFRACT
condition|)
name|lotsfree
operator|=
name|LOOPPAGES
operator|/
name|LOTSFREEFRACT
expr_stmt|;
block|}
comment|/* 	 * Desfree is amount of memory desired free. 	 * If less than this for extended period, do swapping. 	 */
if|if
condition|(
name|desfree
operator|==
literal|0
condition|)
block|{
name|desfree
operator|=
name|DESFREE
operator|/
name|NBPG
expr_stmt|;
if|if
condition|(
name|desfree
operator|>
name|LOOPPAGES
operator|/
name|DESFREEFRACT
condition|)
name|desfree
operator|=
name|LOOPPAGES
operator|/
name|DESFREEFRACT
expr_stmt|;
block|}
comment|/* 	 * Minfree is minimal amount of free memory which is tolerable. 	 */
if|if
condition|(
name|minfree
operator|==
literal|0
condition|)
block|{
name|minfree
operator|=
name|MINFREE
operator|/
name|NBPG
expr_stmt|;
if|if
condition|(
name|minfree
operator|>
name|desfree
operator|/
name|MINFREEFRACT
condition|)
name|minfree
operator|=
name|desfree
operator|/
name|MINFREEFRACT
expr_stmt|;
block|}
comment|/* 	 * Maxpgio thresholds how much paging is acceptable. 	 * This figures that 2/3 busy on an arm is all that is 	 * tolerable for paging.  We assume one operation per disk rev. 	 */
if|if
condition|(
name|maxpgio
operator|==
literal|0
condition|)
name|maxpgio
operator|=
operator|(
name|DISKRPM
operator|*
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
comment|/* 	 * Clock to scan using max of ~~10% of processor time for sampling, 	 *     this estimated to allow maximum of 200 samples per second. 	 * This yields a ``fastscan'' of roughly (with CLSIZE=2): 	 *<=1m	2m	3m	4m	8m 	 * 	5s	10s	15s	20s	40s 	 */
if|if
condition|(
name|fastscan
operator|==
literal|0
condition|)
name|fastscan
operator|=
literal|200
expr_stmt|;
if|if
condition|(
name|fastscan
operator|>
name|LOOPPAGES
operator|/
literal|5
condition|)
name|fastscan
operator|=
name|LOOPPAGES
operator|/
literal|5
expr_stmt|;
comment|/* 	 * Set slow scan time to 1/2 the fast scan time. 	 */
if|if
condition|(
name|slowscan
operator|==
literal|0
condition|)
name|slowscan
operator|=
name|fastscan
operator|/
literal|2
expr_stmt|;
comment|/* 	 * Calculate the swap allocation constants. 	 */
if|if
condition|(
name|dmmin
operator|==
literal|0
condition|)
name|dmmin
operator|=
name|DMMIN
expr_stmt|;
if|if
condition|(
name|dmmax
operator|==
literal|0
condition|)
block|{
name|dmmax
operator|=
name|DMMAX
expr_stmt|;
while|while
condition|(
name|dmapsize
argument_list|(
name|dmmin
argument_list|,
name|dmmax
operator|/
literal|2
argument_list|)
operator|>=
name|MAXDSIZ
operator|&&
name|dmmax
operator|>
name|dmmin
condition|)
name|dmmax
operator|/=
literal|2
expr_stmt|;
block|}
name|maxdmap
operator|=
name|dmapsize
argument_list|(
name|dmmin
argument_list|,
name|dmmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmtext
operator|==
literal|0
condition|)
name|dmtext
operator|=
name|DMTEXT
expr_stmt|;
if|if
condition|(
name|dmtext
operator|>
name|dmmax
condition|)
name|dmtext
operator|=
name|dmmax
expr_stmt|;
if|if
condition|(
name|maxtsize
operator|==
literal|0
condition|)
name|maxtsize
operator|=
name|MAXTSIZ
expr_stmt|;
if|if
condition|(
name|maxtsize
operator|>
name|dtob
argument_list|(
name|NXDAD
operator|*
name|dmtext
argument_list|)
condition|)
name|maxtsize
operator|=
name|dtob
argument_list|(
name|NXDAD
operator|*
name|dmtext
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the initial limits on process VM. 	 * Set the maximum resident set size to be all 	 * of (reasonably) available memory.  This causes 	 * any single, large process to start random page 	 * replacement once it fills memory. 	 */
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_cur
operator|=
name|DFLSSIZ
expr_stmt|;
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_STACK
index|]
operator|.
name|rlim_max
operator|=
name|MIN
argument_list|(
name|MAXSSIZ
argument_list|,
name|maxdmap
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
operator|=
name|DFLDSIZ
expr_stmt|;
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_max
operator|=
name|MIN
argument_list|(
name|MAXDSIZ
argument_list|,
name|maxdmap
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_RSS
index|]
operator|.
name|rlim_cur
operator|=
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_RSS
index|]
operator|.
name|rlim_max
operator|=
name|ctob
argument_list|(
name|LOOPPAGES
operator|-
name|desfree
argument_list|)
expr_stmt|;
name|proc
index|[
literal|0
index|]
operator|.
name|p_maxrss
operator|=
name|LOOPPAGES
operator|-
name|desfree
expr_stmt|;
block|}
end_block

begin_macro
name|dmapsize
argument_list|(
argument|dmin
argument_list|,
argument|dmax
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dmin
decl_stmt|,
name|dmax
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|blk
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|blk
operator|=
name|dmin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDMAP
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|blk
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|dmax
condition|)
name|blk
operator|*=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|dtob
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|pushes
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FRONT
value|1
end_define

begin_define
define|#
directive|define
name|BACK
value|2
end_define

begin_comment
comment|/*  * The page out daemon, which runs as process 2.  *  * As long as there are at least lotsfree pages,  * this process is not run.  When the number of free  * pages stays in the range desfree to lotsfree,  * this daemon runs through the pages in the loop  * at a rate determined in vmsched().  Pageout manages  * two hands on the clock.  The front hand moves through  * memory, clearing the valid bit (simulating a reference bit),  * and stealing pages from procs that are over maxrss.  * The back hand travels a distance behind the front hand,  * freeing the pages that have not been referenced in the time  * since the front hand passed.  If modified, they are pushed to  * swap before being freed.  */
end_comment

begin_macro
name|pageout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|maxhand
init|=
name|pgtocm
argument_list|(
name|maxfree
argument_list|)
decl_stmt|;
specifier|register
name|int
name|fronthand
decl_stmt|,
name|backhand
decl_stmt|;
comment|/* 	 * Set the two clock hands to be separated by a reasonable amount, 	 * but no more than 360 degrees apart. 	 */
name|backhand
operator|=
literal|0
operator|/
name|CLBYTES
expr_stmt|;
name|fronthand
operator|=
name|HANDSPREAD
operator|/
name|CLBYTES
expr_stmt|;
if|if
condition|(
name|fronthand
operator|>=
name|maxhand
condition|)
name|fronthand
operator|=
name|maxhand
operator|-
literal|1
expr_stmt|;
name|loop
label|:
comment|/* 	 * Before sleeping, look to see if there are any swap I/O headers 	 * in the ``cleaned'' list that correspond to dirty 	 * pages that have been pushed asynchronously. If so, 	 * empty the list by calling cleanup(). 	 * 	 * N.B.: We guarantee never to block while the cleaned list is nonempty. 	 */
operator|(
name|void
operator|)
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bclnlist
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|pushes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nscan
operator|<
name|desscan
operator|&&
name|freemem
operator|<
name|lotsfree
condition|)
block|{
comment|/* 		 * If checkpage manages to add a page to the free list, 		 * we give ourselves another couple of trips around the loop. 		 */
if|if
condition|(
name|checkpage
argument_list|(
name|fronthand
argument_list|,
name|FRONT
argument_list|)
condition|)
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|checkpage
argument_list|(
name|backhand
argument_list|,
name|BACK
argument_list|)
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|cnt
operator|.
name|v_scan
operator|++
expr_stmt|;
name|nscan
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|backhand
operator|>=
name|maxhand
condition|)
name|backhand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|fronthand
operator|>=
name|maxhand
condition|)
block|{
name|fronthand
operator|=
literal|0
expr_stmt|;
name|cnt
operator|.
name|v_rev
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
block|{
comment|/* 				 * Extremely unlikely, but we went around 				 * the loop twice and didn't get anywhere. 				 * Don't cycle, stop till the next clock tick. 				 */
goto|goto
name|loop
goto|;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * An iteration of the clock pointer (hand) around the loop.  * Look at the page at hand.  If it is a  * locked (for physical i/o e.g.), system (u., page table)  * or free, then leave it alone.  * Otherwise, if we are running the front hand,  * invalidate the page for simulation of the reference bit.  * If the proc is over maxrss, we take it.  * If running the back hand, check whether the page  * has been reclaimed.  If not, free the page,  * pushing it to disk first if necessary.  */
end_comment

begin_macro
name|checkpage
argument_list|(
argument|hand
argument_list|,
argument|whichhand
argument_list|)
end_macro

begin_decl_stmt
name|int
name|hand
decl_stmt|,
name|whichhand
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|swblk_t
name|daddr
decl_stmt|;
name|unsigned
name|v
decl_stmt|;
name|int
name|klsize
decl_stmt|;
name|top
label|:
comment|/* 	 * Find a process and text pointer for the 	 * page, and a virtual page number in either the 	 * process or the text image. 	 */
name|c
operator|=
operator|&
name|cmap
index|[
name|hand
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
operator|||
name|c
operator|->
name|c_free
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|c
operator|->
name|c_type
condition|)
block|{
case|case
name|CSYS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CTEXT
case|:
name|xp
operator|=
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
name|rp
operator|=
name|xp
operator|->
name|x_caddr
expr_stmt|;
name|v
operator|=
name|tptov
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|pte
operator|=
name|tptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDATA
case|:
case|case
name|CSTACK
case|:
name|rp
operator|=
operator|&
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|p_flag
operator|&
name|SNOVM
condition|)
name|rp
operator|=
name|rp
operator|->
name|p_xlink
expr_stmt|;
name|xp
operator|=
name|rp
operator|->
name|p_textp
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CDATA
condition|)
block|{
name|v
operator|=
name|dptov
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|pte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|sptov
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|pte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|!=
name|cmtopg
argument_list|(
name|hand
argument_list|)
condition|)
name|panic
argument_list|(
literal|"bad c_page"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFBIT
comment|/* 	 * If any processes attached to the text page have used 	 * it, then mark this one used and on the following 	 * distpte, they will all be marked used. 	 */
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
operator|&&
name|tanyu
argument_list|(
name|xp
argument_list|,
name|vtotp
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
argument_list|)
condition|)
name|pte
operator|->
name|pg_u
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If page is referenced, clear its reference bit. 	 * If page is not referenced, clear valid bit 	 * and add it to the free list. 	 */
name|uncachecl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_u
argument_list|)
condition|)
else|#
directive|else
comment|/* 	 * If page is valid; make invalid but reclaimable. 	 * If this pte is not valid, then it must be reclaimable 	 * and we can add it to the free list. 	 */
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|whichhand
operator|==
name|BACK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|REFBIT
name|pte
operator|->
name|pg_u
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|pte
operator|->
name|pg_v
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_m
argument_list|)
condition|)
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|distpte
argument_list|(
name|xp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|p_flag
operator|&
operator|(
name|SSEQL
operator||
name|SUANOM
operator|)
operator|)
operator|==
literal|0
operator|&&
name|rp
operator|->
name|p_rssize
operator|<=
name|rp
operator|->
name|p_maxrss
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|->
name|c_type
operator|!=
name|CTEXT
condition|)
block|{
comment|/* 		 * Guarantee a minimal investment in data 		 * space for jobs in balance set. 		 */
if|if
condition|(
name|rp
operator|->
name|p_rssize
operator|<
name|saferss
operator|-
name|rp
operator|->
name|p_slptime
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the page is currently dirty, we 	 * have to arrange to have it cleaned before it 	 * can be freed.  We mark it clean immediately. 	 * If it is reclaimed while being pushed, then modified 	 * again, we are assured of the correct order of  	 * writes because we lock the page during the write.   	 * This guarantees that a swap() of this process (and 	 * thus this page), initiated in parallel, will, 	 * in fact, push the page after us. 	 * 	 * The most general worst case here would be for 	 * a reclaim, a modify and a swapout to occur 	 * all before the single page transfer completes. 	 */
if|if
condition|(
name|dirtycl
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|/* 		 * If the process is being swapped out 		 * or about to exit, do not bother with its 		 * dirty pages 		 */
if|if
condition|(
name|rp
operator|->
name|p_flag
operator|&
operator|(
name|SLOCK
operator||
name|SWEXIT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Limit pushes to avoid saturating 		 * pageout device. 		 */
if|if
condition|(
name|pushes
operator|>
name|maxpgio
operator|/
name|RATETOSCHEDPAGING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pushes
operator|++
expr_stmt|;
comment|/* 		 * Now carefully make sure that there will 		 * be a header available for the push so that 		 * we will not block waiting for a header in 		 * swap().  The reason this is important is 		 * that we (proc[2]) are the one who cleans 		 * dirty swap headers and we could otherwise 		 * deadlock waiting for ourselves to clean 		 * swap headers.  The sleep here on&proc[2] 		 * is actually (effectively) a sleep on both 		 * ourselves and&bswlist, and this is known 		 * to swdone and swap in vm_swp.c.  That is, 		 *&proc[2] will be awakened both when dirty 		 * headers show up and also to get the pageout 		 * daemon moving. 		 */
name|loop2
label|:
operator|(
name|void
operator|)
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bclnlist
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
goto|goto
name|loop2
goto|;
block|}
if|if
condition|(
name|bswlist
operator|.
name|av_forw
operator|==
name|NULL
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|,
name|PSWP
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
comment|/* 			 * Page disposition may have changed 			 * since process may have exec'ed, 			 * forked, exited or just about 			 * anything else... try this page 			 * frame again, from the top. 			 */
goto|goto
name|top
goto|;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|MLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|uaccess
argument_list|(
name|rp
argument_list|,
name|Pushmap
argument_list|,
operator|&
name|pushutl
argument_list|)
expr_stmt|;
comment|/* 		 * Now committed to pushing the page... 		 */
ifdef|#
directive|ifdef
name|REFBIT
name|pte
operator|->
name|pg_v
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pte
operator|->
name|pg_m
operator|=
literal|0
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
block|{
name|xp
operator|->
name|x_poip
operator|++
expr_stmt|;
name|distpte
argument_list|(
name|xp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
name|rp
operator|->
name|p_poip
operator|++
expr_stmt|;
name|v
operator|=
name|kluster
argument_list|(
name|rp
argument_list|,
name|v
argument_list|,
name|pte
argument_list|,
name|B_WRITE
argument_list|,
operator|&
name|klsize
argument_list|,
name|klout
argument_list|,
operator|(
name|daddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|klsize
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pageout klsize"
argument_list|)
expr_stmt|;
name|daddr
operator|=
name|vtod
argument_list|(
name|rp
argument_list|,
name|v
argument_list|,
operator|&
name|pushutl
operator|.
name|u_dmap
argument_list|,
operator|&
name|pushutl
operator|.
name|u_smap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|swap
argument_list|(
name|rp
argument_list|,
name|daddr
argument_list|,
name|ptob
argument_list|(
name|v
argument_list|)
argument_list|,
name|klsize
operator|*
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|B_WRITE
argument_list|,
name|B_DIRTY
argument_list|,
name|swapdev
argument_list|,
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
comment|/* 		 * The cleaning of this page will be 		 * completed later, in cleanup() called 		 * (synchronously) by us (proc[2]).  In 		 * the meantime, the page frame is locked 		 * so no havoc can result. 		 */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* well, it'll be free soon */
block|}
comment|/* 	 * Propagate valid bit changes. 	 * Decrement the resident set size of the current 	 * text object/process, and put the page in the 	 * free list.  Don't detach the page yet; 	 * it may yet have a chance to be reclaimed from 	 * the free list. 	 */
ifdef|#
directive|ifdef
name|REFBIT
name|pte
operator|->
name|pg_v
operator|=
literal|0
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|distpte
argument_list|(
name|xp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|->
name|c_gone
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|xp
operator|->
name|x_rssize
operator|-=
name|CLSIZE
expr_stmt|;
else|else
name|rp
operator|->
name|p_rssize
operator|-=
name|CLSIZE
expr_stmt|;
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_dfree
operator|+=
name|CLSIZE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* freed a page! */
block|}
end_block

begin_comment
comment|/*  * Process the ``cleaned'' list.  *  * Scan through the linked list of swap I/O headers  * and free the corresponding pages that have been  * cleaned by being written back to the paging area.  * If the page has been reclaimed during this time,  * we do not free the page.  As they are processed,  * the swap I/O headers are removed from the cleaned  * list and inserted into the free list.  */
end_comment

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|struct
name|pte
modifier|*
name|upte
decl_stmt|;
name|unsigned
name|pf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|,
name|center
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|bclnlist
operator|)
operator|==
literal|0
condition|)
break|break;
name|bclnlist
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
operator|&
name|proc
index|[
literal|2
index|]
argument_list|,
name|btop
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
expr_stmt|;
name|center
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_bcount
condition|;
name|i
operator|+=
name|CLSIZE
operator|*
name|NBPG
control|)
block|{
name|pf
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
expr_stmt|;
name|MUNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|!=
name|bp
operator|->
name|b_pfcent
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_gone
condition|)
block|{
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_dfree
operator|+=
name|CLSIZE
expr_stmt|;
block|}
goto|goto
name|skip
goto|;
block|}
name|center
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|c_type
condition|)
block|{
case|case
name|CSYS
case|:
name|panic
argument_list|(
literal|"cleanup CSYS"
argument_list|)
expr_stmt|;
case|case
name|CTEXT
case|:
name|xp
operator|=
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
name|xp
operator|->
name|x_poip
operator|--
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_poip
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|xp
operator|->
name|x_poip
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDATA
case|:
case|case
name|CSTACK
case|:
name|rp
operator|=
operator|&
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|p_flag
operator|&
name|SNOVM
condition|)
name|rp
operator|=
name|rp
operator|->
name|p_xlink
expr_stmt|;
name|rp
operator|->
name|p_poip
operator|--
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|p_poip
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rp
operator|->
name|p_poip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|c_gone
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|c_type
condition|)
block|{
case|case
name|CTEXT
case|:
name|upte
operator|=
name|tptopte
argument_list|(
name|xp
operator|->
name|x_caddr
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDATA
case|:
name|upte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
case|case
name|CSTACK
case|:
name|upte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|upte
operator|->
name|pg_v
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|xp
operator|->
name|x_rssize
operator|-=
name|CLSIZE
expr_stmt|;
else|else
name|rp
operator|->
name|p_rssize
operator|-=
name|CLSIZE
expr_stmt|;
block|}
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_dfree
operator|+=
name|CLSIZE
expr_stmt|;
name|skip
label|:
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
block|}
if|if
condition|(
name|center
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"cleanup center"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|bswlist
operator|.
name|av_forw
expr_stmt|;
name|bswlist
operator|.
name|av_forw
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bswlist
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Kluster locates pages adjacent to the argument pages  * that are immediately available to include in the pagein/pageout,  * and given the availability of memory includes them.  * It knows that the process image is contiguous in chunks;  * an assumption here is that CLSIZE * KLMAX is a divisor of dmmin,  * so that by looking at KLMAX chunks of pages, all such will  * necessarily be mapped swap contiguous.  */
end_comment

begin_decl_stmt
name|int
name|noklust
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|klicnt
index|[
name|KLMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|klocnt
index|[
name|KLMAX
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|kluster
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
name|pte0
argument_list|,
name|rw
argument_list|,
name|pkl
argument_list|,
name|klsize
argument_list|,
name|bn0
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|pte0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|pkl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|klsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|bn0
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|,
name|cl
decl_stmt|,
name|clmax
decl_stmt|;
name|int
name|kloff
decl_stmt|,
name|k
decl_stmt|,
name|klmax
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|int
name|klback
decl_stmt|,
name|klforw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|v0
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|B_READ
condition|)
name|klicnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
else|else
name|klocnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
operator|*
name|pkl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|noklust
operator|||
name|klsize
operator|<=
literal|1
operator|||
name|klsize
operator|>
name|KLMAX
operator|||
operator|(
name|klsize
operator|&
operator|(
name|klsize
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|v
operator|)
return|;
if|if
condition|(
name|rw
operator|==
name|B_READ
operator|&&
name|freemem
operator|<
name|CLSIZE
operator|*
name|KLMAX
condition|)
return|return
operator|(
name|v
operator|)
return|;
if|if
condition|(
name|isassv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|type
operator|=
name|CSTACK
expr_stmt|;
name|cl
operator|=
name|vtosp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
operator|/
name|CLSIZE
expr_stmt|;
name|clmax
operator|=
name|p
operator|->
name|p_ssize
operator|/
name|CLSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isadsv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
block|{
name|type
operator|=
name|CDATA
expr_stmt|;
name|cl
operator|=
name|vtodp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
operator|/
name|CLSIZE
expr_stmt|;
name|clmax
operator|=
name|p
operator|->
name|p_dsize
operator|/
name|CLSIZE
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|CTEXT
expr_stmt|;
name|cl
operator|=
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
operator|/
name|CLSIZE
expr_stmt|;
name|clmax
operator|=
name|p
operator|->
name|p_textp
operator|->
name|x_size
operator|/
name|CLSIZE
expr_stmt|;
block|}
name|kloff
operator|=
name|cl
operator|&
operator|(
name|klsize
operator|-
literal|1
operator|)
expr_stmt|;
name|pte
operator|=
name|pte0
expr_stmt|;
name|bn
operator|=
name|bn0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|kloff
init|;
operator|--
name|k
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|type
operator|==
name|CSTACK
condition|)
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
else|else
name|pte
operator|-=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
operator|&&
name|rw
operator|==
name|B_READ
operator|&&
name|bn
condition|)
block|{
name|bn
operator|-=
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfind
argument_list|(
name|swapdev
argument_list|,
name|bn
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|klok
argument_list|(
name|pte
argument_list|,
name|rw
argument_list|)
condition|)
break|break;
block|}
name|klback
operator|=
operator|(
name|kloff
operator|-
name|k
operator|)
operator|-
literal|1
expr_stmt|;
name|pte
operator|=
name|pte0
expr_stmt|;
if|if
condition|(
operator|(
name|cl
operator|-
name|kloff
operator|)
operator|+
name|klsize
operator|>
name|clmax
condition|)
name|klmax
operator|=
name|clmax
operator|-
operator|(
name|cl
operator|-
name|kloff
operator|)
expr_stmt|;
else|else
name|klmax
operator|=
name|klsize
expr_stmt|;
name|bn
operator|=
name|bn0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|kloff
init|;
operator|++
name|k
operator|<
name|klmax
condition|;
control|)
block|{
if|if
condition|(
name|type
operator|==
name|CSTACK
condition|)
name|pte
operator|-=
name|CLSIZE
expr_stmt|;
else|else
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
operator|&&
name|rw
operator|==
name|B_READ
operator|&&
name|bn
condition|)
block|{
name|bn
operator|+=
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfind
argument_list|(
name|swapdev
argument_list|,
name|bn
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|klok
argument_list|(
name|pte
argument_list|,
name|rw
argument_list|)
condition|)
break|break;
block|}
name|klforw
operator|=
operator|(
name|k
operator|-
name|kloff
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|klforw
operator|+
name|klback
operator|==
literal|0
condition|)
return|return
operator|(
name|v
operator|)
return|;
name|pte
operator|=
name|pte0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CSTACK
condition|)
block|{
name|pte
operator|-=
name|klforw
operator|*
name|CLSIZE
expr_stmt|;
name|v
operator|-=
name|klforw
operator|*
name|CLSIZE
expr_stmt|;
block|}
else|else
block|{
name|pte
operator|-=
name|klback
operator|*
name|CLSIZE
expr_stmt|;
name|v
operator|-=
name|klback
operator|*
name|CLSIZE
expr_stmt|;
block|}
operator|*
name|pkl
operator|=
name|klforw
operator|+
name|klback
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|B_READ
condition|)
name|klicnt
index|[
literal|0
index|]
operator|--
operator|,
name|klicnt
index|[
operator|*
name|pkl
operator|-
literal|1
index|]
operator|++
expr_stmt|;
else|else
name|klocnt
index|[
literal|0
index|]
operator|--
operator|,
name|klocnt
index|[
operator|*
name|pkl
operator|-
literal|1
index|]
operator|++
expr_stmt|;
name|v0
operator|=
name|v
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pkl
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pte
operator|==
name|pte0
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
name|rw
operator|==
name|B_WRITE
condition|)
block|{
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
name|MLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_m
operator|=
literal|0
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pte
name|opte
decl_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|memall
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"kluster"
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_prot
operator|=
name|opte
operator|.
name|pg_prot
expr_stmt|;
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
block|{
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|p_rssize
operator|+=
name|CLSIZE
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
name|cont
label|:
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
name|v
operator|+=
name|CLSIZE
expr_stmt|;
block|}
return|return
operator|(
name|v0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|klok
argument_list|(
name|pte
argument_list|,
name|rw
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|B_WRITE
condition|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_fod
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
operator|||
name|c
operator|->
name|c_intrans
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|uncachecl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirtycl
argument_list|(
name|pte
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|pte
operator|->
name|pg_fod
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * Fodkluster locates pages adjacent to the argument pages  * that are immediately available to include in the pagein,  * and given the availability of memory includes them.  * It wants to page in a file system block if it can.  */
end_comment

begin_decl_stmt
name|int
name|nofodklust
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fodklcnt
index|[
name|KLMAX
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|fodkluster
argument_list|(
name|p
argument_list|,
name|v0
argument_list|,
name|pte0
argument_list|,
name|pkl
argument_list|,
name|dev
argument_list|,
name|pbn
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|v0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|pte0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pkl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
modifier|*
name|pbn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|struct
name|fpte
modifier|*
name|fpte
decl_stmt|;
specifier|register
name|daddr_t
name|bn
decl_stmt|;
name|daddr_t
name|bnswap
decl_stmt|;
name|unsigned
name|v
decl_stmt|,
name|vmin
decl_stmt|,
name|vmax
decl_stmt|;
specifier|register
name|int
name|klsize
decl_stmt|;
name|int
name|klback
decl_stmt|,
name|type
decl_stmt|,
name|i
decl_stmt|;
name|fodklcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
operator|*
name|pkl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|freemem
operator|<
name|KLMAX
operator|||
name|nofodklust
condition|)
return|return
operator|(
name|v0
operator|)
return|;
if|if
condition|(
name|isatsv
argument_list|(
name|p
argument_list|,
name|v0
argument_list|)
condition|)
block|{
name|type
operator|=
name|CTEXT
expr_stmt|;
name|vmin
operator|=
name|tptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmax
operator|=
name|tptov
argument_list|(
name|p
argument_list|,
name|clrnd
argument_list|(
name|p
operator|->
name|p_tsize
argument_list|)
operator|-
name|CLSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|CDATA
expr_stmt|;
name|vmin
operator|=
name|dptov
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmax
operator|=
name|dptov
argument_list|(
name|p
argument_list|,
name|clrnd
argument_list|(
name|p
operator|->
name|p_dsize
argument_list|)
operator|-
name|CLSIZE
argument_list|)
expr_stmt|;
block|}
name|fpte
operator|=
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte0
expr_stmt|;
name|bn
operator|=
operator|*
name|pbn
expr_stmt|;
name|v
operator|=
name|v0
expr_stmt|;
for|for
control|(
name|klsize
operator|=
literal|1
init|;
name|klsize
operator|<
name|KLMAX
condition|;
name|klsize
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|<=
name|vmin
condition|)
break|break;
name|v
operator|-=
name|CLSIZE
expr_stmt|;
name|fpte
operator|-=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|fpte
operator|->
name|pg_fod
operator|==
literal|0
condition|)
break|break;
name|bn
operator|-=
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpte
operator|->
name|pg_blkno
operator|!=
name|bn
condition|)
break|break;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
block|{
if|if
condition|(
name|mfind
argument_list|(
name|dev
argument_list|,
name|bn
argument_list|)
condition|)
break|break;
comment|/* 			 * Flush any previous text page use of this 			 * swap device block. 			 */
name|bnswap
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
name|munhash
argument_list|(
name|swapdev
argument_list|,
name|bnswap
argument_list|)
expr_stmt|;
block|}
block|}
name|klback
operator|=
name|klsize
operator|-
literal|1
expr_stmt|;
name|fpte
operator|=
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte0
expr_stmt|;
name|bn
operator|=
operator|*
name|pbn
expr_stmt|;
name|v
operator|=
name|v0
expr_stmt|;
for|for
control|(
init|;
name|klsize
operator|<
name|KLMAX
condition|;
name|klsize
operator|++
control|)
block|{
name|v
operator|+=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|vmax
condition|)
break|break;
name|fpte
operator|+=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|fpte
operator|->
name|pg_fod
operator|==
literal|0
condition|)
break|break;
name|bn
operator|+=
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpte
operator|->
name|pg_blkno
operator|!=
name|bn
condition|)
break|break;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
block|{
if|if
condition|(
name|mfind
argument_list|(
name|dev
argument_list|,
name|bn
argument_list|)
condition|)
break|break;
comment|/* 			 * Flush any previous text page use of this 			 * swap device block. 			 */
name|bnswap
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
name|munhash
argument_list|(
name|swapdev
argument_list|,
name|bnswap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|klsize
operator|==
literal|1
condition|)
return|return
operator|(
name|v0
operator|)
return|;
name|pte
operator|=
name|pte0
expr_stmt|;
name|pte
operator|-=
name|klback
operator|*
name|CLSIZE
expr_stmt|;
name|v0
operator|-=
name|klback
operator|*
name|CLSIZE
expr_stmt|;
operator|*
name|pbn
operator|-=
name|klback
operator|*
name|btodb
argument_list|(
name|CLBYTES
argument_list|)
expr_stmt|;
operator|*
name|pkl
operator|=
name|klsize
expr_stmt|;
name|fodklcnt
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|fodklcnt
index|[
name|klsize
operator|-
literal|1
index|]
operator|++
expr_stmt|;
name|v
operator|=
name|v0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pte
operator|!=
name|pte0
condition|)
block|{
name|struct
name|pte
name|opte
decl_stmt|;
name|int
name|pf
decl_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|memall
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"fodkluster"
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_prot
operator|=
name|opte
operator|.
name|pg_prot
expr_stmt|;
name|pf
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_intrans
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTEXT
condition|)
block|{
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
operator|(
name|unsigned
operator|)
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|p_rssize
operator|+=
name|CLSIZE
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
name|v
operator|+=
name|CLSIZE
expr_stmt|;
block|}
return|return
operator|(
name|v0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|REFBIT
end_ifdef

begin_comment
comment|/*  * Examine the reference bits in the pte's of all  * processes linked to a particular text segment.   */
end_comment

begin_macro
name|tanyu
argument_list|(
argument|xp
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|p
operator|=
name|xp
operator|->
name|x_caddr
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p_xlink
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_u
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

