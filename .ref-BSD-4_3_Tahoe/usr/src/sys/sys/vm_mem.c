begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)vm_mem.c	7.7 (Berkeley) 8/23/87  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"trace.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"../machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_comment
comment|/*  * Allocate memory, and always succeed  * by jolting page-out daemon  * so as to obtain page frames.  * To be used in conjunction with vmemfree().  */
end_comment

begin_expr_stmt
name|vmemall
argument_list|(
name|pte
argument_list|,
name|size
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
name|maxmem
condition|)
name|panic
argument_list|(
literal|"vmemall size"
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|freemem
operator|<
name|desfree
condition|)
name|outofmem
argument_list|()
expr_stmt|;
while|while
condition|(
name|freemem
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|freemem
argument_list|,
name|PSWP
operator|+
literal|2
argument_list|)
expr_stmt|;
name|m
operator|=
name|imin
argument_list|(
name|size
argument_list|,
name|freemem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memall
argument_list|(
name|pte
argument_list|,
name|m
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|size
operator|-=
name|m
expr_stmt|;
name|pte
operator|+=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|freemem
operator|<
name|desfree
condition|)
name|outofmem
argument_list|()
expr_stmt|;
comment|/* 	 * Always succeeds, but return success for 	 * vgetu and vgetpt (e.g.) which call either 	 * memall or vmemall depending on context. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free valid and reclaimable page frames belonging to the  * count pages starting at pte.  If a page is valid  * or reclaimable and locked (but not a system page), then  * we simply mark the page as c_gone and let the pageout  * daemon free the page when it is through with it.  * If a page is reclaimable, and already in the free list, then  * we mark the page as c_gone, and (of course) don't free it.  *  * Determines the largest contiguous cluster of  * valid pages and frees them in one call to memfree.  */
end_comment

begin_expr_stmt
name|vmemfree
argument_list|(
name|pte
argument_list|,
name|count
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|spte
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|size
decl_stmt|,
name|pcnt
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|int
name|fileno
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"vmemfree"
argument_list|)
expr_stmt|;
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|pcnt
operator|=
literal|0
init|;
name|count
operator|>
literal|0
condition|;
name|pte
operator|+=
name|CLSIZE
operator|,
name|count
operator|-=
name|CLSIZE
control|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|==
literal|0
operator|&&
name|pte
operator|->
name|pg_pfnum
condition|)
block|{
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
name|pcnt
operator|+=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
operator|&&
name|c
operator|->
name|c_type
operator|!=
name|CSYS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
name|PG_PROT
expr_stmt|;
name|c
operator|->
name|c_gone
operator|=
literal|1
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|c
operator|->
name|c_free
condition|)
block|{
name|pcnt
operator|-=
name|CLSIZE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
name|PG_PROT
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|distpte
argument_list|(
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
argument_list|,
name|c
operator|->
name|c_page
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_gone
operator|=
literal|1
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|spte
operator|=
name|pte
expr_stmt|;
name|size
operator|+=
name|CLSIZE
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* Don't do anything with mapped ptes */
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|&&
name|pte
operator|->
name|pg_v
condition|)
goto|goto
name|free
goto|;
endif|#
directive|endif
if|if
condition|(
name|pte
operator|->
name|pg_fod
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|fileno
operator|=
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_fileno
expr_stmt|;
if|if
condition|(
name|fileno
operator|<
name|NOFILE
condition|)
name|panic
argument_list|(
literal|"vmemfree vread"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
name|PG_PROT
expr_stmt|;
block|}
name|free
label|:
if|if
condition|(
name|size
condition|)
block|{
name|memfree
argument_list|(
name|spte
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
condition|)
name|memfree
argument_list|(
name|spte
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Unlink a page frame from the free list -  *  * Performed if the page being reclaimed  * is in the free list.  */
end_comment

begin_expr_stmt
name|munlink
argument_list|(
name|c
argument_list|)
specifier|register
expr|struct
name|cmap
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|c
operator|->
name|c_next
expr_stmt|;
name|prev
operator|=
name|c
operator|->
name|c_prev
expr_stmt|;
name|cmap
index|[
name|prev
index|]
operator|.
name|c_next
operator|=
name|next
expr_stmt|;
name|cmap
index|[
name|next
index|]
operator|.
name|c_prev
operator|=
name|prev
expr_stmt|;
name|c
operator|->
name|c_free
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|freemem
operator|<
name|minfree
condition|)
name|outofmem
argument_list|()
expr_stmt|;
name|freemem
operator|-=
name|CLSIZE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate memory -  *  * The free list appears as a doubly linked list  * in the core map with cmap[0] serving as a header.  */
end_comment

begin_expr_stmt
name|memall
argument_list|(
name|pte
argument_list|,
name|size
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|rpte
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|next
decl_stmt|,
name|curpos
decl_stmt|;
name|unsigned
name|pf
decl_stmt|;
name|struct
name|cmap
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"memall"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|freemem
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trace
argument_list|(
name|TR_MALL
argument_list|,
name|size
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
name|CLSIZE
control|)
block|{
name|curpos
operator|=
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|curpos
index|]
expr_stmt|;
name|freemem
operator|-=
name|CLSIZE
expr_stmt|;
name|next
operator|=
name|c
operator|->
name|c_next
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
operator|=
name|next
expr_stmt|;
name|cmap
index|[
name|next
index|]
operator|.
name|c_prev
operator|=
name|CMHEAD
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_free
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dup mem alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmtopg
argument_list|(
name|curpos
argument_list|)
operator|>
name|maxfree
condition|)
name|panic
argument_list|(
literal|"bad mem alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_gone
operator|==
literal|0
operator|&&
name|c
operator|->
name|c_type
operator|!=
name|CSYS
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|rp
operator|=
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
operator|.
name|x_caddr
expr_stmt|;
else|else
name|rp
operator|=
operator|&
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|p_flag
operator|&
name|SNOVM
condition|)
name|rp
operator|=
name|rp
operator|->
name|p_xlink
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|c_type
condition|)
block|{
case|case
name|CTEXT
case|:
name|rpte
operator|=
name|tptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDATA
case|:
name|rpte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
case|case
name|CSTACK
case|:
name|rpte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
break|break;
block|}
name|zapcl
argument_list|(
name|rpte
argument_list|,
name|pg_pfnum
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_type
operator|==
name|CTEXT
condition|)
name|distpte
argument_list|(
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
argument_list|,
name|c
operator|->
name|c_page
argument_list|,
name|rpte
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CSYS
case|:
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_ndx
expr_stmt|;
break|break;
case|case
name|CTEXT
case|:
name|c
operator|->
name|c_page
operator|=
name|vtotp
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_textp
operator|-
operator|&
name|text
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|CDATA
case|:
name|c
operator|->
name|c_page
operator|=
name|vtodp
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_ndx
expr_stmt|;
break|break;
case|case
name|CSTACK
case|:
name|c
operator|->
name|c_page
operator|=
name|vtosp
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_ndx
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|c_blkno
condition|)
block|{
comment|/* 			 * This is very like munhash(), except 			 * that we really don't want to bother 			 * to calculate a dev to pass to it. 			 */
name|j
operator|=
name|CMHASH
argument_list|(
name|c
operator|->
name|c_blkno
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|&
name|cmap
index|[
name|cmhash
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|c
condition|)
name|cmhash
index|[
name|j
index|]
operator|=
name|c1
operator|->
name|c_hlink
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c1
operator|==
name|ecmap
condition|)
name|panic
argument_list|(
literal|"memall ecmap"
argument_list|)
expr_stmt|;
name|c2
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
operator|&
name|cmap
index|[
name|c2
operator|->
name|c_hlink
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|c
condition|)
break|break;
block|}
name|c2
operator|->
name|c_hlink
operator|=
name|c1
operator|->
name|c_hlink
expr_stmt|;
block|}
if|if
condition|(
name|mfind
argument_list|(
name|c
operator|->
name|c_mdev
operator|==
name|MSWAPX
condition|?
name|swapdev
else|:
name|mount
index|[
name|c
operator|->
name|c_mdev
index|]
operator|.
name|m_dev
argument_list|,
operator|(
name|daddr_t
operator|)
operator|(
name|u_long
operator|)
name|c
operator|->
name|c_blkno
argument_list|)
condition|)
name|panic
argument_list|(
literal|"memall mfind"
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_mdev
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_blkno
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_hlink
operator|=
literal|0
expr_stmt|;
block|}
name|pf
operator|=
name|cmtopg
argument_list|(
name|curpos
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|++
operator|=
name|pf
operator|++
expr_stmt|;
name|c
operator|->
name|c_free
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|c_gone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_intrans
operator|||
name|c
operator|->
name|c_want
condition|)
name|panic
argument_list|(
literal|"memall intrans|want"
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_lock
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|c_type
operator|=
name|type
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free memory -  *  * The page frames being returned are inserted  * to the head/tail of the free list depending  * on whether there is any possible future use of them.  *  * If the freemem count had been zero,  * the processes sleeping for memory  * are awakened.  */
end_comment

begin_expr_stmt
name|memfree
argument_list|(
name|pte
argument_list|,
name|size
argument_list|,
name|detach
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"memfree"
argument_list|)
expr_stmt|;
if|if
condition|(
name|freemem
operator|<
name|CLSIZE
operator|*
name|KLMAX
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|freemem
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|size
operator|-=
name|CLSIZE
expr_stmt|;
name|i
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|firstfree
operator|||
name|i
operator|>
name|maxfree
condition|)
name|panic
argument_list|(
literal|"bad mem free"
argument_list|)
expr_stmt|;
name|i
operator|=
name|pgtocm
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_free
condition|)
name|panic
argument_list|(
literal|"dup mem free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|detach
operator|&&
name|c
operator|->
name|c_type
operator|!=
name|CSYS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
name|PG_PROT
expr_stmt|;
name|c
operator|->
name|c_gone
operator|=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|detach
operator|&&
name|c
operator|->
name|c_blkno
operator|==
literal|0
condition|)
block|{
name|next
operator|=
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
expr_stmt|;
name|cmap
index|[
name|next
index|]
operator|.
name|c_prev
operator|=
name|i
expr_stmt|;
name|c
operator|->
name|c_prev
operator|=
name|CMHEAD
expr_stmt|;
name|c
operator|->
name|c_next
operator|=
name|next
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_prev
expr_stmt|;
name|cmap
index|[
name|prev
index|]
operator|.
name|c_next
operator|=
name|i
expr_stmt|;
name|c
operator|->
name|c_next
operator|=
name|CMHEAD
expr_stmt|;
name|c
operator|->
name|c_prev
operator|=
name|prev
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_prev
operator|=
name|i
expr_stmt|;
block|}
name|c
operator|->
name|c_free
operator|=
literal|1
expr_stmt|;
name|freemem
operator|+=
name|CLSIZE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Enter clist block c on the hash chains.  * It contains file system block bn from device dev.  * Dev must either be a mounted file system or the swap device  * so we panic if getfsx() cannot find it.  */
end_comment

begin_expr_stmt
name|mhash
argument_list|(
name|c
argument_list|,
name|dev
argument_list|,
name|bn
argument_list|)
specifier|register
expr|struct
name|cmap
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|bn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|CMHASH
argument_list|(
name|bn
argument_list|)
decl_stmt|;
name|c
operator|->
name|c_hlink
operator|=
name|cmhash
index|[
name|i
index|]
expr_stmt|;
name|cmhash
index|[
name|i
index|]
operator|=
name|c
operator|-
name|cmap
expr_stmt|;
name|c
operator|->
name|c_blkno
operator|=
name|bn
expr_stmt|;
name|i
operator|=
name|getfsx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"mhash"
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_mdev
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pull the clist entry of<dev,bn> off the hash chains  * if present.  */
end_comment

begin_macro
name|munhash
argument_list|(
argument|dev
argument_list|,
argument|bn
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|bn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
name|CMHASH
argument_list|(
name|bn
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|int
name|mdev
decl_stmt|,
name|s
decl_stmt|;
name|mdev
operator|=
name|getfsx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|c1
operator|=
operator|&
name|cmap
index|[
name|cmhash
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|ecmap
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|c1
operator|->
name|c_blkno
operator|==
name|bn
operator|&&
name|c1
operator|->
name|c_mdev
operator|==
name|mdev
condition|)
name|cmhash
index|[
name|i
index|]
operator|=
name|c1
operator|->
name|c_hlink
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
operator|&
name|cmap
index|[
name|c2
operator|->
name|c_hlink
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|ecmap
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|c1
operator|->
name|c_blkno
operator|==
name|bn
operator|&&
name|c1
operator|->
name|c_mdev
operator|==
name|mdev
condition|)
break|break;
block|}
name|c2
operator|->
name|c_hlink
operator|=
name|c1
operator|->
name|c_hlink
expr_stmt|;
block|}
name|c1
operator|->
name|c_mdev
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_blkno
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_hlink
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mfind
argument_list|(
name|dev
argument_list|,
name|bn
argument_list|)
condition|)
name|panic
argument_list|(
literal|"munhash mfind"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Look for block bn of device dev in the free pool.  * Currently it should not be possible to find it unless it is  * c_free and c_gone, although this may later not be true.  * (This is because active texts are locked against file system  * writes by the system.)  */
end_comment

begin_function
name|struct
name|cmap
modifier|*
name|mfind
parameter_list|(
name|dev
parameter_list|,
name|bn
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c1
init|=
operator|&
name|cmap
index|[
name|cmhash
index|[
name|CMHASH
argument_list|(
name|bn
argument_list|)
index|]
index|]
decl_stmt|;
name|int
name|mdev
init|=
name|getfsx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|si
init|=
name|splimp
argument_list|()
decl_stmt|;
while|while
condition|(
name|c1
operator|!=
name|ecmap
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_blkno
operator|==
name|bn
operator|&&
name|c1
operator|->
name|c_mdev
operator|==
name|mdev
condition|)
block|{
name|splx
argument_list|(
name|si
argument_list|)
expr_stmt|;
return|return
operator|(
name|c1
operator|)
return|;
block|}
name|c1
operator|=
operator|&
name|cmap
index|[
name|c1
operator|->
name|c_hlink
index|]
expr_stmt|;
block|}
name|splx
argument_list|(
name|si
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|cmap
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Purge blocks from device dev from incore cache  * before umount().  */
end_comment

begin_macro
name|mpurge
argument_list|(
argument|mdev
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mdev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|si
init|=
name|splimp
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CMHSIZ
condition|;
name|i
operator|++
control|)
block|{
name|more
label|:
name|c1
operator|=
operator|&
name|cmap
index|[
name|cmhash
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|ecmap
condition|)
continue|continue;
if|if
condition|(
name|c1
operator|->
name|c_mdev
operator|==
name|mdev
condition|)
name|cmhash
index|[
name|i
index|]
operator|=
name|c1
operator|->
name|c_hlink
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
operator|&
name|cmap
index|[
name|c1
operator|->
name|c_hlink
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|ecmap
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
name|c1
operator|->
name|c_mdev
operator|==
name|mdev
condition|)
break|break;
block|}
name|c2
operator|->
name|c_hlink
operator|=
name|c1
operator|->
name|c_hlink
expr_stmt|;
block|}
name|c1
operator|->
name|c_mdev
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_blkno
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_hlink
operator|=
literal|0
expr_stmt|;
goto|goto
name|more
goto|;
name|cont
label|:
empty_stmt|;
block|}
name|splx
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize core map  */
end_comment

begin_macro
name|meminit
argument_list|(
argument|first
argument_list|,
argument|last
argument_list|)
end_macro

begin_decl_stmt
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
name|firstfree
operator|=
name|clrnd
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|maxfree
operator|=
name|clrnd
argument_list|(
name|last
operator|-
operator|(
name|CLSIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|freemem
operator|=
name|maxfree
operator|-
name|firstfree
expr_stmt|;
name|ecmx
operator|=
name|ecmap
operator|-
name|cmap
expr_stmt|;
if|if
condition|(
name|ecmx
operator|<
name|freemem
operator|/
name|CLSIZE
condition|)
name|freemem
operator|=
name|ecmx
operator|*
name|CLSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|freemem
operator|/
name|CLSIZE
condition|;
name|i
operator|++
control|)
block|{
name|cmap
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|c_next
operator|=
name|i
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|i
index|]
expr_stmt|;
name|c
operator|->
name|c_prev
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|c_free
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|c_gone
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|c_type
operator|=
name|CSYS
expr_stmt|;
name|c
operator|->
name|c_mdev
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|c_blkno
operator|=
literal|0
expr_stmt|;
block|}
name|cmap
index|[
name|freemem
operator|/
name|CLSIZE
index|]
operator|.
name|c_next
operator|=
name|CMHEAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CMHSIZ
condition|;
name|i
operator|++
control|)
name|cmhash
index|[
name|i
index|]
operator|=
name|ecmx
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_prev
operator|=
name|freemem
operator|/
name|CLSIZE
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_type
operator|=
name|CSYS
expr_stmt|;
name|avefree
operator|=
name|freemem
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Wait for frame pf to become unlocked  * if it is currently locked.  */
end_comment

begin_macro
name|mwait
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mlock
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|munlock
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Lock a page frame.  */
end_comment

begin_expr_stmt
name|mlock
argument_list|(
name|c
argument_list|)
specifier|register
expr|struct
name|cmap
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|c
operator|->
name|c_lock
condition|)
block|{
name|c
operator|->
name|c_want
operator|=
literal|1
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|c
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|c_lock
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unlock a page frame.  */
end_comment

begin_expr_stmt
name|munlock
argument_list|(
name|c
argument_list|)
specifier|register
expr|struct
name|cmap
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|->
name|c_lock
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dup page unlock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_want
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_want
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|->
name|c_lock
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * Lock a virtual segment.  *  * For each cluster of pages, if the cluster is not valid,  * touch it to fault it in, otherwise just lock page frame.  * Called from physio to ensure that the pages   * participating in raw i/o are valid and locked.  */
end_comment

begin_macro
name|vslock
argument_list|(
argument|base
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|base
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|v
decl_stmt|;
specifier|register
name|int
name|npf
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
comment|/* 	 * TAHOE I/O drivers may arrive here on raw I/O, 	 * base will be a system address in this case 	 */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|KERNBASE
operator|)
operator|==
name|KERNBASE
condition|)
comment|/* system addresses */
return|return;
endif|#
directive|endif
name|v
operator|=
name|btop
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|count
operator|+
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|CLOFSET
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|npf
operator|>
literal|0
condition|;
name|pte
operator|+=
name|CLSIZE
operator|,
name|v
operator|+=
name|CLSIZE
operator|,
name|npf
operator|-=
name|CLSIZE
control|)
block|{
name|retry
label|:
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
block|{
ifdef|#
directive|ifdef
name|MMAP
if|if
condition|(
name|pte
operator|->
name|pg_fod
condition|)
comment|/* mapped page */
continue|continue;
endif|#
directive|endif
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lock
condition|)
block|{
name|MLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|MUNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|MLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|pagein
argument_list|(
name|ctob
argument_list|(
name|v
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* return it locked */
block|}
block|}
end_block

begin_comment
comment|/*   * Unlock a virtual segment.  */
end_comment

begin_macro
name|vsunlock
argument_list|(
argument|base
argument_list|,
argument|count
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|base
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
name|int
name|npf
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|tahoe
argument_list|)
comment|/* 	 * TAHOE I/O drivers may arrive here on raw I/O, 	 * base will be a system address in this case 	 */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|KERNBASE
operator|)
operator|==
name|KERNBASE
condition|)
comment|/* system addresses */
return|return;
endif|#
directive|endif
name|pte
operator|=
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|btop
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|count
operator|+
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|CLOFSET
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|npf
operator|>
literal|0
condition|;
name|pte
operator|+=
name|CLSIZE
operator|,
name|npf
operator|-=
name|CLSIZE
control|)
block|{
ifdef|#
directive|ifdef
name|MMAP
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|&&
name|pte
operator|->
name|pg_v
condition|)
comment|/* mapped page */
continue|continue;
endif|#
directive|endif
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
name|MUNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|B_READ
condition|)
comment|/* Reading from device writes memory */
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

end_unit

