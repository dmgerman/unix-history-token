begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file is derived from version 7.2 of the VX driver to create  * a driver compatible with the 4.3BSD-tahoe release.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)vx.c	7.2 (Berkeley) 7/9/88  */
end_comment

begin_include
include|#
directive|include
file|"vx.h"
end_include

begin_if
if|#
directive|if
name|NVX
operator|>
literal|0
end_if

begin_comment
comment|/*  * VIOC-X driver  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VXPERF
end_ifdef

begin_define
define|#
directive|define
name|DOSCOPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbaparam.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vxreg.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/scope.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VX_DEBUG
end_ifdef

begin_decl_stmt
name|long
name|vxintr4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VXERR4
value|1
end_define

begin_define
define|#
directive|define
name|VXNOBUF
value|2
end_define

begin_decl_stmt
name|long
name|vxdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VXVCM
value|1
end_define

begin_define
define|#
directive|define
name|VXVCC
value|2
end_define

begin_define
define|#
directive|define
name|VXVCX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Interrupt type bits passed to vinthandl().  */
end_comment

begin_define
define|#
directive|define
name|CMDquals
value|0
end_define

begin_comment
comment|/* command completed interrupt */
end_comment

begin_define
define|#
directive|define
name|RSPquals
value|1
end_define

begin_comment
comment|/* command response interrupt */
end_comment

begin_define
define|#
directive|define
name|UNSquals
value|2
end_define

begin_comment
comment|/* unsolicited interrupt */
end_comment

begin_define
define|#
directive|define
name|VXUNIT
parameter_list|(
name|n
parameter_list|)
value|((n)>> 4)
end_define

begin_define
define|#
directive|define
name|VXPORT
parameter_list|(
name|n
parameter_list|)
value|((n)& 0xf)
end_define

begin_decl_stmt
name|struct
name|tty
name|vx_tty
index|[
name|NVX
operator|*
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|int
name|nvx
init|=
name|NVX
operator|*
literal|16
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|vxstart
argument_list|()
decl_stmt|,
name|ttrstrt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vxcmd
modifier|*
name|vobtain
argument_list|()
decl_stmt|,
modifier|*
name|nextcmd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver information for auto-configuration stuff.  */
end_comment

begin_decl_stmt
name|int
name|vxprobe
argument_list|()
decl_stmt|,
name|vxattach
argument_list|()
decl_stmt|,
name|vxrint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vxinfo
index|[
name|NVX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|vxstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|vxdriver
init|=
block|{
name|vxprobe
block|,
literal|0
block|,
name|vxattach
block|,
literal|0
block|,
name|vxstd
block|,
literal|"vx"
block|,
name|vxinfo
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vx_softc
block|{
name|u_char
name|vs_type
decl_stmt|;
comment|/* 0: viox-x/vioc-b, 1: vioc-bop */
name|u_char
name|vs_bop
decl_stmt|;
comment|/* bop board # for vioc-bop's */
name|u_char
name|vs_loport
decl_stmt|;
comment|/* low port nbr */
name|u_char
name|vs_hiport
decl_stmt|;
comment|/* high port nbr */
name|u_short
name|vs_nbr
decl_stmt|;
comment|/* viocx number */
name|u_short
name|vs_maxcmd
decl_stmt|;
comment|/* max number of concurrent cmds */
name|u_short
name|vs_silosiz
decl_stmt|;
comment|/* silo size */
name|short
name|vs_vers
decl_stmt|;
comment|/* vioc/pvioc version */
define|#
directive|define
name|VXV_OLD
value|0
comment|/* PVIOCX | VIOCX */
define|#
directive|define
name|VXV_NEW
value|1
comment|/* NPVIOCX | NVIOCX */
name|short
name|vs_xmtcnt
decl_stmt|;
comment|/* xmit commands pending */
name|short
name|vs_brkreq
decl_stmt|;
comment|/* send break requests pending */
name|short
name|vs_state
decl_stmt|;
comment|/* controller state */
define|#
directive|define
name|VXS_READY
value|0
comment|/* ready for commands */
define|#
directive|define
name|VXS_RESET
value|1
comment|/* in process of reseting */
name|u_short
name|vs_softCAR
decl_stmt|;
comment|/* soft carrier */
name|caddr_t
name|vs_mricmd
decl_stmt|;
comment|/* most recent issued cmd */
name|u_int
name|vs_ivec
decl_stmt|;
comment|/* interrupt vector base */
name|struct
name|vxcmd
modifier|*
name|vs_avail
decl_stmt|;
comment|/* next available command buffer */
name|struct
name|vxcmd
modifier|*
name|vs_build
decl_stmt|;
name|struct
name|vxcmd
name|vs_lst
index|[
name|NVCXBUFS
index|]
decl_stmt|;
name|struct
name|vcmds
name|vs_cmds
decl_stmt|;
block|}
name|vx_softc
index|[
name|NVX
index|]
struct|;
end_struct

begin_macro
name|vxprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|struct
name|pte
modifier|*
name|dummypte
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vackint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vunsol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vcmdrsp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vxfreset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|VBIOMAPPED
argument_list|(
name|reg
argument_list|)
operator|&&
operator|!
name|vbmemalloc
argument_list|(
literal|16
argument_list|,
name|reg
argument_list|,
operator|&
name|dummypte
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: vbmemalloc failed.\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
name|reg
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vi
operator|->
name|ui_addr
operator|=
name|reg
expr_stmt|;
name|vp
operator|->
name|v_fault
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vioc
operator|=
name|V_BSY
expr_stmt|;
name|vp
operator|->
name|v_hdwre
operator|=
name|V_RESET
expr_stmt|;
comment|/* reset interrupt */
name|DELAY
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_fault
operator|!=
name|VXF_READY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Align vioc interrupt vector base to 4 vector 	 * boundary and fitting in 8 bits (is this necessary, 	 * wish we had documentation). 	 */
if|if
condition|(
operator|(
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|-=
literal|3
operator|)
operator|>
literal|0xff
condition|)
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|=
literal|0xff
expr_stmt|;
name|vs
operator|->
name|vs_ivec
operator|=
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|=
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|&
operator|~
literal|0x3
expr_stmt|;
else|#
directive|else
name|vs
operator|->
name|vs_ivec
operator|=
literal|0x40
operator|+
name|vi
operator|->
name|ui_unit
operator|*
literal|4
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x18
operator|,
name|cvec
operator|=
name|vs
operator|->
name|vs_ivec
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vxdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vxattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|vx_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|.
name|vs_softCAR
operator|=
name|vi
operator|->
name|ui_flags
expr_stmt|;
name|vxinit
argument_list|(
name|vi
operator|->
name|ui_unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open a VX line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vxopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* pointer to tty struct for port */
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|vx
decl_stmt|,
name|s
decl_stmt|,
name|error
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vx
operator|=
name|VXUNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx
operator|>=
name|NVX
operator|||
operator|(
name|vi
operator|=
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
name|unit
operator|=
name|VXPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|unit
operator|<
name|vs
operator|->
name|vs_loport
operator|||
name|unit
operator|>
name|vs
operator|->
name|vs_hiport
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|vs
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|vxstart
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|SSPEED
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|SSPEED
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|ODDP
operator||
name|EVENP
operator||
name|ECHO
expr_stmt|;
block|}
name|vxparam
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_ON
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close a VX line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vxclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_HUPCLS
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_OFF
argument_list|)
expr_stmt|;
comment|/* wait for the last response */
while|while
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|,
name|TTOPRI
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read from a VX line.  */
end_comment

begin_macro
name|vxread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * write on a VX line  */
end_comment

begin_macro
name|vxwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOCX unsolicited interrupt.  */
end_comment

begin_expr_stmt
name|vxrint
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|int
name|nc
decl_stmt|,
name|c
decl_stmt|;
specifier|register
struct|struct
name|silo
block|{
name|char
name|data
decl_stmt|,
name|port
decl_stmt|;
block|}
modifier|*
name|sp
struct|;
name|short
modifier|*
name|osp
decl_stmt|;
name|int
name|overrun
init|=
literal|0
decl_stmt|;
name|vi
operator|=
name|vxinfo
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return;
name|addr
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
name|vi
operator|->
name|ui_addr
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|v_uqual
operator|&
literal|037
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"vx%d: vc proc err, ustat %x\n"
argument_list|,
name|vx
argument_list|,
name|addr
operator|->
name|v_ustat
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
name|vcmintr
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
case|case
literal|4
case|:
return|return;
default|default:
name|printf
argument_list|(
literal|"vx%d: vc uqual err, uqual %x\n"
argument_list|,
name|vx
argument_list|,
name|addr
operator|->
name|v_uqual
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|addr
operator|+
operator|*
operator|(
name|short
operator|*
operator|)
name|addr
operator|->
name|v_usdata
operator|)
expr_stmt|;
else|else
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|addr
operator|+
name|VX_SILO
operator|+
operator|(
name|addr
operator|->
name|v_usdata
index|[
literal|0
index|]
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
name|nc
operator|=
operator|*
operator|(
name|osp
operator|=
operator|(
name|short
operator|*
operator|)
name|sp
operator|)
expr_stmt|;
if|if
condition|(
name|nc
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|&&
name|nc
operator|>
name|vs
operator|->
name|vs_silosiz
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: %d exceeds silo size\n"
argument_list|,
name|nc
argument_list|)
expr_stmt|;
name|nc
operator|=
name|vs
operator|->
name|vs_silosiz
expr_stmt|;
block|}
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|sp
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|nc
operator|>
literal|0
condition|;
name|nc
operator|--
operator|,
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|sp
operator|)
operator|+
literal|1
operator|)
control|)
block|{
name|c
operator|=
name|sp
operator|->
name|port
operator|&
literal|017
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_loport
operator|>
name|c
operator|||
name|c
operator|>
name|vs
operator|->
name|vs_hiport
condition|)
continue|continue;
name|tp
operator|=
name|tp0
operator|+
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|sp
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|port
operator|&
name|VX_RO
operator|)
operator|==
name|VX_RO
operator|&&
operator|!
name|overrun
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vx%d: receiver overrun\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|overrun
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|port
operator|&
name|VX_PE
condition|)
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|EVENP
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|ODDP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|PASS8
operator|)
operator|)
operator|==
literal|0
condition|)
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|port
operator|&
name|VX_FE
condition|)
block|{
comment|/* 			 * At framing error (break) generate 			 * a null (in raw mode, for getty), or a 			 * interrupt (in cooked/cbreak mode). 			 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
name|c
operator|=
name|tp
operator|->
name|t_intrc
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
block|}
operator|*
name|osp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ioctl for VX.  */
end_comment

begin_macro
name|vxioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|TIOCSETP
operator|||
name|cmd
operator|==
name|TIOCSETN
operator|||
name|cmd
operator|==
name|TIOCLBIS
operator|||
name|cmd
operator|==
name|TIOCLBIC
operator|||
name|cmd
operator|==
name|TIOCLSET
condition|)
name|vxparam
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_block

begin_macro
name|vxparam
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vxcparam
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set parameters from open or stty into the VX hardware  * registers.  */
end_comment

begin_macro
name|vxcparam
argument_list|(
argument|dev
argument_list|,
argument|wait
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wait
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_ispeed
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_HUPCLS
expr_stmt|;
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_OFF
argument_list|)
expr_stmt|;
return|return;
block|}
name|vs
operator|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
comment|/* 	 * Construct ``load parameters'' command block 	 * to setup baud rates, xon-xoff chars, parity, 	 * and stop bits for the specified port. 	 */
name|cp
operator|->
name|cmd
operator|=
name|VXC_LPARAX
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|VXPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|2
index|]
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
condition|?
literal|0
else|:
name|tp
operator|->
name|t_startc
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
condition|?
literal|0
else|:
name|tp
operator|->
name|t_stopc
expr_stmt|;
ifdef|#
directive|ifdef
name|notnow
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator||
name|PASS8
operator|)
condition|)
block|{
endif|#
directive|endif
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|BITS8
expr_stmt|;
comment|/* 8 bits of data */
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|VNOPARITY
expr_stmt|;
comment|/* no parity */
ifdef|#
directive|ifdef
name|notnow
block|}
else|else
block|{
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|BITS7
expr_stmt|;
comment|/* 7 bits of data */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|ODDP
condition|)
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|VODDP
expr_stmt|;
comment|/* odd parity */
else|else
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|VEVENP
expr_stmt|;
comment|/* even parity */
block|}
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|t_ospeed
operator|==
name|B110
condition|)
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
name|VSTOP2
expr_stmt|;
comment|/* 2 stop bits */
else|else
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
name|VSTOP1
expr_stmt|;
comment|/* 1 stop bit */
if|if
condition|(
name|tp
operator|->
name|t_ospeed
operator|==
name|EXTA
operator|||
name|tp
operator|->
name|t_ospeed
operator|==
name|EXTB
condition|)
name|cp
operator|->
name|par
index|[
literal|6
index|]
operator|=
name|V19200
expr_stmt|;
else|else
name|cp
operator|->
name|par
index|[
literal|6
index|]
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
if|if
condition|(
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
operator|&&
name|wait
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * VIOCX command response interrupt.  * For transmission, restart output to any active port.  * For all other commands, just clean up.  */
end_comment

begin_expr_stmt
name|vxxint
argument_list|(
name|vx
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxmit
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|long
operator|*
operator|)
name|cp
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|cmd
operator|&
literal|0xff00
condition|)
block|{
case|case
name|VXC_LIDENT
case|:
comment|/* initialization complete */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
condition|)
block|{
name|vxfnreset
argument_list|(
name|vx
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|cmd
operator|++
expr_stmt|;
return|return;
case|case
name|VXC_XMITDTA
case|:
case|case
name|VXC_XMITIMM
case|:
break|break;
case|case
name|VXC_LPARAX
case|:
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
comment|/* fall thru... */
default|default:
comment|/* VXC_MDMCTL or VXC_FDTATOX */
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
condition|)
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
name|cp
operator|->
name|par
operator|+
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vxmit
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|vp
operator|>=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
name|cp
operator|->
name|par
condition|;
name|vp
operator|--
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
operator|(
name|vp
operator|->
name|line
operator|&
literal|017
operator|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
else|else
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|vp
operator|->
name|bcount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
block|{
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
operator|+
name|vs
operator|->
name|vs_hiport
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
operator|+
name|vs
operator|->
name|vs_loport
index|]
init|;
name|tp
operator|<=
name|tp0
condition|;
name|tp
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|vs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* command to send? */
name|vs
operator|->
name|vs_xmtcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|vs
operator|->
name|vs_xmtcnt
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Force out partial XMIT command after timeout  */
end_comment

begin_expr_stmt
name|vxforce
argument_list|(
name|vs
argument_list|)
specifier|register
expr|struct
name|vx_softc
operator|*
name|vs
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|vs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vs
operator|->
name|vs_xmtcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start (restart) transmission on the given VX line.  */
end_comment

begin_expr_stmt
name|vxstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|n
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|,
name|port
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|port
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|017
expr_stmt|;
name|vs
operator|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|scope_out
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
operator|(
name|n
operator|&
literal|0177
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|vsetq
argument_list|(
name|vs
argument_list|,
name|port
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_expr_stmt
name|vxstop
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|vxbbno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * VIOCX Initialization.  Makes free lists of command buffers.  * Resets all viocx's.  Issues a LIDENT command to each  * viocx to establish interrupt vectors and logical port numbers.  */
end_comment

begin_expr_stmt
name|vxinit
argument_list|(
name|vx
argument_list|,
name|wait
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|wait
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|char
name|type
decl_stmt|,
modifier|*
name|typestring
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|vs
operator|->
name|vs_type
operator|=
literal|0
expr_stmt|;
comment|/* vioc-x by default */
name|addr
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
name|type
operator|=
name|addr
operator|->
name|v_ident
expr_stmt|;
name|vs
operator|->
name|vs_vers
operator|=
operator|(
name|type
operator|&
name|VXT_NEW
operator|)
condition|?
name|VXV_NEW
else|:
name|VXV_OLD
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
name|vs
operator|->
name|vs_silosiz
operator|=
name|addr
operator|->
name|v_maxsilo
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VXT_VIOCX
case|:
case|case
name|VXT_VIOCX
operator||
name|VXT_NEW
case|:
name|typestring
operator|=
literal|"VIOC-X"
expr_stmt|;
comment|/* set soft carrier for printer ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|addr
operator|->
name|v_portyp
index|[
name|j
index|]
operator|==
name|VXT_PARALLEL
condition|)
block|{
name|vs
operator|->
name|vs_softCAR
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
name|addr
operator|->
name|v_dcd
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
block|}
break|break;
case|case
name|VXT_PVIOCX
case|:
case|case
name|VXT_PVIOCX
operator||
name|VXT_NEW
case|:
name|typestring
operator|=
literal|"VIOC-X (old connector panel)"
expr_stmt|;
break|break;
case|case
name|VXT_VIOCBOP
case|:
comment|/* VIOC-BOP */
name|vs
operator|->
name|vs_type
operator|=
literal|1
expr_stmt|;
name|vs
operator|->
name|vs_bop
operator|=
operator|++
name|vxbbno
expr_stmt|;
name|printf
argument_list|(
literal|"VIOC-BOP no. %d at %x\n"
argument_list|,
name|vs
operator|->
name|vs_bop
argument_list|,
name|addr
argument_list|)
expr_stmt|;
default|default:
name|printf
argument_list|(
literal|"vx%d: unknown type %x\n"
argument_list|,
name|vx
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|vxinfo
index|[
name|vx
index|]
operator|->
name|ui_alive
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|vs
operator|->
name|vs_nbr
operator|=
operator|-
literal|1
expr_stmt|;
name|vs
operator|->
name|vs_maxcmd
operator|=
operator|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|)
condition|?
literal|24
else|:
literal|4
expr_stmt|;
comment|/* 	 * Initialize all cmd buffers by linking them 	 * into a free list. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVCXBUFS
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
index|]
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|vs
operator|->
name|vs_avail
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
literal|0
index|]
expr_stmt|;
comment|/* set idx to 1st free buf */
name|cp
operator|->
name|c_fwd
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* mark last buf in free list */
comment|/* 	 * Establish the interrupt vectors and define the port numbers. 	 */
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|VXC_LIDENT
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|vs
operator|->
name|vs_ivec
expr_stmt|;
comment|/* ack vector */
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
comment|/* cmd resp vector */
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
comment|/* unsol intr vector */
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
literal|15
expr_stmt|;
comment|/* max ports, no longer used */
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set 1st port number */
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wait
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|cp
operator|->
name|cmd
operator|==
name|VXC_LIDENT
operator|&&
name|j
operator|<
literal|4000000
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|>=
literal|4000000
condition|)
name|printf
argument_list|(
literal|"vx%d: didn't respond to LIDENT\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
comment|/* calculate address of response buffer */
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
operator|(
name|addr
operator|->
name|v_rspoff
operator|&
literal|0x3fff
operator|)
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|(
name|resp
index|[
literal|0
index|]
operator|&
literal|0177
operator|)
operator|!=
literal|3
condition|)
block|{
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* init failed */
return|return;
block|}
name|vs
operator|->
name|vs_loport
operator|=
name|cp
operator|->
name|par
index|[
literal|5
index|]
expr_stmt|;
name|vs
operator|->
name|vs_hiport
operator|=
name|cp
operator|->
name|par
index|[
literal|7
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"vx%d: %s%s, ports %d-%d\n"
argument_list|,
name|vx
argument_list|,
operator|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|)
condition|?
literal|""
else|:
literal|"old "
argument_list|,
name|typestring
argument_list|,
name|vs
operator|->
name|vs_loport
argument_list|,
name|vs
operator|->
name|vs_hiport
argument_list|)
expr_stmt|;
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_nbr
operator|=
name|vx
expr_stmt|;
comment|/* assign board number */
block|}
end_block

begin_comment
comment|/*  * Obtain a command buffer  */
end_comment

begin_function
name|struct
name|vxcmd
modifier|*
name|vobtain
parameter_list|(
name|vs
parameter_list|)
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|p
operator|=
name|vs
operator|->
name|vs_avail
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXNOBUF
condition|)
name|vxintr4
operator|&=
operator|~
name|VXNOBUF
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"vx%d: no buffers\n"
argument_list|,
name|vs
operator|-
name|vx_softc
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vs
operator|-
name|vx_softc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|vobtain
argument_list|(
name|vs
argument_list|)
operator|)
return|;
block|}
name|vs
operator|->
name|vs_avail
operator|=
name|p
operator|->
name|c_fwd
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a command buffer  */
end_comment

begin_expr_stmt
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
specifier|register
expr|struct
name|vx_softc
operator|*
name|vs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXNOBUF
condition|)
return|return;
endif|#
directive|endif
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
name|vs
operator|->
name|vs_avail
expr_stmt|;
name|vs
operator|->
name|vs_avail
operator|=
name|cp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|vxcmd
modifier|*
name|nextcmd
parameter_list|(
name|vs
parameter_list|)
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|=
name|vs
operator|->
name|vs_build
expr_stmt|;
name|vs
operator|->
name|vs_build
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assemble transmits into a multiple command;  * up to 8 transmits to 8 lines can be assembled together  * (on PVIOCX only).  */
end_comment

begin_expr_stmt
name|vsetq
argument_list|(
name|vs
argument_list|,
name|line
argument_list|,
name|addr
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|vx_softc
operator|*
name|vs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxmit
modifier|*
name|mp
decl_stmt|;
comment|/* 	 * Grab a new command buffer or append 	 * to the current one being built. 	 */
name|cp
operator|=
name|vs
operator|->
name|vs_build
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
condition|)
block|{
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_build
operator|=
name|cp
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|VXC_XMITDTA
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|==
literal|07
operator|||
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: setq overflow\n"
argument_list|,
name|vs
operator|-
name|vx_softc
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|->
name|cmd
operator|++
expr_stmt|;
block|}
comment|/* 	 * Select the next vxmit buffer and copy the 	 * characters into the buffer (if there's room 	 * and the device supports ``immediate mode'', 	 * or store an indirect pointer to the data. 	 */
name|mp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
name|cp
operator|->
name|par
operator|+
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vxmit
argument_list|)
operator|)
expr_stmt|;
name|mp
operator|->
name|bcount
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|line
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|&&
name|n
operator|<=
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|ostream
argument_list|)
condition|)
block|{
name|cp
operator|->
name|cmd
operator|=
name|VXC_XMITIMM
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|mp
operator|->
name|ostream
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get system address of clist block */
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|addr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|addr
argument_list|,
name|mp
operator|->
name|ostream
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We send the data immediately if a VIOCX, 	 * the command buffer is full, or if we've nothing 	 * currently outstanding.  If we don't send it, 	 * set a timeout to force the data to be sent soon. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|||
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|==
literal|7
operator|||
name|vs
operator|->
name|vs_xmtcnt
operator|==
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_xmtcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_build
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|timeout
argument_list|(
name|vxforce
argument_list|,
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write a command out to the VIOC  */
end_comment

begin_expr_stmt
name|vcmd
argument_list|(
name|vx
argument_list|,
name|cmdad
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|cmdad
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
comment|/* 	 * When the vioc is resetting, don't process 	 * anything other than VXC_LIDENT commands. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
operator|&&
name|cmdad
operator|!=
name|NULL
condition|)
block|{
name|struct
name|vxcmd
modifier|*
name|vcp
init|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
name|cmdad
operator|-
sizeof|sizeof
argument_list|(
name|vcp
operator|->
name|c_fwd
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|vcp
operator|->
name|cmd
operator|!=
name|VXC_LIDENT
condition|)
block|{
name|vrelease
argument_list|(
name|vs
argument_list|,
name|vcp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
if|if
condition|(
name|cmdad
operator|!=
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_fill
index|]
operator|=
name|cmdad
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_fill
operator|>=
name|VC_CMDBUFL
condition|)
name|cp
operator|->
name|v_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_fill
operator|==
name|cp
operator|->
name|v_empty
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: cmd q overflow\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|->
name|v_cmdsem
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|v_cmdsem
operator|&&
name|cp
operator|->
name|v_curcnt
operator|<
name|vs
operator|->
name|vs_maxcmd
condition|)
block|{
name|cp
operator|->
name|v_cmdsem
operator|--
expr_stmt|;
name|cp
operator|->
name|v_curcnt
operator|++
expr_stmt|;
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|CMDquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOC acknowledge interrupt.  The VIOC has received the new  * command.  If no errors, the new command becomes one of 16 (max)  * current commands being executed.  */
end_comment

begin_expr_stmt
name|vackint
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_type
condition|)
comment|/* Its a BOP */
return|return;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vcid
operator|&
name|V_ERR
condition|)
block|{
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"vx%d: ackint error type %x v_dcd %x\n"
argument_list|,
name|vx
argument_list|,
name|vp
operator|->
name|v_vcid
operator|&
literal|07
argument_list|,
name|vp
operator|->
name|v_dcd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|vs
operator|->
name|vs_mricmd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|resp
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|v_hdwre
operator|&
literal|017
operator|)
operator|==
name|CMDquals
condition|)
block|{
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXERR4
condition|)
block|{
comment|/* causes VIOC INTR ERR 4 */
name|struct
name|vxcmd
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp0
decl_stmt|;
name|cp0
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
operator|-
sizeof|sizeof
argument_list|(
name|cp0
operator|->
name|c_fwd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cp0
operator|->
name|cmd
operator|==
name|VXC_XMITDTA
operator|||
name|cp0
operator|->
name|cmd
operator|==
name|VXC_XMITIMM
condition|)
block|{
name|cp1
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
operator|*
name|cp0
expr_stmt|;
name|vxintr4
operator|&=
operator|~
name|VXERR4
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|&
name|cp1
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cp
operator|->
name|v_curcmd
index|[
name|vp
operator|->
name|v_vcid
operator|&
name|VCMDLEN
operator|-
literal|1
index|]
operator|=
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_empty
operator|>=
name|VC_CMDBUFL
condition|)
name|cp
operator|->
name|v_empty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|cp
operator|->
name|v_itrempt
operator|>=
name|VC_IQLEN
condition|)
name|cp
operator|->
name|v_itrempt
operator|=
literal|0
expr_stmt|;
name|vintempt
argument_list|(
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* queue next cmd, if any */
block|}
end_block

begin_comment
comment|/*  * Command Response interrupt.  The Vioc has completed  * a command.  The command may now be returned to  * the appropriate device driver.  */
end_comment

begin_expr_stmt
name|vcmdrsp
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|caddr_t
name|cmd
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|k
expr_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_type
condition|)
block|{
comment|/* Its a BOP */
name|printf
argument_list|(
literal|"vx%d: vcmdrsp interrupt\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|vp
operator|+
operator|(
name|vp
operator|->
name|v_rspoff
operator|&
literal|0x7fff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|k
operator|=
name|resp
index|[
literal|1
index|]
operator|)
operator|&
name|V_UNBSY
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: cmdresp debug\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|&=
name|VCMDLEN
operator|-
literal|1
expr_stmt|;
name|cmd
operator|=
name|cp
operator|->
name|v_curcmd
index|[
name|k
index|]
expr_stmt|;
name|cp
operator|->
name|v_curcmd
index|[
name|k
index|]
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
name|cp
operator|->
name|v_curcnt
operator|--
expr_stmt|;
name|k
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|resp
index|[
literal|4
index|]
operator|)
expr_stmt|;
comment|/* cmd operation code */
if|if
condition|(
operator|(
name|k
operator|&
literal|0xff00
operator|)
operator|==
name|VXC_LIDENT
condition|)
comment|/* want hiport number */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|VRESPLEN
condition|;
name|k
operator|++
control|)
name|cmd
index|[
name|k
index|]
operator|=
name|resp
index|[
name|k
operator|+
literal|4
index|]
expr_stmt|;
name|resp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vxxint
argument_list|(
name|vx
argument_list|,
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_READY
condition|)
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unsolicited interrupt.  */
end_comment

begin_expr_stmt
name|vunsol
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_type
condition|)
block|{
comment|/* Its a BOP */
name|printf
argument_list|(
literal|"vx%d: vunsol from BOP\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_uqual
operator|&
name|V_UNBSY
condition|)
block|{
name|vxrint
argument_list|(
name|vx
argument_list|)
expr_stmt|;
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|UNSquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|}
else|else
block|{
name|printf
argument_list|(
literal|"vx%d: unsolicited interrupt error\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enqueue an interrupt.  */
end_comment

begin_expr_stmt
name|vinthandl
argument_list|(
name|vx
argument_list|,
name|item
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|item
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|cp
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_cmds
expr_stmt|;
name|empty
operator|=
operator|(
name|cp
operator|->
name|v_itrfill
operator|==
name|cp
operator|->
name|v_itrempt
operator|)
expr_stmt|;
name|cp
operator|->
name|v_itrqueu
index|[
name|cp
operator|->
name|v_itrfill
index|]
operator|=
name|item
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_itrfill
operator|>=
name|VC_IQLEN
condition|)
name|cp
operator|->
name|v_itrfill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrfill
operator|==
name|cp
operator|->
name|v_itrempt
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: interrupt q overflow\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|empty
condition|)
name|vintempt
argument_list|(
name|vx
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vintempt
argument_list|(
name|vx
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|short
name|item
decl_stmt|;
specifier|register
name|short
modifier|*
name|intr
decl_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vioc
operator|&
name|V_BSY
condition|)
return|return;
name|cp
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_cmds
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrempt
operator|==
name|cp
operator|->
name|v_itrfill
condition|)
return|return;
name|item
operator|=
name|cp
operator|->
name|v_itrqueu
index|[
name|cp
operator|->
name|v_itrempt
index|]
expr_stmt|;
name|intr
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|vp
operator|->
name|v_vioc
expr_stmt|;
switch|switch
condition|(
operator|(
name|item
operator|>>
literal|8
operator|)
operator|&
literal|03
condition|)
block|{
case|case
name|CMDquals
case|:
block|{
comment|/* command */
name|int
name|phys
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_empty
operator|==
name|cp
operator|->
name|v_fill
operator|||
name|vp
operator|->
name|v_vcbsy
operator|&
name|V_BSY
condition|)
break|break;
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_mricmd
operator|=
operator|(
name|caddr_t
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
expr_stmt|;
name|phys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vcp
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|phys
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|vp
operator|->
name|v_vcp
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|phys
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|vp
operator|->
name|v_vcbsy
operator|=
name|V_BSY
expr_stmt|;
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RSPquals
case|:
comment|/* command response */
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSquals
case|:
comment|/* unsolicited interrupt */
name|vp
operator|->
name|v_uqual
operator|=
literal|0
expr_stmt|;
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Start a reset on a vioc after error (hopefully)  */
end_comment

begin_expr_stmt
name|vxstreset
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|extern
name|int
name|vxinreset
parameter_list|()
function_decl|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
condition|)
block|{
comment|/* avoid recursion */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
comment|/* 	 * Zero out the vioc structures, mark the vioc as being 	 * reset, reinitialize the free command list, reset the vioc 	 * and start a timer to check on the progress of the reset. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|vs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setting VXS_RESET prevents others from issuing 	 * commands while allowing currently queued commands to 	 * be passed to the VIOC. 	 */
name|vs
operator|->
name|vs_state
operator|=
name|VXS_RESET
expr_stmt|;
comment|/* init all cmd buffers */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVCXBUFS
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
index|]
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|vs
operator|->
name|vs_avail
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"vx%d: reset..."
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_fault
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vioc
operator|=
name|V_BSY
expr_stmt|;
name|vp
operator|->
name|v_hdwre
operator|=
name|V_RESET
expr_stmt|;
comment|/* generate reset interrupt */
name|timeout
argument_list|(
name|vxinreset
argument_list|,
operator|(
name|caddr_t
operator|)
name|vx
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* continue processing a reset on a vioc after an error (hopefully) */
end_comment

begin_macro
name|vxinreset
argument_list|(
argument|vx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
comment|/* 	 * See if the vioc has reset. 	 */
if|if
condition|(
name|vp
operator|->
name|v_fault
operator|!=
name|VXF_READY
condition|)
block|{
name|printf
argument_list|(
literal|"failed\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Send a LIDENT to the vioc and mess with carrier flags 	 * on parallel printer ports. 	 */
name|vxinit
argument_list|(
name|vx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Finish the reset on the vioc after an error (hopefully).  *  * Restore modem control, parameters and restart output.  * Since the vioc can handle no more then 24 commands at a time  * and we could generate as many as 48 commands, we must do this in  * phases, issuing no more then 16 commands at a time.  */
end_comment

begin_expr_stmt
name|vxfnreset
argument_list|(
name|vx
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
specifier|register
name|int
name|on
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|vxrestart
parameter_list|()
function_decl|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|vs
operator|->
name|vs_loport
operator|=
name|cp
operator|->
name|par
index|[
literal|5
index|]
expr_stmt|;
name|vs
operator|->
name|vs_hiport
operator|=
name|cp
operator|->
name|par
index|[
literal|7
index|]
expr_stmt|;
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_nbr
operator|=
name|vx
expr_stmt|;
comment|/* assign VIOC-X board number */
name|vs
operator|->
name|vs_state
operator|=
name|VXS_READY
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
name|vp
operator|->
name|v_vcid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Restore modem information and control. 	 */
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vs
operator|->
name|vs_loport
init|;
name|i
operator|<=
name|vs
operator|->
name|vs_hiport
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
name|vcmodem
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
name|VMOD_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * If carrier has changed while we were resetting, 		 * take appropriate action. 		 */
name|on
operator|=
name|vp
operator|->
name|v_dcd
operator|&
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
name|on
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|vs
operator|->
name|vs_state
operator|=
name|VXS_RESET
expr_stmt|;
name|timeout
argument_list|(
name|vxrestart
argument_list|,
operator|(
name|caddr_t
operator|)
name|vx
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Restore a particular aspect of the VIOC.  */
end_comment

begin_macro
name|vxrestart
argument_list|(
argument|vx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|count
operator|=
name|vx
operator|>>
literal|8
expr_stmt|;
name|vx
operator|&=
literal|0xff
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|VXS_READY
expr_stmt|;
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vs
operator|->
name|vs_loport
init|;
name|i
operator|<=
name|vs
operator|->
name|vs_hiport
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_TIMEOUT
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
name|vxstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* restart pending output */
block|}
else|else
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_WOPEN
operator||
name|TS_ISOPEN
operator|)
condition|)
name|vxcparam
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_state
operator|=
name|VXS_RESET
expr_stmt|;
name|timeout
argument_list|(
name|vxrestart
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|vx
operator|+
literal|1
operator|*
literal|256
argument_list|)
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vxreset
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vxstreset
argument_list|(
operator|(
name|int
operator|)
name|VXUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* completes asynchronously */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_expr_stmt
name|vxfreset
argument_list|(
name|vx
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|vx
operator|>
name|NVX
operator|||
operator|(
name|vi
operator|=
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_addr
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_state
operator|=
name|VXS_READY
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* completes asynchronously */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|vcmodem
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|kp
decl_stmt|;
specifier|register
name|port
expr_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
name|vs
operator|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|!=
name|VXS_READY
condition|)
return|return;
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|kp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vs
operator|->
name|vs_nbr
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
name|port
operator|=
name|unit
operator|&
literal|017
expr_stmt|;
comment|/* 	 * Issue MODEM command 	 */
name|cp
operator|->
name|cmd
operator|=
name|VXC_MDMCTL
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|VMOD_ON
condition|)
block|{
if|if
condition|(
name|vs
operator|->
name|vs_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|V_MANUAL
operator||
name|V_DTR_ON
operator||
name|V_RTS
expr_stmt|;
else|else
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|V_AUTO
operator||
name|V_DTR_ON
operator||
name|V_RTS
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|V_DTR_OFF
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|kp
operator|->
name|v_dcd
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|kp
operator|->
name|v_dcd
operator||
name|vs
operator|->
name|vs_softCAR
operator|)
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
operator|&&
name|flag
operator|==
name|VMOD_ON
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * VCMINTR called when an unsolicited interrup occurs signaling  * some change of modem control state.  */
end_comment

begin_expr_stmt
name|vcmintr
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|kp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|port
expr_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|kp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
operator|(
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|->
name|ui_addr
expr_stmt|;
name|port
operator|=
name|kp
operator|->
name|v_usdata
index|[
literal|0
index|]
operator|&
literal|017
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
operator|+
name|port
index|]
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|v_ustat
operator|&
name|DCD_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kp
operator|->
name|v_ustat
operator|&
name|DCD_OFF
operator|)
operator|&&
operator|(
operator|(
name|vs
operator|->
name|vs_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cmdp
decl_stmt|;
comment|/* clear all pending transmits */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
operator|&&
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
block|{
name|int
name|i
decl_stmt|,
name|cmdfound
init|=
literal|0
decl_stmt|;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cp
operator|->
name|v_empty
init|;
name|i
operator|!=
name|cp
operator|->
name|v_fill
condition|;
control|)
block|{
name|cmdp
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|long
operator|*
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|i
index|]
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmdp
operator|->
name|cmd
operator|==
name|VXC_XMITDTA
operator|||
name|cmdp
operator|->
name|cmd
operator|==
name|VXC_XMITIMM
operator|)
operator|&&
operator|(
operator|(
expr|struct
name|vxmit
operator|*
operator|)
name|cmdp
operator|->
name|par
operator|)
operator|->
name|line
operator|==
name|port
condition|)
block|{
name|cmdfound
operator|++
expr_stmt|;
name|cmdp
operator|->
name|cmd
operator|=
name|VXC_FDTATOX
expr_stmt|;
name|cmdp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|VC_CMDBUFL
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cmdfound
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
comment|/* cmd is already in vioc, have to flush it */
else|else
block|{
name|cmdp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|cmdp
operator|->
name|cmd
operator|=
name|VXC_FDTATOX
expr_stmt|;
name|cmdp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cmdp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|kp
operator|->
name|v_ustat
operator|&
name|BRK_CHR
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
condition|?
literal|0
else|:
name|tp
operator|->
name|t_intrc
operator|,
name|tp
operator|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

