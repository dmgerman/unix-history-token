begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * NNTP client routines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)clientlib.c	1.5	(Berkeley) 10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AF_DECnet
argument_list|)
operator|&&
name|defined
argument_list|(
name|ultrix
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|DECNET
end_ifndef

begin_define
define|#
directive|define
name|DECNET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DECNET
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"response_codes.h"
end_include

begin_decl_stmt
name|FILE
modifier|*
name|ser_rd_fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ser_wr_fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * getserverbyfile	Get the name of a server from a named file.  *			Handle white space and comments.  *			Use NNTPSERVER environment variable if set.  *  *	Parameters:	"file" is the name of the file to read.  *  *	Returns:	Pointer to static data area containing the  *			first non-ws/comment line in the file.  *			NULL on error (or lack of entry in file).  *  *	Side effects:	None.  */
end_comment

begin_function
name|char
modifier|*
name|getserverbyfile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
if|if
condition|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"NNTPSERVER"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\n'
operator|||
operator|*
name|buf
operator|==
literal|'#'
condition|)
continue|continue;
name|cp
operator|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* No entry */
block|}
end_function

begin_comment
comment|/*  * server_init  Get a connection to the remote news server.  *  *	Parameters:	"machine" is the machine to connect to.  *  *	Returns:	-1 on error  *			server's initial response code on success.  *  *	Side effects:	Connects to server.  *			"ser_rd_fp" and "ser_wr_fp" are fp's  *			for reading and writing to server.  */
end_comment

begin_macro
name|server_init
argument_list|(
argument|machine
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sockt_rd
decl_stmt|,
name|sockt_wr
decl_stmt|;
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DECNET
name|cp
operator|=
name|index
argument_list|(
name|machine
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|sockt_rd
operator|=
name|get_dnet_socket
argument_list|(
name|machine
argument_list|)
expr_stmt|;
block|}
else|else
name|sockt_rd
operator|=
name|get_tcp_socket
argument_list|(
name|machine
argument_list|)
expr_stmt|;
else|#
directive|else
name|sockt_rd
operator|=
name|get_tcp_socket
argument_list|(
name|machine
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sockt_rd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Now we'll make file pointers (i.e., buffered I/O) out of 	 * the socket file descriptor.  Note that we can't just 	 * open a fp for reading and writing -- we have to open 	 * up two separate fp's, one for reading, one for writing. 	 */
if|if
condition|(
operator|(
name|ser_rd_fp
operator|=
name|fdopen
argument_list|(
name|sockt_rd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"server_init: fdopen #1"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sockt_wr
operator|=
name|dup
argument_list|(
name|sockt_rd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ser_wr_fp
operator|=
name|fdopen
argument_list|(
name|sockt_wr
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"server_init: fdopen #2"
argument_list|)
expr_stmt|;
name|ser_rd_fp
operator|=
name|NULL
expr_stmt|;
comment|/* from above */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Now get the server's signon message */
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|atoi
argument_list|(
name|line
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * get_tcp_socket -- get us a socket connected to the news server.  *  *	Parameters:	"machine" is the machine the server is running on.  *  *	Returns:	Socket connected to the news server if  *			all is ok, else -1 on error.  *  *	Side effects:	Connects to server.  *  *	Errors:		Printed via perror.  */
end_comment

begin_macro
name|get_tcp_socket
argument_list|(
argument|machine
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|servent
modifier|*
name|getservbyname
argument_list|()
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|gethostbyname
argument_list|()
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"nntp"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nntp/tcp: Unknown service.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|machine
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown host.\n"
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
comment|/* 	 * The following is kinda gross.  The name server under 4.3 	 * returns a list of addresses, each of which should be tried 	 * in turn if the previous one fails.  However, 4.2 hostent 	 * structure doesn't have this list of addresses. 	 * Under 4.3, h_addr is a #define to h_addr_list[0]. 	 * We use this to figure out whether to include the NS specific 	 * code... 	 */
ifdef|#
directive|ifdef
name|h_addr
comment|/* get a socket and initiate connection -- use multiple addresses */
for|for
control|(
name|cp
operator|=
name|hp
operator|->
name|h_addr_list
init|;
name|cp
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|s
operator|=
name|socket
argument_list|(
name|hp
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|*
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"connection to %s: "
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"giving up...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|#
directive|else
comment|/* no name server */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Get the socket */
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* And then connect */
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DECNET
end_ifdef

begin_comment
comment|/*  * get_dnet_socket -- get us a socket connected to the news server.  *  *	Parameters:	"machine" is the machine the server is running on.  *  *	Returns:	Socket connected to the news server if  *			all is ok, else -1 on error.  *  *	Side effects:	Connects to server.  *  *	Errors:		Printed via nerror.  */
end_comment

begin_macro
name|get_dnet_socket
argument_list|(
argument|machine
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|,
name|area
decl_stmt|,
name|node
decl_stmt|;
name|struct
name|sockaddr_dn
name|sdn
decl_stmt|;
name|struct
name|nodeent
modifier|*
name|getnodebyname
argument_list|()
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sdn
argument_list|,
sizeof|sizeof
argument_list|(
name|sdn
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|=
name|sscanf
argument_list|(
name|machine
argument_list|,
literal|"%d%*[.]%d"
argument_list|,
operator|&
name|area
argument_list|,
operator|&
name|node
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|node
operator|=
name|area
expr_stmt|;
name|area
operator|=
literal|0
expr_stmt|;
case|case
literal|2
case|:
name|node
operator|+=
name|area
operator|*
literal|1024
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_len
operator|=
literal|2
expr_stmt|;
name|sdn
operator|.
name|sdn_family
operator|=
name|AF_DECnet
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_addr
index|[
literal|0
index|]
operator|=
name|node
operator|%
literal|256
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_addr
index|[
literal|1
index|]
operator|=
name|node
operator|/
literal|256
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|machine
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown host.\n"
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sdn
operator|.
name|sdn_add
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|sdn
operator|.
name|sdn_family
operator|=
name|np
operator|->
name|n_addrtype
expr_stmt|;
block|}
break|break;
block|}
name|sdn
operator|.
name|sdn_objnum
operator|=
literal|0
expr_stmt|;
name|sdn
operator|.
name|sdn_flags
operator|=
literal|0
expr_stmt|;
name|sdn
operator|.
name|sdn_objnamel
operator|=
name|strlen
argument_list|(
literal|"NNTP"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"NNTP"
argument_list|,
operator|&
name|sdn
operator|.
name|sdn_objname
index|[
literal|0
index|]
argument_list|,
name|sdn
operator|.
name|sdn_objnamel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_DECnet
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|nerror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* And then connect */
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdn
argument_list|,
sizeof|sizeof
argument_list|(
name|sdn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nerror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * handle_server_response  *  *	Print some informative messages based on the server's initial  *	response code.  This is here so inews, rn, etc. can share  *	the code.  *  *	Parameters:	"response" is the response code which the  *			server sent us, presumably from "server_init",  *			above.  *			"server" is the news server we got the  *			response code from.  *  *	Returns:	-1 if the error is fatal (and we should exit).  *			0 otherwise.  *  *	Side effects:	None.  */
end_comment

begin_macro
name|handle_server_response
argument_list|(
argument|response
argument_list|,
argument|server
argument_list|)
end_macro

begin_decl_stmt
name|int
name|response
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|server
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|response
condition|)
block|{
case|case
name|OK_NOPOST
case|:
comment|/* fall through */
name|printf
argument_list|(
literal|"NOTE: This machine does not have permission to post articles.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Please don't waste your time trying.\n\n"
argument_list|)
expr_stmt|;
case|case
name|OK_CANPOST
case|:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ERR_ACCESS
case|:
name|printf
argument_list|(
literal|"This machine does not have permission to use the %s news server.\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected response code from %s news server: %d\n"
argument_list|,
name|server
argument_list|,
name|response
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_comment
comment|/*  * put_server -- send a line of text to the server, terminating it  * with CR and LF, as per ARPA standard.  *  *	Parameters:	"string" is the string to be sent to the  *			server.  *  *	Returns:	Nothing.  *  *	Side effects:	Talks to the server.  *  *	Note:		This routine flushes the buffer each time  *			it is called.  For large transmissions  *			(i.e., posting news) don't use it.  Instead,  *			do the fprintf's yourself, and then a final  *			fflush.  */
end_comment

begin_function
name|void
name|put_server
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">>> %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|ser_wr_fp
argument_list|,
literal|"%s\r\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ser_wr_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_server -- get a line of text from the server.  Strips  * CR's and LF's.  *  *	Parameters:	"string" has the buffer space for the  *			line received.  *			"size" is the size of the buffer.  *  *	Returns:	-1 on error, 0 otherwise.  *  *	Side effects:	Talks to server, changes contents of "string".  */
end_comment

begin_macro
name|get_server
argument_list|(
argument|string
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|fgets
argument_list|(
name|string
argument_list|,
name|size
argument_list|,
name|ser_rd_fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|string
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|string
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * close_server -- close the connection to the server, after sending  *		the "quit" command.  *  *	Parameters:	None.  *  *	Returns:	Nothing.  *  *	Side effects:	Closes the connection with the server.  *			You can't use "put_server" or "get_server"  *			after this routine is called.  */
end_comment

begin_function
name|void
name|close_server
parameter_list|()
block|{
name|char
name|ser_line
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|ser_wr_fp
operator|==
name|NULL
operator|||
name|ser_rd_fp
operator|==
name|NULL
condition|)
return|return;
name|put_server
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ser_wr_fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ser_rd_fp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

