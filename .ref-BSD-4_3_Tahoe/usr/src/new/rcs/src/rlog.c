begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                       RLOG    operation  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/local/bin/rcs/src/RCS/rlog.c,v 4.5 87/12/18 11:46:38 narten Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************  *                       print contents of RCS files  *****************************************************************************  *  * Copyright (C) 1982 by Walter Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	rlog.c,v $  * Revision 4.5  87/12/18  11:46:38  narten  * more lint cleanups (Guy Harris)  *   * Revision 4.4  87/10/18  10:41:12  narten  * Updating version numbers  * Changes relative to 1.1 actually relative to 4.2  *   * Revision 1.3  87/09/24  14:01:10  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:45  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:50:45  kcs  * Initial revision  *   * Revision 4.2  83/12/05  09:18:09  wft  * changed rewriteflag to external.  *   * Revision 4.1  83/05/11  16:16:55  wft  * Added -b, updated getnumericrev() accordingly.  * Replaced getpwuid() with getcaller().  *   * Revision 3.7  83/05/11  14:24:13  wft  * Added options -L and -R;  * Fixed selection bug with -l on multiple files.  * Fixed error on dates of the form -d'>date' (rewrote getdatepair()).  *   * Revision 3.6  82/12/24  15:57:53  wft  * shortened output format.  *  * Revision 3.5  82/12/08  21:45:26  wft  * removed call to checkaccesslist(); used DATEFORM to format all dates;  * removed unused variables.  *  * Revision 3.4  82/12/04  13:26:25  wft  * Replaced getdelta() with gettree(); removed updating of field lockedby.  *  * Revision 3.3  82/12/03  14:08:20  wft  * Replaced getlogin with getpwuid(), %02d with %.2d, fancydate with PRINTDATE.  * Fixed printing of nil, removed printing of Suffix,  * added shortcut if no revisions are printed, disambiguated struct members.  *  * Revision 3.2  82/10/18  21:09:06  wft  * call to curdir replaced with getfullRCSname(),  * fixed call to getlogin(), cosmetic changes on output,  * changed conflicting long identifiers.  *  * Revision 3.1  82/10/13  16:07:56  wft  * fixed type of variables receiving from getc() (char -> int).  */
end_comment

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsbaseid
index|[]
init|=
name|RCSBASE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|partialno
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getcaller
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*get login of caller                   */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern        free(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*generate delta numbers                */
end_comment

begin_function_decl
specifier|extern
name|int
name|countnumflds
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|compartial
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|expandsym
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*get numeric name of a revision        */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfullRCSname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*get full path name of RCS file        */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next input character                  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Klog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Ktext
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|partime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|maketime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*convert parsed time to unix time.     */
end_comment

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*convert unixtime into a tm-structure  */
end_comment

begin_function_decl
specifier|extern
name|int
name|pairfilenames
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file                       */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new RCS file                         */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether input should be    */
end_comment

begin_comment
comment|/* echoed to frewrite */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error counter                        */
end_comment

begin_decl_stmt
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|caller
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* caller's login;                    */
end_comment

begin_decl_stmt
name|int
name|descflag
decl_stmt|,
name|selectflag
decl_stmt|,
name|selectop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option to print access list, symbolic  */
end_comment

begin_comment
comment|/* names, descriptive text, locks and */
end_comment

begin_comment
comment|/* Head                               */
end_comment

begin_decl_stmt
name|int
name|onlylockflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option to print only files         */
end_comment

begin_comment
comment|/* with locks			    */
end_comment

begin_decl_stmt
name|int
name|onlyRCSflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option to print only RCS file name */
end_comment

begin_decl_stmt
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether locker option is set       */
end_comment

begin_decl_stmt
name|int
name|revno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of revision chosen          */
end_comment

begin_struct
struct|struct
name|lockers
block|{
comment|/* lockers in locker option; stored   */
name|char
modifier|*
name|login
decl_stmt|;
comment|/* lockerlist                         */
name|struct
name|lockers
modifier|*
name|lockerlink
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stateattri
block|{
comment|/* states in state option; stored in  */
name|char
modifier|*
name|status
decl_stmt|;
comment|/* statelist                          */
name|struct
name|stateattri
modifier|*
name|nextstate
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|authors
block|{
comment|/* login names in author option;      */
name|char
modifier|*
name|login
decl_stmt|;
comment|/* stored in authorlist               */
name|struct
name|authors
modifier|*
name|nextauthor
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Revpairs
block|{
comment|/* revision or branch range in -r     */
name|int
name|numfld
decl_stmt|;
comment|/* option; stored in revlist          */
name|char
modifier|*
name|strtrev
decl_stmt|;
name|char
modifier|*
name|endrev
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|rnext
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Datepairs
block|{
comment|/* date range in -d option; stored in */
name|char
name|strtdate
index|[
name|datelength
index|]
decl_stmt|;
comment|/* duelst and datelist      */
name|char
name|enddate
index|[
name|datelength
index|]
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|dnext
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|Dotstring
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string of numeric revision name    */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Nextdotstring
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next available place of Dotstring  */
end_comment

begin_decl_stmt
name|struct
name|Datepairs
modifier|*
name|datelist
decl_stmt|,
modifier|*
name|duelst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Revpairs
modifier|*
name|revlist
decl_stmt|,
modifier|*
name|Revlst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|branchflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set on -b */
end_comment

begin_decl_stmt
name|struct
name|lockers
modifier|*
name|lockerlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stateattri
modifier|*
name|statelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|authors
modifier|*
name|authorlist
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|Datepairs
modifier|*
name|currdate
decl_stmt|;
name|struct
name|assoc
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|access
modifier|*
name|curaccess
decl_stmt|;
name|struct
name|lock
modifier|*
name|currlock
decl_stmt|;
name|char
modifier|*
name|cmdusage
decl_stmt|;
name|cmdusage
operator|=
literal|"command format:\nrlog -L -R -h -t -b -ddates -l[lockers] -rrevisions -sstates -w[logins] file ..."
expr_stmt|;
name|cmdid
operator|=
literal|"rlog"
expr_stmt|;
name|descflag
operator|=
name|selectflag
operator|=
name|true
expr_stmt|;
name|lockflag
operator|=
name|onlylockflag
operator|=
name|selectop
operator|=
name|false
expr_stmt|;
name|onlyRCSflag
operator|=
name|false
expr_stmt|;
name|lockerlist
operator|=
name|nil
expr_stmt|;
name|authorlist
operator|=
name|nil
expr_stmt|;
name|statelist
operator|=
name|nil
expr_stmt|;
name|Revlst
operator|=
name|revlist
operator|=
name|nil
expr_stmt|;
name|branchflag
operator|=
name|false
expr_stmt|;
name|duelst
operator|=
name|datelist
operator|=
name|nil
expr_stmt|;
name|caller
operator|=
name|getcaller
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'L'
case|:
name|onlylockflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|onlyRCSflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|selectop
operator|=
name|true
expr_stmt|;
name|lockflag
operator|=
name|true
expr_stmt|;
name|getlocker
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|selectop
operator|=
name|true
expr_stmt|;
name|branchflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|selectop
operator|=
name|true
expr_stmt|;
name|getrevpairs
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|selectop
operator|=
name|true
expr_stmt|;
name|getdatepair
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|selectop
operator|=
name|true
expr_stmt|;
name|getstate
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|selectop
operator|=
name|true
expr_stmt|;
name|getauthor
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
operator|!
name|selectflag
condition|)
name|warn
argument_list|(
literal|"option -t overrides -h"
argument_list|)
expr_stmt|;
else|else
name|descflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|selectflag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|descflag
condition|)
name|warn
argument_list|(
literal|"option -t overrides -h"
argument_list|)
expr_stmt|;
name|descflag
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s\n%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end of option processing */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"No input file\n%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
comment|/* now handle all filenames */
do|do
block|{
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|finptr
operator|=
name|frewrite
operator|=
name|nil
expr_stmt|;
if|if
condition|(
operator|!
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
continue|continue;
comment|/* now RCSfilename contains the name of the RCS file, and finptr              * the file descriptor. Workfilename contains the name of the              * working file.              */
if|if
condition|(
operator|!
name|trysema
argument_list|(
name|RCSfilename
argument_list|,
name|false
argument_list|)
condition|)
goto|goto
name|loopend
goto|;
comment|/*  give up */
comment|/* do nothing if -L is given and there are no locks*/
if|if
condition|(
name|onlylockflag
operator|&&
name|Locks
operator|==
name|nil
condition|)
goto|goto
name|loopend
goto|;
if|if
condition|(
name|onlyRCSflag
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|RCSfilename
argument_list|)
decl_stmt|;
goto|goto
name|loopend
goto|;
block|}
comment|/*   print RCS filename , working filename and optional                  administrative information                         */
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nRCS file:        %s;   "
argument_list|,
name|RCSfilename
argument_list|)
decl_stmt|;
comment|/* could use getfullRCSname() here, but that is very slow */
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Working file:    %s\n"
argument_list|,
name|workfilename
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"head:            %s\n"
argument_list|,
name|Head
operator|==
name|nil
condition|?
literal|""
else|:
name|Head
operator|->
name|num
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"branch:          %s\n"
argument_list|,
name|Dbranch
operator|==
name|nil
condition|?
literal|""
else|:
name|Dbranch
operator|->
name|num
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"locks:         "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
comment|/*  print locker list   */
name|currlock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|currlock
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  %s: %s;"
argument_list|,
name|currlock
operator|->
name|login
argument_list|,
name|currlock
operator|->
name|delta
operator|->
name|num
argument_list|)
decl_stmt|;
name|currlock
operator|=
name|currlock
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|StrictLocks
condition|)
name|VOID
name|fputs
argument_list|(
name|Locks
operator|==
name|nil
condition|?
literal|"  ;  strict"
else|:
literal|"  strict"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"\naccess list:   "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
comment|/*  print access list  */
name|curaccess
operator|=
name|AccessList
expr_stmt|;
while|while
condition|(
name|curaccess
condition|)
block|{
name|VOID
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
name|curaccess
operator|->
name|login
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|curaccess
operator|=
name|curaccess
operator|->
name|nextaccess
expr_stmt|;
block|}
name|VOID
name|fputs
argument_list|(
literal|"\nsymbolic names:"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
comment|/*  print symbolic names   */
name|curassoc
operator|=
name|Symbols
expr_stmt|;
while|while
condition|(
name|curassoc
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  %s: %s;"
argument_list|,
name|curassoc
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|delta
operator|->
name|num
argument_list|)
decl_stmt|;
name|curassoc
operator|=
name|curassoc
operator|->
name|nextassoc
expr_stmt|;
block|}
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\ncomment leader:  \"%s\"\n"
argument_list|,
name|Comment
argument_list|)
decl_stmt|;
name|gettree
argument_list|()
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"total revisions: %d;    "
argument_list|,
name|TotalDeltas
argument_list|)
decl_stmt|;
if|if
condition|(
name|Head
operator|==
name|nil
operator|||
operator|!
name|selectflag
operator|||
operator|!
name|descflag
condition|)
block|{
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
if|if
condition|(
name|descflag
condition|)
name|VOID
name|fputs
argument_list|(
literal|"description:\n"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|getdesc
argument_list|(
name|descflag
argument_list|)
expr_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"=============================================================================\n"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
goto|goto
name|loopend
goto|;
block|}
comment|/*  keep only those locks given by -l */
if|if
condition|(
name|lockflag
condition|)
name|trunclocks
argument_list|()
expr_stmt|;
name|getnumericrev
argument_list|()
expr_stmt|;
comment|/* get numeric revision or branch names */
name|revno
operator|=
literal|0
expr_stmt|;
name|exttree
argument_list|(
name|Head
argument_list|)
expr_stmt|;
comment|/*  get most recently date of the dates pointed by duelst  */
name|currdate
operator|=
name|duelst
expr_stmt|;
while|while
condition|(
name|currdate
condition|)
block|{
name|recentdate
argument_list|(
name|Head
argument_list|,
name|currdate
argument_list|)
expr_stmt|;
name|currdate
operator|=
name|currdate
operator|->
name|dnext
expr_stmt|;
block|}
name|extdate
argument_list|(
name|Head
argument_list|)
expr_stmt|;
comment|/*  reinitialize the date specification list   */
name|currdate
operator|=
name|duelst
expr_stmt|;
while|while
condition|(
name|currdate
condition|)
block|{
name|VOID
name|sprintf
argument_list|(
name|currdate
operator|->
name|strtdate
argument_list|,
name|DATEFORM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|currdate
operator|=
name|currdate
operator|->
name|dnext
expr_stmt|;
block|}
if|if
condition|(
name|selectop
operator|||
operator|(
name|selectflag
operator|&&
name|descflag
operator|)
condition|)
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"selected revisions: %d"
argument_list|,
name|revno
argument_list|)
decl_stmt|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
if|if
condition|(
name|descflag
condition|)
name|VOID
name|fputs
argument_list|(
literal|"description:\n"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|getdesc
argument_list|(
name|descflag
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nexttok
operator|!=
name|EOFILE
operator|)
operator|&&
name|readdeltalog
argument_list|()
condition|)
empty_stmt|;
if|if
condition|(
name|selectflag
operator|&&
name|descflag
operator|&&
name|revno
condition|)
block|{
name|putrunk
argument_list|()
expr_stmt|;
name|putree
argument_list|(
name|Head
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextlex
argument_list|()
operator|,
name|nexttok
operator|!=
name|EOFILE
condition|)
name|fatserror
argument_list|(
literal|"syntax error; expecting EOF"
argument_list|)
expr_stmt|;
block|}
name|VOID
name|fputs
argument_list|(
literal|"=============================================================================\n"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|loopend
label|:
name|VOID
name|fclose
argument_list|(
name|finptr
argument_list|)
decl_stmt|;
block|}
do|while
condition|(
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|exit
argument_list|(
name|nerror
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|putrunk
argument_list|()
end_macro

begin_comment
comment|/*  function:  print revisions chosen, which are in trunk      */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
return|return;
comment|/*  empty tree  */
name|pre
operator|=
name|Head
expr_stmt|;
name|ptr
operator|=
name|Head
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|putadelta
argument_list|(
name|pre
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pre
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
name|putadelta
argument_list|(
name|pre
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putree
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function: print delta tree( not include trunck) in reversed calender                order on each branch                                        */
end_comment

begin_block
block|{
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
name|putree
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|putforest
argument_list|(
name|root
operator|->
name|branches
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putforest
argument_list|(
argument|branchroot
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|branchhead
modifier|*
name|branchroot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function:  print branches that has the same direct ancestor    */
end_comment

begin_block
block|{
if|if
condition|(
name|branchroot
operator|==
name|nil
condition|)
return|return;
name|putforest
argument_list|(
name|branchroot
operator|->
name|nextbranch
argument_list|)
expr_stmt|;
name|putabranch
argument_list|(
name|branchroot
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|putree
argument_list|(
name|branchroot
operator|->
name|hsh
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putabranch
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function  :  print one branch     */
end_comment

begin_block
block|{
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
name|putabranch
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|putadelta
argument_list|(
name|root
argument_list|,
name|root
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putadelta
argument_list|(
name|node
argument_list|,
name|editscript
argument_list|,
name|trunk
argument_list|)
specifier|register
expr|struct
name|hshentry
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hshentry
modifier|*
name|editscript
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trunk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function: print delta node if node->selector is 's'.        */
end_comment

begin_comment
comment|/*      editscript indicates where the editscript is stored     */
end_comment

begin_comment
comment|/*      trunk indicated whether this node is in trunk           */
end_comment

begin_block
block|{
name|struct
name|branchhead
modifier|*
name|newbranch
decl_stmt|;
name|char
modifier|*
name|branchnum
decl_stmt|,
name|branch
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|==
name|nil
operator|)
operator|||
operator|(
name|node
operator|->
name|selector
operator|==
literal|'u'
operator|)
condition|)
return|return;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"----------------------------\n"
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"revision %s        "
argument_list|,
name|node
operator|->
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|lockedby
condition|)
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"locked by: %s;       "
argument_list|,
name|node
operator|->
name|lockedby
argument_list|)
decl_stmt|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"date: "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|VOID
name|PRINTDATE
parameter_list|(
name|stdout
parameter_list|,
name|node
operator|->
name|date
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|VOID
name|PRINTTIME
parameter_list|(
name|stdout
parameter_list|,
name|node
operator|->
name|date
parameter_list|)
function_decl|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|";  author: %s;  "
argument_list|,
name|node
operator|->
name|author
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"state: %s;  "
argument_list|,
name|node
operator|->
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|editscript
condition|)
if|if
condition|(
name|trunk
condition|)
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"lines added/del: %d/%d"
argument_list|,
name|editscript
operator|->
name|deletelns
argument_list|,
name|editscript
operator|->
name|insertlns
argument_list|)
decl_stmt|;
else|else
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"lines added/del: %d/%d"
argument_list|,
name|editscript
operator|->
name|insertlns
argument_list|,
name|editscript
operator|->
name|deletelns
argument_list|)
decl_stmt|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
name|branchnum
operator|=
operator|&
operator|(
name|branch
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|newbranch
operator|=
name|node
operator|->
name|branches
expr_stmt|;
if|if
condition|(
name|newbranch
condition|)
block|{
name|VOID
name|fputs
argument_list|(
literal|"branches:  "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|getbranchno
argument_list|(
name|newbranch
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|branchnum
argument_list|)
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s;  "
argument_list|,
name|branchnum
argument_list|)
decl_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
block|}
name|VOID
name|fputs
parameter_list|(
name|node
operator|->
name|log
parameter_list|,
name|stdout
parameter_list|)
function_decl|;
block|}
end_block

begin_macro
name|readdeltalog
argument_list|()
end_macro

begin_comment
comment|/*  Function : get the log message and skip the text of a deltatext node.  *             Return false if current block does not start with a number.  *             Assumes the current lexeme is not yet in nexttok; does not  *             advance nexttok.  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Klog
argument_list|)
operator|||
operator|(
name|nexttok
operator|!=
name|STRING
operator|)
condition|)
name|fatserror
argument_list|(
literal|"Missing log entry"
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|log
operator|=
name|malloc
argument_list|(
name|logsize
argument_list|)
expr_stmt|;
name|VOID
name|savestring
parameter_list|(
name|Delta
operator|->
name|log
parameter_list|,
name|logsize
parameter_list|)
function_decl|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Ktext
argument_list|)
operator|||
operator|(
name|nexttok
operator|!=
name|STRING
operator|)
condition|)
name|fatserror
argument_list|(
literal|"Missing delta text"
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|insertlns
operator|=
name|Delta
operator|->
name|deletelns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Delta
operator|!=
name|Head
condition|)
name|getscript
argument_list|(
name|Delta
argument_list|)
expr_stmt|;
else|else
name|readstring
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_macro
name|getscript
argument_list|(
argument|Delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function:  read edit script of Delta and count how many lines added  */
end_comment

begin_comment
comment|/*              and deleted in the script                                 */
end_comment

begin_block
block|{
name|int
name|ed
decl_stmt|;
comment|/*  editor command  */
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
while|while
condition|(
operator|(
name|ed
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/*  assume first none white character is command name  */
while|while
condition|(
name|ed
operator|==
literal|'\n'
operator|||
name|ed
operator|==
literal|' '
operator|||
name|ed
operator|==
literal|'\t'
condition|)
name|ed
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|SDELIM
condition|)
break|break;
comment|/*  script text is ended   */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/*  skip blank  */
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"Missing line number in edit script"
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
empty_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
comment|/*  skip blanks  */
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"Incorrect range in edit script"
argument_list|)
expr_stmt|;
break|break;
block|}
name|length
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|length
operator|=
name|length
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ed
condition|)
block|{
case|case
literal|'d'
case|:
name|Delta
operator|->
name|deletelns
operator|+=
name|length
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/*  skip scripted lines  */
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
operator|&&
name|c
operator|!=
name|EOF
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
name|Delta
operator|->
name|insertlns
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|faterror
argument_list|(
literal|"Unknown command in edit script: %c"
argument_list|,
name|ed
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nextc
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|exttree
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function: select revisions , starting with root             */
end_comment

begin_block
block|{
name|struct
name|branchhead
modifier|*
name|newbranch
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
name|extractdelta
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|exttree
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|exttree
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getlocker
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function : get the login names of lockers from command line   */
end_comment

begin_comment
comment|/*              and store in lockerlist.                           */
end_comment

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|lockers
modifier|*
name|newlocker
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|lockerlist
operator|=
name|nil
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newlocker
operator|=
operator|(
expr|struct
name|lockers
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lockers
argument_list|)
argument_list|)
expr_stmt|;
name|newlocker
operator|->
name|lockerlink
operator|=
name|lockerlist
expr_stmt|;
name|newlocker
operator|->
name|login
operator|=
name|argv
expr_stmt|;
name|lockerlist
operator|=
name|newlocker
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
block|}
block|}
end_block

begin_macro
name|getauthor
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function:  get the author's name form command line   */
end_comment

begin_comment
comment|/*              and store in aauthorlist                  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|struct
name|authors
modifier|*
name|newauthor
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|authorlist
operator|=
operator|(
expr|struct
name|authors
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|authors
argument_list|)
argument_list|)
expr_stmt|;
name|authorlist
operator|->
name|login
operator|=
name|caller
expr_stmt|;
name|authorlist
operator|->
name|nextauthor
operator|=
name|nil
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newauthor
operator|=
operator|(
expr|struct
name|authors
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|authors
argument_list|)
argument_list|)
expr_stmt|;
name|newauthor
operator|->
name|nextauthor
operator|=
name|authorlist
expr_stmt|;
name|newauthor
operator|->
name|login
operator|=
name|argv
expr_stmt|;
name|authorlist
operator|=
name|newauthor
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
block|}
block|}
end_block

begin_macro
name|getstate
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function :  get the states of revisions from command line  */
end_comment

begin_comment
comment|/*               and store in statelist                         */
end_comment

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|stateattri
modifier|*
name|newstate
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|warn
argument_list|(
literal|" Missing state attributes after -s options"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newstate
operator|=
operator|(
expr|struct
name|stateattri
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stateattri
argument_list|)
argument_list|)
expr_stmt|;
name|newstate
operator|->
name|nextstate
operator|=
name|statelist
expr_stmt|;
name|newstate
operator|->
name|status
operator|=
name|argv
expr_stmt|;
name|statelist
operator|=
name|newstate
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
block|}
block|}
end_block

begin_macro
name|trunclocks
argument_list|()
end_macro

begin_comment
comment|/*  Function:  Truncate the list of locks to those that are held by the  */
end_comment

begin_comment
comment|/*             id's on lockerlist. Do not truncate if lockerlist empty.  */
end_comment

begin_block
block|{
name|struct
name|lockers
modifier|*
name|plocker
decl_stmt|;
name|struct
name|lock
modifier|*
name|plocked
decl_stmt|,
modifier|*
name|nextlocked
decl_stmt|;
if|if
condition|(
operator|(
name|lockerlist
operator|==
name|nil
operator|)
operator|||
operator|(
name|Locks
operator|==
name|nil
operator|)
condition|)
return|return;
comment|/* shorten Locks to those contained in lockerlist */
name|plocked
operator|=
name|Locks
expr_stmt|;
name|Locks
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|plocked
operator|!=
name|nil
condition|)
block|{
name|plocker
operator|=
name|lockerlist
expr_stmt|;
while|while
condition|(
operator|(
name|plocker
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|plocker
operator|->
name|login
argument_list|,
name|plocked
operator|->
name|login
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|plocker
operator|=
name|plocker
operator|->
name|lockerlink
expr_stmt|;
name|nextlocked
operator|=
name|plocked
operator|->
name|nextlock
expr_stmt|;
if|if
condition|(
name|plocker
operator|!=
name|nil
condition|)
block|{
name|plocked
operator|->
name|nextlock
operator|=
name|Locks
expr_stmt|;
name|Locks
operator|=
name|plocked
expr_stmt|;
block|}
name|plocked
operator|=
name|nextlocked
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|recentdate
argument_list|(
argument|root
argument_list|,
argument|pd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Datepairs
modifier|*
name|pd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function:  Finds the delta that is closest to the cutoff date given by   */
end_comment

begin_comment
comment|/*             pd among the revisions selected by exttree.                   */
end_comment

begin_comment
comment|/*             Successively narrows down the interfal given by pd,           */
end_comment

begin_comment
comment|/*             and sets the strtdate of pd to the date of the selected delta */
end_comment

begin_block
block|{
name|struct
name|branchhead
modifier|*
name|newbranch
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
if|if
condition|(
name|root
operator|->
name|selector
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pd
operator|->
name|strtdate
argument_list|)
operator|>=
literal|0
operator|&&
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pd
operator|->
name|enddate
argument_list|)
operator|<=
literal|0
condition|)
name|VOID
name|strcpy
parameter_list|(
name|pd
operator|->
name|strtdate
parameter_list|,
name|root
operator|->
name|date
parameter_list|)
function_decl|;
block|}
name|recentdate
argument_list|(
name|root
operator|->
name|next
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|recentdate
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|extdate
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function:  select revisions which are in the date range specified     */
end_comment

begin_comment
comment|/*             in duelst  and datelist, start at root                     */
end_comment

begin_block
block|{
name|struct
name|branchhead
modifier|*
name|newbranch
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|pdate
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
if|if
condition|(
name|datelist
operator|||
name|duelst
condition|)
block|{
name|pdate
operator|=
name|datelist
expr_stmt|;
while|while
condition|(
name|pdate
condition|)
block|{
if|if
condition|(
operator|(
name|pdate
operator|->
name|strtdate
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pdate
operator|->
name|strtdate
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pdate
operator|->
name|enddate
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|cmpnum
argument_list|(
name|pdate
operator|->
name|enddate
argument_list|,
name|root
operator|->
name|date
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
name|pdate
operator|=
name|pdate
operator|->
name|dnext
expr_stmt|;
block|}
if|if
condition|(
name|pdate
operator|==
name|nil
condition|)
block|{
name|pdate
operator|=
name|duelst
expr_stmt|;
while|while
condition|(
name|pdate
condition|)
block|{
if|if
condition|(
name|cmpnum
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pdate
operator|->
name|strtdate
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pdate
operator|=
name|pdate
operator|->
name|dnext
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pdate
operator|==
name|nil
condition|)
name|root
operator|->
name|selector
operator|=
literal|'u'
expr_stmt|;
block|}
if|if
condition|(
name|root
operator|->
name|selector
operator|==
literal|'s'
condition|)
name|revno
operator|++
expr_stmt|;
name|extdate
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|extdate
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|extractdelta
argument_list|(
argument|pdelta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|pdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function:  compare information of pdelta to the authorlst, lockerlist, */
end_comment

begin_comment
comment|/*             statelist, revlist and mark 's' on selector if pdelta is    */
end_comment

begin_comment
comment|/*             selected; otherwise, mark 'u'                               */
end_comment

begin_block
block|{
name|struct
name|lock
modifier|*
name|plock
decl_stmt|;
name|struct
name|stateattri
modifier|*
name|pstate
decl_stmt|;
name|struct
name|authors
modifier|*
name|pauthor
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|prevision
decl_stmt|;
name|int
name|length
decl_stmt|;
name|pdelta
operator|->
name|selector
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|authorlist
condition|)
block|{
comment|/*  certain author's revisions wanted only  */
name|pauthor
operator|=
name|authorlist
expr_stmt|;
while|while
condition|(
operator|(
name|pauthor
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pauthor
operator|->
name|login
argument_list|,
name|pdelta
operator|->
name|author
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pauthor
operator|=
name|pauthor
operator|->
name|nextauthor
expr_stmt|;
if|if
condition|(
name|pauthor
operator|==
name|nil
condition|)
block|{
name|pdelta
operator|->
name|selector
operator|=
literal|'u'
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|statelist
condition|)
block|{
comment|/* revisions with certain state wanted  */
name|pstate
operator|=
name|statelist
expr_stmt|;
while|while
condition|(
operator|(
name|pstate
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pstate
operator|->
name|status
argument_list|,
name|pdelta
operator|->
name|state
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pstate
operator|=
name|pstate
operator|->
name|nextstate
expr_stmt|;
if|if
condition|(
name|pstate
operator|==
name|nil
condition|)
block|{
name|pdelta
operator|->
name|selector
operator|=
literal|'u'
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|lockflag
condition|)
block|{
comment|/*  locked revisions   */
name|plock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|plock
operator|&&
operator|(
name|plock
operator|->
name|delta
operator|!=
name|pdelta
operator|)
condition|)
name|plock
operator|=
name|plock
operator|->
name|nextlock
expr_stmt|;
if|if
condition|(
name|plock
operator|==
name|nil
condition|)
block|{
name|pdelta
operator|->
name|selector
operator|=
literal|'u'
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|Revlst
condition|)
block|{
comment|/*  revisions or branches selected  */
name|prevision
operator|=
name|Revlst
expr_stmt|;
while|while
condition|(
name|prevision
operator|!=
name|nil
condition|)
block|{
name|length
operator|=
name|prevision
operator|->
name|numfld
expr_stmt|;
if|if
condition|(
name|length
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
comment|/*  a branch number  */
if|if
condition|(
name|countnumflds
argument_list|(
name|pdelta
operator|->
name|num
argument_list|)
operator|==
operator|(
name|length
operator|+
literal|1
operator|)
condition|)
if|if
condition|(
operator|(
name|compartial
argument_list|(
name|pdelta
operator|->
name|num
argument_list|,
name|prevision
operator|->
name|strtrev
argument_list|,
name|length
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|compartial
argument_list|(
name|prevision
operator|->
name|endrev
argument_list|,
name|pdelta
operator|->
name|num
argument_list|,
name|length
argument_list|)
operator|>=
literal|0
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|countnumflds
argument_list|(
name|pdelta
operator|->
name|num
argument_list|)
operator|==
name|length
condition|)
comment|/*  a revision */
if|if
condition|(
operator|(
name|compartial
argument_list|(
name|pdelta
operator|->
name|num
argument_list|,
name|prevision
operator|->
name|strtrev
argument_list|,
name|length
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|compartial
argument_list|(
name|prevision
operator|->
name|endrev
argument_list|,
name|pdelta
operator|->
name|num
argument_list|,
name|length
argument_list|)
operator|>=
literal|0
operator|)
condition|)
break|break;
name|prevision
operator|=
name|prevision
operator|->
name|rnext
expr_stmt|;
block|}
if|if
condition|(
name|prevision
operator|==
name|nil
condition|)
block|{
name|pdelta
operator|->
name|selector
operator|=
literal|'u'
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|procdate
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|)
name|char
modifier|*
name|target
decl_stmt|,
decl|*
name|source
decl_stmt|;
end_function

begin_comment
comment|/* Function: Parses a free-format date in target, converts it  * into RCS internal format, and stores the result into source.  * Returns target on success, nil otherwise.  */
end_comment

begin_block
block|{
name|long
name|unixtime
decl_stmt|;
name|struct
name|tm
name|parseddate
decl_stmt|,
modifier|*
name|ftm
decl_stmt|;
if|if
condition|(
name|partime
argument_list|(
name|source
argument_list|,
operator|&
name|parseddate
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't parse date/time: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
literal|'\0'
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
operator|(
name|unixtime
operator|=
name|maketime
argument_list|(
operator|&
name|parseddate
argument_list|)
operator|)
operator|==
literal|0L
condition|)
block|{
name|error
argument_list|(
literal|"Inconsistent date/time: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
literal|'\0'
expr_stmt|;
return|return
name|nil
return|;
block|}
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|target
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
decl_stmt|;
return|return
name|target
return|;
block|}
end_block

begin_macro
name|getdatepair
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function:  get time range from command line and store in datelist if    */
end_comment

begin_comment
comment|/*             a time range specified or in duelst if a time spot specified */
end_comment

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|nextdate
decl_stmt|;
name|char
modifier|*
name|rawdate
decl_stmt|;
name|int
name|switchflag
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|warn
argument_list|(
literal|"Missing date/time after -d"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|switchflag
operator|=
name|false
expr_stmt|;
name|nextdate
operator|=
operator|(
expr|struct
name|Datepairs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Datepairs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
comment|/*   case: -d<date   */
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|(
name|nextdate
operator|->
name|strtdate
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|c ==
literal|'>'
argument_list|)
block|{
comment|/*  case:  -d>date     */
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|(
name|nextdate
operator|->
name|enddate
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|switchflag
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|rawdate
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|switchflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|procdate
argument_list|(
name|switchflag
condition|?
name|nextdate
operator|->
name|enddate
else|:
name|nextdate
operator|->
name|strtdate
argument_list|,
name|rawdate
argument_list|)
operator|==
name|nil
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  case: -d date  */
name|VOID
name|strcpy
parameter_list|(
name|nextdate
operator|->
name|enddate
parameter_list|,
name|nextdate
operator|->
name|strtdate
parameter_list|)
function_decl|;
name|VOID
name|sprintf
argument_list|(
name|nextdate
operator|->
name|strtdate
argument_list|,
name|DATEFORM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|duelst
expr_stmt|;
name|duelst
operator|=
name|nextdate
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
block|{
comment|/*   case:   -d date<  or -d  date>; see switchflag */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* second date missing */
if|if
condition|(
name|switchflag
condition|)
operator|*
name|nextdate
operator|->
name|strtdate
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|nextdate
operator|->
name|enddate
operator|=
literal|'\0'
expr_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|datelist
expr_stmt|;
name|datelist
operator|=
name|nextdate
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
block|}
name|rawdate
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|procdate
argument_list|(
name|switchflag
condition|?
name|nextdate
operator|->
name|strtdate
else|:
name|nextdate
operator|->
name|enddate
argument_list|,
name|rawdate
argument_list|)
operator|==
name|nil
condition|)
continue|continue;
name|nextdate
operator|->
name|dnext
operator|=
name|datelist
expr_stmt|;
name|datelist
operator|=
name|nextdate
expr_stmt|;
name|end
label|:
comment|/* 	    VOID printf("startdate: %s; enddate: %s;\n", nextdate->strtdate,nextdate->enddate); */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|';'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
block|}
block|}
end_block

begin_macro
name|getnumericrev
argument_list|()
end_macro

begin_comment
comment|/*  function:  get the numeric name of revisions which stored in revlist  */
end_comment

begin_comment
comment|/*             and then stored the numeric names in Revlst                */
end_comment

begin_comment
comment|/*             if branchflag, also add default branch                     */
end_comment

begin_block
block|{
name|struct
name|Revpairs
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|char
modifier|*
name|temprev
decl_stmt|;
comment|/*  free the previous numeric revision list  */
name|pt
operator|=
name|Revlst
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|rnext
expr_stmt|;
block|}
name|Nextdotstring
operator|=
operator|&
name|Dotstring
index|[
literal|0
index|]
expr_stmt|;
comment|/* reset buffer */
name|Revlst
operator|=
name|nil
expr_stmt|;
name|ptr
operator|=
name|revlist
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|pt
operator|=
operator|(
expr|struct
name|Revpairs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Revpairs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|numfld
operator|==
literal|1
condition|)
block|{
comment|/*  case:  -r rev   */
if|if
condition|(
operator|(
name|flag
operator|=
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
name|Nextdotstring
argument_list|)
operator|)
operator|==
name|true
condition|)
block|{
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|Nextdotstring
argument_list|)
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|pt
operator|->
name|endrev
operator|=
name|Nextdotstring
expr_stmt|;
while|while
condition|(
operator|*
name|Nextdotstring
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|numfld
operator|==
literal|2
condition|)
block|{
comment|/*  case: -r rev-   */
if|if
condition|(
operator|(
name|flag
operator|=
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
name|Nextdotstring
argument_list|)
operator|)
operator|==
name|true
condition|)
block|{
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|Nextdotstring
argument_list|)
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|Nextdotstring
expr_stmt|;
while|while
condition|(
operator|*
name|Nextdotstring
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|pt
operator|->
name|endrev
operator|=
name|Nextdotstring
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|numfld
operator|>
literal|2
condition|)
name|choptail
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|)
expr_stmt|;
operator|*
name|Nextdotstring
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|numfld
operator|==
literal|3
condition|)
block|{
comment|/*  case: -r -rev   */
if|if
condition|(
operator|(
name|flag
operator|=
name|expandsym
argument_list|(
name|ptr
operator|->
name|endrev
argument_list|,
name|Nextdotstring
argument_list|)
operator|)
operator|==
name|true
condition|)
block|{
name|pt
operator|->
name|endrev
operator|=
name|Nextdotstring
expr_stmt|;
while|while
condition|(
operator|*
name|Nextdotstring
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|pt
operator|->
name|endrev
argument_list|)
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|Nextdotstring
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|numfld
operator|==
literal|2
condition|)
operator|*
name|Nextdotstring
operator|++
operator|=
literal|'1'
expr_stmt|;
else|else
name|choptail
argument_list|(
name|pt
operator|->
name|endrev
argument_list|)
expr_stmt|;
operator|*
name|Nextdotstring
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|Nextdotstring
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|Nextdotstring
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*   case:  -r rev1-rev2   */
if|if
condition|(
operator|(
name|flag
operator|=
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
name|Nextdotstring
argument_list|)
operator|)
operator|==
name|true
condition|)
block|{
name|pt
operator|->
name|strtrev
operator|=
name|Nextdotstring
expr_stmt|;
while|while
condition|(
operator|*
name|Nextdotstring
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|flag
operator|=
name|expandsym
argument_list|(
name|ptr
operator|->
name|endrev
argument_list|,
name|Nextdotstring
argument_list|)
operator|)
operator|==
name|true
condition|)
block|{
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|)
expr_stmt|;
name|pt
operator|->
name|endrev
operator|=
name|Nextdotstring
expr_stmt|;
while|while
condition|(
operator|*
name|Nextdotstring
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|flag
operator|=
name|checkrevpair
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|,
name|pt
operator|->
name|endrev
argument_list|)
operator|)
operator|==
name|true
condition|)
comment|/*  switch pt->strtrev with pt->endrev, if pt->strtrev> pt->endre  */
if|if
condition|(
name|compartial
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|,
name|pt
operator|->
name|endrev
argument_list|,
name|pt
operator|->
name|numfld
argument_list|)
operator|>
literal|0
condition|)
block|{
name|temprev
operator|=
name|pt
operator|->
name|strtrev
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|pt
operator|->
name|endrev
expr_stmt|;
name|pt
operator|->
name|endrev
operator|=
name|temprev
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|pt
operator|->
name|rnext
operator|=
name|Revlst
expr_stmt|;
name|Revlst
operator|=
name|pt
expr_stmt|;
block|}
else|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|rnext
expr_stmt|;
block|}
comment|/* Now take care of branchflag */
if|if
condition|(
name|branchflag
condition|)
block|{
name|flag
operator|=
name|true
expr_stmt|;
name|pt
operator|=
operator|(
expr|struct
name|Revpairs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Revpairs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dbranch
condition|)
block|{
name|pt
operator|->
name|strtrev
operator|=
name|pt
operator|->
name|endrev
operator|=
name|Dbranch
operator|->
name|num
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|Head!=nil
argument_list|)
block|{
name|pt
operator|->
name|strtrev
operator|=
name|pt
operator|->
name|endrev
operator|=
comment|/* branch number of head */
name|partialno
argument_list|(
name|Nextdotstring
argument_list|,
name|Head
operator|->
name|num
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|Nextdotstring
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
else|else
name|flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
comment|/* prepend new node */
name|pt
operator|->
name|rnext
operator|=
name|Revlst
expr_stmt|;
name|Revlst
operator|=
name|pt
expr_stmt|;
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|checkrevpair
argument_list|(
argument|num1
argument_list|,
argument|num2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|num1
decl_stmt|,
modifier|*
name|num2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function:  check whether num1, num2 are legal pair,i.e.     only the last field are different and have same number of     feilds( if length<= 2, may be different if first field)   */
end_comment

begin_block
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|length
operator|=
name|countnumflds
argument_list|(
name|num1
argument_list|)
operator|)
operator|!=
name|countnumflds
argument_list|(
name|num2
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|" Invalid branch or revision pair %s : %s"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|length
operator|>
literal|2
condition|)
if|if
condition|(
name|compartial
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid branch or revision pair %s : %s"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_expr_stmt
name|getrevpairs
argument_list|(
name|argv
argument_list|)
specifier|register
name|char
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  function:  get revision or branch range from command line, and   */
end_comment

begin_comment
comment|/*             store in revlist                                      */
end_comment

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|nextrevpair
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|warn
argument_list|(
literal|" Missing revision or branch number after -r"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
name|nextrevpair
operator|=
operator|(
expr|struct
name|Revpairs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Revpairs
argument_list|)
argument_list|)
expr_stmt|;
name|nextrevpair
operator|->
name|rnext
operator|=
name|revlist
expr_stmt|;
name|revlist
operator|=
name|nextrevpair
expr_stmt|;
name|nextrevpair
operator|->
name|numfld
operator|=
name|nil
expr_stmt|;
name|nextrevpair
operator|->
name|strtrev
operator|=
name|nil
expr_stmt|;
name|nextrevpair
operator|->
name|endrev
operator|=
name|nil
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
comment|/*  case: -r -rev  or -r<rev  */
name|flag
operator|=
name|true
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
block|}
else|else
block|{
name|nextrevpair
operator|->
name|strtrev
operator|=
name|argv
expr_stmt|;
comment|/*   get a revision or branch name  */
while|while
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'<'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
comment|/*  case: rev  */
name|nextrevpair
operator|->
name|numfld
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|argv
operator|)
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
block|{
comment|/*  case: rev_  */
name|nextrevpair
operator|->
name|numfld
operator|=
literal|2
expr_stmt|;
continue|continue;
block|}
block|}
name|nextrevpair
operator|->
name|endrev
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|';'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|error
argument_list|(
literal|"seperator expected near %s"
argument_list|,
name|nextrevpair
operator|->
name|endrev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
empty_stmt|;
name|revlist
operator|=
name|nextrevpair
operator|->
name|rnext
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|flag
condition|)
comment|/*  case:  -rev   */
name|nextrevpair
operator|->
name|numfld
operator|=
literal|3
expr_stmt|;
else|else
comment|/*   rev1-rev2  appears  */
name|nextrevpair
operator|->
name|numfld
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|choptail
argument_list|(
argument|strhead
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|strhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   function : chop off the last field of a branch or a revision number  */
end_comment

begin_block
block|{
name|char
modifier|*
name|pt
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|pt
operator|=
name|Nextdotstring
operator|-
literal|1
init|;
name|pt
operator|!=
name|strhead
operator|&&
operator|*
name|pt
operator|!=
literal|'.'
condition|;
name|pt
operator|--
control|)
empty_stmt|;
for|for
control|(
name|sp
operator|=
name|strhead
init|;
name|sp
operator|<
name|pt
condition|;
name|sp
operator|++
control|)
operator|*
name|Nextdotstring
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
block|}
end_block

end_unit

