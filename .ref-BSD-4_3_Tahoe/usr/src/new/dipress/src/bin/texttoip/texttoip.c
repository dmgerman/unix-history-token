begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Interpress utility  *  *  Written for Xerox Corporation by William LeFebvre  *  *  6-June-1984  *  * Copyright (c) 1984, 1985, 1986 Xerox Corp.  *  * HISTORY  * 13-Jan-86  lee at Xerox, WRC  *	Changed on strcmpn to strncmp.  *  * 01-Dec-85  lee at Xerox, WRC  *	Linted.  *  *  * 8-apr-85  ed flint	add conditional compilation for vax11-c (vms)  *				add error condition for sbrk failure  *  * 30-aug-85  ed flint	eliminate compiler warning on check of sbreak return  */
end_comment

begin_comment
comment|/*  *  texttoip - convert a textual representation of an interpress file (such as  *  	       produced by iptotext) to an encoded interpress format.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_include
include|#
directive|include
include|stdio
end_include

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"texttoken.h"
end_include

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"texttoken.h"
end_include

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|long
name|yylval_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yylval_charP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipress_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outputname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|long
name|longVal0
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|int
name|pushed_token
init|=
literal|0
decl_stmt|;
name|char
name|first_file
init|=
literal|1
decl_stmt|;
comment|/* look for an output option */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-o"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's there -- get the file name */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|>
literal|2
condition|)
block|{
name|outputname
operator|=
operator|&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|outputname
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* "-o" with no file name -- strangeness, so give up */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* default output -- use stdout if it is NOT a terminal */
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* use default filename */
name|outputname
operator|=
literal|"intertext.ip"
expr_stmt|;
block|}
else|else
block|{
comment|/* use standard output */
name|outputname
operator|=
name|NULL
expr_stmt|;
name|ipress_file
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* open the output file */
ifdef|#
directive|ifdef
name|vax11c
if|if
condition|(
name|outputname
operator|!=
name|NULL
operator|&&
operator|(
name|ipress_file
operator|=
name|creat
argument_list|(
name|outputname
argument_list|,
literal|0
argument_list|,
literal|"rfm=udf"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|outputname
operator|!=
name|NULL
operator|&&
operator|(
name|ipress_file
operator|=
name|open
argument_list|(
name|outputname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|outputname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* main loop */
for|for
control|(
name|arg
operator|=
literal|1
init|;
name|arg
operator|<
name|argc
condition|;
name|arg
operator|++
control|)
block|{
comment|/* open next file for reading */
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* set file dependent stuff */
name|filename
operator|=
name|argv
index|[
name|arg
index|]
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
comment|/* get header */
if|if
condition|(
name|first_file
condition|)
block|{
if|if
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|==
name|T_header
condition|)
block|{
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_string
condition|)
block|{
name|terror
argument_list|(
literal|"Header was not a string, using standard header"
argument_list|)
expr_stmt|;
name|ip_select
argument_list|(
name|ipress_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip_raw_select
argument_list|(
name|ipress_file
argument_list|)
expr_stmt|;
name|append_bytes
argument_list|(
name|strlen
argument_list|(
name|yylval_charP
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|yylval_charP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|terror
argument_list|(
literal|"No header for file, using standard header"
argument_list|)
expr_stmt|;
name|ip_select
argument_list|(
name|ipress_file
argument_list|)
expr_stmt|;
name|pushed_token
operator|=
name|token
expr_stmt|;
block|}
name|first_file
operator|=
literal|0
expr_stmt|;
comment|/* gobble the newline */
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_newline
condition|)
block|{
name|terror
argument_list|(
literal|"newline expected"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|==
name|T_header
condition|)
block|{
comment|/* gobble stuff */
operator|(
name|void
operator|)
name|yylex
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pushed_token
operator|=
name|token
expr_stmt|;
block|}
block|}
while|while
condition|(
name|pushed_token
operator|==
literal|0
condition|?
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
literal|0
else|:
operator|(
name|token
operator|=
name|pushed_token
operator|,
name|pushed_token
operator|=
literal|0
operator|,
literal|1
operator|)
condition|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|T_header
case|:
name|terror
argument_list|(
literal|"Stray header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_seq_comment
case|:
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_string
condition|)
block|{
name|terror
argument_list|(
literal|"Comment was not a string"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AppendComment
argument_list|(
name|yylval_charP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_seq_identifier
case|:
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_identifier
condition|)
block|{
name|terror
argument_list|(
literal|"Identifier is invalid"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AppendIdentifier
argument_list|(
name|yylval_charP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_seq_insert_file
case|:
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_string
condition|)
block|{
name|terror
argument_list|(
literal|"Insert file is not a string"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AppendInsertFile
argument_list|(
name|yylval_charP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_seq_integer
case|:
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_number
condition|)
block|{
name|terror
argument_list|(
literal|"Integer is invalid"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|append_integer_sequence
argument_list|(
name|yylval_long
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_seq_rational
case|:
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_number
condition|)
block|{
name|terror
argument_list|(
literal|"Rational numerator is invalid"
argument_list|)
expr_stmt|;
break|break;
block|}
name|longVal0
operator|=
name|yylval_long
expr_stmt|;
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_character
operator|||
operator|(
name|char
operator|)
name|yylval_long
operator|!=
literal|'/'
condition|)
block|{
name|terror
argument_list|(
literal|"Rational separator invalid"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_number
condition|)
block|{
name|terror
argument_list|(
literal|"Rational denominator is invalid"
argument_list|)
expr_stmt|;
break|break;
block|}
name|AppendRational
argument_list|(
name|longVal0
argument_list|,
operator|(
name|long
operator|)
name|yylval_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_seq_string
case|:
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_string
condition|)
block|{
name|terror
argument_list|(
literal|"String is invalid"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AppendString1
argument_list|(
name|yylval_charP
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Pixel vector sequences */
case|case
name|T_seq_apv
case|:
name|get_pixel_vector
argument_list|(
name|sequenceAdaptivePixelVector
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_seq_cpv
case|:
name|get_pixel_vector
argument_list|(
name|sequenceCompressedPixelVector
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_seq_ppv
case|:
name|get_pixel_vector
argument_list|(
name|sequencePackedPixelVector
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_number
case|:
name|AppendInteger
argument_list|(
name|yylval_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_operator
case|:
name|AppendOp
argument_list|(
operator|(
name|int
operator|)
name|yylval_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_newline
case|:
name|line_number
operator|++
expr_stmt|;
break|break;
case|case
name|T_string
case|:
name|terror
argument_list|(
literal|"Stray string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_identifier
case|:
name|terror
argument_list|(
literal|"Stray string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_character
case|:
name|terror
argument_list|(
literal|"Stray character"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ip_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|get_pixel_vector
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|token
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|T_character
operator|||
name|yylval_long
operator|!=
literal|'['
condition|)
block|{
name|terror
argument_list|(
literal|"Bad pixel vector, expected '['"
argument_list|)
expr_stmt|;
return|return;
block|}
name|radix
operator|=
literal|16
expr_stmt|;
comment|/* allocate space to hold the data */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|300000
argument_list|)
expr_stmt|;
comment|/*  too large for PDP-11's */
if|if
condition|(
name|buffer
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ncannot allocate room for pixel array\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ptr
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
name|T_character
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|T_newline
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|yylval_long
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|yylval_long
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|yylex
argument_list|()
expr_stmt|;
comment|/* gobble trailing newline */
name|append_Sequence
argument_list|(
name|type
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|radix
operator|=
literal|10
expr_stmt|;
block|}
end_block

begin_macro
name|terror
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %d: %s\n"
argument_list|,
name|filename
argument_list|,
name|line_number
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_comment
comment|/*  *  this is needed for the parsing software produced by lex  */
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

