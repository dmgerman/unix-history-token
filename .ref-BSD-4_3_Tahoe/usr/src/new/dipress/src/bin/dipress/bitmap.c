begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1984, 1985, 1986 Xerox Corp.  *  *  bitmap - routines that help build a bitmap of a graphical image  *  *  These are primarily used to implement all of the drawing primitives  *  (except for lines)  *  *  HISTORY  * 13-Aug-86  Lee Moore (lee) at Xerox Webster Research Center  *	Rather than outputing an error message for devices that can't print  *	big pixel arrays, the code now breaks up large pixel arrays into  *	smaller ones.  *  * 04-Mar-86  Lee Moore (lee) at Xerox Webster Research Center  *	Put in code to check the output device type.  Right now, if  *	a bitmap is allocated that won't print then a warning message  *	is produced.  *  *  28-aug-85 John Mellor-Crummey  *	added flush_bitmap which is used instead  *	of print_bitmap if current page is not outputted  *  *  17-jun-85  ed flint  *	bitmap width(bm_width) must be multiple of 32  *	bits for print services 12 (?)  *  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_include
include|#
directive|include
file|"operator.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_define
define|#
directive|define
name|No
value|0
end_define

begin_define
define|#
directive|define
name|Yes
value|1
end_define

begin_decl_stmt
specifier|extern
name|int
name|drawidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|drawscale
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|local
name|int
name|minx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|miny
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|maxx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|maxy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|bm_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in real bytes */
end_comment

begin_decl_stmt
name|local
name|int
name|bm_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|char
modifier|*
name|bitmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|char
name|bm_active
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|scale_x
parameter_list|(
name|x
parameter_list|)
value|x = (double)x * drawscale
end_define

begin_define
define|#
directive|define
name|scale_y
parameter_list|(
name|y
parameter_list|)
value|y = (double)y * drawscale
end_define

begin_comment
comment|/*  *  new_bitmap(x1, y1, x2, y2) - prepare for a new bitmap, the extreme x and y  *				 values are x1, y1, x2, and y2.  */
end_comment

begin_macro
name|new_bitmap
argument_list|(
argument|stroke
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stroke
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|new_size
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"new_bitmap(%d, %d, %d, %d, %d)\n"
argument_list|,
name|stroke
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|drawidth
operator|=
name|stroke
operator|*
name|drawscale
expr_stmt|;
name|scale_x
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|scale_y
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|scale_x
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|scale_y
argument_list|(
name|y2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"after scaling: width %d: %d, %d and %d, %d\n"
argument_list|,
name|drawidth
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* insure that x1, y1 is the lower left */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exchanging pairs ... "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|x1
expr_stmt|;
comment|/* exchange x1 and x2 */
name|x1
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|y1
expr_stmt|;
comment|/* exchange y1 and y2 */
name|y1
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|temp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"now %d, %d and %d, %d\n"
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* adjust the extremes to allow for pen thickness */
name|temp
operator|=
operator|(
name|drawidth
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|x1
operator|-=
name|temp
expr_stmt|;
name|y1
operator|-=
name|temp
expr_stmt|;
name|x2
operator|+=
name|temp
expr_stmt|;
name|y2
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|bm_active
operator|||
operator|!
operator|(
name|x1
operator|>=
name|minx
operator|&&
name|y1
operator|>=
name|miny
operator|&&
name|x2
operator|<=
name|maxx
operator|&&
name|y2
operator|<=
name|maxy
operator|)
condition|)
block|{
comment|/* we need to set up a new map */
comment|/* but first, print the old one if it is still active */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setting up new map, bm_active is %d\n"
argument_list|,
name|bm_active
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_bitmap
argument_list|()
expr_stmt|;
name|minx
operator|=
name|x1
expr_stmt|;
name|miny
operator|=
name|y1
expr_stmt|;
name|maxx
operator|=
name|x2
expr_stmt|;
name|maxy
operator|=
name|y2
expr_stmt|;
name|bm_width
operator|=
operator|(
name|y2
operator|-
name|y1
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* print services 12 (?) wants packed pixel vectors to produce each */
comment|/* scan line as a mutliple of 32 bits, this is backward compatible  */
comment|/* with previous versions of services				    */
comment|/* (the previous version of bitmap produced 16 bit multiples which  */
comment|/* will NOT work with services 12 (?) and beyond)		    */
if|if
condition|(
name|bm_width
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|bm_width
operator|=
name|bm_width
operator|+
operator|(
literal|4
operator|-
name|bm_width
operator|%
literal|4
operator|)
expr_stmt|;
block|}
name|new_size
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
name|bm_width
expr_stmt|;
if|if
condition|(
name|new_size
operator|>
name|bm_size
condition|)
block|{
comment|/* need to allocate a larger area for the bitmap */
if|if
condition|(
name|bitmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bitmap
argument_list|)
expr_stmt|;
comment|/* check to see that this bitmap is printable */
if|if
condition|(
name|new_size
operator|+
literal|4
operator|>=
operator|(
literal|1L
operator|<<
literal|16
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|IPDeviceType
operator|==
name|Xerox8044_Services8
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dipress: bitmap bigger than 2^16-1 -- won't print on a Xerox 8044 under services 8.0\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IPDeviceType
operator|==
name|Xerox8044_Services9
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dipress: bitmap of %d is bigger than 2^16-1 -- won't print on a Xerox 8044 under services 9.0\n"
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IPDeviceType
operator|==
name|Xerox8044_Services10
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dipress: bitmap of %d is bigger than 2^16-1 -- won't print on a Xerox 8044 under services 10.0\n"
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bitmap
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|new_size
argument_list|)
argument_list|)
expr_stmt|;
name|bm_size
operator|=
name|new_size
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bm_width %d, bm_size %d\n"
argument_list|,
name|bm_width
argument_list|,
name|bm_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bitmap
argument_list|,
name|bm_size
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|set_pixel
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mask
decl_stmt|;
name|int
name|half_drawidth
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ybit
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|scale_x
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|scale_y
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|bm_active
operator|=
name|Yes
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|x
operator|<
name|minx
operator|||
name|x
operator|>
name|maxx
operator|||
name|y
operator|<
name|miny
operator|||
name|y
operator|>
name|maxy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"point off map: (%d, %d)\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|x
operator|-=
name|minx
expr_stmt|;
name|y
operator|=
name|maxy
operator|-
name|y
expr_stmt|;
comment|/* yes, it works */
name|half_drawidth
operator|=
name|drawidth
operator|>>
literal|1
expr_stmt|;
comment|/* Remember the bitmap is built in increasing y */
comment|/* draw the "x" line vertically */
name|mask
operator|=
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|007
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|x
operator|-
name|half_drawidth
operator|)
operator|*
name|bm_width
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
operator|+
name|bitmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drawidth
condition|;
name|i
operator|++
operator|,
name|ptr
operator|+=
name|bm_width
control|)
block|{
operator|*
name|ptr
operator||=
name|mask
expr_stmt|;
block|}
comment|/* draw the "y" line horizontally */
name|y
operator|-=
name|half_drawidth
expr_stmt|;
name|ptr
operator|=
operator|(
name|x
operator|*
name|bm_width
operator|)
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
operator|+
name|bitmap
expr_stmt|;
name|ybit
operator|=
name|y
operator|&
literal|007
expr_stmt|;
name|temp
operator|=
name|ybit
operator|+
name|drawidth
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|8
condition|)
block|{
comment|/* special case -- less than one byte */
operator|*
name|ptr
operator||=
operator|(
literal|0xff
operator|>>
name|ybit
operator|)
operator|^
operator|(
literal|0xff
operator|>>
name|temp
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator||=
operator|(
literal|0xff
operator|>>
name|ybit
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|drawidth
operator|-
literal|8
operator|+
name|ybit
init|;
name|i
operator|>
literal|8
condition|;
name|i
operator|-=
literal|8
control|)
block|{
operator|*
operator|++
name|ptr
operator||=
literal|0xff
expr_stmt|;
block|}
operator|*
operator|++
name|ptr
operator||=
operator|~
operator|(
literal|0xff
operator|>>
name|i
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|flush_bitmap
argument_list|()
end_macro

begin_block
block|{
name|bm_active
operator|=
name|No
expr_stmt|;
block|}
end_block

begin_macro
name|print_bitmap
argument_list|()
end_macro

begin_block
block|{
name|int
name|bytesPerScanLine
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bm_active
condition|)
block|{
comment|/* don't bother */
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG2
comment|/* debugging version for now */
name|ptr
operator|=
name|bitmap
expr_stmt|;
for|for
control|(
name|x
operator|=
name|minx
init|;
name|x
operator|<=
name|maxx
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|y
operator|=
name|miny
init|;
name|y
operator|<=
name|maxy
condition|;
name|y
operator|+=
literal|8
operator|,
name|ptr
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0x80
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|&
name|i
condition|)
block|{
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bytesPerScanLine
operator|=
name|bm_width
expr_stmt|;
comment|/* inside a dosavesimplebody to preserve transform */
name|AppendOp
argument_list|(
name|OP_dosavesimplebody
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
comment|/* set the transform to the right scale and position */
comment|/* transform must scale back to micas and position bitmap */
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|minx
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
call|(
name|long
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|11
operator|*
name|INCH
operator|*
name|drawscale
argument_list|)
operator|-
name|maxy
argument_list|)
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_translate
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_scale
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_concat
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IPDeviceType
condition|)
block|{
case|case
name|Xerox8044_Services8
case|:
case|case
name|Xerox8044_Services9
case|:
case|case
name|Xerox8044_Services10
case|:
block|{
name|unsigned
name|char
modifier|*
name|bitmapP
decl_stmt|;
name|int
name|numberOfScanLines
decl_stmt|,
name|pixelsPerScanLine
decl_stmt|,
name|scanLinesPerStripe
decl_stmt|,
name|bytesPerStripe
decl_stmt|,
name|numberOfFullStripes
decl_stmt|,
name|scanLinesRemaining
decl_stmt|,
name|n
decl_stmt|;
name|numberOfScanLines
operator|=
name|maxx
operator|-
name|minx
expr_stmt|;
name|pixelsPerScanLine
operator|=
name|bytesPerScanLine
operator|<<
literal|3
expr_stmt|;
name|scanLinesPerStripe
operator|=
operator|(
literal|64
operator|*
literal|1024
operator|-
literal|4
operator|-
literal|16
operator|)
operator|/
name|bytesPerScanLine
expr_stmt|;
name|bytesPerStripe
operator|=
name|scanLinesPerStripe
operator|*
name|bytesPerScanLine
expr_stmt|;
name|numberOfFullStripes
operator|=
name|numberOfScanLines
operator|/
name|scanLinesPerStripe
expr_stmt|;
name|scanLinesRemaining
operator|=
name|numberOfScanLines
operator|%
name|scanLinesPerStripe
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|bitmapP
operator|=
name|bitmap
init|;
name|n
operator|<
name|numberOfFullStripes
condition|;
name|n
operator|++
operator|,
name|bitmapP
operator|+=
name|bytesPerStripe
control|)
block|{
name|WritePixelArray
argument_list|(
name|bitmapP
argument_list|,
name|scanLinesPerStripe
argument_list|,
name|pixelsPerScanLine
argument_list|)
expr_stmt|;
comment|/* 		 * position the next stripe.  I tried going a setXRel followed 		 * by a trans but this cause strange things to happen on 		 * an 8044 running services 9.0 		 */
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|scanLinesPerStripe
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_translate
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scanLinesRemaining
operator|!=
literal|0
condition|)
name|WritePixelArray
argument_list|(
name|bitmapP
argument_list|,
name|scanLinesRemaining
argument_list|,
name|pixelsPerScanLine
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Xerox9700_V10
case|:
default|default:
name|WritePixelArray
argument_list|(
name|bitmap
argument_list|,
name|maxx
operator|-
name|minx
argument_list|,
name|bytesPerScanLine
operator|<<
literal|3
argument_list|)
expr_stmt|;
block|}
name|AppendOp
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
comment|/* no longer active, now is it? */
name|bm_active
operator|=
name|No
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|WritePixelArray
argument_list|(
argument|pixelArray
argument_list|,
argument|xPixels
argument_list|,
argument|yPixels
argument_list|)
name|unsigned
name|char
operator|*
name|pixelArray
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|xPixels
decl_stmt|,
name|yPixels
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|bytesPerScanLine
decl_stmt|,
name|pixelArraySize
decl_stmt|;
comment|/* in bytes */
name|bytesPerScanLine
operator|=
operator|(
name|yPixels
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|pixelArraySize
operator|=
name|xPixels
operator|*
name|bytesPerScanLine
expr_stmt|;
comment|/* build the pixel array */
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|xPixels
argument_list|)
expr_stmt|;
comment|/* xPixels */
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|yPixels
argument_list|)
expr_stmt|;
comment|/* yPixels */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* samplesPerPixel */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* maxSampleValue */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* samplesInterleaved */
name|Translate
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/* (null) transform */
name|AppendPPVector
argument_list|(
name|pixelArraySize
argument_list|,
literal|1
argument_list|,
name|yPixels
argument_list|,
name|pixelArray
argument_list|)
expr_stmt|;
comment|/* make the pixel array */
name|AppendOp
argument_list|(
name|OP_makepixelarray
argument_list|)
expr_stmt|;
comment|/* mask it */
name|AppendOp
argument_list|(
name|OP_maskpixel
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*-----------------------------------------------------------------------------  *	Gremlin additions:  This should be in a separate file.  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------------  *	drawPolygon(buffer, WantBorder)  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<vfont.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_expr_stmt
specifier|static
name|StippleDesFD
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|StippleChoice
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|fileDes
decl_stmt|;
name|int
name|member
decl_stmt|;
name|int
name|maxSize
decl_stmt|;
struct|struct
block|{
name|char
name|prelude
index|[
literal|4
index|]
decl_stmt|;
name|short
name|bits
index|[
literal|16
index|]
decl_stmt|;
block|}
name|ppv
struct|;
comment|/* In Services<= 10  max sampled black is  					at most 16 x 16 */
name|struct
name|header
name|header
decl_stmt|;
name|struct
name|dispatch
name|dispatch
decl_stmt|;
block|}
name|curStipple
struct|;
end_struct

begin_macro
name|iPdrawPolygon
argument_list|(
argument|s
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
index|[
name|maxPointsInPolygon
index|]
decl_stmt|,
name|y
index|[
name|maxPointsInPolygon
index|]
decl_stmt|;
name|int
name|stippleMember
decl_stmt|,
name|strokeWidth
init|=
literal|254
decl_stmt|;
specifier|extern
name|int
name|hor_pos
decl_stmt|,
name|ver_pos
decl_stmt|,
name|lineThickness
decl_stmt|;
name|int
name|xi
decl_stmt|,
name|yi
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|numPoints
decl_stmt|;
name|float
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|,
name|t
decl_stmt|,
name|dis
decl_stmt|;
name|float
name|euclidDist
parameter_list|()
function_decl|;
name|char
name|more
decl_stmt|;
comment|/* skip all leading white space */
while|while
condition|(
name|white
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return;
if|if
condition|(
name|readNumber
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|stippleMember
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* read in the x y pairs of points for the polygon */
for|for
control|(
name|numPoints
operator|=
literal|0
init|;
name|numPoints
operator|<
name|maxPointsInPolygon
condition|;
control|)
block|{
name|x
index|[
name|numPoints
index|]
operator|=
name|hor_pos
expr_stmt|;
name|more
operator|=
name|readNumber
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|xi
argument_list|)
expr_stmt|;
name|y
index|[
name|numPoints
index|]
operator|=
operator|(
literal|11
operator|*
name|INCH
operator|)
operator|-
name|ver_pos
expr_stmt|;
name|more
operator|*=
name|readNumber
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|yi
argument_list|)
expr_stmt|;
name|hor_pos
operator|+=
name|xi
expr_stmt|;
name|ver_pos
operator|+=
name|yi
expr_stmt|;
name|numPoints
operator|++
expr_stmt|;
if|if
condition|(
name|more
operator|==
literal|0
condition|)
break|break;
block|}
name|getStippleMember
argument_list|(
name|stippleMember
argument_list|)
expr_stmt|;
comment|/* Doit */
if|if
condition|(
name|numPoints
operator|<
literal|2
condition|)
return|return;
name|Op
argument_list|(
name|dosavesimplebody
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|beginBody
argument_list|)
expr_stmt|;
comment|/* First, draw outline, if desired */
if|if
condition|(
name|cmd
operator|==
name|drawPolygon
condition|)
block|{
name|AppendRational
argument_list|(
operator|(
name|long
operator|)
name|strokeWidth
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|I_strokeWidth
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|iset
argument_list|)
expr_stmt|;
name|Moveto
argument_list|(
operator|(
name|double
operator|)
name|x
index|[
literal|0
index|]
argument_list|,
operator|(
name|double
operator|)
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numPoints
condition|;
name|j
operator|++
control|)
name|Lineto
argument_list|(
operator|(
name|double
operator|)
name|x
index|[
name|j
index|]
argument_list|,
operator|(
name|double
operator|)
name|y
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|Lineto
argument_list|(
operator|(
name|double
operator|)
name|x
index|[
literal|0
index|]
argument_list|,
operator|(
name|double
operator|)
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|maskstroke
argument_list|)
expr_stmt|;
block|}
comment|/* Make Sampled Color */
name|AppendInteger
argument_list|(
literal|16L
argument_list|)
expr_stmt|;
comment|/* xPixels */
name|AppendInteger
argument_list|(
literal|16L
argument_list|)
expr_stmt|;
comment|/* yPixels */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* samplesPerPixel */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* maxSampleValue */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* samplesInterleaved */
comment|/*AppendRational((long) 2*strokeWidth, 10); fails in serv< 11 */
name|AppendRational
argument_list|(
operator|(
name|long
operator|)
name|strokeWidth
argument_list|,
literal|30
argument_list|)
expr_stmt|;
comment|/* 1 bit per 300th inch */
name|Op
argument_list|(
name|scale
argument_list|)
expr_stmt|;
comment|/* transform for color */
comment|/* spew out the packed pixel vector */
name|append_Sequence
argument_list|(
name|sequencePackedPixelVector
argument_list|,
literal|32
operator|+
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|curStipple
operator|.
name|ppv
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|makepixelarray
argument_list|)
expr_stmt|;
comment|/* make the pixel array */
name|AppendInteger
argument_list|(
literal|4L
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|iget
argument_list|)
expr_stmt|;
comment|/* current transformation */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|makesampledblack
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|13L
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|iset
argument_list|)
expr_stmt|;
comment|/* Set Color */
comment|/* Print Polygon */
name|Moveto
argument_list|(
operator|(
name|double
operator|)
name|x
index|[
literal|0
index|]
argument_list|,
operator|(
name|double
operator|)
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numPoints
condition|;
name|j
operator|++
control|)
name|Lineto
argument_list|(
operator|(
name|double
operator|)
name|x
index|[
name|j
index|]
argument_list|,
operator|(
name|double
operator|)
name|y
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|Lineto
argument_list|(
operator|(
name|double
operator|)
name|x
index|[
literal|0
index|]
argument_list|,
operator|(
name|double
operator|)
name|y
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|makeoutline
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|maskfill
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|setgray
argument_list|)
expr_stmt|;
comment|/* Restore normal black */
name|Op
argument_list|(
name|endBody
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|newStippleFamily
argument_list|(
argument|new
argument_list|)
end_macro

begin_block
block|{
name|char
name|stippleFilename
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|stippleFamily
condition|)
return|return;
if|if
condition|(
name|curStipple
operator|.
name|fileDes
operator|>
literal|0
condition|)
name|close
argument_list|(
name|curStipple
operator|.
name|fileDes
argument_list|)
expr_stmt|;
name|stippleFamily
operator|=
name|new
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|stippleFilename
argument_list|,
literal|"/usr/lib/vfont/%s.0"
argument_list|,
name|stipTypeName
index|[
name|new
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curStipple
operator|.
name|fileDes
operator|=
name|open
argument_list|(
name|stippleFilename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|stippleFilename
argument_list|,
literal|"%s/dev%s/%s.0"
argument_list|,
name|fontdirectory
argument_list|,
name|devicename
argument_list|,
name|stipTypeName
index|[
name|new
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curStipple
operator|.
name|fileDes
operator|=
name|open
argument_list|(
name|stippleFilename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|reportError
argument_list|(
name|QUIT
argument_list|,
literal|"can't open file %s for device characteristics (%s)"
argument_list|,
name|stippleFilename
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|read
argument_list|(
name|curStipple
operator|.
name|fileDes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|curStipple
operator|.
name|header
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|curStipple
operator|.
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|curStipple
operator|.
name|member
operator|=
operator|-
literal|1
expr_stmt|;
name|getStippleMember
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* build the packed pixel vector */
name|curStipple
operator|.
name|ppv
operator|.
name|prelude
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|curStipple
operator|.
name|ppv
operator|.
name|prelude
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|curStipple
operator|.
name|ppv
operator|.
name|prelude
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* high order byte */
name|curStipple
operator|.
name|ppv
operator|.
name|prelude
index|[
literal|3
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* low  order byte */
block|}
end_block

begin_decl_stmt
name|int
name|showStip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|getStippleMember
argument_list|(
argument|member
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|dispatch
modifier|*
name|dp
init|=
operator|&
name|curStipple
operator|.
name|dispatch
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|short
name|bits
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|curStipple
operator|.
name|member
operator|==
name|member
condition|)
return|return;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
operator|+
operator|(
name|member
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
operator|)
expr_stmt|;
name|lseek
argument_list|(
name|curStipple
operator|.
name|fileDes
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|curStipple
operator|.
name|fileDes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|nbytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|member
operator|==
literal|0
condition|)
return|return;
name|reportError
argument_list|(
name|CONTINUE
argument_list|,
literal|"Stipple Family %s doesn't have member %d"
argument_list|,
name|stipTypeName
index|[
name|stippleFamily
index|]
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|curStipple
operator|.
name|member
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dp
operator|->
name|up
operator|+
name|dp
operator|->
name|down
operator|)
operator|!=
literal|32
operator|||
operator|(
operator|(
name|dp
operator|->
name|left
operator|+
name|dp
operator|->
name|right
operator|)
operator|!=
literal|32
operator|)
condition|)
block|{
if|if
condition|(
name|member
operator|==
literal|0
condition|)
return|return;
name|reportError
argument_list|(
name|CONTINUE
argument_list|,
literal|"Stipple Family %s member %d is not 32x32\n"
argument_list|,
name|stipTypeName
index|[
name|stippleFamily
index|]
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|curStipple
operator|.
name|member
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
operator|+
operator|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
operator|)
operator|+
name|dp
operator|->
name|addr
expr_stmt|;
name|lseek
argument_list|(
name|curStipple
operator|.
name|fileDes
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|curStipple
operator|.
name|fileDes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bits
argument_list|,
sizeof|sizeof
argument_list|(
name|bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|showStip
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stipple Family %s, member %d\n"
argument_list|,
name|stipTypeName
index|[
name|stippleFamily
index|]
argument_list|,
name|member
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|curStipple
operator|.
name|ppv
operator|.
name|bits
index|[
name|i
index|]
operator|=
name|bits
index|[
name|i
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|showStip
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|mask
init|=
name|bits
index|[
name|i
operator|+
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

