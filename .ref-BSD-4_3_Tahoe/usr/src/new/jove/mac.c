begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* (C) 1986, 1987, 1988 Ken Mitchum. This code is intended only for use with Jove. */
end_comment

begin_include
include|#
directive|include
file|"tune.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_define
define|#
directive|define
name|_mac
end_define

begin_include
include|#
directive|include
file|<MacTypes.h>
end_include

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|<QuickDraw.h>
end_include

begin_include
include|#
directive|include
file|<WindowMgr.h>
end_include

begin_include
include|#
directive|include
file|<FontMgr.h>
end_include

begin_include
include|#
directive|include
file|<ListMgr.h>
end_include

begin_include
include|#
directive|include
file|<EventMgr.h>
end_include

begin_include
include|#
directive|include
file|<ControlMgr.h>
end_include

begin_include
include|#
directive|include
file|<DialogMgr.h>
end_include

begin_include
include|#
directive|include
file|<ResourceMgr.h>
end_include

begin_include
include|#
directive|include
file|<ToolboxUtil.h>
end_include

begin_include
include|#
directive|include
file|<HFS.h>
end_include

begin_include
include|#
directive|include
file|<StdFilePkg.h>
end_include

begin_include
include|#
directive|include
file|<MenuMgr.h>
end_include

begin_include
include|#
directive|include
file|<pascal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<SegmentLdr.h>
end_include

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/* these normally reside in "tune.c" which we don't use */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CmdDb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see InitMac() */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p_tempfile
init|=
literal|".jrecXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|d_tempfile
init|=
literal|".joveXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Joverc
init|=
literal|".joverc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|putcurs
argument_list|()
decl_stmt|,
name|curset
argument_list|()
decl_stmt|,
name|putp
argument_list|()
decl_stmt|,
name|dellines
argument_list|()
decl_stmt|,
name|inslines
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WindowPtr
name|theScreen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|,
name|EventCmd
decl_stmt|,
name|Keyonly
decl_stmt|,
name|Macmode
decl_stmt|,
name|Bufchange
decl_stmt|,
name|Modechange
decl_stmt|,
name|Windchange
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization Routines. */
end_comment

begin_function
name|void
name|InitBinds
parameter_list|()
block|{
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|mainmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|c
operator|->
name|c_map
operator|=
name|F_MAINMAP
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|pref1map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|c
operator|->
name|c_map
operator|=
name|F_PREF1MAP
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|pref2map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|c
operator|->
name|c_map
operator|=
name|F_PREF2MAP
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|WindowPtr
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Rect
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CursHandle
name|cross
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|InitEvents
parameter_list|()
block|{
name|void
name|InitSysMenu
parameter_list|()
function_decl|;
name|window
operator|=
name|theScreen
expr_stmt|;
name|InitSysMenu
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|left
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|-
name|SCROLLWIDTH
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|bottom
operator|-
name|SCROLLWIDTH
argument_list|)
expr_stmt|;
name|cross
operator|=
name|GetCursor
argument_list|(
name|crossCursor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MacInit
parameter_list|()
block|{
name|char
modifier|*
name|gethome
parameter_list|()
function_decl|;
name|void
name|tn_init
parameter_list|()
function_decl|;
name|tn_init
argument_list|()
expr_stmt|;
name|getdir
argument_list|()
expr_stmt|;
name|gethome
argument_list|()
expr_stmt|;
comment|/* before anyone changes it */
name|CmdDb
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|gethome
argument_list|()
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|CmdDb
argument_list|,
name|gethome
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|CmdDb
argument_list|,
literal|"/cmds.doc"
argument_list|)
expr_stmt|;
name|InitBinds
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dummy routines. */
end_comment

begin_function
name|void
name|InitCM
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|ResetTerm
parameter_list|()
block|{}
end_function

begin_function
name|void
name|UnsetTerm
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|dummy
parameter_list|()
block|{}
end_function

begin_macro
name|int
argument_list|(
argument|*signal(sig,func)
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
name|int
name|sig
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
block|}
end_block

begin_macro
name|dorecover
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/* Surrogate unix-style file i/o routines for Jove. These replace the    routines distributed in the libraries. They work with Jove, but may    not be general enough for other purposes. */
end_comment

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|NFILES
value|10
end_define

begin_comment
comment|/* #define fsetup(p) {p.ioCompletion = 0; p.ioVRefNum = cur_vol; p.ioDirID = cur_dir;p.ioFVersNum = 0;} #define isetup(p) {p.ioCompletion = 0; p.ioVRefNum = cur_vol;} */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_vol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disk or volume number */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cur_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_vref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ugh.. Vref for volume + directory */
end_comment

begin_struct
struct|struct
name|ftab
block|{
name|int
name|inuse
decl_stmt|;
comment|/* 0 = closed 1 = binary 2 = text*/
name|int
name|refnum
decl_stmt|;
comment|/* Mac file reference number */
block|}
name|ft
index|[
name|NFILES
index|]
struct|;
end_struct

begin_macro
name|fsetup
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|HParmBlkPtr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|HParamBlockRec
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioDirID
operator|=
name|cur_dir
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|isetup
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|HIOParam
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|HIOParam
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Kludge to convert Macintosh error codes to something like Unix. */
end_comment

begin_function
specifier|static
name|int
name|cvt_err
parameter_list|(
name|err
parameter_list|)
comment|/* some of these don't make sense... */
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|noErr
case|:
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|dirFulErr
case|:
name|errno
operator|=
name|ENOSPC
expr_stmt|;
break|break;
case|case
name|dskFulErr
case|:
name|errno
operator|=
name|ENOSPC
expr_stmt|;
break|break;
case|case
name|nsvErr
case|:
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
case|case
name|ioErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|bdNamErr
case|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|fnOpnErr
case|:
name|errno
operator|=
name|EBADF
expr_stmt|;
break|break;
comment|/* dubious... */
case|case
name|eofErr
case|:
name|errno
operator|=
name|ESPIPE
expr_stmt|;
break|break;
comment|/* ditto */
case|case
name|posErr
case|:
name|errno
operator|=
name|ESPIPE
expr_stmt|;
break|break;
case|case
name|mFulErr
case|:
case|case
name|tmfoErr
case|:
case|case
name|fnfErr
case|:
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
case|case
name|wPrErr
case|:
name|errno
operator|=
name|EROFS
expr_stmt|;
break|break;
case|case
name|fLckdErr
case|:
name|errno
operator|=
name|EACCES
expr_stmt|;
break|break;
case|case
name|fBsyErr
case|:
name|errno
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|dupFNErr
case|:
name|errno
operator|=
name|EEXIST
expr_stmt|;
break|break;
case|case
name|opWrErr
case|:
case|case
name|paramErr
case|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|rfNumErr
case|:
name|errno
operator|=
name|EBADF
expr_stmt|;
break|break;
case|case
name|gfpErr
case|:
case|case
name|volOffLinErr
case|:
name|errno
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|permErr
case|:
name|errno
operator|=
name|EACCES
expr_stmt|;
break|break;
case|case
name|volOnLinErr
case|:
name|errno
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|nsDrvErr
case|:
name|errno
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|noMacDskErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|extFSErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|fsRnErr
case|:
case|case
name|badMDBErr
case|:
case|case
name|wrPermErr
case|:
name|errno
operator|=
name|EPERM
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cvt_fnm
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
name|char
name|nm
index|[
literal|255
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|nm
argument_list|,
name|file
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* full path */
else|else
block|{
if|if
condition|(
name|index
argument_list|(
name|file
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|nm
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|/* make a partial pathname */
else|else
operator|*
name|nm
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|nm
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|nm
operator|)
return|;
block|}
end_function

begin_function
name|int
name|creat
parameter_list|(
name|name
parameter_list|,
name|perm
parameter_list|)
comment|/* permission mode is irrelevant on a Mac */
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* convert filename to Mac type name */
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|NFILES
operator|&&
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
condition|;
name|fd
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|fd
operator|==
name|NFILES
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* try to delete it, whether it is there or not. */
name|p
operator|.
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHDelete
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|fnfErr
condition|)
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
if|if
condition|(
name|do_creat
argument_list|(
operator|&
name|p
argument_list|,
name|nm
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
block|{
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|++
expr_stmt|;
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
operator|=
name|p
operator|.
name|ioParam
operator|.
name|ioRefNum
expr_stmt|;
return|return
operator|(
name|fd
operator|+
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|open
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* convert filename to Mac type name */
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|NFILES
operator|&&
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
condition|;
name|fd
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|fd
operator|==
name|NFILES
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
literal|3
operator|)
operator|==
name|O_RDONLY
condition|)
name|p
operator|.
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsRdPerm
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
literal|3
operator|)
operator|==
name|O_WRONLY
condition|)
name|p
operator|.
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsWrPerm
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
literal|3
operator|)
operator|==
name|O_RDWR
condition|)
name|p
operator|.
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsRdWrPerm
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioMisc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHOpen
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|fnfErr
condition|)
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
if|if
condition|(
name|err
operator|==
name|noErr
operator|&&
name|mode
operator|&
name|O_CREAT
operator|&&
name|mode
operator|&
name|O_EXCL
condition|)
block|{
name|PBClose
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|err
operator|==
name|fnfErr
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|O_CREAT
condition|)
block|{
if|if
condition|(
name|do_creat
argument_list|(
operator|&
name|p
argument_list|,
name|nm
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|++
expr_stmt|;
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
operator|=
name|p
operator|.
name|ioParam
operator|.
name|ioRefNum
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_APPEND
condition|)
name|p
operator|.
name|ioParam
operator|.
name|ioPosMode
operator|=
name|fsFromLEOF
expr_stmt|;
else|else
name|p
operator|.
name|ioParam
operator|.
name|ioPosMode
operator|=
name|fsFromStart
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioPosOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBSetFPos
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|fd
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_creat
parameter_list|(
name|p
parameter_list|,
name|nm
parameter_list|)
name|HParmBlkPtr
name|p
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|fsetup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHCreate
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
name|fsetup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHGetFInfo
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
name|p
operator|->
name|fileParam
operator|.
name|ioDirID
operator|=
name|cur_dir
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFlFndrInfo
operator|.
name|fdType
operator|=
literal|'TEXT'
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFlFndrInfo
operator|.
name|fdCreator
operator|=
literal|'JV01'
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFlFndrInfo
operator|.
name|fdFlags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHSetFInfo
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
name|fsetup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ioParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|->
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsRdWrPerm
expr_stmt|;
name|p
operator|->
name|ioParam
operator|.
name|ioMisc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvt_err
argument_list|(
name|PBHOpen
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|close
parameter_list|(
name|fd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioRefNum
operator|=
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
comment|/*	if(cvt_err(PBFlushFile(&p,0))< 0) return(-1); 	fsetup(&p); */
if|if
condition|(
name|cvt_err
argument_list|(
name|PBClose
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioNamePtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvt_err
argument_list|(
name|PBFlushVol
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|IOParam
name|p
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
return|return
operator|(
name|con_read
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
operator|)
return|;
if|if
condition|(
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|inuse
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioBuffer
operator|=
name|buf
expr_stmt|;
name|p
operator|.
name|ioReqCount
operator|=
name|n
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromMark
expr_stmt|;
name|p
operator|.
name|ioPosOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBRead
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|eofErr
condition|)
block|{
name|cvt_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\r'
condition|)
operator|*
name|buf
operator|=
literal|'\n'
expr_stmt|;
comment|/* convert from Mac style */
name|buf
operator|++
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|.
name|ioActCount
operator|)
return|;
block|}
end_function

begin_function
name|int
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|IOParam
name|p
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
return|return
operator|(
name|con_write
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
operator|)
return|;
name|s
operator|=
name|obuf
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obuf
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* shouldn't happen... */
if|if
condition|(
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|inuse
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioBuffer
operator|=
name|obuf
expr_stmt|;
name|p
operator|.
name|ioReqCount
operator|=
operator|(
name|long
operator|)
name|n
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromMark
expr_stmt|;
name|p
operator|.
name|ioPosOffset
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
operator|*
name|s
operator|=
literal|'\r'
expr_stmt|;
comment|/* make it look like Mac files */
else|else
operator|(
operator|*
name|s
operator|=
operator|*
name|buf
operator|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|PBWrite
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|p
operator|.
name|ioActCount
operator|)
return|;
block|}
end_function

begin_function
name|long
name|lseek
parameter_list|(
name|fd
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
comment|/* The Mac version of this doesn't allocate new space. */
name|long
name|offset
decl_stmt|;
name|unsigned
name|type
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|long
name|cur_mark
decl_stmt|,
name|eof
decl_stmt|,
name|new_mark
decl_stmt|;
name|IOParam
name|p
decl_stmt|;
if|if
condition|(
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|inuse
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBGetFPos
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|cvt_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cur_mark
operator|=
name|p
operator|.
name|ioPosOffset
expr_stmt|;
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBGetEOF
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|cvt_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eof
operator|=
operator|(
name|long
operator|)
name|p
operator|.
name|ioMisc
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
name|new_mark
operator|=
name|offset
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|new_mark
operator|=
name|offset
operator|+
name|cur_mark
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|new_mark
operator|=
name|offset
operator|+
name|eof
expr_stmt|;
block|}
if|if
condition|(
name|new_mark
operator|>
name|eof
condition|)
block|{
comment|/* need more space in file */
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioMisc
operator|=
operator|(
name|Ptr
operator|)
name|new_mark
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBSetEOF
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|cvt_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*		if((err = PBAllocContig(&p,0)) != noErr) { 			cvt_err(err); 			return(-1); 		}*/
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioPosOffset
operator|=
name|new_mark
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromStart
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBSetFPos
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|cvt_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|.
name|ioPosOffset
operator|)
return|;
block|}
end_function

begin_function
name|int
name|unlink
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* convert filename to Mac type name */
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* try to delete it, whether it is there or not. */
name|p
operator|.
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHDelete
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|fnfErr
condition|)
return|return
operator|(
name|cvt_err
argument_list|(
name|err
argument_list|)
operator|)
return|;
return|return;
block|}
end_function

begin_comment
comment|/* Console read and write routines */
end_comment

begin_function
specifier|static
name|int
name|con_write
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
while|while
condition|(
name|size
operator|--
condition|)
name|putp
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|con_read
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
name|int
name|p
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|p
operator|=
name|rawgetc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|O_META
if|if
condition|(
name|p
operator|&
literal|0x7f
condition|)
name|p
operator|&=
literal|0x7f
expr_stmt|;
comment|/* was normal ascii char */
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|p
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|rawchkc
argument_list|()
operator|&&
name|n
operator|<=
name|size
condition|)
do|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This didn't seem to be any place else */
end_comment

begin_function
name|int
name|abs
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|n
operator|>=
literal|0
condition|?
name|n
else|:
operator|-
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Simplified stat() routine emulates what is needed most. */
end_comment

begin_function
name|int
name|stat
parameter_list|(
name|fname
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|CInfoPBRec
name|p
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|CInfoPBRec
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioDirID
operator|=
name|cur_dir
expr_stmt|;
switch|switch
condition|(
name|PBHGetFInfo
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|noErr
case|:
name|errno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|nsvErr
case|:
case|case
name|paramErr
case|:
case|case
name|bdNamErr
case|:
case|case
name|fnfErr
case|:
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
case|case
name|ioErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
default|default :
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|buf
operator|->
name|st_dev
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioVRefNum
operator|+
literal|1
expr_stmt|;
comment|/* don't want 0 */
name|buf
operator|->
name|st_ino
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioDirID
expr_stmt|;
name|buf
operator|->
name|st_size
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioFlLgLen
expr_stmt|;
name|buf
operator|->
name|st_mtime
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioFlMdDat
expr_stmt|;
name|buf
operator|->
name|st_mode
operator|=
operator|(
name|p
operator|.
name|hFileInfo
operator|.
name|ioFlAttrib
operator|&
literal|0x10
operator|)
condition|?
name|S_IFDIR
else|:
literal|0
expr_stmt|;
name|PtoCstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Directory related routines. Jove keeps track of the true Volume (disk) number and    directory number, and avoids "Working Directory Reference Numbers", which are    confusing. */
end_comment

begin_function
specifier|static
name|int
name|getdir
parameter_list|()
comment|/* call this only once, during startup. */
block|{
name|WDPBRec
name|p
decl_stmt|;
name|p
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|ioNamePtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PBHGetVol
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|noErr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* BIG trouble */
name|cur_vol
operator|=
name|p
operator|.
name|ioWDVRefNum
expr_stmt|;
name|cur_dir
operator|=
name|p
operator|.
name|ioWDDirID
expr_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|cur_vol
expr_stmt|;
comment|/* these are for SF dialogs */
name|CurDirStore
operator|=
name|cur_dir
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|setdir
parameter_list|(
name|vol
parameter_list|,
name|dir
parameter_list|)
name|long
name|dir
decl_stmt|;
block|{
name|WDPBRec
name|p
decl_stmt|;
name|p
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|ioNamePtr
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|ioVRefNum
operator|=
name|vol
expr_stmt|;
name|p
operator|.
name|ioWDDirID
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|PBHSetVol
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|noErr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cur_vol
operator|=
name|vol
expr_stmt|;
name|cur_dir
operator|=
name|dir
expr_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|vol
expr_stmt|;
comment|/* these are for SF dialogs */
name|CurDirStore
operator|=
name|dir
expr_stmt|;
block|}
end_function

begin_function
name|int
name|chdir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|DirInfo
name|d
decl_stmt|;
name|WDPBRec
name|p
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* There is no root... */
name|nm
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strcpy
argument_list|(
name|nm
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|t
operator|++
expr_stmt|;
comment|/*get rid of initial slashes */
name|strcat
argument_list|(
name|nm
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
comment|/* get the directory number */
name|d
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|t
expr_stmt|;
name|d
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|ioDrDirID
operator|=
literal|0
expr_stmt|;
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|ioResult
operator|!=
name|noErr
operator|||
operator|(
operator|(
name|d
operator|.
name|ioFlAttrib
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|setdir
argument_list|(
name|d
operator|.
name|ioVRefNum
argument_list|,
name|d
operator|.
name|ioDrDirID
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Scandir returns the number of entries or -1 if the directory cannoot    be opened or malloc fails. */
end_comment

begin_decl_stmt
name|int
name|scandir
argument_list|(
name|dir
argument_list|,
name|nmptr
argument_list|,
name|qualify
argument_list|,
name|sorter
argument_list|)
comment|/* this function has NOT been debugged */
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|nmptr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|qualify
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|sorter
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|HParamBlockRec
name|fb
decl_stmt|;
name|DirInfo
name|d
decl_stmt|;
name|long
name|DirID
decl_stmt|;
name|char
modifier|*
modifier|*
name|ourarray
decl_stmt|,
modifier|*
name|nm
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|Str255
name|buf1
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|nalloc
init|=
literal|10
decl_stmt|,
name|nentries
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* There is no root... */
name|nm
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strcpy
argument_list|(
name|nm
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|t
operator|++
expr_stmt|;
comment|/*get rid of initial slashes */
name|strcat
argument_list|(
name|nm
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
comment|/* get the directory number */
name|d
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|t
expr_stmt|;
name|d
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|ioDrDirID
operator|=
literal|0
expr_stmt|;
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioDirID
operator|=
name|DirID
operator|=
name|d
operator|.
name|ioDrDirID
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioCompletion
operator|=
operator|(
name|long
operator|)
literal|0
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioNamePtr
operator|=
name|buf1
expr_stmt|;
if|if
condition|(
operator|(
name|ourarray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|memfail
label|:
name|complain
argument_list|(
literal|"[Malloc failed: cannot scandir]"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fb
operator|.
name|fileParam
operator|.
name|ioFDirIndex
operator|=
name|nentries
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|fb
operator|.
name|fileParam
operator|.
name|ioDirID
operator|=
name|DirID
expr_stmt|;
if|if
condition|(
name|PBHGetFInfo
argument_list|(
operator|&
name|fb
argument_list|,
literal|0
argument_list|)
operator|!=
name|noErr
condition|)
break|break;
comment|/* we are done, then */
name|len
operator|=
operator|(
name|char
operator|)
operator|*
name|fb
operator|.
name|fileParam
operator|.
name|ioNamePtr
expr_stmt|;
comment|/* pascal style string */
name|strncpy
argument_list|(
name|buf
argument_list|,
name|fb
operator|.
name|fileParam
operator|.
name|ioNamePtr
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|qualify
operator|!=
literal|0
operator|&&
call|(
modifier|*
name|qualify
call|)
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nentries
operator|==
name|nalloc
condition|)
block|{
name|ourarray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
operator|(
name|nalloc
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourarray
operator|==
literal|0
condition|)
goto|goto
name|memfail
goto|;
block|}
name|ourarray
index|[
name|nentries
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|null_ncpy
argument_list|(
name|ourarray
index|[
name|nentries
index|]
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nentries
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nentries
operator|+
literal|1
operator|)
operator|!=
name|nalloc
condition|)
name|ourarray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
operator|(
operator|(
name|nentries
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorter
operator|!=
literal|0
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
name|sorter
argument_list|)
expr_stmt|;
operator|*
name|nmptr
operator|=
name|ourarray
expr_stmt|;
name|ourarray
index|[
name|nentries
index|]
operator|=
literal|0
expr_stmt|;
comment|/* guaranteed 0 pointer */
return|return
name|nentries
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getwd
parameter_list|()
block|{
name|DirInfo
name|d
decl_stmt|;
specifier|static
name|char
name|ret
index|[
literal|255
index|]
decl_stmt|;
name|char
name|nm
index|[
literal|50
index|]
decl_stmt|,
name|tmp
index|[
literal|255
index|]
decl_stmt|;
name|ret
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|.
name|ioDrDirID
operator|=
name|cur_dir
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|d
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|d
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|ioFDirIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|ioResult
operator|!=
name|noErr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nm
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|ioDrDirID
operator|==
literal|2
condition|)
break|break;
comment|/* home directory */
name|d
operator|.
name|ioDrDirID
operator|=
name|d
operator|.
name|ioDrParID
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gethome
parameter_list|()
comment|/* this will be startup directory */
block|{
specifier|static
name|char
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|item
init|=
name|getwd
argument_list|()
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|item
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Routines that put up and manipulate the "About Jove" dialog. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) about_j.c. */
end_comment

begin_define
define|#
directive|define
name|DLOGNAME
value|"\pABOUT_JDLOG"
end_define

begin_define
define|#
directive|define
name|DONE_ITEM
value|1
end_define

begin_define
define|#
directive|define
name|LIST_ITEM
value|2
end_define

begin_define
define|#
directive|define
name|DWIDTH
value|460
end_define

begin_comment
comment|/* there should be an easy way to get this */
end_comment

begin_define
define|#
directive|define
name|DHEIGHT
value|240
end_define

begin_comment
comment|/* from the resource file! */
end_comment

begin_function_decl
name|WindowPtr
name|makedisplay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|ListHandle
name|makelist
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|WindowPtr
name|theWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ListHandle
name|theList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Rect
name|theListRect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EventRecord
name|theEvent
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|about_j
parameter_list|()
block|{
name|void
name|do_list
argument_list|()
decl_stmt|,
name|do_events
argument_list|()
decl_stmt|;
name|WindowPtr
name|OldWindow
decl_stmt|;
name|GetPort
argument_list|(
operator|&
name|OldWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|theWindow
operator|=
name|makedisplay
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return;
name|SetPort
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|theList
operator|=
name|makelist
argument_list|()
condition|)
block|{
name|LActivate
argument_list|(
literal|1
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|do_list
argument_list|()
expr_stmt|;
name|ShowWindow
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|do_events
argument_list|()
expr_stmt|;
block|}
name|SetPort
argument_list|(
name|OldWindow
argument_list|)
expr_stmt|;
name|LDispose
argument_list|(
name|theList
argument_list|)
expr_stmt|;
name|DisposDialog
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|WindowPtr
name|makedisplay
parameter_list|()
block|{
specifier|static
name|int
name|dlogid
init|=
literal|0
decl_stmt|;
name|DialogPtr
name|theDialog
decl_stmt|;
name|Handle
name|theHandle
decl_stmt|;
name|Handle
name|theResource
decl_stmt|;
name|Str255
name|buf
decl_stmt|;
name|long
name|itemType
decl_stmt|;
name|Rect
name|theRect
decl_stmt|;
name|short
name|dh
decl_stmt|,
name|dv
decl_stmt|;
comment|/* to center dialog on the screen */
name|Str255
name|nostring
decl_stmt|;
if|if
condition|(
name|dlogid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|theResource
operator|=
name|GetNamedResource
argument_list|(
literal|'DLOG'
argument_list|,
name|DLOGNAME
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|WindowPtr
operator|)
literal|0
operator|)
return|;
name|itemType
operator|=
literal|'DLOG'
expr_stmt|;
name|GetResInfo
argument_list|(
name|theResource
argument_list|,
operator|&
name|dlogid
argument_list|,
operator|&
name|itemType
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|theDialog
operator|=
name|GetNewDialog
argument_list|(
name|dlogid
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|WindowPtr
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nostring
argument_list|,
literal|"\p"
argument_list|)
expr_stmt|;
name|ParamText
argument_list|(
literal|"\pMacJove - Copyright (C) 1986, 1987, 1988 J. Payne, K. Gegenfurtner,"
argument_list|,
literal|"\pK. Mitchum. Portions (C) THINK Technologies, Inc."
argument_list|,
name|nostring
argument_list|,
name|nostring
argument_list|)
expr_stmt|;
name|dh
operator|=
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|+
operator|(
name|screenBits
operator|.
name|bounds
operator|.
name|right
operator|-
name|DWIDTH
operator|)
operator|/
literal|2
expr_stmt|;
name|dv
operator|=
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|+
operator|(
name|screenBits
operator|.
name|bounds
operator|.
name|bottom
operator|-
name|DHEIGHT
operator|)
operator|/
literal|2
expr_stmt|;
name|MoveWindow
argument_list|(
operator|(
name|WindowPtr
operator|)
name|theDialog
argument_list|,
name|dh
argument_list|,
name|dv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ShowWindow
argument_list|(
operator|(
name|WindowPtr
operator|)
name|theDialog
argument_list|)
expr_stmt|;
name|GetDItem
argument_list|(
name|theDialog
argument_list|,
name|LIST_ITEM
argument_list|,
operator|&
name|itemType
argument_list|,
operator|&
name|theHandle
argument_list|,
operator|&
name|theRect
argument_list|)
expr_stmt|;
name|theListRect
operator|=
name|theRect
expr_stmt|;
name|theListRect
operator|.
name|right
operator|-=
literal|15
expr_stmt|;
operator|(
operator|(
name|WindowPtr
operator|)
name|theDialog
operator|)
operator|->
name|txFont
operator|=
name|FONT
expr_stmt|;
operator|(
operator|(
name|WindowPtr
operator|)
name|theDialog
operator|)
operator|->
name|txSize
operator|=
name|TEXTSIZE
expr_stmt|;
return|return
operator|(
operator|(
name|WindowPtr
operator|)
name|theDialog
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_display
parameter_list|()
comment|/* draw necessary controls, lines */
block|{
name|Rect
name|rViewF
decl_stmt|;
comment|/* framing rect for list */
name|int
name|offset
decl_stmt|;
name|rViewF
operator|=
name|theListRect
expr_stmt|;
name|rViewF
operator|.
name|left
operator|--
expr_stmt|;
name|rViewF
operator|.
name|top
operator|--
expr_stmt|;
name|rViewF
operator|.
name|right
operator|++
expr_stmt|;
name|rViewF
operator|.
name|bottom
operator|++
expr_stmt|;
name|FrameRect
argument_list|(
operator|&
name|rViewF
argument_list|)
expr_stmt|;
name|DrawControls
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ListHandle
name|makelist
parameter_list|()
block|{
name|Point
name|csize
decl_stmt|;
name|Rect
name|dataBounds
decl_stmt|,
name|rView
decl_stmt|;
comment|/* list boundaries */
name|csize
operator|.
name|h
operator|=
name|csize
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|dataBounds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|LNew
argument_list|(
operator|&
name|theListRect
argument_list|,
operator|&
name|dataBounds
argument_list|,
name|csize
argument_list|,
literal|0
argument_list|,
name|theWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_list
parameter_list|()
block|{
name|void
name|printbind
parameter_list|()
function_decl|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|struct
name|cmd
modifier|*
name|f
decl_stmt|;
name|Str255
name|buf
decl_stmt|;
name|Point
name|theCell
decl_stmt|;
name|theCell
operator|.
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
name|commands
operator|,
name|row
operator|=
literal|0
init|;
name|f
operator|->
name|Name
condition|;
name|f
operator|++
operator|,
name|row
operator|++
control|)
block|{
name|LAddRow
argument_list|(
literal|1
argument_list|,
name|row
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|theCell
operator|.
name|v
operator|=
name|row
expr_stmt|;
name|printbind
argument_list|(
name|f
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|f
operator|->
name|Name
argument_list|)
expr_stmt|;
name|LSetCell
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
argument_list|,
name|theCell
argument_list|,
name|theList
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printbind
parameter_list|(
name|f
parameter_list|,
name|buf
parameter_list|)
name|struct
name|cmd
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|c_map
operator|==
literal|0
operator|||
operator|(
name|c
operator|=
name|f
operator|->
name|c_key
operator|)
operator|==
literal|0x7f
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|f
operator|->
name|c_map
condition|)
block|{
case|case
name|F_MAINMAP
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"     "
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_PREF1MAP
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|" ESC "
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_PREF2MAP
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"  ^X "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|buf
index|[
literal|5
index|]
operator|=
literal|'^'
expr_stmt|;
comment|/* control char */
name|c
operator||=
literal|0x40
expr_stmt|;
block|}
else|else
name|buf
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|&=
literal|0x5f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pascal
name|Boolean
name|ProcFilter
parameter_list|(
name|theDialog
parameter_list|,
name|event
parameter_list|,
name|itemHit
parameter_list|)
name|DialogPtr
name|theDialog
decl_stmt|;
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|int
modifier|*
name|itemHit
decl_stmt|;
block|{
name|theEvent
operator|=
operator|*
name|event
expr_stmt|;
if|if
condition|(
name|theEvent
operator|.
name|what
operator|==
name|keyDown
operator|&&
name|theEvent
operator|.
name|message
operator|&
name|charCodeMask
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|itemHit
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|theEvent
operator|.
name|what
operator|==
name|activateEvt
operator|&&
operator|(
name|WindowPtr
operator|)
name|theEvent
operator|.
name|message
operator|==
name|theWindow
condition|)
block|{
name|LDoDraw
argument_list|(
literal|1
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|LActivate
argument_list|(
literal|1
argument_list|,
name|theList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|theEvent
operator|.
name|what
operator|==
name|updateEvt
operator|&&
operator|(
name|WindowPtr
operator|)
name|theEvent
operator|.
name|message
operator|==
name|theWindow
condition|)
block|{
name|BeginUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|do_display
argument_list|()
expr_stmt|;
name|DrawDialog
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|LUpdate
argument_list|(
operator|(
name|GrafPtr
operator|)
name|theWindow
operator|->
name|visRgn
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|EndUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|do_events
parameter_list|()
block|{
name|int
name|item
decl_stmt|,
name|done
decl_stmt|;
name|Point
name|p
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|ModalDialog
argument_list|(
name|ProcFilter
argument_list|,
operator|&
name|item
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|DONE_ITEM
case|:
name|done
operator|=
literal|1
expr_stmt|;
case|case
name|LIST_ITEM
case|:
name|p
operator|=
name|theEvent
operator|.
name|where
expr_stmt|;
name|GlobalToLocal
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|LClick
argument_list|(
name|p
argument_list|,
name|theEvent
operator|.
name|modifiers
argument_list|,
name|theList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Window and Control related routines. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) tcon.c.     control handler routines for Jove. K. Mitchum 12/86 */
end_comment

begin_define
define|#
directive|define
name|MINC
value|0
end_define

begin_define
define|#
directive|define
name|MAXC
value|(int)100
end_define

begin_define
define|#
directive|define
name|INITC
value|0
end_define

begin_define
define|#
directive|define
name|EVENTLIST
value|(mDownMask | keyDownMask )
end_define

begin_function_decl
specifier|extern
name|long
name|GetCRefCon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* omitted in ControlMgr.h */
end_comment

begin_decl_stmt
specifier|static
name|Point
name|p
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|intext
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mouse down in jove text */
end_comment

begin_function
name|void
name|docontrols
parameter_list|()
comment|/* called from redisplay routines */
block|{
name|void
name|MakeScrollBar
argument_list|()
decl_stmt|,
name|AdjustScrollBar
argument_list|()
decl_stmt|,
name|drawfluff
argument_list|()
decl_stmt|;
name|Window
modifier|*
name|w
decl_stmt|;
name|int
name|top
decl_stmt|;
name|w
operator|=
name|fwind
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_control
condition|)
name|HideControl
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
name|w
operator|=
name|fwind
expr_stmt|;
do|do
block|{
name|w
operator|->
name|w_topline
operator|=
name|top
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_control
condition|)
name|AdjustScrollBar
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|MakeScrollBar
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|ShowControl
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
name|top
operator|+=
name|w
operator|->
name|w_height
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
name|Windchange
operator|=
literal|0
expr_stmt|;
name|drawfluff
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MakeScrollBar
parameter_list|(
name|w
parameter_list|)
comment|/* set up control */
name|Window
modifier|*
name|w
decl_stmt|;
block|{
name|Rect
name|BarRect
decl_stmt|;
name|int
name|wheight
decl_stmt|,
name|wtop
decl_stmt|;
name|WindowPtr
name|window
init|=
name|theScreen
decl_stmt|;
name|wheight
operator|=
name|w
operator|->
name|w_height
expr_stmt|;
name|wtop
operator|=
name|w
operator|->
name|w_topline
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|BarRect
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|-
name|SCROLLWIDTH
operator|+
literal|1
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
operator|-
literal|1
operator|+
name|wtop
operator|*
name|HEIGHT
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|+
literal|1
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
operator|+
operator|(
operator|(
name|wheight
operator|+
name|wtop
operator|)
operator|*
name|HEIGHT
operator|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_control
operator|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NewControl
argument_list|(
name|window
argument_list|,
operator|&
name|BarRect
argument_list|,
literal|"/psbar"
argument_list|,
literal|1
argument_list|,
name|INITC
argument_list|,
name|MINC
argument_list|,
name|MAXC
argument_list|,
name|scrollBarProc
argument_list|,
name|w
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|AdjustScrollBar
parameter_list|(
name|w
parameter_list|)
comment|/* redo existing control */
name|Window
modifier|*
name|w
decl_stmt|;
block|{
name|int
name|wtop
decl_stmt|,
name|wheight
decl_stmt|;
name|ControlHandle
name|handle
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
name|handle
operator|=
operator|(
name|ControlHandle
operator|)
name|w
operator|->
name|w_control
expr_stmt|;
name|wtop
operator|=
name|w
operator|->
name|w_topline
expr_stmt|;
name|wheight
operator|=
name|w
operator|->
name|w_height
expr_stmt|;
name|window
operator|=
operator|(
operator|*
name|handle
operator|)
operator|->
name|contrlOwner
expr_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
return|return;
name|SizeControl
argument_list|(
name|handle
argument_list|,
name|SCROLLWIDTH
argument_list|,
name|wheight
operator|*
name|HEIGHT
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MoveControl
argument_list|(
name|handle
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|-
name|SCROLLWIDTH
operator|+
literal|1
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
operator|-
literal|1
operator|+
name|wtop
operator|*
name|HEIGHT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetScrollBar
parameter_list|(
name|handle
parameter_list|)
comment|/* set value of the bar */
name|ControlHandle
name|handle
decl_stmt|;
block|{
name|SetCtlValue
argument_list|(
name|handle
argument_list|,
name|ltoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dodivider
parameter_list|()
comment|/* originally to divide windows, but not enough */
comment|/* room in between lines, so just put line at bottom */
block|{
name|WindowPtr
name|window
decl_stmt|;
name|PenState
name|pnState
decl_stmt|;
name|window
operator|=
name|theScreen
expr_stmt|;
name|GetPenState
argument_list|(
operator|&
name|pnState
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|MAXROW
operator|)
operator|*
name|HEIGHT
operator|)
argument_list|)
expr_stmt|;
name|PenSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LineTo
argument_list|(
name|window
operator|->
name|portRect
operator|.
name|right
argument_list|,
operator|(
name|MAXROW
operator|)
operator|*
name|HEIGHT
argument_list|)
expr_stmt|;
name|SetPenState
argument_list|(
operator|&
name|pnState
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|drawfluff
parameter_list|()
comment|/* draw controls and dividers */
block|{
name|WindowPtr
name|window
decl_stmt|;
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
name|window
operator|=
name|theScreen
expr_stmt|;
name|DrawControls
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|dodivider
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RemoveScrollBar
parameter_list|(
name|w
parameter_list|)
name|Window
modifier|*
name|w
decl_stmt|;
block|{
if|if
condition|(
name|w
operator|->
name|w_control
condition|)
name|DisposeControl
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
name|dodivider
argument_list|()
expr_stmt|;
comment|/* erase the divider */
name|w
operator|->
name|w_control
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pascal
name|void
name|DScroll
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|DownScroll
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pascal
name|void
name|UScroll
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|UpScroll
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pascal
name|void
name|NPage
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|NextPage
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pascal
name|void
name|PPage
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|PrevPage
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|long
name|npos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines in buffer */
end_comment

begin_function
specifier|static
name|int
name|ltoc
parameter_list|()
comment|/* calculate ctlvalue for line position */
block|{
specifier|register
name|long
name|ipos
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
for|for
control|(
name|npos
operator|=
literal|1
init|;
name|lp
condition|;
name|npos
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|lp
operator|==
name|curline
condition|)
name|ipos
operator|=
name|npos
expr_stmt|;
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|ipos
operator|*
name|MAXC
operator|)
operator|/
name|npos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Line
modifier|*
name|ctol
parameter_list|(
name|ctlv
parameter_list|)
comment|/* find buffer line for ctlvalue */
name|int
name|ctlv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|itoa
parameter_list|()
function_decl|;
specifier|register
name|long
name|ipos
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
name|ipos
operator|=
operator|(
name|npos
operator|*
name|ctlv
operator|)
operator|/
name|MAXC
expr_stmt|;
while|while
condition|(
name|ipos
operator|--
operator|&&
name|lp
operator|->
name|l_next
condition|)
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doWind
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
define|#
directive|define
name|track
parameter_list|()
value|TrackControl(whichControl,p,(ProcPtr) 0)
name|ControlHandle
name|whichControl
decl_stmt|;
name|Window
modifier|*
name|jwind
decl_stmt|,
modifier|*
name|cwind
decl_stmt|;
name|int
name|notcurwind
decl_stmt|;
name|int
name|cpart
decl_stmt|;
comment|/* control part */
name|int
name|oldval
decl_stmt|,
name|newval
decl_stmt|,
name|thumb
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|event
operator|->
name|where
expr_stmt|;
name|intext
operator|=
literal|0
expr_stmt|;
name|notcurwind
operator|=
literal|0
expr_stmt|;
name|GlobalToLocal
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|what
operator|==
name|mouseDown
condition|)
block|{
if|if
condition|(
operator|(
name|cpart
operator|=
name|FindControl
argument_list|(
name|p
argument_list|,
name|window
argument_list|,
operator|&
name|whichControl
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|jwind
operator|=
operator|(
name|Window
operator|*
operator|)
operator|(
operator|*
name|whichControl
operator|)
operator|->
name|contrlRfCon
operator|)
operator|!=
name|curwind
condition|)
block|{
name|notcurwind
operator|++
expr_stmt|;
name|cwind
operator|=
name|curwind
expr_stmt|;
name|SetWind
argument_list|(
name|jwind
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cpart
condition|)
block|{
case|case
name|inUpButton
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|DScroll
argument_list|)
expr_stmt|;
break|break;
case|case
name|inDownButton
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|UScroll
argument_list|)
expr_stmt|;
break|break;
case|case
name|inPageUp
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|PPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|inPageDown
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|NPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|inThumb
case|:
if|if
condition|(
name|track
argument_list|()
condition|)
block|{
name|newval
operator|=
name|GetCtlValue
argument_list|(
name|whichControl
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|==
name|MAXC
condition|)
name|Eof
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|newval
operator|==
name|MINC
condition|)
name|Bof
argument_list|()
expr_stmt|;
else|else
name|SetLine
argument_list|(
name|ctol
argument_list|(
name|newval
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|notcurwind
condition|)
block|{
name|SetWind
argument_list|(
name|cwind
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
comment|/* again, to set the cursor */
block|}
else|else
block|{
if|if
condition|(
name|findtext
argument_list|()
condition|)
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|doGoAway
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
if|if
condition|(
name|TrackGoAway
argument_list|(
name|window
argument_list|,
operator|&
name|event
operator|->
name|where
argument_list|)
operator|==
name|TRUE
condition|)
name|Leave
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Window
modifier|*
name|rtowind
parameter_list|(
name|row
parameter_list|)
comment|/* return jove window row is in */
name|int
name|row
decl_stmt|;
block|{
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|w_topline
operator|<=
name|row
operator|)
operator|&&
operator|(
operator|(
name|w
operator|->
name|w_height
operator|+
name|w
operator|->
name|w_topline
operator|)
operator|>
name|row
operator|)
condition|)
return|return
operator|(
name|w
operator|)
return|;
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Line
modifier|*
name|windtol
parameter_list|(
name|w
parameter_list|,
name|row
parameter_list|)
comment|/* return line for row in window */
name|Window
modifier|*
name|w
decl_stmt|;
name|int
name|row
decl_stmt|;
block|{
name|Line
modifier|*
name|l
init|=
name|w
operator|->
name|w_top
decl_stmt|;
while|while
condition|(
name|row
operator|--
condition|)
if|if
condition|(
operator|(
name|l
operator|=
name|l
operator|->
name|l_next
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|findtext
parameter_list|()
comment|/* locate and move the point to match the mouse */
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|Window
modifier|*
name|w
decl_stmt|;
name|Line
modifier|*
name|l
decl_stmt|;
name|ptoxy
argument_list|(
name|p
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|rtowind
argument_list|(
name|row
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w
operator|!=
name|curwind
condition|)
name|SetWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|row
operator|-=
name|w
operator|->
name|w_topline
expr_stmt|;
comment|/* now have row number in window */
if|if
condition|(
name|row
operator|>=
name|w
operator|->
name|w_height
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|l
operator|=
name|windtol
argument_list|(
name|w
argument_list|,
name|row
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|l
operator|->
name|l_dline
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|this_cmd
operator|=
name|LINECMD
expr_stmt|;
name|SetLine
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* Curline is in linebuf now */
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
condition|)
name|col
operator|-=
literal|8
expr_stmt|;
comment|/* adjust for line numbers */
if|if
condition|(
name|col
operator|<
literal|0
condition|)
name|col
operator|=
literal|0
expr_stmt|;
name|curchar
operator|=
name|how_far
argument_list|(
name|curline
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptoxy
parameter_list|(
name|p
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
comment|/* convert Point to terminal x,y coordinate */
name|Point
name|p
decl_stmt|;
name|int
modifier|*
name|row
decl_stmt|,
decl|*
name|col
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|row
operator|=
operator|(
name|p
operator|.
name|v
operator|/
name|HEIGHT
operator|)
expr_stmt|;
operator|*
name|col
operator|=
operator|(
name|p
operator|.
name|h
operator|/
name|WIDTH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|row
operator|>
name|MAXROW
operator|)
operator|||
operator|(
operator|*
name|col
operator|>
name|MAXCOL
operator|)
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Event-related routines. The Event loop is CheckEvents(), and is called whenever    a console read occurs or a call to charp(). During certain activities, such as ask(),    etc. non-keyboard events are ignored. This is set by the variable Keyonly.     As an update or activate event generates a call to redisplay(), it is important    that redisplay() and related routines NOT check for keyboard characters. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) tevent.c 	event handler for Jove. K Mitchum 12/86 */
end_comment

begin_define
define|#
directive|define
name|SYS_ID
value|100
end_define

begin_define
define|#
directive|define
name|NOFUNC
value|(void (*)()) 0
end_define

begin_define
define|#
directive|define
name|NEVENTS
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|firsttime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|doMouse
argument_list|()
decl_stmt|,
name|dokeyDown
argument_list|()
decl_stmt|,
name|doUpdate
argument_list|()
decl_stmt|,
name|doActivate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MenuHandle
name|SysMenu
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|eventlist
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|NOFUNC
operator|,
comment|/* nullEvent */
function_decl|doMouse
operator|,
comment|/* mouseDown */
function_decl|doMouse
operator|,
comment|/* mouseUp */
function_decl|dokeyDown
operator|,
comment|/* keyDown */
function_decl|NOFUNC
operator|,
comment|/* keyUp */
function_decl|dokeyDown
operator|,
comment|/* autoKey */
function_decl|doUpdate
operator|,
comment|/* updateEvt */
function_decl|NOFUNC
operator|,
comment|/* diskEvt */
function_decl|doActivate
operator|,
comment|/* activateEvt */
function_decl|NOFUNC
operator|,
comment|/* not  used */
function_decl|NOFUNC
operator|,
comment|/* networkEvt = 10 */
function_decl|NOFUNC
operator|,
comment|/* driverEvt */
function_decl|NOFUNC
operator|,
comment|/* app1Evt */
function_decl|NOFUNC
operator|,
comment|/* app2Evt */
function_decl|NOFUNC
operator|,
comment|/* app3Evt */
function_decl|NOFUNC
end_function_decl

begin_comment
comment|/* app4Ev */
end_comment

begin_function
unit|};
specifier|static
name|void
name|CheckEvents
parameter_list|()
block|{
define|#
directive|define
name|Ticks
value|(long *) 0x16A
name|void
name|SetBufMenu
argument_list|()
decl_stmt|,
name|MarkModes
argument_list|()
decl_stmt|;
specifier|static
name|EventRecord
name|theEvent
decl_stmt|;
specifier|static
name|Point
name|Mousep
decl_stmt|;
specifier|static
name|long
name|time
init|=
literal|0
decl_stmt|;
specifier|static
name|void
function_decl|(
modifier|*
name|fptr
function_decl|)
parameter_list|()
function_decl|;
define|#
directive|define
name|HeapEnd
value|(char **) 0x114
define|#
directive|define
name|ApplLimit
value|(char **) 0x130
specifier|static
name|long
name|freesp
init|=
literal|50000
decl_stmt|;
if|if
condition|(
name|FrontWindow
argument_list|()
operator|==
name|window
condition|)
block|{
name|GetMouse
argument_list|(
operator|&
name|Mousep
argument_list|)
expr_stmt|;
if|if
condition|(
name|PtInRect
argument_list|(
name|Mousep
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|SetCursor
argument_list|(
operator|*
name|cross
argument_list|)
expr_stmt|;
else|else
name|SetCursor
argument_list|(
operator|&
name|arrow
argument_list|)
expr_stmt|;
block|}
name|SystemTask
argument_list|()
expr_stmt|;
if|if
condition|(
name|EventCmd
operator|&&
operator|!
name|Keyonly
condition|)
return|return;
if|if
condition|(
name|Bufchange
operator|!=
literal|0
condition|)
name|SetBufMenu
argument_list|()
expr_stmt|;
if|if
condition|(
name|Modechange
operator|!=
literal|0
condition|)
name|MarkModes
argument_list|()
expr_stmt|;
while|while
condition|(
name|GetNextEvent
argument_list|(
name|everyEvent
argument_list|,
operator|&
name|theEvent
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|theEvent
operator|.
name|what
operator|<
name|NEVENTS
operator|)
operator|&&
operator|(
name|fptr
operator|=
name|eventlist
index|[
name|theEvent
operator|.
name|what
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|fptr
call|)
argument_list|(
operator|&
name|theEvent
argument_list|)
expr_stmt|;
block|}
name|SystemTask
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ApplLimit
operator|-
operator|*
name|HeapEnd
operator|)
operator|<
name|freesp
condition|)
block|{
name|freesp
operator|=
operator|(
operator|(
operator|(
operator|*
name|ApplLimit
operator|-
operator|*
name|HeapEnd
operator|)
operator|/
literal|5000
operator|)
operator|*
literal|5000
operator|)
expr_stmt|;
name|SysBeep
argument_list|(
literal|120
argument_list|)
expr_stmt|;
name|s_mess
argument_list|(
literal|"WARNING: Free memory down to %D bytes"
argument_list|,
name|freesp
argument_list|)
expr_stmt|;
name|freesp
operator|-=
literal|5000
expr_stmt|;
if|if
condition|(
operator|!
name|Macmode
condition|)
name|redisplay
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|Ticks
operator|-
name|time
operator|)
operator|>
literal|3600
condition|)
block|{
name|time
operator|=
operator|*
name|Ticks
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|InitSysMenu
parameter_list|()
block|{
name|void
name|InitLocalMenus
parameter_list|()
function_decl|;
name|SysMenu
operator|=
name|NewMenu
argument_list|(
name|SYS_ID
argument_list|,
literal|"\p\24"
argument_list|)
expr_stmt|;
name|AppendMenu
argument_list|(
name|SysMenu
argument_list|,
literal|"\pAbout Jove"
argument_list|)
expr_stmt|;
name|AddResMenu
argument_list|(
name|SysMenu
argument_list|,
literal|'DRVR'
argument_list|)
expr_stmt|;
name|InsertMenu
argument_list|(
name|SysMenu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|InitLocalMenus
argument_list|()
expr_stmt|;
name|DrawMenuBar
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|void
name|doWind
argument_list|()
decl_stmt|,
name|doGoAway
argument_list|()
decl_stmt|,
name|doSysMenu
argument_list|()
decl_stmt|,
name|doSysClick
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMEVENTS
value|7
end_define

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|mouselist
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|NOFUNC
operator|,
comment|/* inDesk */
function_decl|doSysMenu
operator|,
comment|/* inMenuBar */
function_decl|doSysClick
operator|,
comment|/* inSysWindow */
function_decl|doWind
operator|,
comment|/* inContent */
function_decl|NOFUNC
operator|,
comment|/* inDrag */
function_decl|NOFUNC
operator|,
comment|/* inGrow */
function_decl|doGoAway
end_function_decl

begin_comment
comment|/* inGoAwa */
end_comment

begin_function
unit|};
specifier|static
name|void
name|doMouse
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|WindowPtr
name|theWindow
decl_stmt|;
name|int
name|wpart
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fptr
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|Keyonly
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|what
operator|==
name|mouseDown
condition|)
name|SysBeep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpart
operator|=
name|FindWindow
argument_list|(
name|event
operator|->
name|where
argument_list|,
operator|&
name|theWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wpart
operator|<
name|NMEVENTS
operator|)
operator|&&
operator|(
name|fptr
operator|=
name|mouselist
index|[
name|wpart
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|fptr
call|)
argument_list|(
name|event
argument_list|,
name|theWindow
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|doSysMenu
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
name|void
name|ProcMenu
parameter_list|()
function_decl|;
name|int
name|Menu
decl_stmt|,
name|Item
decl_stmt|;
name|long
name|result
init|=
name|MenuSelect
argument_list|(
name|event
operator|->
name|where
argument_list|)
decl_stmt|;
name|Menu
operator|=
operator|(
name|result
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|Item
operator|=
name|result
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|Item
operator|==
literal|0
condition|)
return|return;
comment|/* no choice made */
if|if
condition|(
name|Menu
operator|==
name|SYS_ID
condition|)
block|{
comment|/* apple menu */
name|Str255
name|Name
decl_stmt|;
name|GrafPtr
name|Port
decl_stmt|;
if|if
condition|(
name|Item
operator|==
literal|1
condition|)
name|about_j
argument_list|()
expr_stmt|;
else|else
block|{
name|GetItem
argument_list|(
name|SysMenu
argument_list|,
name|Item
argument_list|,
name|Name
argument_list|)
expr_stmt|;
name|GetPort
argument_list|(
operator|&
name|Port
argument_list|)
expr_stmt|;
name|OpenDeskAcc
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|Port
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ProcMenu
argument_list|(
name|Menu
argument_list|,
name|Item
argument_list|)
expr_stmt|;
name|HiliteMenu
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|EventCmd
operator|=
literal|1
expr_stmt|;
name|menus_on
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doSysClick
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
name|SystemClick
argument_list|(
name|event
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doUpdate
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|WindowPtr
name|theWindow
decl_stmt|,
name|oldPort
decl_stmt|;
name|theWindow
operator|=
operator|(
name|WindowPtr
operator|)
name|event
operator|->
name|message
expr_stmt|;
if|if
condition|(
name|firsttime
operator|==
literal|0
condition|)
block|{
name|firsttime
operator|++
expr_stmt|;
name|BeginUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|EndUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*	redisplay(); */
name|GetPort
argument_list|(
operator|&
name|oldPort
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|BeginUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|theWindow
operator|==
name|theScreen
operator|&&
name|Windchange
operator|==
literal|0
operator|&&
name|Keyonly
operator|==
literal|0
condition|)
block|{
name|Placur
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawfluff
argument_list|()
expr_stmt|;
name|cl_scr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
name|EndUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|oldPort
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doActivate
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|WindowPtr
name|theWindow
decl_stmt|;
name|ControlHandle
name|control
decl_stmt|;
name|int
name|hilite
decl_stmt|;
name|theWindow
operator|=
operator|(
name|WindowPtr
operator|)
name|event
operator|->
name|message
expr_stmt|;
name|SetPort
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|modifiers
operator|&
name|activeFlag
condition|)
block|{
name|hilite
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hilite
operator|=
literal|255
expr_stmt|;
for|for
control|(
name|control
operator|=
call|(
name|ControlHandle
call|)
argument_list|(
operator|(
operator|(
name|WindowPeek
operator|)
name|theWindow
operator|)
operator|->
name|controlList
argument_list|)
init|;
operator|(
name|control
operator|!=
literal|0
operator|)
condition|;
name|control
operator|=
operator|(
operator|*
name|control
operator|)
operator|->
name|nextControl
control|)
block|{
name|HiliteControl
argument_list|(
name|control
argument_list|,
name|hilite
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Keyboard routines. The Option key was formerly used as a meta key.    However, to take advantage of the full (non-ASCII) character set,    this was removed. The corresponding code is ifdeffed O_META. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) tkey.c    keyboard routines for Macintosh. K Mitchum 12/86 */
end_comment

begin_decl_stmt
specifier|extern
name|jmp_buf
name|auxjmp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|nchars
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|charbuf
index|[
name|MCHARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the following kludges a meta key out of the option key by sending an escape sequence back to the dispatch routines. this is not elegant but it works, and doesn't alter escape sequences for those that prefer them. to remap the control or meta keys, see mackeys.h. */
end_comment

begin_function
specifier|static
name|void
name|dokeyDown
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|unsigned
name|mods
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|static
name|int
name|cptr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MCHARS
operator|-
name|nchars
operator|<
literal|2
condition|)
return|return;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|event
operator|->
name|message
operator|)
operator|&
operator|(
name|charCodeMask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
name|c
operator|=
literal|'\033'
expr_stmt|;
comment|/* for those used to escapes */
name|mods
operator|=
name|event
operator|->
name|modifiers
expr_stmt|;
ifdef|#
directive|ifdef
name|O_META
if|if
condition|(
name|mods
operator|&
operator|(
name|optionKey
operator||
name|cmdKey
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|mods
operator|&
operator|(
name|cmdKey
operator|)
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|mods
operator|&
name|shiftKey
condition|)
name|c
operator|=
name|sh_keycodes
index|[
operator|(
operator|(
operator|(
name|event
operator|->
name|message
operator|)
operator|&
operator|(
name|keyCodeMask
operator|)
operator|)
operator|>>
literal|8
operator|)
index|]
expr_stmt|;
else|else
name|c
operator|=
name|nsh_keycodes
index|[
operator|(
operator|(
operator|(
name|event
operator|->
name|message
operator|)
operator|&
operator|(
name|keyCodeMask
operator|)
operator|)
operator|>>
literal|8
operator|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|O_META
if|if
condition|(
name|mods
operator|&
name|optionKey
condition|)
block|{
comment|/* make escape sequence */
if|if
condition|(
name|mods
operator|&
name|cmdKey
condition|)
name|c
operator|&=
literal|0x1f
expr_stmt|;
name|charbuf
index|[
name|cptr
operator|++
index|]
operator|=
literal|'\033'
expr_stmt|;
name|cptr
operator|&=
name|NMASK
expr_stmt|;
comment|/* zero if necessary */
name|nchars
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* command key (control key) */
if|if
condition|(
operator|(
name|c
operator|==
literal|'2'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
comment|/* so we have a null char */
if|if
condition|(
name|c
operator|!=
literal|'`'
condition|)
name|c
operator|&=
literal|0x1f
expr_stmt|;
comment|/* make a control char */
block|}
block|}
name|charbuf
index|[
name|cptr
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|cptr
operator|&=
name|NMASK
expr_stmt|;
name|nchars
operator|++
expr_stmt|;
block|}
specifier|static
name|int
name|rawgetc
parameter_list|()
block|{
specifier|static
name|int
name|cptr
init|=
literal|0
decl_stmt|;
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|EventCmd
condition|)
name|longjmp
argument_list|(
name|auxjmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
name|nchars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|EventCmd
condition|)
name|longjmp
argument_list|(
name|auxjmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CheckEvents
argument_list|()
expr_stmt|;
comment|/* ugh! WAIT for a character */
block|}
name|nchars
operator|--
expr_stmt|;
name|c
operator|=
name|charbuf
index|[
name|cptr
operator|++
index|]
expr_stmt|;
name|cptr
operator|&=
name|NMASK
expr_stmt|;
comment|/* zero if necessary */
return|return
operator|(
name|c
operator|)
return|;
block|}
name|int
name|rawchkc
parameter_list|()
block|{
if|if
condition|(
name|EventCmd
condition|)
name|longjmp
argument_list|(
name|auxjmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
name|CheckEvents
argument_list|()
expr_stmt|;
comment|/* this should NOT be necessary! */
return|return
operator|(
name|nchars
operator|>
literal|0
operator|)
return|;
block|}
comment|/* Routines for calling the standard file dialogs, when macify is ON. If the user    changes the directory using the file dialogs, Jove's notion of the current directory    is updated. */
comment|/* (ORIGINALLY IN) tmacf.c. K. Mitchum 12/86.    Macify routines for jove. */
name|int
name|CurrentVol
decl_stmt|;
comment|/* see tfile.c */
define|#
directive|define
name|TYPES
value|-1
specifier|static
name|Point
name|px
init|=
block|{
literal|100
block|,
literal|100
block|}
decl_stmt|;
specifier|static
name|char
name|pmess
index|[]
init|=
literal|"\pSave file as: "
decl_stmt|;
specifier|static
name|pascal
name|Boolean
name|Ffilter
parameter_list|(
name|p
parameter_list|)
name|FileParam
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|ioFlFndrInfo
operator|.
name|fdType
operator|==
literal|'APPL'
condition|)
return|return
name|TRUE
return|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|ioNamePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|ioNamePtr
argument_list|,
name|d_tempfile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CtoPstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|ioNamePtr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|CtoPstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|ioNamePtr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
specifier|static
name|void
name|check_dir
parameter_list|()
block|{
if|if
condition|(
name|cur_vol
operator|!=
literal|0
operator|-
name|SFSaveDisk
operator|||
name|cur_dir
operator|!=
name|CurDirStore
condition|)
block|{
name|setdir
argument_list|(
literal|0
operator|-
name|SFSaveDisk
argument_list|,
name|CurDirStore
argument_list|)
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* make sure jove knows the change */
name|Modechange
operator|++
expr_stmt|;
name|setCWD
argument_list|(
name|getwd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|char
modifier|*
name|gfile
parameter_list|(
name|namebuf
parameter_list|)
comment|/* return a filename to get */
name|char
modifier|*
name|namebuf
decl_stmt|;
block|{
name|SFReply
name|frec
decl_stmt|;
name|char
name|ans
index|[
name|FILESIZE
index|]
decl_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|cur_vol
expr_stmt|;
comment|/* in case a Desk Accessory changed them */
name|CurDirStore
operator|=
name|cur_dir
expr_stmt|;
name|SFGetFile
argument_list|(
name|px
argument_list|,
literal|0L
argument_list|,
name|Ffilter
argument_list|,
name|TYPES
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
operator|&
name|frec
argument_list|)
expr_stmt|;
name|check_dir
argument_list|()
expr_stmt|;
comment|/* see if any change, set if so */
if|if
condition|(
name|frec
operator|.
name|good
condition|)
block|{
name|EventRecord
name|theEvent
decl_stmt|;
while|while
condition|(
name|GetNextEvent
argument_list|(
name|updateMask
argument_list|,
operator|&
name|theEvent
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|doUpdate
argument_list|(
operator|&
name|theEvent
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ans
argument_list|,
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
name|PathParse
argument_list|(
name|ans
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|namebuf
operator|)
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|char
modifier|*
name|pfile
parameter_list|(
name|namebuf
parameter_list|)
name|char
modifier|*
name|namebuf
decl_stmt|;
block|{
name|SFReply
name|frec
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|nm
decl_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|cur_vol
expr_stmt|;
comment|/* in case a Desk Accessory changed them */
name|CurDirStore
operator|=
name|cur_dir
expr_stmt|;
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|filename
argument_list|(
name|curbuf
argument_list|)
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|SFPutFile
argument_list|(
name|px
argument_list|,
name|pmess
argument_list|,
name|nm
argument_list|,
literal|0L
argument_list|,
operator|&
name|frec
argument_list|)
expr_stmt|;
name|check_dir
argument_list|()
expr_stmt|;
comment|/* see if any change, set if so */
if|if
condition|(
name|frec
operator|.
name|good
condition|)
block|{
name|EventRecord
name|theEvent
decl_stmt|;
while|while
condition|(
name|GetNextEvent
argument_list|(
name|updateMask
argument_list|,
operator|&
name|theEvent
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|doUpdate
argument_list|(
operator|&
name|theEvent
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
expr_stmt|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|t
operator|++
expr_stmt|;
comment|/* convert to unix style */
name|nm
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|nm
condition|)
block|{
if|if
condition|(
operator|*
name|nm
operator|==
literal|':'
condition|)
operator|*
name|nm
operator|=
literal|'/'
expr_stmt|;
name|nm
operator|++
expr_stmt|;
block|}
name|PathParse
argument_list|(
name|t
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|namebuf
operator|)
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* getArgs() returns an argument list based on documents clicked on by the user. */
name|int
name|getArgs
parameter_list|(
name|avp
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|avp
decl_stmt|;
block|{
name|int
name|argc
decl_stmt|,
name|nargs
decl_stmt|,
name|type
decl_stmt|,
name|old_vol
decl_stmt|;
name|long
name|old_dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|AppFile
name|p
decl_stmt|;
name|WDPBRec
name|d
decl_stmt|;
name|old_vol
operator|=
name|cur_vol
expr_stmt|;
name|old_dir
operator|=
name|cur_dir
expr_stmt|;
name|CountAppFiles
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
comment|/* files to open... */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nargs
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|argc
operator|=
literal|1
init|;
name|argc
operator|<=
name|nargs
condition|;
name|argc
operator|++
control|)
block|{
name|GetAppFiles
argument_list|(
name|argc
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|.
name|fName
argument_list|)
expr_stmt|;
name|d
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|ioNamePtr
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|ioVRefNum
operator|=
name|p
operator|.
name|vRefNum
expr_stmt|;
name|d
operator|.
name|ioWDIndex
operator|=
literal|0
expr_stmt|;
name|PBGetWDInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_vol
operator|=
name|d
operator|.
name|ioWDVRefNum
expr_stmt|;
name|cur_dir
operator|=
name|d
operator|.
name|ioWDDirID
expr_stmt|;
name|pathname
operator|=
name|getwd
argument_list|()
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|.
name|fName
argument_list|)
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|.
name|fName
argument_list|)
expr_stmt|;
block|}
name|ClrAppFiles
argument_list|(
name|argc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
name|argc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
literal|"jove"
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|avp
operator|=
name|argv
expr_stmt|;
name|cur_dir
operator|=
name|old_dir
expr_stmt|;
name|cur_vol
operator|=
name|old_vol
expr_stmt|;
return|return
operator|(
name|argc
operator|)
return|;
block|}
comment|/* Limited version of getenv() */
name|char
modifier|*
name|getenv
parameter_list|(
name|item
parameter_list|)
name|char
modifier|*
name|item
decl_stmt|;
block|{
name|char
modifier|*
name|ret
init|=
literal|0
decl_stmt|,
modifier|*
name|str
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|item
argument_list|,
literal|"CWD"
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|=
name|getwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|item
argument_list|,
literal|"HOME"
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|=
name|gethome
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|ret
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|char
modifier|*
name|mktemp
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
return|;
block|}
comment|/* Menu routines. The menus items are set up in a similar manner as keys, and    are bound prior to runtime. See menumaps.txt, which must be run through setmaps.    Unlike keys, menu items may be bound to variables, and to buffers. Buffer binding    is only done at runtime. */
specifier|static
name|void
name|InitLocalMenus
parameter_list|()
block|{
name|void
name|InitMenu
argument_list|()
decl_stmt|,
name|make_edits
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
condition|;
name|i
operator|++
control|)
block|{
name|InitMenu
argument_list|(
operator|&
name|Menus
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|make_edits
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|menu_id
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|InitMenu
parameter_list|(
name|M
parameter_list|)
name|struct
name|menu
modifier|*
name|M
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|M
operator|->
name|menu_id
operator|==
literal|0
condition|)
return|return;
name|M
operator|->
name|Mn
operator|=
name|NewMenu
argument_list|(
name|M
operator|->
name|menu_id
argument_list|,
name|CtoPstr
argument_list|(
name|M
operator|->
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|M
operator|->
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUITEMS
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
name|M
operator|->
name|m
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
break|break;
comment|/* last item... */
switch|switch
condition|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
condition|)
block|{
case|case
operator|(
name|STRING
operator|)
case|:
name|AppendMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|CtoPstr
argument_list|(
name|d
operator|->
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|VARIABLE
operator|)
case|:
name|SetItemMark
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
case|case
operator|(
name|FUNCTION
operator|)
case|:
name|CtoPstr
argument_list|(
name|name
operator|=
operator|(
operator|(
name|data_obj
operator|*
operator|)
name|d
operator|)
operator|->
name|Name
argument_list|)
expr_stmt|;
name|AppendMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|InsertMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ProcMenu
parameter_list|(
name|menuno
parameter_list|,
name|itemno
parameter_list|)
name|int
name|menuno
decl_stmt|,
name|itemno
decl_stmt|;
block|{
name|void
name|MacSetVar
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
operator|&&
name|Menus
index|[
name|i
index|]
operator|.
name|menu_id
operator|!=
name|menuno
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|NMENUS
condition|)
block|{
comment|/* found the menu */
name|itemno
operator|--
expr_stmt|;
name|d
operator|=
name|Menus
index|[
name|i
index|]
operator|.
name|m
index|[
name|itemno
index|]
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
condition|)
block|{
case|case
name|FUNCTION
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUFFER
case|:
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|tiewind
argument_list|(
name|curwind
argument_list|,
operator|(
name|Buffer
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARIABLE
case|:
name|MacSetVar
argument_list|(
operator|(
expr|struct
name|variable
operator|*
operator|)
name|d
argument_list|,
name|i
argument_list|,
name|itemno
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
block|}
specifier|static
name|void
name|make_edits
parameter_list|(
name|menu
parameter_list|)
comment|/* add dummy edit menu */
name|int
name|menu
decl_stmt|;
block|{
name|MenuHandle
name|M
decl_stmt|;
name|int
name|item
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|M
operator|=
name|NewMenu
argument_list|(
operator|(
name|menu
operator|)
argument_list|,
literal|"\pEdit"
argument_list|)
expr_stmt|;
name|AppendMenu
argument_list|(
name|M
argument_list|,
literal|"\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear;Select All;(-;Show Clipboard"
argument_list|)
expr_stmt|;
name|InsertMenu
argument_list|(
name|M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DisableItem
argument_list|(
name|M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|menus_off
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Keyonly
operator|||
name|EventCmd
condition|)
return|return;
name|DisableItem
argument_list|(
name|SysMenu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
condition|)
name|DisableItem
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Keyonly
operator|=
literal|1
expr_stmt|;
name|DrawMenuBar
argument_list|()
expr_stmt|;
block|}
name|void
name|menus_on
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Keyonly
operator|==
literal|0
condition|)
return|return;
name|EnableItem
argument_list|(
name|SysMenu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
condition|)
name|EnableItem
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Keyonly
operator|=
literal|0
expr_stmt|;
name|DrawMenuBar
argument_list|()
expr_stmt|;
block|}
specifier|static
name|char
modifier|*
name|BufMPrint
parameter_list|(
name|b
parameter_list|,
name|i
parameter_list|)
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|nm
init|=
name|filename
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|char
name|t
index|[
literal|35
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|nm
argument_list|)
operator|>
literal|30
condition|)
block|{
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
argument_list|,
name|nm
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
operator|-
literal|30
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|nm
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|nm
condition|)
block|{
switch|switch
condition|(
operator|*
name|nm
condition|)
block|{
comment|/* ugh... these are metacharacter for Menus */
case|case
literal|'/'
case|:
operator|*
name|nm
operator|=
literal|':'
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'<'
case|:
case|case
literal|'('
case|:
case|case
literal|';'
case|:
operator|*
name|nm
operator|=
literal|'.'
expr_stmt|;
break|break;
comment|/* that will confuse everybody */
block|}
name|nm
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|sprint
argument_list|(
literal|"%-2d %-11s \"%-s\""
argument_list|,
name|i
argument_list|,
name|b
operator|->
name|b_name
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
specifier|static
name|void
name|SetBufMenu
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|stop
decl_stmt|;
name|struct
name|menu
modifier|*
name|M
decl_stmt|;
name|Bufchange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
operator|&&
name|strcmp
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|Name
argument_list|,
literal|"Buffer"
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|NMENUS
condition|)
block|{
name|M
operator|=
operator|&
name|Menus
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMENUITEMS
operator|&&
operator|(
name|d
operator|=
name|Menus
index|[
name|i
index|]
operator|.
name|m
index|[
name|j
index|]
operator|)
operator|&&
operator|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|!=
name|BUFFER
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|<
name|NMENUITEMS
condition|)
block|{
for|for
control|(
name|i
operator|=
name|j
operator|,
name|b
operator|=
name|world
init|;
name|i
operator|<
name|NMENUITEMS
operator|&&
name|b
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|M
operator|->
name|m
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|AppendMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|CtoPstr
argument_list|(
name|BufMPrint
argument_list|(
name|b
argument_list|,
name|i
operator|-
name|j
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add the item */
else|else
name|SetItem
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|CtoPstr
argument_list|(
name|BufMPrint
argument_list|(
name|b
argument_list|,
name|i
operator|-
name|j
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or change it */
name|M
operator|->
name|m
index|[
name|i
index|]
operator|=
operator|(
name|data_obj
operator|*
operator|)
name|b
expr_stmt|;
block|}
name|stop
operator|=
name|i
expr_stmt|;
comment|/* out of buffers? */
for|for
control|(
init|;
name|i
operator|<
name|NMENUITEMS
operator|&&
name|M
operator|->
name|m
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|DelMenuItem
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|stop
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* take off last item */
name|M
operator|->
name|m
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
specifier|static
name|void
name|MacSetVar
parameter_list|(
name|vp
parameter_list|,
name|mnu
parameter_list|,
name|itm
parameter_list|)
comment|/* Set a variable from the menu */
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
comment|/* Liberally taken from SetVar() in extend.c */
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
block|{
name|void
name|MarkVar
parameter_list|()
function_decl|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|prompt
operator|=
name|sprint
argument_list|(
literal|"Set %s: "
argument_list|,
name|vp
operator|->
name|Name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
condition|)
block|{
case|case
name|V_BASE10
case|:
case|case
name|V_BASE8
case|:
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|ask_int
argument_list|(
name|prompt
argument_list|,
operator|(
operator|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
operator|)
operator|==
name|V_BASE10
operator|)
condition|?
literal|10
else|:
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|value
expr_stmt|;
break|break;
block|}
case|case
name|V_BOOL
case|:
comment|/* toggle the value */
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
operator|(
operator|*
name|vp
operator|->
name|v_value
operator|==
name|ON
condition|?
name|OFF
else|:
name|ON
operator|)
expr_stmt|;
name|MarkVar
argument_list|(
name|vp
argument_list|,
name|mnu
argument_list|,
name|itm
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_FILENAME
case|:
case|case
name|V_STRING
case|:
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Do_ask() so you can set string to "" if you so desire. */
name|str
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
name|str
operator|=
name|NullStr
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* ... and hope there is enough room. */
break|break;
block|}
case|case
name|V_CHAR
case|:
name|f_mess
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|addgetc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_MODELINE
condition|)
name|UpdModLine
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_CLRSCREEN
condition|)
name|ClAndRedraw
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TTY_RESET
condition|)
name|tty_reset
argument_list|()
expr_stmt|;
comment|/* probably none on a Mac */
return|return;
block|}
specifier|static
name|void
name|MarkModes
parameter_list|()
block|{
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|,
name|checked
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
name|Modechange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mnu
operator|=
literal|0
init|;
name|mnu
operator|<
name|NMENUS
condition|;
name|mnu
operator|++
control|)
for|for
control|(
name|itm
operator|=
literal|0
init|;
name|itm
operator|<
name|NMENUITEMS
condition|;
name|itm
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|d
operator|->
name|Type
operator|&
operator|(
name|MAJOR_MODE
operator||
name|MINOR_MODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|==
name|BUFFER
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|Type
operator|&
operator|(
name|MAJOR_MODE
operator|)
condition|)
name|checked
operator|=
operator|(
name|curbuf
operator|->
name|b_major
operator|==
operator|(
name|d
operator|->
name|Type
operator|>>
literal|8
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|Type
operator|&
operator|(
name|MINOR_MODE
operator|)
condition|)
name|checked
operator|=
operator|(
name|curbuf
operator|->
name|b_minor
operator|&
operator|(
name|d
operator|->
name|Type
operator|>>
literal|8
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|checked
operator|=
operator|(
name|d
operator|==
operator|(
name|data_obj
operator|*
operator|)
name|curbuf
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CheckItem
argument_list|(
name|Menus
index|[
name|mnu
index|]
operator|.
name|Mn
argument_list|,
name|itm
operator|+
literal|1
argument_list|,
name|checked
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|MarkVar
parameter_list|(
name|vp
parameter_list|,
name|mnu
parameter_list|,
name|itm
parameter_list|)
comment|/* mark a boolean menu item */
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
block|{
name|int
name|checked
decl_stmt|;
if|if
condition|(
name|mnu
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* we don't know the item... slow */
name|int
name|found
decl_stmt|;
for|for
control|(
name|mnu
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
operator|(
name|mnu
operator|<
name|NMENUS
operator|)
operator|&&
operator|!
name|found
condition|;
name|mnu
operator|++
control|)
block|{
for|for
control|(
name|itm
operator|=
literal|0
init|;
operator|(
name|itm
operator|<
name|NMENUITEMS
operator|)
condition|;
name|itm
operator|++
control|)
if|if
condition|(
operator|(
expr|struct
name|variable
operator|*
operator|)
operator|(
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
operator|)
operator|==
name|vp
condition|)
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return;
block|}
name|checked
operator|=
operator|(
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|==
name|ON
operator|)
expr_stmt|;
name|CheckItem
argument_list|(
name|Menus
index|[
name|mnu
index|]
operator|.
name|Mn
argument_list|,
name|itm
operator|+
literal|1
argument_list|,
name|checked
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|MarkAllVar
parameter_list|()
comment|/* slow, but only do it once */
block|{
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|mnu
operator|=
literal|0
init|;
name|mnu
operator|<
name|NMENUS
condition|;
name|mnu
operator|++
control|)
for|for
control|(
name|itm
operator|=
literal|0
init|;
name|itm
operator|<
name|NMENUITEMS
condition|;
name|itm
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|==
name|VARIABLE
condition|)
name|MarkVar
argument_list|(
operator|(
expr|struct
name|variable
operator|*
operator|)
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
argument_list|,
name|mnu
argument_list|,
name|itm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Screen routines and driver. The Macinitosh Text Edit routines are not utilized,    as they are slow and cumbersome for a terminal emulator. Instead, direct QuickDraw    calls are used. The fastest output is obtained writing a line at a time, rather    than on a character basis, so the major output routine is writechr(), which takes    a pascal-style string as an argument. See bufputc() in screen.c. */
name|void
name|Placur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|CapCol
operator|=
name|col
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|putcurs
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|ON
argument_list|)
expr_stmt|;
block|}
name|void
name|NPlacur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|CapCol
operator|=
name|col
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|putcurs
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
block|}
name|void
name|i_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dellines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inslines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
block|}
name|void
name|d_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dellines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inslines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
block|}
name|void
name|clr_page
parameter_list|()
block|{
name|void
name|wipescreen
parameter_list|()
function_decl|;
name|wipescreen
argument_list|()
expr_stmt|;
block|}
name|void
name|clr_eoln
parameter_list|()
block|{
name|void
name|wipeline
parameter_list|()
function_decl|;
name|wipeline
argument_list|()
expr_stmt|;
block|}
name|void
name|SO_on
parameter_list|()
block|{
name|void
name|HLmode
parameter_list|()
function_decl|;
name|HLmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|SO_off
parameter_list|()
block|{
name|void
name|HLmode
parameter_list|()
function_decl|;
name|HLmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* (ORIGINALLY IN) tn.c   */
comment|/* window driver for MacIntosh using windows. */
comment|/* K. Mitchum 9/86 */
comment|/*#define VARFONT*/
ifdef|#
directive|ifdef
name|VARFONT
specifier|static
name|height
operator|,
name|width
operator|,
name|theight
operator|,
name|twidth
operator|,
name|descent
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|height
value|HEIGHT
define|#
directive|define
name|width
value|WIDTH
define|#
directive|define
name|theight
value|THEIGHT
define|#
directive|define
name|twidth
value|TWIDTH
define|#
directive|define
name|descent
value|DESCENT
endif|#
directive|endif
specifier|static
name|trow
operator|,
name|tcol
operator|,
name|insert
operator|,
name|tattr
operator|,
name|cursor
expr_stmt|;
specifier|static
name|Rect
name|cursor_rect
decl_stmt|;
specifier|static
name|Rect
name|vRect
decl_stmt|;
specifier|static
name|WindowRecord
name|myWindowRec
decl_stmt|;
specifier|static
name|Rect
name|myBoundsRect
decl_stmt|;
define|#
directive|define
name|active
parameter_list|()
value|SetPort(theScreen)
comment|/*#define active()*/
define|#
directive|define
name|maxadjust
parameter_list|(
name|r
parameter_list|)
value|OffsetRect(r,0,2);
specifier|static
name|void
name|tn_init
parameter_list|()
block|{
name|void
name|INSmode
argument_list|()
decl_stmt|,
name|init_slate
argument_list|()
decl_stmt|;
name|HLmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init_slate
argument_list|()
expr_stmt|;
name|ShowPen
argument_list|()
expr_stmt|;
block|}
specifier|static
name|void
name|wipescreen
parameter_list|()
comment|/* clear and home function */
block|{
name|Rect
name|r
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WINDWIDTH
argument_list|,
name|WINDHEIGHT
argument_list|)
expr_stmt|;
name|EraseRect
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|OFF
expr_stmt|;
name|putcurs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawfluff
argument_list|()
expr_stmt|;
block|}
specifier|static
name|void
name|putcurs
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|,
name|vis
parameter_list|)
name|unsigned
name|row
decl_stmt|,
name|col
decl_stmt|,
name|vis
decl_stmt|;
block|{
comment|/*	if(row> MAXROW || col> MAXCOL) return(ERROR);*/
comment|/*	if(row != trow || col != tcol) */
block|{
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|==
name|MAXROW
condition|)
name|MoveTo
argument_list|(
name|col
operator|*
name|width
argument_list|,
operator|(
name|row
operator|+
literal|1
operator|)
operator|*
name|height
operator|+
literal|2
operator|-
name|descent
argument_list|)
expr_stmt|;
else|else
name|MoveTo
argument_list|(
name|col
operator|*
name|width
argument_list|,
operator|(
name|row
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
name|descent
argument_list|)
expr_stmt|;
name|trow
operator|=
name|row
expr_stmt|;
name|tcol
operator|=
name|col
expr_stmt|;
name|curset
argument_list|(
name|vis
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|curset
parameter_list|(
name|desired
parameter_list|)
block|{
if|if
condition|(
name|cursor
operator|!=
name|desired
condition|)
block|{
name|SetRect
argument_list|(
operator|&
name|cursor_rect
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
operator|(
name|trow
operator|)
operator|*
name|height
argument_list|,
operator|(
name|tcol
operator|+
literal|1
operator|)
operator|*
name|width
operator|-
literal|1
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|cursor_rect
argument_list|)
expr_stmt|;
name|InvertRect
argument_list|(
operator|&
name|cursor_rect
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|desired
expr_stmt|;
block|}
block|}
name|void
name|putp
parameter_list|(
name|p
parameter_list|)
comment|/* put one character, advance cursor */
name|int
name|p
decl_stmt|;
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
specifier|static
name|RgnHandle
name|updateRgn
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert
condition|)
block|{
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
name|width
argument_list|,
literal|0
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|'0'
condition|)
name|p
operator|=
literal|0xAF
expr_stmt|;
comment|/* slashed zero */
name|DrawChar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcol
operator|>=
name|MAXCOL
condition|)
name|putcurs
argument_list|(
name|trow
argument_list|,
name|MAXCOL
argument_list|)
expr_stmt|;
else|else
name|putcurs
argument_list|(
name|trow
argument_list|,
name|tcol
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|wipeline
parameter_list|()
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|cursor
operator|=
name|OFF
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|EraseRect
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|curset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|delchars
parameter_list|()
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
specifier|static
name|RgnHandle
name|updateRgn
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|twidth
operator|-
name|width
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
operator|-
name|width
argument_list|,
literal|0
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
name|curset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dellines
parameter_list|(
name|n
parameter_list|,
name|bot
parameter_list|)
name|int
name|n
decl_stmt|,
name|bot
decl_stmt|;
block|{
name|Rect
name|r
decl_stmt|;
name|RgnHandle
name|updateRgn
decl_stmt|;
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|trow
operator|)
operator|*
name|height
operator|)
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
operator|(
name|bot
operator|+
literal|1
operator|)
operator|*
name|height
operator|)
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
literal|0
operator|-
operator|(
name|n
operator|*
name|height
operator|)
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
name|putcurs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|inslines
parameter_list|(
name|n
parameter_list|,
name|bot
parameter_list|)
name|int
name|n
decl_stmt|,
name|bot
decl_stmt|;
block|{
name|Rect
name|r
decl_stmt|;
name|RgnHandle
name|updateRgn
decl_stmt|;
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
name|bot
operator|+
literal|1
operator|)
operator|*
name|height
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
operator|(
name|n
operator|*
name|height
operator|)
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
name|putcurs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|INSmode
parameter_list|(
name|new
parameter_list|)
name|int
name|new
decl_stmt|;
block|{
name|insert
operator|=
name|new
expr_stmt|;
block|}
specifier|static
name|void
name|HLmode
parameter_list|(
name|new
parameter_list|)
name|int
name|new
decl_stmt|;
block|{
if|if
condition|(
name|new
condition|)
name|tattr
operator|=
literal|1
expr_stmt|;
else|else
name|tattr
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|writechr
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* actually, a Str255 type string */
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
specifier|static
name|RgnHandle
name|updateRgn
decl_stmt|;
specifier|register
name|len
expr_stmt|;
specifier|register
name|char
name|save
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|start
index|[
literal|0
index|]
expr_stmt|;
comment|/* adjusted 6/86 K. M. in td.c*/
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert
condition|)
block|{
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|twidth
operator|-
name|width
operator|*
name|len
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
name|width
operator|*
name|len
argument_list|,
literal|0
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
block|}
name|DrawString
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcol
operator|>=
name|MAXCOL
condition|)
name|putcurs
argument_list|(
name|trow
argument_list|,
name|MAXCOL
argument_list|)
expr_stmt|;
else|else
name|putcurs
argument_list|(
name|trow
argument_list|,
name|tcol
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|reset
parameter_list|()
block|{}
specifier|static
name|void
name|blanks
parameter_list|()
block|{}
specifier|static
name|void
name|cleanup
parameter_list|()
block|{}
specifier|static
name|void
name|init_slate
parameter_list|()
block|{
name|FontInfo
name|f
decl_stmt|;
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
name|char
modifier|*
name|Name
init|=
literal|"MacJove "
decl_stmt|;
name|char
modifier|*
name|Title
decl_stmt|;
name|InitGraf
argument_list|(
operator|&
name|thePort
argument_list|)
expr_stmt|;
name|InitWindows
argument_list|()
expr_stmt|;
name|InitCursor
argument_list|()
expr_stmt|;
name|InitFonts
argument_list|()
expr_stmt|;
name|InitMenus
argument_list|()
expr_stmt|;
name|InitDialogs
argument_list|(
operator|(
name|ProcPtr
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* no restart proc */
name|tn_left
operator|=
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|+
literal|3
expr_stmt|;
name|tn_top
operator|=
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|+
literal|40
expr_stmt|;
name|tn_rows
operator|=
operator|(
name|screenBits
operator|.
name|bounds
operator|.
name|bottom
operator|-
literal|3
operator|-
name|tn_top
operator|)
operator|/
name|HEIGHT
expr_stmt|;
name|tn_cols
operator|=
operator|(
name|screenBits
operator|.
name|bounds
operator|.
name|right
operator|-
literal|3
operator|-
name|tn_left
operator|-
name|SCROLLWIDTH
operator|)
operator|/
name|WIDTH
expr_stmt|;
name|tn_right
operator|=
name|tn_left
operator|+
name|tn_cols
operator|*
name|WIDTH
operator|+
name|SCROLLWIDTH
expr_stmt|;
name|tn_bottom
operator|=
name|tn_top
operator|+
name|tn_rows
operator|*
name|HEIGHT
operator|+
literal|2
expr_stmt|;
name|tn_cols
operator|++
expr_stmt|;
comment|/* kludge to get jove to use last col */
name|LI
operator|=
name|tn_rows
expr_stmt|;
name|CO
operator|=
name|tn_cols
expr_stmt|;
name|MAXROW
operator|=
name|tn_rows
operator|-
literal|1
expr_stmt|;
name|MAXCOL
operator|=
name|tn_cols
operator|-
literal|1
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|myBoundsRect
argument_list|,
name|tn_left
argument_list|,
name|tn_top
argument_list|,
name|tn_right
argument_list|,
name|tn_bottom
argument_list|)
expr_stmt|;
name|Title
operator|=
name|sprint
argument_list|(
literal|"%s%s"
argument_list|,
name|Name
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|theScreen
operator|=
name|NewWindow
argument_list|(
operator|&
name|myWindowRec
argument_list|,
operator|&
name|myBoundsRect
argument_list|,
name|CtoPstr
argument_list|(
name|Title
argument_list|)
argument_list|,
literal|1
argument_list|,
name|noGrowDocProc
argument_list|,
operator|(
name|WindowPtr
operator|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
comment|/*	SetOrigin(-3,-1);*/
operator|(
name|theScreen
operator|)
operator|->
name|txFont
operator|=
name|FONT
expr_stmt|;
operator|(
name|theScreen
operator|)
operator|->
name|txSize
operator|=
name|TEXTSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|VARFONT
name|GetFontInfo
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
name|height
operator|=
name|f
operator|.
name|ascent
operator|+
name|f
operator|.
name|descent
operator|+
name|f
operator|.
name|leading
expr_stmt|;
name|width
operator|=
name|f
operator|.
name|widMax
expr_stmt|;
name|twidth
operator|=
name|width
operator|*
name|tn_cols
expr_stmt|;
name|theight
operator|=
name|height
operator|*
name|tn_rows
expr_stmt|;
name|descent
operator|=
name|f
operator|.
name|descent
expr_stmt|;
endif|#
directive|endif
comment|/*	(theScreen)->lineHeight = height; 	(theScreen)->fontAscent = ASCENT;*/
name|theScreen
operator|->
name|txMode
operator|=
name|patCopy
expr_stmt|;
name|theScreen
operator|->
name|pnMode
operator|=
name|patCopy
expr_stmt|;
name|PenNormal
argument_list|()
expr_stmt|;
name|cursor
operator|=
name|OFF
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

end_unit

