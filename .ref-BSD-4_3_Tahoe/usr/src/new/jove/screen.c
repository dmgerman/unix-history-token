begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_comment
comment|/* here come the actual emulation routines	*/
end_comment

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_define
define|#
directive|define
name|BYTE
value|unsigned char
end_define

begin_define
define|#
directive|define
name|WORD
value|unsigned int
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINT_ARGS
end_ifdef

begin_function_decl
name|private
name|BYTE
name|near
name|get_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|WORD
name|near
name|cur_page
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|get_cur
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|near
name|ch_out
argument_list|(
name|BYTE
argument_list|,
name|BYTE
argument_list|)
decl_stmt|,
name|near
name|clr_eop
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|cur_advance
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|cur_down
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|cur_left
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|cur_right
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|cur_up
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|line_feed
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|near
name|normfun
argument_list|(
name|char
argument_list|)
decl_stmt|,
name|near
name|scr_win
argument_list|(
name|int
argument_list|,
name|BYTE
argument_list|,
name|BYTE
argument_list|,
name|BYTE
argument_list|,
name|BYTE
argument_list|)
decl_stmt|,
name|near
name|set_cur
argument_list|(
name|WORD
argument_list|)
decl_stmt|,
name|near
name|set_mode
argument_list|(
name|BYTE
argument_list|)
decl_stmt|,
name|near
name|wherexy
argument_list|(
name|BYTE
operator|*
argument_list|,
name|BYTE
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|private
name|BYTE
name|near
name|get_mode
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|WORD
name|near
name|cur_page
argument_list|()
decl_stmt|,
name|near
name|get_cur
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|near
name|ch_out
argument_list|()
decl_stmt|,
name|near
name|clr_eop
argument_list|()
decl_stmt|,
name|near
name|cur_advance
argument_list|()
decl_stmt|,
name|near
name|cur_down
argument_list|()
decl_stmt|,
name|near
name|cur_left
argument_list|()
decl_stmt|,
name|near
name|cur_right
argument_list|()
decl_stmt|,
name|near
name|cur_up
argument_list|()
decl_stmt|,
name|near
name|line_feed
argument_list|()
decl_stmt|,
name|near
name|normfun
argument_list|()
decl_stmt|,
name|near
name|scr_win
argument_list|()
decl_stmt|,
name|near
name|set_cur
argument_list|()
decl_stmt|,
name|near
name|set_mode
argument_list|()
decl_stmt|,
name|near
name|wherexy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINT_ARGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VIDEO
value|0x10
end_define

begin_define
define|#
directive|define
name|intr
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
value|int86(n, r, r);
end_define

begin_decl_stmt
name|BYTE
name|CHPL
init|=
literal|80
decl_stmt|,
name|LPP
init|=
literal|25
decl_stmt|,
name|CUR_PAGE
init|=
literal|0
decl_stmt|,
name|C_ATTR
init|=
literal|0x07
decl_stmt|,
name|C_X
init|=
literal|0
decl_stmt|,
name|C_Y
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Fgcolor
init|=
literal|7
decl_stmt|,
name|Bgcolor
init|=
literal|0
decl_stmt|,
name|Mdcolor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setcolor
parameter_list|(
name|fg
parameter_list|,
name|bg
parameter_list|)
name|BYTE
name|fg
decl_stmt|,
name|bg
decl_stmt|;
block|{
name|C_ATTR
operator|=
operator|(
operator|(
name|bg
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|fg
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|WORD
name|near
name|cur_page
parameter_list|()
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x0f
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
return|return
operator|(
name|vr
operator|.
name|h
operator|.
name|bh
operator|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|set_cur
parameter_list|(
name|xy
parameter_list|)
name|WORD
name|xy
decl_stmt|;
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|bh
operator|=
name|CUR_PAGE
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x02
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|dx
operator|=
name|xy
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|WORD
name|near
name|get_cur
parameter_list|()
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|bh
operator|=
name|CUR_PAGE
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x03
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
return|return
operator|(
name|vr
operator|.
name|x
operator|.
name|dx
operator|)
return|;
block|}
end_function

begin_function
name|private
name|BYTE
name|near
name|get_mode
parameter_list|()
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x0f
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
return|return
operator|(
name|vr
operator|.
name|h
operator|.
name|al
operator|)
return|;
block|}
end_function

begin_function
name|BYTE
name|lpp
parameter_list|()
block|{
name|int
name|far
modifier|*
name|regen
init|=
operator|(
name|int
name|far
operator|*
operator|)
literal|0x44C
decl_stmt|;
name|int
name|what
decl_stmt|;
name|BYTE
name|chpl
parameter_list|()
function_decl|;
name|what
operator|=
operator|(
operator|*
name|regen
operator|&
literal|0xff00
operator|)
operator|/
literal|2
operator|/
name|chpl
argument_list|()
expr_stmt|;
return|return
operator|(
name|what
operator|>
literal|43
condition|?
literal|25
else|:
name|what
operator|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|set_mode
parameter_list|(
name|n
parameter_list|)
name|BYTE
name|n
decl_stmt|;
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x00
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|al
operator|=
name|n
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|gotoxy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|set_cur((x)<<8|((y)&0xff))
end_define

begin_define
define|#
directive|define
name|cur_mov
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|set_cur((C_X=x)<<8|((C_Y=y)&0xff))
end_define

begin_function
name|private
name|void
name|near
name|wherexy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|BYTE
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|WORD
name|xy
decl_stmt|;
name|xy
operator|=
name|get_cur
argument_list|()
expr_stmt|;
operator|*
name|x
operator|=
name|xy
operator|>>
literal|8
expr_stmt|;
operator|*
name|y
operator|=
name|xy
operator|&
literal|0xff
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|wherex
parameter_list|()
value|C_X
end_define

begin_define
define|#
directive|define
name|wherey
parameter_list|()
value|C_Y
end_define

begin_function
name|private
name|void
name|near
name|scr_win
parameter_list|(
name|no
parameter_list|,
name|ulr
parameter_list|,
name|ulc
parameter_list|,
name|lrr
parameter_list|,
name|lrc
parameter_list|)
name|int
name|no
decl_stmt|;
name|BYTE
name|ulr
decl_stmt|,
name|ulc
decl_stmt|,
name|lrr
decl_stmt|,
name|lrc
decl_stmt|;
block|{
name|union
name|REGS
name|vr
decl_stmt|;
if|if
condition|(
name|no
operator|>=
literal|0
condition|)
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x06
expr_stmt|;
else|else
block|{
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x07
expr_stmt|;
name|no
operator|=
operator|-
name|no
expr_stmt|;
block|}
name|vr
operator|.
name|h
operator|.
name|al
operator|=
name|no
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|cx
operator|=
name|ulr
operator|<<
literal|8
operator||
name|ulc
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|dx
operator|=
name|lrr
operator|<<
literal|8
operator||
name|lrc
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bh
operator|=
name|C_ATTR
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|BYTE
name|chpl
parameter_list|()
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x0f
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
return|return
operator|(
name|vr
operator|.
name|h
operator|.
name|ah
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|clr_page
parameter_list|()
value|scr_win(0, 0, 0, LPP-1, CHPL-1), \ 			gotoxy(C_X = 0, C_Y = 0)
end_define

begin_function
name|private
name|void
name|near
name|cur_right
parameter_list|()
block|{
if|if
condition|(
name|C_Y
operator|<
name|CHPL
operator|-
literal|1
condition|)
name|C_Y
operator|++
expr_stmt|;
name|gotoxy
argument_list|(
name|C_X
argument_list|,
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|cur_up
parameter_list|()
block|{
if|if
condition|(
name|C_X
condition|)
name|C_X
operator|--
expr_stmt|;
name|gotoxy
argument_list|(
name|C_X
argument_list|,
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|cur_left
parameter_list|()
block|{
if|if
condition|(
name|C_Y
condition|)
name|C_Y
operator|--
expr_stmt|;
name|gotoxy
argument_list|(
name|C_X
argument_list|,
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|cur_down
parameter_list|()
block|{
if|if
condition|(
name|C_X
operator|<
name|LPP
operator|-
literal|1
condition|)
name|C_X
operator|++
expr_stmt|;
name|gotoxy
argument_list|(
name|C_X
argument_list|,
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|ch_out
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|)
name|BYTE
name|c
decl_stmt|,
name|n
decl_stmt|;
block|{
name|union
name|REGS
name|vr
decl_stmt|;
name|vr
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x09
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|al
operator|=
name|c
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bl
operator|=
name|C_ATTR
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bh
operator|=
name|CUR_PAGE
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|cx
operator|=
name|n
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|wrch
parameter_list|(
name|c
parameter_list|)
value|ch_out((c), 1), cur_advance()
end_define

begin_define
define|#
directive|define
name|home_cur
parameter_list|()
value|gotoxy(C_X = 0, C_Y = 0)
end_define

begin_define
define|#
directive|define
name|clr_eoln
parameter_list|()
value|ch_out(' ', CHPL-wherey())
end_define

begin_function
name|private
name|void
name|near
name|clr_eop
parameter_list|()
block|{
name|clr_eoln
argument_list|()
expr_stmt|;
name|scr_win
argument_list|(
name|LPP
operator|-
literal|1
operator|-
name|wherex
argument_list|()
argument_list|,
name|wherex
argument_list|()
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|LPP
operator|-
literal|1
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_43
parameter_list|()
block|{
name|BYTE
name|far
modifier|*
name|info
init|=
operator|(
name|BYTE
name|far
operator|*
operator|)
literal|0x487
decl_stmt|;
name|WORD
name|far
modifier|*
name|CRTC
init|=
operator|(
name|WORD
name|far
operator|*
operator|)
literal|0x463
decl_stmt|;
name|union
name|REGS
name|vr
decl_stmt|;
name|WORD
name|cur
decl_stmt|;
name|CUR_PAGE
operator|=
name|cur_page
argument_list|()
expr_stmt|;
name|CHPL
operator|=
name|chpl
argument_list|()
expr_stmt|;
name|LPP
operator|=
name|lpp
argument_list|()
expr_stmt|;
if|if
condition|(
name|get_mode
argument_list|()
operator|!=
literal|3
condition|)
name|set_mode
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|cur
operator|=
name|get_cur
argument_list|()
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x1112
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bl
operator|=
literal|0
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
operator|*
name|info
operator||=
literal|1
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x0100
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bh
operator|=
literal|0
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|cx
operator|=
literal|0x0600
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
name|outp
argument_list|(
operator|*
name|CRTC
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|outp
argument_list|(
operator|*
name|CRTC
operator|+
literal|1
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x1200
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bl
operator|=
literal|0x20
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
name|LPP
operator|=
name|lpp
argument_list|()
expr_stmt|;
name|set_cur
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|wherexy
argument_list|(
operator|&
name|C_X
argument_list|,
operator|&
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset_43
parameter_list|()
block|{
name|BYTE
name|far
modifier|*
name|info
init|=
operator|(
name|BYTE
name|far
operator|*
operator|)
literal|0x487
decl_stmt|;
name|WORD
name|far
modifier|*
name|CRTC
init|=
operator|(
name|WORD
name|far
operator|*
operator|)
literal|0x463
decl_stmt|;
name|union
name|REGS
name|vr
decl_stmt|;
name|set_mode
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|info
operator|&=
literal|128
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x0100
expr_stmt|;
name|vr
operator|.
name|h
operator|.
name|bh
operator|=
literal|0x0607
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|cx
operator|=
literal|0x0607
expr_stmt|;
name|intr
argument_list|(
name|VIDEO
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
name|outp
argument_list|(
operator|*
name|CRTC
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|outp
argument_list|(
operator|*
name|CRTC
operator|+
literal|1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|scr_up
parameter_list|()
value|scr_win(1, 0, 0, LPP-1, CHPL-1)
end_define

begin_define
define|#
directive|define
name|back_space
parameter_list|()
value|cur_left()
end_define

begin_function
name|private
name|void
name|near
name|line_feed
parameter_list|()
block|{
if|if
condition|(
operator|++
name|C_X
operator|>
name|LPP
operator|-
literal|1
condition|)
block|{
name|C_X
operator|=
name|LPP
operator|-
literal|1
expr_stmt|;
name|scr_up
argument_list|()
expr_stmt|;
block|}
name|gotoxy
argument_list|(
name|C_X
argument_list|,
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BELL_P
value|0x61
end_define

begin_comment
comment|/* speaker */
end_comment

begin_define
define|#
directive|define
name|BELL_D
value|0x2dc
end_define

begin_comment
comment|/* 550 hz  */
end_comment

begin_define
define|#
directive|define
name|TIME_P
value|0x40
end_define

begin_comment
comment|/* timer   */
end_comment

begin_define
define|#
directive|define
name|TINI
value|182
end_define

begin_comment
comment|/* 10110110b timer initialization */
end_comment

begin_function
name|void
name|dobell
parameter_list|(
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
literal|0x8888
decl_stmt|;
name|int
name|orgval
decl_stmt|;
name|outp
argument_list|(
name|TIME_P
operator|+
literal|3
argument_list|,
name|TINI
argument_list|)
expr_stmt|;
name|outp
argument_list|(
name|TIME_P
operator|+
literal|2
argument_list|,
name|BELL_D
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outp
argument_list|(
name|TIME_P
operator|+
literal|2
argument_list|,
name|BELL_D
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|orgval
operator|=
name|inp
argument_list|(
name|BELL_P
argument_list|)
expr_stmt|;
name|outp
argument_list|(
name|BELL_P
argument_list|,
name|orgval
operator||
literal|3
argument_list|)
expr_stmt|;
comment|/* turn speaker on  */
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
empty_stmt|;
name|outp
argument_list|(
name|BELL_P
argument_list|,
name|orgval
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|carriage_return
parameter_list|()
value|gotoxy(wherex(), C_Y = 0)
end_define

begin_function
name|private
name|void
name|near
name|cur_advance
parameter_list|()
block|{
if|if
condition|(
operator|++
name|C_Y
operator|>
name|CHPL
operator|-
literal|1
condition|)
block|{
name|C_Y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|C_X
operator|>
name|LPP
operator|-
literal|1
condition|)
block|{
name|scr_up
argument_list|()
expr_stmt|;
name|C_X
operator|=
name|LPP
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|gotoxy
argument_list|(
name|C_X
argument_list|,
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_term
parameter_list|()
block|{
if|if
condition|(
name|lpp
argument_list|()
operator|==
literal|43
condition|)
name|reset_43
argument_list|()
expr_stmt|;
name|CUR_PAGE
operator|=
name|cur_page
argument_list|()
expr_stmt|;
name|CHPL
operator|=
name|chpl
argument_list|()
expr_stmt|;
name|LPP
operator|=
name|lpp
argument_list|()
expr_stmt|;
name|wherexy
argument_list|(
operator|&
name|C_X
argument_list|,
operator|&
name|C_Y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|private
name|void
name|near
name|normfun
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|write_em
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|normfun
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_emif
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
condition|)
name|write_em
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_emc
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|--
condition|)
name|normfun
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|near
name|normfun
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|10
case|:
name|line_feed
argument_list|()
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|carriage_return
argument_list|()
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|back_space
argument_list|()
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|dobell
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|wrch
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|BufSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|AbortCnt
decl_stmt|,
name|tabstop
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
end_if

begin_decl_stmt
name|int
argument_list|(
operator|*
name|TTins_line
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|TTdel_line
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(IBMPC) || defined(MAC)) */
end_comment

begin_decl_stmt
name|struct
name|scrimage
modifier|*
name|DesiredScreen
init|=
literal|0
decl_stmt|,
modifier|*
name|PhysScreen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|screenline
modifier|*
name|Screen
init|=
literal|0
decl_stmt|,
comment|/* the screen (a bunch of screenline) */
modifier|*
name|Savelines
init|=
literal|0
decl_stmt|,
comment|/* another bunch (LI of them) */
modifier|*
name|Curline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cursor
decl_stmt|,
comment|/* offset into current Line */
modifier|*
name|cursend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CapCol
decl_stmt|,
name|CapLine
decl_stmt|,
name|i_line
decl_stmt|,
name|i_col
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|make_scr
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|ns
decl_stmt|;
specifier|register
name|char
modifier|*
name|nsp
decl_stmt|;
ifdef|#
directive|ifdef
name|RESHAPING
comment|/* In case we are RESHAPING the window! */
if|if
condition|(
name|DesiredScreen
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DesiredScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|PhysScreen
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PhysScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Savelines
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Savelines
argument_list|)
expr_stmt|;
if|if
condition|(
name|Screen
condition|)
block|{
name|free
argument_list|(
name|Screen
operator|->
name|s_line
argument_list|)
expr_stmt|;
comment|/* free all the screen data */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Screen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RESHAPING */
name|DesiredScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|PhysScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|Savelines
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|Screen
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|CO
operator|*
name|LI
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n\rCannot malloc screen!\n"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
control|)
block|{
name|ns
operator|->
name|s_line
operator|=
name|nsp
expr_stmt|;
name|nsp
operator|+=
name|CO
expr_stmt|;
name|ns
operator|->
name|s_length
operator|=
name|nsp
operator|-
literal|1
expr_stmt|;
comment|/* End of Line */
name|ns
operator|+=
literal|1
expr_stmt|;
block|}
name|cl_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clrline
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|cp1
operator|<=
name|cp2
condition|)
operator|*
name|cp1
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|((*cursor != (char) (c)) ? dosputc(c) : (cursor++, i_col++))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(IBMPC) || defined(MAC)) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|dosputc(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|bufputc(c)
end_define

begin_comment
comment|/* line buffered for mac display */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_define
define|#
directive|define
name|soutputc
parameter_list|(
name|c
parameter_list|)
value|if (--n<= 0) break; else sputc(c)
end_define

begin_function
name|void
name|cl_eol
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|>
name|cursend
condition|)
return|return;
if|if
condition|(
name|cursor
operator|<
name|Curline
operator|->
name|s_length
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
if|if
condition|(
name|CE
condition|)
block|{
endif|#
directive|endif
comment|/* (defined(IBMPC) || defined(MAC)) */
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMCAP
name|putpad
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|clr_eoln
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TERMCAP */
name|clrline
argument_list|(
name|cursor
argument_list|,
name|Curline
operator|->
name|s_length
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
block|}
else|else
block|{
comment|/* Ugh.  The slow way for dumb terminals. */
specifier|register
name|char
modifier|*
name|savecp
init|=
name|cursor
decl_stmt|;
while|while
condition|(
name|cursor
operator|<=
name|Curline
operator|->
name|s_length
condition|)
name|sputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|savecp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (defined(IBMPC) || defined(MAC)) */
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cl_scr
parameter_list|(
name|doit
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|sp
init|=
name|Screen
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
name|clrline
argument_list|(
name|sp
operator|->
name|s_line
argument_list|,
name|sp
operator|->
name|s_length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_length
operator|=
name|sp
operator|->
name|s_line
expr_stmt|;
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doit
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMCAP
name|putpad
argument_list|(
name|CL
argument_list|,
name|LI
argument_list|)
expr_stmt|;
else|#
directive|else
name|clr_page
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TERMCAP */
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|UpdMesg
operator|=
name|YES
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ID_CHAR
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|IN_INSmode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output one character (if necessary) at the current position */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|int
comment|/* only for lints sake */
name|dosputc
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
operator|*
name|cursor
operator|!=
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* IBMPC */
if|if
condition|(
operator|(
name|force
operator|)
operator|||
operator|(
operator|*
name|cursor
operator|!=
name|c
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* IBMPC */
if|if
condition|(
name|i_line
operator|!=
name|CapLine
operator|||
name|i_col
operator|!=
name|CapCol
condition|)
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
name|UL
operator|&&
operator|(
name|c
operator|&
name|CHARMASK
operator|)
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|cursor
operator|&
name|CHARMASK
operator|)
operator|!=
literal|' '
condition|)
name|putstr
argument_list|(
literal|" \b"
argument_list|)
expr_stmt|;
comment|/* Erase so '_' looks right. */
endif|#
directive|endif
comment|/* IBMPC */
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|putchar
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|normfun
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|AbortCnt
operator|-=
literal|1
expr_stmt|;
name|CapCol
operator|+=
literal|1
expr_stmt|;
name|i_col
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|+=
literal|1
expr_stmt|;
name|i_col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* MAC */
comment|/* Character output to bit-mapped screen is very expensive. It makes    much more sense to write the entire line at once. So, we print all    the characters, whether already there or not, once the line is    complete.  */
define|#
directive|define
name|BUFFLUSH
value|(char) 0
define|#
directive|define
name|BUFSTART
value|(char) 1
name|bufputc
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|BUFSTART
condition|)
block|{
comment|/*		if (i_line != CapLine || i_col != CapCol)*/
name|NPlacur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
name|BUFFLUSH
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|len
expr_stmt|;
name|writechr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
literal|255
condition|)
return|return;
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|buf
index|[
operator|++
name|len
index|]
operator|=
literal|0xAF
expr_stmt|;
comment|/* slashed zero */
else|else
name|buf
index|[
operator|++
name|len
index|]
operator|=
name|c
expr_stmt|;
name|CapCol
operator|++
expr_stmt|;
name|i_col
operator|++
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* MAC */
comment|/* Write `line' at the current position of `cursor'.  Stop when we    reach the end of the screen.  Aborts if there is a character    waiting.  */
ifdef|#
directive|ifdef
name|MAC
comment|/* This was getting too complicated with ifdefs ... */
name|int
name|swrite
parameter_list|(
name|line
parameter_list|,
name|inversep
parameter_list|,
name|abortable
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|abortable
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
name|i_col
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|sputc
argument_list|(
name|BUFSTART
argument_list|)
expr_stmt|;
comment|/* Okay, because no interruption possible */
while|while
condition|(
name|c
operator|=
operator|*
name|line
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
decl_stmt|;
name|nchars
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
while|while
condition|(
name|nchars
operator|--
condition|)
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|sputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
name|sputc
argument_list|(
name|BUFFLUSH
argument_list|)
expr_stmt|;
return|return
operator|!
name|aborted
return|;
block|}
else|#
directive|else
comment|/* MAC */
name|int
name|swrite
parameter_list|(
name|line
parameter_list|,
name|inversep
parameter_list|,
name|abortable
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|abortable
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
name|i_col
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|int
name|or_byte
init|=
name|inversep
condition|?
literal|0200
else|:
literal|0
decl_stmt|,
name|thebyte
decl_stmt|;
else|#
directive|else
name|int
name|thebyte
decl_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
ifdef|#
directive|ifdef
name|IBMPC
name|force
operator|=
name|inversep
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* to force a redraw of the modeline */
endif|#
directive|endif
comment|/* IBMPC */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|c
operator|=
operator|*
name|line
operator|++
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
comment|/* don't check after every character */
if|if
condition|(
name|abortable
operator|&&
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
name|InputPending
operator|=
name|charp
argument_list|()
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* (defined(IBMPC) || defined(MAC)) */
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
decl_stmt|;
name|nchars
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|thebyte
operator|=
operator|(
literal|' '
operator||
name|or_byte
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
while|while
condition|(
name|nchars
operator|--
condition|)
ifndef|#
directive|ifndef
name|IBMPC
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|IBMPC
name|thebyte
operator|=
operator|(
literal|'^'
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
name|thebyte
operator|=
operator|(
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|IBMPC
name|thebyte
operator|=
operator|(
name|c
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
if|if
condition|(
name|c
operator|==
literal|255
condition|)
name|c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|inversep
condition|)
name|c
operator|=
literal|255
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
ifndef|#
directive|ifndef
name|IBMPC
name|sputc
argument_list|(
name|c
operator||
name|or_byte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|sputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
else|else
ifndef|#
directive|ifndef
name|IBMPC
name|sputc
argument_list|(
literal|'!'
operator||
name|or_byte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|force
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|aborted
return|;
block|}
endif|#
directive|endif
comment|/* MAC */
comment|/* This is for writing a buffer line to the screen.  This is to    minimize the amount of copying from one buffer to another buffer.    This gets the info directly from the disk buffers. */
name|int
name|BufSwrite
parameter_list|(
name|linenum
parameter_list|)
block|{
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|,
name|col
init|=
literal|0
decl_stmt|,
name|c
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|StartCol
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
decl_stmt|,
name|visspace
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_window
operator|->
name|w_flags
operator|&
name|W_VISSPACE
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|lcontents
argument_list|(
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_lp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|col
operator|>=
name|StartCol
condition|)
block|{
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
operator|=
name|col
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
operator|&
name|CHARMASK
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|col
operator|+=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|col
operator|+=
literal|2
expr_stmt|;
else|else
name|col
operator|+=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|sputc
argument_list|(
name|BUFSTART
argument_list|)
expr_stmt|;
comment|/* Okay because we can't be interrupted */
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
while|while
condition|(
name|c
operator|=
operator|*
name|bp
operator|++
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
comment|/* will never get true so why bother */
if|if
condition|(
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
name|InputPending
operator|=
name|charp
argument_list|()
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* (defined(IBMPC) || defined(MAC)) */
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
init|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
decl_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
if|if
condition|(
name|visspace
condition|)
block|{
name|soutputc
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|nchars
operator|-=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|soutputc
argument_list|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|visspace
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|c
operator|==
literal|255
condition|)
name|c
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|bp
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|sputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|sputc
argument_list|(
name|BUFFLUSH
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|aborted
return|;
comment|/* Didn't abort */
block|}
name|void
name|i_set
parameter_list|(
name|nline
parameter_list|,
name|ncol
parameter_list|)
specifier|register
name|int
name|nline
decl_stmt|,
name|ncol
decl_stmt|;
block|{
name|Curline
operator|=
operator|&
name|Screen
index|[
name|nline
index|]
expr_stmt|;
name|cursor
operator|=
name|Curline
operator|->
name|s_line
operator|+
name|ncol
expr_stmt|;
name|cursend
operator|=
operator|&
name|Curline
operator|->
name|s_line
index|[
name|CO
operator|-
literal|1
index|]
expr_stmt|;
name|i_line
operator|=
name|nline
expr_stmt|;
name|i_col
operator|=
name|ncol
expr_stmt|;
block|}
comment|/* Insert `num' lines a top, but leave all the lines BELOW `bottom'    alone (at least they won't look any different when we are done).    This changes the screen array AND does the physical changes. */
name|void
name|v_ins_line
parameter_list|(
name|num
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Save the screen pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
expr_stmt|;
comment|/* Num number of bottom lines will be lost. 	   Copy everything down num number of times. */
for|for
control|(
name|i
operator|=
name|bottom
init|;
name|i
operator|>
name|top
operator|&&
name|i
operator|-
name|num
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|-
name|num
index|]
expr_stmt|;
comment|/* Restore the saved ones, making them blank. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
call|(
modifier|*
name|TTins_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|i_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMPC
name|scr_win
argument_list|(
operator|-
name|num
argument_list|,
name|top
argument_list|,
literal|0
argument_list|,
name|bottom
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Delete `num' lines starting at `top' leaving the lines below `bottom'    alone.  This updates the internal image as well as the physical image.  */
name|void
name|v_del_line
parameter_list|(
name|num
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|bot
decl_stmt|;
name|bot
operator|=
name|bottom
expr_stmt|;
comment|/* Save the lost lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
expr_stmt|;
comment|/* Copy everything up num number of lines. */
for|for
control|(
name|i
operator|=
name|top
init|;
name|num
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|+
name|num
index|]
expr_stmt|;
comment|/* Restore the lost ones, clearing them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
expr_stmt|;
name|bot
operator|-=
literal|1
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
call|(
modifier|*
name|TTdel_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|d_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMPC
name|scr_win
argument_list|(
name|num
argument_list|,
name|top
argument_list|,
literal|0
argument_list|,
name|bottom
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|MAC
comment|/* remainder of this file */
ifdef|#
directive|ifdef
name|IBMPC
comment|/* No cursor optimization on an IBMPC, this simplifies things a lot.    Think about it: it would be silly!  */
name|int
name|phystab
init|=
literal|8
decl_stmt|;
name|void
name|Placur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
block|{
name|cur_mov
argument_list|(
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|col
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
block|}
name|void
name|SO_on
parameter_list|()
block|{
if|if
condition|(
name|Mdcolor
condition|)
name|setcolor
argument_list|(
name|Mdcolor
operator|&
literal|0xf
argument_list|,
name|Mdcolor
operator|>>
literal|4
argument_list|)
expr_stmt|;
else|else
name|setcolor
argument_list|(
name|Bgcolor
argument_list|,
name|Fgcolor
argument_list|)
expr_stmt|;
block|}
name|void
name|SO_off
parameter_list|()
block|{
name|setcolor
argument_list|(
name|Fgcolor
argument_list|,
name|Bgcolor
argument_list|)
expr_stmt|;
block|}
specifier|extern
name|int
name|EGA
decl_stmt|;
name|void
name|UnsetTerm
parameter_list|(
name|foo
parameter_list|)
name|char
modifier|*
name|foo
decl_stmt|;
block|{
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clr_eoln
argument_list|()
expr_stmt|;
if|if
condition|(
name|EGA
condition|)
name|reset_43
argument_list|()
expr_stmt|;
block|}
name|void
name|ResetTerm
parameter_list|()
block|{
if|if
condition|(
name|EGA
condition|)
name|init_43
argument_list|()
expr_stmt|;
else|else
name|init_term
argument_list|()
expr_stmt|;
name|do_sgtty
argument_list|()
expr_stmt|;
comment|/* this is so if you change baudrate or stuff 				   like that, JOVE will notice. */
name|ttyset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* IBMPC */
comment|/* The cursor optimization happens here.  You may decide that this    is going too far with cursor optimization, or perhaps it should    limit the amount of checking to when the output speed is slow.    What ever turns you on ...   */
name|private
struct|struct
name|cursaddr
block|{
name|int
name|cm_numchars
decl_stmt|,
argument_list|(
operator|*
name|cm_proc
argument_list|)
argument_list|()
decl_stmt|;
block|}
struct|;
name|private
name|char
modifier|*
name|Cmstr
decl_stmt|;
name|private
name|struct
name|cursaddr
modifier|*
name|HorMin
decl_stmt|,
modifier|*
name|VertMin
decl_stmt|,
modifier|*
name|DirectMin
decl_stmt|;
name|private
name|void
name|GENi_lines
argument_list|()
decl_stmt|,
name|GENd_lines
argument_list|()
decl_stmt|,
name|ForMotion
argument_list|()
decl_stmt|,
name|ForTab
argument_list|()
decl_stmt|,
name|BackMotion
argument_list|()
decl_stmt|,
name|RetTab
argument_list|()
decl_stmt|,
name|DownMotion
argument_list|()
decl_stmt|,
name|UpMotion
argument_list|()
decl_stmt|,
name|GoDirect
argument_list|()
decl_stmt|,
name|HomeGo
argument_list|()
decl_stmt|,
name|BottomUp
argument_list|()
decl_stmt|;
name|private
name|struct
name|cursaddr
name|WarpHor
index|[]
init|=
block|{
literal|0
block|,
name|ForMotion
block|,
literal|0
block|,
name|ForTab
block|,
literal|0
block|,
name|BackMotion
block|,
literal|0
block|,
name|RetTab
block|}
decl_stmt|;
name|private
name|struct
name|cursaddr
name|WarpVert
index|[]
init|=
block|{
literal|0
block|,
name|DownMotion
block|,
literal|0
block|,
name|UpMotion
block|}
decl_stmt|;
name|private
name|struct
name|cursaddr
name|WarpDirect
index|[]
init|=
block|{
literal|0
block|,
name|GoDirect
block|,
literal|0
block|,
name|HomeGo
block|,
literal|0
block|,
name|BottomUp
block|}
decl_stmt|;
undef|#
directive|undef
name|FORWARD
define|#
directive|define
name|FORWARD
value|0
comment|/* Move forward */
define|#
directive|define
name|FORTAB
value|1
comment|/* Forward using tabs */
undef|#
directive|undef
name|BACKWARD
define|#
directive|define
name|BACKWARD
value|2
comment|/* Move backward */
define|#
directive|define
name|RETFORWARD
value|3
comment|/* Beginning of line and then tabs */
define|#
directive|define
name|NUMHOR
value|4
define|#
directive|define
name|DOWN
value|0
comment|/* Move down */
define|#
directive|define
name|UPMOVE
value|1
comment|/* Move up */
define|#
directive|define
name|NUMVERT
value|2
define|#
directive|define
name|DIRECT
value|0
comment|/* Using CM */
define|#
directive|define
name|HOME
value|1
comment|/* HOME	*/
define|#
directive|define
name|LOWER
value|2
comment|/* Lower Line */
define|#
directive|define
name|NUMDIRECT
value|3
define|#
directive|define
name|home
parameter_list|()
value|Placur(0, 0)
define|#
directive|define
name|LowLine
parameter_list|()
value|putpad(LL, 1), CapLine = ILI, CapCol = 0
define|#
directive|define
name|PrintHo
parameter_list|()
value|putpad(HO, 1), CapLine = CapCol = 0
name|int
name|phystab
init|=
literal|8
decl_stmt|;
name|private
name|void
name|GoDirect
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|putpad
argument_list|(
name|Cmstr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|CapCol
operator|=
name|col
expr_stmt|;
block|}
name|private
name|void
name|RetTab
parameter_list|(
name|col
parameter_list|)
specifier|register
name|int
name|col
decl_stmt|;
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
literal|0
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|HomeGo
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
block|{
name|PrintHo
argument_list|()
expr_stmt|;
name|DownMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|BottomUp
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|LowLine
argument_list|()
expr_stmt|;
name|UpMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
comment|/* Tries to move forward using tabs (if possible).  It tabs to the    closest tabstop which means it may go past 'destcol' and backspace    to it. */
name|private
name|void
name|ForTab
parameter_list|(
name|destcol
parameter_list|)
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|ntabs
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|destcol
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
comment|/* Don't tab to last place or else it is likely to screw up. */
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|ntabs
operator|=
operator|(
name|tabgoal
operator|/
name|tabstp
operator|)
operator|-
operator|(
name|CapCol
operator|/
name|tabstp
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|ntabs
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|tabgoal
expr_stmt|;
block|}
if|if
condition|(
name|CapCol
operator|>
name|destcol
condition|)
name|BackMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CapCol
operator|<
name|destcol
condition|)
name|ForMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|ForMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|destcol
operator|-
name|CapCol
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
name|Screen
index|[
name|CapLine
index|]
operator|.
name|s_line
index|[
name|CapCol
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
operator|*
name|cp
operator|++
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
name|private
name|void
name|BackMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapCol
operator|-
name|destcol
decl_stmt|;
if|if
condition|(
name|BC
condition|)
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
name|private
name|void
name|DownMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
init|=
name|destline
operator|-
name|CapLine
decl_stmt|;
while|while
condition|(
operator|--
name|nlines
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|NL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
name|private
name|void
name|UpMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapLine
operator|-
name|destline
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|UP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ID_CHAR
specifier|static
name|int
name|EIlen
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|IMlen
decl_stmt|;
name|void
name|InitCM
parameter_list|()
block|{
name|HOlen
operator|=
name|HO
condition|?
name|strlen
argument_list|(
name|HO
argument_list|)
else|:
literal|1000
expr_stmt|;
name|LLlen
operator|=
name|LL
condition|?
name|strlen
argument_list|(
name|LL
argument_list|)
else|:
literal|1000
expr_stmt|;
name|UPlen
operator|=
name|UP
condition|?
name|strlen
argument_list|(
name|UP
argument_list|)
else|:
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|EI
condition|)
name|EIlen
operator|=
name|strlen
argument_list|(
name|EI
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|Placur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
block|{
name|int
name|dline
decl_stmt|,
comment|/* Number of lines to move */
name|dcol
decl_stmt|;
comment|/* Number of columns to move */
specifier|register
name|int
name|best
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|cursaddr
modifier|*
name|cp
decl_stmt|;
name|int
name|xtracost
init|=
literal|0
decl_stmt|;
comment|/* Misc addition to cost. */
define|#
directive|define
name|CursMin
parameter_list|(
name|which
parameter_list|,
name|addrs
parameter_list|,
name|max
parameter_list|)
define|\
value|for (best = 0, cp =&addrs[1], i = 1; i< max; i++, cp++) \ 		if (cp->cm_numchars< addrs[best].cm_numchars) \ 			best = i; \ 	which =&addrs[best];
if|if
condition|(
name|line
operator|==
name|CapLine
operator|&&
name|col
operator|==
name|CapCol
condition|)
return|return;
comment|/* We are already there. */
name|dline
operator|=
name|line
operator|-
name|CapLine
expr_stmt|;
name|dcol
operator|=
name|col
operator|-
name|CapCol
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
name|MI
condition|)
name|xtracost
operator|=
name|EIlen
operator|+
name|IMlen
expr_stmt|;
comment|/* If we're already in insert mode, it is likely that we will 	   want to be in insert mode again, after the insert. */
endif|#
directive|endif
comment|/* Number of characters to move horizontally for each case. 	   1: Just move forward by typing the right character on the screen. 	   2: Print the correct number of back spaces. 	   3: Try tabbing to the correct place. 	   4: Try going to the beginning of the line, and then tab. */
if|if
condition|(
name|dcol
operator|==
literal|1
operator|||
name|dcol
operator|==
literal|0
condition|)
block|{
comment|/* Most common case. */
name|HorMin
operator|=
operator|&
name|WarpHor
index|[
name|FORWARD
index|]
expr_stmt|;
name|HorMin
operator|->
name|cm_numchars
operator|=
name|dcol
operator|+
name|xtracost
expr_stmt|;
block|}
else|else
block|{
name|WarpHor
index|[
name|FORWARD
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|>=
literal|0
condition|?
name|dcol
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|BACKWARD
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|<
literal|0
condition|?
operator|-
operator|(
name|dcol
operator|+
name|xtracost
operator|)
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|FORTAB
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|>=
literal|0
operator|&&
name|TABS
condition|?
name|ForNum
argument_list|(
name|CapCol
argument_list|,
name|col
argument_list|)
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
operator|=
operator|(
name|xtracost
operator|+
literal|1
operator|+
operator|(
name|TABS
condition|?
name|ForNum
argument_list|(
literal|0
argument_list|,
name|col
argument_list|)
else|:
name|col
operator|)
operator|)
expr_stmt|;
comment|/* Which is the shortest of the bunch */
name|CursMin
argument_list|(
name|HorMin
argument_list|,
name|WarpHor
argument_list|,
name|NUMHOR
argument_list|)
expr_stmt|;
block|}
comment|/* Moving vertically is more simple. */
name|WarpVert
index|[
name|DOWN
index|]
operator|.
name|cm_numchars
operator|=
name|dline
operator|>=
literal|0
condition|?
name|dline
else|:
literal|1000
expr_stmt|;
name|WarpVert
index|[
name|UPMOVE
index|]
operator|.
name|cm_numchars
operator|=
name|dline
operator|<
literal|0
condition|?
operator|(
operator|(
operator|-
name|dline
operator|)
operator|*
name|UPlen
operator|)
else|:
literal|1000
expr_stmt|;
comment|/* Which of these is simpler */
name|CursMin
argument_list|(
name|VertMin
argument_list|,
name|WarpVert
argument_list|,
name|NUMVERT
argument_list|)
expr_stmt|;
comment|/* Homing first and lowering first are considered  	   direct motions. 	   Homing first's total is the sum of the cost of homing 	   and the sum of tabbing (if possible) to the right. */
if|if
condition|(
name|VertMin
operator|->
name|cm_numchars
operator|+
name|HorMin
operator|->
name|cm_numchars
operator|<=
literal|3
condition|)
block|{
name|DirectMin
operator|=
operator|&
name|WarpDirect
index|[
name|DIRECT
index|]
expr_stmt|;
comment|/* A dummy ... */
name|DirectMin
operator|->
name|cm_numchars
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|WarpDirect
index|[
name|DIRECT
index|]
operator|.
name|cm_numchars
operator|=
name|CM
condition|?
name|strlen
argument_list|(
name|Cmstr
operator|=
name|tgoto
argument_list|(
name|CM
argument_list|,
name|col
argument_list|,
name|line
argument_list|)
argument_list|)
else|:
literal|1000
expr_stmt|;
name|WarpDirect
index|[
name|HOME
index|]
operator|.
name|cm_numchars
operator|=
name|HOlen
operator|+
name|line
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
expr_stmt|;
name|WarpDirect
index|[
name|LOWER
index|]
operator|.
name|cm_numchars
operator|=
name|LLlen
operator|+
operator|(
operator|(
name|ILI
operator|-
name|line
operator|)
operator|*
name|UPlen
operator|)
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
expr_stmt|;
name|CursMin
argument_list|(
name|DirectMin
argument_list|,
name|WarpDirect
argument_list|,
name|NUMDIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HorMin
operator|->
name|cm_numchars
operator|+
name|VertMin
operator|->
name|cm_numchars
operator|<
name|DirectMin
operator|->
name|cm_numchars
condition|)
block|{
if|if
condition|(
name|line
operator|!=
name|CapLine
condition|)
call|(
modifier|*
name|VertMin
operator|->
name|cm_proc
call|)
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|!=
name|CapCol
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
comment|/* We may use real characters ... */
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|HorMin
operator|->
name|cm_proc
call|)
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
operator|!
name|MI
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|DirectMin
operator|->
name|cm_proc
call|)
argument_list|(
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : -(x))
name|int
name|ForNum
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
name|int
name|numchars
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|>=
name|to
condition|)
return|return
name|from
operator|-
name|to
return|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|to
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|numchars
operator|=
operator|(
name|tabgoal
operator|/
name|tabstop
operator|)
operator|-
operator|(
name|from
operator|/
name|tabstp
operator|)
expr_stmt|;
name|from
operator|=
name|tabgoal
expr_stmt|;
block|}
return|return
name|numchars
operator|+
name|abs
argument_list|(
name|from
operator|-
name|to
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|WIRED_TERMS
name|void
name|BGi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[%d;%dr\033[%dL\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|SUNi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|void
name|C100i_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENi_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WIRED_TERMS */
name|private
name|void
name|GENi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SR
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_DL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_AL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|WIRED_TERMS
name|void
name|BGd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[%d;%dr\033[%dM\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|SUNd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|void
name|C100d_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENd_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WIRED_TERMS */
name|private
name|void
name|GENd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|bottom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SF
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_DL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_AL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
struct|struct
name|ID_lookup
block|{
name|char
modifier|*
name|ID_name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|I_proc
function_decl|)
parameter_list|()
function_decl|;
comment|/* proc to insert lines */
name|int
function_decl|(
modifier|*
name|D_proc
function_decl|)
parameter_list|()
function_decl|;
comment|/* proc to delete lines */
block|}
name|ID_trms
index|[]
init|=
block|{
literal|"generic"
block|,
name|GENi_lines
block|,
name|GENd_lines
block|,
comment|/* This should stay here */
ifdef|#
directive|ifdef
name|WIRED_TERMS
literal|"sun"
block|,
name|SUNi_lines
block|,
name|SUNd_lines
block|,
literal|"bg"
block|,
name|BGi_lines
block|,
name|BGd_lines
block|,
literal|"c1"
block|,
name|C100i_lines
block|,
name|C100d_lines
block|,
endif|#
directive|endif
comment|/* WIRED_TERMS */
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
name|void
name|IDline_setup
parameter_list|(
name|tname
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
block|{
specifier|register
name|struct
name|ID_lookup
modifier|*
name|idp
decl_stmt|;
for|for
control|(
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|1
index|]
init|;
name|idp
operator|->
name|ID_name
condition|;
name|idp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|,
name|tname
argument_list|,
name|strlen
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|idp
operator|->
name|ID_name
operator|==
literal|0
condition|)
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|0
index|]
expr_stmt|;
name|TTins_line
operator|=
name|idp
operator|->
name|I_proc
expr_stmt|;
name|TTdel_line
operator|=
name|idp
operator|->
name|D_proc
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

end_unit

