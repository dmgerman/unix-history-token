begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * expire - expire daemon runs around and nails all articles that  *		 have expired.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)expire.c	2.55	10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOCKF */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Progname
init|=
literal|"expire"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by xerror to identify failing program */
end_comment

begin_comment
comment|/*	Number of array entries to allocate at a time.	*/
end_comment

begin_define
define|#
directive|define
name|SPACE_INCREMENT
value|1000
end_define

begin_struct
struct|struct
name|expdata
block|{
name|char
modifier|*
name|e_name
decl_stmt|;
name|long
name|e_min
decl_stmt|,
name|e_max
decl_stmt|;
name|time_t
name|e_droptime
decl_stmt|,
name|e_expiretime
decl_stmt|;
name|char
name|e_ignorexp
decl_stmt|;
name|char
name|e_doarchive
decl_stmt|;
name|char
name|e_doexpire
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|NARTFILE
index|[
name|BUFLEN
index|]
decl_stmt|,
name|OARTFILE
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PAGFILE
index|[
name|BUFLEN
index|]
decl_stmt|,
name|DIRFILE
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|NACTIVE
index|[
name|BUFLEN
index|]
decl_stmt|,
name|OACTIVE
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|recdate
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|rectime
decl_stmt|,
name|exptime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|OLDNEWS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output trace information */
end_comment

begin_decl_stmt
name|int
name|ignorexp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore Expire: lines */
end_comment

begin_decl_stmt
name|int
name|doarchive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* archive articles in SPOOL/oldnews */
end_comment

begin_decl_stmt
name|int
name|nohistory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore history file */
end_comment

begin_decl_stmt
name|int
name|dorebuild
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rebuild history file */
end_comment

begin_decl_stmt
name|int
name|dorbldhistory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rebuild history.d directory */
end_comment

begin_decl_stmt
name|int
name|usepost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use posting date to expire */
end_comment

begin_decl_stmt
name|int
name|frflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* expire specific user */
end_comment

begin_decl_stmt
name|int
name|doupdateactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* update ACTIVE file */
end_comment

begin_decl_stmt
name|char
name|baduser
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|filename
index|[]
decl_stmt|,
name|nbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeb
name|Now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This code uses realloc to get more of the multhist array.  */
end_comment

begin_struct
struct|struct
name|multhist
block|{
name|char
modifier|*
name|mh_ident
decl_stmt|;
name|char
modifier|*
name|mh_file
decl_stmt|;
block|}
modifier|*
name|multhist
struct|;
end_struct

begin_decl_stmt
name|unsigned
name|int
name|mh_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|DBM
end_ifndef

begin_function_decl
name|FILE
modifier|*
name|nexthistfile
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DBM */
end_comment

begin_decl_stmt
name|long
name|expincr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dropincr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|atol
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|time_t
name|cgtdate
argument_list|()
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|group
modifier|*
name|gp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|arpat
index|[
name|LBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arpatlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ngpat
index|[
name|LBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ngpatlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|afline
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|grpsleft
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hbuf
name|h
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|rmlock
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|time_t
name|today
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|pathinit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|N_UMASK
argument_list|)
expr_stmt|;
name|username
operator|=
name|NEWSUSR
expr_stmt|;
comment|/* 	 * Try to run as NEWSUSR/NEWSGRP 	 */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|NEWSUSR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot get NEWSUSR pw entry"
argument_list|)
expr_stmt|;
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
operator|(
name|gp
operator|=
name|getgrnam
argument_list|(
name|NEWSGRP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot get NEWSGRP gr entry"
argument_list|)
expr_stmt|;
name|gid
operator|=
name|gp
operator|->
name|gr_gid
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|rmlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|rmlock
argument_list|)
expr_stmt|;
name|expincr
operator|=
name|DFLTEXP
expr_stmt|;
name|dropincr
operator|=
name|HISTEXP
expr_stmt|;
name|ngpat
index|[
literal|0
index|]
operator|=
literal|','
expr_stmt|;
name|arpat
index|[
literal|0
index|]
operator|=
literal|','
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'v'
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
name|verbose
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|verbose
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
operator|<
literal|3
condition|)
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Use this as default expiration time */
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|expincr
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|*
name|DAYS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
name|expincr
operator|=
name|atol
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|*
name|DAYS
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Use this as default forget time */
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|dropincr
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|*
name|DAYS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
name|dropincr
operator|=
name|atol
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|*
name|DAYS
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Ignore any existing expiration date */
name|ignorexp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Ignore any existing expiration date */
name|ignorexp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|int
name|argvlen
decl_stmt|;
name|argvlen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngpatlen
operator|+
name|argvlen
operator|+
literal|2
operator|>
sizeof|sizeof
argument_list|(
name|ngpat
argument_list|)
condition|)
block|{
name|xerror
argument_list|(
literal|"Too many groups specified for -n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ngpat
index|[
name|ngpatlen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ngpat
index|[
name|ngpatlen
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|ngpat
index|[
name|ngpatlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|&
name|ngpat
index|[
name|ngpatlen
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ngpatlen
operator|+=
name|argvlen
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
name|argv
operator|--
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
comment|/* archive expired articles */
if|if
condition|(
name|access
argument_list|(
name|OLDNEWS
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|OLDNEWS
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"No archiving possible\n"
argument_list|)
expr_stmt|;
block|}
name|doarchive
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|int
name|argvlen
decl_stmt|;
name|argvlen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arpatlen
operator|+
name|argvlen
operator|+
literal|2
operator|>
sizeof|sizeof
argument_list|(
name|arpat
argument_list|)
condition|)
block|{
name|xerror
argument_list|(
literal|"Too many groups specified for -a\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arpat
index|[
name|arpatlen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|arpat
index|[
name|arpatlen
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|arpat
index|[
name|arpatlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|&
name|arpat
index|[
name|arpatlen
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arpatlen
operator|+=
name|argvlen
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
name|argv
operator|--
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* ignore history */
name|nohistory
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* rebuild history file */
name|dorebuild
operator|++
expr_stmt|;
name|nohistory
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* just rebuild the dbm files */
ifdef|#
directive|ifdef
name|DBM
name|rebuilddbm
argument_list|()
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DBM */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You have not compiled expire with DBM, so -R is meaningless\n"
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DBM */
case|case
literal|'p'
case|:
comment|/* use posting date to expire */
name|usepost
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* expire messages from baduser */
name|frflag
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|strcpy
argument_list|(
name|baduser
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
comment|/* update the active file from 2.10.1 fmt */
name|doupdateactive
operator|++
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* convert to history.d format */
name|dorbldhistory
operator|++
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Usage: expire [ -v [level] ] [-e days ] [-i] [-a] [-r] [-h] [-p] [-u] [-f username] [-n newsgroups] [-H]\n"
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dorbldhistory
condition|)
block|{
ifndef|#
directive|ifndef
name|DBM
name|rebuildhistorydir
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !DBM */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dropincr
operator|<
name|expincr
condition|)
block|{
name|dropincr
operator|=
name|HISTEXP
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"History expiration time< article expiration time. Default used.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ngpat
index|[
literal|0
index|]
operator|==
literal|','
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ngpat
argument_list|,
literal|"all,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arpat
index|[
literal|0
index|]
operator|==
literal|','
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|arpat
argument_list|,
literal|"all,"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftime
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
name|today
operator|=
name|Now
operator|.
name|time
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|SPOOL
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"Cannot chdir %s"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"expire: nohistory %d, rebuild %d, doarchive %d\n"
argument_list|,
name|nohistory
argument_list|,
name|dorebuild
argument_list|,
name|doarchive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"newsgroups: %s\n"
argument_list|,
name|ngpat
argument_list|)
expr_stmt|;
if|if
condition|(
name|doarchive
condition|)
name|printf
argument_list|(
literal|"archiving: %s\n"
argument_list|,
name|arpat
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DBM
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|OARTFILE
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"ohistory"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBM */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|NARTFILE
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"nhistory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|OACTIVE
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"oactive"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|NACTIVE
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"nactive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doupdateactive
condition|)
block|{
name|expire
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|DBM
name|rebuildhistorydir
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|updateactive
argument_list|()
expr_stmt|;
name|rmlock
argument_list|()
expr_stmt|;
comment|/* 	 * Now read in any saved news. 	 */
ifdef|#
directive|ifdef
name|PROFILING
name|monitor
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROFILING */
ifdef|#
directive|ifdef
name|LOGDIR
comment|/*afline happens to be available - (we're getting out anyway)*/
name|sprintf
argument_list|(
name|afline
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|RNEWS
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|afline
argument_list|,
literal|"rnews"
argument_list|,
literal|"-U"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! LOGDIR */
name|execl
argument_list|(
name|RNEWS
argument_list|,
literal|"rnews"
argument_list|,
literal|"-U"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! LOGDIR */
name|perror
argument_list|(
name|RNEWS
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|expire
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
specifier|register
name|time_t
name|newtime
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|ohfd
decl_stmt|,
modifier|*
name|nhfd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|fn
index|[
name|BUFLEN
index|]
decl_stmt|;
name|DIR
modifier|*
name|ngdirp
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|direct
modifier|*
name|ngdir
decl_stmt|;
ifdef|#
directive|ifdef
name|DBM
if|if
condition|(
operator|!
name|dorebuild
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PAGFILE
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"nhistory.pag"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|DIRFILE
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"nhistory.dir"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|PAGFILE
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|DIRFILE
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
name|initdbm
argument_list|(
name|NARTFILE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nohistory
condition|)
block|{
name|ohfd
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dorebuild
condition|)
block|{
comment|/* Allocate initial space for multiple newsgroup (for 			   an article) array */
name|multhist
operator|=
operator|(
expr|struct
name|multhist
operator|*
operator|)
name|calloc
argument_list|(
name|SPACE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|multhist
argument_list|)
argument_list|)
expr_stmt|;
name|mh_size
operator|=
name|SPACE_INCREMENT
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|afline
argument_list|,
literal|"exec sort -t\t +1.6 -2 +1>%s"
argument_list|,
ifdef|#
directive|ifdef
name|DBM
name|NARTFILE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DBM */
name|ARTFILE
block|)
empty_stmt|;
endif|#
directive|endif
comment|/* !DBM */
if|if
condition|(
operator|(
name|nhfd
operator|=
name|popen
argument_list|(
name|afline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot exec %s"
argument_list|,
name|afline
argument_list|)
expr_stmt|;
block|}
else|else
name|nhfd
operator|=
name|xfopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|else
block|{
ifdef|#
directive|ifdef
name|DBM
name|ohfd
operator|=
name|xfopen
argument_list|(
name|ARTFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ohfd
operator|=
name|nexthistfile
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBM */
name|nhfd
operator|=
name|xfopen
argument_list|(
name|NARTFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|dolock
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
condition|;
name|i
operator|++
control|)
name|h
operator|.
name|unrec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
end_for

begin_while
while|while
condition|(
name|TRUE
condition|)
block|{
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nohistory
condition|)
block|{
name|recdate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ngdir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ngdirp
operator|!=
name|NULL
condition|)
name|closedir
argument_list|(
name|ngdirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|ohfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|afline
argument_list|)
expr_stmt|;
name|p1
operator|=
name|index
argument_list|(
name|nbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|p1
operator|=
name|index
argument_list|(
name|nbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|nbuf
argument_list|,
name|ngpat
argument_list|)
condition|)
continue|continue;
comment|/* Change a group name from 					   a.b.c to a/b/c */
for|for
control|(
name|p1
operator|=
name|nbuf
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
operator|*
name|p1
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|(
name|ngdirp
operator|=
name|opendir
argument_list|(
name|nbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
block|}
name|ngdir
operator|=
name|readdir
argument_list|(
name|ngdirp
argument_list|)
expr_stmt|;
comment|/*	Continue looking if not an article.	*/
block|}
do|while
condition|(
name|ngdir
operator|==
name|NULL
operator|||
operator|!
name|islegal
argument_list|(
name|fn
argument_list|,
name|nbuf
argument_list|,
name|ngdir
operator|->
name|d_name
argument_list|)
condition|)
do|;
name|p2
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"article: %s\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|access
argument_list|(
name|filename
argument_list|,
literal|04
argument_list|)
condition|?
name|NULL
else|:
name|art_open
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|dc
decl_stmt|;
ifdef|#
directive|ifdef
name|DBM
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|ohfd
argument_list|)
operator|==
name|NULL
condition|)
break|break;
else|#
directive|else
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|ohfd
argument_list|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|!
operator|(
name|ohfd
operator|=
name|nexthistfile
argument_list|(
name|ohfd
argument_list|)
operator|)
condition|)
break|break;
else|else
continue|continue;
endif|#
directive|endif
comment|/* DBM */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"article: %s"
argument_list|,
name|afline
argument_list|)
expr_stmt|;
name|p1
operator|=
name|index
argument_list|(
name|afline
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p1
condition|)
continue|continue;
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|h
operator|.
name|ident
argument_list|,
name|afline
argument_list|)
expr_stmt|;
operator|*
name|p1
operator|=
literal|'\t'
expr_stmt|;
name|p2
operator|=
name|index
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p2
condition|)
continue|continue;
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|recdate
argument_list|,
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|recdate
argument_list|,
literal|" GMT"
argument_list|)
expr_stmt|;
name|rectime
operator|=
name|cgtdate
argument_list|(
name|recdate
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'\t'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|p3
operator|=
name|index
argument_list|(
name|nbuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p3
condition|)
block|{
specifier|register
name|char
modifier|*
name|p4
decl_stmt|;
name|p4
operator|=
name|index
argument_list|(
name|p3
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p4
condition|)
block|{
while|while
condition|(
name|p4
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|p4
operator|--
expr_stmt|;
operator|*
name|p4
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 				 * convert list of newsgroups from 				 *	ng1/num ng2/num ... 				 * to 				 *	ng1,ng2,... 				 */
name|p4
operator|=
name|p3
expr_stmt|;
do|do
block|{
operator|*
name|p3
operator|++
operator|=
name|NGDELIM
expr_stmt|;
while|while
condition|(
operator|*
name|p4
operator|!=
literal|'\0'
operator|&&
operator|*
name|p4
operator|!=
literal|' '
condition|)
name|p4
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p4
operator|++
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|p3
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|p3
operator|=
operator|*
name|p4
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p3
operator|==
literal|'/'
condition|)
break|break;
else|else
name|p3
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|p3
condition|)
do|;
block|}
else|else
block|{
comment|/* 				 * Nothing after the 2nd tab.  This happens 				 * when there is no message left in the spool 				 * directory, only the memory of it in the 				 * history file. (That is, it got cancelled 				 * or expired.) Use date in the history file 				 * to decide if we should keep the memory. 				 */
name|grpsleft
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|checkdate
goto|;
block|}
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|nbuf
argument_list|,
name|ngpat
argument_list|)
operator|||
operator|(
operator|(
name|rectime
operator|+
name|expincr
operator|>
name|today
operator|)
operator|&&
operator|!
name|dorebuild
operator|&&
operator|!
name|frflag
operator|&&
operator|!
name|usepost
operator|&&
name|recdate
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
goto|goto
name|keephist
goto|;
if|if
condition|(
operator|!
name|dorebuild
operator|&&
operator|!
name|frflag
operator|&&
operator|!
name|usepost
operator|&&
name|recdate
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
block|{
name|grpsleft
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|nailit
goto|;
comment|/* just expire it */
block|}
comment|/* 			 * Look for the file--possibly several times, 			 * if it was posted to several news groups. 			 */
name|dc
operator|=
literal|' '
expr_stmt|;
name|p3
operator|=
name|p2
expr_stmt|;
while|while
condition|(
name|dc
operator|!=
literal|'\n'
condition|)
block|{
name|p1
operator|=
name|index
argument_list|(
name|p3
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
block|{
name|dc
operator|=
literal|' '
expr_stmt|;
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
name|index
argument_list|(
name|p3
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|p1
operator|>
name|p3
condition|)
block|{
name|dc
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|(
name|p3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|fp
operator|=
name|art_open
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
break|break;
name|p3
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p1
condition|)
operator|*
name|p1
operator|=
name|dc
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * this probably means that the article has been 			 * cancelled.  Lets assume that, and make an 			 * entry in the history file to that effect. 			 */
if|if
condition|(
name|verbose
condition|)
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"cancelled\n"
argument_list|)
expr_stmt|;
name|grpsleft
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|checkdate
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h
operator|.
name|unrec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|h
operator|.
name|unrec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|h
operator|.
name|unrec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
if|if
condition|(
operator|!
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Garbled article %s.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 			 * Usually means disk ran out of space. 			 * Drop this article from our history file 			 * completely, so we have a chance of picking 			 * it up again from another feed .. 			 */
goto|goto
name|nailit
goto|;
block|}
if|if
condition|(
name|nohistory
condition|)
block|{
if|if
condition|(
name|recdate
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|rectime
operator|=
name|cgtdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
expr_stmt|;
else|else
name|rectime
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
name|rectime
operator|=
name|cgtdate
argument_list|(
name|recdate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dorebuild
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|lastslash
decl_stmt|;
specifier|register
name|struct
name|multhist
modifier|*
name|mhp
decl_stmt|;
comment|/* 			 * Format of filename until now was /SPOOL/a/b/c/4 			 * and this code changes it to a.b.c/4 (the correct 			 * kind of entry in the history file.) 			 * 			 * This cannot be a strcpy because the addresses 			 * overlap and some machines cannot handle that. 			 */
name|p1
operator|=
name|filename
expr_stmt|;
name|cp
operator|=
name|p1
operator|+
name|strlen
argument_list|(
name|SPOOL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|lastslash
operator|=
name|p1
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
operator|*
name|p1
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|lastslash
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|h
operator|.
name|nbuf
argument_list|,
name|NGDELIM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|saveit
label|:
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|rectime
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|nhfd
argument_list|,
ifdef|#
directive|ifdef
name|USG
literal|"%s\t%s%2.2d/%2.2d/%d %2.2d:%2.2d\t%s\n"
argument_list|,
else|#
directive|else
comment|/* !USG */
literal|"%s\t%s%02d/%02d/%d %02d:%02d\t%s\n"
argument_list|,
endif|#
directive|endif
comment|/* !USG */
name|h
operator|.
name|ident
argument_list|,
name|h
operator|.
name|expdate
index|[
literal|0
index|]
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|filename
argument_list|)
operator|==
name|EOF
condition|)
name|xerror
argument_list|(
literal|"History write failed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|mhp
operator|=
name|multhist
init|;
name|mhp
operator|<
name|multhist
operator|+
name|mh_size
operator|&&
name|mhp
operator|->
name|mh_ident
operator|!=
name|NULL
condition|;
name|mhp
operator|++
control|)
block|{
if|if
condition|(
name|mhp
operator|->
name|mh_file
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|mhp
operator|->
name|mh_ident
argument_list|,
name|h
operator|.
name|ident
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|filename
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|filename
argument_list|,
name|mhp
operator|->
name|mh_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mhp
operator|->
name|mh_file
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|mh_file
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * if we have all the links, write to hist now 				 */
if|if
condition|(
name|chrcnt
argument_list|(
name|filename
argument_list|,
literal|' '
argument_list|)
operator|==
name|chrcnt
argument_list|(
name|cp
argument_list|,
name|NGDELIM
argument_list|)
condition|)
goto|goto
name|saveit
goto|;
break|break;
block|}
comment|/* 			 * Here is where we realloc the multhist space rather 			 * than the old way of static allocation.  It is 			 * really trivial.  We just clear out the space 			 * in case it was reused.  The old static array was 			 * guaranteed to be cleared since it was cleared when 			 * the process started. 			 */
if|if
condition|(
name|mhp
operator|>=
name|multhist
operator|+
name|mh_size
condition|)
block|{
name|multhist
operator|=
operator|(
expr|struct
name|multhist
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multhist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|multhist
argument_list|)
operator|*
operator|(
name|SPACE_INCREMENT
operator|+
name|mh_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|multhist
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Too many articles with multiple newsgroups"
argument_list|)
expr_stmt|;
for|for
control|(
name|mhp
operator|=
name|multhist
operator|+
name|mh_size
init|;
name|mhp
operator|<
name|multhist
operator|+
name|mh_size
operator|+
name|SPACE_INCREMENT
condition|;
name|mhp
operator|++
control|)
block|{
name|mhp
operator|->
name|mh_ident
operator|=
name|NULL
expr_stmt|;
name|mhp
operator|->
name|mh_file
operator|=
name|NULL
expr_stmt|;
block|}
name|mhp
operator|=
name|multhist
operator|+
name|mh_size
expr_stmt|;
name|mh_size
operator|+=
name|SPACE_INCREMENT
expr_stmt|;
block|}
if|if
condition|(
name|mhp
operator|->
name|mh_ident
operator|==
name|NULL
condition|)
block|{
name|mhp
operator|->
name|mh_ident
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|h
operator|.
name|ident
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mhp
operator|->
name|mh_ident
argument_list|,
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|mh_file
operator|=
name|cp
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|expdate
index|[
literal|0
index|]
condition|)
block|{
name|Now
operator|.
name|time
operator|=
name|rectime
expr_stmt|;
name|exptime
operator|=
name|cgtdate
argument_list|(
name|h
operator|.
name|expdate
argument_list|)
expr_stmt|;
block|}
name|newtime
operator|=
operator|(
name|usepost
condition|?
name|cgtdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
else|:
name|rectime
operator|)
operator|+
name|expincr
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|.
name|expdate
index|[
literal|0
index|]
operator|||
name|ignorexp
operator|==
literal|2
operator|||
operator|(
name|ignorexp
operator|==
literal|1
operator|&&
name|newtime
operator|<
name|exptime
operator|)
condition|)
name|exptime
operator|=
name|newtime
expr_stmt|;
if|if
condition|(
name|frflag
condition|?
name|strcmp
argument_list|(
name|baduser
argument_list|,
name|h
operator|.
name|from
argument_list|)
operator|==
literal|0
else|:
name|today
operator|>=
name|exptime
condition|)
block|{
name|nailit
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cancel %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DEBUG */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"cancel %s\n"
argument_list|,
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|ulall
argument_list|(
name|p2
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%s\n"
argument_list|,
name|grpsleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
operator|&&
name|grpsleft
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"Some good in %s\n"
argument_list|,
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DEBUG */
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Good article %s\n"
argument_list|,
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|grpsleft
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
block|}
name|checkdate
label|:
if|if
condition|(
name|grpsleft
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|today
operator|>=
name|rectime
operator|+
name|dropincr
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"Drop history of %s - %s\n"
argument_list|,
name|h
operator|.
name|ident
argument_list|,
name|recdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DBM
name|long
name|hpos
decl_stmt|;
endif|#
directive|endif
comment|/* DBM */
name|keephist
label|:
ifdef|#
directive|ifdef
name|DBM
name|hpos
operator|=
name|ftell
argument_list|(
name|nhfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBM */
if|if
condition|(
name|verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"Retain history of %s - %s\n"
argument_list|,
name|h
operator|.
name|ident
argument_list|,
name|recdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|afline
argument_list|,
name|nhfd
argument_list|)
operator|==
name|EOF
condition|)
name|xerror
argument_list|(
literal|"history write failed"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
if|if
condition|(
operator|!
name|dorebuild
condition|)
name|remember
argument_list|(
name|h
operator|.
name|ident
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBM */
block|}
block|}
end_while

begin_label
name|out
label|:
end_label

begin_if
if|if
condition|(
name|dorebuild
condition|)
block|{
specifier|register
name|struct
name|multhist
modifier|*
name|mhp
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
for|for
control|(
name|mhp
operator|=
name|multhist
init|;
name|mhp
operator|<
name|multhist
operator|+
name|mh_size
operator|&&
name|mhp
operator|->
name|mh_ident
operator|!=
name|NULL
condition|;
name|mhp
operator|++
control|)
if|if
condition|(
name|mhp
operator|->
name|mh_file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Article: %s [%s] Cannot find all links\n"
argument_list|,
name|mhp
operator|->
name|mh_ident
argument_list|,
name|mhp
operator|->
name|mh_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%s"
argument_list|,
name|SPOOL
argument_list|,
name|mhp
operator|->
name|mh_file
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|filename
init|;
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\0'
condition|;
name|p1
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
operator|*
name|p1
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|art_open
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Can't open %s.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Garbled article %s.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|rectime
operator|=
name|cgtdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
expr_stmt|;
else|else
name|rectime
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
block|}
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|rectime
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|nhfd
argument_list|,
ifdef|#
directive|ifdef
name|USG
literal|"%s\t%s%2.2d/%2.2d/%d %2.2d:%2.2d\t%s\n"
argument_list|,
else|#
directive|else
comment|/* !USG */
literal|"%s\t%s%02d/%02d/%d %02d:%02d\t%s\n"
argument_list|,
endif|#
directive|endif
comment|/* !USG */
name|h
operator|.
name|ident
argument_list|,
name|h
operator|.
name|expdate
index|[
literal|0
index|]
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|mhp
operator|->
name|mh_file
argument_list|)
operator|==
name|EOF
condition|)
name|xerror
argument_list|(
literal|"History write failed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|nhfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|multhist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|nhfd
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"History write failed, %s"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|dorebuild
operator|||
operator|!
name|nohistory
condition|)
block|{
ifdef|#
directive|ifdef
name|DBM
operator|(
name|void
operator|)
name|rename
argument_list|(
name|ARTFILE
argument_list|,
name|OARTFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|NARTFILE
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dorebuild
condition|)
name|rebuilddbm
argument_list|( )
expr_stmt|;
else|else
block|{
name|char
name|tempname
index|[
name|BUFLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tempname
argument_list|,
literal|"%s.pag"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|NARTFILE
argument_list|,
literal|".pag"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|NARTFILE
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tempname
argument_list|,
literal|"%s.dir"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rindex
argument_list|(
name|NARTFILE
argument_list|,
literal|'.'
argument_list|)
argument_list|,
literal|".dir"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|NARTFILE
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_if

begin_if
unit|}
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCKF
argument_list|)
end_if

begin_decl_stmt
unit|static
name|int
name|LockFd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|dolock
argument_list|()
end_macro

begin_block
block|{
comment|/* set up exclusive locking so inews does not run while expire does */
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCKF
argument_list|)
name|LockFd
operator|=
name|open
argument_list|(
name|ACTIVE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF
if|if
condition|(
name|lockf
argument_list|(
name|LockFd
argument_list|,
name|F_LOCK
argument_list|,
literal|0L
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
comment|/* BSD4_2 */
if|if
condition|(
name|flock
argument_list|(
name|LockFd
argument_list|,
name|LOCK_EX
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* BSD4_2 */
name|xerror
argument_list|(
literal|"Can't get lock for expire: %s"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !BSD4_2&& !LOCKF */
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|afline
argument_list|,
literal|"%s.lock"
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
while|while
condition|(
name|LINK
argument_list|(
name|ACTIVE
argument_list|,
name|afline
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|5
condition|)
block|{
name|xerror
argument_list|(
literal|"Can't get lock for expire"
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !BSD4_2&& !LOCKF */
block|}
end_block

begin_macro
name|rmlock
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|LOCKF
argument_list|)
name|close
argument_list|(
name|LockFd
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s.lock"
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !BSD4_2 */
block|}
end_block

begin_macro
name|updateactive
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
name|FILE
modifier|*
name|ohfd
decl_stmt|,
modifier|*
name|nhfd
decl_stmt|;
name|DIR
modifier|*
name|ngdirp
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|direct
modifier|*
name|ngdir
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"updating active file %s\n"
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
name|ohfd
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|nhfd
operator|=
name|xfopen
argument_list|(
name|NACTIVE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
do|do
block|{
name|long
name|n
decl_stmt|;
name|long
name|maxart
decl_stmt|,
name|minart
decl_stmt|;
name|char
name|cansub
decl_stmt|;
name|int
name|gdsize
decl_stmt|,
name|hassubs
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|ohfd
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld %ld %c"
argument_list|,
name|nbuf
argument_list|,
operator|&
name|maxart
argument_list|,
operator|&
name|minart
argument_list|,
operator|&
name|cansub
argument_list|)
operator|<
literal|4
condition|)
name|xerror
argument_list|(
literal|"Active file corrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"looking at group %s\n"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|nbuf
argument_list|,
name|ngpat
argument_list|)
condition|)
block|{
if|if
condition|(
name|fputs
argument_list|(
name|afline
argument_list|,
name|nhfd
argument_list|)
operator|==
name|EOF
condition|)
name|xerror
argument_list|(
literal|"active file write failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|minart
operator|=
literal|99999L
expr_stmt|;
comment|/* Change a group name from a.b.c to a/b/c */
for|for
control|(
name|p1
operator|=
name|nbuf
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
operator|*
name|p1
operator|=
literal|'/'
expr_stmt|;
name|hassubs
operator|=
name|stat
argument_list|(
name|nbuf
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|!=
literal|0
operator|||
name|stbuf
operator|.
name|st_nlink
operator|!=
literal|2
expr_stmt|;
name|gdsize
operator|=
name|strlen
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ngdirp
operator|=
name|opendir
argument_list|(
name|nbuf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|ngdir
operator|=
name|readdir
argument_list|(
name|ngdirp
argument_list|)
condition|)
block|{
name|nbuf
index|[
name|gdsize
index|]
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|nbuf
index|[
name|gdsize
operator|+
literal|1
index|]
argument_list|,
name|ngdir
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* We have to do a stat because of micro.6809 */
if|if
condition|(
name|hassubs
operator|&&
operator|(
name|stat
argument_list|(
name|nbuf
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
operator|||
operator|!
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
operator|)
condition|)
continue|continue;
name|n
operator|=
name|atol
argument_list|(
name|ngdir
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
name|minart
condition|)
name|minart
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|>
name|maxart
condition|)
name|maxart
operator|=
name|n
expr_stmt|;
block|}
name|closedir
argument_list|(
name|ngdirp
argument_list|)
expr_stmt|;
block|}
name|afline
index|[
name|gdsize
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|minart
operator|>
name|maxart
condition|)
name|minart
operator|=
name|maxart
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
if|if
condition|(
name|verbose
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"\tmaxart = %5.5ld, minart = %5.5ld\n"
argument_list|,
name|maxart
argument_list|,
name|minart
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|nhfd
argument_list|,
literal|"%s %5.5ld %5.5ld %c\n"
argument_list|,
name|afline
argument_list|,
name|maxart
argument_list|,
name|minart
argument_list|,
name|cansub
argument_list|)
operator|==
name|EOF
condition|)
name|xerror
argument_list|(
literal|"Active file write failed"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|verbose
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"\tmaxart = %05ld, minart = %05ld\n"
argument_list|,
name|maxart
argument_list|,
name|minart
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|nhfd
argument_list|,
literal|"%s %05ld %05ld %c\n"
argument_list|,
name|afline
argument_list|,
name|maxart
argument_list|,
name|minart
argument_list|,
name|cansub
argument_list|)
operator|==
name|EOF
condition|)
name|xerror
argument_list|(
literal|"Active file write failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !USG */
block|}
do|while
condition|(
operator|!
name|feof
argument_list|(
name|ohfd
argument_list|)
condition|)
do|;
if|if
condition|(
name|fclose
argument_list|(
name|nhfd
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"Active file write failed, %s"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ohfd
argument_list|)
expr_stmt|;
comment|/* this might unlock inews as a side effect */
operator|(
name|void
operator|)
name|rename
argument_list|(
name|ACTIVE
argument_list|,
name|OACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|NACTIVE
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Unlink (using unwound tail recursion) all the articles in 'artlist'. */
end_comment

begin_macro
name|ulall
argument_list|(
argument|artlist
argument_list|,
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|artlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|last
init|=
literal|0
decl_stmt|;
name|char
name|newname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|time_t
name|timep
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|grpsleft
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"ulall '%s', '%s'\n"
argument_list|,
name|artlist
argument_list|,
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|nohistory
condition|)
block|{
name|last
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|artlist
operator|==
literal|' '
operator|||
operator|*
name|artlist
operator|==
literal|'\n'
operator|||
operator|*
name|artlist
operator|==
literal|','
condition|)
name|artlist
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|artlist
operator|==
literal|'\0'
condition|)
return|return;
name|p
operator|=
name|index
argument_list|(
name|artlist
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|last
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|artlist
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|newname
argument_list|,
name|artlist
argument_list|)
expr_stmt|;
name|q
operator|=
name|index
argument_list|(
name|newname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|NGDELIM
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|index
argument_list|(
name|newname
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|artlist
condition|)
comment|/* null -> the end */
return|return;
comment|/* should be impossible to get here */
block|}
name|fn
operator|=
name|dirname
argument_list|(
name|artlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngmatch
argument_list|(
name|newname
argument_list|,
name|ngpat
argument_list|)
condition|)
block|{
if|if
condition|(
name|doarchive
condition|)
block|{
if|if
condition|(
name|ngmatch
argument_list|(
name|newname
argument_list|,
name|arpat
argument_list|)
condition|)
block|{
name|q
operator|=
name|fn
operator|+
name|strlen
argument_list|(
name|SPOOL
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s/%s"
argument_list|,
name|OLDNEWS
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"link %s to %s\n"
argument_list|,
name|fn
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINK
argument_list|(
name|fn
argument_list|,
name|newname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkparents
argument_list|(
name|newname
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|LINK
argument_list|(
name|fn
argument_list|,
name|newname
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fcopy
argument_list|(
name|fn
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
name|timep
index|[
literal|0
index|]
operator|=
name|timep
index|[
literal|1
index|]
operator|=
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|newname
argument_list|,
name|timep
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"unlink %s\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLINK
argument_list|(
name|fn
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"retain %s (%s)\n"
argument_list|,
name|hp
operator|->
name|ident
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|grpsleft
argument_list|,
name|artlist
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|grpsleft
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|artlist
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|last
condition|)
do|;
block|}
end_block

begin_macro
name|fcopy
argument_list|(
argument|fn
argument_list|,
argument|newname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|newname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|f1
operator|=
name|open
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|f2
operator|=
name|open
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f2
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|f2
operator|=
name|creat
argument_list|(
name|newname
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|f2
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|f1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|close
argument_list|(
name|f1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
while|while
condition|(
operator|(
name|r
operator|=
name|read
argument_list|(
name|f1
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|f2
argument_list|,
name|buf
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Count instances of c in s  */
end_comment

begin_expr_stmt
name|chrcnt
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
operator|=
literal|0
expr_stmt|;
specifier|register
name|cc
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|cc
operator|==
name|c
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_comment
comment|/*  * If any parent directories of this dir don't exist, create them.  */
end_comment

begin_macro
name|mkparents
argument_list|(
argument|fullname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fullname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|mkparents
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|mkdir
argument_list|(
name|buf
argument_list|,
literal|0755
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"mkdir failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"mkdir %s, rc %d\n"
argument_list|,
name|buf
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_comment
comment|/*	Make sure this file is a legal article. */
end_comment

begin_expr_stmt
name|islegal
argument_list|(
name|fullname
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
specifier|register
name|char
operator|*
name|fullname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|buffer
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* make sure the article is numeric. */
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|name
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|name
operator|++
expr_stmt|;
comment|/*  Now make sure we don't have a group like net.micro.432, 	 *  which is numeric but not a regular file -- i.e., check 	 *  for being a regular file. 	 */
if|if
condition|(
operator|(
name|stat
argument_list|(
name|fullname
argument_list|,
operator|&
name|buffer
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|buffer
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
condition|)
block|{
comment|/* Now that we found a legal group in a/b/c/4 		   notation, switch it to a.b.c/4 notation.  */
for|for
control|(
name|name
operator|=
name|fullname
init|;
name|name
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|!=
literal|'\0'
condition|;
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|&&
name|name
operator|!=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|name
operator|=
literal|'.'
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DBM
end_ifdef

begin_comment
comment|/*  * This is taken mostly intact from ../cvt/cvt.hist.c and is used at the  * end by the options that make a new history file.  * Routine to convert history file to dbm file.  The old 3 field  * history file is still kept there, because we need it for expire  * and for a human readable copy.  But we keep a dbm hashed copy  * around by message ID so we can answer the yes/no question "have  * we already seen this message".  The content is the ftell offset  * into the real history file when we get the article - you can't  * really do much with this because the file gets compacted.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|namebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lb
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|rebuilddbm
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|fpos
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%s.dir"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|namebuf
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%s.pag"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|namebuf
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%s"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|namebuf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|initdbm
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|fpos
operator|=
name|ftell
argument_list|(
name|fd
argument_list|)
operator|,
name|fgets
argument_list|(
name|lb
argument_list|,
name|BUFSIZ
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|lb
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|remember
argument_list|(
name|lb
argument_list|,
name|fpos
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|remember
argument_list|(
name|article
argument_list|,
name|fileoff
argument_list|)
specifier|register
name|char
operator|*
name|article
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|fileoff
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|lcase
argument_list|(
name|article
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|article
expr_stmt|;
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|article
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fileoff
expr_stmt|;
name|rhs
operator|.
name|dsize
operator|=
sizeof|sizeof
name|fileoff
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|5
condition|)
name|printf
argument_list|(
literal|"remember: %s @ %ld\n"
argument_list|,
name|article
argument_list|,
name|fileoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|<
literal|0
condition|)
name|xerror
argument_list|(
literal|"dbm store failed"
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Open the next history subdirectory file  */
end_comment

begin_function
name|FILE
modifier|*
name|nexthistfile
parameter_list|(
name|ofp
parameter_list|)
name|FILE
modifier|*
name|ofp
decl_stmt|;
block|{
specifier|static
name|int
name|histfilecounter
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|ofp
condition|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|histfilecounter
operator|>
literal|9
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s.d/%d"
argument_list|,
name|ARTFILE
argument_list|,
name|histfilecounter
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"reading history file %s\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|bfr
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ofp
operator|==
name|NULL
condition|)
do|;
return|return
name|ofp
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuild the history subdirectory from LIBDIR/history  */
end_comment

begin_macro
name|rebuildhistorydir
argument_list|()
end_macro

begin_block
block|{
name|char
name|fn
index|[
name|BUFLEN
index|]
decl_stmt|,
name|ofn
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|subfd
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|ohfd
decl_stmt|;
comment|/* rebuild history subfiles */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s.od"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|fn
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s.d"
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Rebuilding history subfile directory %s.\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|fn
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s.d/%c"
argument_list|,
name|ARTFILE
argument_list|,
name|i
operator|+
literal|'0'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ofn
argument_list|,
literal|"%s.od/%c"
argument_list|,
name|ARTFILE
argument_list|,
name|i
operator|+
literal|'0'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|fn
argument_list|,
name|ofn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|fn
argument_list|,
literal|0644
argument_list|)
argument_list|)
expr_stmt|;
name|subfd
index|[
name|i
index|]
operator|=
name|xfopen
argument_list|(
name|fn
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
block|}
name|ohfd
operator|=
name|xfopen
argument_list|(
name|ARTFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|fn
argument_list|,
name|BUFLEN
argument_list|,
name|ohfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|findhfdigit
argument_list|(
name|fn
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|fputs
argument_list|(
name|fn
argument_list|,
name|subfd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ohfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ferror
argument_list|(
name|subfd
index|[
name|i
index|]
argument_list|)
operator|||
name|fclose
argument_list|(
name|subfd
index|[
name|i
index|]
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"History subfile write"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|ARTFILE
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DBM */
end_comment

begin_macro
name|xxit
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|rmlock
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

