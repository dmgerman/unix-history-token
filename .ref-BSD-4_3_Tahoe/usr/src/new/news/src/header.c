begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * header.c - header functions plus some other goodies  */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)header.c	2.49	10/7/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_function_decl
name|char
modifier|*
name|hfgets
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|news_version
init|=
name|NEWS_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read header from file fp into *hp.  If wholething is FALSE,  * it's an incremental read, otherwise start from scratch.  * Return (FILE *) if header okay, else NULL.  */
end_comment

begin_function
name|FILE
modifier|*
name|hread
parameter_list|(
name|hp
parameter_list|,
name|fp
parameter_list|,
name|wholething
parameter_list|)
specifier|register
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|wholething
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|GENERICPATH
specifier|register
name|int
name|len
decl_stmt|;
endif|#
directive|endif
comment|/* GENERICPATH */
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|OLD
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
comment|/* OLD */
if|if
condition|(
name|wholething
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|unrec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hp
operator|->
name|unrec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
condition|;
name|i
operator|++
control|)
name|hp
operator|->
name|unrec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Check that it's a B news style header. */
if|if
condition|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|PATHLEN
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
name|isalpha
argument_list|(
name|bfr
index|[
literal|0
index|]
argument_list|)
operator|&&
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
condition|)
if|if
condition|(
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
condition|)
goto|goto
name|strip
goto|;
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|bfr
operator|+
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* It's not.  Try A news (begins with PROTO). */
if|if
condition|(
name|bfr
index|[
literal|0
index|]
operator|!=
name|PROTO
condition|)
return|return
name|NULL
return|;
ifndef|#
directive|ifndef
name|OLD
name|logerr
argument_list|(
literal|"Can not process A news format article without OLD defined"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OLD */
comment|/* Read in an A news format article. */
name|p
operator|=
name|index
argument_list|(
name|bfr
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
name|bfr
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%s@%s%s>"
argument_list|,
name|p
argument_list|,
name|bfr
operator|+
literal|1
argument_list|,
literal|".UUCP"
argument_list|)
expr_stmt|;
comment|/* Newsgroup List */
if|if
condition|(
name|hfgets
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* source path */
if|if
condition|(
name|hfgets
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|PATHLEN
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|path
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* date */
if|if
condition|(
name|hfgets
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
name|DATELEN
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* title */
if|if
condition|(
name|hfgets
argument_list|(
name|hp
operator|->
name|title
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|title
argument_list|)
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* OLD */
name|strip
label|:
comment|/* strip off sys! from front of path. */
ifndef|#
directive|ifndef
name|GENERICPATH
if|if
condition|(
name|strncmp
argument_list|(
name|PATHSYSNAME
argument_list|,
name|hp
operator|->
name|path
argument_list|,
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|PATHSYSNAME
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|hp
operator|->
name|path
index|[
name|len
index|]
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
operator|&
operator|(
name|hp
operator|->
name|path
index|[
name|len
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GENERICPATH */
name|lcase
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
comment|/* Intuit the From: line if only a path was given. */
if|if
condition|(
name|wholething
condition|)
block|{
ifdef|#
directive|ifdef
name|OLD
if|if
condition|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|intuitfrom
argument_list|(
name|hp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* OLD */
name|fixfrom
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Get header info from mail-format file.  * Return non-zero on success.  */
end_comment

begin_define
define|#
directive|define
name|FROM
value|1
end_define

begin_define
define|#
directive|define
name|NEWSGROUP
value|2
end_define

begin_define
define|#
directive|define
name|TITLE
value|3
end_define

begin_define
define|#
directive|define
name|SUBMIT
value|4
end_define

begin_define
define|#
directive|define
name|RECEIVE
value|5
end_define

begin_define
define|#
directive|define
name|EXPIRE
value|6
end_define

begin_define
define|#
directive|define
name|ARTICLEID
value|7
end_define

begin_define
define|#
directive|define
name|MESSAGEID
value|8
end_define

begin_define
define|#
directive|define
name|REPLYTO
value|9
end_define

begin_define
define|#
directive|define
name|FOLLOWID
value|10
end_define

begin_define
define|#
directive|define
name|CONTROL
value|11
end_define

begin_define
define|#
directive|define
name|SENDER
value|12
end_define

begin_define
define|#
directive|define
name|FOLLOWTO
value|13
end_define

begin_define
define|#
directive|define
name|PATH
value|14
end_define

begin_define
define|#
directive|define
name|POSTVERSION
value|15
end_define

begin_define
define|#
directive|define
name|RELAYVERSION
value|16
end_define

begin_define
define|#
directive|define
name|DISTRIBUTION
value|17
end_define

begin_define
define|#
directive|define
name|ORGANIZATION
value|18
end_define

begin_define
define|#
directive|define
name|NUMLINES
value|19
end_define

begin_define
define|#
directive|define
name|KEYWORDS
value|20
end_define

begin_define
define|#
directive|define
name|APPROVED
value|21
end_define

begin_define
define|#
directive|define
name|NFID
value|22
end_define

begin_define
define|#
directive|define
name|NFFROM
value|23
end_define

begin_define
define|#
directive|define
name|XREF
value|24
end_define

begin_define
define|#
directive|define
name|SUMMARY
value|25
end_define

begin_define
define|#
directive|define
name|XPATH
value|26
end_define

begin_define
define|#
directive|define
name|SUPERSEDES
value|27
end_define

begin_define
define|#
directive|define
name|OTHER
value|99
end_define

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unreccnt
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|type
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PATH
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FROM
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|from
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWSGROUP
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TITLE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|title
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|title
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBMIT
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPIRE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|expdate
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|expdate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OLD
case|case
name|ARTICLEID
case|:
comment|/* Believe Message-ID in preference to Article-ID */
if|if
condition|(
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|msgb
index|[
name|NAMELEN
index|]
decl_stmt|;
name|getfield
argument_list|(
name|msgb
argument_list|,
sizeof|sizeof
name|msgb
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|msgb
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
name|msgb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%s@%s%s>"
argument_list|,
name|p
argument_list|,
name|msgb
argument_list|,
literal|".UUCP"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* OLD */
case|case
name|MESSAGEID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLYTO
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|replyto
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|replyto
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|followid
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|followid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SENDER
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|sender
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|sender
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWTO
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|followto
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|followto
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTROL
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|ctlmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|ctlmsg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISTRIBUTION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|distribution
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|distribution
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hp
operator|->
name|distribution
argument_list|,
literal|"net"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|hp
operator|->
name|distribution
argument_list|,
literal|"world"
argument_list|)
operator|==
literal|0
condition|)
name|hp
operator|->
name|distribution
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ORGANIZATION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|organization
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|organization
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMLINES
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|numlines
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|numlines
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|intnumlines
operator|=
name|atoi
argument_list|(
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORDS
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|keywords
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|keywords
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|APPROVED
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|approved
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|approved
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|nf_id
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|nf_id
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFFROM
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|nf_from
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|nf_from
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUPERSEDES
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|supersedes
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|supersedes
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* discard these lines */
case|case
name|XREF
case|:
case|case
name|XPATH
case|:
case|case
name|RELAYVERSION
case|:
case|case
name|POSTVERSION
case|:
case|case
name|RECEIVE
case|:
break|break;
case|case
name|SUMMARY
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|summary
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|summary
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTHER
case|:
if|if
condition|(
name|unreccnt
operator|<
name|NUNREC
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nstrip
argument_list|(
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
argument_list|)
expr_stmt|;
name|unreccnt
operator|++
expr_stmt|;
block|}
else|else
name|xerror
argument_list|(
literal|"frmread: out of memory"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|=
name|type
argument_list|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|LBUFLEN
argument_list|,
name|fp
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
operator|||
name|hp
operator|->
name|path
index|[
literal|0
index|]
operator|)
operator|&&
name|hp
operator|->
name|subdate
index|[
literal|0
index|]
operator|&&
name|hp
operator|->
name|ident
index|[
literal|0
index|]
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OLD
end_ifdef

begin_comment
comment|/*  * There was no From: line in the message (because it was generated by  * an old news program).  Guess what it should have been and create it.  */
end_comment

begin_expr_stmt
name|intuitfrom
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|tailpath
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
name|char
name|pathbuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
name|fullname
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mydomain
parameter_list|()
function_decl|;
name|tp
operator|=
name|tailpath
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|user
operator|=
name|rindex
argument_list|(
name|tp
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
name|user
operator|=
name|tp
expr_stmt|;
else|else
operator|*
name|user
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check for an existing Internet address on the end. */
name|at
operator|=
name|index
argument_list|(
name|user
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
condition|)
block|{
name|dot
operator|=
name|index
argument_list|(
name|at
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* @ signs are illegal except for the biggie, so */
operator|*
name|at
operator|=
literal|'%'
expr_stmt|;
block|}
if|if
condition|(
name|tp
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|host
operator|=
name|index
argument_list|(
name|tp
argument_list|,
literal|'!'
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|user
operator|==
name|tp
condition|)
name|host
operator|=
name|FROMSYSNAME
expr_stmt|;
else|else
name|host
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|index
argument_list|(
name|host
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|host
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|"%s@%s%s"
argument_list|,
name|user
argument_list|,
name|host
argument_list|,
name|mydomain
argument_list|()
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|"%s@%s"
argument_list|,
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|skin
argument_list|(
name|pathbuf
argument_list|,
name|fullname
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* remove RFC822-style comments */
if|if
condition|(
name|fullname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
comment|/* and stick it back in */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD */
end_comment

begin_comment
comment|/*  * Canonicalize the "From:" line into the form  *  * From:<mail-address> (full-name)  *  * RFC822 doesn't require the comment to be at the end of the string  * like that.  */
end_comment

begin_expr_stmt
name|fixfrom
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|frombuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
name|fullname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|skin
argument_list|(
name|frombuf
argument_list|,
name|fullname
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
comment|/* remove RFC822-style comments */
if|if
condition|(
name|fullname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|frombuf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|frombuf
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|frombuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|frombuf
argument_list|)
expr_stmt|;
comment|/* stick the canonicalized "from" back in */
block|}
end_block

begin_macro
name|skin
argument_list|(
argument|name
argument_list|,
argument|fullname
argument_list|,
argument|hfield
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fullname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hfield
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|int
name|gotlt
decl_stmt|,
name|parenlev
decl_stmt|,
name|lastsp
decl_stmt|;
name|int
name|seenfullname
init|=
name|FALSE
decl_stmt|;
operator|*
name|fullname
operator|=
literal|'\0'
expr_stmt|;
comment|/* no full name yet */
if|if
condition|(
name|strpbrk
argument_list|(
name|hfield
argument_list|,
literal|"(< "
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* include ',' ?? */
name|strcpy
argument_list|(
name|name
argument_list|,
name|hfield
argument_list|)
expr_stmt|;
return|return;
block|}
name|gotlt
operator|=
literal|0
expr_stmt|;
name|parenlev
operator|=
literal|0
expr_stmt|;
name|lastsp
operator|=
literal|0
expr_stmt|;
name|bufend
operator|=
name|name
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|hfield
operator|,
name|cp2
operator|=
name|bufend
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
comment|/* 			 * Start of a "comment". 			 * Ignore it, or save it in "fullname" if we haven't 			 * seen a comment yet. 			 */
name|parenlev
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|0
condition|)
goto|goto
name|outcm
goto|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|parenlev
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|parenlev
operator|--
expr_stmt|;
if|if
condition|(
name|parenlev
operator|==
literal|0
condition|)
goto|goto
name|outcm
goto|;
break|break;
block|}
if|if
condition|(
operator|!
name|seenfullname
condition|)
operator|*
name|fullname
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|outcm
label|:
name|parenlev
operator|=
literal|0
expr_stmt|;
name|lastsp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|seenfullname
condition|)
block|{
operator|*
name|fullname
operator|=
literal|'\0'
expr_stmt|;
name|seenfullname
operator|=
name|TRUE
expr_stmt|;
comment|/* only extract first comment */
block|}
break|break;
case|case
literal|'"'
case|:
comment|/* 			 * Start of a "quoted-string". 			 * Copy it in its entirety. 			 */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|0
condition|)
goto|goto
name|outqs
goto|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
goto|goto
name|outqs
goto|;
block|}
operator|*
name|cp2
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|outqs
label|:
name|lastsp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|' '
case|:
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
name|cp
operator|+=
literal|3
operator|,
operator|*
name|cp2
operator|++
operator|=
literal|'@'
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|' '
condition|)
name|cp
operator|+=
literal|2
operator|,
operator|*
name|cp2
operator|++
operator|=
literal|'@'
expr_stmt|;
else|else
name|lastsp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|seenfullname
condition|)
block|{
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|seenfullname
operator|=
name|TRUE
expr_stmt|;
block|}
name|cp2
operator|=
name|bufend
expr_stmt|;
name|gotlt
operator|++
expr_stmt|;
name|lastsp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|gotlt
condition|)
block|{
name|gotlt
operator|=
literal|0
expr_stmt|;
comment|/* 				 * this doesn't seem reasonable, what about (,) 				 * or "," ?? 				 */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|','
operator|&&
operator|*
name|cp
operator|!=
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
operator|*
name|cp2
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|' '
expr_stmt|;
name|bufend
operator|=
name|cp2
expr_stmt|;
break|break;
block|}
comment|/* Fall into . . . */
default|default:
if|if
condition|(
name|lastsp
condition|)
block|{
name|lastsp
operator|=
literal|0
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|cp2
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OLD
end_ifdef

begin_function
name|char
modifier|*
name|oident
parameter_list|(
name|ident
parameter_list|)
name|char
modifier|*
name|ident
decl_stmt|;
block|{
name|char
name|lbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|static
name|char
name|oidbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ident
return|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
index|[
name|SNLN
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|oidbuf
argument_list|,
literal|"%s.%s"
argument_list|,
name|p
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|oidbuf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD */
end_comment

begin_comment
comment|/*  * Get the given field of a header (char * parm) from bfr, but only  * if there's something actually there (after the colon).  Don't  * bother if we already have an entry for this field.  */
end_comment

begin_macro
name|getfield
argument_list|(
argument|hpfield
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|hpfield
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|hpfield
index|[
literal|0
index|]
condition|)
return|return;
for|for
control|(
name|ptr
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
init|;
name|isspace
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|hpfield
argument_list|,
name|ptr
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nstrip
argument_list|(
name|hpfield
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|its
parameter_list|(
name|type
parameter_list|)
value|(PREFIX(ptr, type))
end_define

begin_expr_stmt
name|type
argument_list|(
name|ptr
argument_list|)
specifier|register
name|char
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|space
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"From: "
argument_list|)
condition|)
if|if
condition|(
name|index
argument_list|(
name|ptr
argument_list|,
literal|'@'
argument_list|)
operator|||
operator|!
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
condition|)
return|return
name|FROM
return|;
else|else
return|return
name|PATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Path: "
argument_list|)
condition|)
return|return
name|PATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Newsgroups: "
argument_list|)
condition|)
return|return
name|NEWSGROUP
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Subject: "
argument_list|)
condition|)
return|return
name|TITLE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Date: "
argument_list|)
condition|)
return|return
name|SUBMIT
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Date-Received: "
argument_list|)
condition|)
return|return
name|RECEIVE
return|;
ifdef|#
directive|ifdef
name|OLD
if|if
condition|(
name|its
argument_list|(
literal|"Title: "
argument_list|)
condition|)
return|return
name|TITLE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Posted: "
argument_list|)
condition|)
return|return
name|SUBMIT
return|;
endif|#
directive|endif
comment|/* OLD */
if|if
condition|(
name|its
argument_list|(
literal|"Received: "
argument_list|)
condition|)
return|return
name|RECEIVE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Expires: "
argument_list|)
condition|)
return|return
name|EXPIRE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Article-I.D.: "
argument_list|)
condition|)
return|return
name|ARTICLEID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Message-ID: "
argument_list|)
condition|)
return|return
name|MESSAGEID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Reply-To: "
argument_list|)
condition|)
return|return
name|REPLYTO
return|;
if|if
condition|(
name|its
argument_list|(
literal|"References: "
argument_list|)
condition|)
return|return
name|FOLLOWID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Control: "
argument_list|)
condition|)
return|return
name|CONTROL
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Sender: "
argument_list|)
condition|)
return|return
name|SENDER
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Followup-To: "
argument_list|)
condition|)
return|return
name|FOLLOWTO
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Distribution: "
argument_list|)
condition|)
return|return
name|DISTRIBUTION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Organization: "
argument_list|)
condition|)
return|return
name|ORGANIZATION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Lines: "
argument_list|)
condition|)
return|return
name|NUMLINES
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Summary: "
argument_list|)
condition|)
return|return
name|SUMMARY
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Keywords: "
argument_list|)
condition|)
return|return
name|KEYWORDS
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Approved: "
argument_list|)
condition|)
return|return
name|APPROVED
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Nf-ID: "
argument_list|)
condition|)
return|return
name|NFID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Nf-From: "
argument_list|)
condition|)
return|return
name|NFFROM
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Supersedes: "
argument_list|)
condition|)
return|return
name|SUPERSEDES
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Xref: "
argument_list|)
condition|)
return|return
name|XREF
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Xpath: "
argument_list|)
condition|)
return|return
name|XPATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Posting-Version: "
argument_list|)
condition|)
return|return
name|POSTVERSION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Relay-Version: "
argument_list|)
condition|)
return|return
name|RELAYVERSION
return|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|colon
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|space
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
operator|||
name|space
operator|&&
name|space
operator|<
name|colon
condition|)
return|return
name|FALSE
return|;
return|return
name|OTHER
return|;
block|}
end_block

begin_comment
comment|/*  * Write header at 'hp' on stream 'fp' in B+ format.  Include received date  * if wr is 1.  Leave off sysname if wr is 2.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOXREFS
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOXREFS */
end_comment

begin_expr_stmt
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|wr
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|iu
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|time_t
name|cgtdate
parameter_list|()
function_decl|;
comment|/* 	 * We're being tricky with Path/From because of upward compatibility 	 * issues.  The new version considers From and Path to be separate. 	 * The old one thinks they both mean "Path" but only believes the 	 * first one it sees, so will ignore the second. 	 */
if|if
condition|(
name|PREFIX
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|PATHSYSNAME
argument_list|)
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|hp
operator|->
name|path
index|[
name|strlen
argument_list|(
name|PATHSYSNAME
argument_list|)
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Path: %s\n"
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Path: %s!%s\n"
argument_list|,
name|PATHSYSNAME
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\n"
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|summary
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Summary: %s\n"
argument_list|,
name|hp
operator|->
name|summary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|keywords
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keywords: %s\n"
argument_list|,
name|hp
operator|->
name|keywords
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Message-ID: %s\n"
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|t
operator|=
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLD
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Article-I.D.: %s\n"
argument_list|,
name|oident
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Posted: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OLD */
if|if
condition|(
operator|*
name|hp
operator|->
name|expdate
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Expires: %s\n"
argument_list|,
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followid
condition|)
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|dp
operator|=
name|cp
operator|=
name|hp
operator|->
name|followid
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'<'
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|'>'
condition|)
name|cp
operator|+=
literal|2
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followid
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"References: %s\n"
argument_list|,
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|hp
operator|->
name|ctlmsg
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Control: %s\n"
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|sender
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Sender: %s\n"
argument_list|,
name|hp
operator|->
name|sender
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|replyto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Reply-To: %s\n"
argument_list|,
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Followup-To: %s\n"
argument_list|,
name|hp
operator|->
name|followto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|distribution
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Distribution: %s\n"
argument_list|,
name|hp
operator|->
name|distribution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|organization
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Organization: %s\n"
argument_list|,
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|numlines
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Lines: %s\n"
argument_list|,
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|approved
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Approved: %s\n"
argument_list|,
name|hp
operator|->
name|approved
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|nf_id
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Nf-ID: %s\n"
argument_list|,
name|hp
operator|->
name|nf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|nf_from
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Nf-From: %s\n"
argument_list|,
name|hp
operator|->
name|nf_from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|supersedes
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Supersedes: %s\n"
argument_list|,
name|hp
operator|->
name|supersedes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOXREFS
if|if
condition|(
name|wr
operator|==
literal|1
operator|&&
operator|*
name|hp
operator|->
name|xref
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Xref: %s\n"
argument_list|,
name|hp
operator|->
name|xref
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DOXREFS */
for|for
control|(
name|iu
operator|=
literal|0
init|;
name|iu
operator|<
name|NUNREC
condition|;
name|iu
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|&
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_comment
comment|/*  * Set nc bytes, starting at cp, to zero.  */
end_comment

begin_expr_stmt
name|bzero
argument_list|(
name|cp
argument_list|,
name|nc
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|nc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nc
operator|>
literal|0
condition|)
do|do
block|{
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nc
condition|)
do|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD4_2 */
end_comment

begin_comment
comment|/*  * hfgets is like fgets, but deals with continuation lines.  * It also ensures that even if a line that is too long is  * received, the remainder of the line is thrown away  * instead of treated like a second line.  */
end_comment

begin_function
name|char
modifier|*
name|hfgets
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|len
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|cp
operator|==
name|buf
condition|)
return|return
name|NULL
return|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Line too long - part read didn't fit into a newline */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
block|{
comment|/* Don't look for continuation of blank lines */
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* for each cont line */
comment|/* Continuation line. */
if|if
condition|(
operator|(
name|n
operator|+=
literal|2
operator|)
operator|<
name|len
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|n
operator|++
operator|<
name|len
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|len
operator|-
literal|1
condition|)
name|cp
operator|=
name|buf
operator|+
name|len
operator|-
literal|2
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* push back first char of next header */
return|return
name|buf
return|;
block|}
end_function

end_unit

