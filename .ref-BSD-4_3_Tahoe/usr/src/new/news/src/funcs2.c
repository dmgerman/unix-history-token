begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1985 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  *  * funcs2 - functions used by both inews and readnews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)funcs2.c	1.22	10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SunIII
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|INTERNET
end_ifndef

begin_define
define|#
directive|define
name|INTERNET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !INTERNET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SunIII */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_comment
comment|/*  * Get user name and home directory.  */
end_comment

begin_macro
name|getuser
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|flag
init|=
name|TRUE
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot get user's name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|username
operator|==
name|NULL
operator|||
name|username
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|STRCMP
argument_list|(
name|username
argument_list|,
literal|"Unknown"
argument_list|)
operator|==
literal|0
condition|)
name|username
operator|=
name|AllocCpy
argument_list|(
name|p
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|userhome
operator|=
name|AllocCpy
argument_list|(
name|p
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|flag
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|header
operator|.
name|path
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* no sys file on clients via nntp */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER
end_ifndef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|sysfile
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|fldget
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|sfline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open SUBFILE.  */
end_comment

begin_macro
name|s_openr
argument_list|()
end_macro

begin_block
block|{
name|sysfile
operator|=
name|xfopen
argument_list|(
name|SUBFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sfline
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read SUBFILE.  */
end_comment

begin_expr_stmt
name|s_read
argument_list|(
name|sp
argument_list|)
specifier|register
expr|struct
name|srec
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|chop_spaces
init|=
literal|0
decl_stmt|;
name|again
label|:
name|p
operator|=
name|bfr
expr_stmt|;
comment|/*          * Read  the  SUBFILE  (/usr/lib/news/sys)  from   the   current 	 * position  to  the  first  unescaped newline.  If a newline is 	 * escaped with a backslash (\) continue reading but throw  away 	 * the backslash and newline; read the next line skipping spaces 	 * and tabs until the first non-space/tab character, then  start 	 * looking   for   a   newline   again.   Skipping  the  leading 	 * spaces/tabs after a escaped newline  keeps  the  news  groups 	 * together.  If  a  line  begins  with a newline, just skip it. 	 */
for|for
control|(
name|e
operator|=
name|p
operator|+
name|LBUFLEN
init|;
name|p
operator|<
name|e
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|sysfile
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|sfline
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|bfr
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
block|{
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
name|chop_spaces
operator|++
expr_stmt|;
name|p
operator|-=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chop_spaces
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
else|else
name|chop_spaces
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|bfr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
comment|/* skip leading white space */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
goto|goto
name|again
goto|;
comment|/* skip newlines */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|p
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"SUBFILE (%s) line %d too long."
argument_list|,
name|SUBFILE
argument_list|,
name|sfline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
goto|goto
name|again
goto|;
name|sp
operator|->
name|s_xmit
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|s_flags
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|s_nosend
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|p
operator|=
name|fldget
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"Bad SUBFILE (%s) line %d."
argument_list|,
name|SUBFILE
argument_list|,
name|sfline
argument_list|)
expr_stmt|;
comment|/* 	 * A sys file line reading "ME" means the name of the local system. 	 */
if|if
condition|(
name|STRCMP
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
literal|"ME"
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
name|LOCALPATHSYSNAME
argument_list|)
expr_stmt|;
name|e
operator|=
name|index
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
operator|*
name|e
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|s_nosend
operator|=
name|e
expr_stmt|;
block|}
name|p
operator|=
name|fldget
argument_list|(
name|sp
operator|->
name|s_nbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lcase
argument_list|(
name|sp
operator|->
name|s_nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
name|p
operator|=
name|fldget
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
operator|(
name|void
operator|)
name|fldget
argument_list|(
name|sp
operator|->
name|s_xmit
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|fldget
parameter_list|(
name|q
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|q
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/*  * Find the SUBFILE record for a system.  */
end_comment

begin_expr_stmt
name|s_find
argument_list|(
name|sp
argument_list|,
name|system
argument_list|)
specifier|register
expr|struct
name|srec
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|system
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|STRNCMP
argument_list|(
name|system
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s_close
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|s_close
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Close sysfile.  */
end_comment

begin_macro
name|s_close
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sysfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|timeb
name|Now
decl_stmt|;
end_decl_stmt

begin_function
name|time_t
name|cgtdate
parameter_list|(
name|datestr
parameter_list|)
name|char
modifier|*
name|datestr
decl_stmt|;
block|{
name|char
name|junk
index|[
literal|40
index|]
decl_stmt|,
name|month
index|[
literal|40
index|]
decl_stmt|,
name|day
index|[
literal|30
index|]
decl_stmt|,
name|tod
index|[
literal|60
index|]
decl_stmt|,
name|year
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|time_t
name|lasttime
decl_stmt|;
specifier|static
name|char
name|lastdatestr
index|[
name|BUFLEN
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|lastdatestr
index|[
literal|0
index|]
operator|&&
name|STRCMP
argument_list|(
name|datestr
argument_list|,
name|lastdatestr
argument_list|)
operator|==
literal|0
condition|)
return|return
name|lasttime
return|;
name|lasttime
operator|=
name|getdate
argument_list|(
name|datestr
argument_list|,
operator|&
name|Now
argument_list|)
expr_stmt|;
if|if
condition|(
name|lasttime
operator|<
literal|0
operator|&&
name|sscanf
argument_list|(
name|datestr
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|junk
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|tod
argument_list|,
name|year
argument_list|)
operator|==
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s %s, %s %s"
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|tod
argument_list|)
expr_stmt|;
name|lasttime
operator|=
name|getdate
argument_list|(
name|bfr
argument_list|,
operator|&
name|Now
argument_list|)
expr_stmt|;
if|if
condition|(
name|lasttime
operator|<
literal|0
condition|)
block|{
name|logerr
argument_list|(
literal|"Unparsable date \"%s\""
argument_list|,
name|datestr
argument_list|)
expr_stmt|;
name|datestr
operator|=
literal|"now"
expr_stmt|;
comment|/* better than nothing */
name|lasttime
operator|=
name|Now
operator|.
name|time
expr_stmt|;
block|}
block|}
name|strncpy
argument_list|(
name|lastdatestr
argument_list|,
name|datestr
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
return|return
name|lasttime
return|;
block|}
end_function

begin_expr_stmt
name|lcase
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|s
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|*
name|ptr
operator|=
name|tolower
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return a compact representation of the person who posted the given  * message.  A sender or internet name will be used, otherwise  * the last part of the path is used preceded by an optional ".."  */
end_comment

begin_function
name|char
modifier|*
name|tailpath
parameter_list|(
name|hp
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|static
name|char
name|resultbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
name|pathbuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* 	 * This only happens for articles posted by old news software 	 * in non-internet format. 	 */
name|resultbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pathbuf
argument_list|,
name|hp
operator|->
name|path
argument_list|,
name|PATHLEN
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|pathbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Chop off trailing " (name)" */
name|r
operator|=
name|rindex
argument_list|(
name|pathbuf
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|pathbuf
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|r
operator|>
name|pathbuf
operator|&&
operator|*
operator|--
name|r
operator|!=
literal|'!'
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|>
name|pathbuf
condition|)
block|{
name|r
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resultbuf
argument_list|,
literal|"..!"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|resultbuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|resultbuf
return|;
block|}
end_function

begin_comment
comment|/*  * arpadate is like ctime(3) except that the time is returned in  * an acceptable ARPANET time format instead of ctime format.  */
end_comment

begin_function
name|char
modifier|*
name|arpadate
parameter_list|(
name|longtime
parameter_list|)
name|time_t
modifier|*
name|longtime
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|ud
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|b
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|asctime
parameter_list|()
function_decl|;
comment|/*  Get current time. This will be used resolve the timezone. */
name|ud
operator|=
name|asctime
argument_list|(
name|gmtime
argument_list|(
name|longtime
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Crack the UNIX date line in a singularly unoriginal way. */
name|q
operator|=
name|b
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* until every site installs the fix to getdate.y, the day    of the week can cause time warps */
name|p
operator|=
operator|&
name|ud
index|[
literal|0
index|]
expr_stmt|;
comment|/* Mon */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|&
name|ud
index|[
literal|8
index|]
expr_stmt|;
comment|/* 16 */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|4
index|]
expr_stmt|;
comment|/* Sep */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|22
index|]
expr_stmt|;
comment|/* 1979 */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|11
index|]
expr_stmt|;
comment|/* 01:03:52 */
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'G'
expr_stmt|;
comment|/* GMT */
operator|*
name|q
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|replyname
parameter_list|(
name|hptr
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|char
name|tbuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|ptr
operator|=
name|hptr
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|PREFIX
argument_list|(
name|ptr
argument_list|,
name|PATHSYSNAME
argument_list|)
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|ptr
index|[
name|strlen
argument_list|(
name|PATHSYSNAME
argument_list|)
index|]
argument_list|)
condition|)
name|ptr
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|hptr
operator|->
name|from
index|[
literal|0
index|]
condition|)
name|ptr
operator|=
name|hptr
operator|->
name|from
expr_stmt|;
if|if
condition|(
name|hptr
operator|->
name|replyto
index|[
literal|0
index|]
condition|)
name|ptr
operator|=
name|hptr
operator|->
name|replyto
expr_stmt|;
else|#
directive|else
comment|/* !INTERNET */
if|if
condition|(
name|hptr
operator|->
name|replyto
index|[
literal|0
index|]
operator|&&
operator|!
name|index
argument_list|(
name|hptr
operator|->
name|replyto
argument_list|,
literal|'@'
argument_list|)
condition|)
name|ptr
operator|=
name|hptr
operator|->
name|replyto
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|tbuf
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
while|while
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|--
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SunIII
if|if
condition|(
name|ptr
operator|=
name|rindex
argument_list|(
name|tbuf
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|PREFIX
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"OZ"
argument_list|)
condition|)
block|{
comment|/* some people only allow it in lower case ... */
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"oz"
argument_list|)
expr_stmt|;
return|return
name|tbuf
return|;
block|}
if|if
condition|(
name|PREFIX
argument_list|(
name|ptr
argument_list|,
literal|"UUCP"
argument_list|)
operator|||
name|PREFIX
argument_list|(
name|ptr
argument_list|,
literal|"ARPA"
argument_list|)
operator|||
name|PREFIX
argument_list|(
name|ptr
argument_list|,
literal|"DEC"
argument_list|)
operator|||
name|PREFIX
argument_list|(
name|ptr
argument_list|,
literal|"CSNET"
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|tbuf
argument_list|,
literal|"@munnari.oz"
argument_list|)
expr_stmt|;
comment|/* via sun to munnari */
return|return
name|tbuf
return|;
block|}
block|}
comment|/* 	 * must(?) have come from a uucp site, lets look see if path passes 	 * through munnari, and if so delete the fake uucp path after that. 	 */
for|for
control|(
name|ptr
operator|=
name|tbuf
init|;
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|PREFIX
argument_list|(
name|ptr
argument_list|,
literal|"munnari!"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
break|break;
block|}
comment|/* 	 * now, just send the address we have left to munnari, and 	 * hope that something sensible will be done with it there. 	 * (This works in more cases than you'd think ...) 	 */
name|strcat
argument_list|(
name|tbuf
argument_list|,
literal|"@munnari.oz"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SunIII */
ifndef|#
directive|ifndef
name|INTERNET
comment|/* 	 * Play games stripping off multiple berknet 	 * addresses (a!b!c:d:e => a!b!d:e) here. 	 */
for|for
control|(
name|ptr
operator|=
name|tbuf
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|index
argument_list|(
name|NETCHRS
argument_list|,
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
operator|==
literal|':'
operator|&&
operator|(
name|ptr2
operator|=
name|index
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|ptr2
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* INTERNET */
block|{
name|char
name|mbuf
index|[
name|BUFLEN
index|]
decl_stmt|,
name|modadd
index|[
name|BUFLEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|mfd
decl_stmt|;
comment|/* Let's find a path to the backbone */
name|sprintf
argument_list|(
name|mbuf
argument_list|,
literal|"%s/mailpaths"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|mfd
operator|=
name|xfopen
argument_list|(
name|mbuf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|mbuf
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|,
name|mfd
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't find internet in %s/mailpaths"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|PREFIX
argument_list|(
name|mbuf
argument_list|,
literal|"internet"
argument_list|)
condition|)
do|;
if|if
condition|(
name|sscanf
argument_list|(
name|mbuf
argument_list|,
literal|"%*s %s"
argument_list|,
name|modadd
argument_list|)
operator|!=
literal|1
condition|)
name|xerror
argument_list|(
literal|"backbone address corrupted"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mbuf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
comment|/* If we are lucky, there is no ! or @ in the forward address */
if|if
condition|(
name|strpbrk
argument_list|(
name|modadd
argument_list|,
literal|"!@"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
name|modadd
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
init|=
name|index
argument_list|(
name|mbuf
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
argument_list|(
name|modadd
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|&&
name|cp
condition|)
block|{
comment|/* we have to rearrange the address so no @ are in it */
name|char
name|atbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|atbuf
argument_list|,
literal|"%s!%s"
argument_list|,
name|cp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
name|modadd
argument_list|,
name|atbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
condition|)
block|{
comment|/* some days you don't get lucky. presume the % hack */
operator|*
name|cp
operator|=
literal|'%'
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
name|modadd
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* INTERNET */
endif|#
directive|endif
comment|/* !SunIII */
return|return
name|tbuf
return|;
block|}
end_function

begin_comment
comment|/*  * Given an article ID, find the line in the history file that mentions it.  * Return the text of the line, or NULL if not found.  A pointer to a  * static area is returned.  */
end_comment

begin_function
name|char
modifier|*
name|findhist
parameter_list|(
name|artid
parameter_list|)
name|char
modifier|*
name|artid
decl_stmt|;
block|{
specifier|static
name|char
name|lbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|oidbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|hfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER
name|char
name|workspace
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|long
name|clock
decl_stmt|;
else|#
directive|else
comment|/* !SERVER */
ifdef|#
directive|ifdef
name|DBM
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|datum
name|fetch
parameter_list|()
function_decl|;
name|long
name|fpos
decl_stmt|;
comment|/* We have to use an explicit variable to insure alignment */
else|#
directive|else
comment|/* !DBM */
name|char
modifier|*
name|histfile
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* !DBM */
endif|#
directive|endif
comment|/* !SERVER */
comment|/* Try to understand old artid's as well.  Assume .UUCP domain. */
if|if
condition|(
name|artid
index|[
literal|0
index|]
operator|!=
literal|'<'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|artid
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|oidbuf
argument_list|,
literal|"<%s@%s.UUCP>"
argument_list|,
name|p
argument_list|,
name|artid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oidbuf
argument_list|,
name|artid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"STAT %s"
argument_list|,
name|oidbuf
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|workspace
operator|!=
name|CHAR_OK
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"XHDR xref %s"
argument_list|,
name|oidbuf
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get response */
if|if
condition|(
operator|*
name|workspace
operator|!=
name|CHAR_OK
condition|)
return|return
name|NULL
return|;
comment|/* old style nntp */
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get header line */
name|sync_server
argument_list|()
expr_stmt|;
comment|/* get rid of the rest of it */
name|p
operator|=
name|index
argument_list|(
name|workspace
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
comment|/* there is no xref line */
name|long
name|s
decl_stmt|,
name|sm
decl_stmt|;
name|FILE
modifier|*
name|af
decl_stmt|;
name|char
name|n
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|name
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"XHDR newsgroups %s"
argument_list|,
name|oidbuf
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|workspace
operator|!=
name|CHAR_OK
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
name|sync_server
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|index
argument_list|(
name|workspace
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|name
operator|++
expr_stmt|;
comment|/* now we fetch the line from the active file */
name|af
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|af
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %ld %ld"
argument_list|,
name|n
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|sm
argument_list|)
operator|==
literal|3
operator|&&
name|STRCMP
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|af
argument_list|)
expr_stmt|;
comment|/* now we ask for a message ids in that newsgroup */
if|if
condition|(
name|set_group
argument_list|(
name|name
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"XHDR message-id %d-%d"
argument_list|,
name|sm
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|workspace
operator|!=
name|CHAR_OK
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|workspace
operator|==
literal|'.'
operator|&&
name|strlen
argument_list|(
name|workspace
argument_list|)
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strindex
argument_list|(
name|workspace
argument_list|,
name|oidbuf
argument_list|)
operator|>
operator|-
literal|1
condition|)
break|break;
block|}
name|sync_server
argument_list|()
expr_stmt|;
operator|*
operator|(
name|index
argument_list|(
name|workspace
argument_list|,
literal|' '
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|n
argument_list|,
name|workspace
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|workspace
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|workspace
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|workspace
index|[
literal|0
index|]
expr_stmt|;
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|sprintf
argument_list|(
argument|lbuf
argument_list|,
literal|"%s\t%2.2d/%2.2d/%d %2.2d:%2.2d\t%s"
argument_list|,
else|#
directive|else
comment|/* !USG */
argument|sprintf(lbuf,
literal|"%s\t%02d/%02d/%d %02d:%02d\t%s"
argument|,
endif|#
directive|endif
comment|/* !USG */
argument|oidbuf,tm->tm_mon,tm->tm_mday,tm->tm_year,tm->tm_hour,tm->tm_min,p); 	return lbuf;
comment|/* not really the same, but close */
else|#
directive|else
comment|/* !SERVER */
argument|lcase(oidbuf);
ifdef|#
directive|ifdef
name|DBM
argument|initdbm(ARTFILE); 	lhs.dptr = oidbuf; 	lhs.dsize = strlen(lhs.dptr) +
literal|1
argument|; 	rhs = fetch(lhs); 	if (rhs.dptr == NULL) 		return NULL; 	hfp = xfopen(ARTFILE,
literal|"r"
argument|);
comment|/* The bcopy is NECESSARY to insure alignment on some machines */
argument|bcopy(rhs.dptr, (char *)&fpos, sizeof (long)); 	fseek(hfp, fpos,
literal|0
argument|);
else|#
directive|else
comment|/* !DBM */
argument|hfp = xfopen(histfile(oidbuf),
literal|"r"
argument|);
endif|#
directive|endif
comment|/* !DBM */
argument|while (fgets(lbuf, BUFLEN, hfp) != NULL) { 		p = index(lbuf,
literal|'\t'
argument|); 		if (p == NULL) 			p = index(lbuf,
literal|'\n'
argument|); 		*p =
literal|0
argument|; 		if (STRCMP(lbuf, artid) ==
literal|0
argument||| STRCMP(lbuf, oidbuf) ==
literal|0
argument|) { 			(void) fclose(hfp); 			*p =
literal|'\t'
argument|; 			*(lbuf + strlen(lbuf) -
literal|1
argument|) =
literal|0
argument|;
comment|/* zap the \n */
argument|return lbuf; 		}
ifdef|#
directive|ifdef
name|DBM
argument|break;
endif|#
directive|endif
comment|/* DBM */
argument|} 	(void) fclose(hfp); 	return NULL;
endif|#
directive|endif
comment|/* !SERVER */
argument|}
comment|/*  * Hunt up the article "artid", and return the newsgroup/artnum  * where it can be found.  */
argument|char * findfname(artid) char *artid; { 	char *line
argument_list|,
argument|*p
argument_list|,
argument|*q; 	char *findhist(); 	static char fname[BUFLEN];  	line = findhist(artid); 	if (line) {
comment|/* Look for it stored as an article, where it should be */
argument|p = index(line,
literal|'\t'
argument|); 		p = index(p+
literal|1
argument|,
literal|'\t'
argument|); 		p++; 		if (*p) { 			q = index(p,
literal|' '
argument|); 			if (q) 				*q =
literal|0
argument|; 			(void) strcpy(fname, p); 			return fname; 		} 	} 	return NULL; }
comment|/*  * Hunt up the article "artid", fopen it for read, and return a  * file descriptor to it.  We look everywhere we can think of.  */
argument|FILE * hfopen(artid) char *artid; { 	char *p; 	char *findhist(); 	FILE *rv = NULL; 	char fname[BUFLEN];  	p = findfname(artid); 	if (p) {
ifdef|#
directive|ifdef
name|SERVER
argument|if ((rv = getartbyid(p)) != NULL) { 		strcpy(fname, article_name()); 		(void) fclose(rv); 		rv = NULL; 	} 	else 		xerror(
literal|"Cannot hfopen article %s"
argument|, artid);
else|#
directive|else
comment|/* !SERVER */
argument|(void) strcpy(fname, dirname(p));
endif|#
directive|endif
comment|/* !SERVER */
argument|rv = fopen(fname,
literal|"r"
argument|);
comment|/* NOT xfopen! */
argument|if (rv == NULL) 			xerror(
literal|"Cannot hfopen article %s"
argument|, artid); 	}
ifdef|#
directive|ifdef
name|SERVER
argument|(void) unlink(fname);
endif|#
directive|endif
comment|/* !SERVER */
argument|return rv; }
ifndef|#
directive|ifndef
name|SERVER
ifdef|#
directive|ifdef
name|DBM
comment|/* ** Avoid problems of multiple dbminit calls. */
argument|initdbm(name) char *name; { 	static int called =
literal|0
argument|;  	if (called !=
literal|0
argument|) 		return; 	called =
literal|1
argument|; 	(void) dbminit(name); }
endif|#
directive|endif
comment|/* DBM */
endif|#
directive|endif
comment|/* !SERVER */
ifndef|#
directive|ifndef
name|BSD4_2
comment|/*  * move n bytes from a to b  */
argument|bcopy(a, b, n) register char *a
argument_list|,
argument|*b; register n; { 	while (--n>=
literal|0
argument|) 		*b++ = *a++; }
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
argument|rename(from,to) register char *from
argument_list|,
argument|*to; { 	(void) unlink(to); 	if (link(from, to)<
literal|0
argument|) 		return -
literal|1
argument|;  	(void) unlink(from); 	return
literal|0
argument|; }
endif|#
directive|endif
comment|/* !BSD4_2 */
ifndef|#
directive|ifndef
name|DBM
comment|/* ** Generate the appropriate history subfile name */
argument|char * histfile(hline) char *hline; { 	char chr;
comment|/* least significant digit of article number */
argument|static char subfile[BUFLEN];  	chr = findhfdigit(hline); 	sprintf(subfile,
literal|"%s.d/%c"
argument|, ARTFILE, chr); 	return subfile; }  findhfdigit(fn) char *fn; { 	register char *p; 	register int chr;  	p = index(fn,
literal|'@'
argument|); 	if (p != NULL&& p> fn) 		chr = *(p -
literal|1
argument|); 	else 		chr =
literal|'0'
argument|; 	if (!isdigit(chr)) 		chr =
literal|'0'
argument|; 	return chr; }
endif|#
directive|endif
comment|/* !DBM */
ifdef|#
directive|ifdef
name|VMS
comment|/*  * These functions open an article with one level of indirection,  * to support symbolic links. xart_open exits if the open fails.  */
argument|FILE * xart_open (filename,mode) char *filename
argument_list|,
argument|*mode; { 	FILE *fp = art_open (filename, mode); 	extern int errno; 	if (fp == NULL) 		xerror(
literal|"Cannot open article %s (%s): %s\n"
argument|, 			 filename, mode, errmsg(errno)); 	return fp; }  FILE * art_open (filename,mode) char *filename
argument_list|,
argument|*mode; { 	char linkfile[BUFSIZ]; 	FILE *fp;  	if ((fp = fopen (filename, mode)) == NULL) 		return NULL; 	if (fgets (linkfile, BUFSIZ, fp) == NULL || linkfile[
literal|0
argument|] !=
literal|'/'
argument|) { 		rewind (fp); 		return fp; 	}
comment|/* Chase the symbolic link. */
argument|(void) fclose (fp); 	if ((fp = fopen (linkfile, mode)) == NULL)
comment|/* Clean up dangling link, if we have the power. Ignore error if we don't. */
argument|(void) unlink (filename); 	return fp; }
endif|#
directive|endif
comment|/* VMS */
comment|/*  * Generate the name of the person responsible for posting this article,  * in order to check that two articles were posted by the same person.  */
argument|char * senderof(hp) struct hbuf *hp; { 	register char *q
argument_list|,
argument|*tp; 	char *tailpath(); 	static char senderbuf[BUFLEN];  	if (hp->sender[
literal|0
argument|]) 		tp = hp->sender; 	else if (hp->from[
literal|0
argument|]) 		tp = hp->from; 	else 		tp = tailpath(hp);  	(void) strncpy(senderbuf, tp, BUFLEN);
comment|/* Remove full name */
argument|q = index(senderbuf,
literal|' '
argument|); 	if (q) 		*q =
literal|'\0'
argument|;  	return senderbuf; }
end_function

end_unit

