begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * visual - visual news interface.  * Kenneth Almquist  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)visual.c	1.38	10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USG */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USG */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|m
parameter_list|)
value|(1<<((m)-1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !sigmask */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MYDB
end_ifdef

begin_include
include|#
directive|include
file|"db.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MYDB */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGTSTP */
end_comment

begin_define
define|#
directive|define
name|ARTWLEN
value|(ROWS-2)
end_define

begin_comment
comment|/* number of lines used to display article */
end_comment

begin_define
define|#
directive|define
name|even
parameter_list|(
name|cols
parameter_list|)
value|((cols&1) ? cols + 1 : cols)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|STATTOP
end_ifdef

begin_define
define|#
directive|define
name|PRLINE
value|0
end_define

begin_comment
comment|/* prompter line */
end_comment

begin_define
define|#
directive|define
name|SPLINE
value|1
end_define

begin_comment
comment|/* secondary prompt line */
end_comment

begin_define
define|#
directive|define
name|ARTWIN
value|2
end_define

begin_comment
comment|/* first line of article window */
end_comment

begin_define
define|#
directive|define
name|SECPRLEN
value|81
end_define

begin_comment
comment|/* length of secondary prompter */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRLINE
value|(ROWS-1)
end_define

begin_comment
comment|/* prompter line */
end_comment

begin_define
define|#
directive|define
name|SPLINE
value|(ROWS-2)
end_define

begin_comment
comment|/* secondary prompt line */
end_comment

begin_define
define|#
directive|define
name|ARTWIN
value|0
end_define

begin_comment
comment|/* first line of article window */
end_comment

begin_define
define|#
directive|define
name|SECPRLEN
value|100
end_define

begin_comment
comment|/* length of secondary prompter */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PIPECHAR
value|'|'
end_define

begin_comment
comment|/* indicate save command should pipe to program */
end_comment

begin_define
define|#
directive|define
name|CAGAIN
value|('e'&0x1F)
end_define

begin_comment
comment|/* Save-to-same-place indicator */
end_comment

begin_define
define|#
directive|define
name|META
value|0200
end_define

begin_comment
comment|/* meta character bit (as in emacs) */
end_comment

begin_comment
comment|/* print (display) flags */
end_comment

begin_define
define|#
directive|define
name|HDRONLY
value|0001
end_define

begin_comment
comment|/* print header only */
end_comment

begin_define
define|#
directive|define
name|NOPRT
value|0002
end_define

begin_comment
comment|/* don't print at all */
end_comment

begin_define
define|#
directive|define
name|NEWART
value|0004
end_define

begin_comment
comment|/* force article display to be regenerated */
end_comment

begin_define
define|#
directive|define
name|HELPMSG
value|0010
end_define

begin_comment
comment|/* display currently contains help message */
end_comment

begin_comment
comment|/* prun flags */
end_comment

begin_define
define|#
directive|define
name|CWAIT
value|0001
end_define

begin_comment
comment|/* type "continue?" and wait for return */
end_comment

begin_define
define|#
directive|define
name|BKGRND
value|0002
end_define

begin_comment
comment|/* run process in the background */
end_comment

begin_comment
comment|/* values of curflag */
end_comment

begin_define
define|#
directive|define
name|CURP1
value|1
end_define

begin_comment
comment|/* cursor after prompt */
end_comment

begin_define
define|#
directive|define
name|CURP2
value|2
end_define

begin_comment
comment|/* cursor after secondary prompt */
end_comment

begin_define
define|#
directive|define
name|CURHOME
value|3
end_define

begin_comment
comment|/* cursor at home position */
end_comment

begin_comment
comment|/* flags for vsave routine */
end_comment

begin_define
define|#
directive|define
name|SVHEAD
value|01
end_define

begin_comment
comment|/* write out article header */
end_comment

begin_define
define|#
directive|define
name|OVWRITE
value|02
end_define

begin_comment
comment|/* overwrite the file if it already exists */
end_comment

begin_comment
comment|/* other files */
end_comment

begin_define
define|#
directive|define
name|saveart
value|oobit = bit;strcpy(ofilename1, filename);strcpy(ogroupdir, groupdir);hptr = h;h = hold;hold = hptr;ongsize = pngsize
end_define

begin_define
define|#
directive|define
name|NLINES
parameter_list|(
name|h
parameter_list|,
name|fp
parameter_list|)
value|(h->numlines[0] ? h->intnumlines : (h->intnumlines=linecnt(fp),sprintf(h->numlines, "%d", h->intnumlines), h->intnumlines))
end_define

begin_comment
comment|/* terminal handler stuff */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_junked
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|okclear
parameter_list|()
value|(_junked = 1)
end_define

begin_decl_stmt
specifier|extern
name|int
name|COLS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ROWS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hasscroll
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|tmpfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getmailname
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MYDB
end_ifdef

begin_function_decl
name|char
modifier|*
name|findparent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MYDB */
end_comment

begin_function_decl
name|int
name|onint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|onstop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|xxit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|Progname
init|=
literal|"vnews"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for xerror */
end_comment

begin_comment
comment|/* variables shared between vnews routines */
end_comment

begin_decl_stmt
specifier|static
name|char
name|linebuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary workspace */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary file */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tfname
index|[]
init|=
literal|"/tmp/vnXXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of temp file */
end_comment

begin_decl_stmt
specifier|static
name|long
name|artbody
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset of body into article */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quitflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, then quit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|erased
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current article has been erased */
end_comment

begin_decl_stmt
specifier|static
name|int
name|artlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in article body */
end_comment

begin_decl_stmt
specifier|static
name|int
name|artread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entire article has been read */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hdrstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beginning of header */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hdrend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of header */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastlin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines in tempfile */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tflinno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next line in tempfile */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxlinno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines in file + folded */
end_comment

begin_decl_stmt
specifier|static
name|char
name|secpr
index|[
name|SECPRLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secondary prompt */
end_comment

begin_decl_stmt
specifier|static
name|char
name|prompt
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompter */
end_comment

begin_decl_stmt
specifier|static
name|short
name|prflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print flags (controls updscr) */
end_comment

begin_decl_stmt
specifier|static
name|short
name|curflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to locate cursor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dlinno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top line on screen */
end_comment

begin_decl_stmt
specifier|static
name|char
name|timestr
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ismail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if user has mail */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mailf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user's mail file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if unprocessed alarm signal */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if at end of article */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* erase character */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ckill
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kill character */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cintr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interrupt character */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGLTC
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|cwerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* word erase character */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGLTC */
end_comment

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal speed NOT STATIC */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if interrupt received */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|reading
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to keep stupid BSD from restarting reads */
end_comment

begin_decl_stmt
name|jmp_buf
name|intjmp
decl_stmt|,
name|alrmjmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGTSTP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MYDB
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|hasdb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if article data base exists */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MYDB */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIGPAGE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|endsuba
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of sub-article in digest */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MYDEBUG
end_ifdef

begin_decl_stmt
name|FILE
modifier|*
name|debugf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to write debugging info on */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|tft
init|=
literal|"/tmp/folXXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These were made static for u370 with its buggy cc.  * I judged it better to have one copy with no ifdefs than  * to conditionally compile them as automatic variables  * in readr (which they originally were).  Performance  * considerations might warrant moving some of the simple  * things into register variables, but I don't know what  * breaks the u370 cc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|goodone
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last decent article		*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SERVER */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ogroupdir
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last groupdir		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|edcmdbuf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rfq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for last article		*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|ongsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous ngsize		*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|pngsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printing ngsize		*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp pointer.		*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary file name 		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|ofilename1
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous file name		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|hbuf1
decl_stmt|,
name|hbuf2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for minusing			*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hbuf
modifier|*
name|h
init|=
operator|&
name|hbuf1
decl_stmt|,
comment|/* current header		*/
modifier|*
name|hold
init|=
operator|&
name|hbuf2
decl_stmt|,
comment|/* previous header		*/
modifier|*
name|hptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary			*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|ptr3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for reply manipulation	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|aabs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we asked absolutely	*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ed
decl_stmt|,
name|tf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|oobit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last bit, really		*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|dgest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current article to be printed*/
end_comment

begin_macro
name|readr
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MYDEBUG
name|debugf
operator|=
name|fopen
argument_list|(
literal|"DEBUG"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|debugf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aflag
condition|)
block|{
if|if
condition|(
operator|*
name|datebuf
condition|)
block|{
if|if
condition|(
operator|(
name|atime
operator|=
name|cgtdate
argument_list|(
name|datebuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Cannot parse date string"
argument_list|)
expr_stmt|;
block|}
else|else
name|atime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SigTrap
condition|)
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|tfname
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfp
operator|=
name|fopen
argument_list|(
name|tfname
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't create temp file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
name|mailf
operator|=
name|getmailname
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MYDB
if|if
condition|(
name|opendb
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|hasdb
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"Using article data base\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/*DEBUG*/
name|getng
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|ttysave
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|xxit
argument_list|)
expr_stmt|;
if|if
condition|(
name|SigTrap
condition|)
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ttyraw
argument_list|()
expr_stmt|;
name|timer
argument_list|()
expr_stmt|;
comment|/* loop reading articles. */
name|fp
operator|=
name|NULL
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|nextng
argument_list|()
expr_stmt|;
name|quitflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|quitflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|getnextart
argument_list|(
name|FALSE
argument_list|)
condition|)
break|break;
ifndef|#
directive|ifndef
name|SERVER
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|goodone
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
if|if
condition|(
name|SigTrap
condition|)
return|return;
name|vcmd
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|news
condition|)
block|{
name|ttycooked
argument_list|()
expr_stmt|;
name|ospeed
operator|=
literal|0
expr_stmt|;
comment|/* to convince xxit() not to clear screen */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No news.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Read and execute a command.  */
end_comment

begin_macro
name|vcmd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|countset
decl_stmt|;
if|if
condition|(
name|prflags
operator|&
name|HDRONLY
condition|)
name|appfile
argument_list|(
name|fp
argument_list|,
name|lastlin
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|appfile
argument_list|(
name|fp
argument_list|,
name|dlinno
operator|+
name|ARTWLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIGPAGE
name|endsuba
operator|=
name|findend
argument_list|(
name|dlinno
argument_list|)
expr_stmt|;
if|if
condition|(
name|artlines
operator|>
name|dlinno
operator|+
name|ARTWLEN
operator|||
name|endsuba
operator|>
literal|0
operator|&&
name|endsuba
operator|<
name|artlines
else|#
directive|else
if|if
condition|(
name|artlines
operator|>
name|dlinno
operator|+
name|ARTWLEN
endif|#
directive|endif
operator|||
operator|(
name|prflags
operator|&
name|HDRONLY
operator|)
operator|&&
name|artlines
operator|>
name|hdrend
condition|)
block|{
name|atend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prflags
operator|&
name|HDRONLY
operator|||
name|maxlinno
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prompt
argument_list|,
literal|"more? "
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|DIGPAGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"more(%d%%)? "
argument_list|,
operator|(
operator|(
operator|(
operator|(
name|endsuba
operator|>
literal|0
operator|)
condition|?
name|endsuba
else|:
operator|(
name|dlinno
operator|+
name|ARTWLEN
operator|)
operator|)
operator|-
name|hdrend
operator|)
operator|*
literal|100
operator|)
operator|/
name|maxlinno
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DIGPAGE */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"more(%d%%)? "
argument_list|,
operator|(
operator|(
name|dlinno
operator|+
name|ARTWLEN
operator|-
name|hdrend
operator|)
operator|*
literal|100
operator|)
operator|/
name|maxlinno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DIGPAGE */
block|}
else|else
block|{
name|atend
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prompt
argument_list|,
literal|"next? "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erased
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
comment|/* article read */
block|}
name|curflag
operator|=
name|CURP1
expr_stmt|;
name|p
operator|=
name|prompt
operator|+
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|countset
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop while accumulating a count, until an action character 	 * is entered. Also handle "meta" here. 	 * 	 * Count is the current count. Countset=0 means no count 	 * currently exists. Countset=1, count=0 is valid and means  	 * a count of 0 has been entered  	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|vgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|cerase
operator|||
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|'\177'
condition|)
block|{
if|if
condition|(
name|countset
operator|==
literal|0
condition|)
break|break;
comment|/* Use as action char */
if|if
condition|(
name|count
operator|<
literal|10
condition|)
name|countset
operator|=
literal|0
expr_stmt|;
comment|/* Erase only char of count */
else|else
name|count
operator|/=
literal|10L
expr_stmt|;
comment|/* Erase 1 char of count */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TIOCGLTC
if|if
condition|(
name|c
operator|==
name|ckill
operator|||
name|c
operator|==
name|cwerase
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|c
operator|==
name|ckill
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|countset
operator|==
literal|0
condition|)
break|break;
name|countset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
condition|)
break|break;
else|else
block|{
name|countset
operator|=
literal|1
expr_stmt|;
name|count
operator|=
operator|(
name|count
operator|*
literal|10
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|countset
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%ld"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\033'
condition|)
block|{
comment|/* escape */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|prompt
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|c
operator|=
name|vgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|cintr
condition|)
name|c
operator||=
name|META
expr_stmt|;
block|}
name|secpr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|countset
operator|==
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|docmd
argument_list|(
name|c
argument_list|,
name|count
argument_list|,
name|countset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'?'
operator|&&
name|c
operator|!=
literal|'H'
condition|)
comment|/* UGGH */
name|prflags
operator|&=
operator|~
name|HELPMSG
expr_stmt|;
if|if
condition|(
name|dlinno
operator|>
name|hdrstart
condition|)
name|prflags
operator|&=
operator|~
name|HDRONLY
expr_stmt|;
block|}
comment|/*  * Process one command, which has already been typed in.  */
name|docmd
argument_list|(
argument|c
argument_list|,
argument|count
argument_list|,
argument|countset
argument_list|)
name|int
name|c
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|countset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|long
name|nart
decl_stmt|,
name|Hoffset
decl_stmt|;
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* display list of articles in current group */
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|botscreen
argument_list|()
expr_stmt|;
name|ttycooked
argument_list|()
expr_stmt|;
name|list_group
argument_list|(
name|groupdir
argument_list|,
name|countset
condition|?
operator|(
name|int
operator|)
name|count
else|:
literal|0
argument_list|,
operator|(
name|c
operator|==
literal|'l'
operator|)
condition|?
name|FALSE
else|:
name|TRUE
argument_list|,
name|pngsize
argument_list|)
expr_stmt|;
name|ttyraw
argument_list|()
expr_stmt|;
name|okclear
argument_list|()
expr_stmt|;
name|updscr
argument_list|()
expr_stmt|;
break|break;
comment|/* Show more of current article, or advance to next article */
case|case
literal|'\n'
case|:
case|case
literal|' '
case|:
ifdef|#
directive|ifdef
name|DIGPAGE
case|case
literal|'m'
case|:
endif|#
directive|endif
comment|/* DIGPAGE */
case|case
literal|'\06'
case|:
comment|/* Control-F for vi compat */
name|prflags
operator|&=
operator|~
name|NOPRT
expr_stmt|;
if|if
condition|(
name|atend
condition|)
goto|goto
name|next
goto|;
elseif|else
if|if
condition|(
name|prflags
operator|&
name|HDRONLY
condition|)
block|{
name|prflags
operator|&=
operator|~
name|HDRONLY
expr_stmt|;
if|if
condition|(
name|hasscroll
condition|)
name|dlinno
operator|=
name|hdrstart
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIGPAGE
elseif|else
if|if
condition|(
name|endsuba
operator|>
literal|0
condition|)
name|dlinno
operator|=
name|endsuba
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|lastlin
operator|>=
name|maxlinno
condition|)
goto|goto
name|next
goto|;
else|else
name|appfile
argument_list|(
name|fp
argument_list|,
name|lastlin
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|STRNCMP
argument_list|(
name|linebuf
argument_list|,
literal|"------------------------"
argument_list|,
literal|24
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|dlinno
operator|=
name|endsuba
operator|=
name|lastlin
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
name|appfile
argument_list|(
name|fp
argument_list|,
name|dlinno
operator|+
literal|2
operator|*
name|ARTWLEN
argument_list|)
operator|,
name|artread
operator|)
operator|&&
name|hasscroll
operator|&&
name|artlines
operator|-
name|dlinno
operator|<=
name|ARTWLEN
operator|+
literal|2
condition|)
name|dlinno
operator|=
name|artlines
operator|-
name|ARTWLEN
expr_stmt|;
else|else
name|dlinno
operator|+=
name|ARTWLEN
operator|*
name|count
expr_stmt|;
break|break;
comment|/* No.  Go on to next article. */
case|case
literal|'.'
case|:
comment|/* useful if you have a keypad */
name|next
label|:
case|case
literal|'n'
case|:
name|readmode
operator|=
name|NEXT
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* Back up count pages */
case|case
literal|'\b'
case|:
case|case
literal|'\177'
case|:
if|if
condition|(
name|dlinno
operator|==
literal|0
condition|)
goto|goto
name|backupone
goto|;
comment|/* NO BREAK */
case|case
name|META
operator||
literal|'v'
case|:
case|case
literal|'\002'
case|:
comment|/* Control-B */
name|dlinno
operator|-=
name|ARTWLEN
operator|*
name|count
expr_stmt|;
if|if
condition|(
name|dlinno
operator|<
literal|0
condition|)
name|dlinno
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* forward half a page */
case|case
literal|'\004'
case|:
comment|/* Control-D, as in vi */
if|if
condition|(
operator|!
name|atend
condition|)
name|dlinno
operator|+=
name|ARTWLEN
operator|/
literal|2
operator|*
name|count
expr_stmt|;
break|break;
comment|/* backward half a page */
case|case
literal|'\025'
case|:
comment|/* Control-U */
name|dlinno
operator|-=
name|ARTWLEN
operator|/
literal|2
operator|*
name|count
expr_stmt|;
if|if
condition|(
name|dlinno
operator|<
literal|0
condition|)
name|dlinno
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* forward count lines */
case|case
literal|'\016'
case|:
comment|/* Control-N */
case|case
literal|'\005'
case|:
comment|/* Control-E */
name|dlinno
operator|+=
name|count
expr_stmt|;
break|break;
comment|/* backwards count lines */
case|case
literal|'\020'
case|:
comment|/* Control-P */
case|case
literal|'\031'
case|:
comment|/* Control-Y */
name|dlinno
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|dlinno
operator|<
literal|0
condition|)
name|dlinno
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Turn displaying of article back on */
case|case
literal|'d'
case|:
name|prflags
operator|&=
operator|~
name|NOPRT
expr_stmt|;
break|break;
comment|/* display header */
case|case
literal|'h'
case|:
name|dlinno
operator|=
name|hdrstart
expr_stmt|;
name|prflags
operator||=
name|HDRONLY
expr_stmt|;
name|prflags
operator|&=
operator|~
name|NOPRT
expr_stmt|;
break|break;
comment|/* 	 * Unsubscribe to the newsgroup and go on to next group 	 */
case|case
literal|'U'
case|:
case|case
literal|'u'
case|:
name|strcat
argument_list|(
name|prompt
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
name|c
operator|=
name|vgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
block|{
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|zapng
operator|=
name|TRUE
expr_stmt|;
name|saveart
expr_stmt|;
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
name|msg
argument_list|(
literal|"Can't back up."
argument_list|)
expr_stmt|;
else|else
name|quitflg
operator|=
literal|1
expr_stmt|;
comment|/* probably unnecessary */
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
name|cintr
operator|&&
name|c
operator|!=
name|ckill
condition|)
name|beep
argument_list|()
expr_stmt|;
name|msg
argument_list|(
literal|"Illegal command"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Print the current version of news */
case|case
literal|'v'
case|:
name|msg
argument_list|(
literal|"News version: %s"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
break|break;
comment|/* Decrypt joke.  Always does rot 13 */
case|case
literal|'D'
case|:
name|appfile
argument_list|(
name|fp
argument_list|,
literal|32767
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hdrend
init|;
name|i
operator|<
name|artlines
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
name|ch
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|tfget
argument_list|(
name|linebuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|linebuf
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
condition|)
operator|*
name|p
operator|=
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|13
operator|)
operator|%
literal|26
operator|+
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
condition|)
operator|*
name|p
operator|=
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|13
operator|)
operator|%
literal|26
operator|+
literal|'A'
expr_stmt|;
block|}
name|tfput
argument_list|(
name|linebuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|prflags
operator||=
name|NEWART
expr_stmt|;
name|prflags
operator|&=
operator|~
operator|(
name|HDRONLY
operator||
name|NOPRT
operator|)
expr_stmt|;
break|break;
comment|/* write out the article someplace */
comment|/* w writes out without the header */
comment|/* | defaults to pipeing */
block|{
specifier|static
name|char
name|savebuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|int
name|wflags
decl_stmt|;
case|case
name|PIPECHAR
case|:
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
comment|/* We loop back to here each time user types ^U to prompt */
do|do
block|{
comment|/* Prompt based on command char */
name|msg
argument_list|(
operator|(
name|c
operator|==
name|PIPECHAR
operator|)
condition|?
literal|"|"
else|:
literal|"file: "
argument_list|)
expr_stmt|;
name|curflag
operator|=
name|CURP2
expr_stmt|;
while|while
condition|(
operator|(
name|wflags
operator|=
name|vgetc
argument_list|()
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
name|wflags
operator|==
name|cintr
condition|)
block|{
name|secpr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wflags
operator|!=
name|CAGAIN
condition|)
block|{
if|if
condition|(
operator|(
name|wflags
operator|&
literal|0x1F
operator|)
operator|==
name|wflags
condition|)
block|{
comment|/* control char */
name|pushback
argument_list|(
name|wflags
argument_list|)
expr_stmt|;
name|savebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
name|PIPECHAR
condition|)
block|{
name|savebuf
index|[
literal|0
index|]
operator|=
name|PIPECHAR
expr_stmt|;
name|savebuf
index|[
literal|1
index|]
operator|=
name|wflags
expr_stmt|;
name|savebuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|savebuf
index|[
literal|0
index|]
operator|=
name|wflags
expr_stmt|;
name|savebuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* don't let them pipe to a saved filename */
if|if
condition|(
name|c
operator|==
name|PIPECHAR
operator|&&
name|savebuf
index|[
literal|0
index|]
operator|!=
name|PIPECHAR
condition|)
block|{
name|savebuf
index|[
literal|0
index|]
operator|=
name|PIPECHAR
expr_stmt|;
name|savebuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|wflags
operator|=
name|prget
argument_list|(
operator|(
name|savebuf
index|[
literal|0
index|]
operator|==
name|PIPECHAR
operator|)
condition|?
literal|""
else|:
literal|"file: "
argument_list|,
name|savebuf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wflags
operator|==
literal|2
condition|)
do|;
if|if
condition|(
name|wflags
condition|)
break|break;
comment|/* Interrupted out */
name|wflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PIPECHAR
condition|)
name|c
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
name|wflags
operator||=
name|SVHEAD
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|wflags
operator||=
name|OVWRITE
expr_stmt|;
name|bptr
operator|=
name|savebuf
expr_stmt|;
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
condition|)
name|bptr
operator|++
expr_stmt|;
comment|/* strip leading spaces */
if|if
condition|(
operator|*
name|bptr
operator|!=
name|PIPECHAR
operator|&&
operator|*
name|bptr
operator|!=
literal|'/'
condition|)
block|{
name|char
name|hetyped
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|boxptr
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hetyped
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hetyped
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|hetyped
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|hetyped
argument_list|,
name|bptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|userhome
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boxptr
operator|=
name|getenv
argument_list|(
literal|"NEWSBOX"
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|boxptr
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|struct
name|stat
name|stbf
decl_stmt|;
name|sprintf
argument_list|(
name|bptr
argument_list|,
name|boxptr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bptr
argument_list|,
operator|&
name|stbf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|bptr
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Cannot create directory %s"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|stbf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|msg
argument_list|(
literal|"%s not a directory"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|boxptr
argument_list|)
expr_stmt|;
block|}
else|else
name|bptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bptr
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hetyped
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
name|hetyped
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"Articles"
argument_list|)
expr_stmt|;
block|}
comment|/* handle ~/ for pipes */
if|if
condition|(
operator|*
name|bptr
operator|==
name|PIPECHAR
condition|)
block|{
name|char
name|fullname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|bptr
operator|++
expr_stmt|;
comment|/* skip PIPECHAR */
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
condition|)
name|bptr
operator|++
expr_stmt|;
comment|/* strip leading spaces */
if|if
condition|(
name|bptr
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|bptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|userhome
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname
argument_list|,
name|bptr
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
comment|/* we know PIPECHAR is in *savebuf */
name|strcpy
argument_list|(
name|savebuf
operator|+
literal|1
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|bptr
operator|=
name|savebuf
expr_stmt|;
block|}
name|vsave
argument_list|(
name|bptr
argument_list|,
name|wflags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* back up  */
case|case
literal|'-'
case|:
name|caseminus
label|:
name|aabs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ofilename1
condition|)
block|{
name|msg
argument_list|(
literal|"Can't back up."
argument_list|)
expr_stmt|;
break|break;
block|}
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hptr
operator|=
name|h
expr_stmt|;
name|h
operator|=
name|hold
expr_stmt|;
name|hold
operator|=
name|hptr
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|ofilename1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ofilename1
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|obit
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|STRCMP
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
block|}
name|bit
operator|=
name|oobit
expr_stmt|;
name|oobit
operator|=
name|obit
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|getnextart
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
comment|/* skip forwards */
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
name|caseplus
label|:
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|saveart
expr_stmt|;
name|last
operator|=
name|bit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|nextbit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bit
operator|>
name|pngsize
operator|)
operator|||
operator|(
name|rflag
operator|&&
name|bit
operator|<
literal|1
operator|)
condition|)
break|break;
block|}
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* exit - time updated to that of most recently read article */
case|case
literal|'q'
case|:
name|quitflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* cancel the article. */
case|case
literal|'c'
case|:
name|strcpy
argument_list|(
name|prompt
argument_list|,
literal|"cancel [n]? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|vgetc
argument_list|()
operator|!=
literal|'y'
condition|)
block|{
name|msg
argument_list|(
literal|"Article not cancelled"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cancel_command
argument_list|()
expr_stmt|;
break|break;
comment|/* escape to shell */
case|case
literal|'!'
case|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|p
operator|=
name|linebuf
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prget
argument_list|(
literal|"!"
argument_list|,
name|p
argument_list|)
condition|)
break|break;
name|flags
operator|=
name|CWAIT
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|SHELL
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|linebuf
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'&'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|flags
operator|=
name|BKGRND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|PIPECHAR
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"(%s)%cmail '%s'"
argument_list|,
name|linebuf
argument_list|,
name|PIPECHAR
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|flags
operator||=
name|BKGRND
expr_stmt|;
block|}
else|else
block|{
name|prflags
operator||=
name|NOPRT
expr_stmt|;
block|}
name|shcmd
argument_list|(
name|linebuf
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* mail reply */
case|case
literal|'r'
case|:
name|reply
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|reply
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|META
operator||
literal|'r'
case|:
name|direct_reply
argument_list|()
expr_stmt|;
break|break;
comment|/* next newsgroup */
case|case
literal|'N'
case|:
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_ng_command
argument_list|()
condition|)
name|quitflg
operator|=
literal|1
expr_stmt|;
break|break;
comment|/*  mark the rest of the articles in this group as read */
case|case
literal|'K'
case|:
name|saveart
expr_stmt|;
while|while
condition|(
name|bit
operator|<=
name|ngsize
operator|&&
name|bit
operator|>=
name|minartno
condition|)
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
comment|/* Print the full header */
case|case
literal|'H'
case|:
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"No current article"
argument_list|)
expr_stmt|;
break|break;
block|}
name|move
argument_list|(
name|ARTWIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Hoffset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARTWLEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
name|COLS
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
break|break;
name|linebuf
index|[
name|COLS
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addstr
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|Hoffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|ARTWLEN
condition|;
name|i
operator|++
control|)
name|addstr
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|prflags
operator||=
name|HELPMSG
operator||
name|NEWART
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* backup 1 article */
name|backupone
label|:
name|count
operator|=
name|bit
operator|-
literal|1
expr_stmt|;
comment|/* NO BREAK */
case|case
literal|'A'
case|:
comment|/* specific number */
if|if
condition|(
name|count
operator|>
name|pngsize
condition|)
block|{
name|msg
argument_list|(
literal|"not that many articles"
argument_list|)
expr_stmt|;
break|break;
block|}
name|readmode
operator|=
name|SPEC
expr_stmt|;
name|aabs
operator|=
name|TRUE
expr_stmt|;
name|bit
operator|=
name|count
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
comment|/* display parent article */
case|case
literal|'p'
case|:
ifdef|#
directive|ifdef
name|MYDB
if|if
condition|(
name|hasdb
operator|&&
operator|(
name|ptr3
operator|=
name|findparent
argument_list|(
name|h
operator|->
name|ident
argument_list|,
operator|&
name|nart
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"parent: %s/%ld"
argument_list|,
name|ptr3
argument_list|,
name|nart
argument_list|)
expr_stmt|;
comment|/*DEBUG*/
name|updscr
argument_list|()
expr_stmt|;
comment|/*DEBUG*/
goto|goto
name|selectart
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|h
operator|->
name|followid
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|msg
argument_list|(
literal|"no references line"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr1
operator|=
name|h
operator|->
name|followid
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|followid
argument_list|)
expr_stmt|;
do|do
block|{
name|ptr2
operator|=
name|ptr1
expr_stmt|;
if|if
condition|(
operator|*
name|ptr2
operator|==
literal|'\0'
condition|)
name|ptr1
operator|=
name|rindex
argument_list|(
name|h
operator|->
name|followid
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|ptr2
operator|=
literal|'\0'
expr_stmt|;
name|ptr1
operator|=
name|rindex
argument_list|(
name|h
operator|->
name|followid
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|*
name|ptr2
operator|=
literal|' '
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ptr1
operator|!=
name|NULL
operator|&&
operator|--
name|count
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|ptr1
operator|==
name|NULL
condition|)
name|ptr1
operator|=
name|h
operator|->
name|followid
expr_stmt|;
else|else
operator|++
name|ptr1
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|linebuf
argument_list|,
name|ptr1
argument_list|,
name|ptr2
operator|-
name|ptr1
argument_list|)
expr_stmt|;
name|linebuf
index|[
name|ptr2
operator|-
name|ptr1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|msg
argument_list|(
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|curflag
operator|=
name|CURP2
expr_stmt|;
name|updscr
argument_list|()
expr_stmt|;
comment|/* may take this out later */
goto|goto
name|searchid
goto|;
comment|/* specific message ID. */
case|case
literal|'<'
case|:
comment|/* could improve this */
name|linebuf
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
name|linebuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prget
argument_list|(
literal|""
argument_list|,
name|linebuf
argument_list|)
condition|)
block|{
name|secpr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|searchid
label|:
name|secpr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|linebuf
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|&&
name|index
argument_list|(
name|linebuf
argument_list|,
literal|'>'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ptr1
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
operator|*
name|ptr1
operator|==
literal|'<'
condition|)
name|ptr1
operator|++
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
name|ptr1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr2
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr2
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"<%s@%s.UUCP>"
argument_list|,
name|ptr2
argument_list|,
name|ptr1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
argument_list|(
name|linebuf
argument_list|,
literal|'>'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|linebuf
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|ptr1
operator|=
name|findhist
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr1
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"%s not found"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr2
operator|=
name|index
argument_list|(
name|ptr1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|ptr3
operator|=
name|index
argument_list|(
operator|++
name|ptr2
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
operator|++
name|ptr3
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr2
condition|)
operator|*
name|ptr2
operator|=
literal|'\0'
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
name|ptr3
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr2
condition|)
block|{
if|if
condition|(
name|STRCMP
argument_list|(
name|ptr3
argument_list|,
literal|"cancelled"
argument_list|)
operator|==
literal|0
condition|)
name|msg
argument_list|(
literal|"%s has been cancelled"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"%s has expired"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|ptr2
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|ptr2
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|nart
argument_list|)
expr_stmt|;
comment|/* 		 * Go to a given article.  Ptr3 specifies the newsgroup 		 * and nart specifies the article number. 		 */
ifdef|#
directive|ifdef
name|MYDB
name|selectart
label|:
endif|#
directive|endif
comment|/* MYDB */
name|aabs
operator|=
name|TRUE
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|ptr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRCMP
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|,
name|TRUE
argument_list|,
name|PERHAPS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
block|}
name|bit
operator|=
name|nart
expr_stmt|;
name|oobit
operator|=
name|obit
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|getnextart
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|!=
name|nart
operator|||
name|STRCMP
argument_list|(
name|groupdir
argument_list|,
name|ptr3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"can't read %s/%ld"
argument_list|,
name|ptr3
argument_list|,
name|nart
argument_list|)
expr_stmt|;
goto|goto
name|caseminus
goto|;
block|}
name|rfq
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* follow-up article */
case|case
literal|'f'
case|:
if|if
condition|(
name|STRCMP
argument_list|(
name|h
operator|->
name|followto
argument_list|,
literal|"poster"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reply
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SERVER
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|BIN
argument_list|,
literal|"postnews"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SERVER */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s %s"
argument_list|,
name|BIN
argument_list|,
literal|"postnews"
argument_list|,
name|goodone
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
name|shcmd
argument_list|(
name|bfr
argument_list|,
name|CWAIT
argument_list|)
expr_stmt|;
break|break;
comment|/* erase - pretend we haven't seen this article. */
case|case
literal|'e'
case|:
name|erased
operator|=
literal|1
expr_stmt|;
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
goto|goto
name|caseplus
goto|;
comment|/* skip this article for now */
case|case
literal|'#'
case|:
name|msg
argument_list|(
literal|"Article %ld of %ld"
argument_list|,
name|rfq
condition|?
name|oobit
else|:
name|bit
argument_list|,
name|pngsize
argument_list|)
expr_stmt|;
break|break;
comment|/* error */
case|case
literal|'?'
case|:
block|{
name|FILE
modifier|*
name|helpf
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"%s/vnews.help"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|helpf
operator|=
name|fopen
argument_list|(
name|linebuf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"Can't open help file"
argument_list|)
expr_stmt|;
break|break;
block|}
name|move
argument_list|(
name|ARTWIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
name|LBUFLEN
argument_list|,
name|helpf
argument_list|)
operator|!=
name|NULL
condition|)
name|addstr
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|helpf
argument_list|)
expr_stmt|;
name|prflags
operator||=
name|HELPMSG
operator||
name|NEWART
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|c
operator|!=
name|ckill
operator|&&
name|c
operator|!=
name|cintr
operator|&&
name|c
operator|!=
name|cerase
condition|)
ifdef|#
directive|ifdef
name|TIOCGLTC
if|if
condition|(
name|c
operator|!=
name|cwerase
condition|)
endif|#
directive|endif
block|{
name|beep
argument_list|()
expr_stmt|;
name|msg
argument_list|(
literal|"Illegal command"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|cancel_command
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|poster
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|notauthor
decl_stmt|;
name|char
modifier|*
name|senderof
parameter_list|()
function_decl|;
name|poster
operator|=
name|senderof
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* only compare up to '.' or ' ' */
name|r
operator|=
name|index
argument_list|(
name|poster
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|r
operator|=
name|index
argument_list|(
name|poster
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|tfilename
operator|=
name|filename
expr_stmt|;
name|notauthor
operator|=
name|STRCMP
argument_list|(
name|username
argument_list|,
name|poster
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|ROOTID
operator|&&
name|uid
operator|&&
name|notauthor
condition|)
block|{
name|msg
argument_list|(
literal|"Can't cancel what you didn't write."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|cancel
argument_list|(
name|stderr
argument_list|,
name|h
argument_list|,
name|notauthor
argument_list|)
condition|)
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*  * Generate replies  */
name|reply
argument_list|(
argument|include
argument_list|)
name|int
name|include
decl_stmt|;
block|{
name|char
modifier|*
name|arg
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|char
name|subj
index|[
literal|132
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
name|struct
name|stat
name|statb
decl_stmt|;
name|time_t
name|creatm
decl_stmt|;
comment|/* Put the user in the editor to create the body of the reply. */
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
operator|||
operator|*
name|ed
operator|==
literal|'\0'
condition|)
name|ed
operator|=
name|DFTEDITOR
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"You don't have an editor"
argument_list|)
expr_stmt|;
return|return;
block|}
name|arg
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tf
argument_list|,
name|tft
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|tf
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfp
operator|=
name|fopen
argument_list|(
name|tf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"Can't create %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|subj
argument_list|,
name|h
operator|->
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|subj
argument_list|,
literal|"Re:"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|subj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|subj
argument_list|,
literal|"Re: %s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|replyname
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rfp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rfp
argument_list|,
literal|"In-reply-to: your article %s\n"
argument_list|,
name|h
operator|->
name|ident
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|fprintf
argument_list|(
name|rfp
argument_list|,
literal|"News-Path: %s\n"
argument_list|,
name|h
operator|->
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INTERNET */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s -t< %s; rm -f %s"
argument_list|,
name|MAILPARSER
argument_list|,
name|tf
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|include
condition|)
block|{
name|FILE
modifier|*
name|of
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SERVER
name|of
operator|=
name|xart_open
argument_list|(
name|goodone
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|of
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
break|break;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|of
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|rfp
argument_list|,
literal|"> %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
block|}
name|fflush
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|fileno
argument_list|(
name|rfp
argument_list|)
argument_list|,
operator|&
name|statb
argument_list|)
expr_stmt|;
name|creatm
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|edcmdbuf
argument_list|,
literal|"exec %s %s"
argument_list|,
name|ed
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|edcmdbuf
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prun
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Couldn't run editor"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|access
argument_list|(
name|tf
argument_list|,
literal|4
argument_list|)
operator|||
name|stat
argument_list|(
name|tf
argument_list|,
operator|&
name|statb
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"No input file - mail not sent"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|statb
operator|.
name|st_mtime
operator|==
name|creatm
operator|||
name|statb
operator|.
name|st_size
operator|<
literal|5
condition|)
block|{
name|msg
argument_list|(
literal|"File unchanged - no message posted"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
return|return;
block|}
name|arg
index|[
literal|2
index|]
operator|=
name|rcbuf
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|prun
argument_list|(
name|arg
argument_list|,
name|BKGRND
argument_list|)
expr_stmt|;
name|prflags
operator||=
name|NOPRT
expr_stmt|;
block|}
name|direct_reply
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|arg
index|[
literal|4
index|]
decl_stmt|;
name|char
name|address
index|[
name|PATHLEN
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|arg
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
name|p
operator|=
name|replyname
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|q
operator|=
name|address
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"\"\\$"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|MAILER
operator|=
name|getenv
argument_list|(
literal|"MAILER"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|MAILER
operator|=
literal|"mail"
expr_stmt|;
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
name|MAILER
argument_list|,
name|hptr
operator|->
name|title
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s %s"
argument_list|,
name|rcbuf
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|bfr
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prun
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Couldn't run mailer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|prflags
operator||=
name|NOPRT
expr_stmt|;
block|}
name|next_ng_command
argument_list|()
block|{
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prget
argument_list|(
literal|"group? "
argument_list|,
name|linebuf
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bptr
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bptr
operator|||
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|bptr
condition|)
name|actdirect
operator|=
name|BACKWARD
expr_stmt|;
name|saveart
expr_stmt|;
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
name|msg
argument_list|(
literal|"Can't back up."
argument_list|)
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bptr
argument_list|)
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|validng
argument_list|(
name|bptr
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"No such group."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|saveart
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
name|selectng
argument_list|(
name|bptr
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*  * Find the next article we want to consider, if we're done with  * the last one, and show the header.  */
name|getnextart
argument_list|(
argument|minus
argument_list|)
name|int
name|minus
decl_stmt|;
block|{
name|int
name|noaccess
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER
name|char
name|workspace
index|[
literal|256
index|]
decl_stmt|;
else|#
directive|else
comment|/* !SERVER */
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dir
decl_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
name|long
name|nextnum
decl_stmt|,
name|tnum
decl_stmt|;
name|long
name|atol
parameter_list|()
function_decl|;
name|noaccess
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|minus
condition|)
goto|goto
name|nextart2
goto|;
comment|/* Kludge for "-" command. */
if|if
condition|(
name|bit
operator|==
name|obit
condition|)
comment|/* Return if still on same article as last time */
return|return
literal|0
return|;
name|nextart
label|:
if|if
condition|(
name|news
condition|)
block|{
name|curflag
operator|=
name|CURHOME
expr_stmt|;
name|_amove
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
block|}
name|dgest
operator|=
literal|0
expr_stmt|;
comment|/* If done with this newsgroup, find the next one. */
while|while
condition|(
name|ngsize
operator|<=
literal|0
operator|||
operator|(
operator|!
name|rflag
operator|&&
operator|(
operator|(
name|long
operator|)
name|bit
operator|>
name|ngsize
operator|)
operator|)
operator|||
operator|(
name|rflag
operator|&&
name|bit
operator|<
name|minartno
operator|)
condition|)
block|{
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
block|{
name|msg
argument_list|(
literal|"Can't back up."
argument_list|)
expr_stmt|;
name|actdirect
operator|=
name|FORWARD
expr_stmt|;
continue|continue;
block|}
else|else
comment|/* if (rfq++ || pflag || cflag) */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rflag
condition|)
name|bit
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
else|else
name|bit
operator|=
operator|-
literal|1
expr_stmt|;
name|noaccess
operator|=
literal|2
expr_stmt|;
block|}
comment|/* speed things up by not searching for article -1 */
if|if
condition|(
name|bit
operator|<
literal|0
condition|)
block|{
name|bit
operator|=
name|minartno
operator|-
literal|1
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|aabs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
name|nextart2
label|:
if|if
condition|(
name|rcreadok
condition|)
name|rcreadok
operator|=
literal|2
expr_stmt|;
comment|/* have seen>= 1 article */
ifdef|#
directive|ifdef
name|SERVER
if|if
condition|(
operator|(
name|fp
operator|=
name|getarticle
argument_list|(
name|groupdir
argument_list|,
name|bit
argument_list|,
literal|"ARTICLE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|badart
goto|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|article_name
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* !SERVER */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%ld"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfq
operator|&&
name|goodone
index|[
literal|0
index|]
condition|)
comment|/* ??? */
name|strcpy
argument_list|(
name|filename
argument_list|,
name|goodone
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
if|if
condition|(
name|SigTrap
operator|==
name|SIGHUP
condition|)
return|return
literal|1
return|;
comment|/* Decide if we want to show this article. */
if|if
condition|(
operator|(
name|fp
operator|=
name|art_open
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* since there can be holes in legal article numbers, */
comment|/* we wait till we hit 5 consecutive bad articles */
comment|/* before we haul off and scan the directory */
if|if
condition|(
operator|++
name|noaccess
operator|<
literal|5
condition|)
goto|goto
name|badart
goto|;
name|noaccess
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
if|if
condition|(
operator|*
name|groupdir
operator|==
literal|' '
operator|||
operator|*
name|groupdir
operator|==
literal|'\0'
operator|||
name|set_group
argument_list|(
name|groupdir
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|nextart
goto|;
else|#
directive|else
comment|/* !SERVER */
name|dirp
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EACCES
condition|)
name|msg
argument_list|(
literal|"Can't open %s"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
endif|#
directive|endif
comment|/* !SERVER */
name|nextnum
operator|=
name|rflag
condition|?
name|minartno
operator|-
literal|1
else|:
name|ngsize
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
name|tnum
operator|=
name|nextnum
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"STAT %ld"
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|workspace
argument_list|,
sizeof|sizeof
argument_list|(
name|workspace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|workspace
operator|!=
name|CHAR_OK
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
name|tnum
operator|++
expr_stmt|;
else|else
name|tnum
operator|--
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
comment|/* !SERVER */
while|while
condition|(
operator|(
name|dir
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|->
name|d_ino
condition|)
continue|continue;
name|tnum
operator|=
name|atol
argument_list|(
name|dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnum
operator|<=
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* !SERVER */
if|if
condition|(
name|rflag
condition|?
operator|(
name|tnum
operator|>
name|nextnum
operator|&&
name|tnum
operator|<
name|bit
operator|)
else|:
operator|(
name|tnum
operator|<
name|nextnum
operator|&&
name|tnum
operator|>
name|bit
operator|)
condition|)
name|nextnum
operator|=
name|tnum
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
break|break;
comment|/* not exactly right */
endif|#
directive|endif
comment|/* SERVER */
block|}
ifndef|#
directive|ifndef
name|SERVER
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
if|if
condition|(
name|rflag
condition|?
operator|(
name|nextnum
operator|>=
name|bit
operator|)
else|:
operator|(
name|nextnum
operator|<=
name|bit
operator|)
condition|)
goto|goto
name|badart
goto|;
do|do
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|rflag
condition|?
operator|(
name|nextnum
operator|<
name|bit
operator|)
else|:
operator|(
name|nextnum
operator|>
name|bit
operator|)
condition|)
do|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|aabs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
else|else
name|noaccess
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
operator|||
operator|(
operator|!
name|rfq
operator|&&
operator|!
name|aselect
argument_list|(
name|h
argument_list|,
name|aabs
argument_list|)
operator|)
condition|)
block|{
name|badart
label|:
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|aabs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
name|aabs
operator|=
name|FALSE
expr_stmt|;
name|actdirect
operator|=
name|FORWARD
expr_stmt|;
name|news
operator|=
name|TRUE
expr_stmt|;
name|artbody
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fmthdr
argument_list|()
expr_stmt|;
name|artlines
operator|=
name|lastlin
expr_stmt|;
name|artread
operator|=
literal|0
expr_stmt|;
name|prflags
operator||=
name|NEWART
expr_stmt|;
name|prflags
operator|&=
operator|~
name|NOPRT
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
operator|&&
name|hdrend
operator|<
name|ARTWLEN
operator|&&
operator|!
name|cflag
condition|)
name|prflags
operator||=
name|HDRONLY
expr_stmt|;
name|dlinno
operator|=
literal|0
expr_stmt|;
name|maxlinno
operator|=
name|NLINES
argument_list|(
name|h
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|erased
operator|=
literal|0
expr_stmt|;
name|obit
operator|=
name|bit
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER */
return|return
literal|0
return|;
block|}
comment|/*  * Print out whatever the appropriate header is  */
name|fmthdr
argument_list|()
block|{
name|char
modifier|*
name|briefdate
parameter_list|()
function_decl|;
specifier|static
name|FILE
modifier|*
name|ngfd
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|triedopen
init|=
literal|0
decl_stmt|;
name|char
name|pbuf
index|[
name|BUFLEN
index|]
decl_stmt|,
modifier|*
name|printbuffer
init|=
name|groupdir
decl_stmt|;
name|lastlin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ngrp
condition|)
block|{
name|pngsize
operator|=
name|ngsize
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
condition|)
block|{
if|if
condition|(
operator|!
name|triedopen
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%s/newsgroups"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|ngfd
operator|=
name|fopen
argument_list|(
name|pbuf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|triedopen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ngfd
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|ibuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|rewind
argument_list|(
name|ngfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|ibuf
argument_list|,
name|BUFLEN
argument_list|,
name|ngfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|ibuf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|STRCMP
argument_list|(
name|ibuf
argument_list|,
name|groupdir
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|p
operator|=
name|q
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|q
operator|==
literal|'.'
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%s (%s)"
argument_list|,
name|groupdir
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printbuffer
operator|=
name|pbuf
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Newsgroup %s"
argument_list|,
name|printbuffer
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
block|}
name|hdrstart
operator|=
name|lastlin
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Article %s %s"
argument_list|,
name|h
operator|->
name|ident
argument_list|,
name|briefdate
argument_list|(
name|h
operator|->
name|subdate
argument_list|)
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
name|xtabs
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|vhprint
argument_list|(
name|h
argument_list|,
name|pflag
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"(%d lines)"
argument_list|,
name|NLINES
argument_list|(
name|h
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|hdrend
operator|=
name|lastlin
expr_stmt|;
block|}
comment|/*  * Grow tabs into spaces in header fields, 'cause the rest of this  * lax program drops turds all over tabs (so it does with \b's, but ..)  */
name|xtabs
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|p
expr_stmt|;
block|{
name|xtabf
argument_list|(
name|p
operator|->
name|from
argument_list|,
sizeof|sizeof
name|p
operator|->
name|from
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|path
argument_list|,
sizeof|sizeof
name|p
operator|->
name|path
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|nbuf
argument_list|,
sizeof|sizeof
name|p
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|title
argument_list|,
sizeof|sizeof
name|p
operator|->
name|title
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|ident
argument_list|,
sizeof|sizeof
name|p
operator|->
name|ident
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|replyto
argument_list|,
sizeof|sizeof
name|p
operator|->
name|replyto
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|followid
argument_list|,
sizeof|sizeof
name|p
operator|->
name|followid
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|subdate
argument_list|,
sizeof|sizeof
name|p
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|expdate
argument_list|,
sizeof|sizeof
name|p
operator|->
name|expdate
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|ctlmsg
argument_list|,
sizeof|sizeof
name|p
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|sender
argument_list|,
sizeof|sizeof
name|p
operator|->
name|sender
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|followto
argument_list|,
sizeof|sizeof
name|p
operator|->
name|followto
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|distribution
argument_list|,
sizeof|sizeof
name|p
operator|->
name|distribution
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|organization
argument_list|,
sizeof|sizeof
name|p
operator|->
name|organization
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|numlines
argument_list|,
sizeof|sizeof
name|p
operator|->
name|numlines
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|keywords
argument_list|,
sizeof|sizeof
name|p
operator|->
name|keywords
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|summary
argument_list|,
sizeof|sizeof
name|p
operator|->
name|summary
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|approved
argument_list|,
sizeof|sizeof
name|p
operator|->
name|approved
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|nf_id
argument_list|,
sizeof|sizeof
name|p
operator|->
name|nf_id
argument_list|)
expr_stmt|;
name|xtabf
argument_list|(
name|p
operator|->
name|nf_from
argument_list|,
sizeof|sizeof
name|p
operator|->
name|nf_from
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOXREFS
name|xtabf
argument_list|(
name|p
operator|->
name|xref
argument_list|,
sizeof|sizeof
name|p
operator|->
name|xref
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DOXREFS */
block|}
name|xtabf
argument_list|(
argument|s
argument_list|,
argument|size
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|str
decl_stmt|;
specifier|register
name|c
operator|,
name|i
expr_stmt|;
name|char
name|buf
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|str
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|str
argument_list|,
literal|'\t'
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|c
operator|=
operator|*
name|str
operator|++
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|!=
literal|7
condition|)
name|str
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * Print the file header to the temp file.  */
name|vhprint
argument_list|(
name|hp
argument_list|,
name|verbose
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
name|fname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|tailpath
parameter_list|()
function_decl|;
name|fname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* init name holder */
name|p1
operator|=
name|index
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|/* Find the sender's full name. */
if|if
condition|(
name|p1
operator|==
name|NULL
operator|&&
name|hp
operator|->
name|path
index|[
literal|0
index|]
condition|)
name|p1
operator|=
name|index
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|!=
name|NULL
condition|)
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Subject: %s"
argument_list|,
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|&&
name|hp
operator|->
name|summary
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Summary: %s"
argument_list|,
name|hp
operator|->
name|summary
argument_list|)
operator|,
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|&&
name|hp
operator|->
name|keywords
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Keywords: %s"
argument_list|,
name|hp
operator|->
name|keywords
argument_list|)
operator|,
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"From: %s"
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Path: %s"
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|organization
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Organization: %s"
argument_list|,
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|p1
operator|=
literal|'\0'
expr_stmt|;
comment|/* bump over the '(' */
ifdef|#
directive|ifdef
name|INTERNET
comment|/* 		 * Prefer Path line if it's in internet format, or if we don't 		 * understand internet format here, or if there is no reply-to. 		 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"From: %s"
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Path: %s"
argument_list|,
name|tailpath
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|||
operator|(
name|hp
operator|->
name|organization
index|[
literal|0
index|]
operator|&&
operator|!
name|hflag
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|linebuf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
name|p2
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|linebuf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|organization
index|[
literal|0
index|]
operator|&&
operator|!
name|hflag
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|linebuf
argument_list|,
literal|" @ "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|linebuf
argument_list|,
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|linebuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
operator|*
name|p1
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|ctlmsg
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Control: %s"
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Newsgroups: %s"
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Date: %s"
argument_list|,
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|sender
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Sender: %s"
argument_list|,
name|hp
operator|->
name|sender
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|replyto
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Reply-To: %s"
argument_list|,
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|followto
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Followup-To: %s"
argument_list|,
name|hp
operator|->
name|followto
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|STRCMP
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
name|groupdir
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuf
argument_list|,
literal|"Newsgroups: %s"
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|timer
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MYDB
name|char
modifier|*
name|findparent
parameter_list|(
name|id
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|long
modifier|*
name|num
decl_stmt|;
block|{
name|struct
name|artrec
name|a
decl_stmt|;
name|char
name|idbuf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|ngname
parameter_list|()
function_decl|;
name|strcpy
argument_list|(
name|idbuf
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|lcase
argument_list|(
name|idbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookart
argument_list|(
name|id
argument_list|,
operator|&
name|a
argument_list|)
operator|==
name|DNULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|a
operator|.
name|parent
operator|==
name|DNULL
condition|)
return|return
name|NULL
return|;
name|readrec
argument_list|(
name|a
operator|.
name|parent
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|a
operator|.
name|groups
index|[
literal|0
index|]
operator|.
name|artno
expr_stmt|;
return|return
name|ngname
argument_list|(
name|a
operator|.
name|groups
index|[
literal|0
index|]
operator|.
name|newsgroup
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/*  * Append file to temp file, handling control characters, folding lines, etc.  * We don't grow the temp file to more than nlines so that a user won't have  * to wait for 20 seconds to read in a monster file from net.sources.  * What we really want is coroutines--any year now.  */
define|#
directive|define
name|ULINE
value|0200
specifier|static
name|char
modifier|*
name|maxcol
decl_stmt|;
name|appfile
argument_list|(
name|iop
argument_list|,
name|nlines
argument_list|)
specifier|register
name|FILE
operator|*
name|iop
expr_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|icol
decl_stmt|;
comment|/*&linebuf[0]<= icol<= maxcol */
if|if
condition|(
name|artread
operator|||
name|artlines
operator|>=
name|nlines
operator|||
name|iop
operator|==
name|NULL
condition|)
return|return;
name|maxcol
operator|=
name|linebuf
expr_stmt|;
name|icol
operator|=
name|linebuf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|iop
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
if|if
condition|(
name|icol
operator|==
name|maxcol
operator|&&
name|icol
operator|<
name|linebuf
operator|+
name|LBUFLEN
operator|-
literal|1
condition|)
block|{
operator|*
name|icol
operator|++
operator|=
literal|' '
expr_stmt|;
name|maxcol
operator|=
name|icol
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|icol
operator|==
literal|'_'
condition|)
operator|*
name|icol
operator|++
operator|=
name|ULINE
operator||
literal|' '
expr_stmt|;
else|else
name|icol
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\t'
case|:
name|icol
operator|=
operator|(
name|icol
operator|-
name|linebuf
operator|&
operator|~
literal|07
operator|)
operator|+
literal|8
operator|+
name|linebuf
expr_stmt|;
name|growline
argument_list|(
name|icol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|icol
operator|>
name|linebuf
condition|)
operator|--
name|icol
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|outline
argument_list|()
expr_stmt|;
if|if
condition|(
name|artlines
operator|>=
name|nlines
condition|)
return|return;
name|icol
operator|=
name|linebuf
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|icol
operator|=
name|linebuf
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|outline
argument_list|()
expr_stmt|;
name|outline
argument_list|()
expr_stmt|;
name|outline
argument_list|()
expr_stmt|;
if|if
condition|(
name|artlines
operator|>=
name|nlines
condition|)
return|return;
name|icol
operator|=
name|linebuf
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|'~'
condition|)
break|break;
elseif|else
if|if
condition|(
name|icol
operator|>=
name|linebuf
operator|+
name|LBUFLEN
operator|-
literal|1
condition|)
name|icol
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|icol
operator|==
name|maxcol
condition|)
block|{
operator|*
name|icol
operator|++
operator|=
name|c
expr_stmt|;
name|maxcol
operator|=
name|icol
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
operator|*
name|icol
operator|++
operator||=
name|ULINE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|icol
operator|==
literal|'_'
condition|)
operator|*
name|icol
operator|++
operator|=
operator|(
name|c
operator||
name|ULINE
operator|)
expr_stmt|;
else|else
operator|*
name|icol
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|maxcol
operator|!=
name|linebuf
condition|)
comment|/* file not terminated with newline */
name|outline
argument_list|()
expr_stmt|;
name|artread
operator|++
expr_stmt|;
block|}
name|growline
argument_list|(
argument|col
argument_list|)
name|char
modifier|*
name|col
decl_stmt|;
block|{
while|while
condition|(
name|maxcol
operator|<
name|col
operator|&&
name|maxcol
operator|<
name|linebuf
operator|+
name|LBUFLEN
operator|-
literal|1
condition|)
operator|*
name|maxcol
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|outline
argument_list|()
block|{
operator|*
name|maxcol
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|STRNCMP
argument_list|(
name|linebuf
argument_list|,
literal|">From "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|linebuf
init|;
operator|(
operator|*
name|p
operator|=
name|p
index|[
literal|1
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
block|}
name|tfappend
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxcol
operator|>
name|linebuf
condition|)
name|artlines
operator|=
name|lastlin
expr_stmt|;
name|maxcol
operator|=
name|linebuf
expr_stmt|;
block|}
comment|/*  * Prompt the user and get a line.  * "prompter" is the prompt.  "buf" contains a string which  * will be used as the initial user response (which may be edited  * by the user with backspace, ^U, etc).  The resulting line is  * returned in "buf".  The result of prget() is:  *	 0 if the line was terminated by NL or CR  *	 1 if it was terminated by the interrupt character.  *	 2 if it was terminated by erasing all the characters, including  *	   one or more that were prompted initially in "buf".  (If "buf"  * 	   was empty, this will never occur.)  */
name|int
name|prget
parameter_list|(
name|prompter
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|prompter
decl_stmt|,
decl|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
name|lastc
decl_stmt|;
name|char
name|hadprompt
init|=
name|buf
index|[
literal|0
index|]
decl_stmt|;
name|curflag
operator|=
name|CURP2
expr_stmt|;
name|r
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lastc
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|secpr
expr_stmt|;
for|for
control|(
name|q
operator|=
name|prompter
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
for|for
control|(
name|q
operator|=
name|buf
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|<
operator|&
name|secpr
index|[
name|SECPRLEN
operator|-
literal|1
index|]
operator|&&
operator|*
name|q
operator|>=
literal|' '
operator|&&
operator|*
name|q
operator|<=
literal|'~'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
name|vgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
name|cintr
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|cerase
operator|||
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|'\177'
condition|)
block|{
if|if
condition|(
name|lastc
operator|==
literal|'\\'
condition|)
name|r
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|>
name|buf
condition|)
name|r
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|ckill
condition|)
block|{
if|if
condition|(
name|lastc
operator|==
literal|'\\'
condition|)
name|r
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
else|else
name|r
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGLTC
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|cwerase
condition|)
block|{
if|if
condition|(
name|lastc
operator|==
literal|'\\'
condition|)
name|r
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
while|while
condition|(
name|r
operator|>
name|buf
operator|&&
operator|(
name|r
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|r
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|r
operator|--
expr_stmt|;
while|while
condition|(
name|r
operator|>
name|buf
operator|&&
name|r
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|r
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\t'
condition|)
name|r
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|lastc
operator|=
name|c
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|==
name|buf
operator|)
operator|&&
name|hadprompt
condition|)
return|return
literal|2
return|;
block|}
name|curflag
operator|=
name|CURHOME
expr_stmt|;
name|secpr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|c
operator|==
name|cintr
operator|)
return|;
block|}
comment|/*  * Execute a shell command.  */
name|shcmd
argument_list|(
argument|cmd
argument_list|,
argument|flags
argument_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|char
modifier|*
name|arg
index|[
literal|4
index|]
decl_stmt|;
name|arg
index|[
literal|0
index|]
operator|=
name|SHELL
operator|,
name|arg
index|[
literal|1
index|]
operator|=
literal|"-c"
operator|,
name|arg
index|[
literal|2
index|]
operator|=
name|cmd
operator|,
name|arg
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|prun
argument_list|(
name|arg
argument_list|,
name|flags
argument_list|)
return|;
block|}
name|prun
argument_list|(
argument|args
argument_list|,
argument|flags
argument_list|)
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|savequit
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|env
index|[
literal|100
index|]
decl_stmt|,
modifier|*
modifier|*
name|envp
decl_stmt|,
modifier|*
modifier|*
name|oenvp
decl_stmt|;
name|char
name|a
index|[
name|BUFLEN
operator|+
literal|2
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|int
name|pstatus
decl_stmt|,
name|retval
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BKGRND
operator|)
condition|)
block|{
name|botscreen
argument_list|()
expr_stmt|;
name|ttycooked
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
while|while
condition|(
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
comment|/* !BSD4_2 */
comment|/* 4.1 BSD (at least) can't handle this vfork with -ljobs */
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/* !BSD4_2 */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* must not clear alarm */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BKGRND
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* set $A */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|a
argument_list|,
literal|"A=%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|oenvp
operator|=
name|environ
expr_stmt|;
name|env
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
for|for
control|(
name|envp
operator|=
name|env
operator|+
literal|1
init|;
operator|*
name|oenvp
operator|!=
name|NULL
operator|&&
name|envp
operator|<
name|env
operator|+
literal|98
condition|;
name|oenvp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|oenvp
operator|)
index|[
literal|0
index|]
operator|!=
literal|'A'
operator|||
operator|(
operator|*
name|oenvp
operator|)
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
operator|*
name|envp
operator|++
operator|=
operator|*
name|oenvp
expr_stmt|;
operator|*
name|envp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|savmask
argument_list|)
expr_stmt|;
name|execve
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BKGRND
operator|)
condition|)
block|{
name|savequit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|pstatus
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
operator|(
name|i
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
else|else
name|retval
operator|=
name|pstatus
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CWAIT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[Hit return to continue]"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|errno
operator|=
literal|0
operator|,
name|i
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
operator|(
name|i
operator|!=
name|EOF
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|savequit
argument_list|)
expr_stmt|;
name|ttyraw
argument_list|()
expr_stmt|;
name|okclear
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|retval
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DIGPAGE
comment|/*  * Find end of current subarticle in digest.  */
name|findend
argument_list|(
argument|l
argument_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
name|l
init|;
name|i
operator|<
name|l
operator|+
name|ARTWLEN
operator|&&
name|i
operator|<
name|lastlin
condition|;
name|i
operator|++
control|)
block|{
name|tfget
argument_list|(
name|linebuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|linebuf
init|;
operator|*
name|p
operator|==
literal|'-'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|>
literal|23
operator|&&
name|n
operator|<
literal|33
operator|)
operator|||
operator|(
name|n
operator|>
literal|65
operator|&&
name|n
operator|<
literal|79
operator|)
condition|)
block|{
name|tfget
argument_list|(
name|linebuf
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*** Routines for handling temporary file ***/
comment|/*  * Append to temp file.  * Long lines are folded.  */
name|tfappend
argument_list|(
name|tline
argument_list|)
specifier|register
name|char
operator|*
name|tline
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|nxtlin
decl_stmt|;
do|do
block|{
name|nxtlin
operator|=
name|index
argument_list|(
name|tline
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtlin
condition|)
operator|*
name|nxtlin
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|tline
argument_list|)
operator|>
name|COLS
condition|)
block|{
name|tfput
argument_list|(
name|tline
argument_list|,
name|lastlin
operator|++
argument_list|)
expr_stmt|;
name|tline
operator|+=
name|COLS
expr_stmt|;
name|maxlinno
operator|++
expr_stmt|;
block|}
name|tfput
argument_list|(
name|tline
argument_list|,
name|lastlin
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tline
operator|=
name|nxtlin
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
name|tfput
argument_list|(
argument|tline
argument_list|,
argument|linno
argument_list|)
name|char
modifier|*
name|tline
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|rtfp
decl_stmt|;
comment|/* try to make it a little faster */
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|=
name|tline
operator|,
name|i
operator|=
name|even
argument_list|(
name|COLS
argument_list|)
expr_stmt|;
name|tfseek
argument_list|(
name|linno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rtfp
operator|=
name|tfp
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
condition|)
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|rtfp
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|rtfp
argument_list|)
expr_stmt|;
block|}
name|tflinno
operator|++
expr_stmt|;
block|}
name|tfget
argument_list|(
argument|tline
argument_list|,
argument|linno
argument_list|)
name|char
modifier|*
name|tline
decl_stmt|;
block|{
name|tfseek
argument_list|(
name|linno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|tline
argument_list|,
name|even
argument_list|(
name|COLS
argument_list|)
argument_list|,
literal|1
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|tline
index|[
name|COLS
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tflinno
operator|++
expr_stmt|;
block|}
name|tfseek
argument_list|(
argument|linno
argument_list|,
argument|wrflag
argument_list|)
block|{
specifier|static
name|int
name|lastwrflag
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|linno
operator|!=
name|tflinno
operator|||
name|wrflag
operator|!=
name|lastwrflag
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|tfp
argument_list|,
operator|(
name|long
operator|)
name|linno
operator|*
name|even
argument_list|(
name|COLS
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tflinno
operator|=
name|linno
expr_stmt|;
name|lastwrflag
operator|=
name|wrflag
expr_stmt|;
block|}
block|}
comment|/* VARARGS1 */
name|msg
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|secpr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
block|}
comment|/*  * Update the display.  * The display is entirely controlled by this routine,  * which means that this routine may get pretty snarled.  */
specifier|static
name|int
name|savelinno
init|=
operator|-
literal|1
decl_stmt|;
comment|/* dlinno on last call to updscr */
specifier|static
name|int
name|savepr
decl_stmt|;
comment|/* prflags on last call */
ifdef|#
directive|ifdef
name|TIOCGWINSZ
specifier|static
name|int
name|UPDATING
init|=
literal|0
decl_stmt|,
name|WINCH
init|=
literal|0
decl_stmt|;
comment|/*  * called by winch() from virtterm.c -- resets state information back  * to start-up state and forces a full redraw of the screen.  The  * current article is rewound to the beginning because it's would  * be very difficult to get the screen to return to the exact point  * in the file that the user left off (I know, I tried).  */
name|winch_upd
argument_list|()
block|{
if|if
condition|(
name|UPDATING
condition|)
comment|/* concurrency.  wow! */
name|WINCH
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|WINCH
operator|==
literal|0
operator|)
operator|&&
operator|(
name|savelinno
operator|>=
literal|0
operator|)
condition|)
block|{
name|int
name|saveflag
init|=
name|curflag
decl_stmt|;
comment|/* reread the article */
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|getnextart
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|appfile
argument_list|(
name|fp
argument_list|,
name|dlinno
operator|+
name|ARTWLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* fix up the screen */
name|curflag
operator|=
name|saveflag
expr_stmt|;
name|strcpy
argument_list|(
name|prompt
argument_list|,
literal|"more? "
argument_list|)
expr_stmt|;
name|okclear
argument_list|()
expr_stmt|;
name|updscr
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TIOCGWINSZ */
name|updscr
argument_list|()
block|{
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|UPDATING
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGWINSZ */
if|if
condition|(
name|checkin
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|(
name|prflags
operator|&
name|HELPMSG
operator|)
operator|==
literal|0
operator|&&
operator|(
name|dlinno
operator|!=
name|savelinno
operator|||
name|savepr
operator|!=
name|prflags
operator|)
operator|&&
name|quitflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dlinno
operator|!=
name|savelinno
condition|)
name|prflags
operator|&=
operator|~
name|NOPRT
expr_stmt|;
name|count
operator|=
name|ARTWLEN
expr_stmt|;
if|if
condition|(
name|prflags
operator|&
name|NOPRT
condition|)
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|prflags
operator|&
name|HDRONLY
operator|)
operator|&&
name|count
operator|>
name|hdrend
condition|)
name|count
operator|=
name|hdrend
operator|-
name|dlinno
expr_stmt|;
ifdef|#
directive|ifdef
name|DIGPAGE
if|if
condition|(
name|endsuba
operator|>
literal|0
operator|&&
name|count
operator|>
name|endsuba
operator|-
name|dlinno
condition|)
name|count
operator|=
name|endsuba
operator|-
name|dlinno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|prflags
operator|&
name|NEWART
operator|)
operator|==
literal|0
condition|)
name|ushift
argument_list|(
name|ARTWIN
argument_list|,
name|ARTWIN
operator|+
name|ARTWLEN
operator|-
literal|1
argument_list|,
name|dlinno
operator|-
name|savelinno
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|lastlin
operator|-
name|dlinno
condition|)
name|count
operator|=
name|lastlin
operator|-
name|dlinno
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ARTWIN
init|;
name|i
operator|<
name|ARTWIN
operator|+
name|ARTWLEN
condition|;
name|i
operator|++
control|)
name|clrline
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|tfget
argument_list|(
name|linebuf
argument_list|,
name|dlinno
operator|+
name|i
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ARTWIN
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
block|}
name|prflags
operator|&=
operator|~
name|NEWART
expr_stmt|;
name|savepr
operator|=
name|prflags
expr_stmt|;
name|savelinno
operator|=
name|dlinno
expr_stmt|;
block|}
name|clrline
argument_list|(
name|SPLINE
argument_list|)
operator|,
name|clrline
argument_list|(
name|PRLINE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATTOP
name|mvaddstr
argument_list|(
name|PRLINE
argument_list|,
literal|0
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|strlen
argument_list|(
name|secpr
argument_list|)
operator|<=
name|COLS
condition|)
name|mvaddstr
argument_list|(
name|PRLINE
argument_list|,
literal|0
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mvaddstr
argument_list|(
name|PRLINE
argument_list|,
literal|59
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|PRLINE
argument_list|,
literal|17
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|addnum
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|addnum
argument_list|(
name|pngsize
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismail
condition|)
name|mvaddstr
argument_list|(
name|PRLINE
argument_list|,
literal|75
argument_list|,
name|ismail
operator|>
literal|1
condition|?
literal|"MAIL"
else|:
literal|"mail"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|SPLINE
argument_list|,
literal|0
argument_list|,
name|secpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|curflag
operator|==
name|CURP1
condition|)
name|move
argument_list|(
name|PRLINE
argument_list|,
name|strlen
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|curflag
operator|==
name|CURHOME
condition|)
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|UPDATING
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WINCH
condition|)
block|{
comment|/* window changed while updating screen */
name|WINCH
operator|=
literal|0
expr_stmt|;
name|winch_upd
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCGWINSZ */
block|}
name|addnum
argument_list|(
name|n
argument_list|)
specifier|register
name|long
name|n
expr_stmt|;
block|{
if|if
condition|(
name|n
operator|>=
literal|10
condition|)
name|addnum
argument_list|(
name|n
operator|/
literal|10
argument_list|)
expr_stmt|;
name|addch
argument_list|(
call|(
name|char
call|)
argument_list|(
name|n
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * Called on alarm signal.  * Simply sets flag, signal processed later.  */
name|onalarm
argument_list|()
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
name|int
name|dojump
init|=
name|reading
decl_stmt|;
name|reading
operator|=
name|FALSE
expr_stmt|;
name|alflag
operator|++
expr_stmt|;
if|if
condition|(
name|dojump
condition|)
name|longjmp
argument_list|(
name|alrmjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SIGTSTP */
name|alflag
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * Process alarm signal (or start clock)  */
name|timer
argument_list|()
block|{
name|time_t
name|tod
decl_stmt|;
name|int
name|hour
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
specifier|static
name|char
name|months
index|[]
init|=
literal|"JanFebMarAprMayJunJulAugSepOctNovDec"
decl_stmt|;
specifier|static
name|long
name|oldmsize
init|=
literal|1000000L
decl_stmt|;
specifier|static
name|int
name|rccount
init|=
literal|10
decl_stmt|;
specifier|static
name|time_t
name|lastismail
init|=
literal|0
decl_stmt|;
name|alflag
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|onalarm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|tod
argument_list|)
expr_stmt|;
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|tod
argument_list|)
expr_stmt|;
name|i
operator|=
literal|60
operator|-
name|t
operator|->
name|tm_sec
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|i
operator|>
literal|30
condition|?
literal|30
else|:
name|i
argument_list|)
expr_stmt|;
comment|/* reset alarm */
name|hour
operator|=
name|t
operator|->
name|tm_hour
operator|%
literal|12
expr_stmt|;
if|if
condition|(
name|hour
operator|==
literal|0
condition|)
name|hour
operator|=
literal|12
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timestr
argument_list|,
literal|"%.3s %d %d:%02d"
argument_list|,
name|months
operator|+
literal|3
operator|*
name|t
operator|->
name|tm_mon
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|mailf
operator|==
name|NULL
operator|||
name|stat
argument_list|(
name|mailf
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|statb
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|statb
operator|.
name|st_size
operator|>
name|oldmsize
condition|)
block|{
name|ismail
operator|=
literal|2
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|statb
operator|.
name|st_size
operator|==
literal|0
condition|)
name|ismail
operator|=
literal|0
expr_stmt|;
comment|/* force MAIL for at least 30 seconds */
elseif|else
if|if
condition|(
name|ismail
operator|>
literal|1
operator|&&
operator|(
name|lastismail
operator|+
literal|30
operator|)
operator|<
name|tod
condition|)
name|ismail
operator|=
literal|1
expr_stmt|;
block|}
name|oldmsize
operator|=
name|statb
operator|.
name|st_size
expr_stmt|;
name|lastismail
operator|=
name|tod
expr_stmt|;
if|if
condition|(
name|uflag
operator|&&
operator|!
name|xflag
operator|&&
operator|--
name|rccount
operator|<
literal|0
condition|)
block|{
name|writeoutrc
argument_list|()
expr_stmt|;
if|if
condition|(
name|secpr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|secpr
argument_list|,
literal|".newsrc updated"
argument_list|)
expr_stmt|;
name|rccount
operator|=
literal|10
expr_stmt|;
block|}
block|}
name|char
modifier|*
name|getmailname
parameter_list|()
block|{
specifier|static
name|char
name|mailname
index|[
literal|32
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"MAIL"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
ifndef|#
directive|ifndef
name|MMDF
if|if
condition|(
name|username
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|username
argument_list|)
operator|>
literal|15
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|USG
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mailname
argument_list|,
literal|"/usr/mail/%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USG */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mailname
argument_list|,
literal|"/usr/spool/mail/%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !USG */
else|#
directive|else
comment|/* MMDF */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mailname
argument_list|,
literal|"%s/mailbox"
argument_list|,
name|userhome
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMDF */
return|return
name|mailname
return|;
block|}
comment|/*** Terminal I/O ***/
define|#
directive|define
name|INBUFSIZ
value|8
name|char
name|inbuf
index|[
name|INBUFSIZ
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|outbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* output buffer */
name|int
name|innleft
init|=
literal|0
decl_stmt|;
comment|/* # of chars in input buffer */
name|int
name|outnleft
init|=
name|BUFSIZ
decl_stmt|;
comment|/* room left in output buffer */
name|char
modifier|*
name|innext
decl_stmt|;
comment|/* next input character */
name|char
modifier|*
name|outnext
init|=
name|outbuf
decl_stmt|;
comment|/* next space in output buffer */
ifdef|#
directive|ifdef
name|USG
name|int
name|oflags
decl_stmt|;
comment|/* fcntl flags (for nodelay read) */
endif|#
directive|endif
comment|/*  * Input a character  */
name|vgetc
argument_list|()
block|{
specifier|register
name|c
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
name|int
name|readfds
decl_stmt|,
name|exceptfds
decl_stmt|;
endif|#
directive|endif
name|recurse
label|:
if|if
condition|(
operator|--
name|innleft
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|innext
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|alflag
condition|)
name|timer
argument_list|()
expr_stmt|;
name|updscr
argument_list|()
expr_stmt|;
comment|/* update the display */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|innleft
operator|>
literal|0
operator|||
name|alflag
condition|)
goto|goto
name|recurse
goto|;
name|intflag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
if|if
condition|(
name|oflags
operator|&
name|O_NDELAY
condition|)
block|{
name|oflags
operator|&=
operator|~
name|O_NDELAY
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|setjmp
argument_list|(
name|alrmjmp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|setjmp
argument_list|(
name|intjmp
argument_list|)
condition|)
return|return
name|cintr
return|;
name|reading
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* SIGTSTP */
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
comment|/* Use a select because it can be interrupted. */
name|readfds
operator|=
literal|1
expr_stmt|;
name|exceptfds
operator|=
literal|1
expr_stmt|;
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|readfds
operator|&
literal|1
operator|)
condition|)
break|break;
endif|#
directive|endif
name|innleft
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|inbuf
argument_list|,
name|INBUFSIZ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|reading
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* SIGTSTP */
if|if
condition|(
name|innleft
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|innleft
operator|==
literal|0
condition|)
block|{
name|quitflg
operator|++
expr_stmt|;
return|return
name|cintr
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* "Can't happen" */
if|if
condition|(
name|intflag
condition|)
block|{
name|intflag
operator|--
expr_stmt|;
return|return
name|cintr
return|;
block|}
block|}
name|innext
operator|=
name|inbuf
operator|+
literal|1
expr_stmt|;
name|innleft
operator|--
expr_stmt|;
name|c
operator|=
name|inbuf
index|[
literal|0
index|]
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USG
ifndef|#
directive|ifndef
name|CBREAK
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\034'
condition|)
comment|/* FS character */
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\f'
condition|)
block|{
name|okclear
argument_list|()
expr_stmt|;
name|prflags
operator|&=
operator|~
name|NOPRT
expr_stmt|;
goto|goto
name|recurse
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/*  * Push a character back onto the input stream.  */
name|pushback
argument_list|(
argument|c
argument_list|)
block|{
if|if
condition|(
name|innext
operator|<=
name|inbuf
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
operator|--
name|innext
operator|=
name|c
expr_stmt|;
name|innleft
operator|++
expr_stmt|;
block|}
comment|/*  * Check for terminal input  */
name|checkin
argument_list|()
block|{
ifdef|#
directive|ifdef
name|FIONREAD
name|int
name|count
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATTOP
if|if
condition|(
name|innleft
operator|>
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|innleft
operator|>
literal|0
operator|||
name|alflag
condition|)
endif|#
directive|endif
return|return
literal|1
return|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|FIONREAD
argument_list|)
if|if
condition|(
name|ospeed
operator|>=
name|B9600
condition|)
return|return
literal|0
return|;
name|vflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<=
name|B300
condition|)
name|ttyowait
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
if|if
condition|(
operator|(
name|oflags
operator|&
name|O_NDELAY
operator|)
operator|==
literal|0
condition|)
block|{
name|oflags
operator||=
name|O_NDELAY
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|innleft
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|inbuf
argument_list|,
name|INBUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|innext
operator|=
name|inbuf
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIONREAD
name|count
operator|=
literal|0
expr_stmt|;
comment|/* in case FIONREAD fails */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/*  * flush terminal input queue.  */
name|clearin
argument_list|()
block|{
ifdef|#
directive|ifdef
name|USG
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TIOCFLUSH
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|sgttyb
name|tty
decl_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|innleft
operator|=
literal|0
expr_stmt|;
block|}
name|vputc
argument_list|(
argument|c
argument_list|)
block|{
if|if
condition|(
operator|--
name|outnleft
operator|<
literal|0
condition|)
block|{
name|vflush
argument_list|()
expr_stmt|;
name|outnleft
operator|--
expr_stmt|;
block|}
operator|*
name|outnext
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/*  * Flush the output buffer  */
name|vflush
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
name|int
name|mask
decl_stmt|;
else|#
directive|else
name|unsigned
name|oalarm
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_2
name|mask
operator|=
name|sigblock
argument_list|(
literal|1
operator|<<
operator|(
name|SIGALRM
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|oalarm
operator|=
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|outbuf
init|;
name|p
operator|<
name|outnext
condition|;
name|p
operator|+=
name|i
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|p
argument_list|,
name|outnext
operator|-
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* "Can't happen" */
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|outnleft
operator|=
name|BUFSIZ
expr_stmt|;
name|outnext
operator|=
name|outbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|oalarm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*** terminal modes ***/
ifdef|#
directive|ifdef
name|USG
specifier|static
name|struct
name|termio
name|oldtty
decl_stmt|,
name|newtty
decl_stmt|;
comment|/*  * Save tty modes  */
name|ttysave
argument_list|()
block|{
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
condition|)
name|xerror
argument_list|(
literal|"Can't get tty modes"
argument_list|)
expr_stmt|;
name|newtty
operator|=
name|oldtty
expr_stmt|;
name|newtty
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator|)
expr_stmt|;
name|newtty
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OPOST
operator|)
expr_stmt|;
name|newtty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
name|newtty
operator|.
name|c_lflag
operator||=
operator|(
name|NOFLSH
operator|)
expr_stmt|;
name|newtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|newtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|cerase
operator|=
name|oldtty
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|ckill
operator|=
name|oldtty
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
name|cintr
operator|=
name|oldtty
operator|.
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
name|ospeed
operator|=
name|oldtty
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
name|initterm
argument_list|()
expr_stmt|;
block|}
comment|/*  * Set tty modes for visual processing  */
name|ttyraw
argument_list|()
block|{
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|newtty
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
name|rawterm
argument_list|()
expr_stmt|;
block|}
name|ttyowait
argument_list|()
block|{
comment|/* wait for output queue to drain */
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|newtty
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
block|}
comment|/*  * Restore tty modes  */
name|ttycooked
argument_list|()
block|{
name|cookedterm
argument_list|()
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
name|oflags
operator|&=
operator|~
name|O_NDELAY
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
specifier|static
name|struct
name|sgttyb
name|oldtty
decl_stmt|,
name|newtty
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGLTC
specifier|static
name|struct
name|ltchars
name|oldltchars
decl_stmt|,
name|newltchars
decl_stmt|;
endif|#
directive|endif
comment|/*  * Save tty modes  */
name|ttysave
argument_list|()
block|{
ifdef|#
directive|ifdef
name|CBREAK
name|struct
name|tchars
name|tchars
decl_stmt|;
comment|/* special characters, including interrupt */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
name|int
name|getpgrp
parameter_list|()
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
name|int
name|tpgrp
decl_stmt|;
else|#
directive|else
comment|/* BSD4_1 */
name|short
name|tpgrp
decl_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
name|retry
label|:
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTIN
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !BSD4_2 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !BSD4_2 */
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tpgrp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nottty
goto|;
if|if
condition|(
name|tpgrp
operator|!=
name|getpgrp
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* not in foreground */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_2 */
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
comment|/* job stops here waiting for SIGCONT */
goto|goto
name|retry
goto|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTIN
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_2 */
endif|#
directive|endif
comment|/* SIGTSTP */
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
condition|)
name|nottty
label|:
name|xerror
argument_list|(
literal|"Can't get tty modes"
argument_list|)
expr_stmt|;
name|newtty
operator|=
name|oldtty
expr_stmt|;
name|newtty
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CBREAK
name|newtty
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tchars
argument_list|)
expr_stmt|;
name|cintr
operator|=
name|tchars
operator|.
name|t_intrc
expr_stmt|;
else|#
directive|else
comment|/* !CBREAK */
name|newtty
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
name|cintr
operator|=
literal|'\0177'
expr_stmt|;
comment|/* forcibly this on V6 systems */
endif|#
directive|endif
comment|/* !CBREAK */
name|cerase
operator|=
name|oldtty
operator|.
name|sg_erase
expr_stmt|;
name|ckill
operator|=
name|oldtty
operator|.
name|sg_kill
expr_stmt|;
name|ospeed
operator|=
name|oldtty
operator|.
name|sg_ospeed
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGLTC
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldltchars
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|newltchars
operator|=
name|oldltchars
expr_stmt|;
name|newltchars
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
name|cwerase
operator|=
name|oldltchars
operator|.
name|t_werasc
expr_stmt|;
block|}
endif|#
directive|endif
name|initterm
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGTSTP */
block|}
comment|/*  * Set tty modes for visual processing  */
name|ttyraw
argument_list|()
block|{
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|newtty
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|TIOCGLTC
if|if
condition|(
name|newltchars
operator|.
name|t_dsuspc
operator|==
literal|'\377'
condition|)
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|newltchars
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
endif|#
directive|endif
name|rawterm
argument_list|()
expr_stmt|;
block|}
name|ttyowait
argument_list|()
block|{
comment|/* wait for output queue to drain */
ifdef|#
directive|ifdef
name|TIOCDRAIN
comment|/* This ioctl is a local mod on linus */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCDRAIN
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * Restore tty modes  */
name|ttycooked
argument_list|()
block|{
name|cookedterm
argument_list|()
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCSETN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldtty
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|TIOCGLTC
if|if
condition|(
name|newltchars
operator|.
name|t_dsuspc
operator|==
literal|'\377'
condition|)
while|while
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCSLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldltchars
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/*** signal handlers ***/
name|onint
argument_list|()
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
name|int
name|dojump
init|=
name|reading
decl_stmt|;
name|reading
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* SIGTSTP */
if|if
condition|(
operator|!
name|news
condition|)
block|{
name|ttycooked
argument_list|()
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onint
argument_list|)
expr_stmt|;
name|clearin
argument_list|()
expr_stmt|;
comment|/* flush input queue */
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|dojump
condition|)
name|longjmp
argument_list|(
name|intjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGTSTP */
name|intflag
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGTSTP
name|onstop
argument_list|(
argument|signo
argument_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* restore old terminal state */
name|botscreen
argument_list|()
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
name|ttycooked
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BSD4_1 */
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|signo
argument_list|)
expr_stmt|;
comment|/* stop here until continued */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|signo
argument_list|,
name|onstop
argument_list|)
expr_stmt|;
comment|/* restore our special terminal state */
name|ttyraw
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|winch
argument_list|()
expr_stmt|;
comment|/* get current window size and redraw screen */
else|#
directive|else
comment|/* !TIOCGWINSZ */
name|okclear
argument_list|()
expr_stmt|;
name|updscr
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !TIOCGWINSZ */
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BSD4_1 */
name|timer
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
block|}
endif|#
directive|endif
comment|/*** stolen from rfuncs2.c and modified ***/
name|vsave
argument_list|(
name|to
argument_list|,
name|flags
argument_list|)
specifier|register
name|char
operator|*
name|to
expr_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|ufp
decl_stmt|;
name|int
name|isprogram
init|=
literal|0
decl_stmt|;
name|int
name|isnew
init|=
literal|1
decl_stmt|;
name|long
name|saveoff
decl_stmt|;
name|char
name|temp
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
name|prog
index|[
name|BUFLEN
operator|+
literal|24
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|saveoff
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|artbody
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fname
operator|=
name|to
expr_stmt|;
if|if
condition|(
operator|*
name|to
operator|==
name|PIPECHAR
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|to
argument_list|)
operator|>
name|BUFLEN
condition|)
block|{
name|msg
argument_list|(
literal|"Command name too long"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|flags
operator||=
name|OVWRITE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|temp
argument_list|,
literal|"/tmp/vnXXXXXX"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|fname
operator|=
name|temp
expr_stmt|;
name|_amove
argument_list|(
name|ROWS
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|OVWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|ufp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ufp
argument_list|)
expr_stmt|;
name|isnew
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|savmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|to
operator|==
name|PIPECHAR
condition|)
name|isprogram
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ufp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
operator|(
name|flags
operator|&
name|OVWRITE
operator|)
operator|==
literal|0
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * V7MAIL code is here to conform to V7 mail format. 	 * If you need a different format to be able to 	 * use your local mail command (such as four ^A's 	 * on the end of articles) substitute it here. 	 */
if|if
condition|(
name|flags
operator|&
name|SVHEAD
condition|)
block|{
ifdef|#
directive|ifdef
name|MMDF
if|if
condition|(
operator|!
name|isprogram
condition|)
name|fprintf
argument_list|(
name|ufp
argument_list|,
literal|"\001\001\001\001\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMDF */
ifdef|#
directive|ifdef
name|V7MAIL
name|h
operator|->
name|subtime
operator|=
name|cgtdate
argument_list|(
name|h
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ufp
argument_list|,
literal|"From %s %s"
argument_list|,
name|replyname
argument_list|(
name|h
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|h
operator|->
name|subtime
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hprint
argument_list|(
name|h
argument_list|,
name|ufp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|V7MAIL
name|tprint
argument_list|(
name|fp
argument_list|,
name|ufp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ufp
argument_list|)
expr_stmt|;
comment|/* force blank line at end (ugh) */
else|#
directive|else
name|tprint
argument_list|(
name|fp
argument_list|,
name|ufp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tprint
argument_list|(
name|fp
argument_list|,
name|ufp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ferror
argument_list|(
name|ufp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprogram
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|msg
argument_list|(
literal|"error in writing temp file, maybe disk full?"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|prog
argument_list|,
literal|"(%s)<%s"
argument_list|,
name|to
operator|+
literal|1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|shcmd
argument_list|(
name|prog
argument_list|,
name|CWAIT
argument_list|)
expr_stmt|;
name|prflags
operator||=
name|NOPRT
expr_stmt|;
block|}
block|}
else|else
block|{
name|msg
argument_list|(
literal|"%sfile: %s %s"
argument_list|,
name|err
condition|?
literal|"ERROR WHILE WRITING "
else|:
literal|""
argument_list|,
name|to
argument_list|,
operator|(
name|flags
operator|&
name|OVWRITE
operator|)
condition|?
literal|"written"
else|:
name|isnew
condition|?
literal|"created"
else|:
literal|"appended"
argument_list|)
expr_stmt|;
block|}
comment|/* If we got an error, screen may be messed.  E.g. 4.2BSD 	 * writes "disk full" messages to the user's tty. 	 */
if|if
condition|(
name|err
condition|)
block|{
name|okclear
argument_list|()
expr_stmt|;
name|updscr
argument_list|()
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|isprogram
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|N_UMASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|saveoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|xxit
argument_list|(
argument|status
argument_list|)
name|int
name|status
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
if|if
condition|(
name|STRNCMP
argument_list|(
name|ACTIVE
argument_list|,
literal|"/tmp/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ACTIVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SORTACTIVE */
ifdef|#
directive|ifdef
name|SERVER
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|active_name
argument_list|()
argument_list|)
expr_stmt|;
name|close_server
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER */
if|if
condition|(
name|ospeed
condition|)
block|{
comment|/* is == 0, we haven't been in raw mode yet */
name|botscreen
argument_list|()
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
name|ttycooked
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

