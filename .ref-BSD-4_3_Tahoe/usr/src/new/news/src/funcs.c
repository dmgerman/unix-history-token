begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * funcs - functions used by many programs  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)funcs.c	2.36	10/7/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !v7 */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * News group matching.  *  * nglist is a list of newsgroups.  * sublist is a list of subscriptions.  * sublist may have "meta newsgroups" in it.  * All fields are NGDELIM separated,  * and there is an NGDELIM at the end of each argument.  *  * Currently implemented glitches:  * sublist uses 'all' like shell uses '*', and '.' like shell '/'.  * If subscription X matches Y, it also matches Y.anything.  */
end_comment

begin_expr_stmt
name|ngmatch
argument_list|(
name|nglist
argument_list|,
name|sublist
argument_list|)
specifier|register
name|char
operator|*
name|nglist
operator|,
operator|*
name|sublist
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nglist
init|;
operator|*
name|n
operator|!=
literal|'\0'
operator|&&
name|rc
operator|==
name|FALSE
condition|;
control|)
block|{
for|for
control|(
name|s
operator|=
name|sublist
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
name|NEGCHAR
condition|)
name|rc
operator|=
name|rc
operator|||
name|ptrncmp
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|rc
operator|&&
operator|!
name|ptrncmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|NGDELIM
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
while|while
condition|(
operator|*
name|n
operator|++
operator|!=
name|NGDELIM
operator|&&
operator|*
name|n
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_block

begin_comment
comment|/*  * Compare two newsgroups for equality.  * The first one may be a "meta" newsgroup.  */
end_comment

begin_expr_stmt
name|ptrncmp
argument_list|(
name|ng1
argument_list|,
name|ng2
argument_list|)
specifier|register
name|char
operator|*
name|ng1
operator|,
operator|*
name|ng2
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|ng1
operator|!=
name|NGDELIM
operator|&&
operator|*
name|ng1
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ng1
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
name|ng1
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|ng1
index|[
literal|2
index|]
operator|==
literal|'l'
condition|)
block|{
name|ng1
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
operator|*
name|ng2
operator|!=
name|NGDELIM
operator|&&
operator|*
name|ng2
operator|!=
literal|'.'
operator|&&
operator|*
name|ng2
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|ptrncmp
argument_list|(
name|ng1
argument_list|,
name|ng2
operator|++
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
name|ptrncmp
argument_list|(
name|ng1
argument_list|,
name|ng2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ng1
operator|++
operator|!=
operator|*
name|ng2
operator|++
condition|)
return|return
name|FALSE
return|;
block|}
return|return
operator|*
name|ng2
operator|==
literal|'.'
operator|||
operator|*
name|ng2
operator|==
name|NGDELIM
operator|||
operator|*
name|ng2
operator|==
literal|'\0'
return|;
block|}
end_block

begin_comment
comment|/*  * Exec the shell.  * This version resets uid, gid, and umask.  * Called with fsubr(ushell, s, NULL)  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|ushell
argument_list|(
argument|s
argument_list|,
argument|dummy
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|dummy
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|umask
argument_list|(
name|savmask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|xshell
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Exec the shell.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !lint */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_macro
name|xshell
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|env
index|[
literal|100
index|]
decl_stmt|,
modifier|*
modifier|*
name|envp
decl_stmt|;
name|char
name|a
index|[
name|BUFLEN
operator|+
literal|2
index|]
decl_stmt|;
specifier|extern
name|char
name|filename
index|[]
decl_stmt|;
comment|/* set $A */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|a
argument_list|,
literal|"A=%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|env
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
for|for
control|(
name|envp
operator|=
name|env
operator|+
literal|1
init|;
operator|*
name|environ
operator|!=
name|NULL
operator|&&
name|envp
operator|<
name|env
operator|+
literal|98
condition|;
name|environ
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|environ
operator|)
index|[
literal|0
index|]
operator|!=
literal|'A'
operator|||
operator|(
operator|*
name|environ
operator|)
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
operator|*
name|envp
operator|++
operator|=
operator|*
name|environ
expr_stmt|;
operator|*
name|envp
operator|=
name|NULL
expr_stmt|;
name|execle
argument_list|(
name|SHELL
argument_list|,
name|SHELL
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"No shell!"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fork and call a subroutine with two args.  * Return pid without waiting.  */
end_comment

begin_macro
name|fsubr
argument_list|(
argument|f
argument_list|,
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pid
decl_stmt|;
comment|/* this may NOT be a vfork */
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|f
call|)
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/*  * Wait on a child process.  */
end_comment

begin_expr_stmt
name|fwait
argument_list|(
name|pid
argument_list|)
specifier|register
name|int
name|pid
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
argument_list|(
operator|*
name|onhup
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|onint
argument_list|)
argument_list|()
decl_stmt|;
name|onint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|onhup
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|w
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*  * Strip trailing newlines, blanks, and tabs from 's'.  * Return TRUE if newline was found, else FALSE.  */
end_comment

begin_expr_stmt
name|nstrip
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rc
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|s
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_comment
comment|/*  * Local open routine.  */
end_comment

begin_function
name|FILE
modifier|*
name|xfopen
parameter_list|(
name|name
parameter_list|,
name|fmode
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|fmode
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|fmode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|IHCC
comment|/* 		 * IHCC users only see the "filename" that was in trouble, 		 * not the whole path.  (for security!) 		 */
name|fname
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|fname
operator|=
name|name
expr_stmt|;
endif|#
directive|endif
name|xerror
argument_list|(
literal|"Cannot open %s (%s): %s"
argument_list|,
name|fname
argument_list|,
name|fmode
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* kludge for setuid not being honored for root */
if|if
condition|(
operator|(
name|uid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|duid
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|*
name|fmode
operator|==
literal|'a'
operator|)
operator|||
operator|(
operator|*
name|fmode
operator|==
literal|'w'
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|duid
argument_list|,
name|dgid
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|errmsg
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|ebuf
index|[
literal|6
operator|+
literal|5
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|>
name|sys_nerr
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"Error %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|ebuf
return|;
block|}
else|else
return|return
name|sys_errlist
index|[
name|code
index|]
return|;
block|}
end_function

begin_comment
comment|/* From UC Berkeley @(#)strcasecmp.c	1.3 (Berkeley) 8/3/87 */
end_comment

begin_comment
comment|/*  * This array is designed for mapping upper and lower case letter  * together for a case independent comparison.  The mappings are  * based upon ascii character sequences.  */
end_comment

begin_decl_stmt
name|char
name|charmap
index|[]
init|=
block|{
literal|'\000'
block|,
literal|'\001'
block|,
literal|'\002'
block|,
literal|'\003'
block|,
literal|'\004'
block|,
literal|'\005'
block|,
literal|'\006'
block|,
literal|'\007'
block|,
literal|'\010'
block|,
literal|'\011'
block|,
literal|'\012'
block|,
literal|'\013'
block|,
literal|'\014'
block|,
literal|'\015'
block|,
literal|'\016'
block|,
literal|'\017'
block|,
literal|'\020'
block|,
literal|'\021'
block|,
literal|'\022'
block|,
literal|'\023'
block|,
literal|'\024'
block|,
literal|'\025'
block|,
literal|'\026'
block|,
literal|'\027'
block|,
literal|'\030'
block|,
literal|'\031'
block|,
literal|'\032'
block|,
literal|'\033'
block|,
literal|'\034'
block|,
literal|'\035'
block|,
literal|'\036'
block|,
literal|'\037'
block|,
literal|'\040'
block|,
literal|'\041'
block|,
literal|'\042'
block|,
literal|'\043'
block|,
literal|'\044'
block|,
literal|'\045'
block|,
literal|'\046'
block|,
literal|'\047'
block|,
literal|'\050'
block|,
literal|'\051'
block|,
literal|'\052'
block|,
literal|'\053'
block|,
literal|'\054'
block|,
literal|'\055'
block|,
literal|'\056'
block|,
literal|'\057'
block|,
literal|'\060'
block|,
literal|'\061'
block|,
literal|'\062'
block|,
literal|'\063'
block|,
literal|'\064'
block|,
literal|'\065'
block|,
literal|'\066'
block|,
literal|'\067'
block|,
literal|'\070'
block|,
literal|'\071'
block|,
literal|'\072'
block|,
literal|'\073'
block|,
literal|'\074'
block|,
literal|'\075'
block|,
literal|'\076'
block|,
literal|'\077'
block|,
literal|'\100'
block|,
literal|'\141'
block|,
literal|'\142'
block|,
literal|'\143'
block|,
literal|'\144'
block|,
literal|'\145'
block|,
literal|'\146'
block|,
literal|'\147'
block|,
literal|'\150'
block|,
literal|'\151'
block|,
literal|'\152'
block|,
literal|'\153'
block|,
literal|'\154'
block|,
literal|'\155'
block|,
literal|'\156'
block|,
literal|'\157'
block|,
literal|'\160'
block|,
literal|'\161'
block|,
literal|'\162'
block|,
literal|'\163'
block|,
literal|'\164'
block|,
literal|'\165'
block|,
literal|'\166'
block|,
literal|'\167'
block|,
literal|'\170'
block|,
literal|'\171'
block|,
literal|'\172'
block|,
literal|'\133'
block|,
literal|'\134'
block|,
literal|'\135'
block|,
literal|'\136'
block|,
literal|'\137'
block|,
literal|'\140'
block|,
literal|'\141'
block|,
literal|'\142'
block|,
literal|'\143'
block|,
literal|'\144'
block|,
literal|'\145'
block|,
literal|'\146'
block|,
literal|'\147'
block|,
literal|'\150'
block|,
literal|'\151'
block|,
literal|'\152'
block|,
literal|'\153'
block|,
literal|'\154'
block|,
literal|'\155'
block|,
literal|'\156'
block|,
literal|'\157'
block|,
literal|'\160'
block|,
literal|'\161'
block|,
literal|'\162'
block|,
literal|'\163'
block|,
literal|'\164'
block|,
literal|'\165'
block|,
literal|'\166'
block|,
literal|'\167'
block|,
literal|'\170'
block|,
literal|'\171'
block|,
literal|'\172'
block|,
literal|'\173'
block|,
literal|'\174'
block|,
literal|'\175'
block|,
literal|'\176'
block|,
literal|'\177'
block|,
literal|'\200'
block|,
literal|'\201'
block|,
literal|'\202'
block|,
literal|'\203'
block|,
literal|'\204'
block|,
literal|'\205'
block|,
literal|'\206'
block|,
literal|'\207'
block|,
literal|'\210'
block|,
literal|'\211'
block|,
literal|'\212'
block|,
literal|'\213'
block|,
literal|'\214'
block|,
literal|'\215'
block|,
literal|'\216'
block|,
literal|'\217'
block|,
literal|'\220'
block|,
literal|'\221'
block|,
literal|'\222'
block|,
literal|'\223'
block|,
literal|'\224'
block|,
literal|'\225'
block|,
literal|'\226'
block|,
literal|'\227'
block|,
literal|'\230'
block|,
literal|'\231'
block|,
literal|'\232'
block|,
literal|'\233'
block|,
literal|'\234'
block|,
literal|'\235'
block|,
literal|'\236'
block|,
literal|'\237'
block|,
literal|'\240'
block|,
literal|'\241'
block|,
literal|'\242'
block|,
literal|'\243'
block|,
literal|'\244'
block|,
literal|'\245'
block|,
literal|'\246'
block|,
literal|'\247'
block|,
literal|'\250'
block|,
literal|'\251'
block|,
literal|'\252'
block|,
literal|'\253'
block|,
literal|'\254'
block|,
literal|'\255'
block|,
literal|'\256'
block|,
literal|'\257'
block|,
literal|'\260'
block|,
literal|'\261'
block|,
literal|'\262'
block|,
literal|'\263'
block|,
literal|'\264'
block|,
literal|'\265'
block|,
literal|'\266'
block|,
literal|'\267'
block|,
literal|'\270'
block|,
literal|'\271'
block|,
literal|'\272'
block|,
literal|'\273'
block|,
literal|'\274'
block|,
literal|'\275'
block|,
literal|'\276'
block|,
literal|'\277'
block|,
literal|'\300'
block|,
literal|'\341'
block|,
literal|'\342'
block|,
literal|'\343'
block|,
literal|'\344'
block|,
literal|'\345'
block|,
literal|'\346'
block|,
literal|'\347'
block|,
literal|'\350'
block|,
literal|'\351'
block|,
literal|'\352'
block|,
literal|'\353'
block|,
literal|'\354'
block|,
literal|'\355'
block|,
literal|'\356'
block|,
literal|'\357'
block|,
literal|'\360'
block|,
literal|'\361'
block|,
literal|'\362'
block|,
literal|'\363'
block|,
literal|'\364'
block|,
literal|'\365'
block|,
literal|'\366'
block|,
literal|'\367'
block|,
literal|'\370'
block|,
literal|'\371'
block|,
literal|'\372'
block|,
literal|'\333'
block|,
literal|'\334'
block|,
literal|'\335'
block|,
literal|'\336'
block|,
literal|'\337'
block|,
literal|'\340'
block|,
literal|'\341'
block|,
literal|'\342'
block|,
literal|'\343'
block|,
literal|'\344'
block|,
literal|'\345'
block|,
literal|'\346'
block|,
literal|'\347'
block|,
literal|'\350'
block|,
literal|'\351'
block|,
literal|'\352'
block|,
literal|'\353'
block|,
literal|'\354'
block|,
literal|'\355'
block|,
literal|'\356'
block|,
literal|'\357'
block|,
literal|'\360'
block|,
literal|'\361'
block|,
literal|'\362'
block|,
literal|'\363'
block|,
literal|'\364'
block|,
literal|'\365'
block|,
literal|'\366'
block|,
literal|'\367'
block|,
literal|'\370'
block|,
literal|'\371'
block|,
literal|'\372'
block|,
literal|'\373'
block|,
literal|'\374'
block|,
literal|'\375'
block|,
literal|'\376'
block|,
literal|'\377'
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|strcasecmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cm
init|=
name|charmap
decl_stmt|;
while|while
condition|(
name|cm
index|[
operator|*
name|s1
index|]
operator|==
name|cm
index|[
operator|*
name|s2
operator|++
index|]
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
name|cm
index|[
operator|*
name|s1
index|]
operator|-
name|cm
index|[
operator|*
operator|--
name|s2
index|]
return|;
block|}
end_block

begin_expr_stmt
name|strncasecmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cm
init|=
name|charmap
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
name|cm
index|[
operator|*
name|s1
index|]
operator|==
name|cm
index|[
operator|*
name|s2
operator|++
index|]
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
name|n
operator|<
literal|0
condition|?
literal|0
else|:
name|cm
index|[
operator|*
name|s1
index|]
operator|-
name|cm
index|[
operator|*
operator|--
name|s2
index|]
return|;
block|}
end_block

begin_expr_stmt
name|prefix
argument_list|(
name|full
argument_list|,
name|pref
argument_list|)
specifier|register
name|char
operator|*
name|full
operator|,
operator|*
name|pref
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cm
init|=
name|charmap
decl_stmt|;
while|while
condition|(
operator|*
name|pref
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cm
index|[
operator|*
name|full
operator|++
index|]
operator|!=
name|cm
index|[
operator|*
name|pref
operator|++
index|]
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|dirname
parameter_list|(
name|ngname
parameter_list|)
name|char
modifier|*
name|ngname
decl_stmt|;
block|{
specifier|static
name|char
name|rbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|SPOOL
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|rbuf
operator|+
name|strlen
argument_list|(
name|SPOOL
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
return|return
name|rbuf
return|;
block|}
end_function

begin_comment
comment|/*  * Return TRUE iff ngname is a valid newsgroup name  */
end_comment

begin_macro
name|validng
argument_list|(
argument|ngname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ngname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|abuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|abuf
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|abuf
expr_stmt|;
name|q
operator|=
name|ngname
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|q
operator|++
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|q
operator|==
literal|'\0'
operator|&&
operator|*
operator|--
name|p
operator|==
literal|' '
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|xerror
argument_list|(
argument|message
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|message
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|logerr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|log
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|,
name|a9
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_dolog
argument_list|(
literal|0
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|logerr
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|,
name|a9
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_dolog
argument_list|(
literal|1
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|lfsuffix
index|[]
init|=
block|{
literal|"log"
block|,
literal|"errlog"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Log the given message, with printf strings and parameters allowed,  * on the log file, if it can be written.  The date and an attempt at  * figuring out the remote system name are also logged.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|_dolog
argument_list|(
argument|which
argument_list|,
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|,
name|a9
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|logfile
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|logtime
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|logfname
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* the log file */
name|char
name|rmtsys
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
name|msg
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|time_t
name|t
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|rmtsys
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|index
argument_list|(
name|rmtsys
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|p
operator|=
name|rindex
argument_list|(
name|rmtsys
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
literal|"local"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logtime
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logtime
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|logtime
operator|+=
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|Progname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|which
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|logfname
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
name|lfsuffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|logfname
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|logfile
operator|=
name|fopen
argument_list|(
name|logfname
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|logfile
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|logfile
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_APPEND
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* v7 */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fileno
argument_list|(
name|logfile
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* v7 */
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s\t%s\t%s: %s\n"
argument_list|,
name|logtime
argument_list|,
name|header
operator|.
name|ident
index|[
literal|0
index|]
condition|?
name|header
operator|.
name|ident
else|:
name|username
argument_list|,
name|Progname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s\t%s\t%s\n"
argument_list|,
name|logtime
argument_list|,
name|rmtsys
argument_list|,
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/*  * vmslink allows simulation of file linking under VMS.  */
end_comment

begin_macro
name|vmslink
argument_list|(
argument|infile
argument_list|,
argument|outfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|,
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|outfile
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * vmsdelete deletes all revisions of a file.  It attempts to  * appear as unlink(2) under conventional Unix in other respects.  */
end_comment

begin_macro
name|vmsdelete
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|i
operator|=
name|errno
expr_stmt|;
while|while
condition|(
name|unlink
argument_list|(
name|file
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|errno
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Convert a Unix file to a VMS fixed record format file by  * executing the 'unixtovms' command.  */
end_comment

begin_macro
name|unixtovms
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"exec /etc/unixtovms %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|system
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Convert a VMS fixed record format file to a Unix file by  * executing the 'vmstounix' command.  */
end_comment

begin_macro
name|vmstounix
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"exec /etc/vmstounix %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|system
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
end_if

begin_comment
comment|/*  * make a directory. Also make sure that the directory is owned  * by the right userid  */
end_comment

begin_macro
name|mkdir
argument_list|(
argument|path
argument_list|,
argument|perm
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|perm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|USG
name|char
name|parent
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* 	 * Make parent directory writable, because we will 	 * be creating a directory owned by the real user, 	 * rather than by news. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|parent
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|rindex
argument_list|(
name|parent
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|parent
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|parent
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
name|status
operator|=
name|fwait
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CHEAP
argument_list|)
if|if
condition|(
name|pid
operator|=
name|vfork
argument_list|()
condition|)
operator|(
name|void
operator|)
name|fwait
argument_list|(
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|path
argument_list|,
name|duid
argument_list|,
name|dgid
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|path
argument_list|,
name|perm
operator|&
operator|(
operator|~
name|N_UMASK
operator|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USG&& !CHEAP */
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|dgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|duid
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|umask
argument_list|(
name|perm
operator|&
name|N_UMASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execlp
argument_list|(
literal|"mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USG
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|parent
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
comment|/* Restore mode of parent */
endif|#
directive|endif
return|return
name|status
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD4_2&& ! BSD4_1C */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_function
name|char
modifier|*
name|strpbrk
parameter_list|(
name|str
parameter_list|,
name|chars
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|chars
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
do|do
block|{
name|cp
operator|=
name|chars
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
operator|*
name|cp
condition|)
return|return
name|str
return|;
block|}
block|}
do|while
condition|(
operator|*
name|str
operator|++
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FASCIST
end_ifdef

begin_comment
comment|/*  *  This routine checks to see if the posting user is allowed to  *  post to the given newsgroup.  If the username is not in the file  *  $LIBDIR/authorized then the default in the symbol FASCIST is used.  *  *  Format of the call:  *     fascist(user, newgroups)  *  *  Returns:  *     FALSE, if authorized  *     TRUE, if not  *  *  Format of the file "authorized" is:  *    user:allowed groups    *  *  Example:  *    root:net.all,mod.all  *    naughty_person:junk,net.politics  *    operator:!net.all,general,test,mod.unix  *  *  An open environment could have FASCIST set to "all"  *  and then individual entries could be made in the authorized file  *  to prevent certain individuals from posting to such a wide  *  area.  *  *  Note that a distribution of "all" does NOT mean to allow postings  *  only to local groups -- "all" includes "all.all".    *  Use "all,!all.all" to get this behavior  *  *	Eugene Spafford		spaf@gatech	May 22, 1985  */
end_comment

begin_expr_stmt
name|fascist
argument_list|(
name|user
argument_list|,
name|newsgroups
argument_list|)
specifier|register
name|char
operator|*
name|user
operator|,
operator|*
name|newsgroups
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FILE
modifier|*
name|facfd
decl_stmt|;
name|char
name|facuser
index|[
name|BUFLEN
index|]
decl_stmt|,
name|facgroups
index|[
name|BUFLEN
index|]
decl_stmt|,
name|factemp
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|facptr
decl_stmt|;
comment|/* First, open the necessary file...$LIBDIR/authorized and see if there 	 * is an entry for this user  	 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|facgroups
argument_list|,
name|FASCIST
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|factemp
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"authorized"
argument_list|)
expr_stmt|;
name|facfd
operator|=
name|fopen
argument_list|(
name|factemp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|facfd
operator|!=
name|NULL
condition|)
block|{
comment|/* If no such file, we go with the global default */
while|while
condition|(
name|fscanf
argument_list|(
name|facfd
argument_list|,
literal|"%[^:]:%s\n"
argument_list|,
name|facuser
argument_list|,
name|factemp
argument_list|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|facfd
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|facuser
argument_list|,
name|user
argument_list|,
name|BUFLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|facgroups
argument_list|,
literal|","
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|facgroups
argument_list|,
name|factemp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|facfd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"facgroups = %s\n"
argument_list|,
name|facgroups
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"newsgroups = %s\n"
argument_list|,
name|newsgroups
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* We step through the newsgroups being posted to and check each against 	 * the restriction list.  *ALL* posted groups must match the restriction 	 * list or we don't allow the posting. 	 */
while|while
condition|(
operator|*
name|newsgroups
operator|!=
literal|'\0'
condition|)
block|{
name|facptr
operator|=
name|factemp
expr_stmt|;
while|while
condition|(
operator|*
name|newsgroups
operator|!=
literal|'\0'
operator|&&
operator|*
name|newsgroups
operator|!=
name|NGDELIM
condition|)
operator|*
name|facptr
operator|++
operator|=
operator|*
name|newsgroups
operator|++
expr_stmt|;
operator|*
name|facptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|newsgroups
operator|==
name|NGDELIM
condition|)
name|newsgroups
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking newsgroup '%s'\n"
argument_list|,
name|factemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ngmatch
argument_list|(
name|factemp
argument_list|,
name|facgroups
argument_list|)
operator|==
name|FALSE
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* must be okay -- return */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Newsgroups approved for this poster.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|FALSE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FASCIST */
end_comment

end_unit

