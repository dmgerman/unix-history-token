begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * recnews [to newsgroup] [from user] [approved by]  *  * Process a news article which has been mailed to some group like msgs.  * Such articles are in normal mail format and have never seen the insides  * of netnews.  If the "to newsgroup" is included, the article is posted  * to this newsgroup instead of trying to intuit it from the headers.  * If the "from user" is included, the return address is forged to look  * like that user instead of what getuid or a from line says.  *  * It is recommended that you always include the to newsgroup, since the  * intuition code is flakey and out of date.  The from user is probably  * appropriate for arpanet mailing lists being funnelled at ucbvax but  * not otherwise.  Sample lines in /usr/lib/aliases (if you run delivermail):  *	worldnews: "|/usr/lib/news/recnews net.general"  *		Allows you to mail to worldnews rather than using inews.  *		Intended for humans to mail to.  *	post-unix-wizards: "|/usr/lib/news/recnews fa.unix-wizards unix-wizards"  *		Causes mail to post-unix-wizards to be fed into fa.unix-wizards  *		and the return address forged as unix-wizards on the local  *		machine.  post-unix-wizards (on the local machine) should  *		be part of the master mailing list somewhere (on a different  *		machine.)  *	in-gamemasters: "|/usr/lib/news/recnews mail.gamemasters '' news"  *  * Recnews is primarily useful in remote places on the usenet which collect  * mail from mailing lists and funnel them into the network.  It is also  * useful if you like to send mail to some user instead of invoking  * inews -t .. -n .. when you want to submit an article.  (Many mailers give  * you nice facilities like editing the message.)  It is not, however,  * essential to use recnews to be able to join usenet.  *  * WARNING: recnews disables the "recording" check - it has to because  * by the time inews is run, it's in the background and too late to  * ask permission.  If you depend heavily on recordings you probably  * should not allow recnews (and thus the mail interface) to be used.  *  * 1) We leave the from line alone.  Just escape the double quotes, but let the  *    mailer do the rest.  * 2) We give precedence to "From:" over "From " or ">From " in determining  *    who the article is really from.  *    Modifications by rad@tek  *  * John@ODU.EDU: add third argument to cause inews to be invoked with -a,  *		 for use with local groups for mailing lists with 2.11.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)recnews.c	2.14	10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/*  * Note: we assume there are 2 kinds of hosts using recnews:  * Those that have delivermail (and hence this program will never  * have to deal with more than one message at a time) and those on the arpanet  * that do not (and hence all messages end with a sentinel).  It is  * supposed that regular v7 type systems without delivermail or some  * other automatic forwarding device will just use rnews.  We do  * not attempt to tell where a message ends on all systems due to the  * different conventions in effect.  (This COULD be fixed, I suppose.)  */
end_comment

begin_comment
comment|/*  * Kinds of lines in a message.  */
end_comment

begin_define
define|#
directive|define
name|FROM
value|001
end_define

begin_comment
comment|/* From line */
end_comment

begin_define
define|#
directive|define
name|SUBJ
value|002
end_define

begin_comment
comment|/* Subject */
end_comment

begin_define
define|#
directive|define
name|TO
value|003
end_define

begin_comment
comment|/* To (newgroup based on this) */
end_comment

begin_define
define|#
directive|define
name|BLANK
value|004
end_define

begin_comment
comment|/* blank line */
end_comment

begin_define
define|#
directive|define
name|EOM
value|005
end_define

begin_comment
comment|/* End of message (4 ctrl A's) */
end_comment

begin_define
define|#
directive|define
name|HEADER
value|006
end_define

begin_comment
comment|/* any unrecognized header */
end_comment

begin_define
define|#
directive|define
name|TEXT
value|007
end_define

begin_comment
comment|/* anything unrecognized */
end_comment

begin_define
define|#
directive|define
name|INCLUSIVE
value|010
end_define

begin_comment
comment|/* newsgroup is already in header */
end_comment

begin_comment
comment|/*  * Possible states program can be in.  */
end_comment

begin_define
define|#
directive|define
name|SKIPPING
value|0100
end_define

begin_comment
comment|/* In header of message */
end_comment

begin_define
define|#
directive|define
name|READING
value|0200
end_define

begin_comment
comment|/* In body of message */
end_comment

begin_define
define|#
directive|define
name|BFSZ
value|250
end_define

begin_define
define|#
directive|define
name|EOT
value|'\004'
end_define

begin_decl_stmt
name|char
name|from
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mailing address for replies */
end_comment

begin_decl_stmt
name|char
name|sender
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mailing address of author, if different */
end_comment

begin_decl_stmt
name|char
name|to
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination of mail (msgs, etc) */
end_comment

begin_decl_stmt
name|char
name|subject
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subject of message */
end_comment

begin_decl_stmt
name|char
name|newsgroup
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* newsgroups of message */
end_comment

begin_decl_stmt
name|char
name|approved
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Approved: */
end_comment

begin_decl_stmt
name|int
name|fromset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from passed on command line */
end_comment

begin_decl_stmt
name|char
name|cmdbuf
index|[
name|BFSZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command to popen */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcat
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|any
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BFSZ
index|]
decl_stmt|,
name|inews
index|[
name|BFSZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|pipe
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
comment|/* build inews command */
ifdef|#
directive|ifdef
name|LOGDIR
name|sprintf
argument_list|(
name|inews
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|LIBDIR
argument_list|,
literal|"inews"
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|inews
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIBDIR
argument_list|,
literal|"inews"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|strcpy
argument_list|(
name|to
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|strcpy
argument_list|(
name|from
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
operator|&&
operator|*
name|argv
index|[
literal|3
index|]
condition|)
block|{
name|sprintf
argument_list|(
name|approved
argument_list|,
literal|"-a %s"
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Flag that we know who message is from to avoid trying to  	 * decipher the From line. 	 */
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
operator|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
name|fromset
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|debug
name|printf
argument_list|(
literal|"argv[0] is<%s>, argv[1] is<%s>, argv[2] is<%s>\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|SKIPPING
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BFSZ
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|READING
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|type
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
name|FROM
case|:
name|frombreak
argument_list|(
name|buf
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBJ
case|:
name|p
operator|=
name|any
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
operator|+
literal|8
expr_stmt|;
name|q
operator|=
name|subject
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|TO
case|:
if|if
condition|(
name|to
index|[
literal|0
index|]
condition|)
break|break;
comment|/* already have one */
name|p
operator|=
name|any
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
operator|+
literal|3
expr_stmt|;
name|q
operator|=
name|to
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|INCLUSIVE
case|:
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"exec %s -p"
argument_list|,
name|inews
argument_list|)
expr_stmt|;
name|pipe
operator|=
name|popen
argument_list|(
name|cmdbuf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"recnews: open failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|READING
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Kludge to compensate for messages without real headers 		 */
case|case
name|HEADER
case|:
break|break;
case|case
name|BLANK
case|:
name|state
operator|=
name|READING
expr_stmt|;
name|strcpy
argument_list|(
name|newsgroup
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"exec %s -t \"%s\" -n \"%s\" -f \"%s\" %s"
argument_list|,
name|inews
argument_list|,
operator|*
name|subject
condition|?
name|subject
else|:
literal|"(none)"
argument_list|,
name|newsgroup
argument_list|,
name|from
argument_list|,
operator|*
name|approved
condition|?
name|approved
else|:
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|debug
name|pipe
operator|=
name|stdout
expr_stmt|;
name|printf
argument_list|(
literal|"BLANK: %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|pipe
operator|=
name|popen
argument_list|(
name|cmdbuf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"recnews: popen failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sender
index|[
literal|0
index|]
condition|)
block|{
name|fputs
argument_list|(
name|sender
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEXT
case|:
name|strcpy
argument_list|(
name|newsgroup
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|state
operator|=
name|READING
expr_stmt|;
if|if
condition|(
name|subject
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|subject
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|subject
index|[
name|strlen
argument_list|(
name|subject
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|subject
index|[
name|strlen
argument_list|(
name|subject
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"exec \"%s\" -t \"%s\" -n \"%s\" -f \"%s\" %s"
argument_list|,
name|inews
argument_list|,
name|subject
argument_list|,
name|newsgroup
argument_list|,
name|from
argument_list|,
operator|*
name|approved
condition|?
name|approved
else|:
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|debug
name|pipe
operator|=
name|stdout
expr_stmt|;
name|printf
argument_list|(
literal|"TEXT: %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|pipe
operator|=
name|popen
argument_list|(
name|cmdbuf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"pipe failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sender
index|[
literal|0
index|]
condition|)
block|{
name|fputs
argument_list|(
name|sender
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|type
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|firstbl
decl_stmt|;
specifier|static
name|char
name|lasthdr
init|=
literal|1
decl_stmt|;
comment|/* prev line was a header */
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
operator|&&
name|lasthdr
condition|)
return|return
name|HEADER
return|;
comment|/* continuation line */
name|firstbl
operator|=
name|any
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|0
condition|)
return|return
name|BLANK
return|;
if|if
condition|(
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|">From"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FROM
return|;
if|if
condition|(
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|"Subj"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|"Re:"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|"re:"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SUBJ
return|;
if|if
condition|(
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|"To"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TO
return|;
if|if
condition|(
name|STRNCMP
argument_list|(
name|p
argument_list|,
literal|"\1\1\1\1"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EOM
return|;
if|if
condition|(
name|firstbl
operator|&&
name|firstbl
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|HEADER
return|;
name|lasthdr
operator|=
literal|0
expr_stmt|;
return|return
name|TEXT
return|;
block|}
end_block

begin_comment
comment|/*  * Figure out who a message is from.  */
end_comment

begin_expr_stmt
name|frombreak
argument_list|(
name|buf
argument_list|,
name|fbuf
argument_list|)
specifier|register
name|char
operator|*
name|buf
operator|,
operator|*
name|fbuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|fbuf
index|[
literal|0
index|]
operator|&&
name|fromset
condition|)
block|{
comment|/* we already know who it's from */
if|if
condition|(
name|sender
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|buf
index|[
literal|4
index|]
operator|==
literal|':'
condition|)
block|{
ifdef|#
directive|ifdef
name|debug
name|printf
argument_list|(
literal|"sender set to: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|sender
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Leave fancy Froms alone - this parsing is done by mail 	 * Just quote the double quotes to prevent interpetation  	 * by the shell. 	 * rad@tek 	 */
name|p
operator|=
name|any
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
name|q
operator|=
name|fbuf
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|fbuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|':'
condition|)
name|fromset
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return the ptr in sp at which a character in sq appears;  * NULL if not found  *  */
end_comment

begin_function
name|char
modifier|*
name|any
parameter_list|(
name|sp
parameter_list|,
name|sq
parameter_list|)
name|char
modifier|*
name|sp
decl_stmt|,
decl|*
name|sq
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|c1
operator|,
name|c2
expr_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|c1
operator|=
operator|*
name|sp
operator|++
condition|)
block|{
name|q
operator|=
name|sq
expr_stmt|;
while|while
condition|(
name|c2
operator|=
operator|*
name|q
operator|++
condition|)
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
operator|(
operator|--
name|sp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

end_unit

