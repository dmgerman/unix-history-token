begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * rfuncs - functions for readnews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)rfuncs.c	2.42	10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_decl_stmt
name|char
name|lentab
index|[
name|LINES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of newsgroupname for each rcline */
end_comment

begin_decl_stmt
name|long
name|nngsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next upcoming value of ngsize. */
end_comment

begin_decl_stmt
name|long
name|nminartno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Smallest article number in this group */
end_comment

begin_decl_stmt
name|int
name|BITMAPSIZE
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|nextng
argument_list|()
end_macro

begin_block
block|{
name|long
name|curpos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextng()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curpos
operator|=
name|ftell
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|next
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"next:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
block|{
if|if
condition|(
name|back
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|back
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|nngsize
argument_list|,
operator|&
name|nminartno
argument_list|)
operator|<
literal|3
condition|)
block|{
name|bfr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nngsize
operator|=
literal|0
expr_stmt|;
name|nminartno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bfr = '%s'\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|bfr
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|xflag
condition|)
name|readmode
operator|=
name|SPEC
expr_stmt|;
else|else
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
name|selectng
argument_list|(
name|bfr
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
goto|goto
name|next
goto|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|selectng
argument_list|(
argument|name
argument_list|,
argument|fastcheck
argument_list|,
argument|resubscribe
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
name|punct
init|=
literal|','
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|cur
decl_stmt|;
name|long
name|next
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|af
decl_stmt|;
name|long
name|s
decl_stmt|,
name|sm
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
name|n
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selectng: groupdir = %s\n"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|*
name|groupdir
condition|)
name|updaterc
argument_list|()
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|STRCMP
argument_list|(
name|name
argument_list|,
name|bfr
argument_list|)
condition|)
block|{
name|af
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|af
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %ld %ld"
argument_list|,
name|n
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|sm
argument_list|)
operator|==
literal|3
operator|&&
name|STRCMP
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ngsize
operator|=
name|s
expr_stmt|;
name|minartno
operator|=
name|sm
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|af
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ngsize
operator|=
name|nngsize
expr_stmt|;
name|minartno
operator|=
name|nminartno
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selectng(%s) sets ngsize to %ld, minartno to %ld\n"
argument_list|,
name|name
argument_list|,
name|ngsize
argument_list|,
name|minartno
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|i
operator|=
name|findrcline
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|resubscribe
condition|)
block|{
case|case
name|FALSE
case|:
name|groupdir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TRUE
case|:
operator|*
name|p
operator|=
literal|':'
expr_stmt|;
break|break;
case|case
name|PERHAPS
case|:
name|zapng
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
comment|/* shouldn't happen */
name|p
operator|=
name|rcline
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|==
literal|' '
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s%s%ld"
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'\0'
condition|?
literal|" "
else|:
literal|","
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"ng: %ld"
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"ng: %ld"
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rcbuf set to %s\n"
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Fast check for common case: 1-### 	 */
if|if
condition|(
name|fastcheck
condition|)
block|{
name|p
operator|=
name|rcbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'1'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'-'
condition|)
block|{
name|cur
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|cur
operator|=
literal|10
operator|*
name|cur
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|&&
name|cur
operator|==
name|ngsize
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Group: %s, all read\n"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|groupdir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|cur
operator|>
name|ngsize
condition|)
block|{
comment|/* 				 * Claim to have read articles 				 * which "active" believes have 				 * never existed - we believe "active" 				 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s...\r\n\t%s %ld to %ld\r\n"
argument_list|,
literal|"Warning: newsgroup"
argument_list|,
name|groupdir
argument_list|,
literal|"last article claimed read reset from"
argument_list|,
name|cur
argument_list|,
name|ngsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * The key to understanding this piece of code is that a bit is set iff  * that article has NOT been read.  Thus, we fill in the holes when  * commas are found (e.g. 1-20,30-35 will result in filling in the 21-29  * holes), and so we assume the newsrc file is properly ordered, the way  * we write it out.  */
if|if
condition|(
operator|(
name|ngsize
operator|-
name|minartno
operator|)
operator|>
name|BITMAPSIZE
condition|)
block|{
comment|/* resize the bitmap array */
operator|(
name|void
operator|)
name|free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|BITMAPSIZE
operator|=
literal|8
operator|*
operator|(
operator|(
operator|(
name|ngsize
operator|-
name|minartno
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|bitmap
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|BITMAPSIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't malloc bitmap"
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|bitmap
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ngsize
operator|-
name|minartno
argument_list|)
operator|/
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 8 bits per character */
comment|/* Decode the .newsrc line indicating what we have read. */
for|for
control|(
name|ptr
operator|=
name|rcbuf
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|':'
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
while|while
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|punct
operator|==
literal|','
condition|)
block|{
while|while
condition|(
operator|++
name|cur
operator|<
name|next
condition|)
block|{
name|set
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
name|cur
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|!
name|ispunct
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
name|punct
operator|=
operator|*
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|rflag
condition|)
name|bit
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
else|else
name|bit
operator|=
name|minartno
operator|-
literal|1
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TMAIL
end_ifdef

begin_macro
name|catchterm
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The -M (Mail) interface.  This code is a reasonably simple model for  * writing other interfaces.  We write out all relevant articles to  * a temp file, then invoke Mail with an option to have it tell us which  * articles it read.  Finally we count those articles as really read.  */
end_comment

begin_macro
name|Mail
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|,
modifier|*
name|ofp
decl_stmt|;
name|struct
name|hbuf
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|int
name|isnews
init|=
name|FALSE
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
condition|;
name|i
operator|++
control|)
name|h
operator|.
name|unrec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|outfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|&&
operator|*
name|datebuf
condition|)
if|if
condition|(
operator|(
name|atime
operator|=
name|cgtdate
argument_list|(
name|datebuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Cannot parse date string"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nextng
argument_list|()
condition|)
while|while
condition|(
name|bit
operator|<=
name|ngsize
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER
if|if
condition|(
operator|(
name|fp
operator|=
name|getarticle
argument_list|(
name|groupdir
argument_list|,
name|bit
argument_list|,
literal|"ARTICLE"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|article_name
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad article '%s/%d'\n"
argument_list|,
name|groupdir
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
comment|/* !SERVER */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%ld"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
literal|4
argument_list|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|art_open
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|!
name|aselect
argument_list|(
operator|&
name|h
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad article '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|fname
operator|=
name|ptr
operator|=
name|index
argument_list|(
name|h
operator|.
name|from
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
while|while
condition|(
name|ptr
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|--
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|fname
operator|++
expr_stmt|;
name|ptr
operator|=
name|fname
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|')'
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
name|h
operator|.
name|subtime
operator|=
name|cgtdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"From %s %s"
argument_list|,
ifdef|#
directive|ifdef
name|INTERNET
name|h
operator|.
name|from
index|[
literal|0
index|]
condition|?
name|h
operator|.
name|from
else|:
endif|#
directive|endif
name|h
operator|.
name|path
argument_list|,
name|ctime
argument_list|(
operator|&
name|h
operator|.
name|subtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Full-Name: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|h
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|h
operator|.
name|title
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article-ID: %s/%ld\n\n"
argument_list|,
name|groupdir
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|fp
argument_list|,
name|ofp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|isnews
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* get rid of temp file */
endif|#
directive|endif
comment|/* SERVER */
name|fp
operator|=
name|NULL
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
name|updaterc
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isnews
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No news.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catchterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|catchterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s -f %s -T %s"
argument_list|,
name|TMAIL
argument_list|,
name|outfile
argument_list|,
name|mktemp
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|ushell
argument_list|,
name|bfr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|nngsize
argument_list|)
operator|<
literal|2
condition|)
block|{
name|bfr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nngsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|bfr
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
continue|continue;
operator|*
name|groupdir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|selectng
argument_list|(
name|bfr
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ofp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|groupdir
argument_list|,
name|BUFLEN
argument_list|,
name|ofp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|nstrip
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|groupdir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|STRCMP
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|updaterc
argument_list|()
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|updaterc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
name|cur
init|=
literal|1
decl_stmt|,
name|next
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|oldptr
decl_stmt|;
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s%c "
argument_list|,
name|groupdir
argument_list|,
name|zapng
condition|?
literal|'!'
else|:
literal|':'
argument_list|)
expr_stmt|;
name|zapng
operator|=
name|FALSE
expr_stmt|;
name|again
label|:
name|ptr
operator|=
operator|&
name|rcbuf
index|[
name|strlen
argument_list|(
name|rcbuf
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|get
argument_list|(
name|next
argument_list|)
operator|&&
name|next
operator|<=
name|ngsize
condition|)
name|next
operator|++
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|get
argument_list|(
name|next
argument_list|)
operator|)
operator|&&
name|next
operator|<=
name|ngsize
condition|)
name|next
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|next
condition|)
block|{
name|next
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|cur
operator|+
literal|1
operator|==
name|next
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%ld"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%ld-%ld"
argument_list|,
name|cur
argument_list|,
name|next
operator|-
literal|1
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
operator|(
name|long
operator|)
name|next
operator|>
name|ngsize
condition|)
block|{
if|if
condition|(
name|strpbrk
argument_list|(
name|rcbuf
argument_list|,
literal|":!"
argument_list|)
operator|==
name|NULL
condition|)
comment|/* bad line, huh?? */
return|return;
name|ptr
operator|=
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
comment|/* impossible */
return|return;
name|ptr
operator|--
expr_stmt|;
name|oldptr
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|findrcline
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|ptr
index|[
literal|0
index|]
operator|=
name|oldptr
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|rcline
index|[
name|i
index|]
operator|=
name|realloc
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|rcbuf
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot realloc"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" new rcline = %s\n"
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
if|if
condition|(
operator|++
name|line
operator|>
name|LINES
condition|)
name|xerror
argument_list|(
literal|"Too many newsgroups"
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|oldptr
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|rcline
index|[
name|line
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|rcbuf
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rcline
index|[
name|line
index|]
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" new rcline2 = %s\n"
argument_list|,
name|rcline
index|[
name|line
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
name|cur
operator|=
name|next
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_macro
name|newrc
argument_list|(
argument|rcname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rcname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|close
argument_list|(
name|creat
argument_list|(
name|rcname
argument_list|,
literal|0666
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Cannot create %s"
argument_list|,
name|newsrc
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/users"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bfr
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|bfr
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextbit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextbit() bit = %ld\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|last
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|readmode
operator|==
name|SPEC
operator|||
name|xflag
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
name|bit
operator|--
expr_stmt|;
else|else
name|bit
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rflag
condition|)
while|while
condition|(
operator|--
name|bit
operator|,
operator|!
name|get
argument_list|(
name|bit
argument_list|)
operator|&&
name|bit
operator|>
name|minartno
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|bit
operator|,
operator|!
name|get
argument_list|(
name|bit
argument_list|)
operator|&&
name|bit
operator|<=
name|ngsize
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextng leaves bit as %ld\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_block

begin_comment
comment|/*  * Return TRUE if the user has not ruled out this article.  */
end_comment

begin_expr_stmt
name|aselect
argument_list|(
name|hp
argument_list|,
name|insist
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|insist
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|insist
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|tflag
operator|&&
operator|!
name|titmat
argument_list|(
name|hp
argument_list|,
name|header
operator|.
name|title
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|aflag
operator|&&
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
operator|<
name|atime
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|index
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
literal|','
argument_list|)
operator|&&
operator|!
name|rightgroup
argument_list|(
name|hp
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fflag
operator|&&
operator|(
name|hp
operator|->
name|followid
index|[
literal|0
index|]
operator|||
name|PREFIX
argument_list|(
name|hp
operator|->
name|title
argument_list|,
literal|"Re:"
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * Code to avoid showing multiple articles for news.  * Works even if you exit news.  * Returns nonzero if we should show this article.  */
end_comment

begin_macro
name|rightgroup
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ng
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flag
decl_stmt|;
name|strcpy
argument_list|(
name|ng
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|g
operator|=
name|ng
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|g
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|g
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|STRCMP
argument_list|(
name|g
argument_list|,
name|groupdir
argument_list|)
operator|==
literal|0
condition|)
return|return
name|flag
return|;
if|if
condition|(
name|ngmatch
argument_list|(
name|g
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
operator|&&
operator|(
operator|(
name|i
operator|=
name|findrcline
argument_list|(
name|g
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
name|g
operator|=
name|p
expr_stmt|;
block|}
comment|/* we must be in "junk" or "control" */
return|return
name|TRUE
return|;
block|}
end_block

begin_macro
name|back
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|fseek
argument_list|(
name|actfp
argument_list|,
operator|-
literal|2L
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ftell
argument_list|(
name|actfp
argument_list|)
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|actfp
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ftell
argument_list|(
name|actfp
argument_list|)
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Trap interrupts.  */
end_comment

begin_macro
name|onsig
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|n
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|SigTrap
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|rcreadok
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Aborted early\n"
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * finds the line in your .newsrc file (actually the in-core "rcline"  * copy of it) and returns the index into the array where it was found.  * -1 means it didn't find it.  *  * We play clever games here to make this faster.  It's inherently  * quadratic - we spend lots of CPU time here because we search through  * the whole .newsrc for each line.  The "prev" variable remembers where  * the last match was found; we start the search there and loop around  * to the beginning, in the hopes that the calls will be roughly in order.  */
end_comment

begin_function
name|int
name|findrcline
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|top
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|prev
decl_stmt|;
specifier|static
name|int
name|didthru
decl_stmt|;
for|for
control|(
init|;
name|didthru
operator|<=
name|line
condition|;
operator|++
name|didthru
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|didthru
index|]
argument_list|,
literal|'!'
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|didthru
index|]
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|lentab
index|[
name|didthru
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|rcline
index|[
name|didthru
index|]
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|top
operator|=
name|line
expr_stmt|;
name|i
operator|=
name|prev
expr_stmt|;
name|loop
label|:
for|for
control|(
init|;
name|i
operator|<=
name|top
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|lentab
index|[
name|i
index|]
operator|==
name|len
operator|&&
name|rcline
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|STRNCMP
argument_list|(
name|name
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|prev
operator|=
name|i
return|;
if|if
condition|(
name|i
operator|>
name|line
operator|&&
name|line
operator|>
name|prev
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|prev
operator|-
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * sortactive - make a local copy of the active file, sorted according  *   to the user's preferences, according to his .newsrc file.  */
end_comment

begin_struct
struct|struct
name|table_elt
block|{
name|int
name|rcindex
decl_stmt|;
name|long
name|maxart
decl_stmt|,
name|minart
decl_stmt|;
name|char
name|yn
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SORTACTIVE
end_ifdef

begin_function
specifier|static
name|int
name|rcsort
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
operator|(
operator|(
expr|struct
name|table_elt
operator|*
operator|)
name|a
operator|)
operator|->
name|rcindex
operator|-
operator|(
operator|(
expr|struct
name|table_elt
operator|*
operator|)
name|b
operator|)
operator|->
name|rcindex
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|newactivename
init|=
literal|"/tmp/newsaXXXXXX"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SORTACTIVE */
end_comment

begin_macro
name|sortactive
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|nfp
decl_stmt|,
modifier|*
name|afp
decl_stmt|;
name|char
name|aline
index|[
name|BUFLEN
index|]
decl_stmt|,
name|ngname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|struct
name|table_elt
name|table
index|[
name|LINES
index|]
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|delta
decl_stmt|,
name|lastline
decl_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
comment|/* make a new sorted copy of ACTIVE */
name|nfp
operator|=
name|fopen
argument_list|(
name|mktemp
argument_list|(
name|newactivename
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|newactivename
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|newactivename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* look up all the lines in ACTIVE, finding their positions in .newsrc */
name|p
operator|=
name|ACTIVE
expr_stmt|;
name|ACTIVE
operator|=
name|newactivename
expr_stmt|;
name|afp
operator|=
name|xfopen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SORTACTIVE */
name|afp
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SORTACTIVE */
name|tp
operator|=
name|table
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|aline
argument_list|,
sizeof|sizeof
name|aline
argument_list|,
name|afp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|aline
argument_list|,
literal|"%s %ld %ld %c"
argument_list|,
name|ngname
argument_list|,
operator|&
name|tp
operator|->
name|maxart
argument_list|,
operator|&
name|tp
operator|->
name|minart
argument_list|,
operator|&
name|tp
operator|->
name|yn
argument_list|)
operator|!=
literal|4
condition|)
name|xerror
argument_list|(
literal|"Active file corrupt"
argument_list|)
expr_stmt|;
name|delta
operator|=
name|tp
operator|->
name|maxart
operator|-
name|tp
operator|->
name|minart
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|BITMAPSIZE
condition|)
name|BITMAPSIZE
operator|=
name|delta
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Kflag
operator|&&
name|tp
operator|->
name|maxart
operator|>
literal|0
operator|&&
name|ngmatch
argument_list|(
name|ngname
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|j
operator|=
name|findrcline
argument_list|(
name|ngname
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|index
argument_list|(
name|rcline
index|[
name|j
index|]
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
name|rbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|maxart
operator|==
literal|1
condition|)
name|sprintf
argument_list|(
name|rbuf
argument_list|,
literal|"%s: 1"
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|rbuf
argument_list|,
literal|"%s: 1-%ld"
argument_list|,
name|ngname
argument_list|,
name|tp
operator|->
name|maxart
argument_list|)
expr_stmt|;
name|rcline
index|[
name|j
index|]
operator|=
name|realloc
argument_list|(
name|rcline
index|[
name|j
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|rbuf
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|j
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcline
index|[
name|j
index|]
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SORTACTIVE
name|tp
operator|->
name|rcindex
operator|=
name|findrcline
argument_list|(
name|ngname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|rcindex
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|line
operator|>
name|LINES
condition|)
name|xerror
argument_list|(
literal|"Too many newsgroups"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ngname
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|rcline
index|[
name|line
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|ngname
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|line
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcline
index|[
name|line
index|]
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcindex
operator|=
name|line
expr_stmt|;
block|}
name|tp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* SORTACTIVE */
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|afp
argument_list|)
expr_stmt|;
name|BITMAPSIZE
operator|=
literal|8
operator|*
operator|(
operator|(
name|BITMAPSIZE
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|bitmap
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|BITMAPSIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't malloc bitmap"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
comment|/* sort by position in user's .newsrc file (new groups come up last) */
name|nlines
operator|=
name|tp
operator|-
name|table
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
argument_list|,
name|nlines
argument_list|,
sizeof|sizeof
name|table
index|[
literal|0
index|]
argument_list|,
name|rcsort
argument_list|)
expr_stmt|;
name|tp
operator|=
name|table
expr_stmt|;
name|lastline
operator|=
name|tp
operator|->
name|rcindex
operator|-
literal|1
expr_stmt|;
comment|/* copy active to newactive, in the new order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|++
name|lastline
operator|<
name|tp
operator|->
name|rcindex
condition|)
block|{
if|if
condition|(
name|STRNCMP
argument_list|(
name|rcline
index|[
name|lastline
index|]
argument_list|,
literal|"options "
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|nfp
argument_list|,
literal|"%s\n"
argument_list|,
name|rcline
index|[
name|lastline
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate .newsrc line or bad group %s\n"
argument_list|,
name|rcline
index|[
name|lastline
index|]
argument_list|)
expr_stmt|;
name|lentab
index|[
name|lastline
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|rcline
index|[
name|lastline
index|]
argument_list|)
expr_stmt|;
name|rcline
index|[
name|lastline
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rcline
index|[
name|tp
operator|->
name|rcindex
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|rcline
index|[
name|tp
operator|->
name|rcindex
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'!'
condition|)
name|fputc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|nfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|nfp
argument_list|,
literal|" %ld %ld %c\n"
argument_list|,
name|tp
operator|->
name|maxart
argument_list|,
name|tp
operator|->
name|minart
argument_list|,
name|tp
operator|->
name|yn
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SORTACTIVE */
block|}
end_block

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL_ADDRESS_SPACE
end_ifdef

begin_macro
name|list_group
argument_list|(
argument|lgroup
argument_list|,
argument|displines
argument_list|,
argument|flag
argument_list|,
argument|pngsize
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lgroup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|displines
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|pngsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"Not enough memory on your machine to include this function.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMALL_ADDRESS_SPACE */
end_comment

begin_comment
comment|/*  * Routine to display header lines for all articles in newsgroup. If the flag  * argument is FALSE then only articles which are not marked as read in the  * bitmap will be displayed. This routine makes no attempt to determine if  * the article is in multiple groups and therefore should not be displayed at  * this time.   */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|lg_array
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|lg_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lg_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|int_sig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_macro
name|lg_cmp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|*
name|p1
operator|-
operator|*
name|p2
return|;
block|}
end_block

begin_macro
name|list_group
argument_list|(
argument|lgroup
argument_list|,
argument|displines
argument_list|,
argument|flag
argument_list|,
argument|pngsize
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lgroup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|displines
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|pngsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|briefdate
parameter_list|()
function_decl|;
name|struct
name|hbuf
name|hh
decl_stmt|;
ifndef|#
directive|ifndef
name|SERVER
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dir
decl_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
specifier|register
name|FILE
modifier|*
name|fp_art
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|unsigned
name|int
name|alloc_size
decl_stmt|;
name|int
function_decl|(
modifier|*
name|old_sig
function_decl|)
parameter_list|()
function_decl|;
extern|extern lg_trap(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|char
modifier|*
name|gets
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER
end_ifdef

begin_decl_stmt
name|int
name|lowgp
decl_stmt|,
name|highgp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|workspace
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|*
name|lgroup
operator|==
literal|' '
operator|||
operator|*
name|lgroup
operator|==
literal|'\0'
condition|)
return|return;
end_if

begin_expr_stmt
name|strcpy
argument_list|(
name|workspace
argument_list|,
name|set_group
argument_list|(
name|lgroup
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|workspace
operator|!=
name|CHAR_OK
condition|)
block|{
name|printf
argument_list|(
literal|"Group %s is invalid: \n%s\n"
argument_list|,
name|lgroup
argument_list|,
name|workspace
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_comment
comment|/* We assume that the server will return a line of this format */
end_comment

begin_expr_stmt
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|workspace
argument_list|,
literal|"%s %ld %ld %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|lowgp
argument_list|,
operator|&
name|highgp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"There are no articles in %s\n"
argument_list|,
name|lgroup
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SERVER */
end_comment

begin_comment
comment|/* This should get the numbers from the active file XXX */
end_comment

begin_if
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|(
name|lgroup
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Can't open %s\r\n"
argument_list|,
name|dirname
argument_list|(
name|lgroup
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SERVER */
end_comment

begin_expr_stmt
name|entries
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lg_array
operator|==
name|NULL
condition|)
block|{
name|lg_max
operator|=
literal|50
expr_stmt|;
name|alloc_size
operator|=
name|lg_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|lg_array
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER
end_ifdef

begin_for
for|for
control|(
name|i
operator|=
name|lowgp
init|;
name|i
operator|<
name|highgp
condition|;
name|i
operator|++
control|)
block|{
else|#
directive|else
comment|/* !SERVER */
while|while
condition|(
operator|(
name|dir
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
name|i
operator|=
name|atoi
argument_list|(
name|dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
if|if
condition|(
operator|(
name|i
operator|<
literal|1
operator|)
operator|||
operator|(
name|i
operator|>
name|pngsize
operator|)
condition|)
continue|continue;
if|if
condition|(
name|flag
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|get
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
operator|++
name|entries
operator|>
name|lg_max
condition|)
block|{
name|lg_max
operator|+=
literal|50
expr_stmt|;
name|alloc_size
operator|=
name|lg_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|lg_array
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lg_array
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
block|}
name|lg_array
index|[
name|entries
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|entries
operator|==
name|lg_max
condition|)
block|{
name|lg_max
operator|++
expr_stmt|;
name|alloc_size
operator|=
name|lg_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|lg_array
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lg_array
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|lg_array
argument_list|,
name|entries
argument_list|,
sizeof|sizeof
expr|*
name|lg_array
argument_list|,
name|lg_cmp
argument_list|)
expr_stmt|;
name|lg_array
index|[
name|entries
index|]
operator|=
literal|0
expr_stmt|;
name|int_sig
operator|=
literal|0
expr_stmt|;
name|old_sig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|lg_trap
argument_list|)
expr_stmt|;
name|hh
operator|.
name|unrec
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lg_entry
operator|=
name|lg_array
init|;
operator|*
name|lg_entry
operator|!=
literal|0
operator|&&
name|int_sig
operator|==
literal|0
condition|;
name|lg_entry
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SERVER
comment|/* we'll see if just getting the header will work here */
if|if
condition|(
operator|(
name|fp_art
operator|=
name|getarticle
argument_list|(
name|lgroup
argument_list|,
operator|*
name|lg_entry
argument_list|,
literal|"HEAD"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|article_name
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_art
argument_list|)
expr_stmt|;
name|fp_art
operator|=
name|NULL
expr_stmt|;
block|}
else|else
continue|continue;
else|#
directive|else
comment|/* !SERVER */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%d"
argument_list|,
name|dirname
argument_list|(
name|lgroup
argument_list|)
argument_list|,
operator|*
name|lg_entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
name|fp_art
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_art
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|hh
argument_list|,
name|fp_art
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_art
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%5d %-20.20s %-13s  %s\r\n"
argument_list|,
operator|*
name|lg_entry
argument_list|,
name|hh
operator|.
name|from
argument_list|,
name|briefdate
argument_list|(
name|hh
operator|.
name|subdate
argument_list|)
argument_list|,
name|hh
operator|.
name|title
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|displines
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|LBUFLEN
argument_list|,
name|fp_art
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|bfr
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|bfr
index|[
literal|0
index|]
operator|==
literal|'>'
operator|)
condition|)
block|{
continue|continue;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_art
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER */
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SERVER
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SERVER */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_sig
argument_list|)
expr_stmt|;
comment|/* restore to old value */
name|printf
argument_list|(
literal|"[Press RETURN to continue]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|'\n'
operator|||
name|i
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|'\4'
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
name|lg_array
argument_list|)
expr_stmt|;
name|lg_array
operator|=
name|NULL
expr_stmt|;
block|}
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMALL_ADDRESS_SPACE */
end_comment

begin_macro
name|lg_trap
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int_sig
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|code
argument_list|,
name|lg_trap
argument_list|)
expr_stmt|;
comment|/* reset signal */
block|}
end_block

end_unit

