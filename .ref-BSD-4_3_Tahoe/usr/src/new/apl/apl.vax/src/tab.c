begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|tab_c_Sccsid
index|[]
init|=
literal|"tab.c @(#)tab.c	1.3	10/5/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This table defines the operators in APL\11.  * The first entry is the character representing  * the operator, the second is the unique operator  * identifier (which should give you a hint as  * to what the operator is), and the third is  * the operator type, of interest only to the  * interpreter.  * Those characters represented by octal numbers are actually  * two-character overstrikes.  Ignore the leading "2", and  * the rest of the number is an index into "chartab", below,  * which lists the two-character overstrikes.  Overstrikes  * may be in either order.  *  * Note: What isn't shown here is that unary minus  * is ` (backwards apostrophe).  This is handled in lex.c, a0.c  * and a2.c (both input and output).  */
end_comment

begin_struct
struct|struct
name|tab
block|{
name|int
name|input
decl_stmt|;
name|int
name|lexval
decl_stmt|;
name|int
name|retval
decl_stmt|;
block|}
name|tab
index|[]
init|=
block|{
comment|/*  * one of a kind  */
literal|'('
block|,
name|unk
block|,
name|lpar
block|,
literal|')'
block|,
name|unk
block|,
name|rpar
block|,
literal|'['
block|,
name|unk
block|,
name|lbkt
block|,
literal|']'
block|,
name|unk
block|,
name|rbkt
block|,
literal|'/'
block|,
name|COM
block|,
name|com
block|,
literal|0200
block|,
name|COM0
block|,
name|com0
block|,
literal|'\\'
block|,
name|EXD
block|,
name|com
block|,
literal|0201
block|,
name|EXD0
block|,
name|com0
block|,
literal|'\''
block|,
name|unk
block|,
name|strng
block|,
literal|'J'
block|,
name|unk
block|,
name|null
block|,
literal|'.'
block|,
name|IPROD
block|,
name|dot
block|,
literal|'L'
block|,
name|QUAD
block|,
name|Quad
block|,
literal|0202
block|,
name|QQUAD
block|,
name|Quad
block|,
literal|0203
block|,
name|CQUAD
block|,
name|Quad
block|,
literal|';'
block|,
name|unk
block|,
name|semi
block|,
literal|':'
block|,
name|unk
block|,
name|cln
block|,
literal|0204
block|,
name|COMNT
block|,
name|comnt
block|,
literal|'C'
block|,
name|COMNT
block|,
name|comnt
block|,
literal|'}'
block|,
name|BRAN0
block|,
name|tran
block|,
comment|/*  * dyadic scalars  *	op2 op1 v (dyadic op)  */
literal|'<'
block|,
name|LT
block|,
name|dscal
block|,
literal|'>'
block|,
name|GT
block|,
name|dscal
block|,
literal|'$'
block|,
name|LE
block|,
name|dscal
block|,
literal|0220
block|,
name|LE
block|,
name|dscal
block|,
literal|'&'
block|,
name|GE
block|,
name|dscal
block|,
literal|0221
block|,
name|GE
block|,
name|dscal
block|,
literal|'='
block|,
name|EQ
block|,
name|dscal
block|,
literal|'#'
block|,
name|NE
block|,
name|dscal
block|,
literal|0222
block|,
name|NE
block|,
name|dscal
block|,
literal|'^'
block|,
name|AND
block|,
name|dscal
block|,
literal|'A'
block|,
name|AND
block|,
name|dscal
block|,
literal|'Q'
block|,
name|OR
block|,
name|dscal
block|,
literal|'V'
block|,
name|OR
block|,
name|dscal
block|,
literal|0205
block|,
name|NAND
block|,
name|dscal
block|,
literal|0231
block|,
name|NAND
block|,
name|dscal
block|,
literal|0206
block|,
name|NOR
block|,
name|dscal
block|,
literal|0223
block|,
name|NAND
block|,
name|dscal
block|,
literal|0224
block|,
name|NOR
block|,
name|dscal
block|,
comment|/*  * monadic or dyadic scalars  *	op2 op1 v (dyadic op)  *	op1 v+1 (monadic op)  */
literal|'+'
block|,
name|ADD
block|,
name|mdscal
block|,
literal|'-'
block|,
name|SUB
block|,
name|mdscal
block|,
literal|'M'
block|,
name|MUL
block|,
name|mdscal
block|,
literal|'X'
block|,
name|MUL
block|,
name|mdscal
block|,
literal|0225
block|,
name|MUL
block|,
name|mdscal
block|,
literal|'P'
block|,
name|DIV
block|,
name|mdscal
block|,
literal|0240
block|,
name|DIV
block|,
name|mdscal
block|,
literal|'%'
block|,
name|DIV
block|,
name|mdscal
block|,
literal|0226
block|,
name|DIV
block|,
name|mdscal
block|,
literal|'|'
block|,
name|MOD
block|,
name|mdscal
block|,
literal|'D'
block|,
name|MIN
block|,
name|mdscal
block|,
literal|'S'
block|,
name|MAX
block|,
name|mdscal
block|,
literal|'*'
block|,
name|PWR
block|,
name|mdscal
block|,
literal|0207
block|,
name|LOG
block|,
name|mdscal
block|,
literal|'O'
block|,
name|CIR
block|,
name|mdscal
block|,
literal|0210
block|,
name|COMB
block|,
name|mdscal
block|,
literal|'!'
block|,
name|COMB
block|,
name|mdscal
block|,
comment|/*  * monadic  *	op1 v (monadic op)  */
literal|'~'
block|,
name|NOT
block|,
name|m
block|,
literal|0241
block|,
name|EPS
operator|+
literal|1
block|,
name|m
block|,
comment|/*  * dyadic  *	op2 op1 v (dyadic op)  */
literal|'N'
block|,
name|REP
block|,
name|d
block|,
literal|'Y'
block|,
name|TAKE
block|,
name|d
block|,
literal|'U'
block|,
name|DROP
block|,
name|d
block|,
literal|'_'
block|,
name|ASGN
block|,
name|asg
block|,
literal|'{'
block|,
name|ASGN
block|,
name|asg
block|,
comment|/*  * monadic or dyadic  *	op2 op1 v (dyadic op)  *	op1 v+1 (monadic op)  */
literal|'E'
block|,
name|EPS
block|,
name|md
block|,
literal|'B'
block|,
name|BASE
block|,
name|md
block|,
literal|'?'
block|,
name|DEAL
block|,
name|md
block|,
literal|'R'
block|,
name|DRHO
block|,
name|md
block|,
literal|'I'
block|,
name|DIOT
block|,
name|md
block|,
literal|0211
block|,
name|ROT0
block|,
name|md
block|,
literal|0212
block|,
name|DTRN
block|,
name|md
block|,
literal|0213
block|,
name|DIBM
block|,
name|md
block|,
literal|0214
block|,
name|DDOM
block|,
name|md
block|,
literal|0242
block|,
name|DFMT
block|,
name|md
block|,
comment|/*  * monadic with optional subscript  *	op1 v (monadic op)  *	op1 sub v+1 (subscripted monadic op)  */
literal|0215
block|,
name|GDU
block|,
name|msub
block|,
literal|0216
block|,
name|GDD
block|,
name|msub
block|,
literal|0227
block|,
name|GDU
block|,
name|msub
block|,
literal|0230
block|,
name|GDD
block|,
name|msub
block|,
comment|/*  * dyadic with optional subscript  *	op2 op1 v (dyadic op)  *	op2 op1 sub v+1 (subscripted dyadic op)  */
comment|/*  * monadic or dyadic with optional subscript  *	op2 op1 v (dyadic op)  *	op1 v+1 (monadic op)  *	op2 op1 sub v+2 (subscripted dyadic op)  *	op1 sub v+3 (subscripted monadic op)  */
literal|0217
block|,
name|ROT
block|,
name|mdsub
block|,
literal|','
block|,
name|CAT
block|,
name|mdsub
block|,
comment|/*  *	ISP and PSI  */
literal|0232
block|,
name|PSI
block|,
name|d
block|,
literal|0233
block|,
name|ISP
block|,
name|d
block|,
comment|/*  *	other, non-function  */
literal|0234
block|,
name|unk
block|,
name|null
block|,
literal|0235
block|,
name|unk
block|,
name|null
block|,
literal|0236
block|,
name|unk
block|,
name|null
block|,
literal|0237
block|,
name|unk
block|,
name|null
block|,
literal|'@'
block|,
name|unk
block|,
name|null
block|,
comment|/*  * end of list  */
literal|0
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|char
modifier|*
name|ct_name
decl_stmt|;
comment|/* command name string */
name|int
name|ct_ytype
decl_stmt|;
comment|/* command type */
name|int
name|ct_ylval
decl_stmt|;
comment|/* "yylval" value */
block|}
name|comtab
index|[]
init|=
block|{
literal|"clear"
block|,
name|comnull
block|,
name|CLEAR
block|,
literal|"continue"
block|,
name|comnull
block|,
name|CONTIN
block|,
literal|"copy"
block|,
name|comnam
block|,
name|COPY
block|,
literal|"debug"
block|,
name|comnull
block|,
name|DEBUG
block|,
literal|"digits"
block|,
name|comexpr
block|,
name|DIGITS
block|,
literal|"drop"
block|,
name|comlist
block|,
name|DROPC
block|,
literal|"edit"
block|,
name|comnam
block|,
name|EDIT
block|,
literal|"editf"
block|,
name|comnam
block|,
name|EDITF
block|,
literal|"write"
block|,
name|comnam
block|,
name|WRITE
block|,
literal|"trace"
block|,
name|comnull
block|,
name|TRACE
block|,
literal|"untrace"
block|,
name|comnull
block|,
name|UNTRACE
block|,
literal|"erase"
block|,
name|comlist
block|,
name|ERASE
block|,
literal|"fns"
block|,
name|comnull
block|,
name|FNS
block|,
literal|"fuzz"
block|,
name|comexpr
block|,
name|FUZZ
block|,
literal|"lib"
block|,
name|comnull
block|,
name|LIB
block|,
literal|"load"
block|,
name|comnam
block|,
name|LOAD
block|,
literal|"off"
block|,
name|comnull
block|,
name|OFF
block|,
literal|"origin"
block|,
name|comexpr
block|,
name|ORIGIN
block|,
literal|"read"
block|,
name|comnam
block|,
name|READ
block|,
literal|"save"
block|,
name|comnam
block|,
name|SAVE
block|,
literal|"vars"
block|,
name|comnull
block|,
name|VARS
block|,
literal|"width"
block|,
name|comexpr
block|,
name|WIDTH
block|,
literal|"vsave"
block|,
name|comnam
block|,
name|VSAVE
block|,
literal|"script"
block|,
name|comnam
block|,
name|SCRIPT
block|,
literal|"reset"
block|,
name|comnull
block|,
name|RESET
block|,
literal|"si"
block|,
name|comnull
block|,
name|SICOM
block|,
literal|"code"
block|,
name|comnam
block|,
name|CODE
block|,
literal|"del"
block|,
name|comnam
block|,
name|DEL
block|,
literal|"shell"
block|,
name|comnull
block|,
name|SHELL
block|,
literal|"list"
block|,
name|comnam
block|,
name|LIST
block|,
literal|"prws"
block|,
name|comnull
block|,
name|PRWS
block|,
literal|0
block|,
name|unk
block|}
struct|;
end_struct

begin_comment
comment|/*  * List of two-character escapes.  Indexed by 02XX entries  * in "tab", above.  Entries must be in lexical order, i.e.  * 'V~' will work, '~V' will not (since overstrikes are  * sorted before they are looked up).  'V~' is 6 down in  * the table, and thus corresponds to 0206,  * which "tab" shows to be NOR.  */
end_comment

begin_decl_stmt
name|int
name|chartab
index|[]
init|=
block|{
literal|'-/'
block|,
comment|/* 0200 comprs */
literal|'-\\'
block|,
comment|/* 0201 expand */
literal|'\'L'
block|,
comment|/* 0202 quote quad */
literal|'LO'
block|,
comment|/* 0203 circle quad */
literal|'CJ'
block|,
comment|/* 0204 lamp */
literal|'^~'
block|,
comment|/* 0205 nand */
literal|'V~'
block|,
comment|/* 0206 nor */
literal|'*O'
block|,
comment|/* 0207 log */
literal|'\'.'
block|,
comment|/* 0210 comb/fact ('!') */
literal|'-O'
block|,
comment|/* 0211 rotate */
literal|'O\\'
block|,
comment|/* 0212 transpose */
literal|'BN'
block|,
comment|/* 0213 i beam */
literal|'%L'
block|,
comment|/* 0214 domino */
literal|'A|'
block|,
comment|/* 0215 grade up */
literal|'V|'
block|,
comment|/* 0216 grade dn */
literal|'O|'
block|,
comment|/* 0217 rotate */
literal|'<='
block|,
comment|/* 0220 less eq */
literal|'=>'
block|,
comment|/* 0221 greater eq */
literal|'/='
block|,
comment|/* 0222 not eq */
literal|'A~'
block|,
comment|/* 0223 nand */
literal|'Q~'
block|,
comment|/* 0224 nor */
literal|'/\\'
block|,
comment|/* 0225 multiply */
literal|'-:'
block|,
comment|/* 0226 divide */
literal|'H|'
block|,
comment|/* 0227 another grade up */
literal|'G|'
block|,
comment|/* 0230 another d
comment|grade dn */
literal|'&~'
block|,
comment|/* 0231 yet another nand */
literal|'U|'
block|,
comment|/* 0232 PSI */
literal|'C|'
block|,
comment|/* 0233 ISP */
literal|'Y~'
block|,
comment|/* 0234 bracket 1 */
literal|'U~'
block|,
comment|/* 0235 bracket 2 */
literal|'-U'
block|,
comment|/* 0236 another bracket 2 */
literal|'-Y'
block|,
comment|/* 0237 another bracket 2 */
literal|'//'
block|,
comment|/* 0240 alternate divide */
literal|'BJ'
block|,
comment|/* 0241 standard execute */
literal|'JN'
block|,
comment|/* 0242 format */
comment|/*  *	function alpha() in lex.c must be changed whenever this  *	table is updated.  It must know the index of the alternate  *	character set (currently 0243)  */
literal|'Fa'
block|,
comment|/* alternate character set */
literal|'Fb'
block|,
literal|'Fc'
block|,
literal|'Fd'
block|,
literal|'Fe'
block|,
literal|'Ff'
block|,
literal|'Fg'
block|,
literal|'Fh'
block|,
literal|'Fi'
block|,
literal|'Fj'
block|,
literal|'Fk'
block|,
literal|'Fl'
block|,
literal|'Fm'
block|,
literal|'Fn'
block|,
literal|'Fo'
block|,
literal|'Fp'
block|,
literal|'Fq'
block|,
literal|'Fr'
block|,
literal|'Fs'
block|,
literal|'Ft'
block|,
literal|'Fu'
block|,
literal|'Fv'
block|,
literal|'Fw'
block|,
literal|'Fx'
block|,
literal|'Fy'
block|,
literal|'Fz'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	qtab -- table of valid quad functions  *	the format of the qtab is the similar to tab, above  *  */
end_comment

begin_struct
struct|struct
name|qtab
block|{
name|char
modifier|*
name|qname
decl_stmt|;
name|int
name|qtype
decl_stmt|;
name|int
name|rtype
decl_stmt|;
block|}
name|qtab
index|[]
init|=
block|{
literal|"lx"
block|,
name|XQUAD
block|,
name|Quad
block|,
literal|"width"
block|,
name|QWID
block|,
name|Quad
block|,
literal|"run"
block|,
name|QRUN
block|,
name|m
block|,
literal|"fuzz"
block|,
name|QFUZZ
block|,
name|Quad
block|,
literal|"fork"
block|,
name|QFORK
block|,
name|m
block|,
literal|"wait"
block|,
name|QWAIT
block|,
name|m
block|,
literal|"exec"
block|,
name|QEXEC
block|,
name|m
block|,
literal|"cr"
block|,
name|QCRP
block|,
name|m
block|,
literal|"fx"
block|,
name|FDEF
block|,
name|m
block|,
literal|"exit"
block|,
name|QEXIT
block|,
name|m
block|,
literal|"pipe"
block|,
name|QPIPE
block|,
name|m
block|,
literal|"chdir"
block|,
name|QCHDIR
block|,
name|m
block|,
literal|"open"
block|,
name|QOPEN
block|,
name|d
block|,
literal|"close"
block|,
name|QCLOSE
block|,
name|m
block|,
literal|"read"
block|,
name|QREAD
block|,
name|d
block|,
literal|"write"
block|,
name|QWRITE
block|,
name|d
block|,
literal|"creat"
block|,
name|QCREAT
block|,
name|d
block|,
literal|"seek"
block|,
name|QSEEK
block|,
name|m
block|,
literal|"kill"
block|,
name|QKILL
block|,
name|d
block|,
literal|"rd"
block|,
name|QRD
block|,
name|m
block|,
literal|"rm"
block|,
name|QUNLNK
block|,
name|m
block|,
literal|"dup"
block|,
name|QDUP
block|,
name|m
block|,
literal|"ap"
block|,
name|QAP
block|,
name|d
block|,
literal|"rline"
block|,
name|QRD
block|,
name|m
block|,
literal|"nc"
block|,
name|QNC
block|,
name|m
block|,
literal|"sig"
block|,
name|QSIGNL
block|,
name|d
block|,
literal|"float"
block|,
name|QFLOAT
block|,
name|m
block|,
literal|"nl"
block|,
name|QNL
block|,
name|m
block|,
literal|0
block|}
struct|;
end_struct

end_unit

