begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  rn -- new readnews program  *  *  From: lwall@sdcrdcf.UUCP (Larry Wall)  *  Organization: System Development Corporation, Santa Monica  *  *  begun:   01/14/83  *	1.0: 04/08/83  *      2.0: 09/01/83  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rnid
index|[]
init|=
literal|"@(#)$Header: rn.c,v 4.3.1.4 85/09/10 11:05:13 lwall Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* $Log:	rn.c,v $  * Revision 4.3.1.4  85/09/10  11:05:13  lwall  * Improved %m in in_char().  *   * Revision 4.3.1.3  85/05/16  16:47:10  lwall  * Catchup confirmation didn't grok -t.  *   * Revision 4.3.1.2  85/05/13  09:34:53  lwall  * Fixed default after do_newsgroup() returns from Q command.  *   * Revision 4.3.1.1  85/05/10  11:38:08  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:47:56  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rn.h"
end_include

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"only.h"
end_include

begin_include
include|#
directive|include
file|"ngsrch.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"sw.h"
end_include

begin_include
include|#
directive|include
file|"addng.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_function
name|void
name|rn_init
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|bool
name|foundany
init|=
name|initialize
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|bool
name|oh_for_the_good_old_days
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|maxngtodo
condition|)
name|starthere
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foundany
condition|)
block|{
comment|/* nothing to do? */
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|fputs
argument_list|(
literal|"\ No unread news in subscribed-to newsgroups.  To subscribe to a new\n\ newsgroup use the g<newsgroup> command.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|starthere
operator|=
name|nextrcline
expr_stmt|;
block|}
comment|/* loop through all unread news */
block|{
name|char
name|promptbuf
index|[
literal|80
index|]
decl_stmt|;
name|bool
name|special
init|=
name|FALSE
decl_stmt|;
comment|/* temporarily allow newsgroup */
comment|/*   with no unread news? */
name|bool
name|retry
decl_stmt|;
comment|/* cycle back to top of list? */
name|NG_NUM
name|recent_ng
init|=
literal|0
decl_stmt|;
name|current_ng
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|retry
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|findlast
condition|)
block|{
name|findlast
operator|=
name|FALSE
expr_stmt|;
name|starthere
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|lastngname
condition|)
block|{
if|if
condition|(
operator|(
name|ng
operator|=
name|find_ng
argument_list|(
name|lastngname
argument_list|)
operator|)
operator|==
name|nextrcline
condition|)
name|ng
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|set_ngname
argument_list|(
name|lastngname
argument_list|)
expr_stmt|;
name|set_toread
argument_list|(
name|ng
argument_list|)
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|<=
name|TR_NONE
condition|)
name|ng
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ng
operator|=
name|starthere
expr_stmt|;
name|starthere
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|ng
operator|<=
name|nextrcline
condition|)
block|{
comment|/* for each newsgroup */
name|mode
operator|=
literal|'n'
expr_stmt|;
if|if
condition|(
name|ng
operator|>=
name|nextrcline
condition|)
block|{
comment|/* after the last newsgroup? */
name|ng
operator|=
name|nextrcline
expr_stmt|;
comment|/* force it to 1 after */
ifdef|#
directive|ifdef
name|ONLY
if|if
condition|(
name|maxngtodo
condition|)
block|{
if|if
condition|(
name|retry
condition|)
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nRestriction %s%s still in effect.\n"
argument_list|,
argument|ngtodo[
literal|0
argument|]
argument_list|,
argument|maxngtodo>
literal|1
argument|?
literal|", etc."
argument|: nullstr
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n(\"Only\" mode.)\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nNo articles under restriction."
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nNo \"only\" articles."
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|end_only
argument_list|()
expr_stmt|;
comment|/* release the restriction */
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|dfltcmd
operator|=
operator|(
name|retry
condition|?
literal|"npq"
else|:
literal|"qnp"
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|sprintf
argument_list|(
name|promptbuf
argument_list|,
literal|"\n******** End of newsgroups--what next? [%s] "
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|sprintf
argument_list|(
name|promptbuf
argument_list|,
literal|"\n**** End--next? [%s] "
argument_list|,
name|dfltcmd
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bool
name|shoe_fits
decl_stmt|;
comment|/* newsgroup matches restriction? */
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|>=
name|TR_NONE
condition|)
block|{
comment|/* recalc toread? */
name|set_ngname
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|shoe_fits
operator|=
operator|(
name|special
operator|||
name|inlist
argument_list|(
name|ngname
argument_list|)
operator|)
condition|)
name|set_toread
argument_list|(
name|ng
argument_list|)
expr_stmt|;
if|if
condition|(
name|paranoid
condition|)
block|{
name|recent_ng
operator|=
name|current_ng
expr_stmt|;
name|current_ng
operator|=
name|ng
expr_stmt|;
name|cleanup_rc
argument_list|()
expr_stmt|;
comment|/* this may move newsgroups around */
name|ng
operator|=
name|current_ng
expr_stmt|;
name|set_ngname
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|<
operator|(
name|maxngtodo
operator|||
name|special
condition|?
name|TR_NONE
else|:
name|TR_ONE
operator|)
operator|||
operator|!
name|shoe_fits
condition|)
block|{
comment|/* unwanted newsgroup? */
name|ng
operator|++
expr_stmt|;
comment|/* then skip it */
continue|continue;
block|}
name|dfltcmd
operator|=
literal|"ynq"
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|sprintf
argument_list|(
name|promptbuf
argument_list|,
literal|"\n******** %3ld unread article%c in %s--read now? [%s] "
argument_list|,
operator|(
name|long
operator|)
name|toread
index|[
name|ng
index|]
argument_list|,
operator|(
name|toread
index|[
name|ng
index|]
operator|==
name|TR_ONE
condition|?
literal|' '
else|:
literal|'s'
operator|)
argument_list|,
name|ngname
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
comment|/* format prompt string */
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|sprintf
argument_list|(
name|promptbuf
argument_list|,
literal|"\n**** %3ld in %s--read? [%s] "
argument_list|,
operator|(
name|long
operator|)
name|toread
index|[
name|ng
index|]
argument_list|,
name|ngname
argument_list|,
name|dfltcmd
argument_list|)
decl_stmt|;
comment|/* format prompt string */
endif|#
directive|endif
block|}
name|special
operator|=
name|FALSE
expr_stmt|;
comment|/* go back to normal mode */
if|if
condition|(
name|ng
operator|!=
name|current_ng
condition|)
block|{
name|recent_ng
operator|=
name|current_ng
expr_stmt|;
comment|/* remember previous newsgroup */
name|current_ng
operator|=
name|ng
expr_stmt|;
comment|/* remember current newsgroup */
block|}
name|reask_newsgroup
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|fputs
argument_list|(
argument|promptbuf
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* print prompt */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reinp_newsgroup
label|:
name|eat_typeahead
argument_list|()
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_newsgroup
goto|;
comment|/* give them a prompt again */
block|}
name|setdef
argument_list|(
name|buf
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* find previous unread newsgroup */
do|do
block|{
if|if
condition|(
name|ng
operator|<=
literal|0
condition|)
break|break;
name|ng
operator|--
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|==
name|TR_NONE
condition|)
name|set_toread
argument_list|(
name|ng
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|toread
index|[
name|ng
index|]
operator|<=
name|TR_NONE
condition|)
do|;
break|break;
case|case
literal|'P'
case|:
comment|/* goto previous newsgroup */
do|do
block|{
if|if
condition|(
name|ng
operator|<=
literal|0
condition|)
break|break;
name|ng
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|toread
index|[
name|ng
index|]
operator|<
name|TR_NONE
condition|)
do|;
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
literal|'-'
case|:
name|ng
operator|=
name|recent_ng
expr_stmt|;
comment|/* recall previous newsgroup */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'x'
case|:
comment|/* quit? */
name|oh_for_the_good_old_days
operator|=
operator|(
operator|*
name|buf
operator|==
literal|'x'
operator|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|ng
operator|=
name|nextrcline
operator|+
literal|1
expr_stmt|;
comment|/* satisfy */
name|retry
operator|=
name|FALSE
expr_stmt|;
comment|/*   loop conditions */
break|break;
case|case
literal|'^'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|ng
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'+'
case|:
comment|/* find next unread newsgroup */
if|if
condition|(
name|ng
operator|==
name|nextrcline
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|>
name|TR_NONE
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
name|ng
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* goto next newsgroup */
name|ng
operator|++
expr_stmt|;
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* and don't skip it if toread==0 */
break|break;
case|case
literal|'1'
case|:
comment|/* goto 1st newsgroup */
name|ng
operator|=
literal|0
expr_stmt|;
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* and don't skip it if toread==0 */
break|break;
case|case
literal|'$'
case|:
name|ng
operator|=
name|nextrcline
expr_stmt|;
comment|/* goto last newsgroup */
name|retry
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|list_newsgroups
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
comment|/* scan for newsgroup pattern */
ifdef|#
directive|ifdef
name|NGSEARCH
switch|switch
condition|(
name|ng_search
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|NGS_ABORT
case|:
goto|goto
name|reinp_newsgroup
goto|;
case|case
name|NGS_INTR
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n(Interrupted)\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n(Intr)\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|ng
operator|=
name|current_ng
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
name|NGS_FOUND
case|:
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
name|NGS_NOTFOUND
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\nNot found--use g to add newsgroups\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n\nNot found\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_newsgroup
goto|;
block|}
else|#
directive|else
name|notincl
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
ifndef|#
directive|ifndef
name|RELOCATE
name|notincl
argument_list|(
literal|"m"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'g'
case|:
comment|/* goto named newsgroup */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|FALSE
argument_list|)
condition|)
comment|/* if they didn't finish command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* go try something else */
for|for
control|(
name|s
operator|=
name|buf
operator|+
literal|1
init|;
operator|*
name|s
operator|==
literal|' '
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* skip leading spaces */
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOCATE
if|if
condition|(
operator|!
name|get_ng
argument_list|(
name|s
argument_list|,
operator|*
name|buf
operator|==
literal|'m'
argument_list|)
condition|)
comment|/* try to find newsgroup */
else|#
directive|else
if|if
condition|(
operator|!
name|get_ng
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|)
condition|)
comment|/* try to find newsgroup */
endif|#
directive|endif
name|ng
operator|=
name|current_ng
expr_stmt|;
comment|/* if not found, go nowhere */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
ifdef|#
directive|ifdef
name|DEBUGGING
case|case
literal|'D'
case|:
name|printf
argument_list|(
literal|"\nTries: %d Hits: %d\n"
argument_list|,
argument|softtries
argument_list|,
argument|softtries-softmisses
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
endif|#
directive|endif
case|case
literal|'!'
case|:
comment|/* shell escape */
if|if
condition|(
name|escapade
argument_list|()
condition|)
comment|/* do command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, re input */
goto|goto
name|reask_newsgroup
goto|;
case|case
name|Ctl
argument_list|(
literal|'k'
argument_list|)
case|:
comment|/* edit global KILL file */
name|edit_kfile
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
literal|'c'
case|:
comment|/* catch up */
ifdef|#
directive|ifdef
name|CATCHUP
name|reask_catchup
label|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|in_char
argument_list|(
literal|"\nDo you really want to mark everything as read? [yn] "
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|in_char
argument_list|(
literal|"\nReally? [ynh] "
argument_list|,
literal|'C'
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|setdef
argument_list|(
name|buf
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'h'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"Type y or SP to mark all articles as read.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Type n to leave articles marked as they are.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"y or SP to mark all read.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n to forget it.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|reask_catchup
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|!=
literal|' '
operator|&&
operator|*
name|buf
operator|!=
literal|'y'
operator|&&
operator|*
name|buf
operator|!=
literal|'n'
operator|&&
operator|*
name|buf
operator|!=
literal|'q'
condition|)
block|{
name|printf
argument_list|(
name|hforhelp
argument_list|)
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_catchup
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|buf
operator|==
literal|' '
operator|||
operator|*
name|buf
operator|==
literal|'y'
operator|)
operator|&&
name|ng
operator|<
name|nextrcline
condition|)
name|catch_up
argument_list|(
name|ng
argument_list|)
expr_stmt|;
else|else
name|retry
operator|=
name|TRUE
expr_stmt|;
name|ng
operator|++
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"c"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'u'
case|:
comment|/* unsubscribe */
if|if
condition|(
name|ng
operator|<
name|nextrcline
operator|&&
name|toread
index|[
name|ng
index|]
operator|>=
name|TR_NONE
condition|)
block|{
comment|/* unsubscribable? */
name|printf
argument_list|(
argument|unsubto
argument_list|,
argument|rcline[ng]
argument_list|)
name|FLUSH
expr_stmt|;
name|rcchar
index|[
name|ng
index|]
operator|=
name|NEGCHAR
expr_stmt|;
comment|/* unsubscribe to (from?) it */
name|toread
index|[
name|ng
index|]
operator|=
name|TR_UNSUB
expr_stmt|;
comment|/* and make line invisible */
name|ng
operator|++
expr_stmt|;
comment|/* do an automatic 'n' */
block|}
break|break;
case|case
literal|'h'
case|:
block|{
comment|/* help */
name|int
name|cmd
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|=
name|help_ng
argument_list|()
operator|)
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
case|case
literal|'a'
case|:
ifndef|#
directive|ifndef
name|FINDNEWNG
name|notincl
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
else|#
directive|else
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
literal|'o'
case|:
ifdef|#
directive|ifdef
name|ONLY
block|{
ifdef|#
directive|ifdef
name|FINDNEWNG
name|bool
name|doscan
init|=
operator|(
operator|*
name|buf
operator|==
literal|'a'
operator|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|TRUE
argument_list|)
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, try something else */
name|end_only
argument_list|()
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|1
index|]
condition|)
block|{
name|bool
name|minusd
init|=
name|instr
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"-d"
argument_list|)
operator|!=
name|Nullch
decl_stmt|;
name|sw_list
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|minusd
condition|)
name|cwd_check
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
ifdef|#
directive|ifdef
name|FINDNEWNG
if|if
condition|(
name|doscan
operator|&&
name|maxngtodo
condition|)
name|scanactive
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|ng
operator|=
literal|0
expr_stmt|;
comment|/* simulate ^ */
name|retry
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|notincl
argument_list|(
literal|"o"
argument_list|)
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
endif|#
directive|endif
case|case
literal|'&'
case|:
if|if
condition|(
name|switcheroo
argument_list|()
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, try something else */
goto|goto
name|reask_newsgroup
goto|;
case|case
literal|'l'
case|:
block|{
comment|/* list other newsgroups */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|TRUE
argument_list|)
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, try something else */
for|for
control|(
name|s
operator|=
name|buf
operator|+
literal|1
init|;
operator|*
name|s
operator|==
literal|' '
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* skip leading spaces */
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s '%s'"
argument_list|,
name|filexp
argument_list|(
name|NEWSGROUPS
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
if|if
condition|(
name|doshell
argument_list|(
name|sh
argument_list|,
name|cmd_buf
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"    (Error from newsgroups program)\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"(Error)\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|noecho
argument_list|()
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
case|case
literal|'.'
case|:
case|case
literal|'='
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
comment|/* do normal thing */
if|if
condition|(
name|ng
operator|>=
name|nextrcline
condition|)
block|{
name|fputs
argument_list|(
literal|"\nNot on a newsgroup."
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
if|if
condition|(
operator|*
name|buf
operator|==
literal|'='
condition|)
name|s
operator|=
name|savestr
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'.'
condition|)
block|{
comment|/* start command? */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|FALSE
argument_list|)
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
name|s
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* do_newsgroup will free it */
block|}
else|else
name|s
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ng
index|]
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|do_newsgroup
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|NG_ERROR
case|:
case|case
name|NG_NORM
case|:
name|ng
operator|++
expr_stmt|;
break|break;
case|case
name|NG_ASK
case|:
name|dfltcmd
operator|=
literal|"ynq"
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
name|NG_MINUS
case|:
name|ng
operator|=
name|recent_ng
expr_stmt|;
comment|/* recall previous newsgroup */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|STRICTCR
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
argument|badcr
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|rnid
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
default|default:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
argument|hforhelp
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
block|}
block|}
do|while
condition|(
name|retry
condition|)
do|;
block|}
comment|/* now write .newsrc back out */
name|write_rc
argument_list|()
expr_stmt|;
if|if
condition|(
name|oh_for_the_good_old_days
condition|)
name|get_old_rc
argument_list|()
expr_stmt|;
name|finalize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* and exit */
block|}
end_function

begin_comment
comment|/* set current newsgroup */
end_comment

begin_function
name|void
name|set_ngname
parameter_list|(
name|what
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|what
argument_list|)
operator|+
literal|1
decl_stmt|;
name|growstr
argument_list|(
operator|&
name|ngname
argument_list|,
operator|&
name|ngnlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ngname
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|growstr
argument_list|(
operator|&
name|ngdir
argument_list|,
operator|&
name|ngdlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ngdir
argument_list|,
name|getngdir
argument_list|(
name|ngname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myngdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ngdirlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|getngdir
parameter_list|(
name|ngnam
parameter_list|)
name|char
modifier|*
name|ngnam
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|growstr
argument_list|(
operator|&
name|myngdir
argument_list|,
operator|&
name|ngdirlen
argument_list|,
name|strlen
argument_list|(
name|ngnam
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|myngdir
argument_list|,
name|ngnam
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|myngdir
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
operator|*
name|s
operator|=
literal|'/'
expr_stmt|;
return|return
name|myngdir
return|;
block|}
end_function

end_unit

