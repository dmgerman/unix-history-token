begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: rcln.c,v 4.3.1.3 86/11/04 15:57:03 lwall Exp $  *  * $Log:	rcln.c,v $  * Revision 4.3.1.3  86/11/04  15:57:03  lwall  * realloc attempted on unalloced area.  *   * Revision 4.3.1.2  85/07/23  17:39:08  lwall  * Oops, was freeing a static buf on -c in checkexpired.  *   * Revision 4.3.1.1  85/05/10  11:37:08  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:45:36  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_function
name|void
name|rcln_init
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CATCHUP
end_ifdef

begin_function
name|void
name|catch_up
parameter_list|(
name|ngx
parameter_list|)
name|NG_NUM
name|ngx
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nMarking %s as all read.\n"
argument_list|,
argument|rcline[ngx]
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nMarked read\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s: 1-%ld"
argument_list|,
name|rcline
index|[
name|ngx
index|]
argument_list|,
operator|(
name|long
operator|)
name|getngsize
argument_list|(
name|ngx
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcline
index|[
name|ngx
index|]
argument_list|)
expr_stmt|;
name|rcline
index|[
name|ngx
index|]
operator|=
name|savestr
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rcline
index|[
name|ngx
index|]
operator|+
name|rcnums
index|[
name|ngx
index|]
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|write_rc
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* add an article number to a newsgroup, if it isn't already read */
end_comment

begin_function
name|int
name|addartnum
parameter_list|(
name|artnum
parameter_list|,
name|ngnam
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
name|char
modifier|*
name|ngnam
decl_stmt|;
block|{
specifier|register
name|NG_NUM
name|ngnum
init|=
name|find_ng
argument_list|(
name|ngnam
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|maxt
init|=
name|Nullch
decl_stmt|;
name|ART_NUM
name|min
init|=
literal|0
decl_stmt|,
name|max
init|=
operator|-
literal|1
decl_stmt|,
name|lastnum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|bool
name|morenum
decl_stmt|;
if|if
condition|(
operator|!
name|artnum
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ngnum
operator|==
name|nextrcline
operator|||
operator|!
name|rcnums
index|[
name|ngnum
index|]
condition|)
comment|/* not found in newsrc? */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|CACHEFIRST
if|if
condition|(
operator|!
name|abs1st
index|[
name|ngnum
index|]
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|toread
index|[
name|ngnum
index|]
condition|)
endif|#
directive|endif
comment|/* now is a good time to trim down */
name|set_toread
argument_list|(
name|ngnum
argument_list|)
expr_stmt|;
comment|/* the list due to expires if we */
comment|/* have not yet. */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|artnum
operator|>
name|ngmax
index|[
name|ngnum
index|]
operator|+
literal|10
comment|/* allow for incoming articles */
condition|)
block|{
name|printf
argument_list|(
literal|"\nCorrupt Xref line!!!  %ld --> %s(1..%ld)\n"
argument_list|,
argument|artnum
argument_list|,
argument|ngnam
argument_list|,
argument|ngmax[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
name|paranoid
operator|=
name|TRUE
expr_stmt|;
comment|/* paranoia reigns supreme */
return|return
operator|-
literal|1
return|;
comment|/* hope this was the first newsgroup */
block|}
endif|#
directive|endif
if|if
condition|(
name|toread
index|[
name|ngnum
index|]
operator|==
name|TR_BOGUS
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"%ld->\n%s%c%s\n"
argument_list|,
argument|(long)artnum
argument_list|,
argument|rcline[ngnum]
argument_list|,
argument|rcchar[ngnum]
argument_list|,
argument|rcline[ngnum] + rcnums[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip spaces */
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|artnum
operator|>=
operator|(
name|min
operator|=
name|atol
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
comment|/* while it might have been read */
for|for
control|(
name|t
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
comment|/* skip number */
if|if
condition|(
operator|*
name|t
operator|==
literal|'-'
condition|)
block|{
comment|/* is it a range? */
name|t
operator|++
expr_stmt|;
comment|/* skip to next number */
if|if
condition|(
name|artnum
operator|<=
operator|(
name|max
operator|=
name|atol
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* it is in range => already read */
name|lastnum
operator|=
name|max
expr_stmt|;
comment|/* remember it */
name|maxt
operator|=
name|t
expr_stmt|;
comment|/* remember position in case we */
comment|/* want to overwrite the max */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* skip second number */
block|}
else|else
block|{
if|if
condition|(
name|artnum
operator|==
name|min
condition|)
comment|/* explicitly a read article? */
return|return
literal|0
return|;
name|lastnum
operator|=
name|min
expr_stmt|;
comment|/* remember what the number was */
name|maxt
operator|=
name|Nullch
expr_stmt|;
comment|/* last one was not a range */
block|}
while|while
condition|(
operator|*
name|t
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* skip comma and any spaces */
name|s
operator|=
name|t
expr_stmt|;
block|}
comment|/* we have not read it, so insert the article number before s */
name|morenum
operator|=
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* will it need a comma after? */
operator|*
operator|(
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
operator|-
literal|1
operator|)
operator|=
name|rcchar
index|[
name|ngnum
index|]
expr_stmt|;
name|mbuf
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
operator|(
name|s
operator|-
name|rcline
index|[
name|ngnum
index|]
operator|)
operator|+
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mbuf
argument_list|,
name|rcline
index|[
name|ngnum
index|]
argument_list|)
expr_stmt|;
comment|/* make new rc line */
if|if
condition|(
name|maxt
operator|&&
name|lastnum
operator|&&
name|artnum
operator|==
name|lastnum
operator|+
literal|1
condition|)
comment|/* can we just extend last range? */
name|t
operator|=
name|mbuf
operator|+
operator|(
name|maxt
operator|-
name|rcline
index|[
name|ngnum
index|]
operator|)
expr_stmt|;
comment|/* then overwrite previous max */
else|else
block|{
name|t
operator|=
name|mbuf
operator|+
operator|(
name|t
operator|-
name|rcline
index|[
name|ngnum
index|]
operator|)
expr_stmt|;
comment|/* point t into new line instead */
if|if
condition|(
name|lastnum
condition|)
block|{
comment|/* have we parsed any line? */
if|if
condition|(
operator|!
name|morenum
condition|)
comment|/* are we adding to the tail? */
operator|*
name|t
operator|++
operator|=
literal|','
expr_stmt|;
comment|/* supply comma before */
if|if
condition|(
operator|!
name|maxt
operator|&&
name|artnum
operator|==
name|lastnum
operator|+
literal|1
operator|&&
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|==
literal|','
condition|)
comment|/* adjacent singletons? */
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|=
literal|'-'
expr_stmt|;
comment|/* turn them into a range */
block|}
block|}
if|if
condition|(
name|morenum
condition|)
block|{
comment|/* is there more to life? */
if|if
condition|(
name|min
operator|==
name|artnum
operator|+
literal|1
condition|)
block|{
comment|/* can we consolidate further? */
name|bool
name|range_before
init|=
operator|(
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|==
literal|'-'
operator|)
decl_stmt|;
name|bool
name|range_after
decl_stmt|;
name|char
modifier|*
name|nextmax
decl_stmt|;
for|for
control|(
name|nextmax
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|*
name|nextmax
argument_list|)
condition|;
name|nextmax
operator|++
control|)
empty_stmt|;
name|range_after
operator|=
operator|*
name|nextmax
operator|++
operator|==
literal|'-'
expr_stmt|;
if|if
condition|(
name|range_before
condition|)
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
comment|/* artnum is redundant */
else|else
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%ld-"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
comment|/* artnum will be new min */
if|if
condition|(
name|range_after
condition|)
name|s
operator|=
name|nextmax
expr_stmt|;
comment|/* *s is redundant */
comment|/*  else 		s = s */
comment|/* *s is new max */
block|}
else|else
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%ld,"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
comment|/* put the number and comma */
block|}
else|else
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
comment|/* put the number there (wherever) */
name|strcat
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* copy remainder of line */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
argument|mbuf
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|rcline
index|[
name|ngnum
index|]
argument_list|)
expr_stmt|;
name|rcline
index|[
name|ngnum
index|]
operator|=
name|mbuf
expr_stmt|;
comment|/* pull the switcheroo */
operator|*
operator|(
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out : or ! */
if|if
condition|(
name|toread
index|[
name|ngnum
index|]
operator|>
name|TR_NONE
condition|)
comment|/* lest we turn unsub into bogus */
operator|--
name|toread
index|[
name|ngnum
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MCHASE
end_ifdef

begin_comment
comment|/* delete an article number from a newsgroup, if it is there */
end_comment

begin_function
name|void
name|subartnum
parameter_list|(
name|artnum
parameter_list|,
name|ngnam
parameter_list|)
specifier|register
name|ART_NUM
name|artnum
decl_stmt|;
name|char
modifier|*
name|ngnam
decl_stmt|;
block|{
specifier|register
name|NG_NUM
name|ngnum
init|=
name|find_ng
argument_list|(
name|ngnam
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|ART_NUM
name|min
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|int
name|curlen
decl_stmt|;
if|if
condition|(
operator|!
name|artnum
condition|)
return|return;
if|if
condition|(
name|ngnum
operator|==
name|nextrcline
operator|||
operator|!
name|rcnums
index|[
name|ngnum
index|]
condition|)
return|return;
comment|/* not found in newsrc? */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"%ld<-\n%s%c%s\n"
argument_list|,
argument|(long)artnum
argument_list|,
argument|rcline[ngnum]
argument_list|,
argument|rcchar[ngnum]
argument_list|,
argument|rcline[ngnum] + rcnums[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip spaces */
comment|/* a little optimization, since it is almost always the last number */
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
empty_stmt|;
comment|/* find end of string */
name|curlen
operator|=
name|t
operator|-
name|rcline
index|[
name|ngnum
index|]
expr_stmt|;
for|for
control|(
name|t
operator|--
init|;
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|--
control|)
empty_stmt|;
comment|/* find previous delim */
if|if
condition|(
operator|*
name|t
operator|==
literal|','
operator|&&
name|atol
argument_list|(
name|t
operator|+
literal|1
argument_list|)
operator|==
name|artnum
condition|)
block|{
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ngnum
index|]
operator|>=
name|TR_NONE
condition|)
operator|++
name|toread
index|[
name|ngnum
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
name|printf
argument_list|(
literal|"%s%c %s\n"
argument_list|,
argument|rcline[ngnum]
argument_list|,
argument|rcchar[ngnum]
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* not the last number, oh well, we may need the length anyway */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|artnum
operator|>=
operator|(
name|min
operator|=
name|atol
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
comment|/* while it might have been read */
for|for
control|(
name|t
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
comment|/* skip number */
if|if
condition|(
operator|*
name|t
operator|==
literal|'-'
condition|)
block|{
comment|/* is it a range? */
name|t
operator|++
expr_stmt|;
comment|/* skip to next number */
name|max
operator|=
name|atol
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* skip second number */
if|if
condition|(
name|artnum
operator|<=
name|max
condition|)
block|{
comment|/* it is in range => already read */
if|if
condition|(
name|artnum
operator|==
name|min
condition|)
block|{
name|min
operator|++
expr_stmt|;
name|artnum
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|artnum
operator|==
name|max
condition|)
block|{
name|max
operator|--
expr_stmt|;
name|artnum
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
operator|-
literal|1
operator|)
operator|=
name|rcchar
index|[
name|ngnum
index|]
expr_stmt|;
name|mbuf
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|curlen
operator|+
operator|(
name|artnum
condition|?
literal|15
else|:
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|mbuf
argument_list|,
name|rcline
index|[
name|ngnum
index|]
argument_list|)
expr_stmt|;
comment|/* make new rc line */
name|s
operator|=
name|mbuf
operator|+
operator|(
name|s
operator|-
name|rcline
index|[
name|ngnum
index|]
operator|)
expr_stmt|;
comment|/* point s into mbuf now */
if|if
condition|(
name|artnum
condition|)
block|{
comment|/* split into two ranges? */
name|prange
argument_list|(
name|s
argument_list|,
name|min
argument_list|,
name|artnum
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|prange
argument_list|(
name|s
argument_list|,
name|artnum
operator|+
literal|1
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* only one range */
name|prange
argument_list|(
name|s
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* copy remainder over */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
argument|mbuf
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|rcline
index|[
name|ngnum
index|]
argument_list|)
expr_stmt|;
name|rcline
index|[
name|ngnum
index|]
operator|=
name|mbuf
expr_stmt|;
comment|/* pull the switcheroo */
operator|*
operator|(
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out : or ! */
if|if
condition|(
name|toread
index|[
name|ngnum
index|]
operator|>=
name|TR_NONE
condition|)
operator|++
name|toread
index|[
name|ngnum
index|]
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|artnum
operator|==
name|min
condition|)
block|{
comment|/* explicitly a read article? */
if|if
condition|(
operator|*
name|t
operator|==
literal|','
condition|)
comment|/* pick a comma, any comma */
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
name|s
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|','
condition|)
comment|/* (in case of space) */
name|s
operator|-=
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* no need to realloc */
if|if
condition|(
name|toread
index|[
name|ngnum
index|]
operator|>=
name|TR_NONE
condition|)
operator|++
name|toread
index|[
name|ngnum
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"%s%c%s\n"
argument_list|,
argument|rcline[ngnum]
argument_list|,
argument|rcchar[ngnum]
argument_list|,
argument|rcline[ngnum] + rcnums[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
block|}
while|while
condition|(
operator|*
name|t
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* skip comma and any spaces */
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prange
parameter_list|(
name|where
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|ART_NUM
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|min
operator|==
name|max
condition|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|min
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"%ld-%ld"
argument_list|,
operator|(
name|long
operator|)
name|min
argument_list|,
operator|(
name|long
operator|)
name|max
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* calculate the number of unread articles for a newsgroup */
end_comment

begin_function
name|void
name|set_toread
parameter_list|(
name|ngnum
parameter_list|)
specifier|register
name|NG_NUM
name|ngnum
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|h
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|mybuf
init|=
name|tmpbuf
decl_stmt|;
name|char
modifier|*
name|nums
decl_stmt|;
name|int
name|length
decl_stmt|;
ifdef|#
directive|ifdef
name|CACHEFIRST
name|bool
name|virgin_ng
init|=
operator|(
operator|!
name|abs1st
index|[
name|ngnum
index|]
operator|)
decl_stmt|;
endif|#
directive|endif
name|ART_NUM
name|ngsize
init|=
name|getngsize
argument_list|(
name|ngnum
argument_list|)
decl_stmt|;
name|ART_NUM
name|unread
init|=
name|ngsize
decl_stmt|;
name|ART_NUM
name|newmax
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|ngmax
index|[
name|ngnum
index|]
operator|=
name|ngsize
expr_stmt|;
comment|/* for checking out-of-range Xrefs */
endif|#
directive|endif
if|if
condition|(
name|ngsize
operator|==
name|TR_BOGUS
condition|)
block|{
name|printf
argument_list|(
literal|"Warning!  Bogus newsgroup: %s\n"
argument_list|,
argument|rcline[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
name|paranoid
operator|=
name|TRUE
expr_stmt|;
name|toread
index|[
name|ngnum
index|]
operator|=
name|TR_BOGUS
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|CACHEFIRST
if|if
condition|(
name|virgin_ng
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|toread
index|[
name|ngnum
index|]
condition|)
endif|#
directive|endif
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|" 1-%ld"
argument_list|,
operator|(
name|long
operator|)
name|ngsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|tmpbuf
argument_list|,
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
argument_list|)
condition|)
name|checkexpired
argument_list|(
name|ngnum
argument_list|,
name|ngsize
argument_list|)
expr_stmt|;
comment|/* this might realloc rcline */
block|}
name|nums
operator|=
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|nums
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|60
condition|)
name|mybuf
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|length
operator|+
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mybuf
argument_list|,
name|nums
argument_list|)
expr_stmt|;
name|mybuf
index|[
name|length
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|mybuf
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|mybuf
init|;
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|Nullch
condition|;
name|s
operator|=
operator|++
name|c
control|)
block|{
comment|/* for each range */
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* keep index from running off */
if|if
condition|(
operator|(
name|h
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
comment|/* find - in range, if any */
name|unread
operator|-=
operator|(
name|newmax
operator|=
name|atol
argument_list|(
name|h
operator|+
literal|1
argument_list|)
operator|)
operator|-
name|atol
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|newmax
operator|=
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|unread
operator|--
expr_stmt|;
comment|/* recalculate length */
if|if
condition|(
name|newmax
operator|>
name|ngsize
condition|)
block|{
comment|/* paranoia check */
name|unread
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|unread
operator|>=
literal|0
condition|)
comment|/* reasonable number? */
name|toread
index|[
name|ngnum
index|]
operator|=
operator|(
name|ART_UNREAD
operator|)
name|unread
expr_stmt|;
comment|/* remember how many are left */
else|else
block|{
comment|/* SOMEONE RESET THE NEWSGROUP!!! */
name|toread
index|[
name|ngnum
index|]
operator|=
operator|(
name|ART_UNREAD
operator|)
name|ngsize
expr_stmt|;
comment|/* assume nothing carried over */
name|printf
argument_list|(
literal|"Warning!  Somebody reset %s--assuming nothing read.\n"
argument_list|,
argument|rcline[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
operator|*
operator|(
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|paranoid
operator|=
name|TRUE
expr_stmt|;
comment|/* enough to make a guy paranoid */
block|}
if|if
condition|(
name|mybuf
operator|!=
name|tmpbuf
condition|)
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcchar
index|[
name|ngnum
index|]
operator|==
name|NEGCHAR
condition|)
name|toread
index|[
name|ngnum
index|]
operator|=
name|TR_UNSUB
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make sure expired articles are marked as read */
end_comment

begin_function
name|void
name|checkexpired
parameter_list|(
name|ngnum
parameter_list|,
name|ngsize
parameter_list|)
specifier|register
name|NG_NUM
name|ngnum
decl_stmt|;
name|ART_NUM
name|ngsize
decl_stmt|;
block|{
specifier|register
name|ART_NUM
name|a1st
init|=
name|getabsfirst
argument_list|(
name|ngnum
argument_list|,
name|ngsize
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|ART_NUM
name|num
decl_stmt|,
name|lastnum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|newnum
decl_stmt|;
if|if
condition|(
name|a1st
operator|<=
literal|1
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"1-%ld->\n%s%c%s\n"
argument_list|,
argument|(long)(a1st-
literal|1
argument|)
argument_list|,
argument|rcline[ngnum]
argument_list|,
argument|rcchar[ngnum]
argument_list|,
argument|rcline[ngnum] + rcnums[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|s
operator|=
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
init|;
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
name|num
operator|=
name|atol
argument_list|(
name|s
argument_list|)
operator|)
operator|<=
name|a1st
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|lastnum
operator|=
name|num
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* landed in a range? */
if|if
condition|(
name|lastnum
operator|!=
literal|1
condition|)
name|sprintf
argument_list|(
name|rcline
index|[
name|ngnum
index|]
operator|+
name|rcnums
index|[
name|ngnum
index|]
argument_list|,
literal|" 1-%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
comment|/* s now points to what should follow first range */
if|if
condition|(
name|s
operator|-
name|rcline
index|[
name|ngnum
index|]
operator|>
name|rcnums
index|[
name|ngnum
index|]
operator|+
literal|10
condition|)
name|mbuf
operator|=
name|rcline
index|[
name|ngnum
index|]
expr_stmt|;
else|else
block|{
name|mbuf
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|rcnums
index|[
name|ngnum
index|]
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mbuf
argument_list|,
name|rcline
index|[
name|ngnum
index|]
argument_list|)
expr_stmt|;
block|}
name|newnum
operator|=
name|t
operator|=
name|mbuf
operator|+
name|rcnums
index|[
name|ngnum
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|" 1-%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|a1st
operator|-
operator|(
name|lastnum
operator|!=
name|a1st
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkflag
operator|&&
name|mbuf
operator|==
name|rcline
index|[
name|ngnum
index|]
condition|)
block|{
name|rcline
index|[
name|ngnum
index|]
operator|=
name|saferealloc
argument_list|(
name|rcline
index|[
name|ngnum
index|]
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|rcnums
index|[
name|ngnum
index|]
operator|+
name|strlen
argument_list|(
name|newnum
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|checkflag
condition|)
name|free
argument_list|(
name|rcline
index|[
name|ngnum
index|]
argument_list|)
expr_stmt|;
name|rcline
index|[
name|ngnum
index|]
operator|=
name|mbuf
expr_stmt|;
block|}
name|ret
label|:
empty_stmt|;
comment|/* semicolon in case DEBUGGING undefined */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
block|{
name|printf
argument_list|(
literal|"%s%c%s\n"
argument_list|,
argument|rcline[ngnum]
argument_list|,
argument|rcchar[ngnum]
argument_list|,
argument|rcline[ngnum] + rcnums[ngnum]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

