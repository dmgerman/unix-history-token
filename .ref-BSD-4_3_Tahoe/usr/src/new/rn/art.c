begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: art.c,v 4.3.1.5 85/09/10 11:07:18 lwall Exp $  *  * $Log:	art.c,v $  * Revision 4.3.1.5  85/09/10  11:07:18  lwall  * %m not restored on some returns.  *   * Revision 4.3.1.4  85/05/23  12:13:31  lwall  * shouldn't display article that's really a subdirectory.  *   * Revision 4.3.1.3  85/05/13  09:29:55  lwall  * Added CUSTOMLINES option.  *   * Revision 4.3.1.2  85/05/10  13:46:07  lwall  * Fixed header reparse bug on backpage.  *   * Revision 4.3.1.1  85/05/10  11:30:56  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:34:51  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rn.h"
end_include

begin_include
include|#
directive|include
file|"ngstuff.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"cheat.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"artstate.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"sw.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"backpage.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"art.h"
end_include

begin_comment
comment|/* page_switch() return values */
end_comment

begin_define
define|#
directive|define
name|PS_NORM
value|0
end_define

begin_define
define|#
directive|define
name|PS_ASK
value|1
end_define

begin_define
define|#
directive|define
name|PS_RAISE
value|2
end_define

begin_define
define|#
directive|define
name|PS_TOEND
value|3
end_define

begin_decl_stmt
name|bool
name|special
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is next page special length? */
end_comment

begin_decl_stmt
name|int
name|slines
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how long to make page when special */
end_comment

begin_decl_stmt
name|ART_LINE
name|highlight
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next line to be highlighted */
end_comment

begin_decl_stmt
name|char
modifier|*
name|restart
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if nonzero, the place where last */
end_comment

begin_comment
comment|/* line left off on line split */
end_comment

begin_decl_stmt
name|char
modifier|*
name|blinebeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where in buffer current line began */
end_comment

begin_decl_stmt
name|ART_POS
name|alinebeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where in file current line began */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INNERSEARCH
end_ifdef

begin_decl_stmt
name|ART_POS
name|innersearch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* artpos of end of line we found */
end_comment

begin_comment
comment|/* for 'g' command */
end_comment

begin_decl_stmt
name|ART_LINE
name|isrchline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line to display */
end_comment

begin_decl_stmt
name|bool
name|hide_everything
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, do not write page now, */
end_comment

begin_comment
comment|/* but refresh when done with page */
end_comment

begin_decl_stmt
name|COMPEX
name|gcompex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in article search pattern */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|bool
name|firstpage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is this the 1st page of article? */
end_comment

begin_decl_stmt
name|char
name|art_buf
index|[
name|LBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for article lines */
end_comment

begin_function
name|void
name|art_init
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_function
name|int
name|do_article
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|ART_POS
name|artsize
decl_stmt|;
comment|/* size in bytes of article */
name|bool
name|hide_this_line
init|=
name|FALSE
decl_stmt|;
comment|/* hidden header line? */
name|ART_LINE
name|linenum
decl_stmt|;
comment|/* line # on page, 1 origin */
ifdef|#
directive|ifdef
name|ULSMARTS
name|bool
name|under_lining
init|=
name|FALSE
decl_stmt|;
comment|/* are we underlining a word? */
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|bufptr
init|=
name|art_buf
decl_stmt|;
comment|/* pointer to input buffer */
specifier|register
name|int
name|outpos
decl_stmt|;
comment|/* column position of output */
specifier|static
name|char
name|prompt_buf
index|[
literal|64
index|]
decl_stmt|;
comment|/* place to hold prompt */
name|bool
name|notesfiles
init|=
name|FALSE
decl_stmt|;
comment|/* might there be notesfiles junk? */
name|char
name|oldmode
init|=
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|INNERSEARCH
specifier|register
name|int
name|outputok
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|artfp
operator|->
name|_file
argument_list|,
operator|&
name|filestat
argument_list|)
condition|)
comment|/* get article file stats */
return|return
name|DA_CLEAN
return|;
if|if
condition|(
name|filestat
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|!=
name|S_IFREG
condition|)
return|return
name|DA_NORM
return|;
name|artsize
operator|=
name|filestat
operator|.
name|st_size
expr_stmt|;
comment|/* from that get article size */
name|sprintf
argument_list|(
name|prompt_buf
argument_list|,
literal|"%%sEnd of article %ld (of %ld)--what next? [%%s]"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|,
operator|(
name|long
operator|)
name|lastart
argument_list|)
expr_stmt|;
comment|/* format prompt string */
name|prompt
operator|=
name|prompt_buf
expr_stmt|;
name|int_count
operator|=
literal|0
expr_stmt|;
comment|/* interrupt count is 0 */
name|firstpage
operator|=
operator|(
name|topline
operator|<
literal|0
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* for each page */
name|assert
argument_list|(
name|art
operator|==
name|openart
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_fseek
condition|)
block|{
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parse_maybe
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* make sure header is ours */
endif|#
directive|endif
name|artpos
operator|=
name|vrdary
argument_list|(
name|artline
argument_list|)
expr_stmt|;
if|if
condition|(
name|artpos
operator|<
literal|0
condition|)
name|artpos
operator|=
operator|-
name|artpos
expr_stmt|;
comment|/* labs(), anyone? */
if|if
condition|(
name|firstpage
condition|)
name|artpos
operator|=
operator|(
name|ART_POS
operator|)
literal|0
expr_stmt|;
name|fseek
argument_list|(
name|artfp
argument_list|,
name|artpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|artpos
operator|<
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
condition|)
name|in_header
operator|=
name|SOME_LINE
expr_stmt|;
name|do_fseek
operator|=
name|FALSE
expr_stmt|;
name|restart
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|firstpage
condition|)
block|{
if|if
condition|(
name|firstline
condition|)
block|{
name|interp
argument_list|(
name|art_buf
argument_list|,
operator|(
sizeof|sizeof
name|art_buf
operator|)
argument_list|,
name|firstline
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAREOL
name|maybe_eol
argument_list|()
expr_stmt|;
comment|/* PWP */
endif|#
directive|endif
endif|CLEAREOL
name|fputs
argument_list|(
argument|art_buf
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|artopen
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* rewind article in case interp */
comment|/* forced a header parse */
block|}
else|else
block|{
name|ART_NUM
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|CLEAREOL
name|maybe_eol
argument_list|()
expr_stmt|;
comment|/* PWP */
endif|#
directive|endif
endif|CLEAREOL
name|printf
argument_list|(
literal|"Article %ld"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|ART_NUM
operator|)
name|toread
index|[
name|ng
index|]
operator|)
operator|-
literal|1
operator|+
name|was_read
argument_list|(
name|art
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAYMARK
if|if
condition|(
name|i
operator|||
name|dmcount
condition|)
block|{
name|printf
argument_list|(
literal|" (%ld more"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmcount
condition|)
name|printf
argument_list|(
literal|" + %ld Marked to return)"
argument_list|,
operator|(
name|long
operator|)
name|dmcount
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|" (%ld more)"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|NGS_LINE
index|]
operator|.
name|ht_flags
operator|&
name|HT_HIDE
condition|)
name|printf
argument_list|(
literal|" in %s"
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
block|}
name|start_header
argument_list|(
name|art
argument_list|)
expr_stmt|;
name|forcelast
operator|=
name|FALSE
expr_stmt|;
comment|/* we will have our day in court */
name|restart
operator|=
name|Nullch
expr_stmt|;
name|artline
operator|=
literal|0
expr_stmt|;
comment|/* start counting lines */
name|artpos
operator|=
literal|0
expr_stmt|;
name|vwtary
argument_list|(
name|artline
argument_list|,
name|artpos
argument_list|)
expr_stmt|;
comment|/* remember pos in file */
block|}
for|for
control|(
name|linenum
operator|=
operator|(
name|firstpage
condition|?
literal|2
else|:
literal|1
operator|)
init|;
name|in_header
operator|||
operator|(
ifdef|#
directive|ifdef
name|INNERSEARCH
name|innersearch
condition|?
name|innermore
argument_list|()
else|:
endif|#
directive|endif
name|linenum
operator|<
operator|(
name|firstpage
condition|?
name|initlines
else|:
operator|(
name|special
condition|?
name|slines
else|:
name|LINES
operator|)
operator|)
operator|)
condition|;
name|linenum
operator|++
control|)
block|{
comment|/* for each line on page */
if|if
condition|(
name|int_count
condition|)
block|{
comment|/* exit via interrupt? */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* get to left margin */
name|int_count
operator|=
literal|0
expr_stmt|;
comment|/* reset interrupt count */
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|DA_NORM
return|;
comment|/* skip out of loops */
block|}
if|if
condition|(
name|restart
condition|)
block|{
comment|/* did not finish last line? */
name|bufptr
operator|=
name|restart
expr_stmt|;
comment|/* then start again here */
name|restart
operator|=
name|Nullch
expr_stmt|;
comment|/* and reset the flag */
block|}
else|else
block|{
comment|/* not a restart */
if|if
condition|(
name|fgets
argument_list|(
name|art_buf
argument_list|,
name|LBUFLEN
argument_list|,
name|artfp
argument_list|)
operator|==
name|Nullch
condition|)
block|{
comment|/* if all done */
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|DA_NORM
return|;
comment|/* skip out of loops */
block|}
name|bufptr
operator|=
name|art_buf
expr_stmt|;
comment|/* so start at beginning */
name|art_buf
index|[
name|LBUFLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure string ends */
block|}
name|blinebeg
operator|=
name|bufptr
expr_stmt|;
comment|/* remember where we began */
name|alinebeg
operator|=
name|artpos
expr_stmt|;
comment|/* both in buffer and file */
if|if
condition|(
name|in_header
operator|&&
name|bufptr
operator|==
name|art_buf
condition|)
name|hide_this_line
operator|=
name|parseline
argument_list|(
name|art_buf
argument_list|,
name|do_hiding
argument_list|,
name|hide_this_line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|notesfiles
operator|&&
name|do_hiding
operator|&&
name|bufptr
operator|==
name|art_buf
operator|&&
operator|*
name|art_buf
operator|==
literal|'#'
operator|&&
name|isupper
argument_list|(
name|art_buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|art_buf
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|fgets
argument_list|(
name|art_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|art_buf
argument_list|)
argument_list|,
name|artfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|art_buf
argument_list|,
literal|'!'
argument_list|)
operator|!=
name|Nullch
condition|)
name|fgets
argument_list|(
name|art_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|art_buf
argument_list|)
argument_list|,
name|artfp
argument_list|)
expr_stmt|;
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
operator|=
name|ftell
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
comment|/* exclude notesfiles droppings */
name|hide_this_line
operator|=
name|TRUE
expr_stmt|;
comment|/* and do not print either */
name|notesfiles
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CUSTOMLINES
if|if
condition|(
name|hideline
operator|&&
name|bufptr
operator|==
name|art_buf
operator|&&
name|execute
argument_list|(
operator|&
name|hide_compex
argument_list|,
name|art_buf
argument_list|)
condition|)
name|hide_this_line
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|in_header
operator|&&
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_flags
operator|&
name|HT_MAGIC
condition|)
block|{
if|if
condition|(
name|in_header
operator|==
name|NGS_LINE
condition|)
block|{
name|hide_this_line
operator|=
operator|(
name|index
argument_list|(
name|art_buf
argument_list|,
literal|','
argument_list|)
operator|==
name|Nullch
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_header
operator|==
name|EXPIR_LINE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|htype
index|[
name|EXPIR_LINE
index|]
operator|.
name|ht_flags
operator|&
name|HT_HIDE
operator|)
condition|)
name|hide_this_line
operator|=
operator|(
name|strlen
argument_list|(
name|art_buf
argument_list|)
operator|<
literal|10
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_header
operator|==
name|SUBJ_LINE
operator|&&
name|htype
index|[
name|SUBJ_LINE
index|]
operator|.
name|ht_flags
operator|&
name|HT_MAGIC
condition|)
block|{
comment|/* is this the subject? */
name|int
name|length
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|art_buf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|artline
operator|++
expr_stmt|;
name|art_buf
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out newline */
ifdef|#
directive|ifdef
name|NOFIREWORKS
name|no_ulfire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|notesfiles
operator|=
operator|(
name|instr
argument_list|(
operator|&
name|art_buf
index|[
name|length
operator|-
literal|10
index|]
argument_list|,
literal|" - (nf"
argument_list|)
operator|!=
name|Nullch
operator|)
expr_stmt|;
if|if
condition|(
name|oldsubject
condition|)
block|{
name|length
operator|+=
literal|7
expr_stmt|;
name|fputs
argument_list|(
literal|"(SAME) "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|oldsubject
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|+
name|UG
operator|>
name|COLS
condition|)
block|{
comment|/* rarely true */
name|linenum
operator|++
expr_stmt|;
name|vwtary
argument_list|(
name|artline
argument_list|,
name|vrdary
argument_list|(
name|artline
operator|-
literal|1
argument_list|)
operator|+
name|COLS
argument_list|)
expr_stmt|;
name|artline
operator|++
expr_stmt|;
block|}
name|s
operator|=
name|art_buf
operator|+
literal|8
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make into 2 strings */
ifdef|#
directive|ifdef
name|CLEAREOL
name|maybe_eol
argument_list|()
expr_stmt|;
comment|/* PWP */
endif|#
directive|endif
endif|CLEAREOL
name|fputs
argument_list|(
argument|art_buf
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* print up through : */
if|if
condition|(
operator|!
name|UG
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|underprint
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* print subject underlined */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* and finish the line */
block|}
elseif|else
if|if
condition|(
name|hide_this_line
operator|&&
name|do_hiding
condition|)
block|{
comment|/* do not print line? */
name|linenum
operator|--
expr_stmt|;
comment|/* compensate for linenum++ */
if|if
condition|(
operator|!
name|in_header
condition|)
name|hide_this_line
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* just a normal line */
if|if
condition|(
name|highlight
operator|==
name|artline
condition|)
block|{
comment|/* this line to be highlit? */
if|if
condition|(
name|marking
operator|==
name|STANDOUT
condition|)
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
if|if
condition|(
name|erase_screen
condition|)
name|no_sofire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|standout
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
if|if
condition|(
name|erase_screen
condition|)
name|no_ulfire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|underline
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|'\n'
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INNERSEARCH
name|outputok
operator|=
operator|!
name|hide_everything
expr_stmt|;
comment|/* get it into register, hopefully */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLEAREOL
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
name|maybe_eol
argument_list|()
expr_stmt|;
comment|/* PWP */
endif|#
directive|endif
endif|CLEAREOL
ifdef|#
directive|ifdef
name|CUSTOMLINES
if|if
condition|(
name|pagestop
operator|&&
name|bufptr
operator|==
name|art_buf
operator|&&
name|execute
argument_list|(
operator|&
name|page_compex
argument_list|,
name|art_buf
argument_list|)
condition|)
name|linenum
operator|=
literal|32700
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|outpos
operator|=
literal|0
init|;
name|outpos
operator|<
name|COLS
condition|;
control|)
block|{
comment|/* while line has room */
if|if
condition|(
operator|*
name|bufptr
operator|>=
literal|' '
condition|)
block|{
comment|/* normal char? */
ifdef|#
directive|ifdef
name|ULSMARTS
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|bufptr
index|[
literal|1
index|]
operator|==
literal|'\b'
condition|)
block|{
if|if
condition|(
operator|!
name|under_lining
operator|&&
name|highlight
operator|!=
name|artline
ifdef|#
directive|ifdef
name|INNERSEARCH
operator|&&
name|outputok
endif|#
directive|endif
condition|)
block|{
name|under_lining
operator|++
expr_stmt|;
if|if
condition|(
name|UG
condition|)
block|{
if|if
condition|(
name|bufptr
operator|!=
name|buf
operator|&&
name|bufptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
name|outpos
operator|--
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
block|}
block|}
name|underline
argument_list|()
expr_stmt|;
block|}
name|bufptr
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|under_lining
condition|)
block|{
name|under_lining
operator|=
literal|0
expr_stmt|;
name|un_underline
argument_list|()
expr_stmt|;
if|if
condition|(
name|UG
condition|)
block|{
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|' '
condition|)
goto|goto
name|skip_put
goto|;
name|outpos
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ROTATION
if|if
condition|(
name|rotate
operator|&&
operator|!
name|in_header
operator|&&
name|isalpha
argument_list|(
operator|*
name|bufptr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|bufptr
operator|&
literal|31
operator|)
operator|<=
literal|13
condition|)
name|putchar
argument_list|(
operator|*
name|bufptr
operator|+
literal|13
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|bufptr
operator|-
literal|13
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|putchar
argument_list|(
operator|*
name|bufptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|UC
operator|&&
operator|(
operator|(
name|highlight
operator|==
name|artline
operator|&&
name|marking
operator|==
literal|1
operator|)
ifdef|#
directive|ifdef
name|ULSMARTS
operator|||
name|under_lining
endif|#
directive|endif
operator|)
condition|)
block|{
name|backspace
argument_list|()
expr_stmt|;
name|underchar
argument_list|()
expr_stmt|;
block|}
name|skip_put
label|:
name|bufptr
operator|++
expr_stmt|;
name|outpos
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|'\n'
operator|||
operator|!
operator|*
name|bufptr
condition|)
block|{
comment|/* newline? */
ifdef|#
directive|ifdef
name|ULSMARTS
if|if
condition|(
name|under_lining
condition|)
block|{
name|under_lining
operator|=
literal|0
expr_stmt|;
name|un_underline
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
operator|&&
name|outpos
operator|<
name|COLS
operator|-
literal|6
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%4d"
argument_list|,
name|artline
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|restart
operator|=
literal|0
expr_stmt|;
name|outpos
operator|=
literal|1000
expr_stmt|;
comment|/* signal normal \n */
block|}
elseif|else
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* tab? */
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
name|putchar
argument_list|(
operator|*
name|bufptr
argument_list|)
expr_stmt|;
name|bufptr
operator|++
expr_stmt|;
name|outpos
operator|+=
literal|8
operator|-
name|outpos
operator|%
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|'\f'
condition|)
block|{
comment|/* form feed? */
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
name|fputs
argument_list|(
literal|"^L"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufptr
operator|==
name|blinebeg
operator|&&
name|highlight
operator|!=
name|artline
condition|)
name|linenum
operator|=
literal|32700
expr_stmt|;
comment|/* how is that for a magic number? */
name|bufptr
operator|++
expr_stmt|;
name|outpos
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* other control char */
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
if|if
condition|(
name|highlight
operator|==
name|artline
operator|&&
operator|*
name|UC
operator|&&
name|marking
operator|==
literal|1
condition|)
block|{
name|backspace
argument_list|()
expr_stmt|;
name|underchar
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|bufptr
operator|+
literal|64
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
name|underchar
argument_list|()
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|bufptr
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
name|bufptr
operator|++
expr_stmt|;
name|outpos
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* end of column loop */
if|if
condition|(
name|outpos
operator|<
literal|1000
condition|)
block|{
comment|/* did line overflow? */
name|restart
operator|=
name|bufptr
expr_stmt|;
comment|/* restart here next time */
if|if
condition|(
name|AM
condition|)
block|{
comment|/* automatic margins on tty? */
if|if
condition|(
operator|!
name|XN
operator|&&
operator|*
name|bufptr
operator|==
literal|'\n'
condition|)
comment|/* need we simulate XN? */
name|restart
operator|=
literal|0
expr_stmt|;
comment|/* skip the newline */
block|}
else|else
block|{
comment|/* cursor just hangs there */
ifdef|#
directive|ifdef
name|INNERSEARCH
if|if
condition|(
name|outputok
condition|)
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* so move it down ourselves */
if|if
condition|(
operator|*
name|bufptr
operator|==
literal|'\n'
condition|)
name|restart
operator|=
literal|0
expr_stmt|;
comment|/* simulate XN if need be */
block|}
ifdef|#
directive|ifdef
name|CLEAREOL
comment|/* #ifdef INNERSEARCH 		    if (outputok) #endif 		    maybe_eol(); */
comment|/* PWP */
comment|/* comment this out for now 						    until I am sure it is 						    needed*/
endif|#
directive|endif
endif|CLEAREOL
block|}
comment|/* handle normal end of output line formalities */
if|if
condition|(
name|highlight
operator|==
name|artline
condition|)
block|{
comment|/* were we highlighting line? */
if|if
condition|(
name|marking
operator|==
name|STANDOUT
condition|)
name|un_standout
argument_list|()
expr_stmt|;
else|else
name|un_underline
argument_list|()
expr_stmt|;
name|highlight
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no more we are */
block|}
name|artline
operator|++
expr_stmt|;
comment|/* count the line just printed */
if|if
condition|(
name|artline
operator|-
name|LINES
operator|+
literal|1
operator|>
name|topline
condition|)
comment|/* did we just scroll top line off? */
name|topline
operator|=
name|artline
operator|-
name|LINES
operator|+
literal|1
expr_stmt|;
comment|/* then recompute top line # */
block|}
comment|/* determine actual position in file */
if|if
condition|(
name|restart
condition|)
comment|/* stranded somewhere in the buffer? */
name|artpos
operator|+=
name|restart
operator|-
name|blinebeg
expr_stmt|;
comment|/* just calculate position */
else|else
comment|/* no, ftell will do */
name|artpos
operator|=
name|ftell
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
comment|/* so do ftell */
name|vwtary
argument_list|(
name|artline
argument_list|,
name|artpos
argument_list|)
expr_stmt|;
comment|/* remember pos in file */
block|}
comment|/* end of line loop */
ifdef|#
directive|ifdef
name|INNERSEARCH
name|innersearch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hide_everything
condition|)
block|{
name|hide_everything
operator|=
name|FALSE
expr_stmt|;
operator|*
name|buf
operator|=
name|Ctl
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
goto|goto
name|fake_command
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|linenum
operator|>=
literal|32700
condition|)
comment|/* did last line have formfeed? */
name|vwtary
argument_list|(
name|artline
operator|-
literal|1
argument_list|,
operator|-
name|vrdary
argument_list|(
name|artline
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remember by negating pos in file */
name|special
operator|=
name|FALSE
expr_stmt|;
comment|/* end of page, so reset page length */
name|firstpage
operator|=
name|FALSE
expr_stmt|;
comment|/* and say it is not 1st time thru */
comment|/* extra loop bombout */
if|if
condition|(
name|artpos
operator|==
name|artsize
condition|)
block|{
comment|/* did we just now reach EOF? */
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|DA_NORM
return|;
comment|/* avoid --MORE--(100%) */
block|}
comment|/* not done with this article, so pretend we are a pager */
name|reask_pager
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|standout
argument_list|()
expr_stmt|;
comment|/* enter standout mode */
name|printf
argument_list|(
literal|"--MORE--(%ld%%)"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|artpos
operator|*
literal|100
operator|/
name|artsize
argument_list|)
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
comment|/* leave standout mode */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* reinp_pager:     			/* unused, commented for lint */
name|eat_typeahead
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_CHECKPOINTING
condition|)
block|{
name|printf
argument_list|(
literal|"(%d %d %d)"
argument_list|,
name|checkcount
argument_list|,
name|linenum
argument_list|,
name|artline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|checkcount
operator|>=
name|docheckwhen
operator|&&
name|linenum
operator|==
name|LINES
operator|&&
operator|(
name|artline
operator|>
literal|40
operator|||
name|checkcount
operator|>=
name|docheckwhen
operator|+
literal|10
operator|)
condition|)
block|{
comment|/* while he is reading a whole page */
comment|/* in an article he is interested in */
name|checkcount
operator|=
literal|0
expr_stmt|;
name|checkpoint_rc
argument_list|()
expr_stmt|;
comment|/* update .newsrc */
block|}
name|collect_subjects
argument_list|()
expr_stmt|;
comment|/* loads subject cache until */
comment|/* input is pending */
name|mode
operator|=
literal|'p'
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
if|if
condition|(
name|LINES
operator|<
literal|100
operator|&&
operator|!
name|int_count
condition|)
operator|*
name|buf
operator|=
literal|'\f'
expr_stmt|;
comment|/* on CONT fake up refresh */
else|else
block|{
operator|*
name|buf
operator|=
literal|'q'
expr_stmt|;
comment|/* on INTR or paper just quit */
block|}
block|}
name|carriage_return
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|CLEAREOL
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* and erase the prompt */
else|#
directive|else
if|if
condition|(
name|erase_screen
operator|&&
name|can_home_clear
condition|)
comment|/* PWP was here */
name|clear_rest
argument_list|()
expr_stmt|;
else|else
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* and erase the prompt */
endif|#
directive|endif
endif|CLEAREOL
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fake_command
label|:
comment|/* used by innersearch */
comment|/* parse and process pager command */
switch|switch
condition|(
name|page_switch
argument_list|()
condition|)
block|{
case|case
name|PS_ASK
case|:
comment|/* reprompt "--MORE--..." */
goto|goto
name|reask_pager
goto|;
case|case
name|PS_RAISE
case|:
comment|/* reparse on article level */
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|DA_RAISE
return|;
case|case
name|PS_TOEND
case|:
comment|/* fast pager loop exit */
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|DA_TOEND
return|;
case|case
name|PS_NORM
case|:
comment|/* display more article */
break|break;
block|}
block|}
comment|/* end of page loop */
block|}
end_function

begin_comment
comment|/* process pager commands */
end_comment

begin_function
name|int
name|page_switch
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'d'
case|:
case|case
name|Ctl
argument_list|(
literal|'d'
argument_list|)
case|:
comment|/* half page */
name|special
operator|=
name|TRUE
expr_stmt|;
name|slines
operator|=
name|LINES
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|marking
operator|&&
operator|*
name|blinebeg
operator|!=
literal|'\f'
ifdef|#
directive|ifdef
name|CUSTOMLINES
operator|&&
operator|(
operator|!
name|pagestop
operator|||
name|blinebeg
operator|!=
name|art_buf
operator|||
operator|!
name|execute
argument_list|(
operator|&
name|page_compex
argument_list|,
name|blinebeg
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|up_line
argument_list|()
expr_stmt|;
name|highlight
operator|=
operator|--
name|artline
expr_stmt|;
name|restart
operator|=
name|blinebeg
expr_stmt|;
name|artpos
operator|=
name|alinebeg
expr_stmt|;
block|}
return|return
name|PS_NORM
return|;
case|case
literal|'!'
case|:
comment|/* shell escape */
name|escapade
argument_list|()
expr_stmt|;
return|return
name|PS_ASK
return|;
ifdef|#
directive|ifdef
name|INNERSEARCH
case|case
name|Ctl
argument_list|(
literal|'i'
argument_list|)
case|:
name|gline
operator|=
literal|3
expr_stmt|;
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"^[^%c]"
argument_list|,
operator|*
name|blinebeg
argument_list|)
expr_stmt|;
name|compile
argument_list|(
operator|&
name|gcompex
argument_list|,
name|cmd_buf
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|caseG
goto|;
case|case
name|Ctl
argument_list|(
literal|'g'
argument_list|)
case|:
name|gline
operator|=
literal|3
expr_stmt|;
name|compile
argument_list|(
operator|&
name|gcompex
argument_list|,
literal|"^Subject:"
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|caseG
goto|;
case|case
literal|'g'
case|:
comment|/* in-article search */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|FALSE
argument_list|)
condition|)
comment|/* get rest of command */
return|return
name|PS_ASK
return|;
name|s
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|compile
argument_list|(
operator|&
name|gcompex
argument_list|,
name|s
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
comment|/* compile regular expression */
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|PS_ASK
return|;
block|}
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
comment|/* FALL THROUGH */
name|caseG
label|:
case|case
literal|'G'
case|:
block|{
comment|/* ART_LINE lines_to_skip = 0; */
name|ART_POS
name|start_where
decl_stmt|;
if|if
condition|(
name|gline
operator|<
literal|0
operator|||
name|gline
operator|>
name|LINES
operator|-
literal|2
condition|)
name|gline
operator|=
name|LINES
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"Start here? %d>=? %d\n"
argument_list|,
argument|topline + gline +
literal|1
argument_list|,
argument|artline
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|buf
operator|==
name|Ctl
argument_list|(
literal|'i'
argument_list|)
operator|||
name|topline
operator|+
name|gline
operator|+
literal|1
operator|>=
name|artline
condition|)
name|start_where
operator|=
name|artpos
expr_stmt|;
comment|/* in case we had a line wrap */
else|else
block|{
name|start_where
operator|=
name|vrdary
argument_list|(
name|topline
operator|+
name|gline
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_where
operator|<
literal|0
condition|)
name|start_where
operator|=
operator|-
name|start_where
expr_stmt|;
block|}
if|if
condition|(
name|start_where
operator|<
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
condition|)
name|start_where
operator|=
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
expr_stmt|;
name|fseek
argument_list|(
name|artfp
argument_list|,
operator|(
name|long
operator|)
name|start_where
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|innersearch
operator|=
literal|0
expr_stmt|;
comment|/* assume not found */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|artfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
comment|/* lines_to_skip++; 		NOT USED NOW */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"Test %s"
argument_list|,
argument|buf
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|execute
argument_list|(
operator|&
name|gcompex
argument_list|,
name|buf
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|innersearch
operator|=
name|ftell
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|innersearch
condition|)
block|{
name|fseek
argument_list|(
name|artfp
argument_list|,
name|artpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"(Not found)"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|PS_ASK
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"On page? %ld<=? %ld\n"
argument_list|,
argument|(long)innersearch
argument_list|,
argument|(long)artpos
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|innersearch
operator|<=
name|artpos
condition|)
block|{
comment|/* already on page? */
if|if
condition|(
name|innersearch
operator|<
name|artpos
condition|)
block|{
name|artline
operator|=
name|topline
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|vrdary
argument_list|(
name|artline
argument_list|)
operator|<
name|innersearch
condition|)
name|artline
operator|++
expr_stmt|;
block|}
name|highlight
operator|=
name|artline
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"@ %d\n"
argument_list|,
argument|highlight
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|topline
operator|=
name|highlight
operator|-
name|gline
expr_stmt|;
if|if
condition|(
name|topline
operator|<
operator|-
literal|1
condition|)
name|topline
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\f'
expr_stmt|;
comment|/* fake up a refresh */
name|innersearch
operator|=
literal|0
expr_stmt|;
return|return
name|page_switch
argument_list|()
return|;
block|}
else|else
block|{
comment|/* who knows how many lines it is? */
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
name|hide_everything
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|PS_NORM
return|;
block|}
else|#
directive|else
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
name|Ctl
argument_list|(
literal|'g'
argument_list|)
case|:
name|notincl
argument_list|(
literal|"g"
argument_list|)
expr_stmt|;
return|return
name|PS_ASK
return|;
endif|#
directive|endif
case|case
literal|'\n'
case|:
comment|/* one line */
name|special
operator|=
name|TRUE
expr_stmt|;
name|slines
operator|=
literal|2
expr_stmt|;
return|return
name|PS_NORM
return|;
ifdef|#
directive|ifdef
name|ROTATION
case|case
literal|'X'
case|:
name|rotate
operator|=
operator|!
name|rotate
expr_stmt|;
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
literal|'l'
case|:
case|case
literal|'\f'
case|:
comment|/* refresh screen */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
block|{
name|printf
argument_list|(
literal|"Topline = %d"
argument_list|,
argument|topline
argument_list|)
name|FLUSH
expr_stmt|;
name|gets
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|clear
argument_list|()
expr_stmt|;
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
name|artline
operator|=
name|topline
expr_stmt|;
if|if
condition|(
name|artline
operator|<
literal|0
condition|)
name|artline
operator|=
literal|0
expr_stmt|;
name|firstpage
operator|=
operator|(
name|topline
operator|<
literal|0
operator|)
expr_stmt|;
return|return
name|PS_NORM
return|;
case|case
literal|'b'
case|:
case|case
literal|'\b'
case|:
comment|/* I like backspace for this -- PWP */
comment|/* Leaving it undocumented in case */
comment|/* I want to steal the key--LAW */
case|case
name|Ctl
argument_list|(
literal|'b'
argument_list|)
case|:
block|{
comment|/* back up a page */
name|ART_LINE
name|target
decl_stmt|;
ifndef|#
directive|ifndef
name|CLEAREOL
name|clear
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|can_home_clear
condition|)
comment|/* if we can home do it -- PWP */
name|home_cursor
argument_list|()
expr_stmt|;
else|else
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|CLEAREOL
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
comment|/* reposition article file */
name|target
operator|=
name|topline
operator|-
operator|(
name|LINES
operator|-
literal|2
operator|)
expr_stmt|;
name|artline
operator|=
name|topline
expr_stmt|;
do|do
block|{
name|artline
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|artline
operator|>=
literal|0
operator|&&
name|artline
operator|>
name|target
operator|&&
name|vrdary
argument_list|(
name|artline
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
do|;
name|topline
operator|=
name|artline
expr_stmt|;
comment|/* remember top line of screen */
comment|/*  (line # within article file) */
if|if
condition|(
name|artline
operator|<
literal|0
condition|)
name|artline
operator|=
literal|0
expr_stmt|;
name|firstpage
operator|=
operator|(
name|topline
operator|<
literal|0
operator|)
expr_stmt|;
return|return
name|PS_NORM
return|;
block|}
case|case
literal|'h'
case|:
block|{
comment|/* help */
name|int
name|cmd
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|=
name|help_page
argument_list|()
operator|)
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|PS_ASK
return|;
block|}
case|case
literal|'\177'
case|:
case|case
literal|'\0'
case|:
comment|/* treat del,break as 'n' */
operator|*
name|buf
operator|=
literal|'n'
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
name|Ctl
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'u'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'|'
case|:
name|mark_as_read
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* mark article as read */
comment|/* FALL THROUGH */
case|case
literal|'#'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'='
case|:
case|case
literal|'?'
case|:
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'j'
case|:
case|case
name|Ctl
argument_list|(
literal|'k'
argument_list|)
case|:
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
case|case
name|Ctl
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
literal|'Q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
case|case
name|Ctl
argument_list|(
literal|'r'
argument_list|)
case|:
case|case
literal|'v'
case|:
case|case
literal|'Y'
case|:
ifndef|#
directive|ifndef
name|ROTATION
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
endif|#
directive|endif
case|case
name|Ctl
argument_list|(
literal|'x'
argument_list|)
case|:
case|case
literal|'^'
case|:
ifdef|#
directive|ifdef
name|ROTATION
name|rotate
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|reread
operator|=
name|FALSE
expr_stmt|;
name|do_hiding
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"nNpP"
argument_list|,
operator|*
name|buf
argument_list|)
operator|==
name|Nullch
operator|&&
name|index
argument_list|(
literal|"wWsS!&|/?123456789."
argument_list|,
operator|*
name|buf
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|setdfltcmd
argument_list|()
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
comment|/* enter standout mode */
name|printf
argument_list|(
name|prompt
argument_list|,
name|mailcall
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
comment|/* print prompt, whatever it is */
name|un_standout
argument_list|()
expr_stmt|;
comment|/* leave standout mode */
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|PS_RAISE
return|;
comment|/* and pretend we were at end */
ifdef|#
directive|ifdef
name|ROTATION
case|case
literal|'x'
case|:
name|rotate
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
literal|'y'
case|:
case|case
name|Ctl
argument_list|(
literal|'v'
argument_list|)
case|:
comment|/* I like emacs -- PWP */
comment|/* Leaving it undocumented in case */
comment|/* I want to steal the key--LAW */
case|case
literal|' '
case|:
comment|/* continue current article */
if|if
condition|(
name|erase_screen
condition|)
block|{
comment|/* -e? */
ifndef|#
directive|ifndef
name|CLEAREOL
name|clear
argument_list|()
expr_stmt|;
comment|/* clear screen */
else|#
directive|else
if|if
condition|(
name|can_home_clear
condition|)
comment|/* if we can home do it -- PWP */
name|home_cursor
argument_list|()
expr_stmt|;
else|else
name|clear
argument_list|()
expr_stmt|;
comment|/* else clear screen */
endif|#
directive|endif
endif|CLEAREOL
if|if
condition|(
operator|*
name|blinebeg
operator|!=
literal|'\f'
ifdef|#
directive|ifdef
name|CUSTOMLINES
operator|&&
operator|(
operator|!
name|pagestop
operator|||
name|blinebeg
operator|!=
name|art_buf
operator|||
operator|!
name|execute
argument_list|(
operator|&
name|page_compex
argument_list|,
name|blinebeg
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|restart
operator|=
name|blinebeg
expr_stmt|;
name|artline
operator|--
expr_stmt|;
comment|/* restart this line */
name|artpos
operator|=
name|alinebeg
expr_stmt|;
if|if
condition|(
name|marking
condition|)
comment|/* and mark repeated line */
name|highlight
operator|=
name|artline
expr_stmt|;
block|}
name|topline
operator|=
name|artline
expr_stmt|;
comment|/* and remember top line of screen */
comment|/*  (line # within article file) */
block|}
elseif|else
if|if
condition|(
name|marking
operator|&&
operator|*
name|blinebeg
operator|!=
literal|'\f'
ifdef|#
directive|ifdef
name|CUSTOMLINES
operator|&&
operator|(
operator|!
name|pagestop
operator|||
name|blinebeg
operator|!=
name|art_buf
operator|||
operator|!
name|execute
argument_list|(
operator|&
name|page_compex
argument_list|,
name|blinebeg
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* are we marking repeats? */
name|up_line
argument_list|()
expr_stmt|;
comment|/* go up one line */
name|highlight
operator|=
operator|--
name|artline
expr_stmt|;
comment|/* and get ready to highlight */
name|restart
operator|=
name|blinebeg
expr_stmt|;
comment|/*   the old line */
name|artpos
operator|=
name|alinebeg
expr_stmt|;
block|}
return|return
name|PS_NORM
return|;
case|case
literal|'q'
case|:
comment|/* quit this article? */
name|do_hiding
operator|=
name|TRUE
expr_stmt|;
return|return
name|PS_TOEND
return|;
default|default:
name|fputs
argument_list|(
argument|hforhelp
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
return|return
name|PS_ASK
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INNERSEARCH
end_ifdef

begin_function
name|bool
name|innermore
parameter_list|()
block|{
if|if
condition|(
name|artpos
operator|<
name|innersearch
condition|)
block|{
comment|/* not even on page yet? */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"Not on page %ld< %ld\n"
argument_list|,
argument|(long)artpos
argument_list|,
argument|(long)innersearch
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|artpos
operator|==
name|innersearch
condition|)
block|{
comment|/* just got onto page? */
name|isrchline
operator|=
name|artline
expr_stmt|;
comment|/* remember first line after */
name|highlight
operator|=
name|artline
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"There it is %ld = %ld, %d @ %d\n"
argument_list|,
argument|(long)artpos
argument_list|,
argument|(long)innersearch
argument_list|,
argument|hide_everything
argument_list|,
argument|highlight
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hide_everything
condition|)
block|{
comment|/* forced refresh? */
name|topline
operator|=
name|highlight
operator|-
name|gline
expr_stmt|;
if|if
condition|(
name|topline
operator|<
operator|-
literal|1
condition|)
name|topline
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* let refresh do it all */
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_INNERSRCH
condition|)
name|printf
argument_list|(
literal|"Not far enough? %d<? %d + %d\n"
argument_list|,
argument|artline
argument_list|,
argument|isrchline
argument_list|,
argument|gline
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|artline
operator|<
name|isrchline
operator|+
name|gline
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

