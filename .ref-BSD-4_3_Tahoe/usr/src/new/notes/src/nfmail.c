begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_comment
comment|/* bsd only? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: nfmail.c,v 1.7.0.8 85/10/20 11:09:09 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	nfmail  *  *	A simple program which goes through standard input, which   *	should be a formatted mail article with headers, and  *	parses out the "Subject:" line.  We then turn around and  *	use it to invoke "nfpipe" and send the letter to the appropriate  *	notesfile (specified on the nfmail command line).  *  *	Original coding:	Wayne Hamilton,	U of Illinois CSO (I think)  *	Modified:		Stuart Cracraft, SRI International  *  */
end_comment

begin_function_decl
name|char
modifier|*
name|getadr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|IGNORESIZE
value|256
end_define

begin_decl_stmt
specifier|static
name|char
name|title
index|[
name|BUFSIZ
index|]
init|=
literal|"No Subject Line"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	next three variables declared in "parsepath".  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|fromsys
index|[
name|SYSSZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gave it to us */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|origsys
index|[
name|SYSSZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* started here */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|authname
index|[
name|NAMESZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* author */
end_comment

begin_decl_stmt
name|char
name|Nfpipe
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nfpipe pathname */
end_comment

begin_decl_stmt
name|char
name|tmpname
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scratch file */
end_comment

begin_decl_stmt
name|char
name|system_rc
index|[]
init|=
literal|"/usr/lib/Mail.rc"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_IGNORE
value|32
end_define

begin_decl_stmt
name|char
name|ignore
index|[
name|MAX_IGNORE
index|]
index|[
name|IGNORESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ignore_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|AnchorSearch
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|Ftmp
decl_stmt|;
name|char
name|command
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|from
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|oldfrom
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|gotsubj
init|=
name|FALSE
decl_stmt|,
name|gotfrom
init|=
name|FALSE
decl_stmt|,
name|gotoldfrom
init|=
name|FALSE
decl_stmt|;
name|int
name|stripheader
init|=
name|FALSE
decl_stmt|;
comment|/* leave headers in */
name|int
name|letterstatus
init|=
literal|0
decl_stmt|;
comment|/* director msg? */
name|int
name|tossit
decl_stmt|;
name|char
modifier|*
name|myrc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|home
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|skipwhite
argument_list|()
decl_stmt|;
name|struct
name|io_f
name|io
decl_stmt|;
name|struct
name|daddr_f
name|where
decl_stmt|;
name|struct
name|when_f
name|entered
decl_stmt|;
name|struct
name|id_f
name|respid
decl_stmt|;
name|struct
name|auth_f
name|auth
decl_stmt|;
name|struct
name|when_f
name|whentime
decl_stmt|;
name|int
name|notenum
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|startup
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
comment|/* blast command */
name|argv
operator|++
expr_stmt|;
name|from
index|[
literal|0
index|]
operator|=
name|oldfrom
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* zero them */
while|while
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-s\0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* strip headers */
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|stripheader
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-F\0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* floating match */
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
comment|/* to next arg */
name|AnchorSearch
operator|=
name|FALSE
expr_stmt|;
comment|/* floating search */
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-d\0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* enable dirmsg */
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|letterstatus
operator||=
name|DIRMES
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-m\0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* specify .mailrc */
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|getignore
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Need to specifiy -m file\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
comment|/* next arg */
block|}
break|break;
comment|/* not an arg */
block|}
if|if
condition|(
operator|!
name|argc
condition|)
block|{
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-F] [-s] [-m .mailrc-file]<notesfile>\n"
argument_list|,
name|Invokedas
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/*  *	build ourselves a scratch file.  If we can't, then pass the   *	mail on with a default title.  */
name|sprintf
argument_list|(
name|tmpname
argument_list|,
literal|"/tmp/nfm%05d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Nfpipe
argument_list|,
literal|"%s/nfpipe"
argument_list|,
name|BIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Ftmp
operator|=
name|fopen
argument_list|(
name|tmpname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nfmail: can't fopen temp file, but the mail gets thru\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s %s -t \"Mail to %s\""
argument_list|,
name|Nfpipe
argument_list|,
operator|*
name|argv
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|dopipe
argument_list|(
name|command
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* ... remove scratch file */
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* and leave */
block|}
comment|/*  *	Step through the system Mail.rc file and pilfer the ignore commands.  *	Then, process the .mailrc file in the home directory if there is one.  */
name|getignore
argument_list|(
name|system_rc
argument_list|)
expr_stmt|;
comment|/*  *	read through the mail looking for the subject line.  */
while|while
condition|(
name|gets
argument_list|(
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|buf
index|[
literal|0
index|]
condition|)
break|break;
comment|/* header's end */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
comment|/* continuation */
goto|goto
name|doit
goto|;
comment|/* use same "tossit" */
name|tossit
operator|=
name|stripheader
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"Subject: "
argument_list|,
literal|9
argument_list|)
condition|)
comment|/* check for title */
block|{
if|if
condition|(
operator|!
name|gotsubj
condition|)
comment|/* only first one */
block|{
name|strcpy
argument_list|(
name|title
argument_list|,
name|buf
operator|+
literal|9
argument_list|)
expr_stmt|;
name|gotsubj
operator|=
name|TRUE
expr_stmt|;
block|}
name|tossit
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|doit
goto|;
comment|/* skip other tests */
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"From: "
argument_list|,
literal|6
argument_list|)
condition|)
comment|/* author */
block|{
comment|/* grab user name */
if|if
condition|(
operator|!
name|gotfrom
condition|)
comment|/* only once */
block|{
name|strcpy
argument_list|(
name|from
argument_list|,
name|buf
operator|+
literal|6
argument_list|)
expr_stmt|;
name|gotfrom
operator|=
name|TRUE
expr_stmt|;
block|}
name|tossit
operator|=
name|FALSE
expr_stmt|;
comment|/* keep all from lines */
goto|goto
name|doit
goto|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|">From"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|gotoldfrom
condition|)
block|{
name|strcpy
argument_list|(
name|oldfrom
argument_list|,
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* save it */
name|gotoldfrom
operator|++
expr_stmt|;
block|}
name|tossit
operator|=
name|FALSE
expr_stmt|;
comment|/* save all addresses */
block|}
elseif|else
if|if
condition|(
name|stripheader
operator|&&
operator|!
name|shouldignore
argument_list|(
name|buf
argument_list|)
condition|)
name|tossit
operator|=
name|FALSE
expr_stmt|;
comment|/* "ignore" only when stripping */
name|doit
label|:
comment|/* for continuation lines */
if|if
condition|(
name|tossit
operator|==
name|FALSE
condition|)
name|fprintf
argument_list|(
name|Ftmp
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* send the header line also */
block|}
comment|/* of header parsing loop */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|Ftmp
argument_list|)
expr_stmt|;
comment|/* blank after headers */
name|copy
argument_list|(
name|stdin
argument_list|,
name|Ftmp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|Ftmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Ftmp
operator|=
name|fopen
argument_list|(
name|tmpname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* ... remove scratch file */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nfmail: can't re-fopen temp file %s\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/*  *	Now that we have collected the letter and parsed such banalities  *	as the title and the author and stripped any header lines that we  *	don't care to hear about, it's time to put the letter into  *	the notesfile.  We use routines scammed from our news/notes gateway  *	code to look at the title and determine if it's a response to  *	a previous letter.  This allows us to have the correct linkage  *	for mail sent to a notesfile....  */
if|if
condition|(
operator|(
name|i
operator|=
name|init
argument_list|(
operator|&
name|io
argument_list|,
operator|*
name|argv
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* zap scratch file */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open notesfile %s (retcode %d)\n"
argument_list|,
name|Invokedas
argument_list|,
operator|*
name|argv
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*  	 * Should have a better scheme for knowing why can't open 	 */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
comment|/* bad nf or such */
block|}
name|p
operator|=
name|title
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
comment|/* leading trash */
name|p
operator|++
expr_stmt|;
comment|/* skip */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"re: "
argument_list|,
literal|4
argument_list|)
operator|||
comment|/* it looks like */
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Re: "
argument_list|,
literal|4
argument_list|)
operator|||
comment|/* a response */
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"RE: "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
do|do
block|{
for|for
control|(
name|p
operator|+=
literal|3
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* drop spaces */
block|}
do|while
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"re: "
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Re: "
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"RE: "
argument_list|,
literal|4
argument_list|)
condition|)
do|;
name|strncpy
argument_list|(
name|io
operator|.
name|xstring
argument_list|,
name|p
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
comment|/* load it */
name|io
operator|.
name|xstring
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* and terminate it */
name|notenum
operator|=
name|findtitle
argument_list|(
operator|&
name|io
argument_list|,
name|io
operator|.
name|descr
operator|.
name|d_nnote
argument_list|,
name|AnchorSearch
argument_list|)
expr_stmt|;
comment|/* start at back */
block|}
else|else
block|{
name|notenum
operator|=
literal|0
expr_stmt|;
comment|/* has to be new */
block|}
comment|/*  *	OK. By now, we have a "notenum" if the article can be pegged  *	as a response to one of our notes.  *	Otherwise, notenum==0 and we'll have to turn it into  *	a base note.  */
name|gettime
argument_list|(
operator|&
name|whentime
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/*       *	load the user's name       */
if|if
condition|(
name|from
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* got one */
block|{
name|p
operator|=
name|q
operator|=
name|from
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|q
operator|=
operator|++
name|p
expr_stmt|;
comment|/* get innermost<..> */
name|p
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* zap */
name|parsepath
argument_list|(
name|q
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* actually break it */
block|}
else|else
block|{
if|if
condition|(
name|oldfrom
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|parsepath
argument_list|(
name|oldfrom
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* try for something */
block|}
else|else
block|{
name|strcpy
argument_list|(
name|authname
argument_list|,
literal|"MAILER-DAEMON"
argument_list|)
expr_stmt|;
comment|/* general catch-all */
name|origsys
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* local */
block|}
block|}
name|strncpy
argument_list|(
name|auth
operator|.
name|aname
argument_list|,
name|authname
argument_list|,
name|NAMESZ
argument_list|)
expr_stmt|;
comment|/* user */
if|if
condition|(
name|origsys
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strncpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|Authsystem
argument_list|,
name|HOMESYSSZ
argument_list|)
expr_stmt|;
comment|/* local host */
else|else
name|strncpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|origsys
argument_list|,
name|HOMESYSSZ
argument_list|)
expr_stmt|;
comment|/* system */
name|auth
operator|.
name|aname
index|[
name|NAMESZ
operator|-
literal|1
index|]
operator|=
name|auth
operator|.
name|asystem
index|[
name|HOMESYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* chop */
name|auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
comment|/* uid (none) */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"parse path returns the following:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"authname: %s\n"
argument_list|,
name|authname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"origsys: %s\n"
argument_list|,
name|origsys
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fromsys: %s\n"
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|notenum
operator|>
literal|0
condition|)
block|{
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|Ftmp
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|i
operator|=
name|putresp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|putresp
argument_list|,
name|notenum
argument_list|,
operator|&
name|entered
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|note
argument_list|,
name|LOCKIT
argument_list|,
operator|&
name|respid
argument_list|,
name|ADDID
argument_list|,
name|System
argument_list|,
name|ADDTIME
argument_list|,
operator|&
name|whentime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
operator|&
name|title
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
comment|/* strip blanks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TITLEN
condition|;
name|i
operator|++
control|)
comment|/* shift down */
block|{
if|if
condition|(
operator|(
name|title
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
comment|/* want assignment */
break|break;
comment|/* end */
block|}
name|title
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate for sure */
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|Ftmp
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
name|notenum
operator|=
name|putnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|letterstatus
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|LOCKIT
argument_list|,
name|ADDID
argument_list|,
name|System
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
block|}
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* update numbers and close */
name|fclose
argument_list|(
name|Ftmp
argument_list|)
expr_stmt|;
comment|/* close and ... */
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* ... remove scratch file */
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|skipwhite
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Get all the "ignore" commands from the file. Do nothing if the file  *	does not exist.  */
end_comment

begin_macro
name|getignore
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buff
index|[
name|IGNORESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|p
operator|=
name|buff
expr_stmt|;
name|fgets
argument_list|(
name|buff
argument_list|,
name|IGNORESIZE
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipwhite
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"ignore"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|skipwhite
argument_list|(
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/*  *	Collect the tags of the ignore command  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_cnt
operator|>=
name|MAX_IGNORE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too many ignore tags\n"
argument_list|,
name|Invokedas
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|skipwhite
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ignore
index|[
name|ignore_cnt
index|]
init|;
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|;
operator|*
operator|(
name|q
operator|++
operator|)
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
control|)
empty_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|shouldignore
argument_list|(
name|ignore
index|[
name|ignore_cnt
index|]
argument_list|)
condition|)
block|{
name|ignore_cnt
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|skipwhite
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	Should we ignore this line?  */
end_comment

begin_macro
name|shouldignore
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ignore_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|ignore
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|ignore
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	simple command feeds what is left of the file "File" into  *	a pipe feeding stdin of "command".  *  */
end_comment

begin_macro
name|dopipe
argument_list|(
argument|command
argument_list|,
argument|File
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|File
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|Pipe
decl_stmt|;
if|if
condition|(
operator|(
name|Pipe
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't popen (%s)!?\n"
argument_list|,
name|Invokedas
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
name|copy
argument_list|(
name|File
argument_list|,
name|Pipe
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|Pipe
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	copy rest of file "File" to "To".  */
end_comment

begin_macro
name|copy
argument_list|(
argument|From
argument_list|,
argument|To
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|From
decl_stmt|,
modifier|*
name|To
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|From
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|To
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

