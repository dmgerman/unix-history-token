begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: readem.c,v 1.7.0.3 85/10/06 01:42:00 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/* *	this particular collection of junk handles the basic idea *	of what to do when you are showing a note. *	It displays the note, and then manages to collect enough info *	from the terminal to either progress to the next note or *	show some of the responses. * *	original author : rob kolstad *	modified	: ray essick may 22, 1981 *	modified (again): Ray Essick December 1981 *	modified (more):  Ray Essick, February 1982 * */
end_comment

begin_macro
name|readem
argument_list|(
argument|io
argument_list|,
argument|readnum
argument_list|,
argument|firstdis
argument_list|,
argument|resp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|firstdis
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|resp_f
name|rsprec
decl_stmt|;
name|struct
name|io_f
name|io2
decl_stmt|;
name|FILE
modifier|*
name|txtfile
decl_stmt|;
name|int
name|rrecnum
decl_stmt|,
name|roffset
decl_stmt|;
name|char
name|tonf
index|[
name|WDLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* for forwarding */
name|char
name|ntitle
index|[
name|TITLEN
operator|+
literal|20
index|]
decl_stmt|;
comment|/* scratch space */
name|char
name|nfsave
index|[
name|WDLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* path name for 's' and 'S' */
name|int
name|c
decl_stmt|;
comment|/* input char */
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* scratch pointers */
name|int
name|replot
decl_stmt|;
comment|/* whether to change what's on the screen */
name|int
name|toresp
decl_stmt|;
comment|/* init entry as resp */
name|int
name|forward
decl_stmt|;
comment|/* scroll forward/backward on deleted note */
name|int
name|toauth
decl_stmt|,
comment|/* send to author */
name|znum
decl_stmt|,
comment|/* forward as resp to this note */
name|znote
decl_stmt|,
name|zresp
decl_stmt|,
comment|/* scratch for asearch */
name|i
decl_stmt|,
name|j
decl_stmt|,
name|wtext
decl_stmt|;
comment|/* send mail with text */
name|char
name|cmdline
index|[
name|CMDLEN
index|]
decl_stmt|;
comment|/* leggo brand build-a-command */
name|int
name|retcode
decl_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
comment|/* first pass always writes to the screen */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init so grabs character */
name|forward
operator|=
literal|1
expr_stmt|;
comment|/* default to scroll forward */
name|toresp
operator|=
operator|(
name|resp
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* for entry */
while|while
condition|(
literal|1
condition|)
block|{
name|x
argument_list|(
name|readnum
operator|<
literal|0
argument_list|,
literal|"readem: given bad readnum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|readnum
operator|>
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|)
name|readnum
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
if|if
condition|(
name|readnum
operator|==
literal|0
operator|&&
name|io
operator|->
name|descr
operator|.
name|d_plcy
operator|==
literal|0
condition|)
comment|/* empty notesfile */
return|return
literal|0
return|;
comment|/* so back to the index */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DELETED
condition|)
if|if
condition|(
name|forward
condition|)
goto|goto
name|nextnt
goto|;
comment|/* forward scroll */
else|else
goto|goto
name|prevnote
goto|;
comment|/* backward scroll */
if|if
condition|(
name|toresp
condition|)
block|{
name|toresp
operator|=
literal|0
expr_stmt|;
goto|goto
name|showit
goto|;
block|}
if|if
condition|(
name|replot
condition|)
name|retcode
operator|=
name|dspnote
argument_list|(
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
comment|/* show the note if we need new one */
name|replot
operator|=
literal|1
expr_stmt|;
comment|/* reset later if don't want replot */
name|forward
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|input
label|:
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMPT
name|printf
argument_list|(
name|PROMPT
argument_list|)
expr_stmt|;
comment|/* let him know we're ready */
endif|#
directive|endif
endif|PROMPT
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\10 \10"
argument_list|)
expr_stmt|;
comment|/* Kurt wants this to go away */
block|}
else|else
block|{
name|c
operator|=
name|retcode
expr_stmt|;
name|retcode
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* make sure don't loop! */
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
comment|/* if he doesn't know what to type */
case|case
literal|'h'
case|:
name|help
argument_list|(
name|RDMHLP
argument_list|)
expr_stmt|;
comment|/* print the pseudo-man page */
goto|goto
name|showit
goto|;
case|case
literal|'D'
case|:
comment|/* delete this note/response */
if|if
condition|(
name|resp
condition|)
comment|/* check to see if his note */
block|{
if|if
condition|(
operator|(
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not your response"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not your note"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use 'Z' to delete policy"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|(
literal|"Delete? (y/n):   \b\b"
argument_list|)
operator|==
literal|'n'
condition|)
goto|goto
name|showit
goto|;
name|printf
argument_list|(
literal|"\r                \r"
argument_list|)
expr_stmt|;
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* CRITICAL section */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* this should catch most */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* and an up to date descriptor */
if|if
condition|(
name|resp
condition|)
comment|/* go about deleting it */
block|{
if|if
condition|(
name|resp
operator|==
name|note
operator|.
name|n_nresp
operator|&&
name|inorder
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|)
condition|)
block|{
name|delresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|rrecnum
argument_list|,
name|roffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_nresp
operator|--
expr_stmt|;
comment|/* adjust note response count */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* must free up the lock */
break|break;
comment|/* show next response */
block|}
else|else
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Can't delete: networked, or not last response"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release lock here too */
continue|continue;
block|}
block|}
else|else
comment|/* its a note */
block|{
if|if
condition|(
name|note
operator|.
name|n_nresp
operator|||
name|inorder
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|)
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Can't delete; note has responses or is networked"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release the lock */
continue|continue;
block|}
name|delnote
argument_list|(
name|io
argument_list|,
name|readnum
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resp
operator|=
literal|0
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release the lock */
continue|continue;
block|}
case|case
literal|'E'
case|:
comment|/* edit an article */
if|if
condition|(
name|resp
condition|)
comment|/* check to see if his note */
block|{
if|if
condition|(
operator|(
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not your response"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not your note"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sorry, E doesn't work for policy notes yet"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* CRITICAL section */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* this should catch most */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* and an up to date descriptor */
if|if
condition|(
name|resp
condition|)
comment|/* go about deleting it */
block|{
if|if
condition|(
name|resp
operator|==
name|note
operator|.
name|n_nresp
operator|&&
name|inorder
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|)
condition|)
block|{
name|delresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|rrecnum
argument_list|,
name|roffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_nresp
operator|--
expr_stmt|;
comment|/* adjust note response count */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* must free up the lock */
name|sprintf
argument_list|(
name|nfsave
argument_list|,
literal|"/tmp/nfe%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* build scr file */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|nfsave
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: scrfile"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|nfsave
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
comment|/* dump it */
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* also flushes it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|nfsave
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: edit reopen"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|addresp
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|readnum
argument_list|,
name|EDIT
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* up to date */
comment|/* add it back in ! */
name|x
argument_list|(
name|unlink
argument_list|(
name|nfsave
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: edit unlink"
argument_list|)
expr_stmt|;
break|break;
comment|/* show next response */
block|}
else|else
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Can't edit: networked, or not last response"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release lock here too */
continue|continue;
block|}
block|}
else|else
comment|/* its a note */
block|{
if|if
condition|(
name|note
operator|.
name|n_nresp
operator|||
name|inorder
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|)
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Can't edit; note has responses or is networked"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release the lock */
continue|continue;
block|}
name|delnote
argument_list|(
name|io
argument_list|,
name|readnum
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resp
operator|=
literal|0
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release the lock */
name|sprintf
argument_list|(
name|nfsave
argument_list|,
literal|"/tmp/nfe%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* build scr file */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|nfsave
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: scrfile"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|nfsave
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
comment|/* dump it */
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* also flushes it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|nfsave
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: edit reopen"
argument_list|)
expr_stmt|;
name|znum
operator|=
name|addnote
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
literal|"Edit note text:"
argument_list|,
literal|"Note title: "
argument_list|,
operator|&
name|note
operator|.
name|ntitle
argument_list|,
name|EDIT
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|nfsave
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: edit unlink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|znum
operator|>
literal|0
condition|)
name|readnum
operator|=
name|znum
expr_stmt|;
comment|/* this is the one */
continue|continue;
block|}
case|case
literal|'Z'
case|:
comment|/* zap notes/responses - directors only */
comment|/* kills any note/response */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* up to date descriptor */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not a director"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|(
literal|"Delete? (y/n):   \b\b"
argument_list|)
operator|==
literal|'n'
condition|)
goto|goto
name|showit
goto|;
comment|/* replotter */
name|printf
argument_list|(
literal|"\r                  \r"
argument_list|)
expr_stmt|;
comment|/*  *		should log the deletion here, so the "meta-director" can  *		watch for fascist directors preying on the peasants.  */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
comment|/* deleting policy */
block|{
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* lock us up */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* grab up-to-date */
name|io
operator|->
name|descr
operator|.
name|d_plcy
operator|=
literal|0
expr_stmt|;
comment|/* its gone now */
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* replace descriptor */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* back to the index */
block|}
if|if
condition|(
name|resp
condition|)
comment|/* delete a response */
block|{
name|delresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|rrecnum
argument_list|,
name|roffset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* kill it */
name|note
operator|.
name|n_nresp
operator|--
expr_stmt|;
comment|/* and response count */
break|break;
comment|/* display next response */
block|}
else|else
name|delnote
argument_list|(
name|io
argument_list|,
name|readnum
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
comment|/* replot the current note/response */
case|case
literal|'\f'
case|:
comment|/* everyone else uses ^L, might as well */
name|showit
label|:
comment|/* come here to refill screen */
if|if
condition|(
name|replot
operator|==
literal|0
condition|)
continue|continue;
comment|/* screen appears fine */
if|if
condition|(
name|resp
condition|)
break|break;
comment|/* show him the response */
else|else
block|{
name|replot
operator|=
literal|1
expr_stmt|;
comment|/* make sure it gets done */
continue|continue;
block|}
name|nextnt
label|:
case|case
literal|'\r'
case|:
comment|/* wants the next note */
case|case
literal|'\n'
case|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* policy leaves */
if|if
condition|(
operator|++
name|readnum
operator|>
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|)
block|{
operator|*
name|firstdis
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
return|return
literal|0
return|;
block|}
name|resp
operator|=
literal|0
expr_stmt|;
comment|/* reset response index */
continue|continue;
case|case
literal|'m'
case|:
comment|/* mail a note/response via Unix mail */
name|toauth
operator|=
literal|0
expr_stmt|;
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* to others and no text */
goto|goto
name|sendmail
goto|;
case|case
literal|'M'
case|:
comment|/* same as 'm' but with text */
name|toauth
operator|=
literal|0
expr_stmt|;
name|wtext
operator|=
literal|1
expr_stmt|;
comment|/* to others with text */
goto|goto
name|sendmail
goto|;
case|case
literal|'P'
case|:
name|toauth
operator|=
literal|1
expr_stmt|;
name|wtext
operator|=
literal|1
expr_stmt|;
comment|/* to author with text */
goto|goto
name|sendmail
goto|;
case|case
literal|'p'
case|:
name|toauth
operator|=
literal|1
expr_stmt|;
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* to author, no text */
goto|goto
name|sendmail
goto|;
name|sendmail
label|:
comment|/* jump to here once set mail parms */
if|if
condition|(
name|resp
condition|)
block|{
name|strcpy
argument_list|(
name|ntitle
argument_list|,
literal|"Re: "
argument_list|)
expr_stmt|;
comment|/* prefix */
name|strcat
argument_list|(
name|ntitle
argument_list|,
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
comment|/* append title */
name|mailit
argument_list|(
name|io
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
name|ntitle
argument_list|,
name|toauth
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|ntitle
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
name|mailit
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
name|ntitle
argument_list|,
name|toauth
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
block|}
goto|goto
name|showit
goto|;
comment|/* replot current page */
case|case
literal|'!'
case|:
comment|/* wants to fork a shell */
name|gshell
argument_list|()
expr_stmt|;
goto|goto
name|showit
goto|;
case|case
literal|'q'
case|:
comment|/* quit this, maybe whole system */
ifdef|#
directive|ifdef
name|K_KEY
case|case
literal|'k'
case|:
endif|#
directive|endif
endif|K_KEY
return|return
name|QUITSEQ
return|;
case|case
literal|'\04'
case|:
return|return
name|QUITFAST
return|;
comment|/* leave totally */
case|case
literal|'z'
case|:
comment|/* total exit w/update */
return|return
name|QUITUPD
return|;
case|case
literal|'Q'
case|:
comment|/* exit system without updating sequencer */
ifdef|#
directive|ifdef
name|K_KEY
case|case
literal|'K'
case|:
endif|#
directive|endif
endif|K_KEY
return|return
name|QUITNOSEQ
return|;
case|case
literal|'i'
case|:
comment|/* go back to note index */
operator|*
name|firstdis
operator|=
name|readnum
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'\b'
case|:
case|case
literal|'-'
case|:
comment|/* display previous response */
if|if
condition|(
name|resp
operator|<=
literal|0
condition|)
goto|goto
name|prevnote
goto|;
comment|/* '-' at base note */
if|if
condition|(
operator|--
name|resp
condition|)
break|break;
comment|/* show the previous response */
continue|continue;
comment|/* show him the base note */
name|prevnote
label|:
comment|/* display previous note */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* policy leaves */
name|forward
operator|=
literal|0
expr_stmt|;
comment|/* set to scroll backwards on deleted note */
if|if
condition|(
operator|--
name|readnum
operator|<
literal|1
condition|)
block|{
name|readnum
operator|=
literal|1
expr_stmt|;
comment|/* zero is policy, so stop at 1 */
name|forward
operator|=
literal|1
expr_stmt|;
comment|/* bounce off bottom end */
continue|continue;
comment|/* go hunt for the right note */
block|}
name|resp
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* policy leaves */
name|retcode
operator|=
name|tsearch
argument_list|(
name|io
argument_list|,
name|readnum
operator|-
literal|1
argument_list|,
name|c
operator|==
literal|'x'
argument_list|)
expr_stmt|;
comment|/* look it up */
if|if
condition|(
name|retcode
operator|<=
literal|0
condition|)
name|replot
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|readnum
operator|=
name|retcode
expr_stmt|;
name|resp
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|showit
goto|;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
comment|/* author search from current spot */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* not from policy ! */
name|znote
operator|=
name|readnum
expr_stmt|;
name|zresp
operator|=
name|resp
expr_stmt|;
if|if
condition|(
name|zresp
operator|==
literal|0
condition|)
name|znote
operator|--
expr_stmt|;
else|else
name|zresp
operator|++
expr_stmt|;
comment|/* select 'next' */
name|retcode
operator|=
name|asearch
argument_list|(
name|io
argument_list|,
operator|&
name|znote
argument_list|,
operator|&
name|zresp
argument_list|,
operator|(
name|c
operator|==
literal|'a'
operator|)
argument_list|)
expr_stmt|;
comment|/* look */
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|replot
operator|=
literal|0
expr_stmt|;
goto|goto
name|showit
goto|;
comment|/* didn't want anything */
block|}
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
name|replot
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|readnum
operator|=
name|znote
expr_stmt|;
name|resp
operator|=
name|zresp
expr_stmt|;
comment|/* set returned values */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* grab right descriptor */
block|}
goto|goto
name|showit
goto|;
comment|/* and display them */
case|case
literal|'d'
case|:
comment|/* toggle a notes director status */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* tell him what's up */
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Anonymous: %s   Networked: %s"
argument_list|,
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|ANONOK
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|,
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
comment|/* leave on screen */
goto|goto
name|showit
goto|;
block|}
if|if
condition|(
name|resp
operator|==
literal|0
condition|)
comment|/* toggle a note */
block|{
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DIRMES
condition|)
name|note
operator|.
name|n_stat
operator|&=
name|NOT
name|DIRMES
expr_stmt|;
else|else
name|note
operator|.
name|n_stat
operator||=
name|DIRMES
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* replace */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
goto|goto
name|showit
goto|;
block|}
else|else
comment|/* toggle a response */
block|{
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* this locks the resp index too */
name|getrrec
argument_list|(
name|io
argument_list|,
name|rrecnum
argument_list|,
operator|&
name|rsprec
argument_list|)
expr_stmt|;
comment|/* grab that block */
if|if
condition|(
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator|&
name|DIRMES
condition|)
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator|&=
name|NOT
name|DIRMES
expr_stmt|;
else|else
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator||=
name|DIRMES
expr_stmt|;
name|putrrec
argument_list|(
name|io
argument_list|,
name|rrecnum
argument_list|,
operator|&
name|rsprec
argument_list|)
expr_stmt|;
comment|/* replace */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
goto|goto
name|showit
goto|;
comment|/* and redisplay */
block|}
case|case
literal|'e'
case|:
comment|/* allow him to edit his title */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't touch */
if|if
condition|(
name|resp
condition|)
goto|goto
name|badkey
goto|;
comment|/* bell and reinput */
else|else
block|{
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|globuid
operator|!=
operator|(
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|||
comment|/* check uid */
name|strcmp
argument_list|(
name|System
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
operator|!=
literal|0
operator|)
condition|)
comment|/* other sys */
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Not your note"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"New Title: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|gline
argument_list|(
name|ntitle
argument_list|,
name|TITLEN
operator|-
literal|1
argument_list|)
operator|)
operator|==
literal|1
condition|)
comment|/* glom onto a title */
continue|continue;
comment|/* empty title, leave alone */
name|strclean
argument_list|(
name|ntitle
argument_list|)
expr_stmt|;
comment|/* zip controls */
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* well, update it */
name|strncpy
argument_list|(
name|note
operator|.
name|ntitle
argument_list|,
name|ntitle
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
name|note
operator|.
name|ntitle
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null for sure */
name|putnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* and replace */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
goto|goto
name|showit
goto|;
comment|/* replot the message */
block|}
case|case
literal|'t'
case|:
comment|/* talk to the author of a note */
if|if
condition|(
name|resp
condition|)
name|talkto
argument_list|(
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
else|else
name|talkto
argument_list|(
operator|&
name|note
operator|.
name|n_auth
argument_list|)
expr_stmt|;
goto|goto
name|showit
goto|;
comment|/* and replot the current message */
case|case
literal|'W'
case|:
comment|/* write a response with the text */
case|case
literal|'w'
case|:
comment|/* let him write a response */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* get up to date */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|RESPOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sorry, you are not allowed to write"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* back to key processing */
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No responses allowed to policy note"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* no responses to policy note */
block|}
if|if
condition|(
name|c
operator|==
literal|'w'
condition|)
name|txtfile
operator|=
name|NULL
expr_stmt|;
comment|/* no preface text */
else|else
block|{
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"/tmp/nfx%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: bad scrfile"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|cmdline
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: reopen"
argument_list|)
expr_stmt|;
block|}
name|zresp
operator|=
name|addresp
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|readnum
argument_list|,
name|EDIT
argument_list|)
expr_stmt|;
comment|/* put it in */
if|if
condition|(
name|zresp
operator|>
literal|0
condition|)
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* update descriptor */
if|if
condition|(
name|txtfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* toss out scratch */
name|x
argument_list|(
name|unlink
argument_list|(
name|cmdline
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: couldnt unlink scratch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zresp
condition|)
name|resp
operator|=
name|zresp
expr_stmt|;
comment|/* show the new */
goto|goto
name|showit
goto|;
case|case
literal|'B'
case|:
comment|/* bitch, bitch, bitch */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io2
argument_list|,
name|GRIPES
argument_list|)
operator|<
literal|0
condition|)
comment|/* check gripe file */
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No gripe file"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|NULL
argument_list|,
literal|"Edit Gripe text:"
argument_list|,
literal|"Gripe Header: "
argument_list|,
name|NULL
argument_list|,
name|EDIT
argument_list|)
expr_stmt|;
comment|/* let him put the note in */
name|finish
argument_list|(
operator|&
name|io2
argument_list|)
expr_stmt|;
comment|/* close up the gripe file */
block|}
goto|goto
name|showit
goto|;
case|case
literal|'C'
case|:
comment|/* copy to other notesfile with editing */
case|case
literal|'c'
case|:
comment|/* copy to other notefile without editing */
if|if
condition|(
name|c
operator|==
literal|'C'
condition|)
name|wtext
operator|=
literal|1
expr_stmt|;
else|else
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* determine which */
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nCopy to: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gline
argument_list|(
name|tonf
argument_list|,
name|NNLEN
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|showit
goto|;
comment|/* gave up */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io2
argument_list|,
name|tonf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"Can't find notesfile %s\n"
argument_list|,
name|tonf
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"/tmp/nfx%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem:creat scratch failed"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|cmdline
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* close it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: couldnt reopen"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'n'
expr_stmt|;
comment|/* default to note */
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|WRITOK
argument_list|)
operator|&&
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|READOK
argument_list|)
operator|&&
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|RESPOK
argument_list|)
condition|)
name|c
operator|=
name|askyn
argument_list|(
literal|"Copy as Response (y/n)? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|WRITOK
argument_list|)
condition|)
if|if
condition|(
operator|!
name|resp
operator|&&
name|wtext
operator|==
literal|0
condition|)
comment|/* use old title */
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
else|else
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
literal|"Edit copied text:"
argument_list|,
literal|"Copy Title: "
argument_list|,
name|NULL
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|znum
operator|=
name|limindx
argument_list|(
operator|&
name|io2
argument_list|)
condition|)
name|addresp
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
name|znum
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"You haven't permission"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'b'
expr_stmt|;
comment|/* leave message */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|io
operator|->
name|nf
argument_list|,
name|io2
operator|.
name|nf
argument_list|)
operator|==
literal|0
condition|)
comment|/* if was this notefile */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* get new descriptor */
name|finish
argument_list|(
operator|&
name|io2
argument_list|)
expr_stmt|;
comment|/* close up that notefile */
if|if
condition|(
name|txtfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* throw it away */
name|x
argument_list|(
name|unlink
argument_list|(
name|cmdline
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: couldnt unlink scratch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
block|{
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* leave on screen */
block|}
else|else
goto|goto
name|showit
goto|;
comment|/* redo the screen */
case|case
literal|'f'
case|:
comment|/* Forward (copy) string to other notefile w/o edit */
case|case
literal|'F'
case|:
comment|/* Forward (copy) string to other notefile w/edit */
if|if
condition|(
name|resp
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f/F only allowed from base note"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'F'
condition|)
name|wtext
operator|=
literal|1
expr_stmt|;
else|else
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* determine which */
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nForward to: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gline
argument_list|(
name|tonf
argument_list|,
name|NNLEN
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|showit
goto|;
comment|/* gave up */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io2
argument_list|,
name|tonf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"Can't find notesfile %s\n"
argument_list|,
name|tonf
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"/tmp/nfx%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem:creat scratch failed"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|cmdline
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod failed"
argument_list|)
expr_stmt|;
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* close it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: couldnt reopen"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'n'
expr_stmt|;
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|WRITOK
argument_list|)
condition|)
block|{
if|if
condition|(
name|wtext
operator|==
literal|0
condition|)
name|znum
operator|=
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|NOEDIT
argument_list|)
expr_stmt|;
else|else
name|znum
operator|=
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
literal|"Edit copy text:"
argument_list|,
literal|"Copy Title:"
argument_list|,
name|NULL
argument_list|,
name|EDIT
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem:creat scratch failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|note
operator|.
name|n_nresp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wtext
condition|)
comment|/* if editing */
name|printf
argument_list|(
literal|"Forwarding response %d of %d"
argument_list|,
name|i
argument_list|,
name|note
operator|.
name|n_nresp
argument_list|)
expr_stmt|;
comment|/* \n by addresp() below */
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|i
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rrecnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* hit end of chain */
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem:creat scratch failed"
argument_list|)
expr_stmt|;
name|addresp
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
name|znum
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|cmdline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem:creat scratch failed"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"You haven't permission"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'b'
expr_stmt|;
comment|/* leave message */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|io
operator|->
name|nf
argument_list|,
name|io2
operator|.
name|nf
argument_list|)
operator|==
literal|0
condition|)
comment|/* if was this notefile */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* get new descriptor */
name|finish
argument_list|(
operator|&
name|io2
argument_list|)
expr_stmt|;
comment|/* close up that notefile */
if|if
condition|(
name|txtfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* throw it away */
name|x
argument_list|(
name|unlink
argument_list|(
name|cmdline
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: couldnt unlink scratch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
block|{
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* leave on screen */
block|}
else|else
goto|goto
name|showit
goto|;
comment|/* redo the screen */
case|case
literal|'N'
case|:
comment|/* go to an archive */
name|sprintf
argument_list|(
name|tonf
argument_list|,
literal|"%s/%s"
argument_list|,
name|ARCHDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|)
expr_stmt|;
comment|/* build dest */
goto|goto
name|donest
goto|;
comment|/* share common code */
case|case
literal|'n'
case|:
comment|/* nest notesfiles - a stack */
name|at
argument_list|(
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  New notesfile: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"               \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gline
argument_list|(
name|tonf
argument_list|,
name|NNLEN
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|showit
goto|;
comment|/* forget it, replot */
name|donest
label|:
comment|/* used by N */
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* save fids */
if|if
condition|(
operator|(
name|i
operator|=
name|control
argument_list|(
name|tonf
argument_list|,
name|NOSEQ
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* do the other */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* some error there */
if|if
condition|(
name|opennf
argument_list|(
name|io
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Couldn't reopen notesfile %s"
argument_list|,
name|io
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|QUITNOSEQ
return|;
comment|/* don't update */
block|}
if|if
condition|(
name|i
operator|==
name|QUITFAST
condition|)
comment|/* he in a hurry? */
return|return
name|QUITFAST
return|;
comment|/* oblige him */
goto|goto
name|showit
goto|;
comment|/* redisplay page */
case|case
literal|'s'
case|:
comment|/* place text at end of 'nfsave' */
case|case
literal|'S'
case|:
comment|/* place the whole string */
name|at
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"File name:             \b\b\b\b\b\b\b\b\b\b\b\b"
argument_list|)
expr_stmt|;
name|znum
operator|=
name|gline
argument_list|(
name|nfsave
argument_list|,
name|WDLEN
argument_list|)
expr_stmt|;
name|at
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|znum
operator|+
literal|11
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* overwrite */
if|if
condition|(
name|znum
operator|==
literal|1
condition|)
comment|/* no file */
block|{
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
comment|/* tell him didn't do */
name|printf
argument_list|(
literal|"No Text Saved"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
name|q
operator|=
name|nfsave
expr_stmt|;
comment|/* kill leading spaces */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip them */
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
comment|/* move down */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
for|for
control|(
operator|--
name|q
init|;
condition|;
name|q
operator|--
control|)
comment|/* strip trailing */
block|{
if|if
condition|(
operator|*
name|q
operator|!=
literal|' '
condition|)
break|break;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip trailing */
block|}
if|if
condition|(
name|nfsave
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
comment|/* pipe */
block|{
name|p
operator|=
literal|"Pipe"
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* hold stat result */
if|if
condition|(
name|stat
argument_list|(
name|nfsave
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
comment|/* find it? */
name|p
operator|=
literal|"Appended"
expr_stmt|;
else|else
name|p
operator|=
literal|"New File"
expr_stmt|;
comment|/* prolly new */
block|}
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
comment|/* save single page */
block|{
if|if
condition|(
name|resp
condition|)
block|{
name|znum
operator|=
name|savtxt
argument_list|(
name|io
argument_list|,
name|nfsave
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|znum
operator|=
name|savtxt
argument_list|(
name|io
argument_list|,
name|nfsave
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* save whole string */
block|{
name|znum
operator|=
name|savtxt
argument_list|(
name|io
argument_list|,
name|nfsave
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|note
operator|.
name|n_nresp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|i
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rrecnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* hit end of chain */
name|znum
operator|+=
name|savtxt
argument_list|(
name|io
argument_list|,
name|nfsave
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|at
argument_list|(
literal|0
argument_list|,
name|PROMPTMSGX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Saved %d lines in \"%s\" [%s]"
argument_list|,
name|znum
argument_list|,
name|nfsave
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
comment|/* dont erase it */
continue|continue;
comment|/* don't replot */
case|case
literal|'j'
case|:
comment|/* goto next note/resp */
case|case
literal|'l'
case|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* policy returns */
if|if
condition|(
name|resp
operator|==
name|note
operator|.
name|n_nresp
condition|)
goto|goto
name|findnext
goto|;
comment|/* at end of the responses for this note */
if|if
condition|(
operator|(
name|resp
operator|=
name|nxtresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|resp
argument_list|,
operator|&
name|io
operator|->
name|stime
argument_list|)
operator|)
operator|>
literal|0
condition|)
break|break;
comment|/* go show it */
else|else
goto|goto
name|findnext
goto|;
comment|/* try next note ! */
name|findnext
label|:
case|case
literal|'J'
case|:
comment|/* next unread note */
case|case
literal|'L'
case|:
comment|/* like J */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* policy note returns */
name|resp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|readnum
operator|=
name|nxtnote
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|io
operator|->
name|stime
argument_list|)
operator|)
operator|>
literal|0
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'L'
operator|||
name|c
operator|==
literal|'l'
condition|)
comment|/* leave */
return|return
name|QUITSEQ
return|;
comment|/* and update... */
operator|*
name|firstdis
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
comment|/* last index page */
return|return
literal|0
return|;
comment|/* and show it */
block|}
case|case
literal|'+'
case|:
case|case
literal|';'
case|:
case|case
literal|' '
case|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* such is the fate of policy notes */
name|resp
operator|++
expr_stmt|;
if|if
condition|(
name|resp
operator|>
name|note
operator|.
name|n_nresp
condition|)
goto|goto
name|nextnt
goto|;
break|break;
case|case
literal|'*'
case|:
comment|/* skip to last note */
name|resp
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
break|break;
comment|/* and show it */
case|case
literal|'='
case|:
comment|/* go back to the base note */
name|resp
operator|=
literal|0
expr_stmt|;
comment|/* reset index into responses */
continue|continue;
case|case
literal|'1'
case|:
comment|/* skip n responses */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|note
operator|.
name|n_nresp
operator|<
literal|1
condition|)
goto|goto
name|nextnt
goto|;
name|resp
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* let him skip all over responses */
if|if
condition|(
name|resp
operator|>
name|note
operator|.
name|n_nresp
condition|)
name|resp
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
comment|/* dont go past end */
break|break;
default|default:
comment|/* something we haven't covered */
name|badkey
label|:
comment|/* so can jump down here */
name|printf
argument_list|(
literal|"\07"
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
comment|/* leave whatever is up on the screen */
continue|continue;
block|}
if|if
condition|(
name|resp
operator|>
name|note
operator|.
name|n_nresp
condition|)
name|resp
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
comment|/* set to the end */
if|if
condition|(
name|resp
operator|==
literal|0
condition|)
continue|continue;
comment|/* wound up at base note */
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|resp
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rrecnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* get a new descriptor */
goto|goto
name|showit
goto|;
comment|/* dropped something */
block|}
name|retcode
operator|=
name|dspresp
argument_list|(
name|io
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|rsprec
argument_list|,
name|roffset
argument_list|,
name|resp
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
comment|/* show the darn thing */
name|replot
operator|=
literal|0
expr_stmt|;
comment|/* leave the response on the screen */
block|}
block|}
end_block

end_unit

