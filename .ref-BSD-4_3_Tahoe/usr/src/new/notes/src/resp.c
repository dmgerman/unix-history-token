begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: resp.c,v 1.7 85/01/18 15:38:30 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  * putresp (io, text, status, noteno, anon)  *  *	writes out a response to noteno in the last position.  *	returns 0 to indicate note has been deleted,  *	otherwise it returns the response number it inserted.  *  *  * delresp(io, noteno, resprec, resphys)  *  *	Deletes PHYSICAL response located at resprec (record id)  *	resphys (internal subscript), updates note's response count  *  *  * getfrsp(io) gets the next free response index -- simple free list chained  *   off first two bytes of file, currently.  *  */
end_comment

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* declare for type checking */
end_comment

begin_macro
name|putresp
argument_list|(
argument|io
argument_list|,
argument|where
argument_list|,
argument|status
argument_list|,
argument|noteno
argument_list|,
argument|adate
argument_list|,
argument|auth
argument_list|,
argument|note
argument_list|,
argument|lockit
argument_list|,
argument|theid
argument_list|,
argument|addid
argument_list|,
argument|fromsys
argument_list|,
argument|addtime
argument_list|,
argument|rcvdtime
argument_list|)
end_macro

begin_comment
comment|/* all input params */
end_comment

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|daddr_f
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|when_f
modifier|*
name|adate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|auth_f
modifier|*
name|auth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|id_f
modifier|*
name|theid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fromsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addtime - whether to modify time stamps - useed for compression */
end_comment

begin_decl_stmt
name|struct
name|when_f
modifier|*
name|rcvdtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time to mark as written */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|phys
decl_stmt|,
comment|/* physical subscript number */
name|lastin
decl_stmt|;
comment|/* address of resp record in memory */
name|struct
name|resp_f
name|resp
decl_stmt|;
if|if
condition|(
name|lockit
condition|)
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* entirely critical */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NFINVALID
condition|)
block|{
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|opennf
argument_list|(
name|io
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* and updated descriptor */
if|if
condition|(
name|lockit
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|getnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|note
operator|->
name|n_stat
operator|&
name|DELETED
operator|)
operator|!=
literal|0
condition|)
comment|/* is note gone? */
block|{
comment|/*  	 * see, it could be deleted by someone else in the 	 * mean time... 	 */
if|if
condition|(
name|lockit
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* not so critical now */
return|return
literal|0
return|;
comment|/* putresp failed */
block|}
if|if
condition|(
name|note
operator|->
name|n_rindx
operator|<
literal|0
condition|)
comment|/* is there an attached response record ? */
block|{
name|lastin
operator|=
name|note
operator|->
name|n_rindx
operator|=
name|getfrsp
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* no, make one */
name|resp
operator|.
name|r_first
operator|=
literal|1
expr_stmt|;
name|resp
operator|.
name|r_last
operator|=
literal|0
expr_stmt|;
comment|/* counts */
name|resp
operator|.
name|r_previous
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* no previous */
name|resp
operator|.
name|r_next
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* no next */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RESPSZ
condition|;
name|i
operator|++
control|)
name|resp
operator|.
name|r_stat
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark all as undeleted at start */
block|}
else|else
name|getrrec
argument_list|(
name|io
argument_list|,
name|lastin
operator|=
name|note
operator|->
name|n_rindx
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* get first resp record */
name|i
operator|=
name|phys
operator|=
literal|0
expr_stmt|;
comment|/* logical/phys records start here */
comment|/*  *	should update this to take advantage of r_first and r_last  *	as it would speed up writing responses in long note strings.  */
while|while
condition|(
name|i
operator|<
name|note
operator|->
name|n_nresp
condition|)
comment|/* until we get to end */
block|{
if|if
condition|(
name|phys
operator|>=
name|RESPSZ
condition|)
comment|/* off end? -- need next recd */
block|{
name|phys
operator|=
literal|0
expr_stmt|;
comment|/* beginning of next one */
name|getrrec
argument_list|(
name|io
argument_list|,
name|lastin
operator|=
name|resp
operator|.
name|r_next
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* next recd */
block|}
if|if
condition|(
operator|(
name|resp
operator|.
name|r_stat
index|[
name|phys
index|]
operator|&
name|DELETED
operator|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
comment|/* count this entry if undeleted */
name|phys
operator|++
expr_stmt|;
comment|/* always count these */
block|}
comment|/*       * could have gone off end with last phys++      */
if|if
condition|(
name|phys
operator|>=
name|RESPSZ
condition|)
block|{
name|phys
operator|=
literal|0
expr_stmt|;
name|resp
operator|.
name|r_next
operator|=
name|getfrsp
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|putrrec
argument_list|(
name|io
argument_list|,
name|lastin
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* out w/modified link */
name|resp
operator|.
name|r_previous
operator|=
name|lastin
expr_stmt|;
comment|/* back ptr */
name|lastin
operator|=
name|resp
operator|.
name|r_next
expr_stmt|;
name|resp
operator|.
name|r_next
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* helps debugging */
name|resp
operator|.
name|r_first
operator|=
name|note
operator|->
name|n_nresp
operator|+
literal|1
expr_stmt|;
comment|/* front and */
name|resp
operator|.
name|r_last
operator|=
name|resp
operator|.
name|r_first
operator|-
literal|1
expr_stmt|;
comment|/* last. */
comment|/*  	 * r_last is bumped just before the putrrec() below. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RESPSZ
condition|;
name|i
operator|++
control|)
block|{
name|resp
operator|.
name|r_stat
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark all as undeleted */
block|}
block|}
name|note
operator|->
name|n_nresp
operator|++
expr_stmt|;
comment|/* one more response! */
name|resp
operator|.
name|r_addr
index|[
name|phys
index|]
operator|=
operator|*
name|where
expr_stmt|;
if|if
condition|(
name|addtime
condition|)
name|gettime
argument_list|(
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
else|else
name|copydate
argument_list|(
name|rcvdtime
argument_list|,
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* use supplied */
name|copydate
argument_list|(
name|adate
argument_list|,
operator|&
name|resp
operator|.
name|r_when
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* copy date over */
name|copyauth
argument_list|(
name|auth
argument_list|,
operator|&
name|resp
operator|.
name|r_auth
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* and author */
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|resp
operator|.
name|r_from
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* who gave it to us */
if|if
condition|(
name|addid
condition|)
comment|/* generate unique id */
block|{
ifdef|#
directive|ifdef
name|SHAREDATA
name|strmove
argument_list|(
name|System
argument_list|,
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* load sys name */
else|#
directive|else
else|! SHAREDATA
name|strmove
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_id
operator|.
name|sys
argument_list|,
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SHAREDATA
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|uniqid
operator|=
operator|++
operator|(
name|io
operator|->
name|descr
operator|.
name|d_id
operator|.
name|uniqid
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UNIQPLEX
argument_list|)
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|uniqid
operator|+=
name|UNIQPLEX
operator|*
name|io
operator|->
name|descr
operator|.
name|d_nfnum
expr_stmt|;
comment|/* mpx in the nf number */
endif|#
directive|endif
endif|defined(UNIQPLEX)
block|}
else|else
block|{
comment|/* use the supplied unique id */
name|strmove
argument_list|(
name|theid
operator|->
name|sys
argument_list|,
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
expr_stmt|;
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|uniqid
operator|=
name|theid
operator|->
name|uniqid
expr_stmt|;
block|}
name|resp
operator|.
name|r_stat
index|[
name|phys
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|addtime
condition|)
comment|/* timestamp ? */
block|{
name|gettime
argument_list|(
operator|&
name|note
operator|->
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* last modified entire note */
name|gettime
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lastm
argument_list|)
expr_stmt|;
comment|/* last modified entire file */
block|}
name|resp
operator|.
name|r_last
operator|++
expr_stmt|;
comment|/* 1 more there */
name|putrrec
argument_list|(
name|io
argument_list|,
name|lastin
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* order of these three keeps disk consistent */
if|if
condition|(
name|lockit
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|io
operator|->
name|nrspwrit
operator|++
expr_stmt|;
comment|/* add count of writes */
return|return
name|note
operator|->
name|n_nresp
return|;
comment|/* success */
block|}
end_block

begin_comment
comment|/*  *	getfrsp()  *  *	get the next open response block.  */
end_comment

begin_macro
name|getfrsp
argument_list|(
argument|io
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* will contain the free pointer */
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"getfrsp: seek I"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|read
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
operator|<
sizeof|sizeof
name|i
argument_list|,
literal|"getfrsp: read"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* next free */
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"getfrsp: seek II"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|write
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
operator|<
sizeof|sizeof
name|i
argument_list|,
literal|"getfrsp: write"
argument_list|)
expr_stmt|;
return|return
name|i
operator|-
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  *	delresp()  *  *	delete a PHYSICAL response.  This takes the actual place  *	the response lives in rather than the logical response  *	number.  *  *	Updates r_first and r_last for the rest of the response  *	chain.  */
end_comment

begin_macro
name|delresp
argument_list|(
argument|io
argument_list|,
argument|noteno
argument_list|,
argument|resprec
argument_list|,
argument|resphys
argument_list|,
argument|lockit
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|resp_f
name|resp
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* follows resp chain */
if|if
condition|(
name|lockit
condition|)
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* all critical */
name|getrrec
argument_list|(
name|io
argument_list|,
name|resprec
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resp
operator|.
name|r_stat
index|[
name|resphys
index|]
operator|&
name|DELETED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  	 * makes sure that someone hasn't zapped at same time 	 */
name|resp
operator|.
name|r_stat
index|[
name|resphys
index|]
operator||=
name|DELETED
expr_stmt|;
comment|/* deleted */
name|resp
operator|.
name|r_last
operator|--
expr_stmt|;
comment|/* fix count */
comment|/*  	 *	if r_first> r_last, we have an empty block. 	 *	unfortunate waste of space that is rectified 	 *	by compression later. 	 */
name|putrrec
argument_list|(
name|io
argument_list|,
name|resprec
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|resp
operator|.
name|r_next
operator|)
operator|>=
literal|0
condition|)
comment|/* for rest of chain */
block|{
name|getrrec
argument_list|(
name|io
argument_list|,
name|i
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* get it */
name|resp
operator|.
name|r_first
operator|--
expr_stmt|;
name|resp
operator|.
name|r_last
operator|--
expr_stmt|;
comment|/* fix indices */
name|putrrec
argument_list|(
name|io
argument_list|,
name|i
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* and replace */
block|}
name|getnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* update the note */
operator|--
name|note
operator|.
name|n_nresp
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* count deletes */
name|io
operator|->
name|descr
operator|.
name|d_delresp
operator|++
expr_stmt|;
comment|/* used by compress */
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lockit
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

