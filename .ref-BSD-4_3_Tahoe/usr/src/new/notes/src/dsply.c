begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: dsply.c,v 1.7.0.2 85/03/18 20:54:06 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  * dspnote(io,note) struct io_f *io; struct note_f *note;  *  *    displays a completely formatted note on the screen.  It calls  *    gettrec to get the text of the note.  *  * dspresp(io,note,resp,phys,logical) is a little trickier.  *  *   it prints out the response to<note> from response form<resp>  *   (at index of<resp> of<phys>).<logical> is the logical number  *   of the note and is displayed.  *  *	Original coding:	Rob Kolstad	Winter 1980  *	Modified:		Ray Essick	December 1981  *		- reordered display so went top to bottom, left to right  *		- to facilitate use on dumb terminals (or tty's)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Anon
init|=
literal|"Anonymous"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Fromnews
init|=
literal|"(From News system)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Continued
init|=
literal|"-- more  %d%% --"
decl_stmt|;
end_decl_stmt

begin_macro
name|dspnote
argument_list|(
argument|io
argument_list|,
argument|note
argument_list|,
argument|notenum
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
comment|/* character temp */
name|Rotate
decl_stmt|;
comment|/* whether rotated */
name|long
name|where
decl_stmt|;
comment|/* for seeking */
name|struct
name|dsply_f
name|dispbuf
decl_stmt|;
name|long
name|pagecnt
index|[
name|PAGESAV
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|pagesout
decl_stmt|;
name|Rotate
operator|=
literal|0
expr_stmt|;
comment|/* default non-rotated */
name|io
operator|->
name|nnotread
operator|++
expr_stmt|;
comment|/* bump count of notes read */
name|pagesout
operator|=
literal|0
expr_stmt|;
name|pagecnt
index|[
name|pagesout
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|==
literal|0
condition|)
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|=
literal|0
expr_stmt|;
comment|/* empty text */
else|else
block|{
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|note
operator|->
name|n_addr
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
name|note
operator|->
name|n_addr
operator|.
name|addr
argument_list|,
literal|"dsply: bad note seek"
argument_list|)
expr_stmt|;
name|dispbuf
operator|.
name|d_head
operator|=
name|note
operator|->
name|n_addr
expr_stmt|;
comment|/* get header info */
block|}
name|dispbuf
operator|.
name|outcount
operator|=
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
comment|/* fix buffer */
do|do
comment|/* always show the first page */
comment|/* display loop */
block|{
name|erase
argument_list|()
expr_stmt|;
comment|/* write header crap */
name|at
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|notenum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dispbuf
operator|.
name|outcount
condition|)
comment|/* nth page */
name|printf
argument_list|(
literal|"[Continued] "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Note %d"
argument_list|,
name|notenum
argument_list|)
expr_stmt|;
block|}
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_title
argument_list|,
name|NNLEN
argument_list|,
literal|1
argument_list|,
literal|40
operator|-
name|NNLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|n_nresp
operator|>
literal|0
condition|)
block|{
name|at
argument_list|(
literal|1
argument_list|,
literal|67
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d response"
argument_list|,
name|note
operator|->
name|n_nresp
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|n_nresp
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
block|}
name|at
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|note
operator|->
name|n_auth
operator|.
name|aname
argument_list|)
expr_stmt|;
name|center
argument_list|(
name|note
operator|->
name|ntitle
argument_list|,
name|TITLEN
argument_list|,
literal|2
argument_list|,
literal|40
operator|-
name|TITLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|prdate
argument_list|(
operator|&
name|note
operator|->
name|n_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|Authsystem
argument_list|,
name|note
operator|->
name|n_auth
operator|.
name|asystem
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|Anon
argument_list|,
name|note
operator|->
name|n_auth
operator|.
name|aname
argument_list|)
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(at %s)"
argument_list|,
name|note
operator|->
name|n_auth
operator|.
name|asystem
argument_list|)
expr_stmt|;
comment|/* print system name if not local */
block|}
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|DIRMES
condition|)
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_drmes
argument_list|,
name|DMLEN
argument_list|,
literal|3
argument_list|,
literal|40
operator|-
name|DMLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|ORPHND
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- (Foster Parent) --"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|WRITONLY
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- (Write Only) --"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|FRMNEWS
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Fromnews
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
comment|/* header is it for empties */
block|}
name|at
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* make sure soft-tabs work */
name|c
operator|=
name|showit
argument_list|(
name|io
argument_list|,
operator|&
name|dispbuf
argument_list|,
name|Rotate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
comment|/* wants the next page */
if|if
condition|(
name|pagesout
operator|<
name|PAGESAV
condition|)
name|pagecnt
index|[
operator|++
name|pagesout
index|]
operator|=
name|dispbuf
operator|.
name|outcount
expr_stmt|;
comment|/* save new start */
break|break;
case|case
literal|'-'
case|:
comment|/* go back to previous */
case|case
literal|'\b'
case|:
comment|/* backspace has same function */
if|if
condition|(
name|pagesout
operator|--
operator|==
literal|0
condition|)
return|return
name|c
return|;
comment|/* pass the buck */
goto|goto
name|replot
goto|;
comment|/* else fall into replot */
ifdef|#
directive|ifdef
name|ROTATE
case|case
literal|'R'
case|:
comment|/* rot-13 the text */
name|Rotate
operator|=
operator|!
name|Rotate
expr_stmt|;
comment|/* toggle */
comment|/* and fall into re-plot */
endif|#
directive|endif
endif|ROTATE
name|replot
label|:
comment|/* nasty goto label */
case|case
literal|'r'
case|:
case|case
literal|'\014'
case|:
comment|/* control-L too */
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
name|dispbuf
operator|.
name|outcount
operator|=
name|pagecnt
index|[
name|pagesout
index|]
expr_stmt|;
name|where
operator|=
name|dispbuf
operator|.
name|d_head
operator|.
name|addr
operator|+
name|dispbuf
operator|.
name|outcount
expr_stmt|;
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"dspnote: bad seek"
argument_list|)
expr_stmt|;
break|break;
comment|/* are all set now */
default|default:
comment|/* pass the buck */
return|return
name|c
return|;
block|}
block|}
do|while
condition|(
name|dispbuf
operator|.
name|outcount
operator|<
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
condition|)
do|;
return|return
name|c
return|;
comment|/* didn't field a command */
block|}
end_block

begin_comment
comment|/*  *	Code to print the header and manage the paging of a response  *	It calls the "showit" routine to print pages of text  */
end_comment

begin_macro
name|dspresp
argument_list|(
argument|io
argument_list|,
argument|note
argument_list|,
argument|resp
argument_list|,
argument|phys
argument_list|,
argument|logical
argument_list|,
argument|notenum
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|resp_f
modifier|*
name|resp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|int
name|Rotate
decl_stmt|;
comment|/* whether rotated */
name|struct
name|dsply_f
name|dispbuf
decl_stmt|;
name|long
name|where
decl_stmt|,
name|pagecnt
index|[
name|PAGESAV
operator|+
literal|1
index|]
decl_stmt|;
comment|/* stack for backing up */
name|int
name|pagesout
decl_stmt|;
name|Rotate
operator|=
literal|0
expr_stmt|;
comment|/* default non-rotated */
name|io
operator|->
name|nrspread
operator|++
expr_stmt|;
comment|/* bump count or responses read */
name|pagesout
operator|=
literal|0
expr_stmt|;
name|pagecnt
index|[
name|pagesout
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|r_addr
index|[
name|phys
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|=
literal|0
expr_stmt|;
comment|/* so can get a header */
else|else
block|{
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|resp
operator|->
name|r_addr
index|[
name|phys
index|]
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
name|resp
operator|->
name|r_addr
index|[
name|phys
index|]
operator|.
name|addr
argument_list|,
literal|"dspresp: bad resp seek"
argument_list|)
expr_stmt|;
name|dispbuf
operator|.
name|d_head
operator|=
name|resp
operator|->
name|r_addr
index|[
name|phys
index|]
expr_stmt|;
comment|/* get header info */
block|}
name|dispbuf
operator|.
name|outcount
operator|=
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
comment|/* fix buffer */
do|do
comment|/* always make 1 pass */
block|{
name|erase
argument_list|()
expr_stmt|;
comment|/* paint the header */
name|at
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispbuf
operator|.
name|outcount
condition|)
comment|/* nth page */
name|printf
argument_list|(
literal|"[Continued] "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Note %d"
argument_list|,
name|notenum
argument_list|)
expr_stmt|;
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_title
argument_list|,
name|NNLEN
argument_list|,
literal|1
argument_list|,
literal|40
operator|-
name|NNLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|resp
operator|->
name|r_auth
index|[
name|phys
index|]
operator|.
name|aname
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Response %2d of %2d"
argument_list|,
name|logical
argument_list|,
name|note
operator|->
name|n_nresp
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|prdate
argument_list|(
operator|&
name|resp
operator|->
name|r_when
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|Authsystem
argument_list|,
name|resp
operator|->
name|r_auth
index|[
name|phys
index|]
operator|.
name|asystem
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|Anon
argument_list|,
name|resp
operator|->
name|r_auth
index|[
name|phys
index|]
operator|.
name|aname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(at %s)"
argument_list|,
name|resp
operator|->
name|r_auth
index|[
name|phys
index|]
operator|.
name|asystem
argument_list|)
expr_stmt|;
comment|/* print sys name if not here */
block|}
if|if
condition|(
name|resp
operator|->
name|r_stat
index|[
name|phys
index|]
operator|&
name|DIRMES
condition|)
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_drmes
argument_list|,
name|DMLEN
argument_list|,
literal|3
argument_list|,
literal|40
operator|-
name|DMLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|r_stat
index|[
name|phys
index|]
operator|&
name|FRMNEWS
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Fromnews
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
comment|/* header is all for empties */
block|}
name|at
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* make sure soft-tabs work */
name|c
operator|=
name|showit
argument_list|(
name|io
argument_list|,
operator|&
name|dispbuf
argument_list|,
name|Rotate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
comment|/* wants the next page */
if|if
condition|(
name|pagesout
operator|<
name|PAGESAV
condition|)
name|pagecnt
index|[
operator|++
name|pagesout
index|]
operator|=
name|dispbuf
operator|.
name|outcount
expr_stmt|;
comment|/* save new start */
break|break;
case|case
literal|'-'
case|:
comment|/* go back to previous */
case|case
literal|'\b'
case|:
comment|/* backspace does the same thing */
if|if
condition|(
name|pagesout
operator|--
operator|==
literal|0
condition|)
return|return
name|c
return|;
comment|/* pass the buck */
goto|goto
name|replot
goto|;
comment|/* else fall into replot */
ifdef|#
directive|ifdef
name|ROTATE
case|case
literal|'R'
case|:
comment|/* rot-13 the text */
name|Rotate
operator|=
operator|!
name|Rotate
expr_stmt|;
comment|/* toggle */
comment|/* and fall into re-plot */
endif|#
directive|endif
endif|ROTATE
name|replot
label|:
comment|/* nasty goto label */
case|case
literal|'r'
case|:
case|case
literal|'\014'
case|:
comment|/* control-L too */
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
name|dispbuf
operator|.
name|outcount
operator|=
name|pagecnt
index|[
name|pagesout
index|]
expr_stmt|;
name|where
operator|=
name|dispbuf
operator|.
name|d_head
operator|.
name|addr
operator|+
name|dispbuf
operator|.
name|outcount
expr_stmt|;
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"dspnote: bad seek"
argument_list|)
expr_stmt|;
break|break;
comment|/* are all set now */
default|default:
comment|/* pass the buck */
return|return
name|c
return|;
block|}
block|}
do|while
condition|(
name|dispbuf
operator|.
name|outcount
operator|<
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
condition|)
do|;
return|return
name|c
return|;
comment|/* didn't field a command */
block|}
end_block

begin_comment
comment|/*  *	showit  *  *	accepts a pointer to a dsply_f and dumps text until runs out  *	or the screen is filled.  *	Counts things like lines, columns, and also prints a "more" line  *  *	Ray Essick	June 15, 1982  */
end_comment

begin_macro
name|showit
argument_list|(
argument|io
argument_list|,
argument|dbuf
argument_list|,
argument|Rotate
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dsply_f
modifier|*
name|dbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Rotate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lines
decl_stmt|,
name|wides
decl_stmt|;
comment|/* screen fill stuff */
name|int
name|c
decl_stmt|;
name|lines
operator|=
literal|4
expr_stmt|;
comment|/* header eats 4 */
name|wides
operator|=
literal|0
expr_stmt|;
comment|/* start in col 1 */
while|while
condition|(
name|lines
operator|<
name|nrows
operator|-
literal|1
operator|&&
name|dbuf
operator|->
name|outcount
operator|<
name|dbuf
operator|->
name|d_head
operator|.
name|textlen
condition|)
block|{
if|if
condition|(
name|intflag
condition|)
comment|/* user abort? */
block|{
name|intflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* back to key processing */
block|}
if|if
condition|(
name|dbuf
operator|->
name|optr
operator|==
name|dbuf
operator|->
name|olim
condition|)
comment|/* buffer is empty */
block|{
name|x
argument_list|(
operator|(
name|dbuf
operator|->
name|olim
operator|=
name|read
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"dspnote: text read"
argument_list|)
expr_stmt|;
name|dbuf
operator|->
name|optr
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ROTATE
if|if
condition|(
name|Rotate
condition|)
block|{
specifier|register
name|char
name|cc
decl_stmt|;
name|cc
operator|=
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
index|[
name|dbuf
operator|->
name|optr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|>=
literal|'a'
operator|&&
name|cc
operator|<=
literal|'m'
operator|)
operator|||
operator|(
name|cc
operator|>=
literal|'A'
operator|&&
name|cc
operator|<=
literal|'M'
operator|)
condition|)
name|cc
operator|+=
name|ROTATE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cc
operator|>=
literal|'n'
operator|&&
name|cc
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|cc
operator|>=
literal|'N'
operator|&&
name|cc
operator|<=
literal|'Z'
operator|)
condition|)
name|cc
operator|-=
name|ROTATE
expr_stmt|;
name|putc
argument_list|(
name|cc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|ROTATE
block|{
name|putc
argument_list|(
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
index|[
name|dbuf
operator|->
name|optr
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* show the character */
name|dbuf
operator|->
name|outcount
operator|++
expr_stmt|;
switch|switch
condition|(
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
index|[
name|dbuf
operator|->
name|optr
operator|++
index|]
condition|)
comment|/* some special chars */
block|{
case|case
literal|'\n'
case|:
comment|/* next line */
if|if
condition|(
name|isinput
argument_list|()
condition|)
comment|/* PLATO-brand erase-abort */
goto|goto
name|exisho
goto|;
name|wides
operator|=
literal|0
expr_stmt|;
name|lines
operator|++
expr_stmt|;
break|break;
case|case
literal|'\014'
case|:
comment|/* force next page */
name|lines
operator|=
name|nrows
expr_stmt|;
comment|/* forces loop exit */
break|break;
case|case
literal|'\t'
case|:
comment|/* almost forgot tabs */
name|wides
operator|+=
operator|(
literal|8
operator|-
operator|(
name|wides
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* tab stops */
break|break;
case|case
literal|'\b'
case|:
comment|/* perverts using backspaces */
name|wides
operator|--
expr_stmt|;
break|break;
default|default:
comment|/* dull characters */
name|wides
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wides
operator|>=
name|ncols
condition|)
comment|/* test line overflow */
block|{
name|lines
operator|++
expr_stmt|;
name|wides
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|exisho
label|:
comment|/* typeahead exit */
if|if
condition|(
name|dbuf
operator|->
name|outcount
operator|<
name|dbuf
operator|->
name|d_head
operator|.
name|textlen
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|Continued
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dbuf
operator|->
name|outcount
operator|*
literal|100L
operator|/
operator|(
name|long
operator|)
name|dbuf
operator|->
name|d_head
operator|.
name|textlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* grab command */
ifdef|#
directive|ifdef
name|PROMPT
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|PROMPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
comment|/* grab command */
name|printf
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
comment|/* so let caller handle it */
block|}
end_block

end_unit

