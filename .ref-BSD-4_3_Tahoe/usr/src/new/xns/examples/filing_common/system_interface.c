begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: system_interface.c,v 1.6 87/05/14 11:35:19 ed Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * Copyright (c) 1986, 1987 Xerox Corporation.  */
end_comment

begin_comment
comment|/* $Log:	system_interface.c,v $  * Revision 1.6  87/05/14  11:35:19  ed  * Enhanced fileID to be 32 bit inode (previous oversight).  * Also get_name_from_fileID now uses -a on ls to look at all files.  *   * Revision 1.5  87/04/16  15:26:17  ed  * Fixed bug if count was Filing4_unlimitedCount. (from jqj)  * Resolved lingering Subset pathname bugs.  *   * Revision 1.4  87/04/01  10:10:42  ed  * Added recognition of 'file drawers' (directories in root)   * 	in make_attribute_sequence.  *   * Revision 1.3  87/03/31  14:17:54  ed  * Fixed bug in access_file (per JQ Johnson) passed dir_handle,  * 	expected pathname, check for -1 failure, not success.  *   * Revision 1.2  87/03/31  09:46:46  ed  * New procedures: Create, ChangeAttributes(name only), Copy, Move,  * 		Replace, Serialize, Deserialize.  * Added conditional disabling of root logins.  * Support for GetAttributes (allAttributeTypes).  * Support for filter of type all.  *   * Revision 1.1  87/01/14  11:26:12  ed  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/sp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FILING4
end_ifdef

begin_include
include|#
directive|include
file|"filingV4.h"
end_include

begin_include
include|#
directive|include
file|"authenticationV2.h"
end_include

begin_endif
endif|#
directive|endif
endif|FILING4
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FILING5
end_ifdef

begin_include
include|#
directive|include
file|"filingV5.h"
end_include

begin_include
include|#
directive|include
file|"authenticationV2.h"
end_include

begin_endif
endif|#
directive|endif
endif|FILING5
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FILING6
end_ifdef

begin_include
include|#
directive|include
file|"filingV6.h"
end_include

begin_include
include|#
directive|include
file|"authenticationV3.h"
end_include

begin_endif
endif|#
directive|endif
endif|FILING5
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FILINGSUBSET1
end_ifdef

begin_include
include|#
directive|include
file|"filingsubsetV1.h"
end_include

begin_include
include|#
directive|include
file|"authenticationV3.h"
end_include

begin_endif
endif|#
directive|endif
endif|FILINGSUBSET1
end_endif

begin_include
include|#
directive|include
file|<xnscourier/filing_server.h>
end_include

begin_include
include|#
directive|include
file|<xnscourier/filetypes.h>
end_include

begin_define
define|#
directive|define
name|XNS_TIME_DIFFERENCE
value|2177452800
end_define

begin_comment
comment|/* [(1970-1901) years * 365 days/year + 17 leap days */
end_comment

begin_comment
comment|/* * 24 hours/day * 60 min/hour * 60 sec/min */
end_comment

begin_define
define|#
directive|define
name|SERVICE_ROOT
value|"/"
end_define

begin_comment
comment|/* root directory for service */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|FILE
modifier|*
name|msgs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cardinal
name|continuance
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* continuance value, in seconds */
end_comment

begin_extern
extern|extern continuance_expiration(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* expiration routine */
end_comment

begin_comment
comment|/*  * routine:  *	verifyandposition_user  * input:  *	user_name	- derived from secondary credentials  *	user_password	- derived form secondary credentials  * returns:  *	-1	- success  *	else	Filing Error, Problem  */
end_comment

begin_macro
name|verifyandposition_user
argument_list|(
argument|user_name
argument_list|,
argument|user_password
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|user_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|user_password
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|pwd_entry
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"user= '%s'\n"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* determine if user is valid */
if|if
condition|(
operator|(
name|pwd_entry
operator|=
name|getpwnam
argument_list|(
name|user_name
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|passwd
operator|*
operator|)
literal|0
condition|)
block|{
name|char
modifier|*
name|lowercase
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"name= '%s'\n"
argument_list|,
name|lowercase
argument_list|(
name|user_name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|(
name|pwd_entry
operator|=
name|getpwnam
argument_list|(
name|lowercase
argument_list|(
name|user_name
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|passwd
operator|*
operator|)
literal|0
condition|)
block|{
if|#
directive|if
name|FILING4
operator||
name|FILING5
name|ReturnAuthenticationError
argument_list|(
name|AUTHENTICATION_credentialsInvalid
argument_list|)
expr_stmt|;
else|#
directive|else
else|FILING4 | FILING5
name|ReturnAuthenticationError
argument_list|(
name|FILING_secondaryCredentialsValueInvalid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FILING4 | FILING5
comment|/* NOT REACHED */
block|}
block|}
if|#
directive|if
operator|!
operator|(
name|FILING4
operator||
name|FILING5
operator|)
if|if
condition|(
name|strcmp
argument_list|(
name|pwd_entry
operator|->
name|pw_passwd
argument_list|,
name|crypt
argument_list|(
name|user_password
argument_list|,
name|pwd_entry
operator|->
name|pw_passwd
argument_list|)
argument_list|)
condition|)
block|{
name|ReturnAuthenticationError
argument_list|(
name|FILING_secondaryCredentialsValueInvalid
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
endif|#
directive|endif
endif|!(FILING4 | FILING5)
comment|/* set process group ID */
if|if
condition|(
name|setgid
argument_list|(
name|pwd_entry
operator|->
name|pw_gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|FILING4
operator||
name|FILING5
name|ReturnAuthenticationError
argument_list|(
name|AUTHENTICATION_credentialsInvalid
argument_list|)
expr_stmt|;
else|#
directive|else
else|FILING4 | FILING5
name|ReturnAuthenticationError
argument_list|(
name|FILING_secondaryCredentialsValueInvalid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FILING4 | FILING5
comment|/* NOT REACHED */
block|}
comment|/* set process user ID */
if|if
condition|(
name|setuid
argument_list|(
name|pwd_entry
operator|->
name|pw_uid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|FILING4
operator||
name|FILING5
name|ReturnAuthenticationError
argument_list|(
name|AUTHENTICATION_credentialsInvalid
argument_list|)
expr_stmt|;
else|#
directive|else
else|FILING4 | FILING5
name|ReturnAuthenticationError
argument_list|(
name|FILING_secondaryCredentialsValueInvalid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FILING4 | FILING5
comment|/* NOT REACHED */
block|}
comment|/* position in service root */
if|if
condition|(
name|chdir
argument_list|(
name|SERVICE_ROOT
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ReturnServiceError
argument_list|(
name|FILING_serviceUnavailable
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	set_continuance_timer  */
end_comment

begin_macro
name|set_continuance_timer
argument_list|()
end_macro

begin_block
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cancel any previous alarm */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|continuance_expiration
argument_list|)
expr_stmt|;
comment|/* set routine to catch alarm */
name|alarm
argument_list|(
name|continuance
argument_list|)
expr_stmt|;
comment|/* set alarm */
block|}
end_block

begin_comment
comment|/*  * routine:  *	reset_continuance_timer  */
end_comment

begin_macro
name|reset_continuance_timer
argument_list|()
end_macro

begin_block
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cancel previous alarm */
name|alarm
argument_list|(
name|continuance
argument_list|)
expr_stmt|;
comment|/* then, reset alarm */
block|}
end_block

begin_comment
comment|/*  * routine:  *	cancel_continuance_timer  */
end_comment

begin_macro
name|cancel_continuance_timer
argument_list|()
end_macro

begin_block
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cancel any previous alarm */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* set routine to ignore alarm */
block|}
end_block

begin_comment
comment|/*  * routine:  *	open_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  *	else FILING_ error, problem  */
end_comment

begin_macro
name|open_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"open_file\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|(
name|file_context_block
operator|->
name|file_desc
operator|=
name|fopen
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
comment|/* user has no access */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|ENOENT
case|:
comment|/* no such file */
case|case
name|ENOTDIR
case|:
comment|/* no such directory */
name|ReturnHandleError
argument_list|(
name|FILING_fileNotFound
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
default|default :
comment|/* all other errors */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsIndeterminate
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	close_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  */
end_comment

begin_macro
name|close_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"closing...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|file_context_block
operator|->
name|file_desc
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|file_context_block
operator|->
name|file_desc
argument_list|)
expr_stmt|;
name|file_context_block
operator|->
name|file_desc
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	stat_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  *	else Filing Error, Problem  *  *	file_context_block entries filled in  */
end_comment

begin_macro
name|stat_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|file_stat
decl_stmt|;
name|LongCardinal
name|get_type
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"stating '%s'\n"
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|stat
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
comment|/* user has no access */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|ENOTDIR
case|:
comment|/* directory doesn't exist */
case|case
name|ENOENT
case|:
comment|/* file doesn't exist */
name|ReturnAccessError
argument_list|(
name|FILING_fileNotFound
argument_list|)
expr_stmt|;
default|default :
comment|/* all other errors */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsIndeterminate
argument_list|)
expr_stmt|;
block|}
block|}
name|file_context_block
operator|->
name|datasize
operator|=
name|file_stat
operator|.
name|st_size
expr_stmt|;
comment|/* dataSize */
comment|/* file type */
if|if
condition|(
operator|(
name|file_stat
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* directory */
name|file_context_block
operator|->
name|isdirectory
operator|=
name|TRUE
expr_stmt|;
name|file_context_block
operator|->
name|truetype
operator|=
name|FILING_tDirectory
expr_stmt|;
block|}
else|else
block|{
name|file_context_block
operator|->
name|isdirectory
operator|=
name|FALSE
expr_stmt|;
comment|/* non-directory */
name|file_context_block
operator|->
name|truetype
operator|=
name|get_type
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	create_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  *	else FILING_  Error, Problem  *  *	file_context_block->file_desc filled in  */
end_comment

begin_macro
name|create_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|access
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ReturnInsertionError
argument_list|(
name|FILING_fileNotUnique
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|(
name|file_context_block
operator|->
name|file_desc
operator|=
name|fopen
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
comment|/* user has no access */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|EEXIST
case|:
comment|/* file exists */
name|ReturnInsertionError
argument_list|(
name|FILING_fileNotUnique
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|ENOENT
case|:
comment|/* no such file, OK */
break|break;
case|case
name|ENOTDIR
case|:
comment|/* no such directory */
name|ReturnAccessError
argument_list|(
name|FILING_fileNotFound
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|EMFILE
case|:
comment|/* process file table full */
case|case
name|ENFILE
case|:
comment|/* system file table full */
name|ReturnSpaceError
argument_list|(
name|FILING_allocationExceeded
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
default|default :
comment|/* all other errors */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsIndeterminate
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	create_directory  * input:  *	pointer to file handle  * returns:  *	-1 - success  *	else FILING_  Error, Problem  *  */
end_comment

begin_macro
name|create_directory
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"createdir '%s'\n"
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* execute command */
name|execl
argument_list|(
literal|"/bin/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* error reports accessRightsInsufficient */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	rename_file  * input:  *	pointer to old name  *	pointer to file handle (containing new name)  * returns:  *	-1 - success  *	else Filing Error, Problem  *  */
end_comment

begin_macro
name|rename_file
argument_list|(
argument|oldname
argument_list|,
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oldname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|access
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ReturnInsertionError
argument_list|(
name|FILING_fileNotUnique
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"renaming '%s' to '%s'\n"
argument_list|,
name|oldname
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|rename
argument_list|(
name|oldname
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
comment|/* user has no access */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|ENOTDIR
case|:
comment|/* directory doesn't exist */
case|case
name|ENOENT
case|:
comment|/* file doesn't exist */
case|case
name|EXDEV
case|:
comment|/* no cross file system move */
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|EINVAL
case|:
comment|/* old is parent of new */
name|ReturnInsertionError
argument_list|(
name|FILING_loopInHierarchy
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
default|default :
comment|/* all other errors */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsIndeterminate
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	copy_file  * input:  *	pointer to old file handle  *	pointer to new file handle  * returns:  *	-1 - success  *	else Filing Error, Problem  *  */
end_comment

begin_macro
name|copy_file
argument_list|(
argument|old_file_context_block
argument_list|,
argument|new_file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|old_file_context_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_handle
modifier|*
name|new_file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|old_file_context_block
operator|->
name|pathname
argument_list|,
name|new_file_context_block
operator|->
name|pathname
argument_list|,
name|strlen
argument_list|(
name|old_file_context_block
operator|->
name|pathname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ReturnInsertionError
argument_list|(
name|FILING_loopInHierarchy
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
name|access
argument_list|(
name|new_file_context_block
operator|->
name|pathname
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ReturnInsertionError
argument_list|(
name|FILING_fileNotUnique
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"copying '%s' to '%s'\n"
argument_list|,
name|old_file_context_block
operator|->
name|pathname
argument_list|,
name|new_file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|copy
argument_list|(
name|old_file_context_block
operator|->
name|pathname
argument_list|,
name|new_file_context_block
operator|->
name|pathname
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* child */
name|execl
argument_list|(
literal|"/bin/cp"
argument_list|,
literal|"cp"
argument_list|,
literal|"-r"
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|ReturnUndefinedError
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
while|while
condition|(
name|wait
argument_list|(
operator|&
name|s
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
comment|/* 	 * would be nice if cp returned useful errors, but ... 	 */
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|list_directory
argument_list|(
argument|conn
argument_list|,
argument|directory
argument_list|,
argument|attr
argument_list|,
argument|file_spec
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_handle
modifier|*
name|directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILING_AttributeTypeSequence
name|attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file_spec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cardinal
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILING_StreamOfAttributeSequence
name|stream_of_attrseq
decl_stmt|;
name|FILING_AttributeSequence
name|attribute_sequence
decl_stmt|;
name|FILE
modifier|*
name|pipe_desc
decl_stmt|;
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
name|Boolean
name|first
init|=
name|TRUE
decl_stmt|;
name|char
name|command
index|[
literal|256
index|]
decl_stmt|;
name|char
name|filename
index|[
name|MAX_FILE_NAME_LENGTH
index|]
decl_stmt|;
name|stream_of_attrseq
operator|.
name|nextSegment_case
operator|.
name|segment
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|stream_of_attrseq
operator|.
name|nextSegment_case
operator|.
name|segment
operator|.
name|sequence
operator|=
operator|&
name|attribute_sequence
expr_stmt|;
name|strcpy
argument_list|(
name|command
argument_list|,
literal|"/bin/ls -1d "
argument_list|)
expr_stmt|;
comment|/* form appropriate command */
name|strcat
argument_list|(
name|command
argument_list|,
name|directory
operator|->
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|directory
operator|->
name|pathname
argument_list|,
literal|"/"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|command
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|command
argument_list|,
name|file_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_types
argument_list|(
name|attr
argument_list|,
operator|&
name|attribute_sequence
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* NOT REACHED */
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"listing '%s'\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|(
name|pipe_desc
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* issue command */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
while|while
condition|(
name|fgets
argument_list|(
name|filename
argument_list|,
name|MAX_FILE_NAME_LENGTH
argument_list|,
name|pipe_desc
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
name|filename
index|[
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"got '%s'     "
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"count= %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|(
name|count
operator|!=
name|FILING_unlimitedCount
operator|)
operator|&&
operator|(
operator|--
name|count
operator|<
literal|0
operator|)
condition|)
block|{
break|break;
block|}
name|make_attribute_sequence
argument_list|(
name|filename
argument_list|,
operator|&
name|attribute_sequence
argument_list|)
expr_stmt|;
name|put_next_attribute_sequence
argument_list|(
name|conn
argument_list|,
operator|&
name|stream_of_attrseq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|==
name|TRUE
condition|)
block|{
name|pclose
argument_list|(
name|pipe_desc
argument_list|)
expr_stmt|;
comment|/*		ReturnAccessError(FILING_fileNotFound);		??? */
comment|/* NOT REACHED */
block|}
name|put_last_attribute_sequence
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|BDTclosewrite
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pipe_desc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	delete_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  * 	else Filing Error, Problem  */
end_comment

begin_macro
name|delete_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|" deleting '%s'"
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|file_context_block
operator|->
name|isdirectory
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* use rm -rf for directories */
name|execl
argument_list|(
literal|"/bin/rm"
argument_list|,
literal|"rm"
argument_list|,
literal|"-rf"
argument_list|,
name|file_context_block
operator|->
name|pathname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
else|else
block|{
comment|/* use unlink for non-directories */
if|if
condition|(
name|unlink
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
comment|/* user has no access */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|ENOENT
case|:
comment|/* no such file */
case|case
name|ENOTDIR
case|:
comment|/* no such directory */
name|ReturnAccessError
argument_list|(
name|FILING_fileNotFound
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
default|default :
comment|/* all other errors */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsIndeterminate
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * routine:  *	delete_partial_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  */
end_comment

begin_macro
name|delete_partial_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unlink
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	access_file  * input:  *	pointer to file handle  * returns:  *	-1 - success  */
end_comment

begin_macro
name|access_file
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"access_file\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|access
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
name|R_OK
operator||
name|F_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
comment|/* user has no access */
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|ENOENT
case|:
comment|/* no such file */
case|case
name|ENOTDIR
case|:
comment|/* no such directory */
name|ReturnHandleError
argument_list|(
name|FILING_invalid
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
default|default :
comment|/* all other errors */
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsIndeterminate
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	set_create_time  * input:  *	pointer to file context block  *		where  *		if no createdOn value was specified on Store, createdon = 0  *		if createdOn value was specified on Store, createdOn != 0,  *			value is in XNS time format  * returns:  *	none  */
end_comment

begin_macro
name|set_create_time
argument_list|(
argument|file_context_block
argument_list|)
end_macro

begin_decl_stmt
name|file_handle
modifier|*
name|file_context_block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|time_t
name|time_buffer
index|[
literal|2
index|]
decl_stmt|;
name|time_t
name|time
parameter_list|()
function_decl|;
if|if
condition|(
name|file_context_block
operator|->
name|createdon
condition|)
comment|/* save createdOn if specified */
name|time_buffer
index|[
literal|1
index|]
operator|=
name|file_context_block
operator|->
name|createdon
operator|-
name|XNS_TIME_DIFFERENCE
expr_stmt|;
else|else
comment|/* else, set to current date/time */
name|time_buffer
index|[
literal|1
index|]
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|time_buffer
index|[
literal|0
index|]
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set modifiedOn to current date/time */
name|utime
argument_list|(
name|file_context_block
operator|->
name|pathname
argument_list|,
name|time_buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * routine:  *	make_attribute_sequence  * inputs:  *	pointer to file name  *	pointer to sequence of attributes to fill in  * returns:  *	-1 - success  */
end_comment

begin_macro
name|make_attribute_sequence
argument_list|(
argument|pathname
argument_list|,
argument|attrseq
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pathname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILING_AttributeSequence
modifier|*
name|attrseq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|file_stat
decl_stmt|;
name|FILING_AttributeType
name|t
decl_stmt|;
name|LongCardinal
name|createdon
decl_stmt|,
name|modifiedon
decl_stmt|;
name|LongCardinal
name|type
decl_stmt|,
name|get_type
argument_list|()
decl_stmt|;
name|LongCardinal
name|datasize
decl_stmt|;
name|Boolean
name|isdirectory
decl_stmt|;
name|Boolean
name|all_attributes
init|=
name|FALSE
decl_stmt|;
name|Cardinal
name|unix_version
init|=
literal|1
decl_stmt|;
name|Boolean
name|istemporary
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|FILETOOLCOMPATIBILITY
name|Cardinal
name|fileid
index|[
literal|6
index|]
decl_stmt|;
name|AUTHENTICATION_Clearinghouse_Name
name|user
decl_stmt|;
name|AUTHENTICATION_Clearinghouse_Name
name|CH_StringToName
parameter_list|()
function_decl|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|pwname
decl_stmt|;
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|getpwuid
argument_list|()
decl_stmt|,
modifier|*
name|pwd
decl_stmt|;
endif|#
directive|endif
endif|FILETOOLCOMPATIBILITY
ifdef|#
directive|ifdef
name|EXTENSIONS
name|Boolean
name|inroot
init|=
name|FALSE
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
endif|#
directive|endif
endif|EXTENSIONS
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"make_attrseq '%s'\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
ifndef|#
directive|ifndef
name|FILINGSUBSET1
if|if
condition|(
operator|(
name|name
operator|=
name|rindex
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|name
operator|=
name|pathname
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|EXTENSIONS
if|if
condition|(
name|name
operator|==
name|pathname
condition|)
name|inroot
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
endif|EXTENSIONS
name|name
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
endif|FILINGSUBSET1
if|if
condition|(
name|stat
argument_list|(
name|pathname
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|createdon
operator|=
name|file_stat
operator|.
name|st_mtime
operator|+
name|XNS_TIME_DIFFERENCE
expr_stmt|;
comment|/* createdOn */
name|modifiedon
operator|=
name|file_stat
operator|.
name|st_atime
operator|+
name|XNS_TIME_DIFFERENCE
expr_stmt|;
comment|/* modifiedOn */
name|datasize
operator|=
name|file_stat
operator|.
name|st_size
expr_stmt|;
comment|/* dataSize */
comment|/* type and isDirectory */
if|if
condition|(
operator|(
name|file_stat
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|!=
literal|0
condition|)
block|{
name|isdirectory
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTENSIONS
if|if
condition|(
name|inroot
condition|)
comment|/* if root& directory, assume file drawer */
name|type
operator|=
name|TYPE_VPDrawer
expr_stmt|;
else|else
name|type
operator|=
name|FILING_tDirectory
expr_stmt|;
else|#
directive|else
else|EXTENSIONS
name|type
operator|=
name|FILING_tDirectory
expr_stmt|;
endif|#
directive|endif
endif|EXTENSIONS
block|}
else|else
block|{
name|type
operator|=
name|get_type
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTENSIONS
if|if
condition|(
operator|(
name|type
operator|>
name|LAST_FILING_TYPE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TYPE_Interpress
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TYPE_VPCanvas
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|isdirectory
operator|=
name|GetDirectoryAttribute
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isdirectory
operator|=
name|FALSE
expr_stmt|;
block|}
else|#
directive|else
else|EXTENSIONS
name|isdirectory
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
endif|EXTENSIONS
block|}
ifdef|#
directive|ifdef
name|EXTENSIONS
if|if
condition|(
name|attrseq
operator|->
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|all_attributes
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|>
name|LAST_FILING_TYPE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TYPE_Interpress
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TYPE_VPCanvas
operator|)
condition|)
name|make_required_attributes
argument_list|(
name|attrseq
argument_list|)
expr_stmt|;
else|else
name|make_supported_attributes
argument_list|(
name|attrseq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|EXTENSIONS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attrseq
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"#%d  type= %d \n"
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|t
operator|==
name|FILING_pathname
condition|)
block|{
name|StringToAttr
argument_list|(
name|pathname
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_type
condition|)
block|{
name|LongCardinalToAttr
argument_list|(
name|type
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_dataSize
condition|)
block|{
name|LongCardinalToAttr
argument_list|(
name|datasize
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_isDirectory
condition|)
block|{
name|BooleanToAttr
argument_list|(
name|isdirectory
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_createdOn
condition|)
block|{
name|LongCardinalToAttr
argument_list|(
name|createdon
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_modifiedOn
condition|)
block|{
name|LongCardinalToAttr
argument_list|(
name|modifiedon
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_version
condition|)
block|{
name|CardinalToAttr
argument_list|(
name|unix_version
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_isTemporary
condition|)
block|{
name|BooleanToAttr
argument_list|(
name|istemporary
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILETOOLCOMPATIBILITY
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_name
condition|)
block|{
name|StringToAttr
argument_list|(
name|name
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_fileID
condition|)
block|{
name|fileid
index|[
literal|0
index|]
operator|=
operator|(
name|file_stat
operator|.
name|st_ino
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|fileid
index|[
literal|1
index|]
operator|=
name|file_stat
operator|.
name|st_ino
operator|&
literal|0xffff
expr_stmt|;
name|fileid
index|[
literal|2
index|]
operator|=
name|fileid
index|[
literal|3
index|]
operator|=
name|fileid
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|FileIDToAttr
argument_list|(
name|fileid
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_readOn
condition|)
block|{
name|LongCardinalToAttr
argument_list|(
name|modifiedon
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FILING_createdBy
condition|)
block|{
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|file_stat
operator|.
name|st_uid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pwname
operator|=
literal|"Unkown"
expr_stmt|;
else|else
name|pwname
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
name|user
operator|=
name|CH_StringToName
argument_list|(
name|pwname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UserToAttr
argument_list|(
name|user
argument_list|,
operator|&
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FILETOOLCOMPATIBILITY
block|}
else|else
block|{
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
operator|.
name|value
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|attrseq
operator|->
name|sequence
index|[
name|i
index|]
operator|.
name|value
operator|.
name|sequence
operator|=
operator|(
name|Unspecified
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|EXTENSIONS
if|if
condition|(
name|all_attributes
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|>
name|LAST_FILING_TYPE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TYPE_Interpress
operator|)
operator|&&
operator|(
name|type
operator|!=
name|TYPE_VPCanvas
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
name|AddAllExtendedAttributes
argument_list|(
name|fd
argument_list|,
name|attrseq
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ReturnAccessError
argument_list|(
name|FILING_fileChanged
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|EXTENSIONS
block|}
end_block

begin_function
name|int
name|getBDTch
parameter_list|(
name|conn
parameter_list|,
name|bpp
parameter_list|)
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|bpp
decl_stmt|;
block|{
specifier|static
name|u_char
name|buffer
index|[
name|SPPMAXDATA
index|]
decl_stmt|;
specifier|static
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|*
name|bpp
operator|==
name|NULL
condition|)
block|{
operator|*
name|bpp
operator|=
name|buffer
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bpp
operator|>=
name|buffer
operator|+
name|count
condition|)
block|{
name|count
operator|=
name|BDTread
argument_list|(
name|conn
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
return|return
operator|(
operator|*
operator|(
operator|(
operator|*
name|bpp
operator|)
operator|++
operator|)
operator|)
return|;
block|}
end_function

begin_macro
name|storeproc
argument_list|(
argument|conn
argument_list|,
argument|handle
argument_list|)
end_macro

begin_decl_stmt
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|file_handle
modifier|*
name|handle
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|,
name|ocount
decl_stmt|,
name|ch
decl_stmt|,
name|hashbytes
decl_stmt|;
name|char
name|buffer
index|[
name|SPPMAXDATA
index|]
decl_stmt|;
name|int
name|charset
decl_stmt|,
name|charset16
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|fout
operator|=
name|handle
operator|->
name|file_desc
expr_stmt|;
name|fd
operator|=
name|fileno
argument_list|(
name|fout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILETOOLCOMPATIBILITY
if|if
condition|(
name|handle
operator|->
name|type
operator|==
name|FILING_tText
condition|)
block|{
name|charset
operator|=
literal|0
expr_stmt|;
name|charset16
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getBDTch
argument_list|(
name|conn
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\377'
condition|)
block|{
name|ch
operator|=
name|getBDTch
argument_list|(
name|conn
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\377'
condition|)
name|charset16
operator|=
literal|1
expr_stmt|;
else|else
name|charset
operator|=
name|ch
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|charset16
condition|)
block|{
name|charset
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|getBDTch
argument_list|(
name|conn
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|charset
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal character set -- minimal xlation */
if|if
condition|(
name|ch
operator|==
literal|'\r'
condition|)
block|{
name|int
name|nextch
decl_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextch
operator|=
name|getBDTch
argument_list|(
name|conn
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|nextch
operator|==
literal|'\r'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nextch
operator|==
literal|','
operator|+
literal|0200
condition|)
name|putc
argument_list|(
literal|'_'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nextch
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|nextch
argument_list|,
name|fout
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
operator|+
literal|0200
condition|)
name|ch
operator|=
literal|'_'
expr_stmt|;
comment|/* more mapping here */
name|putc
argument_list|(
name|ch
argument_list|,
name|fout
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* ignore */
block|}
block|}
comment|/* if (count< 0) perror("netin"); */
block|}
else|else
block|{
else|#
directive|else
else|FILETOOLCOMPATIBILITY
block|{
endif|#
directive|endif
endif|FILETOOLCOMPATIBILITY
name|errno
operator|=
name|ocount
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|BDTread
argument_list|(
name|conn
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ocount
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|BDTabort
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"netin"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|retrieveproc
argument_list|(
argument|conn
argument_list|,
argument|handle
argument_list|)
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
name|file_handle
modifier|*
name|handle
decl_stmt|;
block|{
name|int
name|count
decl_stmt|,
name|ocount
decl_stmt|;
name|u_char
name|buffer
index|[
name|SPPMAXDATA
index|]
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|errno
operator|=
name|ocount
operator|=
literal|0
expr_stmt|;
name|clearerr
argument_list|(
name|handle
operator|->
name|file_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|type
operator|==
operator|-
literal|1
condition|)
name|handle
operator|->
name|type
operator|=
name|handle
operator|->
name|truetype
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"transferring data type= %d\n"
argument_list|,
name|handle
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
ifdef|#
directive|ifdef
name|FILETOOLCOMPATIBILITY
if|if
condition|(
name|handle
operator|->
name|type
operator|==
name|FILING_tText
condition|)
block|{
while|while
condition|(
operator|(
name|count
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|SPPMAXDATA
argument_list|,
name|handle
operator|->
name|file_desc
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|ocount
operator|=
name|count
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|*
name|bp
operator|=
literal|'\r'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'_'
condition|)
operator|*
name|bp
operator|=
literal|','
operator|+
literal|0200
expr_stmt|;
comment|/* more translations here */
block|}
if|if
condition|(
operator|(
name|ocount
operator|=
name|BDTwrite
argument_list|(
name|conn
argument_list|,
name|buffer
argument_list|,
name|ocount
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
else|else
block|{
else|#
directive|else
else|FILETOOLCOMPATIBILITY
block|{
endif|#
directive|endif
endif|FILETOOLCOMPATIBILITY
while|while
condition|(
operator|(
name|count
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|SPPMAXDATA
argument_list|,
name|handle
operator|->
name|file_desc
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|ocount
operator|=
name|BDTwrite
argument_list|(
name|conn
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{ 		}
block|}
if|if
condition|(
name|ocount
operator|<
literal|0
condition|)
block|{
name|BDTabort
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"netout"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|handle
operator|->
name|file_desc
argument_list|)
condition|)
block|{
name|BDTabort
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|BDTclosewrite
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|FILETOOLCOMPATIBILITY
name|get_name_from_fileID
argument_list|(
argument|handle
argument_list|,
argument|fileid
argument_list|)
name|file_handle
modifier|*
name|handle
decl_stmt|;
name|Unspecified
modifier|*
name|fileid
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|256
index|]
decl_stmt|;
name|char
name|pathname
index|[
literal|256
index|]
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|int
name|inode
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|Boolean
name|first
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|handle
operator|->
name|pathname
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|ReturnAttributeTypeError
argument_list|(
name|FILING_unreasonable
argument_list|,
name|FILING_fileID
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"looking for fileid %x %x\n"
argument_list|,
name|fileid
index|[
literal|0
index|]
argument_list|,
name|fileid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|strcpy
argument_list|(
name|cmd
argument_list|,
literal|"/bin/ls -1ai "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|handle
operator|->
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ReturnAccessError
argument_list|(
name|FILING_accessRightsInsufficient
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|buffer
index|[
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|inode
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|msgs
argument_list|,
literal|"inode= %d '%s'\n"
argument_list|,
name|inode
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|(
name|fileid
index|[
literal|0
index|]
operator|==
operator|(
operator|(
name|inode
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|)
operator|&&
operator|(
name|fileid
index|[
literal|1
index|]
operator|==
operator|(
name|inode
operator|&
literal|0xffff
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|handle
operator|->
name|pathname
argument_list|,
literal|"/"
argument_list|)
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|handle
operator|->
name|pathname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|handle
operator|->
name|pathname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|pclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ReturnAccessError
argument_list|(
name|FILING_fileNotFound
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
endif|#
directive|endif
endif|FILETOOLCOMPATIBILITY
name|check_pathname
argument_list|(
argument|pathname
argument_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|pathname
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
name|iscntrl
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
name|ReturnAttributeValueError
argument_list|(
name|FILING_illegal
argument_list|,
name|FILING_pathname
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|EXTENSIONS
comment|/*  * make_backup  *  */
name|make_backup
argument_list|(
argument|handle
argument_list|)
name|file_handle
modifier|*
name|handle
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|backup_name
index|[
name|MAX_FILE_NAME_LENGTH
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|fout
decl_stmt|,
name|count
decl_stmt|;
name|strcpy
argument_list|(
name|backup_name
argument_list|,
name|handle
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|backup_name
argument_list|,
literal|".REP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|handle
operator|->
name|pathname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|(
name|fout
operator|=
name|open
argument_list|(
name|backup_name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NOT REACHED */
block|}
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|fin
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fout
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|backup_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NOT REACHED */
block|}
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * recall_backup  *  */
name|recall_backup
argument_list|(
argument|handle
argument_list|)
name|file_handle
modifier|*
name|handle
decl_stmt|;
block|{
name|char
name|backup_name
index|[
name|MAX_FILE_NAME_LENGTH
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|backup_name
argument_list|,
name|handle
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|backup_name
argument_list|,
literal|".REP"
argument_list|)
expr_stmt|;
comment|/* 	 * we better not see an error here, since we have already 	 * munged the original file 	 */
if|if
condition|(
name|rename
argument_list|(
name|backup_name
argument_list|,
name|handle
operator|->
name|pathname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|unlink_backup
argument_list|(
argument|handle
argument_list|)
name|file_handle
modifier|*
name|handle
decl_stmt|;
block|{
name|char
name|backup_name
index|[
name|MAX_FILE_NAME_LENGTH
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|backup_name
argument_list|,
name|handle
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|backup_name
argument_list|,
literal|".REP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|backup_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|EXTENSIONS
end_endif

end_unit

