begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: constantcode.c,v 2.0 85/11/21 07:21:32 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	constantcode.c,v $  * Revision 2.0  85/11/21  07:21:32  jqj  * 4.3BSD standard release  *   * Revision 1.4  85/05/23  06:19:32  jqj  * *** empty log message ***  *   * Revision 1.4  85/05/23  06:19:32  jqj  * Public Beta-test version, released 24 May 1985  *   * Revision 1.3  85/03/26  06:09:41  jqj  * Revised public alpha-test version, released 26 March 1985  *   * Revision 1.2  85/03/11  16:38:56  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.1  85/02/15  13:55:18  jqj  * Initial revision  *   */
end_comment

begin_comment
comment|/*  * Generate code for constant declarations.  */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_comment
comment|/*  * Generate code for constant declarations  */
end_comment

begin_macro
name|define_constant
argument_list|(
argument|name
argument_list|,
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
name|name
operator|->
name|o_class
operator|=
name|O_CONSTANT
expr_stmt|;
name|name
operator|->
name|o_constant
operator|=
name|value
expr_stmt|;
name|fullname
operator|=
name|make_full_name
argument_list|(
name|name
operator|->
name|o_module
argument_list|,
name|name
operator|->
name|o_modversion
argument_list|,
name|name_of
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for simple case of Foo: TypeBaz = Mumble; 	 * where Mumble is another constant.  In this case, 	 * just use the existing declaration 	 */
if|if
condition|(
name|value
operator|->
name|cn_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|recursive_flag
condition|)
block|{
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"#define %s %s\n"
argument_list|,
name|fullname
argument_list|,
name|value
operator|->
name|cn_name
argument_list|)
expr_stmt|;
comment|/* open scope */
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"#define %s %s\n"
argument_list|,
name|name_of
argument_list|(
name|name
argument_list|)
argument_list|,
name|value
operator|->
name|cn_name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * We have to generate some code for this one.  We'll generate 	 * the declaration in the header file of a static variable 	 * initialized to the appropriate values. 	 */
name|value
operator|->
name|cn_name
operator|=
name|fullname
expr_stmt|;
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* it's already been expanded elsewhere */
comment|/* open scope */
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"#define %s %s\n"
argument_list|,
name|name_of
argument_list|(
name|name
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
comment|/* make sure the type is defined */
if|if
condition|(
name|typename
argument_list|(
name|typtr
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* create an anonymous (not in symboltable) type and subtypes */
name|char
modifier|*
name|typenam
decl_stmt|;
name|typenam
operator|=
name|gensym
argument_list|(
literal|"T_cn"
argument_list|)
expr_stmt|;
name|code_type
argument_list|(
name|typenam
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|typenam
expr_stmt|;
block|}
comment|/* depending on the type, generate appropriate initializer */
switch|switch
condition|(
name|typtr
operator|->
name|type_constr
condition|)
block|{
case|case
name|C_PROCEDURE
case|:
name|define_procedure_constant
argument_list|(
name|name
argument_list|,
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ERROR
case|:
name|define_error_constant
argument_list|(
name|name
argument_list|,
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_NUMERIC
case|:
case|case
name|C_BOOLEAN
case|:
case|case
name|C_STRING
case|:
case|case
name|C_ENUMERATION
case|:
comment|/* these are simple, since they can't include sequences */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\nstatic %s %s = {%s};\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|value
operator|->
name|cn_name
argument_list|,
name|value
operator|->
name|cn_value
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* the general case */
name|scan_for_sequences
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* kludge */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\nstatic %s %s = "
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|value
operator|->
name|cn_name
argument_list|)
expr_stmt|;
name|code_constant
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * Generate client and server code for error constants  */
end_comment

begin_macro
name|define_error_constant
argument_list|(
argument|symbol
argument_list|,
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|errvalue
decl_stmt|;
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* can't happen */
if|if
condition|(
name|typtr
operator|->
name|type_constr
operator|!=
name|C_ERROR
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"internal error (define_error_constant): not an error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|cn_constr
operator|!=
name|C_NUMERIC
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Values of ERRORs must be numeric"
argument_list|)
expr_stmt|;
name|errvalue
operator|=
literal|"-1"
expr_stmt|;
block|}
else|else
name|errvalue
operator|=
name|value
operator|->
name|cn_value
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n#define %s (ERROR_OFFSET+%s)\n\ #define %sArgs %s\n"
argument_list|,
name|value
operator|->
name|cn_name
argument_list|,
name|errvalue
argument_list|,
name|value
operator|->
name|cn_name
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"#define %sArgs %sArgs\n"
argument_list|,
name|symbol
operator|->
name|o_name
argument_list|,
name|value
operator|->
name|cn_name
argument_list|)
expr_stmt|;
name|value
operator|->
name|cn_constr
operator|=
name|C_ERROR
expr_stmt|;
comment|/* put this error in the constant's data structure */
comment|/* also store this error on the global list */
if|if
condition|(
name|typtr
operator|->
name|type_list
operator|==
name|NIL
condition|)
block|{
name|value
operator|->
name|cn_list
operator|=
name|cons
argument_list|(
operator|(
name|list
operator|)
name|errvalue
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|Errors
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
operator|(
name|list
operator|)
name|value
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|Errors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|->
name|cn_list
operator|=
name|cons
argument_list|(
operator|(
name|list
operator|)
name|errvalue
argument_list|,
operator|(
name|list
operator|)
name|typtr
argument_list|)
expr_stmt|;
name|Errors
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
operator|(
name|list
operator|)
name|value
argument_list|,
operator|(
name|list
operator|)
name|typtr
argument_list|)
argument_list|,
name|Errors
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * recursively generate the code for a constant  */
end_comment

begin_macro
name|code_constant
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|typtr
operator|->
name|type_constr
condition|)
block|{
case|case
name|C_NUMERIC
case|:
case|case
name|C_BOOLEAN
case|:
case|case
name|C_STRING
case|:
case|case
name|C_ENUMERATION
case|:
if|if
condition|(
name|value
operator|==
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
condition|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"%s"
argument_list|,
name|value
operator|->
name|cn_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ARRAY
case|:
name|code_array_constant
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_SEQUENCE
case|:
name|code_sequence_constant
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_RECORD
case|:
name|code_record_constant
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_CHOICE
case|:
name|code_choice_constant
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ERROR
case|:
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Error constants may not be part of a structure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PROCEDURE
case|:
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Procedures may not be part of a structure"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Given the name of a record field and a record constant, return  * the corresponding component of the record constant.  */
end_comment

begin_function
specifier|static
name|struct
name|constant
modifier|*
name|findcomponent
parameter_list|(
name|name
parameter_list|,
name|recvalue
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|constant
modifier|*
name|recvalue
decl_stmt|;
block|{
name|list
name|p
decl_stmt|;
if|if
condition|(
name|recvalue
operator|->
name|cn_constr
operator|!=
name|C_RECORD
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"internal error (findcomponent): constant is of type %d"
argument_list|,
name|recvalue
operator|->
name|cn_constr
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|recvalue
operator|->
name|cn_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|streq
argument_list|(
operator|(
name|char
operator|*
operator|)
name|caar
argument_list|(
name|p
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|constant
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * kludge since PCC doesn't like initializations of the form  *   struct {int length; Seqtype *sequence} seq = {3,{1,2,3}};  * instead, use:  *   Seqtype anonymous[3] = {1,2,3};  *   struct {int length; Seqtype *sequence} seq = {3,anonymous};  * We have to generate the sequence value before we walk the constant.  */
end_comment

begin_macro
name|scan_for_sequences
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|;
switch|switch
condition|(
name|typtr
operator|->
name|type_constr
condition|)
block|{
case|case
name|C_ARRAY
case|:
for|for
control|(
name|p
operator|=
name|value
operator|->
name|cn_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
name|scan_for_sequences
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|,
operator|(
expr|struct
name|constant
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_RECORD
case|:
name|scan_record_for_sequences
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_CHOICE
case|:
name|scan_choice_for_sequences
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_SEQUENCE
case|:
for|for
control|(
name|p
operator|=
name|value
operator|->
name|cn_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
name|scan_for_sequences
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|,
operator|(
expr|struct
name|constant
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|->
name|cn_seqvalname
operator|=
name|gensym
argument_list|(
literal|"S_v"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\nstatic %s %s[%d] = {\n\t"
argument_list|,
name|typename
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|)
argument_list|,
name|value
operator|->
name|cn_seqvalname
argument_list|,
name|length
argument_list|(
name|value
operator|->
name|cn_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|value
operator|->
name|cn_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|code_constant
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|,
operator|(
expr|struct
name|constant
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|",\n\t"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* other types don't have embedded sequences */
break|break;
block|}
block|}
end_block

begin_macro
name|scan_record_for_sequences
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|struct
name|constant
modifier|*
name|component
decl_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|q
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|component
operator|=
name|findcomponent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|caar
argument_list|(
name|q
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|component
operator|!=
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
condition|)
name|scan_for_sequences
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdr
argument_list|(
name|q
argument_list|)
argument_list|,
name|component
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|scan_choice_for_sequences
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* constants of type CHOICE are not implemented */
block|}
end_block

begin_escape
end_escape

begin_macro
name|code_array_constant
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"{0"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|typtr
operator|->
name|type_size
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|",0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|typtr
operator|->
name|type_size
operator|!=
name|length
argument_list|(
name|value
operator|->
name|cn_list
argument_list|)
condition|)
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"wrong number of constant elements specified for array"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\t{"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|value
operator|->
name|cn_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|code_constant
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|,
operator|(
expr|struct
name|constant
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|code_choice_constant
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|struct
name|type
modifier|*
name|bt
decl_stmt|;
name|char
modifier|*
name|desigval
decl_stmt|;
name|struct
name|object
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
condition|)
name|desigval
operator|=
literal|"?"
expr_stmt|;
comment|/* caar(typtr->type_designator->type_list); */
else|else
name|desigval
operator|=
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|value
operator|->
name|cn_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\t{ %s"
argument_list|,
name|desigval
argument_list|)
expr_stmt|;
comment|/* find the corresponding arm of the choice */
name|bt
operator|=
name|TNIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_candidates
init|;
name|bt
operator|==
name|TNIL
operator|&&
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|bt
operator|==
name|TNIL
operator|&&
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|name
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|caar
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|name
operator|->
name|o_enum
operator|->
name|en_name
argument_list|,
name|desigval
argument_list|)
condition|)
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bt
operator|==
name|TNIL
condition|)
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"CHOICE designator %s is invalid here"
argument_list|,
name|desigval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bt
operator|!=
name|NilRecord_type
condition|)
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"Constants of type CHOICE are not supported"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\t}"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|code_sequence_constant
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
operator|||
operator|(
name|p
operator|=
name|value
operator|->
name|cn_list
operator|)
operator|==
name|NIL
condition|)
block|{
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"{0, 0}"
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|=
name|length
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|typtr
operator|->
name|type_size
operator|<
name|l
condition|)
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"too many constant elements specified for sequence"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"{%d, %s}"
argument_list|,
name|l
argument_list|,
name|value
operator|->
name|cn_seqvalname
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|code_record_constant
argument_list|(
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|struct
name|constant
modifier|*
name|component
decl_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|q
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
expr|struct
name|constant
operator|*
operator|)
literal|0
condition|)
name|component
operator|=
name|value
expr_stmt|;
else|else
name|component
operator|=
name|findcomponent
argument_list|(
operator|(
name|char
operator|*
operator|)
name|caar
argument_list|(
name|q
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|code_constant
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdr
argument_list|(
name|q
argument_list|)
argument_list|,
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\t}"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

