begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: code.c,v 2.4 87/03/17 09:32:16 ed Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	code.c,v $  * Revision 2.4  87/03/17  09:32:16  ed  * changes from Webster integrated  *   * Revision 2.4  87/03/17  09:32:16  ed  * Added -I switch to establish search path for DEPENDS UPON files.  *   * Revision 2.3  86/06/30  12:50:28  jqj  * bugfix to Server() code generation from Jack Callahan -- add "break;" if  * new Courier procedure call is for a different module.  I'm not convinced  * this is the right fix, but have not had time to examine it in detail.  *   * Revision 2.2  86/06/06  07:28:31  jqj  * many mods for better symbol table management:  added CurrentModule,  *  made check_dependency, make_symbol, check_def set/use/use a symbol  *  table instead of a module name string, etc.  Result is that we can  *  now handle DEPENDS UPON 2 versions of same program.  *   * Revision 2.1  86/01/21  10:04:02  jqj  * changes from Dan Chernikoff:  dereferencing null pointer in code  * generation for Abort messages from servers.  *   * Revision 2.0  85/11/21  07:21:28  jqj  * 4.3BSD standard release  *   * Revision 1.6  85/05/23  06:19:16  jqj  * *** empty log message ***  *   * Revision 1.6  85/05/23  06:19:16  jqj  * Public Beta-test version, released 24 May 1985  *   * Revision 1.5  85/05/06  08:12:58  jqj  * Almost Beta-test version.  *   * Revision 1.4  85/03/26  06:09:24  jqj  * Revised public alpha-test version, released 26 March 1985  *   * Revision 1.3  85/03/11  16:38:39  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:04:47  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:15  jqj  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_include
include|#
directive|include
file|<xnscourier/courierdb.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|CurrentProgram
init|=
literal|"unknown"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|object
modifier|*
name|CurrentModule
init|=
operator|(
expr|struct
name|object
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CurrentNumber
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CurrentVersion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dirs
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ndirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Generate comments, #includes, and client binding.  * This action is called before the module body has been reduced.  * (jqj)  */
end_comment

begin_macro
name|program_header
argument_list|(
argument|symbol
argument_list|,
argument|number
argument_list|,
argument|version
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|number
decl_stmt|,
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|check_dependency
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Module %s already seen."
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
return|return;
block|}
name|CurrentModule
operator|=
name|make_module
argument_list|(
name|symbol
argument_list|,
name|number
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|CurrentProgram
operator|=
name|symbol
expr_stmt|;
name|CurrentVersion
operator|=
name|stringtocard
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|CurrentNumber
operator|=
name|stringtocard
argument_list|(
name|number
argument_list|)
expr_stmt|;
comment|/* 	 * only do this stuff for the main Courier program -- generate 	 * minimal code for DEPENDS UPON inclusions. 	 */
if|if
condition|(
name|recursive_flag
condition|)
block|{
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"/* DEPENDS UPON %s NUMBER %d VERSION %d */\n"
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentNumber
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Generate initial contents of all sorts of stuff: 	 * (1) set up gensym counter, 	 * (2) generate beginning of header files, support file,  	 *	client file, server file 	 */
name|setgensym
argument_list|(
name|number
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"/*\n\  * This header file contains inclusions for the main definitions and for\n\  * any DEPENDS UPON modules.  It also contains #define commands to open\n\  * the scope of the main definitons module.\n\  *\n\  * main inclusion:\n\  */\n\ #include \"%s%d.h\"\n\n"
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
comment|/* 	 * In the definitions for this module, make sure we don't 	 * compile things twice by wrapping everything inside of a 	 * #ifndef ... #endif (the #endif is in wrapup_program() ). 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"/*\n\  * Definitions for %s VERSION %s NUMBER %s.\n\  */\n\ #ifndef __%s%d\n\ #define __%s%d\n\ #include<xnscourier/courier.h>\n\ #include<xnscourier/courierconnection.h>\n\n"
argument_list|,
name|CurrentProgram
argument_list|,
name|version
argument_list|,
name|number
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"/*\n\  * Support routines for %s.\n\  */\n\ #include \"%s%d.h\"\n"
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"/*\n\  * Client routines for %s.\n\  */\n\ #include \"%s%d.h\"\n"
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"/*\n\  * Server for %s.\n\  */\n\ #include \"%s%d.h\"\n\ #include<xnscourier/except.h>\n\n\ extern CourierConnection *_serverConnection;\n"
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Recursively parse a program to get types and constants.  * as a side effect, enters the program name into the SymbolTables   * symbol table.  */
end_comment

begin_macro
name|ref_program
argument_list|(
argument|name
argument_list|,
argument|number
argument_list|,
argument|version
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|number
decl_stmt|,
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|save_offset
decl_stmt|;
name|char
modifier|*
name|save_input_file
decl_stmt|;
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
name|int
name|intversion
decl_stmt|,
name|i
decl_stmt|;
specifier|extern
name|int
modifier|*
name|save_parser_state
parameter_list|()
function_decl|;
name|struct
name|courierdbent
modifier|*
name|dbent
decl_stmt|;
name|intversion
operator|=
name|stringtocard
argument_list|(
name|version
argument_list|)
expr_stmt|;
comment|/* 	 * in a DEPENDS UPON inclusion, generate minimal code, making 	 * sure we don't do it twice.  The included program is wrapped in 	 * an #ifdef ... #endif 	 */
if|if
condition|(
operator|!
name|recursive_flag
condition|)
block|{
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ /*\n\  * Definitions from DEPENDS UPON %s inclusion\n\  * (must be linked with %s%d_support.c also)\n\  */\n\ #include<xnscourier/%s%d.h>\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|intversion
argument_list|,
name|name
argument_list|,
name|intversion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|check_module_def
argument_list|(
name|name
argument_list|,
name|number
argument_list|,
name|version
argument_list|)
condition|)
block|{
comment|/* we've already parsed this one, so don't bother to redo */
comment|/* as a side effect, check_module_def adds this module to */
comment|/* the dependency list for CurrentModule */
return|return;
block|}
name|save_offset
operator|=
name|ftell
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|save_input_file
operator|=
name|input_file
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d.cr"
argument_list|,
name|name
argument_list|,
name|intversion
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|input_file
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * attempt to find file from include directories 		 *	-I switch on command line 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndirs
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s%s%d.cr"
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|,
operator|(
name|strcmp
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|?
literal|""
else|:
literal|"/"
operator|)
argument_list|,
name|name
argument_list|,
name|intversion
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|input_file
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 		 * if all else fails, look in courier description file 		 */
if|if
condition|(
name|i
operator|>=
name|ndirs
condition|)
block|{
name|dbent
operator|=
name|getcourierservice
argument_list|(
name|stringtocard
argument_list|(
name|number
argument_list|)
argument_list|,
name|intversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbent
operator|==
name|NULL
operator|||
name|dbent
operator|->
name|cr_description
operator|==
name|NULL
operator|||
operator|(
name|input_file
operator|=
name|copy
argument_list|(
name|dbent
operator|->
name|cr_description
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|freopen
argument_list|(
name|input_file
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"file %s not found"
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|save_input_file
expr_stmt|;
name|freopen
argument_list|(
name|input_file
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|stdin
argument_list|,
name|save_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|p
operator|=
name|save_parser_state
argument_list|()
expr_stmt|;
comment|/* note:  recursive_flag is now set */
operator|(
name|void
operator|)
name|yyparse
argument_list|()
expr_stmt|;
comment|/* recursively parse */
name|restore_parser_state
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file
operator|=
name|save_input_file
expr_stmt|;
name|freopen
argument_list|(
name|input_file
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|stdin
argument_list|,
name|save_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Generate any code needed after DEPENDS UPON modules have been  * parsed, but before declarations.  */
end_comment

begin_macro
name|program_body
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|recursive_flag
condition|)
return|return;
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"/*\n\  * Widen scope to include all symbols defined in main inclusion:\n\  */\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate code relating to binding.  * This action is called after the entire module has been reduced.  */
end_comment

begin_macro
name|wrapup_program
argument_list|(
argument|prog
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|recursive_flag
condition|)
return|return;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n#endif __%s\n\n"
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|prog
argument_list|,
name|CurrentProgram
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"internal error (module): conflicting module names, %s and %s"
argument_list|,
name|prog
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
name|generate_server_binding
argument_list|()
expr_stmt|;
name|generate_client_binding
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate export function for server.  */
end_comment

begin_macro
name|generate_server_binding
argument_list|()
end_macro

begin_block
block|{
name|list
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\nServer(skipcount,skippedwords)\n\ \tint skipcount;\n\ \tUnspecified skippedwords[];\n\ {\n\ \tCardinal _procedure;\n\ \tregister Unspecified *_buf;\n\ \tLongCardinal programnum;\n\ \tCardinal versionnum;\n\ \tCardinal _n;\n\ \n\ \tfor (;;) {\n\ \t\t_buf = ReceiveCallMessage(&_procedure, skipcount, skippedwords);\n\ \t\tDURING switch (_procedure) {\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Find all the procedures declared in the program. 	 */
for|for
control|(
name|p
operator|=
name|Procedures
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t\tcase %s:\n\ \t\t\tserver_%s(_buf);\n\ \t\t\tbreak;\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|caar
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t\tdefault:\n\ \t\t\tNoSuchProcedureValue(\"%s\", _procedure);\n\ \t\t\tbreak;\n\ \t\t} HANDLER {\n\ \t\t    Deallocate(_buf);\n\ \t\t    switch (Exception.Code) {\n"
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|Errors
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|struct
name|constant
modifier|*
name|errconst
decl_stmt|;
name|struct
name|type
modifier|*
name|errtype
decl_stmt|;
name|errconst
operator|=
operator|(
expr|struct
name|constant
operator|*
operator|)
name|caar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|errtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtype
operator|==
name|TNIL
condition|)
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t\t    case %s:\n\ \t\t\t_buf = Allocate(0);\n\ \t\t\tSendAbortMessage(Exception.Code-ERROR_OFFSET, 0, _buf);\n\ \t\t\tbreak;\n"
argument_list|,
name|errconst
operator|->
name|cn_name
argument_list|)
expr_stmt|;
comment|/* errtype != TNIL */
elseif|else
if|if
condition|(
name|typename
argument_list|(
name|errtype
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Internal error (server): unexpanded type for %s"
argument_list|,
name|errconst
operator|->
name|cn_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* errtype != TNIL&& typename(errtype) != NULL */
else|else
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t\t    case %s:\n\ \t\t\t_n = sizeof_%s((%s *)Exception.Message);\n\ \t\t\t_buf = Allocate(_n);\n\ \t\t\t(void) %s((%s*)Exception.Message, _buf);\n\ \t\t\tSendAbortMessage(Exception.Code-ERROR_OFFSET, _n, _buf);\n\ \t\t\tbreak;\n"
argument_list|,
name|errconst
operator|->
name|cn_name
argument_list|,
name|typename
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|typename
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|errtype
argument_list|)
argument_list|,
name|typename
argument_list|(
name|errtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t\t    default:\n\ \t\t\t_buf = Allocate(0);\n\ \t\t\tSendRejectMessage(unspecifiedError, 0, _buf);\n\ \t\t\tbreak;\n\ \t\t    }\n\ \t\t} END_HANDLER;\n\ \t\tDeallocate(_buf);\n\ \t\tfor (;;) {\n\ \t\t\tskipcount = LookAheadCallMsg(&programnum,&versionnum,\n\ \t\t\t\t\tskippedwords);\n\ \t\t\tif (skipcount< 0) return(0);\t/* timed out */\n\ \t\t\tif (programnum != %d || versionnum != %d)\n\ \t\t\t\tExecCourierProgram(programnum, versionnum,\n\ \t\t\t\t\t\tskipcount, skippedwords);\n\ \t\t\telse break;\n\ \t\t\}  /* loop if can't exec that program */\n\ \t}\n\ }\n"
argument_list|,
name|CurrentNumber
argument_list|,
name|CurrentVersion
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate function for importing server module.  */
end_comment

begin_macro
name|generate_client_binding
argument_list|()
end_macro

begin_block
block|{ }
end_block

end_unit

