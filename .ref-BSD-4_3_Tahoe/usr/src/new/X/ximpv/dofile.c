begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 University of Alberta *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_dofile_c
init|=
literal|"$Header: dofile.c,v 10.2 86/02/01 15:59:47 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"site.h"
end_include

begin_include
include|#
directive|include
file|"imPdefs.h"
end_include

begin_include
include|#
directive|include
file|"imPcodes.h"
end_include

begin_include
include|#
directive|include
file|"impv.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|XWIND
end_ifndef

begin_include
include|#
directive|include
file|<pixrect/pixrect_hs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|dofile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|code
decl_stmt|;
specifier|register
name|struct
name|glyph
modifier|*
name|gp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|COLOR
specifier|register
name|int
name|k
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|t
decl_stmt|,
name|tmp
index|[
literal|1000
index|]
decl_stmt|;
name|unsigned
name|char
name|setcolor
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|COLOR
name|short
name|rwid
decl_stmt|,
name|iwid
decl_stmt|;
name|short
name|hsize
decl_stmt|,
name|vsize
decl_stmt|;
name|MSKWORD
name|mw
decl_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|gc
argument_list|()
operator|)
operator|==
literal|'@'
condition|)
comment|/* skip document control stuff */
while|while
condition|(
operator|(
name|code
operator|=
name|gc
argument_list|()
operator|)
operator|!=
literal|')'
condition|)
if|if
condition|(
name|code
operator|==
literal|'"'
condition|)
while|while
condition|(
name|gc
argument_list|()
operator|!=
literal|'"'
condition|)
empty_stmt|;
do|do
block|{
if|if
condition|(
name|code
operator|&
literal|0200
condition|)
name|decode
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASP0
case|:
name|HPos
operator|+=
name|SpaceSize
expr_stmt|;
break|break;
case|case
name|ASP1
case|:
name|HPos
operator|+=
name|SpaceSize
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|AM
case|:
name|EXTSIGN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|HPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMM
case|:
name|HPos
operator|--
expr_stmt|;
break|break;
case|case
name|AMP
case|:
name|HPos
operator|++
expr_stmt|;
break|break;
case|case
name|ASRULE
case|:
name|EXTSIGN
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|P_rule
argument_list|()
expr_stmt|;
break|break;
case|case
name|ABRULE
case|:
name|P_rule
argument_list|()
expr_stmt|;
break|break;
case|case
name|ASGLY
case|:
name|EXTSIGN
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|EXTSIGN
argument_list|(
literal|6
argument_list|)
expr_stmt|;
case|case
name|ABGLY
case|:
name|fam
operator|=
operator|(
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|7
operator|)
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|family
index|[
name|fam
index|]
operator|==
literal|0
condition|)
block|{
name|family
index|[
name|fam
index|]
operator|=
operator|(
expr|struct
name|glyph
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
name|font0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|127
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|family
index|[
name|fam
index|]
index|[
name|i
index|]
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
name|fam_rot
index|[
name|fam
index|]
operator|=
operator|(
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|14
operator|)
operator|&
literal|03
expr_stmt|;
block|}
name|gp
operator|=
operator|&
name|family
index|[
name|fam
index|]
index|[
literal|0177
operator|&
name|V
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
name|gp
operator|->
name|advance
operator|=
name|V
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|gp
operator|->
name|left
operator|=
name|V
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|gp
operator|->
name|top
operator|=
name|V
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|rwid
operator|=
operator|(
name|V
argument_list|(
literal|3
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
block|{
name|gp
operator|->
name|width
operator|=
operator|(
name|V
argument_list|(
literal|3
argument_list|)
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|gp
operator|->
name|height
operator|=
operator|(
name|V
argument_list|(
literal|5
argument_list|)
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|iwid
operator|=
name|gp
operator|->
name|height
operator|*
name|gp
operator|->
name|width
expr_stmt|;
name|gp
operator|->
name|bits
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|iwid
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|gp
operator|->
name|bits
operator|,
name|i
operator|=
name|iwid
init|;
name|i
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|tmp
operator|,
name|i
operator|=
operator|(
name|gp
operator|->
name|width
operator|*
literal|3
operator|)
init|;
name|i
operator|--
condition|;
control|)
operator|*
name|tp
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V
argument_list|(
literal|5
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rwid
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
name|gc
argument_list|()
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|8
init|;
name|k
operator|--
condition|;
control|)
name|tmp
index|[
name|j
operator|*
literal|8
operator|+
operator|(
literal|7
operator|-
name|k
operator|)
index|]
operator|=
operator|(
name|t
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|tp
operator|=
name|tmp
expr_stmt|;
name|p
operator|=
operator|&
name|gp
operator|->
name|bits
index|[
name|i
operator|/
literal|3
operator|*
name|gp
operator|->
name|width
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|gp
operator|->
name|width
init|;
name|j
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|+=
operator|*
name|tp
operator|++
operator|+
operator|*
name|tp
operator|++
operator|+
operator|*
name|tp
operator|++
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|gp
operator|->
name|bits
operator|,
name|i
operator|=
name|iwid
init|;
name|i
operator|--
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
name|gp
operator|->
name|width
operator|=
operator|(
name|V
argument_list|(
literal|3
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|gp
operator|->
name|height
operator|=
operator|(
name|V
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/*round size to nearest byte size */
name|iwid
operator|=
operator|(
name|gp
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|gp
operator|->
name|bits
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|gp
operator|->
name|height
operator|*
name|iwid
argument_list|)
expr_stmt|;
comment|/* for the height of the glyph */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V
argument_list|(
literal|5
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* point at the bytes of glyph storage*/
name|p
operator|=
operator|&
name|gp
operator|->
name|bits
index|[
operator|(
name|i
operator|>>
literal|1
operator|)
operator|*
name|iwid
index|]
expr_stmt|;
comment|/* for two bytes at a time */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rwid
condition|;
name|j
operator|+=
literal|2
operator|,
name|p
operator|++
control|)
block|{
comment|/* squeez the first byte 4 left */
name|mw
operator|=
name|map8_4
index|[
name|gc
argument_list|()
index|]
operator|<<
literal|4
expr_stmt|;
comment|/* if not the last byte squeez */
comment|/* in another */
if|if
condition|(
name|j
operator|<
operator|(
name|rwid
operator|-
literal|1
operator|)
condition|)
name|mw
operator||=
name|map8_4
index|[
name|gc
argument_list|()
index|]
expr_stmt|;
comment|/* or store byte if i odd */
if|if
condition|(
name|i
operator|&
literal|1
condition|)
operator|*
name|p
operator||=
name|mw
expr_stmt|;
comment|/* store byte if even */
else|else
operator|*
name|p
operator|=
name|mw
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ADELC
case|:
case|case
name|ADELG
case|:
name|gp
operator|=
operator|&
name|family
index|[
literal|0177
operator|&
operator|(
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|7
operator|)
index|]
index|[
literal|0177
operator|&
name|V
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|bits
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gp
operator|->
name|bits
argument_list|)
expr_stmt|;
name|gp
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ADELF
case|:
name|fam
operator|=
literal|0177
operator|&
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|family
index|[
name|fam
index|]
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|127
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gp
operator|=
operator|&
name|family
index|[
name|fam
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|bits
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gp
operator|->
name|bits
argument_list|)
expr_stmt|;
name|gp
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|AMARGIN
case|:
name|BeginOfLine
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABSKIP
case|:
name|InterLine
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|AN
case|:
name|HPos
operator|=
name|BeginOfLine
expr_stmt|;
name|VPos
operator|+=
name|InterLine
expr_stmt|;
break|break;
case|case
name|AEND
case|:
if|if
condition|(
name|ppause
argument_list|()
condition|)
return|return;
case|case
name|APAGE
case|:
name|HPos
operator|=
name|VPos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AF
case|:
name|CurFamily
operator|=
literal|0177
operator|&
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASETSP
case|:
name|SpaceSize
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH
case|:
if|if
condition|(
name|V
argument_list|(
literal|1
argument_list|)
operator|&
literal|01
condition|)
name|HPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|1
expr_stmt|;
else|else
name|HPos
operator|=
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|AV
case|:
if|if
condition|(
name|V
argument_list|(
literal|1
argument_list|)
operator|&
literal|01
condition|)
name|VPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|1
expr_stmt|;
else|else
name|VPos
operator|=
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|ASET_HV_SYS
case|:
comment|/*page orientation  not done*/
name|set_hv_sys
argument_list|()
expr_stmt|;
break|break;
case|case
name|ASET_ABS_H
case|:
comment|/*set abs major advance pos*/
name|HPos
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASET_ABS_V
case|:
comment|/*set abs minor advance pos*/
name|VPos
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASET_REL_H
case|:
comment|/*set rel major advance pos*/
name|HPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASET_REL_V
case|:
comment|/*set rel minor advance pos*/
name|VPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|AROTMS
case|:
comment|/*set advance directions not done*/
name|advance_dir
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMMOVE
case|:
comment|/*add to main dir  not done*/
if|if
condition|(
name|orient
operator|==
literal|0
condition|)
name|HPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASMOVE
case|:
comment|/*add to main dir  not done*/
if|if
condition|(
name|orient
operator|==
literal|0
condition|)
name|VPos
operator|+=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACREATE_MAP
case|:
comment|/*create font map not done*/
comment|/* get name  and size*/
name|map_name
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ntuples
operator|=
name|v
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* read and throw away bytes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntuples
operator|*
literal|4
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|gc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* get memory for ntuples*/
name|map
operator|=
operator|(
name|map_ptr
operator|*
operator|)
name|malloc
argument_list|(
name|ntuples
operator|*
sizeof|sizeof
name|int
argument_list|)
expr_stmt|;
comment|/* read in map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntuples
condition|;
name|i
operator|++
control|)
block|{
name|get
name|and
name|store
name|byte
name|word
name|byte
name|map
init|=
name|map
decl_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|ACREATE_FAMILY
case|:
comment|/* create family table not done */
comment|/* get family name and size*/
name|fam_in
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ntuples
operator|=
name|v
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntuples
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|gc
argument_list|()
expr_stmt|;
while|while
condition|(
name|gc
argument_list|()
operator|!=
name|NULL
condition|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* get memory for ntuples*/
comment|/* read in family */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntuples
condition|;
name|i
operator|++
control|)
block|{
name|get
name|and
name|store
name|byte
name|string
operator|*
block|}
endif|#
directive|endif
break|break;
case|case
name|AFORCE_GLY_DELETE
case|:
comment|/*delete marked glyphs  */
break|break;
case|case
name|ASET_PATH
case|:
comment|/*get a line path */
comment|/*get vertexcount*/
name|vertex_count
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|path_point
operator|=
operator|(
expr|struct
name|path
operator|*
operator|)
name|malloc
argument_list|(
name|vertex_count
operator|*
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vertex_count
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|path_point
operator|+
name|i
operator|)
operator|->
name|hor
operator|=
name|getint
argument_list|()
operator|/
literal|3
expr_stmt|;
operator|(
name|path_point
operator|+
name|i
operator|)
operator|->
name|vert
operator|=
name|getint
argument_list|()
operator|/
literal|3
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vertex_count
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|path_point
operator|+
name|i
operator|)
operator|->
name|hor
operator|=
operator|(
name|getint
argument_list|()
operator|>>
literal|1
operator|)
expr_stmt|;
operator|(
name|path_point
operator|+
name|i
operator|)
operator|->
name|vert
operator|=
operator|(
name|getint
argument_list|()
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ASET_TEXTURE
case|:
comment|/*set texture for lines? */
name|fam
operator|=
operator|(
name|V
argument_list|(
literal|1
argument_list|)
operator|>>
literal|7
operator|)
operator|&
literal|0177
expr_stmt|;
name|member
operator|=
name|V
argument_list|(
literal|1
argument_list|)
operator|&
literal|0177
expr_stmt|;
break|break;
case|case
name|ASET_PEN
case|:
comment|/*set pen diameter */
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
name|diameter
operator|=
operator|(
name|v
argument_list|(
literal|1
argument_list|)
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
else|else
endif|#
directive|endif
endif|COLOR
name|diameter
operator|=
operator|(
name|v
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
operator|)
operator|>
literal|1
expr_stmt|;
break|break;
case|case
name|ADRAW_PATH
case|:
comment|/* draw a path of bits or lines */
name|operation
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|diameter
operator|<
literal|4
condition|)
block|{
comment|/* draw up to 4 || lines */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|vertex_count
operator|-
literal|1
operator|)
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diameter
condition|;
name|i
operator|++
control|)
block|{
name|draw_path1
argument_list|(
operator|(
name|path_point
operator|+
name|j
operator|)
operator|->
name|hor
argument_list|,
operator|(
name|path_point
operator|+
name|j
operator|)
operator|->
name|vert
argument_list|,
operator|(
name|path_point
operator|+
name|j
operator|+
literal|1
operator|)
operator|->
name|hor
argument_list|,
operator|(
name|path_point
operator|+
name|j
operator|+
literal|1
operator|)
operator|->
name|vert
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* draw a path wider than 4 lines */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vertex_count
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AFILL_PATH
case|:
comment|/* fill in a polygon   not done*/
name|operation
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABIT_MAP
case|:
comment|/* get a bit map  not done*/
name|operation
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hsize
operator|=
name|v
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|vsize
operator|=
name|v
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|Prnt_Bitmap
argument_list|(
name|hsize
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASET_MAGNIFICATION
case|:
name|magnification
operator|=
name|v
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASET_PUSH_MASK
case|:
comment|/* set the state mask */
name|push_mask
operator|=
name|V
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|APUSH
case|:
comment|/*push a state onto the state stack */
name|push_stack
index|[
name|pushed
index|]
operator|=
operator|(
expr|struct
name|state
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
name|pstack
argument_list|)
expr_stmt|;
name|stap
operator|=
name|push_stack
index|[
name|pushed
index|]
expr_stmt|;
name|stap
operator|->
name|push_mask
operator|=
name|push_mask
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|0400
condition|)
block|{
name|stap
operator|->
name|diameter
operator|=
name|diameter
expr_stmt|;
name|stap
operator|->
name|texture
operator|=
name|texture
expr_stmt|;
block|}
if|if
condition|(
name|push_mask
operator|&
literal|0200
condition|)
name|stap
operator|->
name|SpaceSize
operator|=
name|SpaceSize
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|0100
condition|)
name|stap
operator|->
name|InterLine
operator|=
name|InterLine
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|040
condition|)
name|stap
operator|->
name|BeginOfLine
operator|=
name|BeginOfLine
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|020
condition|)
name|stap
operator|->
name|fam
operator|=
name|fam
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|010
condition|)
block|{
name|stap
operator|->
name|HPos
operator|=
name|HPos
expr_stmt|;
name|stap
operator|->
name|VPos
operator|=
name|VPos
expr_stmt|;
block|}
if|if
condition|(
name|push_mask
operator|&
literal|04
condition|)
name|stap
operator|->
name|advance_dir
operator|=
name|advance_dir
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|02
condition|)
block|{
name|stap
operator|->
name|horigin
operator|=
name|horigin
expr_stmt|;
name|stap
operator|->
name|vorigin
operator|=
name|vorigin
expr_stmt|;
block|}
if|if
condition|(
name|push_mask
operator|&
literal|01
condition|)
name|stap
operator|->
name|orient
operator|=
name|orient
expr_stmt|;
name|pushed
operator|++
expr_stmt|;
break|break;
case|case
name|APOP
case|:
comment|/*pop a state off the state stack */
if|if
condition|(
name|pushed
operator|>=
literal|1
condition|)
block|{
name|pushed
operator|--
expr_stmt|;
name|stap
operator|=
name|push_stack
index|[
name|pushed
index|]
expr_stmt|;
name|push_mask
operator|=
name|stap
operator|->
name|push_mask
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|0400
condition|)
block|{
name|diameter
operator|=
name|stap
operator|->
name|diameter
expr_stmt|;
name|texture
operator|=
name|stap
operator|->
name|texture
expr_stmt|;
block|}
if|if
condition|(
name|push_mask
operator|&
literal|0200
condition|)
name|SpaceSize
operator|=
name|stap
operator|->
name|SpaceSize
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|0100
condition|)
name|InterLine
operator|=
name|stap
operator|->
name|InterLine
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|040
condition|)
name|BeginOfLine
operator|=
name|stap
operator|->
name|BeginOfLine
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|020
condition|)
name|fam
operator|=
name|stap
operator|->
name|fam
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|010
condition|)
block|{
name|HPos
operator|=
name|stap
operator|->
name|HPos
expr_stmt|;
name|VPos
operator|=
name|stap
operator|->
name|VPos
expr_stmt|;
block|}
if|if
condition|(
name|push_mask
operator|&
literal|04
condition|)
name|advance_dir
operator|=
name|stap
operator|->
name|advance_dir
expr_stmt|;
if|if
condition|(
name|push_mask
operator|&
literal|02
condition|)
block|{
name|horigin
operator|=
name|stap
operator|->
name|horigin
expr_stmt|;
name|vorigin
operator|=
name|stap
operator|->
name|vorigin
expr_stmt|;
block|}
if|if
condition|(
name|push_mask
operator|&
literal|01
condition|)
name|orient
operator|=
name|stap
operator|->
name|orient
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|push_stack
index|[
name|pushed
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can not pop more states\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADEFINE_MACRO
case|:
comment|/* define a macro  */
comment|/* get the name v(1) and length V(2) of the macro*/
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|v
argument_list|(
literal|1
argument_list|)
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|gc
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bc
operator|.
name|red
operator|=
operator|(
name|float
operator|)
name|gc
argument_list|()
expr_stmt|;
name|bc
operator|.
name|green
operator|=
operator|(
name|float
operator|)
name|gc
argument_list|()
expr_stmt|;
name|bc
operator|.
name|blue
operator|=
operator|(
name|float
operator|)
name|gc
argument_list|()
expr_stmt|;
if|if
condition|(
name|slide
condition|)
block|{
name|backcolor
operator|=
name|setcolor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scr_size
init|;
name|i
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
name|backcolor
expr_stmt|;
block|}
block|}
else|else
block|{
name|cc
operator|.
name|red
operator|=
operator|(
name|float
operator|)
name|gc
argument_list|()
expr_stmt|;
name|cc
operator|.
name|green
operator|=
operator|(
name|float
operator|)
name|gc
argument_list|()
expr_stmt|;
name|cc
operator|.
name|blue
operator|=
operator|(
name|float
operator|)
name|gc
argument_list|()
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
name|macro
index|[
name|v
argument_list|(
literal|1
argument_list|)
index|]
operator|.
name|length
operator|=
name|V
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|macro_length
operator|=
name|V
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* get space equal to length */
name|mp
operator|=
name|macro
index|[
name|v
argument_list|(
literal|1
argument_list|)
index|]
operator|.
name|pointer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|macro_length
argument_list|)
expr_stmt|;
comment|/*read the macro into the got space*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro_length
condition|;
name|i
operator|++
control|)
name|mp
index|[
name|i
index|]
operator|=
name|gc
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|AEXECUTE_MACRO
case|:
comment|/* execute a macro */
name|macro_length
operator|=
name|macro
index|[
name|v
argument_list|(
literal|1
argument_list|)
index|]
operator|.
name|length
expr_stmt|;
name|mp
operator|=
name|macro
index|[
name|v
argument_list|(
literal|1
argument_list|)
index|]
operator|.
name|pointer
expr_stmt|;
name|macro_on
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ANOP
case|:
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|code
operator|&
literal|0200
operator|)
condition|)
block|{
name|gp
operator|=
operator|&
name|family
index|[
name|CurFamily
index|]
index|[
name|code
index|]
expr_stmt|;
name|Prnt_Glyph
argument_list|(
operator|&
name|family
index|[
name|CurFamily
index|]
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|'$'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|AEOF
operator|!=
operator|(
name|code
operator|=
name|gc
argument_list|()
operator|)
condition|)
do|;
block|}
end_block

begin_decl_stmt
name|char
name|r_mask
index|[
literal|9
index|]
init|=
block|{
literal|0
block|,
literal|01
block|,
literal|03
block|,
literal|07
block|,
literal|017
block|,
literal|037
block|,
literal|077
block|,
literal|0177
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|l_mask
index|[
literal|9
index|]
init|=
block|{
literal|0377
block|,
literal|0376
block|,
literal|0374
block|,
literal|0370
block|,
literal|0360
block|,
literal|0340
block|,
literal|0300
block|,
literal|0200
block|,
literal|00
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Prnt_Glyph
argument_list|(
name|gp
argument_list|)
specifier|register
expr|struct
name|glyph
operator|*
name|gp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|bit_width
decl_stmt|,
name|skew
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|bp
init|=
name|gp
operator|->
name|bits
decl_stmt|;
name|short
name|x_bit_pos
decl_stmt|,
name|y_bit_pos
decl_stmt|;
ifdef|#
directive|ifdef
name|COLOR
name|short
name|int
name|j
decl_stmt|;
name|unsigned
name|char
name|setcolor
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|COLOR
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
block|{
name|x_bit_pos
operator|=
operator|(
name|HPos
operator|-
name|gp
operator|->
name|left
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|y_bit_pos
operator|=
operator|(
name|VPos
operator|-
name|gp
operator|->
name|top
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|base
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
operator|)
operator|+
name|y_bit_pos
operator|*
name|scr_x
operator|+
name|x_bit_pos
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
name|x_bit_pos
operator|=
operator|(
name|HPos
operator|-
name|gp
operator|->
name|left
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|y_bit_pos
operator|=
operator|(
name|VPos
operator|-
name|gp
operator|->
name|top
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|HPos
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|+
name|gp
operator|->
name|width
operator|)
operator|>
name|scr_x
operator|)
operator|||
operator|(
operator|(
operator|(
operator|(
name|VPos
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|+
name|gp
operator|->
name|height
operator|)
operator|>
name|scr_y
operator|)
operator|||
name|bp
operator|==
literal|0
condition|)
block|{
name|big
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|x_bit_pos
operator|<
literal|0
operator|)
operator|||
operator|(
name|y_bit_pos
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|little
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|XWIND
name|base
operator|=
name|pscreen
else|#
directive|else
else|XWIND
name|base
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
operator|)
endif|#
directive|endif
endif|XWIND
operator|+
operator|(
name|y_bit_pos
operator|*
name|wide
operator|)
operator|+
operator|(
name|x_bit_pos
operator|>>
literal|3
operator|)
expr_stmt|;
block|}
comment|/* skew is bits displacement of glyph from a byte edge*/
name|skew
operator|=
literal|8
operator|-
operator|(
name|x_bit_pos
operator|&
literal|07
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
block|{
for|for
control|(
name|i
operator|=
name|gp
operator|->
name|height
init|;
name|i
operator|--
condition|;
name|base
operator|+=
name|scr_x
control|)
block|{
name|sp
operator|=
name|base
expr_stmt|;
for|for
control|(
name|j
operator|=
name|gp
operator|->
name|width
init|;
name|j
operator|--
condition|;
control|)
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0
condition|)
operator|*
name|sp
operator|++
operator|=
name|setcolor
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
expr_stmt|;
else|else
block|{
name|bp
operator|++
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
for|for
control|(
name|i
operator|=
name|gp
operator|->
name|height
init|;
name|i
operator|--
condition|;
name|base
operator|+=
name|wide
control|)
block|{
name|sp
operator|=
name|base
expr_stmt|;
for|for
control|(
name|bit_width
operator|=
name|gp
operator|->
name|width
init|;
name|bit_width
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
block|{
operator|*
name|sp
operator|++
operator||=
operator|*
name|bp
operator|++
expr_stmt|;
name|bit_width
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sp
operator|++
operator||=
operator|(
operator|*
name|bp
operator|>>
operator|(
literal|8
operator|-
name|skew
operator|)
operator|)
operator|&
name|r_mask
index|[
name|skew
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bit_width
operator|-=
name|skew
operator|)
operator|<=
literal|0
condition|)
block|{
name|bp
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|sp
operator||=
operator|(
operator|*
name|bp
operator|++
operator|<<
name|skew
operator|)
operator|&
name|l_mask
index|[
name|skew
index|]
expr_stmt|;
name|bit_width
operator|-=
operator|(
literal|8
operator|-
name|skew
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|HPos
operator|+=
name|gp
operator|->
name|advance
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|l_bits
index|[
literal|8
index|]
init|=
block|{
literal|0377
block|,
literal|0200
block|,
literal|0300
block|,
literal|0340
block|,
literal|0360
block|,
literal|0370
block|,
literal|0374
block|,
literal|0376
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|P_rule
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|bit_width
decl_stmt|,
name|skew
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|int
name|bits_l
decl_stmt|;
name|short
name|x_bit_pos
decl_stmt|,
name|y_bit_pos
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|V
argument_list|(
literal|1
argument_list|)
operator|+
name|HPos
operator|)
operator|>
literal|2048
operator|)
operator|||
operator|(
operator|(
name|V
argument_list|(
literal|2
argument_list|)
operator|+
name|VPos
operator|)
operator|>
literal|2640
operator|)
condition|)
block|{
name|big
operator|++
expr_stmt|;
return|return;
block|}
name|x_bit_pos
operator|=
operator|(
name|HPos
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|y_bit_pos
operator|=
operator|(
name|VPos
operator|+
name|V
argument_list|(
literal|3
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|x_bit_pos
operator|<
literal|0
operator|)
operator|||
operator|(
name|y_bit_pos
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|little
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|XWIND
name|base
operator|=
name|pscreen
else|#
directive|else
name|base
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
operator|)
endif|#
directive|endif
operator|+
operator|(
name|y_bit_pos
operator|*
name|wide
operator|)
operator|+
operator|(
name|x_bit_pos
operator|>>
literal|3
operator|)
expr_stmt|;
name|skew
operator|=
literal|8
operator|-
operator|(
name|x_bit_pos
operator|&
literal|07
operator|)
expr_stmt|;
name|V
argument_list|(
literal|1
argument_list|)
operator|=
operator|(
name|V
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|V
argument_list|(
literal|2
argument_list|)
operator|=
operator|(
name|V
argument_list|(
literal|2
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|V
argument_list|(
literal|2
argument_list|)
init|;
name|i
operator|--
condition|;
name|base
operator|+=
name|wide
control|)
block|{
name|sp
operator|=
name|base
expr_stmt|;
for|for
control|(
name|bit_width
operator|=
name|V
argument_list|(
literal|1
argument_list|)
init|;
name|bit_width
operator|>
literal|0
condition|;
control|)
block|{
name|bits_l
operator|=
name|l_bits
index|[
name|bit_width
operator|>
literal|7
condition|?
literal|0
else|:
name|bit_width
index|]
expr_stmt|;
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
block|{
operator|*
name|sp
operator|++
operator||=
name|bits_l
expr_stmt|;
name|bit_width
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sp
operator|++
operator||=
operator|(
name|bits_l
operator|>>
operator|(
literal|8
operator|-
name|skew
operator|)
operator|)
operator|&
name|r_mask
index|[
name|skew
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bit_width
operator|-=
name|skew
operator|)
operator|<=
literal|0
condition|)
break|break;
operator|*
name|sp
operator||=
operator|(
name|bits_l
operator|<<
name|skew
operator|)
operator|&
name|l_mask
index|[
name|skew
index|]
expr_stmt|;
name|bit_width
operator|-=
operator|(
literal|8
operator|-
name|skew
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|set_hv_sys
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|norigin
decl_stmt|,
name|naxes
decl_stmt|,
name|norient
decl_stmt|;
comment|/*set a logical page orientation relative to the physical pagenot done*/
name|norigin
operator|=
operator|(
name|v
argument_list|(
literal|1
argument_list|)
operator|>>
literal|5
operator|)
operator|&
literal|03
expr_stmt|;
name|naxes
operator|=
operator|(
name|v
argument_list|(
literal|1
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|03
expr_stmt|;
name|norient
operator|=
name|v
argument_list|(
literal|1
argument_list|)
operator|&
literal|07
expr_stmt|;
if|if
condition|(
name|norient
operator|<
literal|4
condition|)
name|orient
operator|=
operator|(
name|orient
operator|+
name|norient
operator|)
operator|%
literal|4
expr_stmt|;
else|else
name|orient
operator|=
name|norient
operator|-
literal|4
expr_stmt|;
name|set_axes
argument_list|(
name|naxes
argument_list|,
name|norigin
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_axes
argument_list|(
argument|ax
argument_list|,
argument|or
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ax
decl_stmt|,
name|or
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|ax
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|hvangle
operator|=
operator|-
name|hvangle
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|hvangle
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|hvangle
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|set_origin
argument_list|(
name|or
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_origin
argument_list|(
argument|or
argument_list|)
end_macro

begin_decl_stmt
name|int
name|or
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*set the origin of the logical page relative to the physical*/
switch|switch
condition|(
name|or
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|originlv
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|orient
condition|)
block|{
case|case
literal|0
case|:
name|originlh
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|originlh
operator|=
name|MAXx
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|originlh
operator|=
name|MAXy
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
if|if
condition|(
name|orient
operator|==
literal|1
operator|||
name|orient
operator|==
literal|3
condition|)
block|{
name|originlh
operator|=
name|xpos
expr_stmt|;
name|originlv
operator|=
name|ypos
expr_stmt|;
block|}
else|else
block|{
name|originlv
operator|=
name|xpos
expr_stmt|;
name|originlh
operator|=
name|ypos
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_macro
name|draw_path1
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_comment
comment|/* draw line from here to x0, y0, x1, y1 */
end_comment

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|d
decl_stmt|,
name|xd
decl_stmt|,
name|yd
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|incr1
decl_stmt|,
name|incr2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numdots
decl_stmt|;
name|int
name|motincrx
decl_stmt|,
name|motincry
decl_stmt|;
name|xd
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
name|yd
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
name|dx
operator|=
name|abs
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|dy
operator|=
name|abs
argument_list|(
name|yd
argument_list|)
expr_stmt|;
comment|/* sort between vertical, horizontal and in between */
name|put1
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|==
literal|0
condition|)
block|{
name|numdots
operator|=
name|abs
argument_list|(
name|yd
argument_list|)
expr_stmt|;
name|motincry
operator|=
operator|(
name|yd
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|y0
operator|+=
name|motincry
expr_stmt|;
name|put1
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|yd
operator|==
literal|0
condition|)
block|{
name|numdots
operator|=
name|abs
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|motincrx
operator|=
operator|(
name|xd
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|x0
operator|+=
name|motincrx
expr_stmt|;
name|put1
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|abs
argument_list|(
name|xd
argument_list|)
operator|>
name|abs
argument_list|(
name|yd
argument_list|)
condition|)
block|{
comment|/* slope less than 1 */
name|d
operator|=
literal|2
operator|*
name|dy
operator|-
name|dx
expr_stmt|;
name|incr1
operator|=
literal|2
operator|*
name|dy
expr_stmt|;
name|incr2
operator|=
literal|2
operator|*
operator|(
name|dy
operator|-
name|dx
operator|)
expr_stmt|;
name|numdots
operator|=
name|abs
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|motincrx
operator|=
operator|(
name|xd
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|motincry
operator|=
operator|(
name|yd
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|put1
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
name|x0
operator|+=
name|motincrx
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
name|d
operator|+
name|incr1
expr_stmt|;
else|else
block|{
name|y0
operator|+=
name|motincry
expr_stmt|;
name|d
operator|=
name|d
operator|+
name|incr2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* slope more than 1 */
name|d
operator|=
literal|2
operator|*
name|dx
operator|-
name|dy
expr_stmt|;
name|incr1
operator|=
literal|2
operator|*
name|dx
expr_stmt|;
name|incr2
operator|=
literal|2
operator|*
operator|(
name|dx
operator|-
name|dy
operator|)
expr_stmt|;
name|numdots
operator|=
name|abs
argument_list|(
name|yd
argument_list|)
expr_stmt|;
name|motincrx
operator|=
operator|(
name|xd
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|motincry
operator|=
operator|(
name|yd
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|put1
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
name|y0
operator|+=
name|motincry
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
name|d
operator|+
name|incr1
expr_stmt|;
else|else
block|{
name|x0
operator|+=
name|motincrx
expr_stmt|;
name|d
operator|=
name|d
operator|+
name|incr2
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* set the value of a t byte (texture) */
end_comment

begin_macro
name|t_byte
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fam
operator|==
literal|0
operator|&&
name|member
operator|==
literal|0
condition|)
return|return
operator|(
name|r_mask
index|[
literal|9
index|]
operator|)
return|;
comment|/* else find the byte in the glyph mask */
return|return
operator|(
operator|*
operator|(
name|family
index|[
name|fam
index|]
index|[
name|member
index|]
operator|.
name|bits
operator|+
operator|(
operator|(
name|x
operator|&
literal|017
operator|)
operator|>>
literal|3
operator|)
operator|+
literal|2
operator|*
operator|(
name|y
operator|&
literal|017
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* put a pixel onto a page image. */
end_comment

begin_macro
name|put1
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|skew
decl_stmt|;
name|short
name|x_bit_pos
decl_stmt|,
name|y_bit_pos
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pbyte
decl_stmt|,
name|tbyte
decl_stmt|;
ifdef|#
directive|ifdef
name|COLOR
name|unsigned
name|char
name|setcolor
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|COLOR
name|x_bit_pos
operator|=
name|x
expr_stmt|;
name|y_bit_pos
operator|=
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|x_bit_pos
operator|>
name|scr_x
operator|)
operator|||
operator|(
name|y_bit_pos
operator|>
name|scr_y
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"+pix"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|x_bit_pos
operator|<
literal|0
operator|)
operator|||
operator|(
name|y_bit_pos
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
block|{
name|pbyte
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
operator|)
operator|+
operator|(
name|y_bit_pos
operator|*
name|scr_x
operator|)
operator|+
name|x_bit_pos
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
ifdef|#
directive|ifdef
name|XWIND
name|pbyte
operator|=
name|pscreen
else|#
directive|else
name|pbyte
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
operator|)
endif|#
directive|endif
operator|+
operator|(
name|y_bit_pos
operator|*
name|wide
operator|)
operator|+
operator|(
name|x_bit_pos
operator|>>
literal|3
operator|)
expr_stmt|;
block|}
comment|/* skew is bits displacement of pixel from a byte edge*/
name|skew
operator|=
literal|8
operator|-
operator|(
name|x_bit_pos
operator|&
literal|07
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLOR
if|if
condition|(
name|slide
condition|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
operator|*
name|pbyte
operator|=
name|backcolor
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|)
case|:
case|case
operator|(
literal|7
operator|)
case|:
default|default:
operator|*
name|pbyte
operator|=
name|setcolor
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
endif|COLOR
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
comment|/* clear the bit */
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
operator|*
name|pbyte
operator|&=
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
expr_stmt|;
else|else
operator|*
name|pbyte
operator|&=
operator|(
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
operator||
name|l_mask
index|[
name|skew
operator|+
literal|1
index|]
operator|)
expr_stmt|;
return|return;
case|case
operator|(
literal|3
operator|)
case|:
comment|/* opaque with t bit */
name|tbyte
operator|=
name|t_byte
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
operator|*
name|pbyte
operator|&=
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
expr_stmt|;
else|else
operator|*
name|pbyte
operator|&=
operator|(
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
operator||
name|l_mask
index|[
name|skew
operator|+
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
name|tbyte
operator|&=
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|tbyte
operator|&=
operator|(
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
operator||
name|l_mask
index|[
name|skew
operator|+
literal|1
index|]
operator|)
expr_stmt|;
operator|*
name|pbyte
operator|&=
name|tbyte
expr_stmt|;
return|return;
case|case
operator|(
literal|7
operator|)
case|:
comment|/* or with t bit */
name|tbyte
operator|=
name|t_byte
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
name|tbyte
operator|&=
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|tbyte
operator|&=
operator|(
name|r_mask
index|[
name|skew
operator|-
literal|1
index|]
operator||
name|l_mask
index|[
name|skew
operator|+
literal|1
index|]
operator|)
expr_stmt|;
operator|*
name|pbyte
operator||=
name|tbyte
expr_stmt|;
return|return;
default|default:
comment|/* black the bit */
if|if
condition|(
name|skew
operator|==
literal|8
condition|)
operator|*
operator|(
name|pbyte
operator|-
literal|1
operator|)
operator||=
literal|1
expr_stmt|;
else|else
operator|*
name|pbyte
operator||=
literal|1
operator|<<
name|skew
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* put a line onto a page image. */
end_comment

begin_macro
name|putline
argument_list|(
argument|xstart
argument_list|,
argument|xend
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xstart
decl_stmt|,
name|xend
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nbytes
decl_stmt|,
name|xh
decl_stmt|,
name|xs
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
name|pbyte
decl_stmt|,
name|tbyte
decl_stmt|,
modifier|*
name|scptr
decl_stmt|;
comment|/* find how many bytes are affected by the line*/
name|nbytes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xstart
operator|/
literal|8
operator|!=
name|xend
operator|/
literal|8
condition|)
name|nbytes
operator|+=
name|xend
operator|/
literal|8
operator|-
name|xstart
operator|/
literal|8
expr_stmt|;
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
comment|/* clear the bytes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
name|xh
operator|=
name|xstart
operator|/
literal|8
expr_stmt|;
name|xs
operator|=
name|xstart
operator|%
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|XWIND
name|scptr
operator|=
name|pscreen
expr_stmt|;
else|#
directive|else
name|scptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
expr_stmt|;
endif|#
directive|endif
name|pbyte
operator|=
operator|*
name|scptr
operator|+
name|y
operator|*
name|wide
operator|+
name|xh
expr_stmt|;
if|if
condition|(
operator|(
name|xend
operator|+
literal|1
operator|)
operator|/
literal|8
operator|>
name|xh
operator|+
literal|1
condition|)
name|pbyte
operator|&=
name|l_mask
index|[
name|xs
index|]
expr_stmt|;
else|else
name|pbyte
operator|&=
operator|(
name|l_mask
index|[
name|xs
index|]
operator|&
name|r_mask
index|[
operator|(
name|xend
operator|+
literal|1
operator|)
operator|%
literal|8
index|]
operator|)
expr_stmt|;
operator|*
operator|(
name|scptr
operator|+
name|y
operator|*
name|wide
operator|+
name|xh
operator|)
operator|=
name|pbyte
expr_stmt|;
name|xstart
operator|=
name|xstart
operator|+
literal|8
operator|-
name|xs
expr_stmt|;
block|}
return|return;
case|case
operator|(
literal|15
operator|)
case|:
comment|/* black the bit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
name|xh
operator|=
name|xstart
operator|/
literal|8
expr_stmt|;
name|xs
operator|=
name|xstart
operator|%
literal|8
expr_stmt|;
name|pbyte
operator|=
operator|*
name|scptr
operator|+
name|y
operator|*
name|wide
operator|+
name|xh
expr_stmt|;
if|if
condition|(
operator|(
name|xend
operator|+
literal|1
operator|)
operator|/
literal|8
operator|>
name|xh
operator|+
literal|1
condition|)
name|pbyte
operator|&=
name|r_mask
index|[
literal|8
operator|-
name|xs
index|]
expr_stmt|;
else|else
name|pbyte
operator|&=
operator|(
name|r_mask
index|[
literal|8
operator|-
name|xs
index|]
operator|&
name|l_mask
index|[
literal|8
operator|-
operator|(
name|xend
operator|+
literal|1
operator|)
operator|%
literal|8
index|]
operator|)
expr_stmt|;
operator|*
operator|(
name|scptr
operator|+
name|y
operator|*
name|wide
operator|+
name|xh
operator|)
operator|=
name|pbyte
expr_stmt|;
name|xstart
operator|=
name|xstart
operator|+
literal|8
operator|-
name|xs
expr_stmt|;
block|}
return|return;
case|case
operator|(
literal|3
operator|)
case|:
comment|/* opaque with t bit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
name|xh
operator|=
name|xstart
operator|>>
literal|3
expr_stmt|;
name|xs
operator|=
name|xstart
operator|&
literal|07
expr_stmt|;
name|pbyte
operator|=
operator|*
name|scptr
operator|+
name|wide
operator|*
name|y
operator|+
name|xh
expr_stmt|;
if|if
condition|(
operator|(
name|xend
operator|+
literal|1
operator|)
operator|/
literal|8
operator|>
name|xh
operator|+
literal|1
condition|)
name|pbyte
operator|&=
name|l_mask
index|[
name|xs
index|]
operator|&
name|t_byte
argument_list|(
name|xstart
argument_list|,
operator|(
name|xstart
operator|+
literal|8
operator|-
name|xs
operator|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|pbyte
operator|&=
operator|(
name|l_mask
index|[
name|xs
index|]
operator|&
name|r_mask
index|[
operator|(
name|xend
operator|+
literal|1
operator|)
operator|%
literal|8
index|]
operator|)
operator|&
name|t_byte
argument_list|(
name|xstart
argument_list|,
name|xend
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
operator|(
name|scptr
operator|+
name|y
operator|*
name|wide
operator|+
name|xh
operator|)
operator|=
name|pbyte
expr_stmt|;
name|xstart
operator|=
name|xstart
operator|+
literal|8
operator|-
name|xs
expr_stmt|;
block|}
return|return;
case|case
operator|(
literal|7
operator|)
case|:
comment|/* or with t bit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
name|xh
operator|=
name|xstart
operator|/
literal|8
expr_stmt|;
name|xs
operator|=
name|xstart
operator|%
literal|8
expr_stmt|;
name|pbyte
operator|=
operator|*
name|scptr
operator|+
name|wide
operator|*
name|y
operator|+
name|xh
expr_stmt|;
if|if
condition|(
operator|(
name|xend
operator|+
literal|1
operator|)
operator|/
literal|8
operator|>
name|xh
operator|+
literal|1
condition|)
name|pbyte
operator||=
name|t_byte
argument_list|(
name|xstart
argument_list|,
operator|(
name|xstart
operator|+
literal|8
operator|-
name|xs
operator|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|pbyte
operator||=
name|t_byte
argument_list|(
name|xstart
argument_list|,
name|xend
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
operator|(
name|scptr
operator|+
name|y
operator|*
name|wide
operator|+
name|xh
operator|)
operator|=
name|pbyte
expr_stmt|;
name|xstart
operator|=
name|xstart
operator|+
literal|8
operator|-
name|xs
expr_stmt|;
block|}
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|Prnt_Bitmap
argument_list|(
argument|hsize
argument_list|,
argument|vsize
argument_list|)
end_macro

begin_decl_stmt
name|short
name|int
name|hsize
decl_stmt|,
name|vsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|char
name|mw
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|basev
decl_stmt|,
modifier|*
name|baseb
decl_stmt|;
name|short
name|x_bit_pos
decl_stmt|,
name|y_bit_pos
decl_stmt|;
comment|/* 		 * get the bits and put them ??? 		 */
name|x_bit_pos
operator|=
operator|(
name|HPos
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|y_bit_pos
operator|=
operator|(
name|VPos
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|HPos
operator|+
name|hsize
operator|*
literal|4
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|>
name|scr_x
operator|)
operator|||
operator|(
operator|(
operator|(
name|VPos
operator|+
name|vsize
operator|*
literal|32
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|>
name|scr_y
operator|)
condition|)
block|{
name|big
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|x_bit_pos
operator|<
literal|0
operator|)
operator|||
operator|(
name|y_bit_pos
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|little
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|XWIND
name|base
operator|=
name|pscreen
else|#
directive|else
name|base
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|mpr_d
argument_list|(
name|pscreen
argument_list|)
operator|->
name|md_image
operator|)
operator|)
endif|#
directive|endif
operator|+
operator|(
name|y_bit_pos
operator|*
name|wide
operator|)
operator|+
operator|(
name|x_bit_pos
operator|>>
literal|3
operator|)
expr_stmt|;
name|basev
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|magnification
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* rows of cols of 32*32 blocks */
name|baseb
operator|=
name|basev
expr_stmt|;
comment|/* cols of 32*32 blocks */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|hsize
condition|;
name|j
operator|++
control|)
block|{
name|sp
operator|=
name|baseb
expr_stmt|;
comment|/* block of 32*32 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|32
condition|;
name|k
operator|++
control|)
block|{
comment|/* row of 32 bits in 32*32 block*/
comment|/* point at the bytes of glyph storage*/
comment|/* for two bytes at a time */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
literal|2
condition|;
name|l
operator|++
operator|,
name|sp
operator|++
control|)
block|{
comment|/* squeez the first byte 4 left */
name|mw
operator|=
name|map8_4
index|[
name|gc
argument_list|()
index|]
operator|<<
literal|4
expr_stmt|;
name|mw
operator||=
name|map8_4
index|[
name|gc
argument_list|()
index|]
expr_stmt|;
comment|/* or store byte if k odd */
if|if
condition|(
name|k
operator|&
literal|1
condition|)
operator|*
name|sp
operator||=
name|mw
expr_stmt|;
comment|/* store byte if even */
else|else
operator|*
name|sp
operator|=
name|mw
expr_stmt|;
block|}
name|sp
operator|=
name|baseb
operator|+
name|wide
operator|*
operator|(
operator|(
literal|1
operator|+
name|k
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* add 1 line to v pos if odd*/
block|}
name|baseb
operator|=
name|basev
operator|+
literal|2
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* add 16 bits to h pos */
block|}
name|basev
operator|=
name|base
operator|+
name|wide
operator|*
literal|16
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* squeeze to 1/2 height*/
block|}
elseif|else
if|if
condition|(
name|magnification
operator|==
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
name|baseb
operator|=
name|basev
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|hsize
condition|;
name|j
operator|++
control|)
block|{
name|sp
operator|=
name|baseb
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|32
condition|;
name|k
operator|++
control|)
block|{
comment|/* point at the bytes of glyph storage*/
for|for
control|(
name|l
operator|=
literal|4
init|;
name|l
condition|;
name|l
operator|--
control|)
operator|*
name|sp
operator|++
operator|=
name|gc
argument_list|()
expr_stmt|;
name|sp
operator|+=
literal|124
expr_stmt|;
block|}
name|baseb
operator|+=
literal|4
expr_stmt|;
block|}
name|basev
operator|=
name|base
operator|+
name|wide
operator|*
literal|32
operator|*
name|i
expr_stmt|;
block|}
block|}
end_block

end_unit

