begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright 1985, Massachusetts Institute of Technology */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_bitmap_c
init|=
literal|"$Header: bitmap.c,v 10.9 86/11/19 19:13:23 jg Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"../cursors/cross.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/cross_mask.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/ul_angle.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/ul_angle_mask.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/lr_angle.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/lr_angle_mask.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/dot.cursor"
end_include

begin_include
include|#
directive|include
file|"../cursors/dot_mask.cursor"
end_include

begin_define
define|#
directive|define
name|TOP_MARGIN
value|10
end_define

begin_define
define|#
directive|define
name|LEFT_MARGIN
value|10
end_define

begin_define
define|#
directive|define
name|BOTTOM_MARGIN
value|10
end_define

begin_define
define|#
directive|define
name|AROUND_RASTER_MARGIN
value|20
end_define

begin_define
define|#
directive|define
name|GRID_TO_COMMAND_MARGIN
value|5
end_define

begin_define
define|#
directive|define
name|RIGHT_MARGIN
value|5
end_define

begin_define
define|#
directive|define
name|MIN_SQUARE_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|DEFAULT_SQUARE_SIZE
value|13
end_define

begin_define
define|#
directive|define
name|bit
value|int
end_define

begin_define
define|#
directive|define
name|boolean
value|int
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|OUT_OF_RANGE
value|10000
end_define

begin_define
define|#
directive|define
name|COPY
value|0
end_define

begin_define
define|#
directive|define
name|MOVE
value|1
end_define

begin_define
define|#
directive|define
name|OVERLAY
value|2
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x< y) ? x : y)
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x< y) ? y : x)
end_define

begin_comment
comment|/* error handling stuff */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global "constants" -- set once at startup time */
end_comment

begin_comment
comment|/* the first few variables are not static because they are shared    with dialog.c */
end_comment

begin_decl_stmt
name|int
name|foreground
init|=
name|BlackPixel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|background
init|=
name|WhitePixel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Pixmap
name|backmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Pixmap
name|border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|borderwidth
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|invertplane
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|highlightplane
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mousepix
init|=
name|BlackPixel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|squares_wide
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|squares_high
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|raster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|raster_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many shorts in the raster[] array */
end_comment

begin_decl_stmt
specifier|static
name|Window
name|outer_window
decl_stmt|,
name|grid_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Window
name|raster_window
decl_stmt|,
name|raster_invert_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Font
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FontInfo
name|fontInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cursor
name|cross
decl_stmt|,
name|upper_left
decl_stmt|,
name|lower_right
decl_stmt|,
name|dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of input file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backup_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stripped_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name without directory path or extension */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name this program was invoked by */
end_comment

begin_decl_stmt
specifier|static
name|Pattern
name|DottedPattern
init|=
name|XMakePattern
argument_list|(
literal|1
comment|/* pattern */
argument_list|,
literal|2
comment|/* length */
argument_list|,
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* multiplier */
end_comment

begin_decl_stmt
specifier|static
name|Pattern
name|InverseDottedPattern
init|=
name|XMakePattern
argument_list|(
literal|2
comment|/* pattern */
argument_list|,
literal|2
comment|/* length */
argument_list|,
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* multiplier */
end_comment

begin_comment
comment|/* command-button data */
end_comment

begin_define
define|#
directive|define
name|N_COMMANDS
value|16
end_define

begin_struct
specifier|static
struct|struct
name|command_data
block|{
name|Window
name|window
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|name_length
decl_stmt|;
name|int
name|x_offset
decl_stmt|;
comment|/* so text is centered within command box */
name|boolean
name|inverted
decl_stmt|;
name|int
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
comment|/* function to invoke when command button is "pressed" */
comment|/* actually no return value, but compiler doesn't like "void" here */
name|int
name|data
decl_stmt|;
comment|/* arbitrary instance data to call procedure back with */
block|}
name|commands
index|[
name|N_COMMANDS
index|]
struct|;
end_struct

begin_comment
comment|/* global variables */
end_comment

begin_comment
comment|/* layout-related variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|square_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of square's side, in pixels */
end_comment

begin_decl_stmt
specifier|static
name|OpaqueFrame
name|frames
index|[
name|N_COMMANDS
operator|+
literal|3
index|]
decl_stmt|,
name|outer_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frames[0] throgh frames[N_COMMANDS-1] are the command windows;         frames[N_COMMANDS] is the raster;     	frames[N_COMMANDS+1] is the inverted raster; 	frames[N_COMMANDS+2] is the grid */
end_comment

begin_comment
comment|/* location of x'd-through squares, if any */
end_comment

begin_decl_stmt
specifier|static
name|int
name|x1_square_exed_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|y1_square_exed_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|x2_square_exed_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|y2_square_exed_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* location of "plus'd through" squares, if any */
end_comment

begin_decl_stmt
specifier|static
name|int
name|x1_square_plus_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|y1_square_plus_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|x2_square_plus_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|y2_square_plus_through
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* location of hot spot, if any */
end_comment

begin_decl_stmt
specifier|static
name|int
name|x_hot_spot
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|y_hot_spot
init|=
name|OUT_OF_RANGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|changed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has user changed bitmap since starting program or last write? */
end_comment

begin_enum
specifier|static
enum|enum
name|RepaintGridType
block|{
name|e_AgainstBackground
block|,
name|e_AgainstForeground
block|,
name|e_Invert
block|}
enum|;
end_enum

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|SetUp
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|XEvent
name|event
decl_stmt|;
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of main procedure */
end_comment

begin_macro
name|SetUp
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|StripName
argument_list|()
decl_stmt|,
modifier|*
name|BackupName
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|geometry
init|=
name|NULL
decl_stmt|,
modifier|*
name|host
init|=
name|NULL
decl_stmt|,
modifier|*
name|dimensions
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Parse command line */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
name|geometry
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|index
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
name|host
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|dimensions
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no file name specified\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|stripped_name
operator|=
name|StripName
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|backup_filename
operator|=
name|BackupName
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|&&
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: could not open file '%s' for reading -- %s\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
name|DimensionsFromFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dimensions
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|dimensions
argument_list|,
literal|"%dx%d"
argument_list|,
operator|&
name|squares_wide
argument_list|,
operator|&
name|squares_high
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid dimensions '%s'\n"
argument_list|,
name|progname
argument_list|,
name|dimensions
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|squares_wide
operator|<=
literal|0
operator|)
operator|||
operator|(
name|squares_high
operator|<=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dimensions must be positive\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* dimensions not supplied on command line */
name|squares_wide
operator|=
name|squares_high
operator|=
literal|16
expr_stmt|;
block|}
name|raster_length
operator|=
operator|(
operator|(
name|squares_wide
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
operator|*
name|squares_high
expr_stmt|;
name|raster
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
name|raster_length
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|InitialValuesFromFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set raster to all 0's (background color) */
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raster_length
condition|;
name|i
operator|++
control|)
name|raster
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|XOpenDisplay
argument_list|(
name|host
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open display '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|XDisplayName
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|backmap
operator|=
name|WhitePixmap
expr_stmt|;
name|border
operator|=
name|BlackPixmap
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"BorderWidth"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|borderwidth
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"BodyFont"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|option
operator|=
literal|"vtsingle"
expr_stmt|;
name|font
operator|=
name|XGetFont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|XQueryFont
argument_list|(
name|font
argument_list|,
operator|&
name|fontInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|DisplayCells
argument_list|()
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|fore_color
init|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Foreground"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|back_color
init|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Background"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|high_color
init|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Highlight"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|brdr_color
init|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Border"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|mous_color
init|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Mouse"
argument_list|)
decl_stmt|;
name|Color
name|fdef
decl_stmt|,
name|bdef
decl_stmt|,
name|hdef
decl_stmt|;
if|if
condition|(
name|fore_color
operator|&&
name|XParseColor
argument_list|(
name|fore_color
argument_list|,
operator|&
name|fdef
argument_list|)
operator|&&
name|back_color
operator|&&
name|XParseColor
argument_list|(
name|back_color
argument_list|,
operator|&
name|bdef
argument_list|)
operator|&&
operator|(
name|high_color
operator|==
name|NULL
operator|||
name|XParseColor
argument_list|(
name|high_color
argument_list|,
operator|&
name|hdef
argument_list|)
operator|)
operator|&&
name|XGetColorCells
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|high_color
condition|?
literal|2
else|:
literal|1
argument_list|,
operator|&
name|invertplane
argument_list|,
operator|&
name|bdef
operator|.
name|pixel
argument_list|)
condition|)
block|{
name|background
operator|=
name|bdef
operator|.
name|pixel
expr_stmt|;
name|backmap
operator|=
name|XMakeTile
argument_list|(
name|background
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_color
condition|)
block|{
name|hdef
operator|.
name|pixel
operator|=
name|bdef
operator|.
name|pixel
operator||
name|invertplane
expr_stmt|;
name|XStoreColor
argument_list|(
operator|&
name|hdef
argument_list|)
expr_stmt|;
name|highlightplane
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|invertplane
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|hdef
operator|.
name|pixel
operator|=
name|bdef
operator|.
name|pixel
operator||
name|highlightplane
expr_stmt|;
name|XStoreColor
argument_list|(
operator|&
name|hdef
argument_list|)
expr_stmt|;
name|invertplane
operator|^=
name|highlightplane
expr_stmt|;
block|}
else|else
name|highlightplane
operator|=
name|invertplane
expr_stmt|;
name|XStoreColor
argument_list|(
operator|&
name|bdef
argument_list|)
expr_stmt|;
name|foreground
operator|=
name|background
operator||
name|invertplane
expr_stmt|;
name|fdef
operator|.
name|pixel
operator|=
name|foreground
expr_stmt|;
name|XStoreColor
argument_list|(
operator|&
name|fdef
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|brdr_color
operator|&&
name|XParseColor
argument_list|(
name|brdr_color
argument_list|,
operator|&
name|bdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|bdef
argument_list|)
condition|)
name|border
operator|=
name|XMakeTile
argument_list|(
name|bdef
operator|.
name|pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|mous_color
operator|&&
name|XParseColor
argument_list|(
name|mous_color
argument_list|,
operator|&
name|fdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|fdef
argument_list|)
condition|)
name|mousepix
operator|=
name|fdef
operator|.
name|pixel
expr_stmt|;
block|}
block|{
name|int
name|right_side_bottom
decl_stmt|,
name|right_side_width
decl_stmt|;
name|int
name|minwidth
decl_stmt|,
name|minheight
decl_stmt|;
name|int
name|default_width
decl_stmt|,
name|default_height
decl_stmt|,
name|default_x
decl_stmt|,
name|default_y
decl_stmt|;
name|int
name|display_width
init|=
name|DisplayWidth
argument_list|()
decl_stmt|;
name|int
name|display_height
init|=
name|DisplayHeight
argument_list|()
decl_stmt|;
name|char
name|default_geometry
index|[
literal|20
index|]
decl_stmt|;
name|LayoutStage1
argument_list|()
expr_stmt|;
name|right_side_bottom
operator|=
name|frames
index|[
name|N_COMMANDS
operator|+
literal|1
index|]
operator|.
name|y
operator|+
name|frames
index|[
name|N_COMMANDS
operator|+
literal|1
index|]
operator|.
name|height
operator|+
literal|2
comment|/* borders */
operator|+
name|AROUND_RASTER_MARGIN
expr_stmt|;
name|right_side_width
operator|=
name|frames
index|[
literal|0
index|]
operator|.
name|width
operator|+
literal|2
comment|/* borders */
operator|+
name|GRID_TO_COMMAND_MARGIN
operator|+
name|RIGHT_MARGIN
expr_stmt|;
name|OuterWindowDims
argument_list|(
name|MIN_SQUARE_SIZE
argument_list|,
name|right_side_width
argument_list|,
name|right_side_bottom
argument_list|,
operator|&
name|minwidth
argument_list|,
operator|&
name|minheight
argument_list|)
expr_stmt|;
name|OuterWindowDims
argument_list|(
name|DEFAULT_SQUARE_SIZE
argument_list|,
name|right_side_width
argument_list|,
name|right_side_bottom
argument_list|,
operator|&
name|default_width
argument_list|,
operator|&
name|default_height
argument_list|)
expr_stmt|;
name|default_x
operator|=
name|min
argument_list|(
literal|200
argument_list|,
name|display_width
operator|-
name|default_width
operator|-
literal|2
operator|*
name|borderwidth
argument_list|)
expr_stmt|;
name|default_y
operator|=
name|min
argument_list|(
literal|200
argument_list|,
name|display_height
operator|-
name|default_height
operator|-
literal|2
operator|*
name|borderwidth
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|default_geometry
argument_list|,
literal|"=%dx%d+%d+%d"
argument_list|,
name|default_width
argument_list|,
name|default_height
argument_list|,
name|default_x
argument_list|,
name|default_y
argument_list|)
expr_stmt|;
name|outer_frame
operator|.
name|bdrwidth
operator|=
name|borderwidth
expr_stmt|;
name|outer_frame
operator|.
name|border
operator|=
name|border
expr_stmt|;
name|outer_frame
operator|.
name|background
operator|=
name|backmap
expr_stmt|;
name|outer_window
operator|=
name|XCreate
argument_list|(
literal|"Bitmap Editor"
argument_list|,
name|progname
argument_list|,
name|geometry
argument_list|,
name|default_geometry
argument_list|,
operator|&
name|outer_frame
argument_list|,
name|minwidth
argument_list|,
name|minheight
argument_list|)
expr_stmt|;
name|LayoutStage2
argument_list|()
expr_stmt|;
block|}
name|upper_left
operator|=
name|XCreateCursor
argument_list|(
name|ul_angle_width
argument_list|,
name|ul_angle_height
argument_list|,
name|ul_angle_bits
argument_list|,
name|ul_angle_mask_bits
argument_list|,
name|ul_angle_x_hot
argument_list|,
name|ul_angle_y_hot
argument_list|,
name|mousepix
argument_list|,
name|background
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|lower_right
operator|=
name|XCreateCursor
argument_list|(
name|lr_angle_width
argument_list|,
name|lr_angle_height
argument_list|,
name|lr_angle_bits
argument_list|,
name|lr_angle_mask_bits
argument_list|,
name|lr_angle_x_hot
argument_list|,
name|lr_angle_y_hot
argument_list|,
name|mousepix
argument_list|,
name|background
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|cross
operator|=
name|XCreateCursor
argument_list|(
name|cross_width
argument_list|,
name|cross_height
argument_list|,
name|cross_bits
argument_list|,
name|cross_mask_bits
argument_list|,
name|cross_x_hot
argument_list|,
name|cross_y_hot
argument_list|,
name|mousepix
argument_list|,
name|background
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|dot
operator|=
name|XCreateCursor
argument_list|(
name|dot_width
argument_list|,
name|dot_height
argument_list|,
name|dot_bits
argument_list|,
name|dot_mask_bits
argument_list|,
name|dot_x_hot
argument_list|,
name|dot_y_hot
argument_list|,
name|mousepix
argument_list|,
name|background
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|cross
argument_list|)
expr_stmt|;
name|XExpandEvents
argument_list|()
expr_stmt|;
comment|/* do NOT collapse adjacent MouseMotion events */
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
comment|/* to detect size changes */
name|XMapWindow
argument_list|(
name|outer_window
argument_list|)
expr_stmt|;
name|XMapSubwindows
argument_list|(
name|outer_window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of Set_Up procedure */
end_comment

begin_comment
comment|/* Unfortunately, the current implementation of X (version 10) does not    handle resize event notification very well.  When the outer window    is resized, X sends ExposeWindow events for each subwindow BEFORE sending    an ExposeWindow for the outer window.     If I handled the events in the order sent, I would repaint each    subwindow, only then to discover that the outer window had changed    size...at which time I would unmap and rearrange the subwindows,    causing ANOTHER set of exposure events on the subwindows.  This would    not just be inefficient, it would also look ugly on the screen.     To work around this misfeature, I do not process ExposeWindow events    immediately upon receipt, but instead go into a recursion (HandleExposure)    until I either run out of events or get a non-ExposeWindow event.  If    the list of ExposeWindow events ends with a resize, I discard all of the    earlier ExposeWindow events.  Otherwise, I unwind out of the recursion,    processing each exposure event in the opposite of the order received,    eventually returning to the normal event notification loop.     This code is admittedly convoluted, and will hopefully go away in a    future version of X.  */
end_comment

begin_define
define|#
directive|define
name|PROCESS_IT
value|0
end_define

begin_define
define|#
directive|define
name|DISCARD_IT
value|1
end_define

begin_expr_stmt
name|ProcessEvent
argument_list|(
name|event
argument_list|)
specifier|register
name|XEvent
operator|*
name|event
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Window
name|w
init|=
name|event
operator|->
name|window
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|ExposeWindow
condition|)
block|{
name|int
name|status
decl_stmt|;
comment|/* make sure that I get all the exposure events that have been sent */
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|HandleExposure
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|DISCARD_IT
condition|)
return|return;
block|}
name|ProcessEventReally
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ProcessEventReally
argument_list|(
name|event
argument_list|)
specifier|register
name|XEvent
operator|*
name|event
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Window
name|w
init|=
name|event
operator|->
name|window
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|w
operator|==
name|grid_window
condition|)
name|ProcessGridWindowEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|==
name|outer_window
condition|)
name|ProcessOuterWindowEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|==
name|raster_window
condition|)
name|RepaintRaster
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|==
name|raster_invert_window
condition|)
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMMANDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|w
operator|==
name|commands
index|[
name|i
index|]
operator|.
name|window
condition|)
name|ProcessCommandButtonEvent
argument_list|(
operator|&
name|commands
index|[
name|i
index|]
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of ProcessInput procedure */
end_comment

begin_function
name|int
name|HandleExposure
parameter_list|(
name|event
parameter_list|)
name|XExposeWindowEvent
modifier|*
name|event
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|XEvent
name|next_event
decl_stmt|;
if|if
condition|(
name|QLength
argument_list|()
operator|==
literal|0
condition|)
comment|/* there are no more events, so this can't be a resize */
return|return
operator|(
name|PROCESS_IT
operator|)
return|;
name|XNextEvent
argument_list|(
operator|&
name|next_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_event
operator|.
name|type
operator|!=
name|ExposeWindow
condition|)
block|{
comment|/* the list of exposures ended, so this can't be a resize */
name|XPutBackEvent
argument_list|(
operator|&
name|next_event
argument_list|)
expr_stmt|;
return|return
operator|(
name|PROCESS_IT
operator|)
return|;
block|}
if|if
condition|(
name|next_event
operator|.
name|window
operator|==
name|outer_window
condition|)
block|{
if|if
condition|(
operator|(
name|outer_frame
operator|.
name|height
operator|==
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
operator|&
name|next_event
operator|)
operator|->
name|height
operator|)
operator|&&
operator|(
name|outer_frame
operator|.
name|width
operator|==
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
operator|&
name|next_event
operator|)
operator|->
name|width
operator|)
condition|)
comment|/* the list of exposures ended with a non-resize */
name|status
operator|=
name|PROCESS_IT
expr_stmt|;
else|else
comment|/* this IS a resize */
name|status
operator|=
name|DISCARD_IT
expr_stmt|;
comment|/* Handle the outer window exposure, whether or not it's a resize */
name|ProcessEventReally
argument_list|(
operator|&
name|next_event
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|HandleExposure
argument_list|(
operator|&
name|next_event
argument_list|)
operator|)
operator|==
name|PROCESS_IT
condition|)
name|ProcessEventReally
argument_list|(
operator|&
name|next_event
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_macro
name|ProcessGridWindowEvent
argument_list|(
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|XEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x_square
decl_stmt|,
name|y_square
decl_stmt|;
specifier|static
name|int
name|x_square_prev
decl_stmt|,
name|y_square_prev
decl_stmt|;
specifier|static
name|boolean
name|raster_outdated
decl_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
name|RepaintGridLines
argument_list|(
name|e_AgainstBackground
argument_list|)
expr_stmt|;
name|RefillGrid
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1_square_exed_through
operator|!=
name|OUT_OF_RANGE
condition|)
name|ExThroughRectangle
argument_list|(
name|x1_square_exed_through
argument_list|,
name|y1_square_exed_through
argument_list|,
name|x2_square_exed_through
argument_list|,
name|y2_square_exed_through
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1_square_plus_through
operator|!=
name|OUT_OF_RANGE
condition|)
name|PlusThroughRectangle
argument_list|(
name|x1_square_plus_through
argument_list|,
name|y1_square_plus_through
argument_list|,
name|x2_square_plus_through
argument_list|,
name|y2_square_plus_through
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
break|break;
case|case
name|ExposeRegion
case|:
block|{
define|#
directive|define
name|this_event
value|((XExposeRegionEvent *)event)
name|int
name|x1
init|=
name|this_event
operator|->
name|x
decl_stmt|;
name|int
name|y1
init|=
name|this_event
operator|->
name|y
decl_stmt|;
name|int
name|x2
init|=
name|x1
operator|+
name|this_event
operator|->
name|width
decl_stmt|;
name|int
name|y2
init|=
name|y1
operator|+
name|this_event
operator|->
name|height
decl_stmt|;
undef|#
directive|undef
name|this_event
name|x1
operator|/=
name|square_size
expr_stmt|;
name|x2
operator|/=
name|square_size
expr_stmt|;
name|y1
operator|/=
name|square_size
expr_stmt|;
name|y2
operator|/=
name|square_size
expr_stmt|;
if|if
condition|(
name|x2
operator|>=
name|squares_wide
condition|)
name|x2
operator|=
name|squares_wide
operator|-
literal|1
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|y2
operator|>=
name|squares_high
condition|)
name|y2
operator|=
name|squares_high
operator|-
literal|1
expr_stmt|;
comment|/* sanity check */
name|RepaintGridLinesPartially
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|+
literal|1
argument_list|,
name|y2
operator|+
literal|1
argument_list|,
name|e_AgainstBackground
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|RefillGridPartially
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1_square_exed_through
operator|!=
name|OUT_OF_RANGE
condition|)
name|ExThroughRectangle
argument_list|(
name|max
argument_list|(
name|x1
argument_list|,
name|x1_square_exed_through
argument_list|)
argument_list|,
name|max
argument_list|(
name|y1
argument_list|,
name|y1_square_exed_through
argument_list|)
argument_list|,
name|min
argument_list|(
name|x2
argument_list|,
name|x2_square_exed_through
argument_list|)
argument_list|,
name|min
argument_list|(
name|y2
argument_list|,
name|y2_square_exed_through
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1_square_plus_through
operator|!=
name|OUT_OF_RANGE
condition|)
name|PlusThroughRectangle
argument_list|(
name|max
argument_list|(
name|x1
argument_list|,
name|x1_square_plus_through
argument_list|)
argument_list|,
name|max
argument_list|(
name|y1
argument_list|,
name|y1_square_plus_through
argument_list|)
argument_list|,
name|min
argument_list|(
name|x2
argument_list|,
name|x2_square_plus_through
argument_list|)
argument_list|,
name|min
argument_list|(
name|y2
argument_list|,
name|y2_square_plus_through
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_hot_spot
operator|>=
name|x1
operator|&&
name|x_hot_spot
operator|<=
name|x2
operator|&&
name|y_hot_spot
operator|>=
name|y1
operator|&&
name|y_hot_spot
operator|<=
name|y2
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|ButtonPressed
case|:
if|if
condition|(
name|WhatSquare
argument_list|(
name|event
argument_list|,
operator|&
name|x_square
argument_list|,
operator|&
name|y_square
argument_list|)
condition|)
return|return;
comment|/* mouse outside grid; really shouldn't happen, but... */
switch|switch
condition|(
operator|(
operator|(
name|XButtonPressedEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|detail
operator|&
name|ValueMask
condition|)
block|{
case|case
name|LeftButton
case|:
name|PaintSquare
argument_list|(
name|x_square
argument_list|,
name|y_square
argument_list|,
name|foreground
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_square
operator|==
name|x_hot_spot
operator|&&
name|y_square
operator|==
name|y_hot_spot
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|SetRasterBit
argument_list|(
name|raster
argument_list|,
name|x_square
argument_list|,
name|y_square
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MiddleButton
case|:
name|InvertSquare
argument_list|(
name|x_square
argument_list|,
name|y_square
argument_list|)
expr_stmt|;
name|InvertRasterBit
argument_list|(
name|raster
argument_list|,
name|x_square
argument_list|,
name|y_square
argument_list|)
expr_stmt|;
break|break;
case|case
name|RightButton
case|:
name|PaintSquare
argument_list|(
name|x_square
argument_list|,
name|y_square
argument_list|,
name|background
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_square
operator|==
name|x_hot_spot
operator|&&
name|y_square
operator|==
name|y_hot_spot
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|SetRasterBit
argument_list|(
name|raster
argument_list|,
name|x_square
argument_list|,
name|y_square
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
name|x_square_prev
operator|=
name|x_square
expr_stmt|;
name|y_square_prev
operator|=
name|y_square
expr_stmt|;
name|raster_outdated
operator|=
name|FALSE
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|MouseMoved
case|:
if|if
condition|(
name|WhatSquare
argument_list|(
name|event
argument_list|,
operator|&
name|x_square
argument_list|,
operator|&
name|y_square
argument_list|)
condition|)
return|return;
comment|/* mouse outside grid; really shouldn't happen, but... */
if|if
condition|(
operator|(
name|x_square
operator|!=
name|x_square_prev
operator|)
operator|||
operator|(
name|y_square
operator|!=
name|y_square_prev
operator|)
condition|)
switch|switch
condition|(
operator|(
operator|(
name|XMouseMovedEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|detail
condition|)
block|{
case|case
name|LeftMask
case|:
name|PaintSquare
argument_list|(
name|x_square
argument_list|,
name|y_square
argument_list|,
name|foreground
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_square
operator|==
name|x_hot_spot
operator|&&
name|y_square
operator|==
name|y_hot_spot
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|SetRasterBit
argument_list|(
name|raster
argument_list|,
name|x_square
argument_list|,
name|y_square
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|changed
operator|=
name|raster_outdated
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|MiddleMask
case|:
name|InvertSquare
argument_list|(
name|x_square
argument_list|,
name|y_square
argument_list|)
expr_stmt|;
name|InvertRasterBit
argument_list|(
name|raster
argument_list|,
name|x_square
argument_list|,
name|y_square
argument_list|)
expr_stmt|;
name|changed
operator|=
name|raster_outdated
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|RightMask
case|:
name|PaintSquare
argument_list|(
name|x_square
argument_list|,
name|y_square
argument_list|,
name|background
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_square
operator|==
name|x_hot_spot
operator|&&
name|y_square
operator|==
name|y_hot_spot
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|SetRasterBit
argument_list|(
name|raster
argument_list|,
name|x_square
argument_list|,
name|y_square
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|changed
operator|=
name|raster_outdated
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* ignore events with multiple buttons down */
block|}
if|if
condition|(
name|raster_outdated
operator|&&
operator|!
name|MouseMovedEventQueued
argument_list|()
condition|)
block|{
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
name|raster_outdated
operator|=
name|FALSE
expr_stmt|;
block|}
name|x_square_prev
operator|=
name|x_square
expr_stmt|;
name|y_square_prev
operator|=
name|y_square
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/* end of ProcessGridWindowEvent procedure */
end_comment

begin_function
name|boolean
name|MouseMovedEventQueued
parameter_list|()
block|{
name|XEvent
name|event
decl_stmt|;
if|if
condition|(
name|XPending
argument_list|()
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|XPeekEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
name|event
operator|.
name|type
operator|==
name|MouseMoved
operator|)
return|;
block|}
end_function

begin_macro
name|ProcessOuterWindowEvent
argument_list|(
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|XEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|event
operator|->
name|type
operator|!=
name|ExposeWindow
condition|)
return|return;
if|if
condition|(
operator|(
name|outer_frame
operator|.
name|height
operator|==
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|height
operator|)
operator|&&
operator|(
name|outer_frame
operator|.
name|width
operator|==
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|width
operator|)
condition|)
comment|/* if this isn't a resize, there's nothing to do here. */
return|return;
comment|/* the outer window's size has changed.  Must rearrange subwindows. */
name|outer_frame
operator|.
name|height
operator|=
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|height
expr_stmt|;
name|outer_frame
operator|.
name|width
operator|=
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|width
expr_stmt|;
name|XDestroySubwindows
argument_list|(
name|outer_window
argument_list|)
expr_stmt|;
name|LayoutStage2
argument_list|()
expr_stmt|;
name|XMapSubwindows
argument_list|(
name|outer_window
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ProcessCommandButtonEvent
argument_list|(
argument|command
argument_list|,
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|command_data
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|command_data
modifier|*
name|button_down_command
decl_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
if|if
condition|(
name|command
operator|->
name|inverted
condition|)
name|XClear
argument_list|(
name|command
operator|->
name|window
argument_list|)
expr_stmt|;
name|XTextMask
argument_list|(
name|command
operator|->
name|window
argument_list|,
comment|/* w */
name|command
operator|->
name|x_offset
argument_list|,
comment|/* x */
literal|0
argument_list|,
comment|/* y */
name|command
operator|->
name|name
argument_list|,
comment|/* string */
name|command
operator|->
name|name_length
argument_list|,
comment|/* length */
name|font
argument_list|,
comment|/* font */
name|foreground
argument_list|)
expr_stmt|;
comment|/* source pixel */
if|if
condition|(
name|command
operator|->
name|inverted
condition|)
name|InvertCommandWindow
argument_list|(
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|ButtonPressed
case|:
if|if
condition|(
name|button_down_command
operator|!=
name|NULL
condition|)
break|break;
comment|/* must be a second button push--ignore */
name|button_down_command
operator|=
name|command
expr_stmt|;
name|InvertCommandWindow
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|->
name|inverted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|LeaveWindow
case|:
if|if
condition|(
name|command
operator|==
name|button_down_command
condition|)
block|{
name|InvertCommandWindow
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|->
name|inverted
operator|=
name|FALSE
expr_stmt|;
name|button_down_command
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ButtonReleased
case|:
if|if
condition|(
name|command
operator|==
name|button_down_command
condition|)
block|{
call|(
modifier|*
name|command
operator|->
name|proc
call|)
argument_list|(
name|command
operator|->
name|data
argument_list|)
expr_stmt|;
name|button_down_command
operator|=
name|NULL
expr_stmt|;
name|InvertCommandWindow
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|->
name|inverted
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_macro
name|InvertCommandWindow
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|command_data
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XPixFill
argument_list|(
name|command
operator|->
name|window
argument_list|,
literal|0
argument_list|,
comment|/* x */
literal|0
argument_list|,
comment|/* y */
literal|400
argument_list|,
comment|/* width = "infinity " */
name|fontInfo
operator|.
name|height
argument_list|,
comment|/* height */
literal|1
argument_list|,
comment|/* pixel */
name|NULL
argument_list|,
comment|/* clipmask bitmap */
name|GXinvert
argument_list|,
comment|/* function */
name|invertplane
argument_list|)
expr_stmt|;
comment|/* planes */
block|}
end_block

begin_comment
comment|/* end of InvertCommandWindow procedure */
end_comment

begin_comment
comment|/* WhatSquare returns TRUE if mouse is outside grid, FALSE if inside.    If it returns FALSE, it assigns to *x_square and *y_square. */
end_comment

begin_function
name|boolean
name|WhatSquare
parameter_list|(
name|event
parameter_list|,
name|x_square
parameter_list|,
name|y_square
parameter_list|)
specifier|register
name|XEvent
modifier|*
name|event
decl_stmt|;
specifier|register
name|int
modifier|*
name|x_square
decl_stmt|,
decl|*
name|y_square
decl_stmt|;
end_function

begin_comment
comment|/*RETURN*/
end_comment

begin_block
block|{
name|int
name|x
init|=
operator|(
operator|(
name|XKeyPressedEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|x
decl_stmt|;
name|int
name|y
init|=
operator|(
operator|(
name|XKeyPressedEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|<
literal|0
operator|)
operator|||
operator|(
name|y
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
operator|*
name|x_square
operator|=
name|x
operator|/
name|square_size
expr_stmt|;
operator|*
name|y_square
operator|=
name|y
operator|/
name|square_size
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|x_square
operator|>=
name|squares_wide
operator|)
operator|||
operator|(
operator|*
name|y_square
operator|>=
name|squares_high
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end of WhatSquare procedure */
end_comment

begin_expr_stmt
name|RepaintGridLines
argument_list|(
name|how
argument_list|)
expr|enum
name|RepaintGridType
name|how
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|RepaintGridLinesPartially
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|squares_wide
argument_list|,
name|squares_high
argument_list|,
name|how
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|RepaintGridLinesPartially
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|how
argument_list|,
argument|include_boundaries
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|RepaintGridType
name|how
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|include_boundaries
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Vertex
name|v
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pixel
decl_stmt|,
name|func
decl_stmt|,
name|planes
decl_stmt|;
name|Pattern
name|pattern
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|e_AgainstBackground
case|:
name|pixel
operator|=
name|foreground
expr_stmt|;
name|pattern
operator|=
name|DottedPattern
expr_stmt|;
name|func
operator|=
name|GXcopy
expr_stmt|;
name|planes
operator|=
name|AllPlanes
expr_stmt|;
break|break;
case|case
name|e_AgainstForeground
case|:
name|pixel
operator|=
name|background
expr_stmt|;
name|pattern
operator|=
name|InverseDottedPattern
expr_stmt|;
name|func
operator|=
name|GXcopy
expr_stmt|;
name|planes
operator|=
name|AllPlanes
expr_stmt|;
break|break;
case|case
name|e_Invert
case|:
name|pixel
operator|=
literal|1
expr_stmt|;
name|pattern
operator|=
name|SolidLine
expr_stmt|;
name|func
operator|=
name|GXinvert
expr_stmt|;
name|planes
operator|=
name|invertplane
expr_stmt|;
break|break;
block|}
comment|/* draw vertical grid lines */
name|v
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y1
operator|*
name|square_size
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|y
operator|+=
operator|(
name|v
index|[
literal|0
index|]
operator|.
name|y
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* make sure pattern is aligned on even bit boundary */
name|v
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|y2
operator|*
name|square_size
expr_stmt|;
if|if
condition|(
operator|!
name|include_boundaries
condition|)
block|{
name|x1
operator|++
expr_stmt|;
name|x2
operator|--
expr_stmt|;
block|}
name|v
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|x1
operator|*
name|square_size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|x1
init|;
name|i
operator|<=
name|x2
condition|;
name|i
operator|++
control|)
block|{
name|XDrawDashed
argument_list|(
name|grid_window
argument_list|,
name|v
argument_list|,
comment|/* vertices */
literal|2
argument_list|,
comment|/* vertex count */
literal|1
argument_list|,
comment|/* width */
literal|1
argument_list|,
comment|/* height */
name|pixel
argument_list|,
name|pattern
argument_list|,
name|func
argument_list|,
name|planes
argument_list|)
expr_stmt|;
comment|/* planes */
name|v
index|[
literal|0
index|]
operator|.
name|x
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|.
name|x
operator|+=
name|square_size
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|include_boundaries
condition|)
block|{
name|x1
operator|--
expr_stmt|;
name|x2
operator|++
expr_stmt|;
block|}
comment|/* draw horizontal grid lines */
name|v
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x1
operator|*
name|square_size
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|x
operator|+=
operator|(
name|v
index|[
literal|0
index|]
operator|.
name|x
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* make sure pattern is aligned on even bit boundary */
name|v
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|x2
operator|*
name|square_size
expr_stmt|;
if|if
condition|(
operator|!
name|include_boundaries
condition|)
block|{
name|y1
operator|++
expr_stmt|;
name|y2
operator|--
expr_stmt|;
block|}
name|v
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|y1
operator|*
name|square_size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|y1
init|;
name|i
operator|<=
name|y2
condition|;
name|i
operator|++
control|)
block|{
name|XDrawDashed
argument_list|(
name|grid_window
argument_list|,
name|v
argument_list|,
comment|/* vertices */
literal|2
argument_list|,
comment|/* vertex count */
literal|1
argument_list|,
comment|/* width */
literal|1
argument_list|,
comment|/* height */
name|pixel
argument_list|,
name|pattern
argument_list|,
name|func
argument_list|,
name|planes
argument_list|)
expr_stmt|;
comment|/* planes */
name|v
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|.
name|y
operator|+=
name|square_size
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end of RepaintGridLinesPartially procedure */
end_comment

begin_macro
name|RefillGrid
argument_list|(
argument|paint_background
argument_list|)
end_macro

begin_decl_stmt
name|boolean
name|paint_background
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RefillGridPartially
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|squares_wide
operator|-
literal|1
argument_list|,
name|squares_high
operator|-
literal|1
argument_list|,
name|paint_background
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|RefillGridPartially
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|paint_background
argument_list|)
specifier|register
name|int
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean
name|paint_background
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
name|x1
init|;
name|i
operator|<=
name|x2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|y1
init|;
name|j
operator|<=
name|y2
condition|;
name|j
operator|++
control|)
block|{
name|bit
name|b
init|=
name|GetRasterBit
argument_list|(
name|raster
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|||
name|paint_background
condition|)
name|PaintSquare
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|b
condition|?
name|foreground
else|:
name|background
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* end of RefillGridPartially procedure */
end_comment

begin_macro
name|PaintSquare
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|pixel
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pixel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display function */
end_comment

begin_block
block|{
name|XPixSet
argument_list|(
name|grid_window
argument_list|,
name|x
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* x */
name|y
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* y */
name|square_size
operator|-
literal|1
argument_list|,
comment|/* width */
name|square_size
operator|-
literal|1
argument_list|,
comment|/* height */
name|pixel
argument_list|)
expr_stmt|;
comment|/* pixel */
block|}
end_block

begin_comment
comment|/* end of PaintSquare procedure */
end_comment

begin_macro
name|InvertSquare
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XPixFill
argument_list|(
name|grid_window
argument_list|,
name|x
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* x */
name|y
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* y */
name|square_size
operator|-
literal|1
argument_list|,
comment|/* width */
name|square_size
operator|-
literal|1
argument_list|,
comment|/* height */
literal|1
argument_list|,
comment|/* pixel */
name|NULL
argument_list|,
comment|/* clipmask */
name|GXinvert
argument_list|,
comment|/* function */
name|invertplane
argument_list|)
expr_stmt|;
comment|/* planes */
block|}
end_block

begin_function
name|bit
name|GetRasterBit
parameter_list|(
name|raster
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|short
modifier|*
name|raster
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
block|{
specifier|register
name|short
modifier|*
name|word
init|=
name|raster
operator|+
name|x
operator|/
literal|16
operator|+
name|y
operator|*
operator|(
operator|(
name|squares_wide
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|word
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|16
operator|)
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of GetRasterBit procedure */
end_comment

begin_macro
name|SetRasterBit
argument_list|(
argument|raster
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|raster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bit
name|new
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|word
init|=
name|raster
operator|+
name|x
operator|/
literal|16
operator|+
name|y
operator|*
operator|(
operator|(
name|squares_wide
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
decl_stmt|;
name|x
operator|%=
literal|16
expr_stmt|;
operator|*
name|word
operator|=
operator|(
name|new
operator|<<
name|x
operator|)
operator||
operator|(
operator|*
name|word
operator|&
operator|~
operator|(
literal|1
operator|<<
name|x
operator|)
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of SetRasterBit procedure */
end_comment

begin_macro
name|InvertRasterBit
argument_list|(
argument|raster
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|raster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|word
init|=
name|raster
operator|+
name|x
operator|/
literal|16
operator|+
name|y
operator|*
operator|(
operator|(
name|squares_wide
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
decl_stmt|;
operator|*
name|word
operator|^=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of InvertRasterBit procedure */
end_comment

begin_macro
name|RepaintRaster
argument_list|()
end_macro

begin_block
block|{
name|XBitmapBitsPut
argument_list|(
name|raster_window
argument_list|,
literal|3
argument_list|,
comment|/* x */
literal|3
argument_list|,
comment|/* y */
name|squares_wide
argument_list|,
comment|/* width */
name|squares_high
argument_list|,
comment|/* height */
name|raster
argument_list|,
comment|/* data */
name|foreground
argument_list|,
comment|/* foreground */
name|background
argument_list|,
comment|/* background */
literal|0
argument_list|,
comment|/* mask */
name|GXcopy
argument_list|,
comment|/* func */
name|AllPlanes
argument_list|)
expr_stmt|;
comment|/* planes */
block|}
end_block

begin_comment
comment|/* end of RepaintRaster procedure */
end_comment

begin_macro
name|RepaintRasterInverted
argument_list|()
end_macro

begin_block
block|{
name|XBitmapBitsPut
argument_list|(
name|raster_invert_window
argument_list|,
literal|3
argument_list|,
comment|/* x */
literal|3
argument_list|,
comment|/* y */
name|squares_wide
argument_list|,
comment|/* width */
name|squares_high
argument_list|,
comment|/* height */
name|raster
argument_list|,
comment|/* data */
name|background
argument_list|,
comment|/* foreground */
name|foreground
argument_list|,
comment|/* background */
literal|0
argument_list|,
comment|/* mask */
name|GXcopy
argument_list|,
comment|/* func */
name|AllPlanes
argument_list|)
expr_stmt|;
comment|/* planes */
block|}
end_block

begin_comment
comment|/* end of RepaintRasterInverted procedure */
end_comment

begin_macro
name|WriteOutputToFile
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"#define %s_width %d\n"
argument_list|,
name|stripped_name
argument_list|,
name|squares_wide
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"#define %s_height %d\n"
argument_list|,
name|stripped_name
argument_list|,
name|squares_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"#define %s_x_hot %d\n"
argument_list|,
name|stripped_name
argument_list|,
name|x_hot_spot
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"#define %s_y_hot %d\n"
argument_list|,
name|stripped_name
argument_list|,
name|y_hot_spot
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"static short %s_bits[] = {\n   0x%04x"
argument_list|,
name|stripped_name
argument_list|,
operator|(
name|u_short
operator|)
name|raster
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|raster_length
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|i
operator|%
literal|4
operator|)
condition|?
literal|" "
else|:
literal|"\n   "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%04x"
argument_list|,
operator|(
name|u_short
operator|)
name|raster
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of WriteOutputToFile procedure */
end_comment

begin_macro
name|DimensionsFromFile
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|variable
index|[
literal|81
index|]
decl_stmt|;
name|int
name|value
decl_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"#define %80s %d\n"
argument_list|,
name|variable
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|StringEndsWith
argument_list|(
name|variable
argument_list|,
literal|"width"
argument_list|)
condition|)
name|squares_wide
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|StringEndsWith
argument_list|(
name|variable
argument_list|,
literal|"height"
argument_list|)
condition|)
name|squares_high
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|StringEndsWith
argument_list|(
name|variable
argument_list|,
literal|"x_hot"
argument_list|)
condition|)
name|x_hot_spot
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|StringEndsWith
argument_list|(
name|variable
argument_list|,
literal|"y_hot"
argument_list|)
condition|)
name|y_hot_spot
operator|=
name|value
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized variable '%s' in file '%s'\n"
argument_list|,
name|variable
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|squares_wide
operator|<=
literal|0
operator|||
name|squares_wide
operator|==
name|OUT_OF_RANGE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: file '%s' does not have a valid width dimension\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|squares_high
operator|<=
literal|0
operator|||
name|squares_high
operator|==
name|OUT_OF_RANGE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: file '%s' does not have a valid height dimension\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end of DimensionsFromFile procedure */
end_comment

begin_macro
name|InitialValuesFromFile
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
name|char
name|s
index|[
literal|81
index|]
decl_stmt|;
name|status
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"static short %80s = { 0x%4hx"
argument_list|,
name|s
argument_list|,
operator|&
name|raster
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
literal|2
operator|)
operator|||
operator|!
name|StringEndsWith
argument_list|(
name|s
argument_list|,
literal|"bits[]"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: file '%s' has an invalid 1st array element\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|raster_length
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|fscanf
argument_list|(
name|file
argument_list|,
literal|", 0x%4hx"
argument_list|,
operator|&
name|raster
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: file '%s' has an invalid %dth array element\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* end of InitialValuesFromFile procedure */
end_comment

begin_function
name|char
modifier|*
name|StripName
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|char
modifier|*
name|begin
init|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|int
name|length
decl_stmt|;
name|begin
operator|=
operator|(
name|begin
condition|?
name|begin
operator|+
literal|1
else|:
name|name
operator|)
expr_stmt|;
name|end
operator|=
name|index
argument_list|(
name|begin
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|end
condition|?
operator|(
name|end
operator|-
name|begin
operator|)
else|:
name|strlen
argument_list|(
name|begin
argument_list|)
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|begin
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|result
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|BackupName
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|name_length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|name_length
operator|+
literal|2
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|result
index|[
name|name_length
index|]
operator|=
literal|'~'
expr_stmt|;
name|result
index|[
name|name_length
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|TmpFileName
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
block|{
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|char
modifier|*
name|begin
init|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|begin
condition|)
name|name
operator|=
name|begin
operator|+
literal|1
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|tmp
init|=
literal|"/tmp/"
decl_stmt|;
name|int
name|name_length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|tmp_length
init|=
name|strlen
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|int
name|result_length
init|=
name|name_length
operator|+
name|tmp_length
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|result_length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|tmp
argument_list|,
name|tmp_length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
operator|+
name|tmp_length
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|result
index|[
name|result_length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* StringEndsWith returns TRUE if "s" ends with "suffix", else returns FALSE */
end_comment

begin_function
name|boolean
name|StringEndsWith
parameter_list|(
name|s
parameter_list|,
name|suffix
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|suffix
decl_stmt|;
end_function

begin_block
block|{
name|int
name|s_len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|suffix_len
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|s
operator|+
name|s_len
operator|-
name|suffix_len
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* LayoutStage1 determines the size and y-position of all commmand    windows and both raster windows.  It fills in everything in the    commands[] array except the "window" field, and fills in everything in    the frames[] array except for the "self" (window) and "x" fields. It    returns in *width and *bottom the dimensions of the command area to be    created.      This routine is called only once, at startup time.    Everything done at this stage stays the same even if the user later    reshapes the window. */
end_comment

begin_macro
name|LayoutStage1
argument_list|()
end_macro

begin_block
block|{
name|int
name|widths
index|[
name|N_COMMANDS
index|]
decl_stmt|;
name|int
name|maxwidth
init|=
literal|0
decl_stmt|;
name|int
name|ypos
init|=
name|TOP_MARGIN
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|OpaqueFrame
modifier|*
name|frame
decl_stmt|;
name|int
name|ClearOrSetAll
argument_list|()
decl_stmt|,
name|InvertAll
argument_list|()
decl_stmt|,
name|ClearOrSetArea
argument_list|()
decl_stmt|,
name|InvertArea
argument_list|()
decl_stmt|,
name|CopyOrMoveArea
argument_list|()
decl_stmt|,
name|Line
argument_list|()
decl_stmt|,
name|Circle
argument_list|()
decl_stmt|,
name|FilledCircle
argument_list|()
decl_stmt|,
name|SetHotSpot
argument_list|()
decl_stmt|,
name|ClearHotSpot
argument_list|()
decl_stmt|,
name|WriteOutput
argument_list|()
decl_stmt|,
name|Quit
argument_list|()
decl_stmt|;
name|commands
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"Clear All"
expr_stmt|;
name|commands
index|[
literal|0
index|]
operator|.
name|proc
operator|=
name|ClearOrSetAll
expr_stmt|;
name|commands
index|[
literal|0
index|]
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|commands
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|"Set All"
expr_stmt|;
name|commands
index|[
literal|1
index|]
operator|.
name|proc
operator|=
name|ClearOrSetAll
expr_stmt|;
name|commands
index|[
literal|1
index|]
operator|.
name|data
operator|=
literal|1
expr_stmt|;
name|commands
index|[
literal|2
index|]
operator|.
name|name
operator|=
literal|"Invert All"
expr_stmt|;
name|commands
index|[
literal|2
index|]
operator|.
name|proc
operator|=
name|InvertAll
expr_stmt|;
name|commands
index|[
literal|3
index|]
operator|.
name|name
operator|=
literal|"Clear Area"
expr_stmt|;
name|commands
index|[
literal|3
index|]
operator|.
name|proc
operator|=
name|ClearOrSetArea
expr_stmt|;
name|commands
index|[
literal|3
index|]
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|commands
index|[
literal|4
index|]
operator|.
name|name
operator|=
literal|"Set Area"
expr_stmt|;
name|commands
index|[
literal|4
index|]
operator|.
name|proc
operator|=
name|ClearOrSetArea
expr_stmt|;
name|commands
index|[
literal|4
index|]
operator|.
name|data
operator|=
literal|1
expr_stmt|;
name|commands
index|[
literal|5
index|]
operator|.
name|name
operator|=
literal|"Invert Area"
expr_stmt|;
name|commands
index|[
literal|5
index|]
operator|.
name|proc
operator|=
name|InvertArea
expr_stmt|;
name|commands
index|[
literal|6
index|]
operator|.
name|name
operator|=
literal|"Copy Area"
expr_stmt|;
name|commands
index|[
literal|6
index|]
operator|.
name|proc
operator|=
name|CopyOrMoveArea
expr_stmt|;
name|commands
index|[
literal|6
index|]
operator|.
name|data
operator|=
name|COPY
expr_stmt|;
name|commands
index|[
literal|7
index|]
operator|.
name|name
operator|=
literal|"Move Area"
expr_stmt|;
name|commands
index|[
literal|7
index|]
operator|.
name|proc
operator|=
name|CopyOrMoveArea
expr_stmt|;
name|commands
index|[
literal|7
index|]
operator|.
name|data
operator|=
name|MOVE
expr_stmt|;
name|commands
index|[
literal|8
index|]
operator|.
name|name
operator|=
literal|"Overlay Area"
expr_stmt|;
name|commands
index|[
literal|8
index|]
operator|.
name|proc
operator|=
name|CopyOrMoveArea
expr_stmt|;
name|commands
index|[
literal|8
index|]
operator|.
name|data
operator|=
name|OVERLAY
expr_stmt|;
name|commands
index|[
literal|9
index|]
operator|.
name|name
operator|=
literal|"Line"
expr_stmt|;
name|commands
index|[
literal|9
index|]
operator|.
name|proc
operator|=
name|Line
expr_stmt|;
name|commands
index|[
literal|10
index|]
operator|.
name|name
operator|=
literal|"Circle"
expr_stmt|;
name|commands
index|[
literal|10
index|]
operator|.
name|proc
operator|=
name|Circle
expr_stmt|;
name|commands
index|[
literal|10
index|]
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|commands
index|[
literal|11
index|]
operator|.
name|name
operator|=
literal|"Filled Circle"
expr_stmt|;
name|commands
index|[
literal|11
index|]
operator|.
name|proc
operator|=
name|Circle
expr_stmt|;
name|commands
index|[
literal|11
index|]
operator|.
name|data
operator|=
literal|1
expr_stmt|;
name|commands
index|[
literal|12
index|]
operator|.
name|name
operator|=
literal|"Set HotSpot"
expr_stmt|;
name|commands
index|[
literal|12
index|]
operator|.
name|proc
operator|=
name|SetHotSpot
expr_stmt|;
name|commands
index|[
literal|13
index|]
operator|.
name|name
operator|=
literal|"Clear HotSpot"
expr_stmt|;
name|commands
index|[
literal|13
index|]
operator|.
name|proc
operator|=
name|ClearHotSpot
expr_stmt|;
name|commands
index|[
literal|14
index|]
operator|.
name|name
operator|=
literal|"Write Output"
expr_stmt|;
name|commands
index|[
literal|14
index|]
operator|.
name|proc
operator|=
name|WriteOutput
expr_stmt|;
name|commands
index|[
literal|15
index|]
operator|.
name|name
operator|=
literal|"Quit"
expr_stmt|;
name|commands
index|[
literal|15
index|]
operator|.
name|proc
operator|=
name|Quit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMMANDS
condition|;
name|i
operator|++
control|)
block|{
name|widths
index|[
name|i
index|]
operator|=
name|XQueryWidth
argument_list|(
name|commands
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxwidth
operator|<
name|widths
index|[
name|i
index|]
condition|)
name|maxwidth
operator|=
name|widths
index|[
name|i
index|]
expr_stmt|;
block|}
name|maxwidth
operator|+=
literal|4
expr_stmt|;
comment|/* so even widest command has a little space around it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMMANDS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|command_data
modifier|*
name|command
init|=
operator|&
name|commands
index|[
name|i
index|]
decl_stmt|;
name|frame
operator|=
operator|&
name|frames
index|[
name|i
index|]
expr_stmt|;
name|command
operator|->
name|name_length
operator|=
name|strlen
argument_list|(
name|command
operator|->
name|name
argument_list|)
expr_stmt|;
name|command
operator|->
name|x_offset
operator|=
operator|(
name|maxwidth
operator|-
name|widths
index|[
name|i
index|]
operator|)
operator|/
literal|2
expr_stmt|;
name|frame
operator|->
name|y
operator|=
name|ypos
expr_stmt|;
name|frame
operator|->
name|width
operator|=
name|maxwidth
expr_stmt|;
name|frame
operator|->
name|height
operator|=
name|fontInfo
operator|.
name|height
expr_stmt|;
name|frame
operator|->
name|bdrwidth
operator|=
literal|1
expr_stmt|;
name|frame
operator|->
name|border
operator|=
name|border
expr_stmt|;
name|frame
operator|->
name|background
operator|=
name|backmap
expr_stmt|;
name|ypos
operator|+=
name|fontInfo
operator|.
name|height
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|5
operator|||
name|i
operator|==
literal|8
operator|||
name|i
operator|==
literal|11
operator|||
name|i
operator|==
literal|13
condition|)
name|ypos
operator|+=
name|fontInfo
operator|.
name|height
operator|+
literal|5
expr_stmt|;
comment|/* for gaps between groups;  pretty random! */
block|}
comment|/* set up raster window */
name|frame
operator|=
operator|&
name|frame
index|[
name|N_COMMANDS
index|]
expr_stmt|;
name|frame
operator|=
operator|&
name|frames
index|[
name|i
index|]
expr_stmt|;
name|frame
operator|->
name|y
operator|=
operator|(
name|ypos
operator|+=
name|AROUND_RASTER_MARGIN
operator|)
expr_stmt|;
name|frame
operator|->
name|width
operator|=
name|squares_wide
operator|+
literal|6
expr_stmt|;
name|frame
operator|->
name|height
operator|=
name|squares_high
operator|+
literal|6
expr_stmt|;
name|frame
operator|->
name|bdrwidth
operator|=
literal|1
expr_stmt|;
name|frame
operator|->
name|border
operator|=
name|border
expr_stmt|;
name|frame
operator|->
name|background
operator|=
name|backmap
expr_stmt|;
comment|/* raster invert window is the same, except for y position */
operator|*
operator|(
name|frame
operator|+
literal|1
operator|)
operator|=
operator|*
name|frame
expr_stmt|;
operator|(
operator|++
name|frame
operator|)
operator|->
name|y
operator|+=
name|squares_high
operator|+
literal|8
operator|+
name|AROUND_RASTER_MARGIN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* LayoutStage2 is called both at startup time and whenever the user    resizes the outer window.  It figures out what the new grid square size    should be, determines the size and position of all subwindows, then    creates (but does not map) the subwindows. */
end_comment

begin_macro
name|LayoutStage2
argument_list|()
end_macro

begin_block
block|{
name|int
name|x_room
init|=
name|outer_frame
operator|.
name|width
operator|-
literal|1
operator|-
name|LEFT_MARGIN
operator|-
name|frames
index|[
literal|0
index|]
operator|.
name|width
operator|-
name|GRID_TO_COMMAND_MARGIN
operator|-
name|RIGHT_MARGIN
decl_stmt|;
name|int
name|y_room
init|=
name|outer_frame
operator|.
name|height
operator|-
literal|1
operator|-
name|TOP_MARGIN
operator|-
name|BOTTOM_MARGIN
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|command_x_offset
decl_stmt|;
name|OpaqueFrame
modifier|*
name|grid_frame
init|=
operator|&
name|frames
index|[
name|N_COMMANDS
operator|+
literal|2
index|]
decl_stmt|;
name|x_room
operator|/=
name|squares_wide
expr_stmt|;
name|y_room
operator|/=
name|squares_high
expr_stmt|;
name|square_size
operator|=
name|min
argument_list|(
name|x_room
argument_list|,
name|y_room
argument_list|)
expr_stmt|;
comment|/* fill in the grid window's frame */
name|grid_frame
operator|->
name|x
operator|=
name|LEFT_MARGIN
expr_stmt|;
name|grid_frame
operator|->
name|y
operator|=
name|TOP_MARGIN
expr_stmt|;
name|grid_frame
operator|->
name|width
operator|=
operator|(
name|squares_wide
operator|*
name|square_size
operator|)
operator|+
literal|1
expr_stmt|;
name|grid_frame
operator|->
name|height
operator|=
operator|(
name|squares_high
operator|*
name|square_size
operator|)
operator|+
literal|1
expr_stmt|;
name|grid_frame
operator|->
name|bdrwidth
operator|=
literal|0
expr_stmt|;
name|grid_frame
operator|->
name|border
operator|=
name|NULL
expr_stmt|;
name|grid_frame
operator|->
name|background
operator|=
name|backmap
expr_stmt|;
comment|/* fill in x offsets for command window frames */
name|command_x_offset
operator|=
name|grid_frame
operator|->
name|x
operator|+
name|grid_frame
operator|->
name|width
operator|+
name|GRID_TO_COMMAND_MARGIN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMMANDS
condition|;
name|i
operator|++
control|)
name|frames
index|[
name|i
index|]
operator|.
name|x
operator|=
name|command_x_offset
expr_stmt|;
comment|/* fill in x offsets for raster and raster-inverted window frames */
name|frames
index|[
name|N_COMMANDS
index|]
operator|.
name|x
operator|=
name|frames
index|[
name|N_COMMANDS
operator|+
literal|1
index|]
operator|.
name|x
operator|=
name|grid_frame
operator|->
name|x
operator|+
name|grid_frame
operator|->
name|width
operator|+
name|AROUND_RASTER_MARGIN
expr_stmt|;
comment|/* create all the subwindows */
name|XCreateWindows
argument_list|(
name|outer_window
argument_list|,
name|frames
argument_list|,
name|N_COMMANDS
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* stow away all the resulting window id's, and select input */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMMANDS
condition|;
name|i
operator|++
control|)
name|XSelectInput
argument_list|(
name|commands
index|[
name|i
index|]
operator|.
name|window
operator|=
name|frames
index|[
name|i
index|]
operator|.
name|self
argument_list|,
name|ButtonPressed
operator||
name|ButtonReleased
operator||
name|LeaveWindow
operator||
name|ExposeWindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|raster_window
operator|=
name|frames
index|[
name|N_COMMANDS
index|]
operator|.
name|self
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|raster_invert_window
operator|=
name|frames
index|[
name|N_COMMANDS
operator|+
literal|1
index|]
operator|.
name|self
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|grid_window
operator|=
name|grid_frame
operator|->
name|self
argument_list|,
name|RightDownMotion
operator||
name|MiddleDownMotion
operator||
name|LeftDownMotion
operator||
name|ExposeRegion
operator||
name|ButtonPressed
operator||
name|ButtonReleased
argument_list|)
expr_stmt|;
comment|/* ButtonReleased is selected for AskUserForArea's benefit */
block|}
end_block

begin_comment
comment|/* OuterWindowDims determines the minimum size for the outer window,    based on three constraints:  the grid square size, the width of    the command/raster area, and the minimum height of the    command/raster area ("right side" of the window).  It is called    at startup time. */
end_comment

begin_macro
name|OuterWindowDims
argument_list|(
argument|square_size
argument_list|,
argument|right_side_width
argument_list|,
argument|right_side_bottom
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|)
end_macro

begin_decl_stmt
name|int
name|square_size
decl_stmt|,
name|right_side_width
decl_stmt|,
name|right_side_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|width
decl_stmt|,
modifier|*
name|height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN */
end_comment

begin_block
block|{
operator|*
name|width
operator|=
name|LEFT_MARGIN
operator|+
name|squares_wide
operator|*
name|square_size
operator|+
literal|1
operator|+
name|right_side_width
expr_stmt|;
operator|*
name|height
operator|=
name|TOP_MARGIN
operator|+
name|squares_high
operator|*
name|square_size
operator|+
literal|1
operator|+
name|BOTTOM_MARGIN
expr_stmt|;
if|if
condition|(
operator|*
name|height
operator|<
name|right_side_bottom
condition|)
operator|*
name|height
operator|=
name|right_side_bottom
expr_stmt|;
block|}
end_block

begin_macro
name|ClearOrSetAll
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|bit
name|b
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 for clear, 1 for set */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|new
init|=
operator|(
name|b
condition|?
operator|~
literal|0
else|:
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raster_length
condition|;
name|i
operator|++
control|)
name|raster
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
name|XPixSet
argument_list|(
name|grid_window
argument_list|,
comment|/* window */
literal|0
argument_list|,
comment|/* x */
literal|0
argument_list|,
comment|/* y */
name|squares_wide
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* width */
name|squares_high
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* height */
name|b
condition|?
name|foreground
else|:
name|background
argument_list|)
expr_stmt|;
name|RepaintGridLines
argument_list|(
name|b
condition|?
name|e_AgainstForeground
else|:
name|e_AgainstBackground
argument_list|)
expr_stmt|;
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
if|if
condition|(
name|x_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of ClearAll procedure */
end_comment

begin_macro
name|ClearOrSetArea
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|bit
name|b
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 for clear, 1 for set */
end_comment

begin_block
block|{
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|AskUserForArea
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
condition|)
return|return;
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<=
name|x2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<=
name|y2
condition|;
name|y
operator|++
control|)
name|SetRasterBit
argument_list|(
name|raster
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|XPixSet
argument_list|(
name|grid_window
argument_list|,
comment|/* window */
name|x1
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* x */
name|y1
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* y */
operator|(
name|x2
operator|-
name|x1
operator|+
literal|1
operator|)
operator|*
name|square_size
operator|-
literal|1
argument_list|,
comment|/* width */
operator|(
name|y2
operator|-
name|y1
operator|+
literal|1
operator|)
operator|*
name|square_size
operator|-
literal|1
argument_list|,
comment|/* height */
name|b
condition|?
name|foreground
else|:
name|background
argument_list|)
expr_stmt|;
name|RepaintGridLinesPartially
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|+
literal|1
argument_list|,
name|y2
operator|+
literal|1
argument_list|,
name|b
condition|?
name|e_AgainstForeground
else|:
name|e_AgainstBackground
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_hot_spot
operator|>=
name|x1
operator|&&
name|x_hot_spot
operator|<=
name|x2
operator|&&
name|y_hot_spot
operator|>=
name|y1
operator|&&
name|y_hot_spot
operator|<=
name|y2
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
name|x1_square_exed_through
operator|=
name|y1_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of ClearArea procedure */
end_comment

begin_macro
name|InvertAll
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raster_length
condition|;
name|i
operator|++
control|)
name|raster
index|[
name|i
index|]
operator|^=
operator|~
literal|0
expr_stmt|;
comment|/* invert = exclusive or with all 1's */
name|changed
operator|=
name|TRUE
expr_stmt|;
name|XPixFill
argument_list|(
name|grid_window
argument_list|,
comment|/* window */
literal|0
argument_list|,
comment|/* x */
literal|0
argument_list|,
comment|/* y */
name|squares_wide
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* width */
name|squares_high
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* height */
literal|1
argument_list|,
comment|/* pixel */
name|NULL
argument_list|,
comment|/* clipmask */
name|GXinvert
argument_list|,
comment|/* function */
name|invertplane
argument_list|)
expr_stmt|;
comment|/* plane mask */
name|RepaintGridLines
argument_list|(
name|e_Invert
argument_list|)
expr_stmt|;
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of InvertAll procedure */
end_comment

begin_macro
name|InvertArea
argument_list|()
end_macro

begin_block
block|{
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|AskUserForArea
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
condition|)
return|return;
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<=
name|x2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<=
name|y2
condition|;
name|y
operator|++
control|)
name|InvertRasterBit
argument_list|(
name|raster
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ExThroughRectangle
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* wipe out X-outs */
name|XPixFill
argument_list|(
name|grid_window
argument_list|,
comment|/* window */
name|x1
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* x */
name|y1
operator|*
name|square_size
operator|+
literal|1
argument_list|,
comment|/* y */
operator|(
name|x2
operator|-
name|x1
operator|+
literal|1
operator|)
operator|*
name|square_size
operator|-
literal|1
argument_list|,
comment|/* width */
operator|(
name|y2
operator|-
name|y1
operator|+
literal|1
operator|)
operator|*
name|square_size
operator|-
literal|1
argument_list|,
comment|/* height */
literal|1
argument_list|,
comment|/* pixel */
name|NULL
argument_list|,
comment|/* clipmask */
name|GXinvert
argument_list|,
comment|/* function */
name|invertplane
argument_list|)
expr_stmt|;
comment|/* plane mask */
name|RepaintGridLinesPartially
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
operator|+
literal|1
argument_list|,
name|y2
operator|+
literal|1
argument_list|,
name|e_Invert
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
name|x1_square_exed_through
operator|=
name|y1_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of InvertArea procedure */
end_comment

begin_macro
name|CopyOrMoveArea
argument_list|(
argument|what
argument_list|)
end_macro

begin_block
block|{
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|x1dest
decl_stmt|,
name|y1dest
decl_stmt|;
if|if
condition|(
name|AskUserForArea
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
condition|)
return|return;
if|if
condition|(
name|AskUserForDest
argument_list|(
operator|&
name|x1dest
argument_list|,
operator|&
name|y1dest
argument_list|,
name|x2
operator|-
name|x1
operator|+
literal|1
argument_list|,
name|y2
operator|-
name|y1
operator|+
literal|1
argument_list|)
condition|)
comment|/* button released outside grid */
name|ExThroughRectangle
argument_list|(
name|x1_square_exed_through
argument_list|,
name|y1_square_exed_through
argument_list|,
name|x2_square_exed_through
argument_list|,
name|y2_square_exed_through
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|xsrc
decl_stmt|,
name|ysrc
decl_stmt|,
name|xdest
decl_stmt|,
name|ydest
decl_stmt|;
specifier|register
name|short
modifier|*
name|new_raster
init|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
name|raster_length
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
comment|/* actually UNhighlight it */
comment|/* copy whole raster to new raster */
name|bcopy
argument_list|(
name|raster
argument_list|,
name|new_raster
argument_list|,
name|raster_length
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|MOVE
condition|)
comment|/* clear source bits in new raster.  this is VERY inefficient.          sure wish we had BitBlt available in user memory! */
for|for
control|(
name|xsrc
operator|=
name|x1
init|;
name|xsrc
operator|<=
name|x2
condition|;
name|xsrc
operator|++
control|)
for|for
control|(
name|ysrc
operator|=
name|y1
init|;
name|ysrc
operator|<=
name|y2
condition|;
name|ysrc
operator|++
control|)
name|SetRasterBit
argument_list|(
name|new_raster
argument_list|,
name|xsrc
argument_list|,
name|ysrc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* copy old source bits to new destination. this is VERY inefficient.        sure wish we had BitBlt available in user memory! */
for|for
control|(
name|xsrc
operator|=
name|x1
operator|,
name|xdest
operator|=
name|x1dest
init|;
name|xsrc
operator|<=
name|x2
operator|&&
name|xdest
operator|<
name|squares_wide
condition|;
name|xsrc
operator|++
operator|,
name|xdest
operator|++
control|)
for|for
control|(
name|ysrc
operator|=
name|y1
operator|,
name|ydest
operator|=
name|y1dest
init|;
name|ysrc
operator|<=
name|y2
operator|&&
name|ydest
operator|<
name|squares_high
condition|;
name|ysrc
operator|++
operator|,
name|ydest
operator|++
control|)
if|if
condition|(
name|what
operator|==
name|OVERLAY
condition|)
block|{
if|if
condition|(
name|GetRasterBit
argument_list|(
name|raster
argument_list|,
name|xsrc
argument_list|,
name|ysrc
argument_list|)
condition|)
name|SetRasterBit
argument_list|(
name|new_raster
argument_list|,
name|xdest
argument_list|,
name|ydest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|SetRasterBit
argument_list|(
name|new_raster
argument_list|,
name|xdest
argument_list|,
name|ydest
argument_list|,
name|GetRasterBit
argument_list|(
name|raster
argument_list|,
name|xsrc
argument_list|,
name|ysrc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|raster
argument_list|)
expr_stmt|;
name|raster
operator|=
name|new_raster
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|MOVE
condition|)
name|RepaintRectangles
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x1dest
argument_list|,
name|y1dest
argument_list|)
expr_stmt|;
else|else
block|{
name|ExThroughRectangle
argument_list|(
name|x1_square_exed_through
argument_list|,
name|y1_square_exed_through
argument_list|,
name|x2_square_exed_through
argument_list|,
name|y2_square_exed_through
argument_list|)
expr_stmt|;
name|RefillGridPartially
argument_list|(
name|x1dest
argument_list|,
name|y1dest
argument_list|,
name|xdest
operator|-
literal|1
argument_list|,
name|ydest
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
comment|/* put the hot spot back on the screen */
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
name|x1_square_plus_through
operator|=
name|y1_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_plus_through
operator|=
name|y2_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
name|x1_square_exed_through
operator|=
name|y1_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of CopyArea procedure */
end_comment

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|a
parameter_list|)
value|(((a)>= 0) ? (a) : -(a))
end_define

begin_define
define|#
directive|define
name|CheckSetRasterBit
parameter_list|(
name|r
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|c
parameter_list|)
define|\
value|if ((x)>= 0&& (x)< squares_wide&& (y)>= 0&& (y)< squares_high) \ 		SetRasterBit(r, x, y, c)
end_define

begin_macro
name|Line
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|double
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|diff
decl_stmt|;
if|if
condition|(
name|AskUserForPoint
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|AskUserForPoint
argument_list|(
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|ExThroughRectangle
argument_list|(
name|x1_square_exed_through
argument_list|,
name|y1_square_exed_through
argument_list|,
name|x2_square_exed_through
argument_list|,
name|y2_square_exed_through
argument_list|)
expr_stmt|;
name|PlusThroughRectangle
argument_list|(
name|x1_square_plus_through
argument_list|,
name|y1_square_plus_through
argument_list|,
name|x2_square_plus_through
argument_list|,
name|y2_square_plus_through
argument_list|)
expr_stmt|;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|x
operator|=
name|x1
operator|+
literal|0.5
expr_stmt|;
name|y
operator|=
name|y1
operator|+
literal|0.5
expr_stmt|;
name|diff
operator|=
name|MAX
argument_list|(
name|ABS
argument_list|(
name|dx
argument_list|)
argument_list|,
name|ABS
argument_list|(
name|dy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
name|diff
operator|=
literal|0.9
expr_stmt|;
name|dx
operator|/=
name|diff
expr_stmt|;
name|dy
operator|/=
name|diff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|diff
condition|;
name|i
operator|++
control|)
block|{
name|SetRasterBit
argument_list|(
name|raster
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|+=
name|dx
expr_stmt|;
name|y
operator|+=
name|dy
expr_stmt|;
block|}
name|RefillGridPartially
argument_list|(
name|MIN
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
name|x1_square_exed_through
operator|=
name|y1_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x1_square_plus_through
operator|=
name|y1_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_plus_through
operator|=
name|y2_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_macro
name|Circle
argument_list|(
argument|filled
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|double
name|rad
decl_stmt|,
name|half
decl_stmt|;
if|if
condition|(
name|AskUserForPoint
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|AskUserForPoint
argument_list|(
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|ExThroughRectangle
argument_list|(
name|x1_square_exed_through
argument_list|,
name|y1_square_exed_through
argument_list|,
name|x2_square_exed_through
argument_list|,
name|y2_square_exed_through
argument_list|)
expr_stmt|;
name|PlusThroughRectangle
argument_list|(
name|x1_square_plus_through
argument_list|,
name|y1_square_plus_through
argument_list|,
name|x2_square_plus_through
argument_list|,
name|y2_square_plus_through
argument_list|)
expr_stmt|;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|rad
operator|=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
argument_list|)
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|filled
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|rad
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sqrt
argument_list|(
name|rad
operator|*
name|rad
operator|-
name|i
operator|*
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|x1
operator|-
name|x
init|;
name|j
operator|<=
name|x1
operator|+
name|x
condition|;
name|j
operator|++
control|)
block|{
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|j
argument_list|,
name|y1
operator|-
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|j
argument_list|,
name|y1
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|half
operator|=
name|rad
operator|*
name|sqrt
argument_list|(
literal|2.0
argument_list|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|half
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sqrt
argument_list|(
name|rad
operator|*
name|rad
operator|-
name|i
operator|*
name|i
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|-
name|x
argument_list|,
name|y1
operator|-
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|-
name|x
argument_list|,
name|y1
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|+
name|x
argument_list|,
name|y1
operator|-
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|+
name|x
argument_list|,
name|y1
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|-
name|i
argument_list|,
name|y1
operator|-
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|-
name|i
argument_list|,
name|y1
operator|+
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|+
name|i
argument_list|,
name|y1
operator|-
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckSetRasterBit
argument_list|(
name|raster
argument_list|,
name|x1
operator|+
name|i
argument_list|,
name|y1
operator|+
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|RefillGridPartially
argument_list|(
name|x1
operator|-
operator|(
name|int
operator|)
name|rad
argument_list|,
name|y1
operator|-
operator|(
name|int
operator|)
name|rad
argument_list|,
name|x1
operator|+
operator|(
name|int
operator|)
name|rad
argument_list|,
name|y1
operator|+
operator|(
name|int
operator|)
name|rad
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
name|x1_square_exed_through
operator|=
name|y1_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x1_square_plus_through
operator|=
name|y1_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_plus_through
operator|=
name|y2_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|RepaintRaster
argument_list|()
expr_stmt|;
name|RepaintRasterInverted
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ClearHotSpot
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|x_hot_spot
operator|==
name|OUT_OF_RANGE
condition|)
return|return;
name|HighlightHotSpot
argument_list|()
expr_stmt|;
comment|/* UNhighlight existing hot spot */
name|x_hot_spot
operator|=
name|y_hot_spot
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SetHotSpot
argument_list|()
end_macro

begin_block
block|{
name|XCompressEvents
argument_list|()
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ButtonPressed
operator||
name|ButtonReleased
operator||
name|ExposeWindow
argument_list|)
expr_stmt|;
comment|/* so that we can detect button pressed outside grid */
while|while
condition|(
name|TRUE
condition|)
block|{
name|XEvent
name|event
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ButtonPressed
case|:
case|case
name|MouseMoved
case|:
if|if
condition|(
operator|(
name|event
operator|.
name|window
operator|==
name|grid_window
operator|)
operator|&&
operator|!
name|WhatSquare
argument_list|(
operator|&
name|event
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
operator|&&
operator|(
name|x_hot_spot
operator|!=
name|x1
operator|||
name|y_hot_spot
operator|!=
name|y1
operator|)
condition|)
block|{
comment|/* UNhighlight old hot spot */
if|if
condition|(
name|x_hot_spot
operator|!=
name|OUT_OF_RANGE
condition|)
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|x_hot_spot
operator|=
name|x1
expr_stmt|;
name|y_hot_spot
operator|=
name|y1
expr_stmt|;
comment|/* highlight new hot spot */
name|HighlightHotSpot
argument_list|()
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
comment|/* keep looping until button is released */
case|case
name|ButtonReleased
case|:
name|XExpandEvents
argument_list|()
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|cross
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
return|return;
case|case
name|ExposeWindow
case|:
case|case
name|ExposeRegion
case|:
name|ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* just throw it away */
block|}
block|}
block|}
end_block

begin_macro
name|RepaintRectangles
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|x3
argument_list|,
argument|y3
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first rectangle's top& left */
end_comment

begin_decl_stmt
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first rectangle's bottom& right */
end_comment

begin_decl_stmt
name|int
name|x3
decl_stmt|,
name|y3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* second rectangle's top& left */
end_comment

begin_block
block|{
name|int
name|x4
init|=
name|x3
operator|+
operator|(
name|x2
operator|-
name|x1
operator|)
decl_stmt|;
comment|/* second rectangle's right edge */
name|int
name|y4
init|=
name|y3
operator|+
operator|(
name|y2
operator|-
name|y1
operator|)
decl_stmt|;
comment|/* second rectangle's bottom edge */
if|if
condition|(
name|x4
operator|>=
name|squares_wide
condition|)
name|x4
operator|=
name|squares_wide
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y4
operator|>=
name|squares_wide
condition|)
name|y4
operator|=
name|squares_high
operator|-
literal|1
expr_stmt|;
comment|/* if first rectangle is right of second, swap "first" and "second" variables */
if|if
condition|(
name|x1
operator|>
name|x3
condition|)
block|{
name|int
name|temp
decl_stmt|;
define|#
directive|define
name|swap
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{temp = a; a = b; b = temp;}
name|swap
argument_list|(
name|x1
argument_list|,
name|x3
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|y1
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|x2
argument_list|,
name|x4
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|y2
argument_list|,
name|y4
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|swap
block|}
name|RefillGridPartially
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x3
operator|>
name|x2
operator|)
operator|||
operator|(
name|max
argument_list|(
name|y1
argument_list|,
name|y3
argument_list|)
operator|>
name|min
argument_list|(
name|y2
argument_list|,
name|y4
argument_list|)
operator|)
condition|)
comment|/* rectangles don't overlap */
name|RefillGridPartially
argument_list|(
name|x3
argument_list|,
name|y3
argument_list|,
name|x4
argument_list|,
name|y4
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y1
operator|<
name|y3
condition|)
block|{
comment|/* second rectangle is below& right of first */
name|RefillGridPartially
argument_list|(
name|x2
operator|+
literal|1
argument_list|,
name|y3
argument_list|,
name|x4
argument_list|,
name|y2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|RefillGridPartially
argument_list|(
name|x3
argument_list|,
name|y2
operator|+
literal|1
argument_list|,
name|x4
argument_list|,
name|y4
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* second rectangle is above& right of first */
name|RefillGridPartially
argument_list|(
name|x3
argument_list|,
name|y3
argument_list|,
name|x4
argument_list|,
name|y1
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|RefillGridPartially
argument_list|(
name|x2
operator|+
literal|1
argument_list|,
name|y1
argument_list|,
name|x4
argument_list|,
name|y4
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* AskUserForArea returns FALSE if the user has defined a valid area,    TRUE if the user hasn't (e.g. by clicking outside grid) */
end_comment

begin_function
name|boolean
name|AskUserForArea
parameter_list|(
name|px1
parameter_list|,
name|py1
parameter_list|,
name|px2
parameter_list|,
name|py2
parameter_list|)
name|int
modifier|*
name|px1
decl_stmt|,
decl|*
name|py1
decl_stmt|,
modifier|*
name|px2
decl_stmt|,
modifier|*
name|py2
decl_stmt|;
end_function

begin_block
block|{
name|XEvent
name|event
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|boolean
name|result
decl_stmt|;
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ButtonPressed
operator||
name|ExposeWindow
argument_list|)
expr_stmt|;
comment|/* so that we can detect button pressed outside grid */
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|upper_left
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ButtonPressed
case|:
if|if
condition|(
operator|(
name|event
operator|.
name|window
operator|!=
name|grid_window
operator|)
operator|||
name|WhatSquare
argument_list|(
operator|&
name|event
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|)
condition|)
block|{
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|cross
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
goto|goto
name|out1
goto|;
comment|/* get out of the loop */
case|case
name|ExposeWindow
case|:
case|case
name|ExposeRegion
case|:
name|ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* just throw it away */
block|}
block|}
name|out1
label|:
name|XCompressEvents
argument_list|()
expr_stmt|;
comment|/* DO collapse consecutive MouseMoved events */
name|ExThroughSquare
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|FlushLineBuffer
argument_list|()
expr_stmt|;
name|x1_square_exed_through
operator|=
name|x2_square_exed_through
operator|=
name|x2
operator|=
name|x1
expr_stmt|;
name|y1_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|y2
operator|=
name|y1
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|lower_right
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ButtonPressed
case|:
name|result
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|out2
goto|;
case|case
name|ExposeWindow
case|:
case|case
name|ExposeRegion
case|:
name|ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|MouseMoved
case|:
case|case
name|ButtonReleased
case|:
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|result
operator|=
operator|(
name|event
operator|.
name|window
operator|!=
name|grid_window
operator|)
operator|||
name|WhatSquare
argument_list|(
operator|&
name|event
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
comment|/* mouse outside grid? */
operator|||
operator|(
name|x
operator|<
name|x1
operator|)
operator|||
operator|(
name|y
operator|<
name|y1
operator|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|ExThroughRectangle
argument_list|(
name|x1
operator|+
literal|1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|ExThroughRectangle
argument_list|(
name|x1
argument_list|,
name|y1
operator|+
literal|1
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x2_square_exed_through
operator|=
name|x1
expr_stmt|;
name|y2
operator|=
name|y2_square_exed_through
operator|=
name|y1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|==
name|x2
operator|)
operator|&&
operator|(
name|y
operator|==
name|y2
operator|)
condition|)
empty_stmt|;
comment|/* both dimensions the same; do nothing */
elseif|else
if|if
condition|(
operator|(
name|x
operator|>
name|x2
operator|)
operator|==
operator|(
name|y
operator|>
name|y2
operator|)
condition|)
block|{
comment|/* both dimensions bigger or smaller */
name|ExThroughRectangle
argument_list|(
name|min
argument_list|(
name|x2
argument_list|,
name|x
argument_list|)
operator|+
literal|1
argument_list|,
name|y1
argument_list|,
name|max
argument_list|(
name|x2
argument_list|,
name|x
argument_list|)
argument_list|,
name|max
argument_list|(
name|y2
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|ExThroughRectangle
argument_list|(
name|x1
argument_list|,
name|min
argument_list|(
name|y2
argument_list|,
name|y
argument_list|)
operator|+
literal|1
argument_list|,
name|min
argument_list|(
name|x2
argument_list|,
name|x
argument_list|)
argument_list|,
name|max
argument_list|(
name|y2
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x2_square_exed_through
operator|=
name|x
expr_stmt|;
name|y2
operator|=
name|y2_square_exed_through
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* one dimension bigger, the other smaller */
name|ExThroughRectangle
argument_list|(
name|min
argument_list|(
name|x2
argument_list|,
name|x
argument_list|)
operator|+
literal|1
argument_list|,
name|y1
argument_list|,
name|max
argument_list|(
name|x2
argument_list|,
name|x
argument_list|)
argument_list|,
name|min
argument_list|(
name|y2
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|ExThroughRectangle
argument_list|(
name|x1
argument_list|,
name|min
argument_list|(
name|y2
argument_list|,
name|y
argument_list|)
operator|+
literal|1
argument_list|,
name|min
argument_list|(
name|x2
argument_list|,
name|x
argument_list|)
argument_list|,
name|max
argument_list|(
name|y2
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|x2_square_exed_through
operator|=
name|x
expr_stmt|;
name|y2
operator|=
name|y2_square_exed_through
operator|=
name|y
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|.
name|type
operator|==
name|ButtonReleased
condition|)
goto|goto
name|out2
goto|;
break|break;
block|}
default|default:
break|break;
comment|/* just throw it away */
block|}
block|}
name|out2
label|:
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|cross
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* no area properly selected; remove X-outs from display */
name|ExThroughRectangle
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|x1_square_exed_through
operator|=
name|y1_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|px1
operator|=
name|x1
expr_stmt|;
operator|*
name|px2
operator|=
name|x2
expr_stmt|;
operator|*
name|py1
operator|=
name|y1
expr_stmt|;
operator|*
name|py2
operator|=
name|y2
expr_stmt|;
block|}
name|XExpandEvents
argument_list|()
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end of AskUserForArea procedure */
end_comment

begin_function
name|boolean
name|AskUserForDest
parameter_list|(
name|px1
parameter_list|,
name|py1
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|)
name|int
modifier|*
name|px1
decl_stmt|,
decl|*
name|py1
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XEvent
name|event
decl_stmt|;
name|boolean
name|result
decl_stmt|;
name|XCompressEvents
argument_list|()
expr_stmt|;
comment|/* DO collapse consecutive MouseMoved events */
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ButtonPressed
operator||
name|ButtonReleased
operator||
name|ExposeWindow
argument_list|)
expr_stmt|;
comment|/* so we can detect button action outside grid */
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|upper_left
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
case|case
name|ExposeRegion
case|:
name|ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|ButtonPressed
case|:
case|case
name|MouseMoved
case|:
block|{
name|int
name|x1_new
decl_stmt|,
name|y1_new
decl_stmt|;
name|boolean
name|this_window
init|=
operator|(
name|event
operator|.
name|window
operator|==
name|grid_window
operator|)
operator|&&
operator|!
name|WhatSquare
argument_list|(
operator|&
name|event
argument_list|,
operator|&
name|x1_new
argument_list|,
operator|&
name|y1_new
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_window
operator|&&
operator|(
name|x1_new
operator|==
operator|*
name|px1
operator|)
operator|&&
operator|(
name|y1_new
operator|==
operator|*
name|py1
operator|)
condition|)
break|break;
comment|/* mouse is still in same square as before; do nothing */
if|if
condition|(
name|x1_square_plus_through
operator|!=
name|OUT_OF_RANGE
condition|)
name|PlusThroughRectangle
argument_list|(
name|x1_square_plus_through
argument_list|,
name|y1_square_plus_through
argument_list|,
name|x2_square_plus_through
argument_list|,
name|y2_square_plus_through
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_window
condition|)
block|{
operator|*
name|px1
operator|=
name|x1_square_plus_through
operator|=
name|x1_new
expr_stmt|;
operator|*
name|py1
operator|=
name|y1_square_plus_through
operator|=
name|y1_new
expr_stmt|;
name|x2_square_plus_through
operator|=
name|min
argument_list|(
name|x1_new
operator|+
name|width
argument_list|,
name|squares_wide
argument_list|)
operator|-
literal|1
expr_stmt|;
name|y2_square_plus_through
operator|=
name|min
argument_list|(
name|y1_new
operator|+
name|height
argument_list|,
name|squares_high
argument_list|)
operator|-
literal|1
expr_stmt|;
name|PlusThroughRectangle
argument_list|(
name|x1_square_plus_through
argument_list|,
name|y1_square_plus_through
argument_list|,
name|x2_square_plus_through
argument_list|,
name|y2_square_plus_through
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x1_square_plus_through
operator|=
name|y1_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_plus_through
operator|=
name|y2_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
operator|*
name|px1
operator|=
operator|*
name|py1
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ButtonReleased
case|:
block|{
name|result
operator|=
operator|(
name|event
operator|.
name|window
operator|!=
name|grid_window
operator|)
operator|||
name|WhatSquare
argument_list|(
operator|&
name|event
argument_list|,
name|px1
argument_list|,
name|py1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
default|default:
break|break;
comment|/* throw it away */
block|}
block|}
name|out
label|:
if|if
condition|(
name|result
condition|)
block|{
comment|/* button released outside grid */
if|if
condition|(
name|x1_square_plus_through
operator|!=
name|OUT_OF_RANGE
condition|)
name|PlusThroughRectangle
argument_list|(
name|x1_square_plus_through
argument_list|,
name|y1_square_plus_through
argument_list|,
name|x2_square_plus_through
argument_list|,
name|y2_square_plus_through
argument_list|)
expr_stmt|;
name|x1_square_plus_through
operator|=
name|y1_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
name|x2_square_plus_through
operator|=
name|y2_square_plus_through
operator|=
name|OUT_OF_RANGE
expr_stmt|;
block|}
name|XExpandEvents
argument_list|()
expr_stmt|;
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|cross
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end of AskUserForDest procedure */
end_comment

begin_function
name|boolean
name|AskUserForPoint
parameter_list|(
name|xp
parameter_list|,
name|yp
parameter_list|,
name|plus
parameter_list|)
name|int
modifier|*
name|xp
decl_stmt|,
decl|*
name|yp
decl_stmt|;
end_function

begin_block
block|{
name|XEvent
name|event
decl_stmt|;
name|boolean
name|this_window
decl_stmt|;
name|XCompressEvents
argument_list|()
expr_stmt|;
comment|/* DO collapse consecutive MouseMoved events */
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ButtonPressed
operator||
name|ExposeWindow
argument_list|)
expr_stmt|;
comment|/* so we can detect button action outside grid */
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|dot
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
case|case
name|ExposeRegion
case|:
name|ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|ButtonReleased
case|:
name|this_window
operator|=
operator|(
name|event
operator|.
name|window
operator|==
name|grid_window
operator|)
operator|&&
operator|!
name|WhatSquare
argument_list|(
operator|&
name|event
argument_list|,
name|xp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_window
condition|)
block|{
if|if
condition|(
name|plus
condition|)
block|{
name|PlusThroughRectangle
argument_list|(
operator|*
name|xp
argument_list|,
operator|*
name|yp
argument_list|,
operator|*
name|xp
argument_list|,
operator|*
name|yp
argument_list|)
expr_stmt|;
name|x1_square_plus_through
operator|=
name|x2_square_plus_through
operator|=
operator|*
name|xp
expr_stmt|;
name|y1_square_plus_through
operator|=
name|y2_square_plus_through
operator|=
operator|*
name|yp
expr_stmt|;
block|}
else|else
block|{
name|ExThroughRectangle
argument_list|(
operator|*
name|xp
argument_list|,
operator|*
name|yp
argument_list|,
operator|*
name|xp
argument_list|,
operator|*
name|yp
argument_list|)
expr_stmt|;
name|x1_square_exed_through
operator|=
name|x2_square_exed_through
operator|=
operator|*
name|xp
expr_stmt|;
name|y1_square_exed_through
operator|=
name|y2_square_exed_through
operator|=
operator|*
name|yp
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
break|break;
default|default:
break|break;
comment|/* throw it away */
block|}
block|}
name|out
label|:
name|XExpandEvents
argument_list|()
expr_stmt|;
name|XSelectInput
argument_list|(
name|outer_window
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|outer_window
argument_list|,
name|cross
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|this_window
operator|)
return|;
block|}
end_block

begin_macro
name|DialogInputHandler
argument_list|(
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|XEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
case|case
name|ExposeRegion
case|:
name|ProcessEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_enum
enum|enum
name|output_error
block|{
name|e_rename
block|,
name|e_write
block|}
enum|;
end_enum

begin_comment
comment|/* WriteOutput returns TRUE if output successfully written, FALSE if not */
end_comment

begin_macro
name|WriteOutput
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|rename
argument_list|(
name|filename
argument_list|,
name|backup_filename
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|HandleOutputError
argument_list|(
name|e_rename
argument_list|)
operator|)
return|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
operator|(
name|HandleOutputError
argument_list|(
name|e_write
argument_list|)
operator|)
return|;
name|WriteOutputToFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|changed
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* HandleOutputError returns TRUE if alternate file written, FALSE if not */
end_comment

begin_function
name|int
name|HandleOutputError
parameter_list|(
name|e
parameter_list|)
name|enum
name|output_error
name|e
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|strings
index|[
literal|2
index|]
decl_stmt|;
name|char
name|msg1
index|[
literal|120
index|]
decl_stmt|,
name|msg2
index|[
literal|120
index|]
decl_stmt|;
name|char
modifier|*
name|tmp_filename
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|e_rename
condition|)
name|sprintf
argument_list|(
name|msg1
argument_list|,
literal|"Can't rename %s to %s -- %s"
argument_list|,
name|filename
argument_list|,
name|backup_filename
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|msg1
argument_list|,
literal|"Can't write on file %s -- %s"
argument_list|,
name|filename
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|tmp_filename
operator|=
name|TmpFileName
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg2
argument_list|,
literal|"Should I write output to file %s?"
argument_list|,
name|tmp_filename
argument_list|)
expr_stmt|;
name|strings
index|[
literal|0
index|]
operator|=
literal|"Yes"
expr_stmt|;
name|strings
index|[
literal|1
index|]
operator|=
literal|"No"
expr_stmt|;
name|result
operator|=
name|dialog
argument_list|(
name|outer_window
argument_list|,
name|font
argument_list|,
name|fontInfo
operator|.
name|height
argument_list|,
name|msg1
argument_list|,
name|msg2
argument_list|,
name|strings
argument_list|,
literal|2
argument_list|,
name|DialogInputHandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
comment|/* "yes" */
block|{
name|filename
operator|=
name|tmp_filename
expr_stmt|;
name|free
argument_list|(
name|backup_filename
argument_list|)
expr_stmt|;
name|backup_filename
operator|=
name|BackupName
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|WriteOutput
argument_list|()
operator|)
return|;
block|}
else|else
block|{
comment|/* "no" */
name|free
argument_list|(
name|tmp_filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|Quit
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|changed
condition|)
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|strings
index|[
literal|3
index|]
decl_stmt|;
name|strings
index|[
literal|0
index|]
operator|=
literal|"Yes"
expr_stmt|;
name|strings
index|[
literal|1
index|]
operator|=
literal|"No"
expr_stmt|;
name|strings
index|[
literal|2
index|]
operator|=
literal|"Cancel"
expr_stmt|;
name|result
operator|=
name|dialog
argument_list|(
name|outer_window
argument_list|,
name|font
argument_list|,
name|fontInfo
operator|.
name|height
argument_list|,
literal|"Save changes before quitting?"
argument_list|,
literal|""
argument_list|,
name|strings
argument_list|,
literal|3
argument_list|,
name|DialogInputHandler
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
literal|0
case|:
comment|/* "yes" */
if|if
condition|(
name|WriteOutput
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
return|return;
case|case
literal|1
case|:
comment|/* "no" */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
comment|/* "cancel" */
return|return;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|HighlightHotSpot
argument_list|()
end_macro

begin_block
block|{
comment|/* Draw a diamond in the hot spot square */
comment|/* x1 and y1 are the center of the hot spot square */
specifier|register
name|int
name|x1
init|=
name|x_hot_spot
operator|*
name|square_size
operator|+
name|square_size
operator|/
literal|2
decl_stmt|;
specifier|register
name|int
name|y1
init|=
name|y_hot_spot
operator|*
name|square_size
operator|+
name|square_size
operator|/
literal|2
decl_stmt|;
specifier|register
name|int
name|radius
init|=
name|square_size
operator|/
literal|6
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Vertex
name|v
index|[
literal|5
index|]
decl_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|v
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|v
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|x1
operator|+
name|radius
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|x1
operator|-
name|radius
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|v
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|y1
operator|+
name|radius
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|v
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|y1
operator|-
name|radius
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|v
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|XDraw
argument_list|(
name|grid_window
argument_list|,
name|v
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GXinvert
argument_list|,
name|highlightplane
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ExThroughRectangle
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
specifier|register
name|int
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<=
name|x2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<=
name|y2
condition|;
name|y
operator|++
control|)
name|ExThroughSquare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|FlushLineBuffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ExThroughSquare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x1
init|=
name|x
operator|*
name|square_size
decl_stmt|;
specifier|register
name|int
name|y1
init|=
name|y
operator|*
name|square_size
decl_stmt|;
name|LineIntoBuffer
argument_list|(
name|x1
operator|+
literal|1
argument_list|,
name|y1
operator|+
literal|1
argument_list|,
name|x1
operator|+
name|square_size
argument_list|,
name|y1
operator|+
name|square_size
argument_list|)
expr_stmt|;
name|LineIntoBuffer
argument_list|(
name|x1
operator|+
name|square_size
operator|-
literal|1
argument_list|,
name|y1
operator|+
literal|1
argument_list|,
name|x1
argument_list|,
name|y1
operator|+
name|square_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|PlusThroughRectangle
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
specifier|register
name|int
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|x
operator|=
name|x1
init|;
name|x
operator|<=
name|x2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|y1
init|;
name|y
operator|<=
name|y2
condition|;
name|y
operator|++
control|)
name|PlusThroughSquare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|FlushLineBuffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|PlusThroughSquare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x1
init|=
name|x
operator|*
name|square_size
decl_stmt|;
specifier|register
name|int
name|y1
init|=
name|y
operator|*
name|square_size
decl_stmt|;
name|LineIntoBuffer
argument_list|(
name|x1
operator|+
name|square_size
operator|/
literal|2
argument_list|,
name|y1
operator|+
literal|1
argument_list|,
name|x1
operator|+
name|square_size
operator|/
literal|2
argument_list|,
name|y1
operator|+
name|square_size
argument_list|)
expr_stmt|;
name|LineIntoBuffer
argument_list|(
name|x1
operator|+
literal|1
argument_list|,
name|y1
operator|+
name|square_size
operator|/
literal|2
argument_list|,
name|x1
operator|+
name|square_size
argument_list|,
name|y1
operator|+
name|square_size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|BUFFER_MAXLENGTH
value|200
end_define

begin_comment
comment|/* must be even */
end_comment

begin_decl_stmt
specifier|static
name|Vertex
name|buffer
index|[
name|BUFFER_MAXLENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buffer_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|LineIntoBuffer
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|)
end_macro

begin_block
block|{
name|buffer
index|[
name|buffer_length
index|]
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|buffer
index|[
name|buffer_length
index|]
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|buffer
index|[
name|buffer_length
operator|++
index|]
operator|.
name|flags
operator|=
name|VertexDontDraw
expr_stmt|;
name|buffer
index|[
name|buffer_length
index|]
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|buffer
index|[
name|buffer_length
index|]
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|buffer
index|[
name|buffer_length
operator|++
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buffer_length
operator|==
name|BUFFER_MAXLENGTH
condition|)
name|FlushLineBuffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|FlushLineBuffer
argument_list|()
end_macro

begin_block
block|{
name|XDraw
argument_list|(
name|grid_window
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GXinvert
argument_list|,
name|highlightplane
argument_list|)
expr_stmt|;
name|buffer_length
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|romp
end_ifdef

begin_comment
comment|/*   * prerelease IBM RT/PC software does not have ffs in its C library.  * This code should be thrown away by summer, 1986.  */
end_comment

begin_function
name|int
name|ffs
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|int
name|j
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|&
literal|1
condition|)
return|return
operator|(
name|j
operator|)
return|;
name|j
operator|++
expr_stmt|;
name|i
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

