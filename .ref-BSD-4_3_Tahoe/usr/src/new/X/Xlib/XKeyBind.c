begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* $Header: XKeyBind.c,v 10.12 86/07/21 15:27:14 wesommer Rel $ */
end_comment

begin_comment
comment|/* Copyright 1985, Massachusetts Institute of Technology */
end_comment

begin_include
include|#
directive|include
file|"XlibInternal.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"Xkeymap.h"
end_include

begin_include
include|#
directive|include
file|"Xkeyboard.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KEYBD
end_ifdef

begin_include
include|#
directive|include
file|"Xdefault.h"
end_include

begin_endif
endif|#
directive|endif
endif|KEYBD
end_endif

begin_define
define|#
directive|define
name|EMPTY_ENTRY
value|LeftMask
end_define

begin_comment
comment|/* if the "metabits" field of a runtime table entry contains this,     it's an empty entry */
end_comment

begin_decl_stmt
specifier|static
name|KeyMapElt
modifier|*
name|keymap
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Bool
name|inited
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ExtensionHeader
modifier|*
name|ext_begin
decl_stmt|,
modifier|*
name|ext_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Runtime table: contains multiple-byte character bindings defined   at runtime with XRebindCode */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|keycode
decl_stmt|;
name|unsigned
name|short
name|metabits
decl_stmt|;
name|short
name|length
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|RuntimeTableEntry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|RuntimeTableEntry
modifier|*
name|rt_begin
decl_stmt|,
comment|/* first entry of runtime table */
modifier|*
name|rt_end
decl_stmt|,
comment|/* this and all succeeding entries are empty */
modifier|*
name|rt_buf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points beyond end of allocated storage for table */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KEYBD
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|keyboardtype
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|KEYBD
end_endif

begin_define
define|#
directive|define
name|RT_INITIAL_SIZE
value|100
end_define

begin_comment
comment|/* initial size of runtime table */
end_comment

begin_define
define|#
directive|define
name|RT_INCREMENT
value|40
end_define

begin_comment
comment|/* size to grow by if expanded */
end_comment

begin_macro
name|XUseKeymap
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|filesize
decl_stmt|;
name|unsigned
name|char
name|magic
decl_stmt|;
name|struct
name|stat
name|filestat
decl_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no keymap file found */
block|}
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
name|filesize
operator|=
name|filestat
operator|.
name|st_size
operator|-
literal|1
expr_stmt|;
comment|/* first byte is magic number */
if|if
condition|(
name|filesize
operator|<
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|KeyMapElt
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keymap file %s is too small\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|read
argument_list|(
name|file
argument_list|,
operator|&
name|magic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|X_KEYMAP_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keymap file %s doesn't begin with the proper magic number\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|keymap
operator|=
operator|(
name|KeyMapElt
operator|*
operator|)
name|malloc
argument_list|(
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keymap
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* couldn't malloc; just act like there isn't a keymap */
block|}
name|read
argument_list|(
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keymap
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
name|ext_begin
operator|=
operator|(
name|ExtensionHeader
operator|*
operator|)
operator|(
name|keymap
operator|+
literal|256
operator|)
expr_stmt|;
name|ext_end
operator|=
operator|(
name|ExtensionHeader
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|keymap
operator|)
operator|+
name|filesize
operator|)
expr_stmt|;
name|rt_begin
operator|=
operator|(
name|RuntimeTableEntry
operator|*
operator|)
name|malloc
argument_list|(
name|RT_INITIAL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|RuntimeTableEntry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rt_begin
condition|)
name|_XIOError
argument_list|(
name|_XlibCurrentDisplay
argument_list|)
expr_stmt|;
name|rt_end
operator|=
name|rt_begin
expr_stmt|;
name|rt_buf_end
operator|=
name|rt_begin
operator|+
name|RT_INITIAL_SIZE
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|inited
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|Initialize
argument_list|()
block|{
name|int
name|file
operator|=
operator|-
literal|1
block|;
name|int
name|filesize
block|;
name|unsigned
name|char
name|magic
block|;     struct
name|stat
name|filestat
block|;
name|char
operator|*
name|getenv
argument_list|()
block|;
name|char
operator|*
name|filename
operator|=
name|NULL
block|;
ifdef|#
directive|ifdef
name|KEYBD
name|char
operator|*
name|home
block|;
name|char
operator|*
name|kdefault
operator|=
literal|"default"
block|;
name|char
operator|*
name|keybddir
operator|=
name|KEYBDDIR
block|;
else|#
directive|else
else|KEYBD
name|char
operator|*
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
block|;
endif|#
directive|endif
endif|KEYBD
name|inited
operator|=
name|TRUE
block|;
ifdef|#
directive|ifdef
name|KEYBD
if|if
condition|(
name|keyboardtype
operator|&&
operator|*
name|keyboardtype
condition|)
block|{
comment|/* Use keyboard type keymap */
name|filename
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|keybddir
argument_list|)
operator|+
name|strlen
argument_list|(
name|keyboardtype
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|keybddir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|keyboardtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     if
operator|(
name|file
operator|<
literal|0
operator|&&
operator|(
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|)
end_expr_stmt

begin_else
else|#
directive|else
else|KEYBD
end_else

begin_if
if|if
condition|(
name|home
condition|)
endif|#
directive|endif
endif|KEYBD
block|{
name|int
name|homelen
init|=
name|strlen
argument_list|(
name|home
argument_list|)
decl_stmt|;
name|char
modifier|*
name|keymapstr
init|=
literal|"/.Xkeymap"
decl_stmt|;
name|int
name|keymapstrlen
init|=
name|strlen
argument_list|(
name|keymapstr
argument_list|)
decl_stmt|;
name|filename
operator|=
name|malloc
argument_list|(
name|homelen
operator|+
name|keymapstrlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|filename
argument_list|,
name|home
argument_list|,
name|homelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|filename
argument_list|,
name|keymapstr
argument_list|,
name|keymapstrlen
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|KEYBD
end_ifdef

begin_if
if|if
condition|(
name|file
operator|<
literal|0
condition|)
block|{
comment|/* Try system default keymap */
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|keybddir
argument_list|)
operator|+
name|strlen
argument_list|(
name|kdefault
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|keybddir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|kdefault
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|KEYBD
end_endif

begin_if
if|if
condition|(
name|file
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
comment|/* no keymap file found */
block|}
end_if

begin_expr_stmt
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|filesize
operator|=
name|filestat
operator|.
name|st_size
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* first byte is magic number */
end_comment

begin_if
if|if
condition|(
name|filesize
operator|<
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|KeyMapElt
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keymap file %s is too small\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|read
argument_list|(
name|file
argument_list|,
operator|&
name|magic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|magic
operator|!=
name|X_KEYMAP_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keymap file %s doesn't begin with the proper magic number\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|keymap
operator|=
operator|(
name|KeyMapElt
operator|*
operator|)
name|malloc
argument_list|(
name|filesize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|keymap
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
comment|/* couldn't malloc; just act like there isn't a keymap */
block|}
end_if

begin_expr_stmt
name|read
argument_list|(
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keymap
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ext_begin
operator|=
operator|(
name|ExtensionHeader
operator|*
operator|)
operator|(
name|keymap
operator|+
literal|256
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ext_end
operator|=
operator|(
name|ExtensionHeader
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|keymap
operator|)
operator|+
name|filesize
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rt_begin
operator|=
operator|(
name|RuntimeTableEntry
operator|*
operator|)
name|malloc
argument_list|(
name|RT_INITIAL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|RuntimeTableEntry
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|rt_begin
condition|)
name|_XIOError
argument_list|(
name|_XlibCurrentDisplay
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|rt_end
operator|=
name|rt_begin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rt_buf_end
operator|=
name|rt_begin
operator|+
name|RT_INITIAL_SIZE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* this routine is used when initialization failed to find a    valid keymap file */
end_comment

begin_function
unit|static
name|char
modifier|*
name|BackstopLookupMapping
parameter_list|(
name|event
parameter_list|,
name|nbytes
parameter_list|)
name|XKeyPressedEvent
modifier|*
name|event
decl_stmt|;
name|int
modifier|*
name|nbytes
decl_stmt|;
block|{
name|int
name|detail
init|=
name|event
operator|->
name|detail
decl_stmt|;
specifier|register
name|int
name|keycode
init|=
name|detail
operator|&
name|ValueMask
decl_stmt|;
specifier|extern
name|KeyMapEntry
name|StdMap
index|[]
decl_stmt|;
specifier|static
name|char
name|c
decl_stmt|;
name|short
name|s
decl_stmt|;
comment|/* needed to distinguish a real character (e.g. \0377) from -1 */
name|s
operator|=
name|StdMap
index|[
name|keycode
index|]
index|[
name|KeyState
argument_list|(
name|detail
argument_list|)
index|]
expr_stmt|;
name|c
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|detail
operator|&
name|ShiftLockMask
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'z'
operator|)
condition|)
name|c
operator|+=
operator|(
literal|'A'
operator|-
literal|'a'
operator|)
expr_stmt|;
if|if
condition|(
name|IsTypewriterKey
argument_list|(
name|keycode
argument_list|)
operator|||
name|keycode
operator|==
name|KC_ESC
operator|||
name|keycode
operator|==
name|KC_BS
operator|||
name|keycode
operator|==
name|KC_LF
condition|)
operator|*
name|nbytes
operator|=
operator|(
name|s
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
else|else
operator|*
name|nbytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|c
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|XLookupMapping
parameter_list|(
name|event
parameter_list|,
name|nbytes
parameter_list|)
name|XKeyPressedEvent
modifier|*
name|event
decl_stmt|;
name|int
modifier|*
name|nbytes
decl_stmt|;
block|{
name|int
name|detail
init|=
name|event
operator|->
name|detail
decl_stmt|;
name|unsigned
name|int
name|metabits
init|=
name|FullKeyState
argument_list|(
name|detail
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|key
init|=
name|detail
operator|&
name|ValueMask
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|the_char
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
name|Initialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|keymap
condition|)
return|return
operator|(
name|BackstopLookupMapping
argument_list|(
name|event
argument_list|,
name|nbytes
argument_list|)
operator|)
return|;
name|the_char
operator|=
operator|&
name|keymap
index|[
name|key
index|]
index|[
name|metabits
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|the_char
condition|)
block|{
case|case
name|UNBOUND
case|:
block|{
operator|*
name|nbytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
case|case
name|EXTENSION_BOUND
case|:
block|{
specifier|register
name|ExtensionHeader
modifier|*
name|this
decl_stmt|;
for|for
control|(
name|this
operator|=
name|ext_begin
init|;
name|this
operator|<
name|ext_end
condition|;
name|NextExtension
argument_list|(
name|this
argument_list|)
control|)
if|if
condition|(
operator|(
name|key
operator|==
name|this
operator|->
name|keycode
operator|)
operator|&&
operator|(
operator|(
name|metabits
operator|==
name|this
operator|->
name|metabits
operator|)
operator|||
operator|(
name|this
operator|->
name|metabits
operator|==
name|DontCareMetaBits
operator|)
operator|)
condition|)
block|{
operator|*
name|nbytes
operator|=
name|this
operator|->
name|length
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|this
operator|+
name|ExtensionHeaderSize
operator|)
return|;
block|}
comment|/* if we get here, no match was found in the table extension */
operator|*
name|nbytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
case|case
name|RUNTIME_TABLE_BOUND
case|:
block|{
specifier|register
name|RuntimeTableEntry
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|rt_begin
init|;
name|entry
operator|<
name|rt_end
condition|;
name|entry
operator|++
control|)
if|if
condition|(
operator|(
name|key
operator|==
name|entry
operator|->
name|keycode
operator|)
operator|&&
operator|(
operator|(
name|metabits
operator|==
name|entry
operator|->
name|metabits
operator|)
operator|||
operator|(
name|entry
operator|->
name|metabits
operator|==
name|DontCareMetaBits
operator|)
operator|)
condition|)
block|{
operator|*
name|nbytes
operator|=
name|entry
operator|->
name|length
expr_stmt|;
return|return
operator|(
name|entry
operator|->
name|value
operator|)
return|;
block|}
comment|/* if we get here, no match was found in the runtime table */
operator|*
name|nbytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
default|default:
block|{
operator|*
name|nbytes
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|the_char
operator|)
return|;
block|}
block|}
block|}
end_function

begin_macro
name|XRebindCode
argument_list|(
argument|keycode
argument_list|,
argument|metabits
argument_list|,
argument|str
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|keycode
decl_stmt|,
name|metabits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|table_char
decl_stmt|;
name|metabits
operator|=
name|FullKeyState
argument_list|(
name|metabits
argument_list|)
expr_stmt|;
comment|/* shift meta bits to rightmost four bits */
if|if
condition|(
operator|!
name|inited
condition|)
name|Initialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|keymap
condition|)
return|return;
comment|/* no keymap file; what else can I do? */
name|table_char
operator|=
operator|&
name|keymap
index|[
name|keycode
index|]
index|[
name|metabits
index|]
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|table_char
operator|==
name|RUNTIME_TABLE_BOUND
condition|)
name|Unbind
argument_list|(
name|keycode
argument_list|,
name|metabits
argument_list|)
expr_stmt|;
operator|*
name|table_char
operator|=
name|UNBOUND
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|nbytes
operator|==
literal|1
operator|)
operator|&&
name|SingleCharBound
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|table_char
operator|==
name|RUNTIME_TABLE_BOUND
condition|)
name|Unbind
argument_list|(
name|keycode
argument_list|,
name|metabits
argument_list|)
expr_stmt|;
operator|*
name|table_char
operator|=
operator|*
name|str
expr_stmt|;
return|return;
block|}
comment|/* the new binding is either multi-character, or one of the        three reserved special characters */
if|if
condition|(
operator|*
name|table_char
operator|==
name|RUNTIME_TABLE_BOUND
condition|)
block|{
comment|/* entry is already in table; just change its binding */
specifier|register
name|RuntimeTableEntry
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|rt_begin
init|;
name|entry
operator|<
name|rt_end
condition|;
name|entry
operator|++
control|)
if|if
condition|(
name|keycode
operator|==
name|entry
operator|->
name|keycode
operator|&&
name|metabits
operator|==
name|entry
operator|->
name|metabits
condition|)
block|{
name|entry
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|entry
operator|->
name|length
operator|=
name|nbytes
expr_stmt|;
return|return;
block|}
comment|/* if we get here, entry wasn't found in table; shouldn't 	 * ever happen!  Not much to do but fall through to  	 * the following code.  */
block|}
comment|/* new binding must go in a new entry in the table */
operator|*
name|table_char
operator|=
name|RUNTIME_TABLE_BOUND
expr_stmt|;
if|if
condition|(
name|rt_end
operator|<
name|rt_buf_end
condition|)
block|{
name|rt_end
operator|->
name|keycode
operator|=
name|keycode
expr_stmt|;
name|rt_end
operator|->
name|metabits
operator|=
name|metabits
expr_stmt|;
name|rt_end
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|rt_end
operator|++
operator|->
name|length
operator|=
name|nbytes
expr_stmt|;
return|return;
block|}
comment|/* no room at end of table; look for holes in middle */
block|{
specifier|register
name|RuntimeTableEntry
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|rt_begin
init|;
name|entry
operator|<
name|rt_end
condition|;
name|entry
operator|++
control|)
if|if
condition|(
name|entry
operator|->
name|metabits
operator|==
name|EMPTY_ENTRY
condition|)
block|{
name|entry
operator|->
name|keycode
operator|=
name|keycode
expr_stmt|;
name|entry
operator|->
name|metabits
operator|=
name|metabits
expr_stmt|;
name|entry
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|entry
operator|->
name|length
operator|=
name|nbytes
expr_stmt|;
return|return;
block|}
block|}
comment|/* no room in table at all.  Must expand it. */
block|{
name|int
name|rt_length
init|=
name|rt_end
operator|-
name|rt_begin
decl_stmt|;
name|rt_begin
operator|=
operator|(
name|RuntimeTableEntry
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt_begin
argument_list|,
operator|(
name|rt_length
operator|+
name|RT_INCREMENT
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|RuntimeTableEntry
argument_list|)
argument_list|)
expr_stmt|;
name|rt_end
operator|=
name|rt_begin
operator|+
name|rt_length
expr_stmt|;
name|rt_buf_end
operator|=
name|rt_end
operator|+
name|RT_INCREMENT
expr_stmt|;
name|rt_end
operator|->
name|keycode
operator|=
name|keycode
expr_stmt|;
name|rt_end
operator|->
name|metabits
operator|=
name|metabits
expr_stmt|;
name|rt_end
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|rt_end
operator|++
operator|->
name|length
operator|=
name|nbytes
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|Unbind
argument_list|(
argument|keycode
argument_list|,
argument|metabits
argument_list|)
name|unsigned
name|int
name|keycode
operator|,
name|metabits
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|RuntimeTableEntry
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|rt_begin
init|;
name|entry
operator|<
name|rt_end
condition|;
name|entry
operator|++
control|)
if|if
condition|(
name|keycode
operator|==
name|entry
operator|->
name|keycode
operator|&&
name|metabits
operator|==
name|entry
operator|->
name|metabits
condition|)
block|{
name|entry
operator|->
name|metabits
operator|=
name|EMPTY_ENTRY
expr_stmt|;
return|return;
block|}
block|}
end_block

end_unit

