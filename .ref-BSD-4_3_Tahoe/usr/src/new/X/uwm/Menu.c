begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_Menu_c
init|=
literal|"$Header: Menu.c,v 10.4 86/11/19 16:23:55 jg Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  *			COPYRIGHT 1985, 1986  *		   DIGITAL EQUIPMENT CORPORATION  *		       MAYNARD, MASSACHUSETTS  *			ALL RIGHTS RESERVED.  *  * THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE AND  * SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.  * DIGITAL MAKES NO REPRESENTATIONS ABOUT THE SUITIBILITY OF THIS SOFTWARE FOR  * ANY PURPOSE.  IT IS SUPPLIED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.  *  * IF THE SOFTWARE IS MODIFIED IN A MANNER CREATING DERIVATIVE COPYRIGHT RIGHTS,  * APPROPRIATE LEGENDS MAY BE PLACED ON THE DERIVATIVE WORK IN ADDITION TO THAT  * SET FORTH ABOVE.  *  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting documentation,  * and that the name of Digital Equipment Corporation not be used in advertising  * or publicity pertaining to distribution of the software without specific,   * written prior permission.  *  */
end_comment

begin_comment
comment|/*  * MODIFICATION HISTORY  *  * 000 -- M. Gancarz, DEC Ultrix Engineering Group  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)Menu.c	3.8	1/24/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uwm.h"
end_include

begin_define
define|#
directive|define
name|DisplayLine
parameter_list|(
name|w
parameter_list|,
name|pane
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|str
parameter_list|,
name|fg
parameter_list|,
name|bg
parameter_list|)
define|\
value|XPixSet(w, 0, pane, width, height, bg); \          XTextMask(w, HMenuPad, pane + VMenuPad, str, strlen(str), MFont, fg);
end_define

begin_define
define|#
directive|define
name|NVERTS
value|5
end_define

begin_comment
comment|/* Number of vertices for hi-liter. */
end_comment

begin_decl_stmt
specifier|static
name|Vertex
name|vlist
index|[
name|NVERTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vertex list for hi-liter. */
end_comment

begin_function
name|Bool
name|Menu
parameter_list|(
name|window
parameter_list|,
name|mask
parameter_list|,
name|button
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|menu
parameter_list|)
name|Window
name|window
decl_stmt|;
comment|/* Event window. */
name|int
name|mask
decl_stmt|;
comment|/* Button/key mask. */
name|short
name|button
decl_stmt|;
comment|/* Button event detail. */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Event mouse position. */
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
block|{
name|XButtonEvent
name|button_event
decl_stmt|;
comment|/* Button event packet. */
name|Bool
name|func_stat
decl_stmt|;
comment|/* Function status return. */
name|int
name|cur_x
decl_stmt|,
name|cur_y
decl_stmt|;
comment|/* Current mouse position. */
name|Window
name|sub_window
decl_stmt|;
comment|/* Current subwindow. */
name|int
name|cur_item
init|=
literal|0
decl_stmt|;
comment|/* Current menu item. */
name|int
name|hi_lite
init|=
literal|0
decl_stmt|;
comment|/* Current highlighted item. */
name|int
name|i
decl_stmt|;
comment|/* Iteration counter. */
name|short
name|hlfg
decl_stmt|,
name|hlbg
decl_stmt|;
comment|/* Hi-liter pixels. */
name|MenuLine
modifier|*
name|ml
decl_stmt|;
comment|/* Menu lines pointer. */
name|char
modifier|*
name|hlname
decl_stmt|;
comment|/* Pointer to hi-liter name. */
name|char
modifier|*
name|strbuf
decl_stmt|;
comment|/* String buffer for IsTextNL. */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/*      * Change the cursor.      */
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|MenuCursor
argument_list|,
name|mask
argument_list|,
name|EVENTMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Menu -> Unable to grab button and change cursor."
argument_list|)
expr_stmt|;
comment|/*      * Map the menu.      */
name|MapMenu
argument_list|(
name|menu
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/*      * Main loop.      */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/*          * If no button event, check the current mouse position.          */
name|status
operator|=
name|XUpdateMouse
argument_list|(
name|menu
operator|->
name|w
argument_list|,
operator|&
name|cur_x
argument_list|,
operator|&
name|cur_y
argument_list|,
operator|&
name|sub_window
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
continue|continue;
comment|/*          * If the mouse has moved out of the menu sideways, abort          * the menu operation. Reset the cursor and unmap the menu.          */
if|if
condition|(
name|cur_x
operator|<
literal|0
operator|||
name|cur_x
operator|>
name|menu
operator|->
name|width
condition|)
block|{
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*          * If the mouse has moved below or above the menu, but is still          * within the same vertical plane, then simply adjust the values          * so the user doesn't fall off the edge.          */
if|if
condition|(
name|cur_y
operator|>=
name|menu
operator|->
name|height
condition|)
name|cur_y
operator|=
name|menu
operator|->
name|height
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_y
operator|<
literal|0
condition|)
name|cur_y
operator|=
literal|0
expr_stmt|;
comment|/*          * If the mouse has moved to another item in the menu,          * highlight the new item.          */
name|cur_item
operator|=
name|cur_y
operator|/
name|menu
operator|->
name|iheight
expr_stmt|;
if|if
condition|(
name|cur_item
operator|!=
name|hi_lite
condition|)
block|{
comment|/*              * Remove highlighting on old item.              */
if|if
condition|(
name|hi_lite
condition|)
block|{
name|DisplayLine
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|hi_lite
operator|*
name|menu
operator|->
name|iheight
argument_list|,
name|menu
operator|->
name|width
argument_list|,
name|menu
operator|->
name|iheight
argument_list|,
name|hlname
argument_list|,
name|hlfg
argument_list|,
name|hlbg
argument_list|)
expr_stmt|;
block|}
comment|/*              * Highlight new item.              */
if|if
condition|(
name|cur_item
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|ml
operator|=
name|menu
operator|->
name|line
init|;
name|ml
condition|;
name|i
operator|++
operator|,
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
if|if
condition|(
name|i
operator|==
name|cur_item
condition|)
break|break;
block|}
name|DisplayLine
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|cur_item
operator|*
name|menu
operator|->
name|iheight
argument_list|,
name|menu
operator|->
name|width
argument_list|,
name|menu
operator|->
name|iheight
argument_list|,
name|ml
operator|->
name|name
argument_list|,
name|menu
operator|->
name|hlfg
operator|.
name|pixel
argument_list|,
name|menu
operator|->
name|hlbg
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|vlist
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|cur_item
operator|*
name|menu
operator|->
name|iheight
operator|+
literal|1
expr_stmt|;
name|XDraw
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|vlist
argument_list|,
name|NVERTS
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|menu
operator|->
name|hlfg
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
block|}
name|hi_lite
operator|=
name|cur_item
expr_stmt|;
name|hlfg
operator|=
name|ml
operator|->
name|fg
operator|.
name|pixel
expr_stmt|;
name|hlbg
operator|=
name|ml
operator|->
name|bg
operator|.
name|pixel
expr_stmt|;
name|hlname
operator|=
name|ml
operator|->
name|name
expr_stmt|;
block|}
comment|/*          * Check to see if we have a change in the mouse buttons.          * This means the user has selected an item or aborted the          * operation.          */
if|if
condition|(
name|XPending
argument_list|()
operator|&&
name|GetButton
argument_list|(
operator|&
name|button_event
argument_list|)
condition|)
block|{
comment|/*              * Was button released?              */
if|if
condition|(
operator|(
name|button_event
operator|.
name|type
operator|==
name|ButtonReleased
operator|)
operator|&&
operator|(
operator|(
name|button_event
operator|.
name|detail
operator|&
name|ValueMask
operator|)
operator|==
name|button
operator|)
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/*                  * Some other button event occurred, so abort the menu                  * operation.                  */
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
comment|/*      * If no item was selected, simply close the menu and return.      */
if|if
condition|(
operator|!
name|cur_item
condition|)
block|{
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*      * Get a pointer to the menu line selected.      */
operator|--
name|cur_item
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ml
operator|=
name|menu
operator|->
name|line
init|;
name|ml
condition|;
name|i
operator|++
operator|,
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
if|if
condition|(
name|i
operator|==
name|cur_item
condition|)
break|break;
block|}
comment|/*      * Perform the selected menu line action.      */
switch|switch
condition|(
name|ml
operator|->
name|type
condition|)
block|{
case|case
name|IsShellCommand
case|:
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|ml
operator|->
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|IsText
case|:
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|XStoreBytes
argument_list|(
name|ml
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|ml
operator|->
name|text
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IsTextNL
case|:
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|strbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ml
operator|->
name|text
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strbuf
argument_list|,
name|ml
operator|->
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|strbuf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|XStoreBytes
argument_list|(
name|strbuf
argument_list|,
name|strlen
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|IsUwmFunction
case|:
name|GetContext
argument_list|(
operator|&
name|sub_window
argument_list|,
operator|&
name|cur_x
argument_list|,
operator|&
name|cur_y
argument_list|)
expr_stmt|;
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_window
operator|!=
name|menu
operator|->
name|w
condition|)
call|(
modifier|*
name|ml
operator|->
name|func
call|)
argument_list|(
name|sub_window
argument_list|,
name|mask
argument_list|,
name|button
argument_list|,
name|cur_x
argument_list|,
name|cur_y
argument_list|)
expr_stmt|;
break|break;
case|case
name|IsImmFunction
case|:
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ml
operator|->
name|func
call|)
argument_list|(
name|sub_window
argument_list|,
name|mask
argument_list|,
name|button
argument_list|,
name|cur_x
argument_list|,
name|cur_y
argument_list|)
expr_stmt|;
break|break;
case|case
name|IsMenuFunction
case|:
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|GetButton
argument_list|(
operator|&
name|button_event
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|button_event
operator|.
name|type
operator|!=
name|ButtonPressed
condition|)
continue|continue;
if|if
condition|(
operator|(
name|KeyMask
argument_list|(
name|button_event
operator|.
name|detail
argument_list|)
operator|!=
name|KeyMask
argument_list|(
name|mask
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|button_event
operator|.
name|detail
operator|&
name|ButtonMods
operator|)
operator|!=
name|button
operator|)
condition|)
block|{
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
block|}
name|UnmapMenu
argument_list|(
name|menu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|func_stat
operator|=
name|Menu
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|mask
argument_list|,
name|button
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|ml
operator|->
name|menu
argument_list|)
expr_stmt|;
return|return
operator|(
name|func_stat
operator|)
return|;
break|break;
default|default:
name|Error
argument_list|(
literal|"Menu -> Internal type error."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the menu windows for later use.  */
end_comment

begin_macro
name|CreateMenus
argument_list|()
end_macro

begin_block
block|{
name|MenuLink
modifier|*
name|ptr
decl_stmt|;
comment|/*      * If MaxColors isn't set, then jam it to an impossibly high      * number.      */
if|if
condition|(
name|MaxColors
operator|==
literal|0
condition|)
name|MaxColors
operator|=
literal|25000
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|Menus
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|InitMenu
argument_list|(
name|ptr
operator|->
name|menu
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize a menu.  */
end_comment

begin_macro
name|InitMenu
argument_list|(
argument|menu
argument_list|)
end_macro

begin_decl_stmt
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|MenuLine
modifier|*
name|ml
decl_stmt|;
comment|/* Menu lines pointer. */
name|int
name|width
decl_stmt|;
comment|/* Width of an item name. */
name|int
name|maxwidth
decl_stmt|;
comment|/* Maximum width of item names. */
name|int
name|len
decl_stmt|;
comment|/* Length of an item name. */
name|int
name|count
init|=
literal|1
decl_stmt|;
comment|/* Number of items + 1 for name. */
comment|/*      * Determine the name of the longest menu item.      */
name|maxwidth
operator|=
name|XQueryWidth
argument_list|(
name|menu
operator|->
name|name
argument_list|,
name|MFont
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxwidth
operator|==
literal|0
condition|)
name|Error
argument_list|(
literal|"InitMenu -> Couldn't get length of menu name"
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|menu
operator|->
name|line
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|ml
operator|->
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|width
operator|=
name|XQueryWidth
argument_list|(
name|ml
operator|->
name|name
argument_list|,
name|MFont
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|Error
argument_list|(
literal|"InitMenu -> Couldn't get length of menu item name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|maxwidth
condition|)
name|maxwidth
operator|=
name|width
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/*      * Get the color cells for the menu items.      */
name|GetMenuColors
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/*      * Stash the menu parameters in the menu info structure.      */
name|menu
operator|->
name|iheight
operator|=
name|MFontInfo
operator|.
name|height
operator|+
operator|(
name|VMenuPad
operator|<<
literal|1
operator|)
expr_stmt|;
name|menu
operator|->
name|height
operator|=
name|menu
operator|->
name|iheight
operator|*
name|count
expr_stmt|;
name|menu
operator|->
name|width
operator|=
name|maxwidth
operator|+
operator|(
name|HMenuPad
operator|<<
literal|1
operator|)
expr_stmt|;
name|menu
operator|->
name|image
operator|=
name|NULL
expr_stmt|;
comment|/*      * Create the menu window.      */
name|menu
operator|->
name|w
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|width
argument_list|,
name|menu
operator|->
name|height
argument_list|,
name|MBorderWidth
argument_list|,
name|MBorder
argument_list|,
name|MBackground
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|w
operator|==
name|NULL
condition|)
name|Error
argument_list|(
literal|"InitMenu -> Couldn't create menu window"
argument_list|)
expr_stmt|;
comment|/*      * Store the window name.      */
name|XStoreName
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|menu
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*      * Define a cursor for the window.      */
name|XDefineCursor
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|MenuCursor
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map a menu.  */
end_comment

begin_macro
name|MapMenu
argument_list|(
argument|menu
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|item
decl_stmt|;
name|Window
name|w
decl_stmt|;
name|MenuLine
modifier|*
name|ml
decl_stmt|;
name|w
operator|=
name|menu
operator|->
name|w
expr_stmt|;
comment|/*      * Move the menu into place, normalizing the coordinates, if necessary;      * then map it.      */
name|x
operator|-=
operator|(
name|menu
operator|->
name|width
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|+
name|menu
operator|->
name|width
operator|>=
name|ScreenWidth
condition|)
name|x
operator|=
name|ScreenWidth
operator|-
name|menu
operator|->
name|width
operator|-
operator|(
name|MBorderWidth
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|+
name|menu
operator|->
name|height
operator|>=
name|ScreenHeight
condition|)
name|y
operator|=
name|ScreenHeight
operator|-
name|menu
operator|->
name|height
operator|-
operator|(
name|MBorderWidth
operator|<<
literal|1
operator|)
expr_stmt|;
name|XMoveWindow
argument_list|(
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/*      * Map the window and draw the text items.      */
name|XMapWindow
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|DisplayLine
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|width
argument_list|,
name|menu
operator|->
name|iheight
argument_list|,
name|menu
operator|->
name|name
argument_list|,
name|menu
operator|->
name|bg
operator|.
name|pixel
argument_list|,
name|menu
operator|->
name|fg
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|SetUpVlist
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|vlist
index|[
literal|0
index|]
operator|.
name|x
operator|=
literal|1
expr_stmt|;
name|vlist
index|[
literal|0
index|]
operator|.
name|y
operator|=
literal|1
expr_stmt|;
name|XDraw
argument_list|(
name|menu
operator|->
name|w
argument_list|,
name|vlist
argument_list|,
name|NVERTS
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|menu
operator|->
name|bg
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|item
operator|=
name|menu
operator|->
name|iheight
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|menu
operator|->
name|line
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
name|DisplayLine
argument_list|(
name|w
argument_list|,
name|item
argument_list|,
name|menu
operator|->
name|width
argument_list|,
name|menu
operator|->
name|iheight
argument_list|,
name|ml
operator|->
name|name
argument_list|,
name|ml
operator|->
name|fg
operator|.
name|pixel
argument_list|,
name|ml
operator|->
name|bg
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|item
operator|+=
name|menu
operator|->
name|iheight
expr_stmt|;
block|}
comment|/*      * Position the mouse cursor in the menu header (or in the first item      * if "autoselect" is set).      */
if|if
condition|(
name|Autoselect
condition|)
name|XWarpMouse
argument_list|(
name|w
argument_list|,
operator|(
name|menu
operator|->
name|width
operator|>>
literal|2
operator|)
operator|*
literal|3
argument_list|,
operator|(
name|menu
operator|->
name|iheight
operator|>>
literal|1
operator|)
operator|*
literal|3
argument_list|)
expr_stmt|;
else|else
name|XWarpMouse
argument_list|(
name|w
argument_list|,
operator|(
name|menu
operator|->
name|width
operator|>>
literal|2
operator|)
operator|*
literal|3
argument_list|,
name|menu
operator|->
name|iheight
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unmap a menu, restoring the contents of the screen underneath  * if necessary. (Restore portion is a future.)  */
end_comment

begin_macro
name|UnmapMenu
argument_list|(
argument|menu
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*      * Restore the main cursor.      */
name|Grab
argument_list|(
operator|(
name|short
operator|)
name|mask
argument_list|)
expr_stmt|;
comment|/*      * Unmap and flush.      */
name|XUnmapWindow
argument_list|(
name|menu
operator|->
name|w
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the context for invoking a window manager function.  */
end_comment

begin_macro
name|GetContext
argument_list|(
argument|w
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|Window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XButtonEvent
name|button_event
decl_stmt|;
comment|/* Button input event. */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/*          * Get the next mouse button event.  Spin our wheels until          * a button event is returned (ie. GetButton == TRUE).          * Note that mouse events within an icon window are handled          * in the "GetButton" function or by the icon's owner if          * it is not uwm.          */
if|if
condition|(
operator|!
name|GetButton
argument_list|(
operator|&
name|button_event
argument_list|)
condition|)
continue|continue;
comment|/*          * If the button event received is not a ButtonPressed event          * then continue until we find one.          */
if|if
condition|(
name|button_event
operator|.
name|type
operator|!=
name|ButtonPressed
condition|)
continue|continue;
comment|/*          * Okay, determine the event window and mouse coordinates.          */
name|status
operator|=
name|XInterpretLocator
argument_list|(
name|RootWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|button_event
operator|.
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
continue|continue;
if|if
condition|(
operator|*
name|w
operator|==
literal|0
condition|)
operator|*
name|w
operator|=
name|RootWindow
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the color cells for a menu.  This function is slightly brain-damaged  * in that once MaxColors<= 1, then it refuses to even try to allocate any  * more colors, even though the colors may have already been allocated.  It  * probably ought to be done right someday.  */
end_comment

begin_macro
name|GetMenuColors
argument_list|(
argument|menu
argument_list|)
end_macro

begin_decl_stmt
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuLine
modifier|*
name|ml
decl_stmt|;
comment|/* Menu lines pointer. */
comment|/*      * If we have more than 2 colors available, then attempt to get      * the color map entries requested by the user.      * Otherwise, default to standard black and white.      */
if|if
condition|(
name|DisplayCells
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|/*          * Get the menu header colors first.          */
if|if
condition|(
operator|!
operator|(
name|menu
operator|->
name|foreground
operator|&&
name|menu
operator|->
name|background
operator|&&
name|MaxColors
operator|>
literal|1
operator|&&
name|XParseColor
argument_list|(
name|menu
operator|->
name|foreground
argument_list|,
operator|&
name|menu
operator|->
name|fg
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|menu
operator|->
name|fg
argument_list|)
operator|&&
name|XParseColor
argument_list|(
name|menu
operator|->
name|background
argument_list|,
operator|&
name|menu
operator|->
name|bg
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|menu
operator|->
name|bg
argument_list|)
operator|)
condition|)
block|{
name|menu
operator|->
name|fg
operator|.
name|pixel
operator|=
name|MTextForground
expr_stmt|;
name|menu
operator|->
name|bg
operator|.
name|pixel
operator|=
name|MTextBackground
expr_stmt|;
block|}
else|else
block|{
name|AdjustMaxColors
argument_list|(
name|menu
operator|->
name|fg
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|AdjustMaxColors
argument_list|(
name|menu
operator|->
name|bg
operator|.
name|pixel
argument_list|)
expr_stmt|;
block|}
comment|/*          * Get the menu highlight colors.          */
if|if
condition|(
operator|!
operator|(
name|menu
operator|->
name|fghighlight
operator|&&
name|menu
operator|->
name|bghighlight
operator|&&
name|MaxColors
operator|>
literal|1
operator|&&
name|XParseColor
argument_list|(
name|menu
operator|->
name|fghighlight
argument_list|,
operator|&
name|menu
operator|->
name|hlfg
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|menu
operator|->
name|hlfg
argument_list|)
operator|&&
name|XParseColor
argument_list|(
name|menu
operator|->
name|bghighlight
argument_list|,
operator|&
name|menu
operator|->
name|hlbg
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|menu
operator|->
name|hlbg
argument_list|)
operator|)
condition|)
block|{
name|menu
operator|->
name|hlfg
operator|.
name|pixel
operator|=
name|MTextBackground
expr_stmt|;
name|menu
operator|->
name|hlbg
operator|.
name|pixel
operator|=
name|MTextForground
expr_stmt|;
block|}
else|else
block|{
name|AdjustMaxColors
argument_list|(
name|menu
operator|->
name|hlfg
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|AdjustMaxColors
argument_list|(
name|menu
operator|->
name|hlbg
operator|.
name|pixel
argument_list|)
expr_stmt|;
block|}
comment|/*          * Get the menu item colors.          */
for|for
control|(
name|ml
operator|=
name|menu
operator|->
name|line
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ml
operator|->
name|foreground
operator|&&
name|ml
operator|->
name|background
operator|&&
name|MaxColors
operator|>
literal|1
operator|&&
name|XParseColor
argument_list|(
name|ml
operator|->
name|foreground
argument_list|,
operator|&
name|ml
operator|->
name|fg
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|ml
operator|->
name|fg
argument_list|)
operator|&&
name|XParseColor
argument_list|(
name|ml
operator|->
name|background
argument_list|,
operator|&
name|ml
operator|->
name|bg
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|ml
operator|->
name|bg
argument_list|)
operator|)
condition|)
block|{
name|ml
operator|->
name|fg
operator|.
name|pixel
operator|=
name|MTextForground
expr_stmt|;
name|ml
operator|->
name|bg
operator|.
name|pixel
operator|=
name|MTextBackground
expr_stmt|;
block|}
else|else
block|{
name|AdjustMaxColors
argument_list|(
name|ml
operator|->
name|fg
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|AdjustMaxColors
argument_list|(
name|ml
operator|->
name|bg
operator|.
name|pixel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*          * Only 2 colors available, so default to standard black and white.          */
name|menu
operator|->
name|fg
operator|.
name|pixel
operator|=
name|MTextForground
expr_stmt|;
name|menu
operator|->
name|bg
operator|.
name|pixel
operator|=
name|MTextBackground
expr_stmt|;
name|menu
operator|->
name|hlfg
operator|.
name|pixel
operator|=
name|MTextBackground
expr_stmt|;
name|menu
operator|->
name|hlbg
operator|.
name|pixel
operator|=
name|MTextForground
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|menu
operator|->
name|line
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
name|ml
operator|->
name|fg
operator|.
name|pixel
operator|=
name|MTextForground
expr_stmt|;
name|ml
operator|->
name|bg
operator|.
name|pixel
operator|=
name|MTextBackground
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Decrement "MaxColors" if this pixel value has never been used in a  * menu before.  */
end_comment

begin_macro
name|AdjustMaxColors
argument_list|(
argument|pixel
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pixel
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuLink
modifier|*
name|mptr
decl_stmt|;
specifier|register
name|MenuLine
modifier|*
name|lptr
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|mptr
operator|=
name|Menus
init|;
name|mptr
condition|;
name|mptr
operator|=
name|mptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mptr
operator|->
name|menu
operator|->
name|fg
operator|.
name|pixel
operator|==
name|pixel
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|mptr
operator|->
name|menu
operator|->
name|bg
operator|.
name|pixel
operator|==
name|pixel
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|mptr
operator|->
name|menu
operator|->
name|hlfg
operator|.
name|pixel
operator|==
name|pixel
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|mptr
operator|->
name|menu
operator|->
name|hlbg
operator|.
name|pixel
operator|==
name|pixel
condition|)
operator|++
name|count
expr_stmt|;
for|for
control|(
name|lptr
operator|=
name|mptr
operator|->
name|menu
operator|->
name|line
init|;
name|lptr
condition|;
name|lptr
operator|=
name|lptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lptr
operator|->
name|fg
operator|.
name|pixel
operator|==
name|pixel
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|lptr
operator|->
name|bg
operator|.
name|pixel
operator|==
name|pixel
condition|)
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
return|return;
block|}
operator|--
name|MaxColors
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set up the vertex list for the hi-liter.  */
end_comment

begin_macro
name|SetUpVlist
argument_list|(
argument|menu
argument_list|)
end_macro

begin_decl_stmt
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vlist
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|menu
operator|->
name|width
operator|-
literal|3
expr_stmt|;
name|vlist
index|[
literal|1
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|vlist
index|[
literal|2
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|vlist
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|menu
operator|->
name|iheight
operator|-
literal|3
expr_stmt|;
name|vlist
index|[
literal|3
index|]
operator|.
name|x
operator|=
call|(
name|short
call|)
argument_list|(
literal|0
operator|-
name|menu
operator|->
name|width
operator|+
literal|3
argument_list|)
expr_stmt|;
name|vlist
index|[
literal|3
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|vlist
index|[
literal|4
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|vlist
index|[
literal|4
index|]
operator|.
name|y
operator|=
call|(
name|short
call|)
argument_list|(
literal|0
operator|-
name|menu
operator|->
name|iheight
operator|+
literal|3
argument_list|)
expr_stmt|;
name|vlist
index|[
literal|1
index|]
operator|.
name|flags
operator|=
name|vlist
index|[
literal|2
index|]
operator|.
name|flags
operator|=
name|vlist
index|[
literal|3
index|]
operator|.
name|flags
operator|=
name|vlist
index|[
literal|4
index|]
operator|.
name|flags
operator|=
name|VertexRelative
expr_stmt|;
block|}
end_block

end_unit

