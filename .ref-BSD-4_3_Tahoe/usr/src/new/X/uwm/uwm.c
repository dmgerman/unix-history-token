begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_uwm_c
init|=
literal|"$Header: uwm.c,v 10.7 86/11/19 19:03:58 jg Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  *			COPYRIGHT 1985, 1986  *		   DIGITAL EQUIPMENT CORPORATION  *		       MAYNARD, MASSACHUSETTS  *			ALL RIGHTS RESERVED.  *  * THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE AND  * SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.  * DIGITAL MAKES NO REPRESENTATIONS ABOUT THE SUITIBILITY OF THIS SOFTWARE FOR  * ANY PURPOSE.  IT IS SUPPLIED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.  *  * IF THE SOFTWARE IS MODIFIED IN A MANNER CREATING DERIVATIVE COPYRIGHT RIGHTS,  * APPROPRIATE LEGENDS MAY BE PLACED ON THE DERIVATIVE WORK IN ADDITION TO THAT  * SET FORTH ABOVE.  *  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting documentation,  * and that the name of Digital Equipment Corporation not be used in advertising  * or publicity pertaining to distribution of the software without specific,   * written prior permission.  *  */
end_comment

begin_comment
comment|/*  * MODIFICATION HISTORY  *  * 000 -- M. Gancarz, DEC Ultrix Engineering Group  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)uwm.c	3.8	1/24/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"uwm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PROFIL
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  * Dummy handler for profiling.  */
end_comment

begin_macro
name|ptrap
argument_list|()
end_macro

begin_block
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_decl_stmt
specifier|static
name|short
name|gray_bits
index|[
literal|16
index|]
init|=
block|{
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Bool
name|ChkMline
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|sfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main program.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|environ
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
block|{
name|short
name|hi
decl_stmt|;
comment|/* Button event high detail. */
name|short
name|lo
decl_stmt|;
comment|/* Button event low detail. */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Mouse X and Y coordinates. */
name|int
name|cur_x
decl_stmt|,
name|cur_y
decl_stmt|;
comment|/* Current mouse X and Y coordinates. */
name|int
name|str_width
decl_stmt|;
comment|/* Width in pixels of output string. */
name|int
name|pop_width
decl_stmt|,
name|pop_height
decl_stmt|;
comment|/* Pop up window width and height. */
name|int
name|context
decl_stmt|;
comment|/* Root, window, or icon context. */
name|Bool
name|func_stat
decl_stmt|;
comment|/* If true, function swallowed a ButtonUp. */
name|Bool
name|delta_done
decl_stmt|;
comment|/* If true, then delta functions are done. */
specifier|register
name|Binding
modifier|*
name|bptr
decl_stmt|;
comment|/* Pointer to Bindings list. */
name|char
modifier|*
name|root_name
decl_stmt|;
comment|/* Root window name. */
name|char
modifier|*
name|display
init|=
name|NULL
decl_stmt|;
comment|/* Display name pointer. */
name|char
name|message
index|[
literal|128
index|]
decl_stmt|;
comment|/* Error message buffer. */
name|char
modifier|*
name|rc_file
decl_stmt|;
comment|/* Pointer to $HOME/.uwmrc. */
name|Bitmap
name|gray_bitmap
decl_stmt|;
comment|/* Gray bitmap used for gray pixmap. */
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/* Display info pointer. */
name|Window
name|event_win
decl_stmt|;
comment|/* Event window. */
name|Window
name|sub_win
decl_stmt|;
comment|/* Subwindow for XUpdateMouse calls. */
name|WindowInfo
name|root_info
decl_stmt|;
comment|/* Root window info. */
name|WindowInfo
name|event_info
decl_stmt|;
comment|/* Event window info. */
name|XButtonEvent
name|button_event
decl_stmt|;
comment|/* Button input event. */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|PROFIL
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|ptrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Set up internal defaults.      */
name|strcpy
argument_list|(
name|IFontName
argument_list|,
name|DEF_FONT
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|PFontName
argument_list|,
name|DEF_FONT
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|MFontName
argument_list|,
name|DEF_FONT
argument_list|)
expr_stmt|;
name|CursorFunc
operator|=
name|DEF_FUNC
expr_stmt|;
name|Delta
operator|=
name|DEF_DELTA
expr_stmt|;
name|IBorderWidth
operator|=
name|DEF_ICON_BORDER_WIDTH
expr_stmt|;
name|HIconPad
operator|=
name|DEF_ICON_PADDING
expr_stmt|;
name|VIconPad
operator|=
name|DEF_ICON_PADDING
expr_stmt|;
name|PBorderWidth
operator|=
name|DEF_POP_BORDER_WIDTH
expr_stmt|;
name|PPadding
operator|=
name|DEF_POP_PADDING
expr_stmt|;
name|MBorderWidth
operator|=
name|DEF_MENU_BORDER_WIDTH
expr_stmt|;
name|HMenuPad
operator|=
name|DEF_MENU_PADDING
expr_stmt|;
name|VMenuPad
operator|=
name|DEF_MENU_PADDING
expr_stmt|;
name|Volume
operator|=
name|DEF_VOLUME
expr_stmt|;
comment|/*      * Set XErrorFunction to be non-terminating.      */
name|XErrorHandler
argument_list|(
name|XError
argument_list|)
expr_stmt|;
comment|/*       * Parse the command line arguments.      */
name|Argv
operator|=
name|argv
expr_stmt|;
name|Environ
operator|=
name|environ
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-f"
argument_list|)
operator|)
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|0
operator|)
operator|||
operator|(
name|Startup_File
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
name|Usage
argument_list|()
expr_stmt|;
name|strncpy
argument_list|(
name|Startup_File
argument_list|,
operator|*
name|argv
argument_list|,
name|NAME_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|display
operator|=
operator|*
name|argv
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
comment|/*      * Initialize the default bindings.      */
name|InitBindings
argument_list|()
expr_stmt|;
comment|/*      * Read in and parse $HOME/.uwmrc, if it exists.      */
name|sfilename
operator|=
name|rc_file
operator|=
name|malloc
argument_list|(
name|NAME_LEN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rc_file
argument_list|,
literal|"%s/.uwmrc"
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|rc_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lineno
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
if|if
condition|(
name|Startup_File_Error
condition|)
name|Error
argument_list|(
literal|"Bad .uwmrc file...aborting"
argument_list|)
expr_stmt|;
block|}
comment|/*       * Read in and parse the startup file from the command line, if      * specified.      */
if|if
condition|(
name|Startup_File
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|sfilename
operator|=
name|Startup_File
expr_stmt|;
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|Startup_File
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cannot open startup file '%s'"
argument_list|,
name|Startup_File
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|Lineno
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
if|if
condition|(
name|Startup_File_Error
condition|)
name|Error
argument_list|(
literal|"Bad startup file...aborting"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Verify the menu bindings.      */
name|VerifyMenuBindings
argument_list|()
expr_stmt|;
if|if
condition|(
name|Startup_File_Error
condition|)
name|Error
argument_list|(
literal|"Bad startup file...aborting"
argument_list|)
expr_stmt|;
comment|/*       * Open the display.      */
if|if
condition|(
operator|(
name|dpy
operator|=
name|XOpenDisplay
argument_list|(
name|display
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open display '%s'\n"
argument_list|,
name|Argv
index|[
literal|0
index|]
argument_list|,
name|XDisplayName
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Force child processes to disinherit the TCP file descriptor.      * This helps shell commands forked and exec'ed from menus      * to work properly.      */
if|if
condition|(
operator|(
name|status
operator|=
name|fcntl
argument_list|(
name|dpyno
argument_list|()
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"uwm: child cannot disinherit TCP fd"
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"TCP file descriptor problems"
argument_list|)
expr_stmt|;
block|}
comment|/*      * If the root window has not been named, name it.      */
name|status
operator|=
name|XFetchName
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|root_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't fetch Root Window name string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_name
operator|==
name|NULL
condition|)
name|XStoreName
argument_list|(
name|RootWindow
argument_list|,
literal|" X Root Window "
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_name
condition|)
name|free
argument_list|(
name|root_name
argument_list|)
expr_stmt|;
comment|/*      * Gather information about the root window.      */
name|status
operator|=
name|XQueryWindow
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|root_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't acquire root window information from X server"
argument_list|)
expr_stmt|;
name|ScreenHeight
operator|=
name|root_info
operator|.
name|height
expr_stmt|;
comment|/* True height of entire screen */
name|ScreenWidth
operator|=
name|root_info
operator|.
name|width
expr_stmt|;
comment|/* True width of entire screen */
comment|/*      * Create and store the icon background pixmap.      */
name|gray_bitmap
operator|=
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
expr_stmt|;
name|GrayPixmap
operator|=
name|XMakePixmap
argument_list|(
name|gray_bitmap
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
comment|/*      * Set up icon window, icon cursor and pop-up window color parameters.      */
if|if
condition|(
name|Reverse
condition|)
block|{
name|IconCursorFunc
operator|=
name|GXcopyInverted
expr_stmt|;
name|IBorder
operator|=
name|WhitePixmap
expr_stmt|;
name|IBackground
operator|=
name|GrayPixmap
expr_stmt|;
name|ITextForground
operator|=
name|WhitePixel
expr_stmt|;
name|ITextBackground
operator|=
name|BlackPixel
expr_stmt|;
name|PBorder
operator|=
name|BlackPixmap
expr_stmt|;
name|PBackground
operator|=
name|WhitePixmap
expr_stmt|;
name|PTextForground
operator|=
name|BlackPixel
expr_stmt|;
name|PTextBackground
operator|=
name|WhitePixel
expr_stmt|;
name|MBorder
operator|=
name|WhitePixmap
expr_stmt|;
name|MBackground
operator|=
name|BlackPixmap
expr_stmt|;
name|MTextForground
operator|=
name|WhitePixel
expr_stmt|;
name|MTextBackground
operator|=
name|BlackPixel
expr_stmt|;
block|}
else|else
block|{
name|IconCursorFunc
operator|=
name|GXcopy
expr_stmt|;
name|IBorder
operator|=
name|BlackPixmap
expr_stmt|;
name|IBackground
operator|=
name|GrayPixmap
expr_stmt|;
name|ITextForground
operator|=
name|BlackPixel
expr_stmt|;
name|ITextBackground
operator|=
name|WhitePixel
expr_stmt|;
name|PBorder
operator|=
name|WhitePixmap
expr_stmt|;
name|PBackground
operator|=
name|BlackPixmap
expr_stmt|;
name|PTextForground
operator|=
name|WhitePixel
expr_stmt|;
name|PTextBackground
operator|=
name|BlackPixel
expr_stmt|;
name|MBorder
operator|=
name|BlackPixmap
expr_stmt|;
name|MBackground
operator|=
name|WhitePixmap
expr_stmt|;
name|MTextForground
operator|=
name|BlackPixel
expr_stmt|;
name|MTextBackground
operator|=
name|WhitePixel
expr_stmt|;
block|}
comment|/*      * Store all the cursors.      */
name|StoreCursors
argument_list|()
expr_stmt|;
comment|/*       * grab the mouse buttons according to the map structure      */
name|Grab_Buttons
argument_list|()
expr_stmt|;
comment|/*      * Load the selected fonts.      */
name|IFont
operator|=
name|XGetFont
argument_list|(
name|IFontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFont
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to get font '%s'."
argument_list|,
name|IFontName
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|PFont
operator|=
name|XGetFont
argument_list|(
name|PFontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|PFont
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to get font '%s'."
argument_list|,
name|PFontName
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|MFont
operator|=
name|XGetFont
argument_list|(
name|MFontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|MFont
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to get font '%s'."
argument_list|,
name|MFontName
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/*      * Retrieve the information structure for the specifed fonts and      * set the global font information pointers.      */
name|status
operator|=
name|XQueryFont
argument_list|(
name|IFont
argument_list|,
operator|&
name|IFontInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to query X server for info on font '%s'."
argument_list|,
name|IFontName
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|XQueryFont
argument_list|(
name|PFont
argument_list|,
operator|&
name|PFontInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to query X server for info on font '%s'."
argument_list|,
name|PFontName
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|XQueryFont
argument_list|(
name|MFont
argument_list|,
operator|&
name|MFontInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to query X server for info on font '%s'."
argument_list|,
name|MFontName
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/*      * Calculate size of the resize pop-up window.      */
name|str_width
operator|=
name|XQueryWidth
argument_list|(
name|PText
argument_list|,
name|PFont
argument_list|)
expr_stmt|;
name|pop_width
operator|=
name|str_width
operator|+
operator|(
name|PPadding
operator|<<
literal|1
operator|)
expr_stmt|;
name|PWidth
operator|=
name|pop_width
operator|+
operator|(
name|PBorderWidth
operator|<<
literal|1
operator|)
expr_stmt|;
name|pop_height
operator|=
name|PFontInfo
operator|.
name|height
operator|+
operator|(
name|PPadding
operator|<<
literal|1
operator|)
expr_stmt|;
name|PHeight
operator|=
name|pop_height
operator|+
operator|(
name|PBorderWidth
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/*      * Create the pop-up window.  Create it at (0, 0) for now.  We will      * move it where we want later.      */
name|Pop
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pop_width
argument_list|,
name|pop_height
argument_list|,
name|PBorderWidth
argument_list|,
name|PBorder
argument_list|,
name|PBackground
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pop
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't create pop-up dimension display window."
argument_list|)
expr_stmt|;
comment|/*      * Create the menus for later use.      */
name|CreateMenus
argument_list|()
expr_stmt|;
comment|/*      * Tell the user we're alive and well.      */
name|XFeep
argument_list|(
name|Volume
argument_list|)
expr_stmt|;
comment|/*       * Main command loop.      */
while|while
condition|(
name|TRUE
condition|)
block|{
name|delta_done
operator|=
name|func_stat
operator|=
name|FALSE
expr_stmt|;
comment|/*          * Get the next mouse button event.  Spin our wheels until          * a ButtonPressed event is returned.          * Note that mouse events within an icon window are handled          * in the "GetButton" function or by the icon's owner if          * it is not uwm.          */
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
name|GetButton
argument_list|(
operator|&
name|button_event
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|button_event
operator|.
name|type
operator|==
name|ButtonPressed
condition|)
break|break;
block|}
comment|/*          * Okay, determine the event window and mouse coordinates.          */
name|status
operator|=
name|XInterpretLocator
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|event_win
argument_list|,
name|button_event
operator|.
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
continue|continue;
comment|/*          * Determine the event window and context.          */
if|if
condition|(
name|event_win
operator|==
literal|0
condition|)
block|{
name|event_win
operator|=
name|RootWindow
expr_stmt|;
name|context
operator|=
name|ROOT
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|XQueryWindow
argument_list|(
name|event_win
argument_list|,
operator|&
name|event_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
continue|continue;
if|if
condition|(
name|event_info
operator|.
name|type
operator|&
name|IsIcon
condition|)
name|context
operator|=
name|ICON
expr_stmt|;
else|else
name|context
operator|=
name|WINDOW
expr_stmt|;
block|}
comment|/*          * Get the button event detail.          */
name|lo
operator|=
operator|(
name|button_event
operator|.
name|detail
operator|&
name|ValueMask
operator|)
expr_stmt|;
name|hi
operator|=
name|KeyMask
argument_list|(
name|button_event
operator|.
name|detail
argument_list|)
expr_stmt|;
comment|/*          * Determine which function was selected and invoke it.          */
for|for
control|(
name|bptr
operator|=
name|Blist
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bptr
operator|->
name|button
operator|!=
name|lo
operator|)
operator|||
operator|(
name|KeyMask
argument_list|(
name|bptr
operator|->
name|mask
argument_list|)
operator|!=
name|hi
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bptr
operator|->
name|context
operator|!=
name|context
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|bptr
operator|->
name|mask
operator|&
name|ButtonDown
operator|)
condition|)
continue|continue;
comment|/*              * Found a match! Invoke the function.              */
if|if
condition|(
call|(
modifier|*
name|bptr
operator|->
name|func
call|)
argument_list|(
name|event_win
argument_list|,
operator|(
name|int
operator|)
name|bptr
operator|->
name|mask
operator|&
operator|~
name|ButtonMods
argument_list|,
name|bptr
operator|->
name|button
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|bptr
operator|->
name|menu
argument_list|)
condition|)
block|{
name|func_stat
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/*          * If the function ate the ButtonUp event, then restart the loop.          */
if|if
condition|(
name|func_stat
condition|)
continue|continue;
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/*              * Wait for the next button event.              */
if|if
condition|(
name|XPending
argument_list|()
operator|&&
name|GetButton
argument_list|(
operator|&
name|button_event
argument_list|)
condition|)
block|{
comment|/*                  * If it's not a release of the same button that was pressed,                  * don't do the function bound to 'ButtonUp'.                  */
if|if
condition|(
name|button_event
operator|.
name|type
operator|!=
name|ButtonReleased
condition|)
break|break;
if|if
condition|(
name|lo
operator|!=
operator|(
name|button_event
operator|.
name|detail
operator|&
name|ValueMask
operator|)
condition|)
break|break;
if|if
condition|(
name|hi
operator|!=
name|KeyMask
argument_list|(
name|button_event
operator|.
name|detail
argument_list|)
condition|)
break|break;
comment|/*                  * Okay, determine the event window and mouse coordinates.                  */
name|status
operator|=
name|XInterpretLocator
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|event_win
argument_list|,
name|button_event
operator|.
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
break|break;
if|if
condition|(
name|event_win
operator|==
literal|0
condition|)
block|{
name|event_win
operator|=
name|RootWindow
expr_stmt|;
name|context
operator|=
name|ROOT
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|XQueryWindow
argument_list|(
name|event_win
argument_list|,
operator|&
name|event_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
break|break;
if|if
condition|(
name|event_info
operator|.
name|type
operator|&
name|IsIcon
condition|)
name|context
operator|=
name|ICON
expr_stmt|;
else|else
name|context
operator|=
name|WINDOW
expr_stmt|;
block|}
comment|/*                  * Determine which function was selected and invoke it.                  */
for|for
control|(
name|bptr
operator|=
name|Blist
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bptr
operator|->
name|button
operator|!=
name|lo
operator|)
operator|||
operator|(
name|KeyMask
argument_list|(
name|bptr
operator|->
name|mask
argument_list|)
operator|!=
name|hi
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bptr
operator|->
name|context
operator|!=
name|context
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|bptr
operator|->
name|mask
operator|&
name|ButtonUp
operator|)
condition|)
continue|continue;
comment|/*                      * Found a match! Invoke the function.                      */
call|(
modifier|*
name|bptr
operator|->
name|func
call|)
argument_list|(
name|event_win
argument_list|,
operator|(
name|int
operator|)
name|bptr
operator|->
name|mask
operator|&
operator|~
name|ButtonMods
argument_list|,
name|bptr
operator|->
name|button
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|bptr
operator|->
name|menu
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|XUpdateMouse
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|cur_x
argument_list|,
operator|&
name|cur_y
argument_list|,
operator|&
name|sub_win
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta_done
operator|&&
operator|(
operator|(
name|abs
argument_list|(
name|cur_x
operator|-
name|x
argument_list|)
operator|>
name|Delta
operator|)
operator|||
operator|(
name|abs
argument_list|(
name|cur_y
operator|-
name|y
argument_list|)
operator|>
name|Delta
operator|)
operator|)
condition|)
block|{
comment|/*                  * Delta functions are done once (and only once.)                  */
name|delta_done
operator|=
name|TRUE
expr_stmt|;
comment|/*                  * Determine the new event window's coordinates.                  */
name|status
operator|=
name|XInterpretLocator
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|event_win
argument_list|,
name|button_event
operator|.
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
break|break;
comment|/*                  * Determine the event window and context.                  */
if|if
condition|(
name|event_win
operator|==
literal|0
condition|)
block|{
name|event_win
operator|=
name|RootWindow
expr_stmt|;
name|context
operator|=
name|ROOT
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|XQueryWindow
argument_list|(
name|event_win
argument_list|,
operator|&
name|event_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
break|break;
if|if
condition|(
name|event_info
operator|.
name|type
operator|&
name|IsIcon
condition|)
name|context
operator|=
name|ICON
expr_stmt|;
else|else
name|context
operator|=
name|WINDOW
expr_stmt|;
block|}
comment|/*                  * Determine which function was selected and invoke it.                  */
for|for
control|(
name|bptr
operator|=
name|Blist
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bptr
operator|->
name|button
operator|!=
name|lo
operator|)
operator|||
operator|(
name|KeyMask
argument_list|(
name|bptr
operator|->
name|mask
argument_list|)
operator|!=
name|hi
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bptr
operator|->
name|context
operator|!=
name|context
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|bptr
operator|->
name|mask
operator|&
name|DeltaMotion
operator|)
condition|)
continue|continue;
comment|/*                      * Found a match! Invoke the function.                      */
if|if
condition|(
call|(
modifier|*
name|bptr
operator|->
name|func
call|)
argument_list|(
name|event_win
argument_list|,
operator|(
name|int
operator|)
name|bptr
operator|->
name|mask
operator|&
operator|~
name|ButtonMods
argument_list|,
name|bptr
operator|->
name|button
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|bptr
operator|->
name|menu
argument_list|)
condition|)
block|{
name|func_stat
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/*                  * If the function ate the ButtonUp event,                  * then restart the loop.                  */
if|if
condition|(
name|func_stat
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the default bindings.  First, write the character array  * out to a temp file, then point the parser to it and read it in.  * Afterwards, we unlink the temp file.  */
end_comment

begin_macro
name|InitBindings
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
name|char
modifier|*
name|tempfile
init|=
name|TEMPFILE
decl_stmt|;
comment|/* Temporary filename. */
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Temporary file pointer. */
specifier|register
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
comment|/* Default bindings string array pointer. */
comment|/*      * Create and write the temp file.      */
name|sfilename
operator|=
name|mktemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|tempfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"uwm: cannot create temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|DefaultBindings
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
block|{
name|fputs
argument_list|(
operator|*
name|ptr
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/*      * Read in the bindings from the temp file and parse them.      */
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|tempfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"uwm: cannot open temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Lineno
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Startup_File_Error
condition|)
name|Error
argument_list|(
literal|"Bad default bindings...aborting"
argument_list|)
expr_stmt|;
comment|/*      * Parse the system startup file, if one exists.      */
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|SYSFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sfilename
operator|=
name|SYSFILE
expr_stmt|;
name|Lineno
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
if|if
condition|(
name|Startup_File_Error
condition|)
name|Error
argument_list|(
literal|"Bad system startup file...aborting"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Verify menu bindings by checking that a menu that is mapped actually  * exists.  Stash a pointer in the binding to the relevant menu info data  * structure.  * Check nested menu consistency.  */
end_comment

begin_macro
name|VerifyMenuBindings
argument_list|()
end_macro

begin_block
block|{
name|Binding
modifier|*
name|bptr
decl_stmt|;
name|MenuLink
modifier|*
name|mptr
decl_stmt|;
for|for
control|(
name|bptr
operator|=
name|Blist
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bptr
operator|->
name|func
operator|==
name|Menu
condition|)
block|{
for|for
control|(
name|mptr
operator|=
name|Menus
init|;
name|mptr
condition|;
name|mptr
operator|=
name|mptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|bptr
operator|->
name|menuname
argument_list|,
name|mptr
operator|->
name|menu
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
name|bptr
operator|->
name|menu
operator|=
name|mptr
operator|->
name|menu
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mptr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uwm: non-existent menu reference: \"%s\"\n"
argument_list|,
name|bptr
operator|->
name|menuname
argument_list|)
expr_stmt|;
name|Startup_File_Error
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|CheckMenus
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check nested menu consistency by verifying that every menu line that  * calls another menu references a menu that actually exists.  */
end_comment

begin_macro
name|CheckMenus
argument_list|()
end_macro

begin_block
block|{
name|MenuLink
modifier|*
name|ptr
decl_stmt|;
name|Bool
name|errflag
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|Menus
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ChkMline
argument_list|(
name|ptr
operator|->
name|menu
argument_list|)
condition|)
name|errflag
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|errflag
condition|)
name|Error
argument_list|(
literal|"Nested menu inconsistency"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Bool
name|ChkMline
parameter_list|(
name|menu
parameter_list|)
name|MenuInfo
modifier|*
name|menu
decl_stmt|;
block|{
name|MenuLine
modifier|*
name|ptr
decl_stmt|;
name|MenuLink
modifier|*
name|lptr
decl_stmt|;
name|Bool
name|errflag
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|menu
operator|->
name|line
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|IsMenuFunction
condition|)
block|{
for|for
control|(
name|lptr
operator|=
name|Menus
init|;
name|lptr
condition|;
name|lptr
operator|=
name|lptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|ptr
operator|->
name|text
argument_list|,
name|lptr
operator|->
name|menu
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
name|ptr
operator|->
name|menu
operator|=
name|lptr
operator|->
name|menu
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lptr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uwm: non-existent menu reference: \"%s\"\n"
argument_list|,
name|ptr
operator|->
name|text
argument_list|)
expr_stmt|;
name|errflag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|errflag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grab the mouse buttons according to the bindings list.  */
end_comment

begin_macro
name|Grab_Buttons
argument_list|()
end_macro

begin_block
block|{
name|Binding
modifier|*
name|bptr
decl_stmt|;
for|for
control|(
name|bptr
operator|=
name|Blist
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
name|Grab
argument_list|(
name|bptr
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Grab a mouse button according to the given mask.  */
end_comment

begin_macro
name|Grab
argument_list|(
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|short
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|m
init|=
name|LeftMask
operator||
name|MiddleMask
operator||
name|RightMask
decl_stmt|;
switch|switch
condition|(
name|mask
operator|&
name|m
condition|)
block|{
case|case
name|LeftMask
case|:
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|LeftButtonCursor
argument_list|,
name|mask
operator|&
operator|~
name|ButtonMods
argument_list|,
name|EVENTMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't grab left mouse button."
argument_list|)
expr_stmt|;
break|break;
case|case
name|MiddleMask
case|:
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|MiddleButtonCursor
argument_list|,
name|mask
operator|&
operator|~
name|ButtonMods
argument_list|,
name|EVENTMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't grab middle mouse button."
argument_list|)
expr_stmt|;
break|break;
case|case
name|RightMask
case|:
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|RightButtonCursor
argument_list|,
name|mask
operator|&
operator|~
name|ButtonMods
argument_list|,
name|EVENTMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't grab right mouse button."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * error routine for .uwmrc parser  */
end_comment

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uwm: %s: %d: %s\n"
argument_list|,
name|sfilename
argument_list|,
name|Lineno
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Startup_File_Error
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print usage message and quit.  */
end_comment

begin_macro
name|Usage
argument_list|()
end_macro

begin_block
block|{
name|fputs
argument_list|(
literal|"Usage:  uwm [-f<file>] [<host>:<display>]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * error handler for X I/O errors  */
end_comment

begin_macro
name|XIOError
argument_list|(
argument|dsp
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dsp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|perror
argument_list|(
literal|"uwm"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

