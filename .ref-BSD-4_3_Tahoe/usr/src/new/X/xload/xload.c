begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright 1985, by the Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* xload -- graph load average on X window system display.  * K. Shane Hartman and Stuart A. Malone with ripoffs from xclock.  * Host name feature added by Jim Gettys.  * Scale feature added by Bob Scheifler.  * Rescale feature added by Stuart A. Malone.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xload_c
init|=
literal|"$Header: xload.c,v 10.13 86/11/30 14:59:08 jg Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_typedef
typedef|typedef
enum|enum
name|_bool
block|{
name|FALSE
block|,
name|TRUE
block|}
name|Bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|KMEM_FILE
value|"/dev/kmem"
end_define

begin_define
define|#
directive|define
name|KMEM_ERROR
value|"cannot open /dev/kmem"
end_define

begin_define
define|#
directive|define
name|DEFAULT_BORDER_WIDTH
value|3
end_define

begin_define
define|#
directive|define
name|DEFAULT_UPDATE
value|5
end_define

begin_comment
comment|/* Any smaller leads to lossage */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_FONT
value|"6x10"
end_define

begin_define
define|#
directive|define
name|DEFAULT_POSITION
value|"=360x120-0+0"
end_define

begin_comment
comment|/* upper right hand corner */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SCALE
value|1
end_define

begin_decl_stmt
name|struct
name|nlist
name|namelist
index|[]
init|=
block|{
comment|/* namelist for vmunix grubbing */
define|#
directive|define
name|LOADAV
value|0
block|{
literal|"_avenrun"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* GLOBAL */
end_comment

begin_decl_stmt
name|Window
name|win
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* load average window */
end_comment

begin_decl_stmt
name|double
name|data
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated load average data */
end_comment

begin_decl_stmt
name|int
name|background
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of background */
end_comment

begin_decl_stmt
name|int
name|foreground
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of graph */
end_comment

begin_decl_stmt
name|int
name|highlight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of text, scale */
end_comment

begin_decl_stmt
name|Font
name|font
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font for printing hostname */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fn
init|=
name|DEFAULT_FONT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font for hostname */
end_comment

begin_decl_stmt
name|FontInfo
name|font_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|host
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the host name */
end_comment

begin_decl_stmt
name|double
name|scale
init|=
name|DEFAULT_SCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* n divisions for graph */
end_comment

begin_decl_stmt
name|double
name|min_scale
init|=
name|DEFAULT_SCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum value for scale */
end_comment

begin_decl_stmt
name|double
name|max_loadavg
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum loadavg on the graph */
end_comment

begin_decl_stmt
name|int
name|mapped
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should really display? */
end_comment

begin_comment
comment|/* Diagnostic printer - Print message and exit */
end_comment

begin_function
name|void
name|xload_error
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xload: %s\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"xload"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Blts data according to current size, then redraws the load average window.  * Next represents the number of valid points in data.  Returns the (possibly)  * adjusted value of next.  If next is 0, this routine draws an empty window  * (scale - 1 lines for graph).  If next is less than the current window width,  * the returned value is identical to the initial value of next and data is  * unchanged.  Otherwise keeps half a window's worth of data.  If data is  * changed, then max_loadavg is updated to reflect the largest data point.  */
end_comment

begin_function
name|int
name|repaint_window
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|,
name|next
parameter_list|)
specifier|register
name|int
name|width
decl_stmt|,
name|height
decl_stmt|,
name|next
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|mapped
condition|)
name|XClear
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|width
condition|)
block|{
name|j
operator|=
name|width
operator|>>
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|next
operator|-
name|j
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|j
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|j
expr_stmt|;
comment|/* Since we just lost some data, recompute the max_loadavg. */
name|max_loadavg
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|>
name|max_loadavg
condition|)
name|max_loadavg
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Compute the minimum scale required to graph the data, but don't go        lower than min_scale. */
if|if
condition|(
name|max_loadavg
operator|>
name|min_scale
condition|)
name|scale
operator|=
operator|(
operator|(
name|int
operator|)
name|max_loadavg
operator|)
operator|+
literal|1
expr_stmt|;
else|else
name|scale
operator|=
name|min_scale
expr_stmt|;
if|if
condition|(
operator|!
name|mapped
condition|)
return|return
operator|(
name|next
operator|)
return|;
comment|/* Print hostname */
name|XTextMask
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|host
argument_list|,
name|strlen
argument_list|(
name|host
argument_list|)
argument_list|,
name|font
argument_list|,
name|highlight
argument_list|)
expr_stmt|;
comment|/* Draw graph reference lines */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|scale
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|i
operator|*
name|height
operator|)
operator|/
name|scale
expr_stmt|;
name|XLine
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
name|width
argument_list|,
name|j
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|highlight
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
block|}
comment|/* Draw data point lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next
condition|;
name|i
operator|++
control|)
name|XLine
argument_list|(
name|win
argument_list|,
name|i
argument_list|,
name|height
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|height
operator|-
operator|(
name|data
index|[
name|i
index|]
operator|*
name|height
operator|)
operator|/
name|scale
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Exit with message describing command line format */
end_comment

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: xload [-fn {font}] [-update {seconds}] [-scale {integer}] [-rv]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             [=[{width}][x{height}][{+-}{xoff}[{+-}{yoff}]]] [[{host}]:[{vs}]]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             [-fg {color}] [-bg {color}] [-hl {color}] [-bd {color}] [-bw {pixels}]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns pointer to first char in search which is also in what, else NULL. */
end_comment

begin_function
name|char
modifier|*
name|strscan
parameter_list|(
name|search
parameter_list|,
name|what
parameter_list|)
specifier|register
name|char
modifier|*
name|search
decl_stmt|;
specifier|register
name|char
modifier|*
name|what
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|len
operator|=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
operator|(
name|search
operator|++
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|what
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|--
name|search
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|kmem
decl_stmt|;
comment|/* kmem pointer */
specifier|register
name|double
name|loadavg
decl_stmt|;
comment|/* load average value */
name|long
name|loadavg_seek
decl_stmt|;
comment|/* offset to load average in kmem */
name|char
name|display
index|[
literal|256
index|]
decl_stmt|;
comment|/* will contain vs host */
name|int
name|vsnum
decl_stmt|;
comment|/* will contain vs number */
name|int
name|reverse
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|border_color
decl_stmt|;
name|char
modifier|*
name|fore_color
decl_stmt|;
name|char
modifier|*
name|back_color
decl_stmt|;
name|char
modifier|*
name|high_color
decl_stmt|;
name|int
name|border_pixmap
decl_stmt|;
name|int
name|border_width
init|=
name|DEFAULT_BORDER_WIDTH
decl_stmt|;
name|int
name|update
init|=
name|DEFAULT_UPDATE
decl_stmt|;
name|Color
name|cdef
decl_stmt|;
name|OpaqueFrame
name|window
decl_stmt|;
comment|/* frame for the window */
name|char
modifier|*
name|geometry
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|def
init|=
name|DEFAULT_POSITION
decl_stmt|;
comment|/* default position */
name|char
modifier|*
name|option
decl_stmt|;
name|XEvent
name|event
decl_stmt|;
name|int
name|maxfds
decl_stmt|;
comment|/* for select call */
name|int
name|readfds
decl_stmt|;
name|int
name|fdmask
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
comment|/* will contain update interval */
comment|/* Get name list. Then open kmem so we can seek for load average. */
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|namelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelist
index|[
name|LOADAV
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
name|xload_error
argument_list|(
literal|"cannot get name list"
argument_list|)
expr_stmt|;
name|loadavg_seek
operator|=
name|namelist
index|[
name|LOADAV
index|]
operator|.
name|n_value
expr_stmt|;
name|kmem
operator|=
name|open
argument_list|(
name|KMEM_FILE
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmem
operator|<
literal|0
condition|)
name|xload_error
argument_list|(
name|KMEM_ERROR
argument_list|)
expr_stmt|;
name|gethostname
argument_list|(
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Who are we? */
name|display
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ReverseVideo"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|reverse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BorderWidth"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|border_width
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BodyFont"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fn
operator|=
name|option
expr_stmt|;
if|if
condition|(
operator|(
name|border_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Border"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|border_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BorderColor"
argument_list|)
expr_stmt|;
name|back_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Background"
argument_list|)
expr_stmt|;
name|fore_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Foreground"
argument_list|)
expr_stmt|;
name|high_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Highlight"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Update"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|update
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Scale"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|min_scale
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Geometry"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|geometry
operator|=
name|option
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* Parse line */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|geometry
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|index
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* host:display */
name|strncpy
argument_list|(
name|display
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-rv"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-reverse"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* black on white */
name|reverse
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-forward"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* white on black */
name|reverse
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-bw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-border"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* border width */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|border_width
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fn"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-font"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* host name font */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|fn
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-bd"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-color"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* border color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|border_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fg"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-foreground"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* foreground color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|fore_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-bg"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-background"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* background color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|back_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-hl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-highlight"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* highlight color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|high_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-u"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-update"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* update interval */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|update
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-scale"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* load scale */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|min_scale
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|border_width
operator|<
literal|0
condition|)
name|border_width
operator|=
name|DEFAULT_BORDER_WIDTH
expr_stmt|;
if|if
condition|(
name|update
operator|<
name|DEFAULT_UPDATE
condition|)
name|update
operator|=
name|DEFAULT_UPDATE
expr_stmt|;
if|if
condition|(
name|min_scale
operator|<=
literal|0
condition|)
name|min_scale
operator|=
name|DEFAULT_SCALE
expr_stmt|;
name|scale
operator|=
name|min_scale
expr_stmt|;
comment|/* Open display  */
if|if
condition|(
operator|!
name|XOpenDisplay
argument_list|(
name|display
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open display '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|XDisplayName
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Need a font to print hostname in */
name|font
operator|=
name|XGetFont
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|font
condition|)
name|xload_error
argument_list|(
literal|"cannot open font"
argument_list|)
expr_stmt|;
name|XQueryFont
argument_list|(
name|font
argument_list|,
operator|&
name|font_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|border_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|border_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|border_pixmap
operator|=
name|XMakeTile
argument_list|(
name|cdef
operator|.
name|pixel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reverse
condition|)
name|border_pixmap
operator|=
name|WhitePixmap
expr_stmt|;
else|else
name|border_pixmap
operator|=
name|BlackPixmap
expr_stmt|;
if|if
condition|(
name|back_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|back_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|background
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
elseif|else
if|if
condition|(
name|reverse
condition|)
name|background
operator|=
name|BlackPixel
expr_stmt|;
else|else
name|background
operator|=
name|WhitePixel
expr_stmt|;
if|if
condition|(
name|fore_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|fore_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|foreground
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
elseif|else
if|if
condition|(
name|reverse
condition|)
name|foreground
operator|=
name|WhitePixel
expr_stmt|;
else|else
name|foreground
operator|=
name|BlackPixel
expr_stmt|;
if|if
condition|(
name|high_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|high_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|highlight
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
name|highlight
operator|=
name|foreground
expr_stmt|;
name|window
operator|.
name|bdrwidth
operator|=
name|border_width
expr_stmt|;
name|window
operator|.
name|border
operator|=
name|border_pixmap
expr_stmt|;
name|window
operator|.
name|background
operator|=
name|XMakeTile
argument_list|(
name|background
argument_list|)
expr_stmt|;
name|win
operator|=
name|XCreate
argument_list|(
literal|"Load Average"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|geometry
argument_list|,
name|def
argument_list|,
operator|&
name|window
argument_list|,
name|font_info
operator|.
name|width
operator|*
name|strlen
argument_list|(
name|host
argument_list|)
operator|+
literal|4
argument_list|,
name|font_info
operator|.
name|height
operator|+
literal|4
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|win
argument_list|,
name|ExposeWindow
operator||
name|UnmapWindow
argument_list|)
expr_stmt|;
name|XMapWindow
argument_list|(
name|win
argument_list|)
expr_stmt|;
comment|/* Map window to screen */
name|timeout
operator|.
name|tv_sec
operator|=
name|update
expr_stmt|;
comment|/* Set up timeout for select */
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|maxfds
operator|=
name|dpyno
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|/* Set up select arguments */
name|fdmask
operator|=
literal|1
operator|<<
name|dpyno
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Window is initially empty */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Main loop */
if|if
condition|(
name|XPending
argument_list|()
condition|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
name|mapped
operator|=
literal|1
expr_stmt|;
name|window
operator|.
name|width
operator|=
operator|(
operator|(
name|XExposeEvent
operator|*
operator|)
operator|&
name|event
operator|)
operator|->
name|width
expr_stmt|;
name|window
operator|.
name|height
operator|=
operator|(
operator|(
name|XExposeEvent
operator|*
operator|)
operator|&
name|event
operator|)
operator|->
name|height
expr_stmt|;
name|i
operator|=
name|repaint_window
argument_list|(
name|window
operator|.
name|width
argument_list|,
name|window
operator|.
name|height
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UnmapWindow
case|:
name|mapped
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|xload_error
argument_list|(
literal|"unexpected X event"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|window
operator|.
name|width
condition|)
name|i
operator|=
name|repaint_window
argument_list|(
name|window
operator|.
name|width
argument_list|,
name|window
operator|.
name|height
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Get the load average, stash the point and draw corresponding line. */
name|lseek
argument_list|(
name|kmem
argument_list|,
name|loadavg_seek
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
block|{
name|long
name|temp
decl_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|loadavg
operator|=
operator|(
name|double
operator|)
name|temp
operator|/
name|FSCALE
expr_stmt|;
block|}
else|#
directive|else
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|loadavg
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Keep max_loadavg up to date, and if this data point is off the 	   graph, change the scale to make it fit. */
if|if
condition|(
name|loadavg
operator|>
name|max_loadavg
condition|)
block|{
name|max_loadavg
operator|=
name|loadavg
expr_stmt|;
if|if
condition|(
name|max_loadavg
operator|>
name|scale
condition|)
block|{
name|scale
operator|=
operator|(
operator|(
name|int
operator|)
name|max_loadavg
operator|)
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|repaint_window
argument_list|(
name|window
operator|.
name|width
argument_list|,
name|window
operator|.
name|height
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|data
index|[
name|i
index|]
operator|=
name|loadavg
expr_stmt|;
if|if
condition|(
name|mapped
condition|)
block|{
name|XLine
argument_list|(
name|win
argument_list|,
name|i
argument_list|,
name|window
operator|.
name|height
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|window
operator|.
name|height
operator|-
operator|(
name|window
operator|.
name|height
operator|*
name|loadavg
operator|)
operator|/
name|scale
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
comment|/* Flush output buffers */
block|}
name|i
operator|++
expr_stmt|;
comment|/* Next point */
name|readfds
operator|=
name|fdmask
expr_stmt|;
comment|/* Initialize select mask */
comment|/* and select on display fd */
if|if
condition|(
name|select
argument_list|(
name|maxfds
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|xload_error
argument_list|(
literal|"select error on display file descriptor"
argument_list|)
expr_stmt|;
block|}
comment|/* while */
block|}
end_function

begin_comment
comment|/* main */
end_comment

end_unit

