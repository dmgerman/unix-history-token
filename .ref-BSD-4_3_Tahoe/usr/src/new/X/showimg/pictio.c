begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* read in image header information - if `headskip' flag is non-zero, read  * in that many words, leaving unaltered the input nrows and ncols  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"shimg.h"
end_include

begin_comment
comment|/* flag definitions */
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|HALFBOX
value|10
end_define

begin_function
name|short
modifier|*
name|readheader
parameter_list|(
name|fd
parameter_list|,
name|headskip
parameter_list|,
name|nrows
parameter_list|,
name|ncols
parameter_list|,
name|fitsflag
parameter_list|)
name|int
name|fd
decl_stmt|,
name|headskip
decl_stmt|,
name|fitsflag
decl_stmt|;
name|int
modifier|*
name|nrows
decl_stmt|,
decl|*
name|ncols
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
name|field
index|[
literal|80
index|]
decl_stmt|;
name|short
modifier|*
name|header
decl_stmt|;
name|int
name|headlen
init|=
literal|1536
decl_stmt|;
comment|/* standard SAO Nova CCD header length */
name|int
name|nbytes
decl_stmt|,
name|rfitscard
argument_list|()
decl_stmt|;
if|if
condition|(
name|headskip
condition|)
name|headlen
operator|=
name|headskip
expr_stmt|;
if|if
condition|(
name|fitsflag
condition|)
name|headlen
operator|=
name|FITSBUFLEN
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
name|headlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't malloc() memory for header!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|header
argument_list|,
name|headlen
argument_list|)
operator|)
operator|!=
name|headlen
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"?? Only %d bytes in header?\n"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* see if FITS decode necessary */
if|if
condition|(
name|fitsflag
condition|)
block|{
name|rfitsheader
argument_list|(
name|header
argument_list|,
name|ncols
argument_list|,
name|nrows
argument_list|)
expr_stmt|;
comment|/* skip past furthur header records until END card */
while|while
condition|(
name|rfitscard
argument_list|(
name|header
argument_list|,
literal|"END     "
argument_list|,
name|field
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|read
argument_list|(
name|fd
argument_list|,
name|header
argument_list|,
name|FITSBUFLEN
argument_list|)
expr_stmt|;
block|}
comment|/* pull the parameters from CCD style header */
elseif|else
if|if
condition|(
name|headskip
operator|==
literal|0
condition|)
block|{
operator|*
name|ncols
operator|=
name|header
index|[
literal|512
operator|+
literal|127
index|]
expr_stmt|;
operator|*
name|nrows
operator|=
name|header
index|[
literal|512
operator|+
literal|126
index|]
expr_stmt|;
block|}
return|return
operator|(
name|header
operator|)
return|;
block|}
end_block

begin_macro
name|rfitsheader
argument_list|(
argument|fitshead
argument_list|,
argument|ncols
argument_list|,
argument|nrows
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fitshead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ncols
decl_stmt|,
modifier|*
name|nrows
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sscanf
argument_list|()
decl_stmt|,
name|strlen
argument_list|()
decl_stmt|,
name|strncmp
argument_list|()
decl_stmt|,
name|strcmp
argument_list|()
decl_stmt|,
name|atoi
argument_list|()
decl_stmt|;
name|int
name|rfitscard
argument_list|()
decl_stmt|,
name|naxis
decl_stmt|;
name|char
name|field
index|[
literal|21
index|]
decl_stmt|;
name|rfitscard
argument_list|(
name|fitshead
argument_list|,
literal|"SIMPLE  "
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|field
argument_list|,
literal|"%s"
argument_list|,
name|field
argument_list|)
operator|!=
literal|1
condition|)
name|fitserror
argument_list|(
name|fitshead
argument_list|,
literal|"Malformed key field"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|field
argument_list|,
literal|"T"
argument_list|)
operator|!=
literal|0
condition|)
name|fitserror
argument_list|(
name|fitshead
argument_list|,
literal|"Only SIMPLE = T capability"
argument_list|)
expr_stmt|;
name|rfitscard
argument_list|(
name|fitshead
operator|+
literal|80
argument_list|,
literal|"BITPIX  "
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|field
argument_list|)
operator|!=
literal|16
condition|)
name|fitserror
argument_list|(
name|fitshead
operator|+
literal|80
argument_list|,
literal|"Only 16-bit images at this time"
argument_list|)
expr_stmt|;
name|rfitscard
argument_list|(
name|fitshead
operator|+
literal|160
argument_list|,
literal|"NAXIS   "
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|naxis
operator|=
name|atoi
argument_list|(
name|field
argument_list|)
operator|)
operator|<
literal|2
condition|)
name|fitserror
argument_list|(
name|fitshead
operator|+
literal|160
argument_list|,
literal|"NAXIS less than 2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|naxis
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** WARNING ** Only first 2 axes will be read. "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(naxis read was %d)\n"
argument_list|,
name|naxis
argument_list|)
expr_stmt|;
block|}
name|rfitscard
argument_list|(
name|fitshead
operator|+
literal|240
argument_list|,
literal|"NAXIS1  "
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ncols
operator|=
name|atoi
argument_list|(
name|field
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|fitserror
argument_list|(
name|fitshead
operator|+
literal|240
argument_list|,
literal|"NAXIS1 value error"
argument_list|)
expr_stmt|;
name|rfitscard
argument_list|(
name|fitshead
operator|+
literal|320
argument_list|,
literal|"NAXIS2  "
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|nrows
operator|=
name|atoi
argument_list|(
name|field
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|fitserror
argument_list|(
name|fitshead
operator|+
literal|240
argument_list|,
literal|"NAXIS2 value error"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rfitscard
argument_list|(
argument|cardbuf
argument_list|,
argument|keyword
argument_list|,
argument|keyfield
argument_list|,
argument|anywhere
argument_list|,
argument|fatal
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cardbuf
decl_stmt|,
modifier|*
name|keyword
decl_stmt|,
modifier|*
name|keyfield
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anywhere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if non-zero, search entire buffer for keyword */
end_comment

begin_decl_stmt
name|int
name|fatal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if non-zero, fatal if key not found */
end_comment

begin_block
block|{
name|char
name|errmsg
index|[
literal|80
index|]
decl_stmt|;
name|int
name|sscanf
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|anywhere
condition|?
name|FITSBUFLEN
else|:
literal|80
operator|)
condition|;
name|i
operator|+=
literal|80
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cardbuf
operator|+
name|i
argument_list|,
name|keyword
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sscanf
argument_list|(
name|cardbuf
operator|+
name|i
operator|+
literal|10
argument_list|,
literal|"%20c"
argument_list|,
name|keyfield
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|fatal
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"No `%s' keyword"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|fitserror
argument_list|(
name|cardbuf
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
comment|/* fatal error exit */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|fitserror
argument_list|(
argument|card
argument_list|,
argument|message
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|card
decl_stmt|,
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|card
index|[
literal|79
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FITS format error: %s\ncard is:\n%s\n"
argument_list|,
name|message
argument_list|,
name|card
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|short
modifier|*
name|readpict
parameter_list|(
name|fd
parameter_list|,
name|nrows
parameter_list|,
name|ncols
parameter_list|,
name|fitsflag
parameter_list|)
name|int
name|fd
decl_stmt|,
name|nrows
decl_stmt|,
name|ncols
decl_stmt|,
name|fitsflag
decl_stmt|;
block|{
name|short
modifier|*
name|picture
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|register
name|int
name|nbytes
init|=
name|nrows
operator|*
name|ncols
operator|*
literal|2
decl_stmt|;
specifier|register
name|int
name|nread
init|=
literal|0
decl_stmt|,
name|ntotal
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|pict
decl_stmt|;
if|if
condition|(
name|fitsflag
condition|)
name|nbytes
operator|=
operator|(
operator|(
name|nbytes
operator|/
name|FITSBUFLEN
operator|)
operator|+
operator|(
operator|(
name|nbytes
operator|%
name|FITSBUFLEN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
name|FITSBUFLEN
expr_stmt|;
if|if
condition|(
operator|(
name|pict
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't allocate picture memory!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|picture
operator|=
operator|(
name|short
operator|*
operator|)
name|pict
expr_stmt|;
if|if
condition|(
name|fitsflag
condition|)
block|{
comment|/* do successive reads until enough bytes */
while|while
condition|(
name|ntotal
operator|<
name|nbytes
condition|)
block|{
if|if
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|pict
argument_list|,
name|FITSBUFLEN
argument_list|)
operator|)
operator|!=
name|FITSBUFLEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad record of %d bytes read?\n"
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VAX
if|if
condition|(
name|fitsflag
operator|==
literal|1
condition|)
comment|/* do not swap bytes if disk fits format */
name|swab
argument_list|(
name|pict
argument_list|,
name|pict
argument_list|,
name|nread
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ntotal
operator|+=
name|nread
expr_stmt|;
name|pict
operator|+=
name|nread
expr_stmt|;
block|}
comment|/* read past EOF, if from tape */
if|if
condition|(
operator|(
name|pict
operator|=
name|malloc
argument_list|(
name|FITSBUFLEN
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
while|while
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|pict
argument_list|,
name|FITSBUFLEN
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|picture
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|!=
operator|(
name|nrows
operator|*
name|ncols
operator|)
operator|<<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"only %d bytes in picture?\n"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|picture
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VERY SIMPLE 16-bit to n-bit scaling for now. We assume we know a  * little something about the picture, so as get best contrast soonest.  */
end_comment

begin_macro
name|scalepict
argument_list|(
argument|byteimage
argument_list|,
argument|picture
argument_list|,
argument|pmaxval
argument_list|,
argument|pminval
argument_list|,
argument|ncolors
argument_list|,
argument|pixoffset
argument_list|,
argument|lshift
argument_list|,
argument|nrows
argument_list|,
argument|ncols
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|byteimage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|picture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmaxval
decl_stmt|,
name|pminval
decl_stmt|,
name|ncolors
decl_stmt|,
name|pixoffset
decl_stmt|,
name|lshift
decl_stmt|,
name|nrows
decl_stmt|,
name|ncols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|image
init|=
name|byteimage
decl_stmt|;
specifier|register
name|short
modifier|*
name|pict
init|=
name|picture
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|lookup
decl_stmt|;
specifier|register
name|int
name|npix
decl_stmt|;
specifier|register
name|int
name|pint
init|=
name|pmaxval
decl_stmt|;
specifier|register
name|int
name|pmin
init|=
name|pminval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|xpinterval
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|lookup
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|65536
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't allocate lookup table?\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|npix
operator|=
literal|0
init|;
name|npix
operator|<=
name|pmin
operator|+
literal|32768
condition|;
control|)
name|lookup
index|[
name|npix
operator|++
index|]
operator|=
name|pixoffset
expr_stmt|;
name|pmin
operator|=
name|pixoffset
operator|+
name|ncolors
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|npix
operator|=
name|pint
operator|+
literal|32768
init|;
name|npix
operator|<
literal|65536
condition|;
control|)
name|lookup
index|[
name|npix
operator|++
index|]
operator|=
name|pmin
expr_stmt|;
name|pmin
operator|=
name|MAX
argument_list|(
operator|-
literal|50
argument_list|,
name|pminval
argument_list|)
expr_stmt|;
comment|/* disallow large negative pixels */
if|if
condition|(
name|flags
operator|&
name|SOP_Linear
condition|)
block|{
comment|/* disallow large positive pixels here, too */
name|pint
operator|=
name|MIN
argument_list|(
literal|1000
operator|+
name|pmin
argument_list|,
name|pint
argument_list|)
expr_stmt|;
name|pint
operator|=
operator|(
name|pint
operator|-
name|pmin
operator|)
operator|/
name|ncolors
expr_stmt|;
comment|/* reus as interval measure */
comment|/* code added by egm */
name|pint
operator|=
name|MAX
argument_list|(
name|pint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* end of egm code */
name|ncolors
operator|--
expr_stmt|;
for|for
control|(
name|npix
operator|=
name|pmin
init|;
name|npix
operator|<=
name|pmaxval
condition|;
name|npix
operator|++
control|)
name|lookup
index|[
name|npix
operator|+
literal|32768
index|]
operator|=
operator|(
name|MIN
argument_list|(
name|ncolors
argument_list|,
operator|(
name|npix
operator|-
name|pmin
operator|)
operator|/
name|pint
argument_list|)
operator|<<
name|lshift
operator|)
operator|+
name|pixoffset
expr_stmt|;
block|}
comment|/* a little work will generalize this to logarithmic mapping */
elseif|else
if|if
condition|(
name|flags
operator|&
name|SOP_Sqrt
condition|)
block|{
name|xpinterval
operator|=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|pint
operator|-
name|pmin
argument_list|)
argument_list|)
operator|/
operator|(
name|double
operator|)
name|ncolors
expr_stmt|;
name|ncolors
operator|--
expr_stmt|;
for|for
control|(
name|npix
operator|=
name|pmin
init|;
name|npix
operator|<=
name|pmaxval
condition|;
name|npix
operator|++
control|)
block|{
name|pint
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|npix
operator|-
name|pmin
argument_list|)
argument_list|)
operator|/
name|xpinterval
operator|)
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|lookup
index|[
name|npix
operator|+
literal|32768
index|]
operator|=
name|MIN
argument_list|(
name|ncolors
argument_list|,
name|pint
operator|<<
name|lshift
argument_list|)
operator|+
name|pixoffset
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown scaling type request!\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lookup
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|npix
operator|=
name|nrows
operator|*
name|ncols
expr_stmt|;
name|image
operator|=
name|byteimage
expr_stmt|;
name|pict
operator|=
name|picture
expr_stmt|;
while|while
condition|(
name|npix
operator|--
condition|)
operator|*
name|image
operator|++
operator|=
operator|*
operator|(
name|lookup
operator|+
operator|*
name|pict
operator|++
operator|+
literal|32768
operator|)
expr_stmt|;
name|free
argument_list|(
name|lookup
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* return max, min of data in picture (approximately - sample areas likely  * to be of interest.  */
end_comment

begin_macro
name|maxminpict
argument_list|(
argument|picture
argument_list|,
argument|nrows
argument_list|,
argument|ncols
argument_list|,
argument|pmaxval
argument_list|,
argument|pminval
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|picture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrows
decl_stmt|,
name|ncols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pmaxval
decl_stmt|,
modifier|*
name|pminval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURNED */
end_comment

begin_block
block|{
specifier|register
name|short
modifier|*
name|pict
init|=
name|picture
decl_stmt|;
specifier|register
name|int
name|npix
decl_stmt|;
specifier|register
name|int
name|pmax
init|=
operator|-
literal|32768
decl_stmt|,
name|pmin
init|=
literal|32767
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|ncols
operator|*
name|nrows
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ncols
operator|/
literal|8
init|;
name|i
operator|<
operator|(
literal|7
operator|*
name|ncols
operator|)
operator|/
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
operator|(
literal|7
operator|*
name|ncols
operator|*
name|nrows
operator|)
operator|/
literal|8
operator|+
operator|(
name|ncols
operator|>>
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|nrows
operator|*
name|ncols
operator|/
literal|8
operator|)
operator|+
operator|(
name|ncols
operator|>>
literal|1
operator|)
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|+=
name|ncols
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|j
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
comment|/* find min,max from 5 regions (center, 4 areas around it) */
for|for
control|(
name|i
operator|=
name|ncols
operator|/
literal|2
operator|-
name|HALFBOX
init|;
name|i
operator|<
name|ncols
operator|/
literal|2
operator|+
name|HALFBOX
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|nrows
operator|/
literal|8
operator|-
name|HALFBOX
init|;
name|j
operator|<
name|nrows
operator|/
literal|8
operator|+
name|HALFBOX
condition|;
name|j
operator|++
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|j
operator|*
name|ncols
operator|+
name|i
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|nrows
operator|/
literal|2
operator|-
name|HALFBOX
init|;
name|j
operator|<
name|nrows
operator|/
literal|2
operator|+
name|HALFBOX
condition|;
name|j
operator|++
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|j
operator|*
name|ncols
operator|+
name|i
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|7
operator|*
name|nrows
operator|/
literal|8
operator|-
name|HALFBOX
init|;
name|j
operator|<
literal|7
operator|*
name|nrows
operator|/
literal|8
operator|+
name|HALFBOX
condition|;
name|j
operator|++
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|j
operator|*
name|ncols
operator|+
name|i
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
name|nrows
operator|/
literal|2
operator|-
name|HALFBOX
init|;
name|j
operator|<
name|nrows
operator|/
literal|2
operator|+
name|HALFBOX
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
name|ncols
operator|/
literal|8
operator|-
name|HALFBOX
init|;
name|i
operator|<
name|ncols
operator|/
literal|8
operator|+
name|HALFBOX
condition|;
name|i
operator|++
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|j
operator|*
name|ncols
operator|+
name|i
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|7
operator|*
name|nrows
operator|/
literal|8
operator|-
name|HALFBOX
init|;
name|i
operator|<
literal|7
operator|*
name|ncols
operator|/
literal|8
operator|+
name|HALFBOX
condition|;
name|i
operator|++
control|)
block|{
name|npix
operator|=
name|pict
index|[
name|j
operator|*
name|ncols
operator|+
name|i
index|]
expr_stmt|;
name|pmax
operator|=
name|MAX
argument_list|(
name|pmax
argument_list|,
name|npix
argument_list|)
expr_stmt|;
name|pmin
operator|=
name|MIN
argument_list|(
name|pmin
argument_list|,
name|npix
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*	printf("pixel range is %d to %d\n",pmin,pmax);  */
operator|*
name|pminval
operator|=
name|pmin
expr_stmt|;
operator|*
name|pmaxval
operator|=
name|pmax
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* print out a piece of the picture */
end_comment

begin_comment
comment|/*   * We really shoud use the environment to get the reverse video  * escape sequence. Oh well....  */
end_comment

begin_macro
name|prpict
argument_list|(
argument|pict
argument_list|,
argument|wx
argument_list|,
argument|wy
argument_list|,
argument|xzero
argument_list|,
argument|yzero
argument_list|,
argument|ncols
argument_list|,
argument|nrows
argument_list|,
argument|npcol
argument_list|,
argument|nprow
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|pict
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wx
decl_stmt|,
name|wy
decl_stmt|,
name|xzero
decl_stmt|,
name|yzero
decl_stmt|,
name|ncols
decl_stmt|,
name|nrows
decl_stmt|,
name|npcol
decl_stmt|,
name|nprow
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nRow %d, Col %d:\n\n       "
argument_list|,
name|wy
operator|+
name|yzero
argument_list|,
name|wx
operator|+
name|xzero
argument_list|)
expr_stmt|;
name|i
operator|=
name|MIN
argument_list|(
name|ncols
operator|-
name|npcol
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|wx
operator|+
name|xzero
operator|-
name|npcol
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|i
operator|+
name|npcol
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|==
name|wx
operator|+
name|xzero
condition|)
name|printf
argument_list|(
literal|"  %c[7m%4d%c[0m"
argument_list|,
literal|27
argument_list|,
name|k
argument_list|,
literal|27
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %4d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n       "
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|i
operator|+
name|npcol
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"  ----"
argument_list|)
expr_stmt|;
name|j
operator|=
name|MIN
argument_list|(
name|nrows
operator|-
name|nprow
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|wy
operator|+
name|yzero
operator|-
name|nprow
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|j
operator|+
name|nprow
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|==
name|wy
operator|+
name|yzero
condition|)
name|printf
argument_list|(
literal|"\n %c[7m%4d%c[0m |"
argument_list|,
literal|27
argument_list|,
name|k
argument_list|,
literal|27
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n%5d |"
argument_list|,
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|i
init|;
name|l
operator|<
name|i
operator|+
name|npcol
condition|;
name|l
operator|++
control|)
if|if
condition|(
operator|(
name|l
operator|==
name|wx
operator|+
name|xzero
operator|)
operator|&&
operator|(
name|k
operator|==
name|wy
operator|+
name|yzero
operator|)
condition|)
name|printf
argument_list|(
literal|" %c[7m%5d%c[0m"
argument_list|,
literal|27
argument_list|,
name|pict
index|[
name|k
operator|*
name|ncols
operator|+
name|l
index|]
argument_list|,
literal|27
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%6d"
argument_list|,
name|pict
index|[
name|k
operator|*
name|ncols
operator|+
name|l
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

