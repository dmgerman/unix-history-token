begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/*	Routines to calculate how rectangles overlap and abut:  *  *	Calc_overlaps, Do_overlap,  *	Clip_raster, Clip_rectangle, Rec_intersection,  *	Merge_vertical, Merge_rectangles  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_overlap_c
init|=
literal|"$Header: overlap.c,v 10.6 86/02/01 15:16:58 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"Xint.h"
end_include

begin_decl_stmt
specifier|extern
name|RECTANGLE
modifier|*
name|free_rectangles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RECTANGLE
modifier|*
modifier|*
name|Do_overlap
argument_list|()
decl_stmt|,
modifier|*
name|Alloc_rectangle
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calc_overlaps figures out how raster rast overlaps rectangles rects and  * recreates in rects a list of the maximally wide visible rectangles.  * It returns 0 if no overlap, 1 if overlap.  */
end_comment

begin_function
name|int
name|Calc_overlaps
parameter_list|(
name|rast
parameter_list|,
name|rects
parameter_list|)
specifier|register
name|RASTER
modifier|*
name|rast
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
modifier|*
name|rects
decl_stmt|;
block|{
specifier|register
name|RECTANGLE
modifier|*
name|rbot
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|obscured
decl_stmt|;
name|obscured
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|rects
expr_stmt|;
comment|/* Go through the bottom rectangles and see which are obscured */
while|while
condition|(
name|rbot
operator|=
operator|*
name|prev
condition|)
block|{
if|if
condition|(
name|rast
operator|->
name|left
operator|>=
name|rbot
operator|->
name|right
operator|||
name|rbot
operator|->
name|left
operator|>=
name|rast
operator|->
name|right
operator|||
name|rast
operator|->
name|top
operator|>=
name|rbot
operator|->
name|bottom
operator|||
name|rbot
operator|->
name|top
operator|>=
name|rast
operator|->
name|bottom
condition|)
block|{
name|prev
operator|=
operator|&
name|rbot
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|Do_overlap
argument_list|(
name|rast
argument_list|,
name|prev
argument_list|,
name|rects
argument_list|)
expr_stmt|;
name|FREERECT
argument_list|(
name|rbot
argument_list|)
expr_stmt|;
name|obscured
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|obscured
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do_overlap figures out how raster front overlaps rectangle *prev and  * replaces *prev in recs with a list of the maximally wide visible  * rectangles.  Returns an updated list pointer that points to *prev->next.  */
end_comment

begin_function
name|RECTANGLE
modifier|*
modifier|*
name|Do_overlap
parameter_list|(
name|front
parameter_list|,
name|prev
parameter_list|,
name|recs
parameter_list|)
specifier|register
name|RASTER
modifier|*
name|front
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
modifier|*
name|prev
decl_stmt|;
name|RECTANGLE
modifier|*
modifier|*
name|recs
decl_stmt|;
block|{
specifier|register
name|RECTANGLE
modifier|*
name|back
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|overlap
decl_stmt|;
name|back
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|back
operator|->
name|next
expr_stmt|;
name|overlap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|front
operator|->
name|right
operator|<
name|back
operator|->
name|right
condition|)
name|overlap
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|front
operator|->
name|left
operator|>
name|back
operator|->
name|left
condition|)
name|overlap
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|front
operator|->
name|bottom
operator|<
name|back
operator|->
name|bottom
condition|)
name|overlap
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|front
operator|->
name|top
operator|>
name|back
operator|->
name|top
condition|)
name|overlap
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|overlap
condition|)
block|{
case|case
literal|0
case|:
comment|/* Top completely covers bottom */
goto|goto
name|done
goto|;
comment|/* In the next four cases the bottom shows in one rectangle. */
case|case
literal|1
case|:
comment|/* Back peeks out on top */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ...on bottom */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* ...on left */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|back
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|refind
goto|;
break|break;
case|case
literal|8
case|:
comment|/* ...on right */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|back
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|refind
goto|;
break|break;
comment|/* Now we have the cases where there are 2 rectangles */
case|case
literal|3
case|:
comment|/* ...on top& bottom */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* ...on top& left */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|6
case|:
comment|/* ...on bottom& left */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|9
case|:
comment|/* ...on top& right */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|10
case|:
comment|/* ...on bottom& right */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|12
case|:
comment|/* ...on left& right */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|back
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* refind insertion point */
name|prev
operator|=
name|recs
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
operator|*
name|prev
operator|)
operator|!=
name|back
condition|)
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|refind
goto|;
block|}
else|else
block|{
name|r
operator|->
name|next
operator|=
name|back
operator|->
name|next
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
break|break;
comment|/* Now the cases where there are 3 rectangles */
case|case
literal|7
case|:
comment|/* ...top, bottom,& left */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* ...top, bottom,& right */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* ...top, left,& right */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if FALSE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
block|}
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|14
case|:
comment|/* ...left, right,& bottom */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if FALSE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|r
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
block|}
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|Merge_vertical
argument_list|(
name|r
argument_list|,
name|recs
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
comment|/* And the case where there are 4 rectangles */
case|case
literal|15
case|:
comment|/* ...left, right, top,& bottom */
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|back
operator|->
name|top
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|front
operator|->
name|left
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|front
operator|->
name|right
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|top
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|NEWRECT
argument_list|(
name|r
argument_list|,
name|back
operator|->
name|left
argument_list|,
name|back
operator|->
name|right
argument_list|,
name|front
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|bottom
argument_list|,
name|back
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|r
operator|->
name|next
operator|=
name|back
operator|->
name|next
expr_stmt|;
operator|*
name|prev
operator|=
name|r
expr_stmt|;
return|return
operator|(
operator|&
name|r
operator|->
name|next
operator|)
return|;
name|refind
label|:
comment|/* refind insertion point */
name|prev
operator|=
name|recs
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
operator|*
name|prev
operator|)
operator|!=
name|back
condition|)
name|prev
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
operator|*
name|prev
operator|=
name|back
operator|->
name|next
expr_stmt|;
name|done
label|:
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clip_raster modifies raster1 so that it all fits in raster2.  */
end_comment

begin_expr_stmt
name|Clip_raster
argument_list|(
name|rast1
argument_list|,
name|rast2
argument_list|)
specifier|register
name|RASTER
operator|*
name|rast1
operator|,
operator|*
name|rast2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|rast1
operator|->
name|right
operator|>
name|rast2
operator|->
name|right
condition|)
name|rast1
operator|->
name|right
operator|=
name|rast2
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|rast1
operator|->
name|left
operator|<
name|rast2
operator|->
name|left
condition|)
name|rast1
operator|->
name|left
operator|=
name|rast2
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|rast1
operator|->
name|bottom
operator|>
name|rast2
operator|->
name|bottom
condition|)
name|rast1
operator|->
name|bottom
operator|=
name|rast2
operator|->
name|bottom
expr_stmt|;
if|if
condition|(
name|rast1
operator|->
name|top
operator|<
name|rast2
operator|->
name|top
condition|)
name|rast1
operator|->
name|top
operator|=
name|rast2
operator|->
name|top
expr_stmt|;
if|if
condition|(
name|rast1
operator|->
name|left
operator|>=
name|rast1
operator|->
name|right
operator|||
name|rast1
operator|->
name|top
operator|>=
name|rast1
operator|->
name|bottom
condition|)
block|{
name|rast1
operator|->
name|right
operator|=
name|rast1
operator|->
name|left
expr_stmt|;
name|rast1
operator|->
name|bottom
operator|=
name|rast1
operator|->
name|top
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Rec_intersection returns a rectangle which is the intersection of its  * 2 arguments.  If they don't interesect, it returns NULL.  */
end_comment

begin_function
name|RECTANGLE
modifier|*
name|Rec_intersection
parameter_list|(
name|rec1
parameter_list|,
name|rec2
parameter_list|)
specifier|register
name|RECTANGLE
modifier|*
name|rec1
decl_stmt|,
decl|*
name|rec2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
name|l
operator|=
name|max
argument_list|(
name|rec1
operator|->
name|left
argument_list|,
name|rec2
operator|->
name|left
argument_list|)
expr_stmt|;
name|r
operator|=
name|min
argument_list|(
name|rec1
operator|->
name|right
argument_list|,
name|rec2
operator|->
name|right
argument_list|)
expr_stmt|;
name|t
operator|=
name|max
argument_list|(
name|rec1
operator|->
name|top
argument_list|,
name|rec2
operator|->
name|top
argument_list|)
expr_stmt|;
name|b
operator|=
name|min
argument_list|(
name|rec1
operator|->
name|bottom
argument_list|,
name|rec2
operator|->
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|r
operator|||
name|t
operator|>=
name|b
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|NEWRECT
argument_list|(
name|rec1
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|t
argument_list|,
name|b
argument_list|,
name|new_rec
argument_list|)
expr_stmt|;
return|return
operator|(
name|rec1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Clips a rectangle to fit in a raster.  Returns 0 if part of the rectangle  * is inside, else frees the rectangle and returns 1.  */
end_comment

begin_function
name|int
name|Clip_rectangle
parameter_list|(
name|rect
parameter_list|,
name|rast
parameter_list|)
specifier|register
name|RECTANGLE
modifier|*
name|rect
decl_stmt|;
specifier|register
name|RASTER
modifier|*
name|rast
decl_stmt|;
block|{
if|if
condition|(
name|rect
operator|->
name|left
operator|<
name|rast
operator|->
name|left
condition|)
name|rect
operator|->
name|left
operator|=
name|rast
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|rect
operator|->
name|right
operator|>
name|rast
operator|->
name|right
condition|)
name|rect
operator|->
name|right
operator|=
name|rast
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|rect
operator|->
name|top
operator|<
name|rast
operator|->
name|top
condition|)
name|rect
operator|->
name|top
operator|=
name|rast
operator|->
name|top
expr_stmt|;
if|if
condition|(
name|rect
operator|->
name|bottom
operator|>
name|rast
operator|->
name|bottom
condition|)
name|rect
operator|->
name|bottom
operator|=
name|rast
operator|->
name|bottom
expr_stmt|;
if|if
condition|(
name|rect
operator|->
name|left
operator|<
name|rect
operator|->
name|right
operator|&&
name|rect
operator|->
name|top
operator|<
name|rect
operator|->
name|bottom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|FREERECT
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge_vertical tries to find a rectangle in the list that abuts above or  * below with rec, and merges rec into it.  If bothsides is non-zero, the  * merge might allow a further merge with an existing rectangle in the list,  * and if so, the earlier rectangle is merged into the later rectangle in  * the list.  Returns 1 if a merge was made, else 0.  */
end_comment

begin_expr_stmt
name|Merge_vertical
argument_list|(
name|rec
argument_list|,
name|list
argument_list|,
name|bothsides
argument_list|)
specifier|register
name|RECTANGLE
operator|*
name|rec
operator|,
operator|*
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|bothsides
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|rec
operator|->
name|type
operator|&&
name|r
operator|->
name|left
operator|==
name|rec
operator|->
name|left
operator|&&
name|r
operator|->
name|right
operator|==
name|rec
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|top
operator|==
name|rec
operator|->
name|bottom
condition|)
block|{
name|r
operator|->
name|top
operator|=
name|rec
operator|->
name|top
expr_stmt|;
name|FREERECT
argument_list|(
name|rec
argument_list|)
expr_stmt|;
if|if FALSE
condition|(
name|bothsides
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|bottom
operator|==
name|rec
operator|->
name|top
condition|)
block|{
name|r
operator|->
name|bottom
operator|=
name|rec
operator|->
name|bottom
expr_stmt|;
name|FREERECT
argument_list|(
name|rec
argument_list|)
expr_stmt|;
if|if FALSE
condition|(
name|bothsides
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|r
operator|->
name|next
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rec
operator|=
name|r
expr_stmt|;
while|while
condition|(
name|r
operator|=
name|r
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|rec
operator|->
name|type
operator|&&
name|r
operator|->
name|left
operator|==
name|rec
operator|->
name|left
operator|&&
name|r
operator|->
name|right
operator|==
name|rec
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|top
operator|==
name|rec
operator|->
name|bottom
condition|)
name|r
operator|->
name|top
operator|=
name|rec
operator|->
name|top
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|bottom
operator|==
name|rec
operator|->
name|top
condition|)
name|r
operator|->
name|bottom
operator|=
name|rec
operator|->
name|bottom
expr_stmt|;
else|else
continue|continue;
while|while
condition|(
operator|(
name|r
operator|=
operator|*
name|list
operator|)
operator|!=
name|rec
condition|)
name|list
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
operator|*
name|list
operator|=
name|rec
operator|->
name|next
expr_stmt|;
name|FREERECT
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Merge_rectangles merges one list of rectangles into another.  It may also  * resize rectangles to get wide rather than tall rectangles.  It makes  * multiple passes since doing some merges may enable others to be made.  * Since the lists might be long, you would think sorting would help, but  * sorting actually seems to run slower.  */
end_comment

begin_expr_stmt
name|Merge_rectangles
argument_list|(
name|r1
argument_list|,
name|recs
argument_list|)
specifier|register
name|RECTANGLE
operator|*
name|r1
operator|,
operator|*
operator|*
name|recs
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r2
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|prev
operator|=
name|recs
expr_stmt|;
while|while
condition|(
name|r2
operator|=
operator|*
name|prev
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|type
operator|!=
name|r2
operator|->
name|type
condition|)
block|{
name|prev
operator|=
operator|&
name|r2
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r1
operator|->
name|top
operator|==
name|r2
operator|->
name|top
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|right
operator|==
name|r2
operator|->
name|left
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|bottom
operator|==
name|r2
operator|->
name|bottom
condition|)
block|{
name|r1
operator|->
name|right
operator|=
name|r2
operator|->
name|right
expr_stmt|;
goto|goto
name|free
goto|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|bottom
operator|<
name|r2
operator|->
name|bottom
condition|)
block|{
name|r1
operator|->
name|right
operator|=
name|r2
operator|->
name|right
expr_stmt|;
name|r2
operator|->
name|top
operator|=
name|r1
operator|->
name|bottom
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
else|else
block|{
name|r1
operator|->
name|top
operator|=
name|r2
operator|->
name|bottom
expr_stmt|;
name|r2
operator|->
name|left
operator|=
name|r1
operator|->
name|left
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|left
operator|==
name|r2
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|bottom
operator|==
name|r2
operator|->
name|bottom
condition|)
block|{
name|r1
operator|->
name|left
operator|=
name|r2
operator|->
name|left
expr_stmt|;
goto|goto
name|free
goto|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|bottom
operator|<
name|r2
operator|->
name|bottom
condition|)
block|{
name|r1
operator|->
name|left
operator|=
name|r2
operator|->
name|left
expr_stmt|;
name|r2
operator|->
name|top
operator|=
name|r1
operator|->
name|bottom
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
else|else
block|{
name|r1
operator|->
name|top
operator|=
name|r2
operator|->
name|bottom
expr_stmt|;
name|r2
operator|->
name|right
operator|=
name|r1
operator|->
name|right
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|bottom
operator|==
name|r2
operator|->
name|bottom
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|right
operator|==
name|r2
operator|->
name|left
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|top
operator|<
name|r2
operator|->
name|top
condition|)
block|{
name|r2
operator|->
name|left
operator|=
name|r1
operator|->
name|left
expr_stmt|;
name|r1
operator|->
name|bottom
operator|=
name|r2
operator|->
name|top
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
else|else
block|{
name|r1
operator|->
name|right
operator|=
name|r2
operator|->
name|right
expr_stmt|;
name|r2
operator|->
name|bottom
operator|=
name|r1
operator|->
name|top
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|left
operator|==
name|r2
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|top
operator|<
name|r2
operator|->
name|top
condition|)
block|{
name|r2
operator|->
name|right
operator|=
name|r1
operator|->
name|right
expr_stmt|;
name|r1
operator|->
name|bottom
operator|=
name|r2
operator|->
name|top
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
else|else
block|{
name|r1
operator|->
name|left
operator|=
name|r2
operator|->
name|left
expr_stmt|;
name|r2
operator|->
name|bottom
operator|=
name|r1
operator|->
name|top
expr_stmt|;
goto|goto
name|remerge
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|left
operator|==
name|r2
operator|->
name|left
operator|&&
name|r1
operator|->
name|right
operator|==
name|r2
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|bottom
operator|==
name|r2
operator|->
name|top
condition|)
block|{
name|r1
operator|->
name|bottom
operator|=
name|r2
operator|->
name|bottom
expr_stmt|;
goto|goto
name|free
goto|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|->
name|top
operator|==
name|r2
operator|->
name|bottom
condition|)
block|{
name|r1
operator|->
name|top
operator|=
name|r2
operator|->
name|top
expr_stmt|;
goto|goto
name|free
goto|;
block|}
block|}
name|prev
operator|=
operator|&
name|r2
operator|->
name|next
expr_stmt|;
continue|continue;
name|free
label|:
operator|*
name|prev
operator|=
name|r2
operator|->
name|next
expr_stmt|;
name|FREERECT
argument_list|(
name|r2
argument_list|)
expr_stmt|;
name|prev
operator|=
name|recs
expr_stmt|;
continue|continue;
name|remerge
label|:
operator|*
name|prev
operator|=
name|r2
operator|->
name|next
expr_stmt|;
name|r2
operator|->
name|next
operator|=
name|r1
expr_stmt|;
name|r1
operator|=
name|r2
expr_stmt|;
name|prev
operator|=
name|recs
expr_stmt|;
block|}
operator|*
name|prev
operator|=
name|r1
expr_stmt|;
if|if
condition|(
operator|(
name|r2
operator|=
name|r1
operator|->
name|next
operator|)
operator|==
name|NULL
condition|)
return|return;
name|r1
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r1
operator|=
name|r2
expr_stmt|;
block|}
block|}
end_block

end_unit

