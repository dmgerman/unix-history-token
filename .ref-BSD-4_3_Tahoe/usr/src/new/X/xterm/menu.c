begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	$Source: /u1/X/xterm/RCS/menu.c,v $  *	$Header: menu.c,v 10.101 86/12/01 17:52:43 swick Rel $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MODEMENU
end_ifdef

begin_include
include|#
directive|include
file|"X/Xlib.h"
end_include

begin_include
include|#
directive|include
file|"menu.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccs_id
index|[]
init|=
literal|"@(#)menu.c\tX10/6.6B\t12/26/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|InvertPlane
value|1
end_define

begin_define
define|#
directive|define
name|SetStateFlags
parameter_list|(
name|item
parameter_list|)
value|item->itemFlags = (item->itemFlags&\ 				 ~(itemStateMask | itemChanged)) |\ 				 ((item->itemFlags& itemSetMask)>>\ 				 itemSetMaskShift)
end_define

begin_decl_stmt
specifier|static
name|short
name|Check_MarkBits
index|[]
init|=
block|{
literal|0x0100
block|,
literal|0x0180
block|,
literal|0x00c0
block|,
literal|0x0060
block|,
literal|0x0031
block|,
literal|0x001b
block|,
literal|0x000e
block|,
literal|0x0004
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|Check_GrayBits
index|[]
init|=
block|{
literal|0x0100
block|,
literal|0x0080
block|,
literal|0x0040
block|,
literal|0x0020
block|,
literal|0x0011
block|,
literal|0x000a
block|,
literal|0x0004
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|Default_CursorBits
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0002
block|,
literal|0x0006
block|,
literal|0x000e
block|,
literal|0x001e
block|,
literal|0x003e
block|,
literal|0x007e
block|,
literal|0x00fe
block|,
literal|0x01fe
block|,
literal|0x003e
block|,
literal|0x0036
block|,
literal|0x0062
block|,
literal|0x0060
block|,
literal|0x00c0
block|,
literal|0x00c0
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|Default_GrayBits
index|[]
init|=
block|{
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|Default_MaskBits
index|[]
init|=
block|{
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000f
block|,
literal|0x001f
block|,
literal|0x003f
block|,
literal|0x007f
block|,
literal|0x00ff
block|,
literal|0x01ff
block|,
literal|0x03ff
block|,
literal|0x07ff
block|,
literal|0x007f
block|,
literal|0x00f7
block|,
literal|0x00f3
block|,
literal|0x01e1
block|,
literal|0x01e0
block|,
literal|0x01c0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|def_menu_font
index|[]
init|=
literal|"vtsingle"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Pixmap
name|Gray_Tile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Menu
name|Menu_Default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cursor
name|Menu_DefaultCursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Menu_DefaultFont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FontInfo
modifier|*
name|Menu_DefaultFontInfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * AddMenuItem() adds a menu item to an existing menu, at the end of the  * list, which are number sequentially from zero.  The menuitem index is  * return, or -1 if failed.  */
end_comment

begin_expr_stmt
name|AddMenuItem
argument_list|(
name|menu
argument_list|,
name|text
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|menuitem
decl_stmt|,
modifier|*
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
name|text
operator|||
operator|(
name|menuitem
operator|=
operator|(
name|MenuItem
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MenuItem
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|MenuItem
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|menuitem
argument_list|,
sizeof|sizeof
argument_list|(
name|MenuItem
argument_list|)
argument_list|)
expr_stmt|;
name|menuitem
operator|->
name|itemText
operator|=
name|text
expr_stmt|;
name|menuitem
operator|->
name|itemTextLength
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next
operator|=
operator|&
name|menu
operator|->
name|menuItems
init|;
operator|*
name|next
condition|;
name|i
operator|++
control|)
name|next
operator|=
operator|&
operator|(
operator|*
name|next
operator|)
operator|->
name|nextItem
expr_stmt|;
operator|*
name|next
operator|=
name|menuitem
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator||=
name|menuChanged
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * DisposeItem() releases the memory allocated for the given indexed  * menuitem.  Nonzero is returned if an item was actual disposed of.  */
end_comment

begin_expr_stmt
name|DisposeItem
argument_list|(
name|menu
argument_list|,
name|i
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|last
decl_stmt|,
modifier|*
name|menuitem
decl_stmt|;
if|if
condition|(
operator|!
name|menu
operator|||
name|i
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|next
operator|=
operator|&
name|menu
operator|->
name|menuItems
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|*
name|next
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|last
operator|=
name|next
expr_stmt|;
name|next
operator|=
operator|&
operator|(
operator|*
name|next
operator|)
operator|->
name|nextItem
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
do|;
name|menuitem
operator|=
operator|*
name|last
expr_stmt|;
operator|*
name|last
operator|=
operator|*
name|next
expr_stmt|;
name|free
argument_list|(
name|menuitem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * DisposeMenu() releases the memory allocated for the given menu.  */
end_comment

begin_expr_stmt
name|DisposeMenu
argument_list|(
name|menu
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|Unmap_Menu
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
return|return;
if|if
condition|(
name|menu
operator|->
name|menuFlags
operator|&
name|menuMapped
condition|)
name|Unmap_Menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
while|while
condition|(
name|DisposeItem
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|menu
operator|->
name|menuWindow
condition|)
name|XDestroyWindow
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|menuSaved
condition|)
name|XFreePixmap
argument_list|(
name|menu
operator|->
name|menuSaved
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|InitMenu
argument_list|(
name|name
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|Bitmap
name|bit
decl_stmt|;
comment|/* 	 * If the gray tile hasn't been set up, do it now. 	 */
if|if
condition|(
operator|!
name|Gray_Tile
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bit
operator|=
name|XStoreBitmap
argument_list|(
name|grayWidth
argument_list|,
name|grayHeight
argument_list|,
name|Default_GrayBits
argument_list|)
operator|)
condition|)
return|return;
name|Gray_Tile
operator|=
name|XMakePixmap
argument_list|(
name|bit
argument_list|,
name|WhitePixel
argument_list|,
name|BlackPixel
argument_list|)
expr_stmt|;
name|XFreeBitmap
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
name|Menu_Default
operator|.
name|menuFlags
operator|=
name|menuChanged
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|name
argument_list|,
literal|"MenuFreeze"
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|Menu_Default
operator|.
name|menuFlags
operator||=
name|menuFreeze
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|name
argument_list|,
literal|"MenuSave"
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|Menu_Default
operator|.
name|menuFlags
operator||=
name|menuSaveMenu
expr_stmt|;
name|Menu_Default
operator|.
name|menuInitialItem
operator|=
operator|-
literal|1
expr_stmt|;
name|Menu_Default
operator|.
name|menuBorderWidth
operator|=
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|name
argument_list|,
literal|"MenuBorder"
argument_list|)
operator|)
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|2
expr_stmt|;
name|Menu_Default
operator|.
name|menuItemPad
operator|=
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|name
argument_list|,
literal|"MenuPad"
argument_list|)
operator|)
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|3
expr_stmt|;
name|Menu_DefaultFont
operator|=
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|name
argument_list|,
literal|"MenuFont"
argument_list|)
operator|)
condition|?
name|cp
else|:
name|def_menu_font
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * ItemFlags returns the state of item "n" of the menu.  */
end_comment

begin_expr_stmt
name|ItemFlags
argument_list|(
name|menu
argument_list|,
name|n
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
name|menu
operator|->
name|menuItems
operator|||
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|item
operator|=
name|item
operator|->
name|nextItem
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemSetMask
operator|)
operator|>>
name|itemSetMaskShift
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ItemText changes the text of item "n" of the menu.  */
end_comment

begin_expr_stmt
name|ItemText
argument_list|(
name|menu
argument_list|,
name|n
argument_list|,
name|text
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
name|menu
operator|->
name|menuItems
operator|||
name|n
operator|<
literal|0
operator|||
operator|!
name|text
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|item
operator|=
name|item
operator|->
name|nextItem
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|item
operator|->
name|itemText
operator|=
name|text
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator||=
name|menuChanged
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NewMenu() returns a pointer to an initialized new Menu structure, or NULL  * if failed.  *  * The Menu structure _menuDefault contains the default menu settings.  */
end_comment

begin_function
name|Menu
modifier|*
name|NewMenu
parameter_list|(
name|name
parameter_list|,
name|reverse
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|{
specifier|register
name|Menu
modifier|*
name|menu
decl_stmt|;
specifier|register
name|int
name|fg
decl_stmt|,
name|bg
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* 	 * If the GrayTile hasn't been defined, InitMenu() was never 	 * run, so exit. 	 */
if|if
condition|(
operator|!
name|Gray_Tile
condition|)
return|return
operator|(
operator|(
name|Menu
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Allocate the memory for the menu structure. 	 */
if|if
condition|(
operator|(
name|menu
operator|=
operator|(
name|Menu
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Menu
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|Menu
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|Menu
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* 	 * Initialize to default values. 	 */
operator|*
name|menu
operator|=
name|Menu_Default
expr_stmt|;
comment|/* 	 * If the menu font hasn't yet been gotten, go get it. 	 */
if|if
condition|(
operator|!
name|menu
operator|->
name|menuFontInfo
condition|)
block|{
if|if
condition|(
operator|!
name|Menu_DefaultFontInfo
operator|&&
operator|!
operator|(
name|Menu_DefaultFontInfo
operator|=
name|XOpenFont
argument_list|(
name|Menu_DefaultFont
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|Menu
operator|*
operator|)
literal|0
operator|)
return|;
name|menu
operator|->
name|menuFontInfo
operator|=
name|Menu_DefaultFontInfo
expr_stmt|;
block|}
comment|/* 	 * If the menu cursor hasn't been given, make a default one. 	 */
if|if
condition|(
operator|!
name|menu
operator|->
name|menuCursor
condition|)
block|{
if|if
condition|(
operator|!
name|Menu_DefaultCursor
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
block|{
name|fg
operator|=
name|WhitePixel
expr_stmt|;
name|bg
operator|=
name|BlackPixel
expr_stmt|;
block|}
else|else
block|{
name|fg
operator|=
name|BlackPixel
expr_stmt|;
name|bg
operator|=
name|WhitePixel
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|Menu_DefaultCursor
operator|=
name|XCreateCursor
argument_list|(
name|defaultCursorWidth
argument_list|,
name|defaultCursorHeight
argument_list|,
name|Default_CursorBits
argument_list|,
name|Default_MaskBits
argument_list|,
name|defaultCursorX
argument_list|,
name|defaultCursorY
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|,
name|GXcopy
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|Menu
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|menu
operator|->
name|menuCursor
operator|=
name|Menu_DefaultCursor
expr_stmt|;
block|}
comment|/* 	 * Initialze the default background and border pixmaps and foreground 	 * and background colors (black and white). 	 */
if|if
condition|(
name|reverse
condition|)
block|{
name|menu
operator|->
name|menuBgTile
operator|=
name|BlackPixmap
expr_stmt|;
name|menu
operator|->
name|menuFgColor
operator|=
name|WhitePixel
expr_stmt|;
name|menu
operator|->
name|menuBgColor
operator|=
name|BlackPixel
expr_stmt|;
block|}
else|else
block|{
name|menu
operator|->
name|menuBgTile
operator|=
name|WhitePixmap
expr_stmt|;
name|menu
operator|->
name|menuFgColor
operator|=
name|BlackPixel
expr_stmt|;
name|menu
operator|->
name|menuBgColor
operator|=
name|WhitePixel
expr_stmt|;
block|}
comment|/* 	 * Set the menu title.  If name is NULL or is an empty string, no 	 * title will be displayed. 	 */
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
name|menu
operator|->
name|menuTitleLength
operator|=
name|strlen
argument_list|(
name|menu
operator|->
name|menuTitle
operator|=
name|name
argument_list|)
expr_stmt|;
name|menu
operator|->
name|menuTitleWidth
operator|=
name|XStringWidth
argument_list|(
name|name
argument_list|,
name|menu
operator|->
name|menuFontInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|menu
operator|->
name|menuItemTop
operator|=
name|menu
operator|->
name|menuFontInfo
operator|->
name|height
operator|+
literal|2
operator|*
name|menu
operator|->
name|menuItemPad
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|menu
operator|->
name|menuTitleLength
operator|=
name|menu
operator|->
name|menuTitleWidth
operator|=
name|menu
operator|->
name|menuItemTop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|menu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SetItemCheck sets the check state of item "n" of the menu to "state".  */
end_comment

begin_expr_stmt
name|SetItemCheck
argument_list|(
name|menu
argument_list|,
name|n
argument_list|,
name|state
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
name|menu
operator|->
name|menuItems
operator|||
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|item
operator|=
name|item
operator|->
name|nextItem
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|state
condition|)
name|item
operator|->
name|itemFlags
operator||=
name|itemSetChecked
expr_stmt|;
else|else
name|item
operator|->
name|itemFlags
operator|&=
operator|~
name|itemSetChecked
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemSetMask
operator|)
operator|>>
name|itemSetMaskShift
operator|)
operator|!=
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemStateMask
operator|)
condition|)
block|{
name|item
operator|->
name|itemFlags
operator||=
name|itemChanged
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator||=
name|menuItemChanged
expr_stmt|;
block|}
else|else
name|item
operator|->
name|itemFlags
operator|&=
operator|~
name|itemChanged
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * SetItemDisable sets the disable state of item "n" of the menu to "state".  */
end_comment

begin_expr_stmt
name|SetItemDisable
argument_list|(
name|menu
argument_list|,
name|n
argument_list|,
name|state
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
name|menu
operator|->
name|menuItems
operator|||
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|item
operator|=
name|item
operator|->
name|nextItem
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|state
condition|)
name|item
operator|->
name|itemFlags
operator||=
name|itemSetDisabled
expr_stmt|;
else|else
name|item
operator|->
name|itemFlags
operator|&=
operator|~
name|itemSetDisabled
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemSetMask
operator|)
operator|>>
name|itemSetMaskShift
operator|)
operator|!=
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemStateMask
operator|)
condition|)
block|{
name|item
operator|->
name|itemFlags
operator||=
name|itemChanged
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator||=
name|menuItemChanged
expr_stmt|;
block|}
else|else
name|item
operator|->
name|itemFlags
operator|&=
operator|~
name|itemChanged
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * TrackMenu does most of the work of displaying the menu and tracking the  * mouse.  */
end_comment

begin_expr_stmt
name|TrackMenu
argument_list|(
name|menu
argument_list|,
name|event
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XButtonPressedEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|button
decl_stmt|;
specifier|register
name|MenuItem
modifier|*
name|hilited_item
init|=
operator|(
name|MenuItem
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|int
name|drawn
decl_stmt|;
name|XButtonReleasedEvent
name|ev
decl_stmt|;
specifier|register
name|int
name|changed
decl_stmt|;
name|int
name|y
decl_stmt|,
name|n
decl_stmt|,
name|hilited_y
decl_stmt|,
name|hilited_n
decl_stmt|,
name|in_window
decl_stmt|;
specifier|static
name|MenuItem
modifier|*
name|Mouse_InItem
argument_list|()
decl_stmt|,
modifier|*
name|Y_InItem
argument_list|()
decl_stmt|;
specifier|static
name|Unmap_Menu
argument_list|()
expr_stmt|;
comment|/* 	 * Check that things are reasonable. 	 */
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
name|event
operator|||
operator|!
name|menu
operator|->
name|menuItems
operator|||
name|event
operator|->
name|type
operator|!=
name|ButtonPressed
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Set the changed flag and clear the menu changed flags. 	 */
name|changed
operator|=
name|menu
operator|->
name|menuFlags
operator|&
operator|(
name|menuChanged
operator||
name|menuItemChanged
operator|)
expr_stmt|;
comment|/* 	 * If the entire menu has changed, throw away any saved pixmap and 	 * then call RecalcMenu(). 	 */
if|if
condition|(
name|changed
operator|&
name|menuChanged
condition|)
block|{
if|if
condition|(
name|menu
operator|->
name|menuSaved
condition|)
name|XFreePixmap
argument_list|(
name|menu
operator|->
name|menuSaved
argument_list|)
expr_stmt|;
name|menu
operator|->
name|menuSaved
operator|=
operator|(
name|Pixmap
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Recalc_Menu
argument_list|(
name|menu
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|changed
operator|&=
operator|~
name|menuItemChanged
expr_stmt|;
block|}
comment|/* 	 * Now if the window was never created, go ahead and make it.  Otherwise 	 * if the menu has changed, resize the window. 	 */
if|if
condition|(
operator|!
name|menu
operator|->
name|menuWindow
condition|)
block|{
if|if
condition|(
operator|(
name|menu
operator|->
name|menuWindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|menu
operator|->
name|menuHeight
argument_list|,
name|menu
operator|->
name|menuBorderWidth
argument_list|,
name|Gray_Tile
argument_list|,
name|menu
operator|->
name|menuBgTile
argument_list|)
operator|)
operator|==
operator|(
name|Window
operator|)
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|XDefineCursor
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|menu
operator|->
name|menuCursor
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|ExposeWindow
operator||
name|EnterWindow
operator||
name|LeaveWindow
operator||
name|MouseMoved
operator||
name|ButtonReleased
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|changed
operator|&
name|menuChanged
condition|)
name|XChangeWindow
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|menu
operator|->
name|menuHeight
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out where the menu is supposed to go, from the initial button 	 * press, and move the window there.  Then map the menu. 	 */
if|if
condition|(
operator|!
name|Move_Menu
argument_list|(
name|menu
argument_list|,
name|event
argument_list|)
operator|||
operator|!
name|Map_Menu
argument_list|(
name|menu
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Try to grab the mouse, over a period of 10 seconds. 	 */
for|for
control|(
name|i
operator|=
literal|10
init|;
condition|;
control|)
block|{
if|if
condition|(
name|XGrabMouse
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|menu
operator|->
name|menuCursor
argument_list|,
name|ButtonReleased
operator||
name|EnterWindow
operator||
name|LeaveWindow
operator||
name|MouseMoved
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|--
name|i
operator|<=
literal|0
condition|)
block|{
name|Unmap_Menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save away the button that was pressed and use it to match a 	 * corresponding ButtonReleased event. 	 */
name|button
operator|=
name|event
operator|->
name|detail
operator|&
literal|03
expr_stmt|;
comment|/* 	 * Now process events for the menu window. 	 */
name|drawn
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|type
operator|!=
name|ButtonReleased
operator|&&
name|ev
operator|.
name|window
operator|!=
name|menu
operator|->
name|menuWindow
condition|)
block|{
if|if
condition|(
name|menu
operator|->
name|menuEventHandler
condition|)
call|(
modifier|*
name|menu
operator|->
name|menuEventHandler
call|)
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ev
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
comment|/* 			 * If we have a saved pixmap, display it.  Otherwise 			 * redraw the menu and save it away. 			 */
if|if
condition|(
name|menu
operator|->
name|menuSaved
condition|)
block|{
name|XPixmapPut
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|menu
operator|->
name|menuHeight
argument_list|,
name|menu
operator|->
name|menuSaved
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
comment|/* 				 * If the menuItemChanged flag is still set, 				 * then we need to redraw certain menu items. 				 * ("i" is the vertical position of the top 				 * of the current item.) 				 */
if|if
condition|(
name|changed
operator|&
name|menuItemChanged
condition|)
block|{
name|i
operator|=
name|menu
operator|->
name|menuItemTop
expr_stmt|;
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|nextItem
control|)
block|{
if|if
condition|(
name|item
operator|->
name|itemFlags
operator|&
name|itemChanged
condition|)
name|Modify_Item
argument_list|(
name|menu
argument_list|,
name|item
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
name|item
operator|->
name|itemHeight
expr_stmt|;
block|}
block|}
block|}
else|else
name|Draw_Menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/* 			 * If the menu has changed in any way and we want to 			 * save the menu, throw away any existing save menu 			 * image and make a new one. 			 */
name|XFlush
argument_list|()
expr_stmt|;
if|if
condition|(
name|changed
operator|&&
operator|(
name|menu
operator|->
name|menuFlags
operator|&
name|menuSaveMenu
operator|)
condition|)
block|{
if|if
condition|(
name|menu
operator|->
name|menuSaved
condition|)
name|XFreePixmap
argument_list|(
name|menu
operator|->
name|menuSaved
argument_list|)
expr_stmt|;
name|menu
operator|->
name|menuSaved
operator|=
name|XPixmapSave
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|menu
operator|->
name|menuHeight
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * See which item the cursor may currently be in.  If 			 * it is in a non-disabled item, hilite it. 			 */
if|if
condition|(
name|hilited_item
operator|=
name|Mouse_InItem
argument_list|(
name|menu
argument_list|,
operator|&
name|hilited_y
argument_list|,
operator|&
name|hilited_n
argument_list|,
operator|&
name|in_window
argument_list|)
condition|)
name|XPixFill
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|hilited_y
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|hilited_item
operator|->
name|itemHeight
argument_list|,
name|BlackPixmap
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|InvertPlane
argument_list|)
expr_stmt|;
name|drawn
operator|++
expr_stmt|;
break|break;
case|case
name|EnterWindow
case|:
name|in_window
operator|=
name|TRUE
expr_stmt|;
comment|/* drop through */
case|case
name|MouseMoved
case|:
if|if
condition|(
operator|!
name|drawn
operator|||
operator|!
name|in_window
condition|)
break|break;
comment|/* 			 * See which item the cursor may currently be in.  If 			 * the item has changed, unhilite the old one and 			 * then hilited the new one. 			 */
name|y
operator|=
operator|(
operator|(
name|XEnterWindowEvent
operator|*
operator|)
operator|&
name|ev
operator|)
operator|->
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|Y_InItem
argument_list|(
name|menu
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|n
argument_list|)
operator|)
operator|!=
name|hilited_item
condition|)
block|{
if|if
condition|(
name|hilited_item
condition|)
name|XPixFill
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|hilited_y
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|hilited_item
operator|->
name|itemHeight
argument_list|,
name|BlackPixmap
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|InvertPlane
argument_list|)
expr_stmt|;
if|if
condition|(
name|hilited_item
operator|=
name|item
condition|)
block|{
name|XPixFill
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|hilited_y
operator|=
name|y
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|item
operator|->
name|itemHeight
argument_list|,
name|BlackPixmap
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|InvertPlane
argument_list|)
expr_stmt|;
name|hilited_n
operator|=
name|n
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LeaveWindow
case|:
if|if
condition|(
operator|!
name|drawn
condition|)
break|break;
comment|/* 			 * Unhilite any window that is currently hilited. 			 */
if|if
condition|(
name|hilited_item
condition|)
block|{
name|XPixFill
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|hilited_y
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|hilited_item
operator|->
name|itemHeight
argument_list|,
name|BlackPixmap
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|InvertPlane
argument_list|)
expr_stmt|;
name|hilited_item
operator|=
operator|(
name|MenuItem
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|in_window
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|ButtonReleased
case|:
comment|/* 			 * If the correct button was released, ungrab the mouse 			 * and return the index number of any selected menu 			 * item. 			 */
if|if
condition|(
operator|(
name|ev
operator|.
name|detail
operator|&
literal|0x3
operator|)
operator|==
name|button
condition|)
block|{
if|if
condition|(
name|in_window
condition|)
block|{
name|y
operator|=
operator|(
operator|(
name|XButtonReleasedEvent
operator|*
operator|)
operator|&
name|ev
operator|)
operator|->
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|Y_InItem
argument_list|(
name|menu
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|n
argument_list|)
operator|)
operator|!=
name|hilited_item
condition|)
block|{
if|if
condition|(
name|hilited_item
condition|)
name|XPixFill
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|hilited_y
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|hilited_item
operator|->
name|itemHeight
argument_list|,
name|BlackPixmap
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|InvertPlane
argument_list|)
expr_stmt|;
if|if
condition|(
name|hilited_item
operator|=
name|item
condition|)
block|{
name|XPixFill
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|hilited_y
operator|=
name|y
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|hilited_item
operator|->
name|itemHeight
argument_list|,
name|BlackPixmap
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|InvertPlane
argument_list|)
expr_stmt|;
name|hilited_n
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
name|XUngrabMouse
argument_list|()
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator|&=
operator|~
operator|(
name|menuChanged
operator||
name|menuItemChanged
operator|)
expr_stmt|;
name|Unmap_Menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
if|if
condition|(
name|hilited_item
condition|)
return|return
operator|(
name|menu
operator|->
name|menuInitialItem
operator|=
name|hilited_n
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Recalculate all of the various menu and item variables.  */
end_comment

begin_expr_stmt
specifier|static
name|Recalc_Menu
argument_list|(
name|menu
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|,
name|i
decl_stmt|,
name|height
decl_stmt|,
name|fontheight
decl_stmt|;
comment|/* 	 * We must have already gotten the menu font. 	 */
if|if
condition|(
operator|!
name|menu
operator|->
name|menuFontInfo
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Initialize the various max width variables. 	 */
name|fontheight
operator|=
name|menu
operator|->
name|menuFontInfo
operator|->
name|height
expr_stmt|;
name|height
operator|=
name|menu
operator|->
name|menuItemTop
expr_stmt|;
name|menu
operator|->
name|menuMaxTextWidth
operator|=
name|menu
operator|->
name|menuTitleWidth
expr_stmt|;
comment|/* 	 * The item height is the maximum of the font height and the 	 * checkbox height. 	 */
name|max
operator|=
name|fontheight
expr_stmt|;
if|if
condition|(
name|checkMarkHeight
operator|>
name|max
condition|)
name|max
operator|=
name|checkMarkHeight
expr_stmt|;
comment|/* 	 * Go through the menu item list. 	 */
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|nextItem
control|)
block|{
comment|/* 		 * If the item text is a single dash, we assume this is 		 * a line separator and treat it special. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|item
operator|->
name|itemText
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|height
operator|+=
operator|(
name|item
operator|->
name|itemHeight
operator|=
name|lineSeparatorHeight
operator|)
expr_stmt|;
else|else
block|{
name|height
operator|+=
operator|(
name|item
operator|->
name|itemHeight
operator|=
name|max
operator|)
expr_stmt|;
comment|/* 			 * Check the text width with the max value stored in 			 * menu. 			 */
if|if
condition|(
operator|(
name|item
operator|->
name|itemTextWidth
operator|=
name|XStringWidth
argument_list|(
name|item
operator|->
name|itemText
argument_list|,
name|menu
operator|->
name|menuFontInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|menu
operator|->
name|menuMaxTextWidth
condition|)
name|menu
operator|->
name|menuMaxTextWidth
operator|=
name|item
operator|->
name|itemTextWidth
expr_stmt|;
block|}
comment|/* 		 * If the itemChanged flag is set, set the state bits. 		 */
if|if
condition|(
name|item
operator|->
name|itemFlags
operator|&
name|itemChanged
condition|)
block|{
name|item
operator|->
name|itemFlags
operator|=
operator|(
name|item
operator|->
name|itemFlags
operator|&
operator|~
name|itemStateMask
operator|)
operator||
operator|(
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemSetMask
operator|)
operator|>>
name|itemSetMaskShift
operator|)
expr_stmt|;
name|item
operator|->
name|itemFlags
operator|&=
operator|~
name|itemChanged
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the menu height and then set the menu width. 	 */
name|menu
operator|->
name|menuHeight
operator|=
name|height
expr_stmt|;
name|menu
operator|->
name|menuWidth
operator|=
literal|3
operator|*
name|menu
operator|->
name|menuItemPad
operator|+
name|menu
operator|->
name|menuMaxTextWidth
operator|+
name|checkMarkWidth
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Figure out where to popup the menu, relative to the where the button was  * pressed.  */
end_comment

begin_expr_stmt
specifier|static
name|Move_Menu
argument_list|(
name|menu
argument_list|,
name|ev
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|XButtonPressedEvent
modifier|*
name|ev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|ev_x
decl_stmt|,
name|ev_y
decl_stmt|;
name|int
name|total_width
decl_stmt|;
name|Window
name|subw
decl_stmt|;
specifier|extern
name|int
name|dropmenu
decl_stmt|;
comment|/* XXX */
comment|/* 	 * Get the coordinates of the mouse when the button was pressed. 	 */
name|XInterpretLocator
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|ev_x
argument_list|,
operator|&
name|ev_y
argument_list|,
operator|&
name|subw
argument_list|,
name|ev
operator|->
name|location
argument_list|)
expr_stmt|;
comment|/* 	 * Try to popup the menu so that the cursor is centered within the 	 * width of the menu, but compensate if that would run it outside 	 * the display area. 	 */
name|total_width
operator|=
name|menu
operator|->
name|menuWidth
operator|+
literal|2
operator|*
name|menu
operator|->
name|menuBorderWidth
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|ev_x
operator|-
name|total_width
operator|/
literal|2
operator|)
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|+
name|total_width
operator|>
name|DisplayWidth
argument_list|()
condition|)
name|x
operator|=
name|DisplayWidth
argument_list|()
operator|-
name|total_width
expr_stmt|;
if|if
condition|(
name|dropmenu
condition|)
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|menu
operator|->
name|menuInitialItem
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * If we have an inital item, try to popup the menu centered 		 * vertically within this item. 		 * 		 * Look through the item list. "y" is the vertical position 		 * of the top of the current item and "n" is the item number. 		 */
name|y
operator|=
name|menu
operator|->
name|menuItemTop
operator|+
name|menu
operator|->
name|menuBorderWidth
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
condition|;
name|n
operator|++
control|)
block|{
comment|/* 			 * On finding the intial item, center within this item. 			 */
if|if
condition|(
name|n
operator|==
name|menu
operator|->
name|menuInitialItem
condition|)
block|{
name|y
operator|+=
name|item
operator|->
name|itemHeight
operator|/
literal|2
expr_stmt|;
break|break;
block|}
name|y
operator|+=
name|item
operator|->
name|itemHeight
expr_stmt|;
comment|/* 			 * If we run out of items, turn off the initial item 			 * and treat this as if no initial item. 			 */
if|if
condition|(
operator|!
operator|(
name|item
operator|=
name|item
operator|->
name|nextItem
operator|)
condition|)
block|{
name|menu
operator|->
name|menuInitialItem
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|noInitial
goto|;
block|}
block|}
comment|/* 	 * If no initial item, try to popup the menu centered in the item 	 * nearest the center of the menu. 	 */
block|}
else|else
block|{
name|noInitial
label|:
comment|/* 		 * Look through the item list. "y" is the vertical position 		 * of the top of the current item and "n" is the vertical 		 * position of the center of the menu. 		 */
name|y
operator|=
name|menu
operator|->
name|menuItemTop
operator|+
name|menu
operator|->
name|menuBorderWidth
expr_stmt|;
for|for
control|(
name|n
operator|=
name|menu
operator|->
name|menuHeight
operator|/
literal|2
operator|,
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|nextItem
control|)
comment|/* 			 * If the center of the menu is in this item, we 			 * center within this item. 			 */
if|if
condition|(
operator|(
name|y
operator|+=
name|item
operator|->
name|itemHeight
operator|)
operator|>
name|n
condition|)
block|{
name|y
operator|-=
name|item
operator|->
name|itemHeight
operator|/
literal|2
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If the menu extends above outside of the display, warp 	 * the mouse vertically so the menu will all show up. 	 */
if|if
condition|(
operator|(
name|y
operator|=
name|ev_y
operator|-
name|y
operator|)
operator|<
literal|0
condition|)
block|{
name|XWarpMouse
argument_list|(
name|RootWindow
argument_list|,
name|ev_x
argument_list|,
name|ev_y
operator|-
name|y
argument_list|)
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|n
operator|=
name|y
operator|+
name|menu
operator|->
name|menuHeight
operator|+
literal|2
operator|*
name|menu
operator|->
name|menuBorderWidth
operator|-
name|DisplayHeight
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|XWarpMouse
argument_list|(
name|RootWindow
argument_list|,
name|ev_x
argument_list|,
name|ev_y
operator|-
name|n
argument_list|)
expr_stmt|;
name|y
operator|-=
name|n
expr_stmt|;
block|}
name|XMoveWindow
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* 	 * If we are in freeze mode, save what will be the coordinates of 	 * the save image. 	 */
if|if
condition|(
name|menu
operator|->
name|menuFlags
operator|&
name|menuFreeze
condition|)
block|{
name|menu
operator|->
name|menuSavedImageX
operator|=
name|x
expr_stmt|;
name|menu
operator|->
name|menuSavedImageY
operator|=
name|y
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Map the menu window.  */
end_comment

begin_expr_stmt
specifier|static
name|Map_Menu
argument_list|(
name|menu
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * If we are in freeze mode, save the pixmap underneath where the menu 	 * will be (including the border). 	 */
if|if
condition|(
name|menu
operator|->
name|menuFlags
operator|&
name|menuFreeze
condition|)
block|{
name|XGrabServer
argument_list|()
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|menu
operator|->
name|menuBorderWidth
expr_stmt|;
if|if
condition|(
operator|(
name|menu
operator|->
name|menuSavedImage
operator|=
name|XPixmapSave
argument_list|(
name|RootWindow
argument_list|,
name|menu
operator|->
name|menuSavedImageX
argument_list|,
name|menu
operator|->
name|menuSavedImageY
argument_list|,
name|menu
operator|->
name|menuWidth
operator|+
name|i
argument_list|,
name|menu
operator|->
name|menuHeight
operator|+
name|i
argument_list|)
operator|)
operator|==
operator|(
name|Pixmap
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Actually map the window. 	 */
name|XMapWindow
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|)
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator||=
name|menuMapped
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Draw the entire menu in the blank window.  */
end_comment

begin_expr_stmt
specifier|static
name|Draw_Menu
argument_list|(
name|menu
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
specifier|register
name|int
name|top
init|=
name|menu
operator|->
name|menuItemTop
decl_stmt|;
specifier|register
name|int
name|x
init|=
name|menu
operator|->
name|menuItemPad
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|,
name|dim
decl_stmt|;
comment|/* 	 * If we have a menu title, draw it first, centered and hilited. 	 */
if|if
condition|(
name|menu
operator|->
name|menuTitleLength
condition|)
block|{
name|XPixSet
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|top
operator|-
literal|1
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|)
expr_stmt|;
name|XText
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
operator|(
name|menu
operator|->
name|menuWidth
operator|-
name|menu
operator|->
name|menuTitleWidth
operator|)
operator|/
literal|2
argument_list|,
name|menu
operator|->
name|menuItemPad
argument_list|,
name|menu
operator|->
name|menuTitle
argument_list|,
name|menu
operator|->
name|menuTitleLength
argument_list|,
name|menu
operator|->
name|menuFontInfo
operator|->
name|id
argument_list|,
name|menu
operator|->
name|menuBgColor
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For each item in the list, first draw any check mark and then 	 * draw the rest of it. 	 */
for|for
control|(
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|nextItem
control|)
block|{
name|SetStateFlags
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|dim
operator|=
operator|(
name|item
operator|->
name|itemFlags
operator|&
name|itemDisabled
operator|)
expr_stmt|;
comment|/* 		 * Draw the check mark, possibly dimmed, wherever is necessary. 		 */
if|if
condition|(
name|item
operator|->
name|itemFlags
operator|&
name|itemChecked
condition|)
block|{
name|XBitmapBitsPut
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
operator|=
name|top
operator|+
operator|(
name|item
operator|->
name|itemHeight
operator|-
name|checkMarkHeight
operator|)
operator|/
literal|2
argument_list|,
name|checkMarkWidth
argument_list|,
name|checkMarkHeight
argument_list|,
name|dim
condition|?
name|Check_GrayBits
else|:
name|Check_MarkBits
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|,
name|menu
operator|->
name|menuBgColor
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Draw the item, possibly dimmed. 		 */
name|Draw_Item
argument_list|(
name|menu
argument_list|,
name|item
argument_list|,
name|top
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|top
operator|+=
name|item
operator|->
name|itemHeight
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Modify the item at vertical position y.  This routine is table driven and  * the state and set bits are each 2 bits long, contiguous, the least  * significant bits in the flag word and with the state bits in bits 0& 1.  */
end_comment

begin_define
define|#
directive|define
name|drawCheck
value|0x10
end_define

begin_define
define|#
directive|define
name|removeCheck
value|0x08
end_define

begin_define
define|#
directive|define
name|dimCheck
value|0x04
end_define

begin_define
define|#
directive|define
name|drawItem
value|0x02
end_define

begin_define
define|#
directive|define
name|dimItem
value|0x01
end_define

begin_decl_stmt
specifier|static
name|char
name|Modify_Table
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x02
block|,
literal|0x08
block|,
literal|0x0a
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x09
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x12
block|,
literal|0x15
block|,
literal|0x14
block|,
literal|0x05
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|Modify_Item
argument_list|(
name|menu
argument_list|,
name|item
argument_list|,
name|top
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
init|=
name|menu
operator|->
name|menuItemPad
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|;
specifier|register
name|int
name|center
init|=
name|top
operator|+
name|item
operator|->
name|itemHeight
operator|/
literal|2
decl_stmt|;
specifier|register
name|int
name|func
init|=
name|Modify_Table
index|[
name|item
operator|->
name|itemFlags
operator|&
operator|(
name|itemStateMask
operator||
name|itemSetMask
operator|)
index|]
decl_stmt|;
comment|/* 	 * If we really won't be making a change, return. 	 */
if|if
condition|(
name|func
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Draw the check mark if needed, possibly dimmed. 	 */
name|y
operator|=
name|center
operator|-
operator|(
name|checkMarkHeight
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|func
operator|&
operator|(
name|drawCheck
operator||
name|dimCheck
operator|)
condition|)
name|XBitmapBitsPut
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|checkMarkWidth
argument_list|,
name|checkMarkHeight
argument_list|,
operator|(
name|func
operator|&
name|dimCheck
operator|)
condition|?
name|Check_GrayBits
else|:
name|Check_MarkBits
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|,
name|menu
operator|->
name|menuBgColor
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the check mark if needed. 	 */
if|if
condition|(
name|func
operator|&
name|removeCheck
condition|)
name|XTileSet
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|checkMarkWidth
argument_list|,
name|checkMarkHeight
argument_list|,
name|menu
operator|->
name|menuBgTile
argument_list|)
expr_stmt|;
comment|/* 	 * Call Draw_Item if we need to draw or dim the item. 	 */
if|if
condition|(
operator|(
name|x
operator|=
name|func
operator|&
name|dimItem
operator|)
operator|||
operator|(
name|func
operator|&
name|drawItem
operator|)
condition|)
name|Draw_Item
argument_list|(
name|menu
argument_list|,
name|item
argument_list|,
name|top
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* 	 * Update state flags. 	 */
name|SetStateFlags
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Draw the item (less check mark) at vertical position y.  * Dim the item if "dim" is set.  */
end_comment

begin_expr_stmt
specifier|static
name|Draw_Item
argument_list|(
name|menu
argument_list|,
name|item
argument_list|,
name|y
argument_list|,
name|dim
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dim
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
init|=
literal|2
operator|*
name|menu
operator|->
name|menuItemPad
operator|+
name|checkMarkWidth
decl_stmt|;
specifier|register
name|int
name|center
init|=
name|y
operator|+
name|item
operator|->
name|itemHeight
operator|/
literal|2
decl_stmt|;
comment|/* 	 * If the item text is a single dash, draw a separating line. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|item
operator|->
name|itemText
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XLine
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
literal|0
argument_list|,
name|center
argument_list|,
name|menu
operator|->
name|menuWidth
argument_list|,
name|center
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Draw and/or dim the text, centered vertically. 	 */
name|y
operator|=
name|center
operator|-
operator|(
name|menu
operator|->
name|menuFontInfo
operator|->
name|height
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|dim
condition|)
block|{
name|XTileSet
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|item
operator|->
name|itemTextWidth
argument_list|,
name|menu
operator|->
name|menuFontInfo
operator|->
name|height
argument_list|,
name|Gray_Tile
argument_list|)
expr_stmt|;
name|XTextPad
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|item
operator|->
name|itemText
argument_list|,
name|item
operator|->
name|itemTextLength
argument_list|,
name|menu
operator|->
name|menuFontInfo
operator|->
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|,
name|menu
operator|->
name|menuBgColor
argument_list|,
name|menu
operator|->
name|menuFgColor
condition|?
name|GXand
else|:
name|GXor
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
block|}
else|else
name|XText
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|item
operator|->
name|itemText
argument_list|,
name|item
operator|->
name|itemTextLength
argument_list|,
name|menu
operator|->
name|menuFontInfo
operator|->
name|id
argument_list|,
name|menu
operator|->
name|menuFgColor
argument_list|,
name|menu
operator|->
name|menuBgColor
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Determine which enabled menu item the mouse is currently in.  Return the  * top position of this item and its item number.  Set inwindow to whether  * we are or not.  */
end_comment

begin_function
specifier|static
name|MenuItem
modifier|*
name|Mouse_InItem
parameter_list|(
name|menu
parameter_list|,
name|top
parameter_list|,
name|n
parameter_list|,
name|inwindow
parameter_list|)
specifier|register
name|Menu
modifier|*
name|menu
decl_stmt|;
name|int
modifier|*
name|top
decl_stmt|,
decl|*
name|n
decl_stmt|,
modifier|*
name|inwindow
decl_stmt|;
end_function

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|Window
name|subw
decl_stmt|;
specifier|static
name|MenuItem
modifier|*
name|Y_InItem
parameter_list|()
function_decl|;
comment|/* 	 * Find out where the mouse is.  If its not in the menu window, 	 * return NULL. 	 */
name|XQueryMouse
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|subw
argument_list|)
expr_stmt|;
if|if
condition|(
name|subw
operator|!=
name|menu
operator|->
name|menuWindow
condition|)
block|{
operator|*
name|inwindow
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
operator|(
name|MenuItem
operator|*
operator|)
literal|0
operator|)
return|;
block|}
operator|*
name|inwindow
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Now get the coordinates relative to the menu window. 	 */
name|XInterpretLocator
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|subw
argument_list|,
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
comment|/* 	 * Call Y_InItem(). 	 */
operator|*
name|top
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|Y_InItem
argument_list|(
name|menu
argument_list|,
name|top
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return which enabled item the locator is in.  Also return the  * top position of this item and its item number.  Initial y passed  * in top.  */
end_comment

begin_function
specifier|static
name|MenuItem
modifier|*
name|Y_InItem
parameter_list|(
name|menu
parameter_list|,
name|top
parameter_list|,
name|n
parameter_list|)
specifier|register
name|Menu
modifier|*
name|menu
decl_stmt|;
name|int
modifier|*
name|top
decl_stmt|,
decl|*
name|n
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|MenuItem
modifier|*
name|item
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|y
init|=
operator|*
name|top
decl_stmt|;
name|Window
name|subw
decl_stmt|;
comment|/* 	 * Go through the item list.  "t" is the vertical position of the 	 * current item and "i" is its item number. 	 */
name|t
operator|=
name|menu
operator|->
name|menuItemTop
expr_stmt|;
comment|/* 	 * If the mouse is before the first item, return. 	 */
if|if
condition|(
name|y
operator|<
name|t
condition|)
return|return
operator|(
operator|(
name|MenuItem
operator|*
operator|)
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|item
operator|=
name|menu
operator|->
name|menuItems
init|;
name|item
condition|;
name|i
operator|++
operator|,
name|item
operator|=
name|item
operator|->
name|nextItem
control|)
block|{
comment|/* 		 * If the y coordinate is within this menu item, then return. 		 * But don't return disable items. 		 */
if|if
condition|(
name|t
operator|+
name|item
operator|->
name|itemHeight
operator|>
name|y
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|itemFlags
operator|&
name|itemDisabled
condition|)
return|return
operator|(
operator|(
name|MenuItem
operator|*
operator|)
literal|0
operator|)
return|;
operator|*
name|top
operator|=
name|t
expr_stmt|;
operator|*
name|n
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
name|t
operator|+=
name|item
operator|->
name|itemHeight
expr_stmt|;
block|}
comment|/* 	 * Should never get here. 	 */
return|return
operator|(
operator|(
name|MenuItem
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Unmap_Menu() unmaps a menu, if it is currently mapped.  */
end_comment

begin_expr_stmt
specifier|static
name|Unmap_Menu
argument_list|(
name|menu
argument_list|)
specifier|register
name|Menu
operator|*
name|menu
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|menu
operator|||
operator|!
operator|(
name|menu
operator|->
name|menuFlags
operator|&
name|menuMapped
operator|)
condition|)
return|return;
if|if
condition|(
name|menu
operator|->
name|menuFlags
operator|&
name|menuFreeze
condition|)
block|{
name|XUnmapTransparent
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|menu
operator|->
name|menuBorderWidth
expr_stmt|;
name|XPixmapPut
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|menu
operator|->
name|menuSavedImageX
argument_list|,
name|menu
operator|->
name|menuSavedImageY
argument_list|,
name|menu
operator|->
name|menuWidth
operator|+
name|i
argument_list|,
name|menu
operator|->
name|menuHeight
operator|+
name|i
argument_list|,
name|menu
operator|->
name|menuSavedImage
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|menu
operator|->
name|menuSavedImage
argument_list|)
expr_stmt|;
name|XUngrabServer
argument_list|()
expr_stmt|;
block|}
else|else
name|XUnmapWindow
argument_list|(
name|menu
operator|->
name|menuWindow
argument_list|)
expr_stmt|;
name|menu
operator|->
name|menuFlags
operator|&=
operator|~
name|menuMapped
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MODEMENU
end_endif

end_unit

