begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_font_c
init|=
literal|"$Header: font.c,v 10.1 86/11/19 10:41:45 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* Copyright 1985 Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* font.c - Reads a font from a file and stores it on the workstation  *  *      GetFont         Takes a font name and opens it  *      FreeFont        Frees the storage taken by a font  *	StrikeToBitmaps converts strike format into an array of individual  *			character bitmaps  *  *  	Changes and additions by:  *  *		Scott Bates  *		Brown University  *		IRIS, Box 1946  *     		Providence, RI 02912  *  *  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software  * without specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"bitblt.h"
end_include

begin_include
include|#
directive|include
file|"xsite.h"
end_include

begin_include
include|#
directive|include
file|"font.h"
end_include

begin_comment
comment|/*  * Open font file  */
end_comment

begin_function
name|FONT
modifier|*
name|GetFont
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|fontname
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fontfile
decl_stmt|;
name|FontData
name|fd
decl_stmt|;
define|#
directive|define
name|chars
value|((BitMap *) fd.f_characters)
name|int
name|fontsize
decl_stmt|,
name|leftsize
decl_stmt|,
name|width
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|BITMAP
modifier|*
name|strike_bm
decl_stmt|;
name|char
modifier|*
name|fontarea
decl_stmt|;
name|int
name|VisibleChars
init|=
literal|0
decl_stmt|;
specifier|register
name|short
modifier|*
name|leftarea
decl_stmt|,
modifier|*
name|leftarray
decl_stmt|;
specifier|register
name|FONT
modifier|*
name|font
decl_stmt|;
specifier|register
name|FontPriv
modifier|*
name|fpriv
decl_stmt|;
name|int
name|tablesize
init|=
name|CHARPERFONT
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In GetFont\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Convert font name into full path name 	 */
name|strcpy
argument_list|(
name|fontname
argument_list|,
name|DEFAULT_FONT_DIRECTORY
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fontname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fontname
argument_list|,
name|DEFAULT_FONT_SUFFIX
argument_list|)
expr_stmt|;
comment|/* 	 * Open font file 	 */
if|if
condition|(
operator|(
name|fontfile
operator|=
name|open
argument_list|(
name|fontname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|!=
name|ENOENT
operator|||
operator|(
name|fontfile
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Read in font data structure 	 */
if|if
condition|(
name|read
argument_list|(
name|fontfile
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|FontData
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|FontData
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fontfile
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Swap each of the shorts in font data structure. 	 * font was created on a VAX and needs to be swapped  	 * for this hardware. 	 */
name|Swap_shorts
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|FontData
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for font bitmap. 	 * bitmap is in strike format. 	 */
name|fontsize
operator|=
name|BitmapSize
argument_list|(
name|chars
operator|->
name|bm_width
argument_list|,
name|chars
operator|->
name|bm_height
argument_list|)
expr_stmt|;
name|fontarea
operator|=
operator|(
name|char
operator|*
operator|)
name|Xalloc
argument_list|(
name|fontsize
argument_list|)
expr_stmt|;
comment|/* 	 * Read font bitmap into allocated area 	 */
name|lseek
argument_list|(
name|fontfile
argument_list|,
operator|(
name|long
operator|)
name|fd
operator|.
name|f_characters
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fontfile
argument_list|,
name|fontarea
argument_list|,
name|fontsize
argument_list|)
operator|!=
name|fontsize
condition|)
block|{
name|close
argument_list|(
name|fontfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fontarea
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Reverse all the bits in each character of font bitmap. 	 * The font bitmap was created on VAX and needs to be 	 * reversed for this hardware. 	 */
name|ReverseCharBits
argument_list|(
name|fontarea
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for left array and width table 	 */
name|leftarea
operator|=
operator|(
name|short
operator|*
operator|)
name|Xalloc
argument_list|(
name|tablesize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarea
argument_list|,
name|tablesize
argument_list|)
expr_stmt|;
name|leftarray
operator|=
operator|(
name|short
operator|*
operator|)
name|Xalloc
argument_list|(
name|tablesize
argument_list|)
expr_stmt|;
comment|/* 	 * What kind of font is this ? 	 */
if|if
condition|(
name|fd
operator|.
name|f_fixedWidth
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The font is variable width so allocate space for left 		 * array and read it in. The left array is an array 		 * of pointers to the left most bit of each character 		 * in the font. 		 */
name|leftsize
operator|=
operator|(
name|fd
operator|.
name|f_lastChar
operator|-
name|fd
operator|.
name|f_firstChar
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fontfile
argument_list|,
operator|(
name|long
operator|)
name|fd
operator|.
name|f_leftArray
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fontfile
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|leftarea
index|[
name|fd
operator|.
name|f_firstChar
index|]
argument_list|,
name|leftsize
argument_list|)
operator|!=
name|leftsize
condition|)
block|{
name|close
argument_list|(
name|fontfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fontarea
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarea
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarray
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Swap each short in the leftarray. The array was created  		 * on a VAX and needs to be swapped for this hardware 		 */
name|Swap_shorts
argument_list|(
name|leftarea
argument_list|,
name|leftsize
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The font is of a fixed width so create the left 		 * array ourselves 		 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|fd
operator|.
name|f_firstChar
init|;
name|i
operator|<=
name|fd
operator|.
name|f_lastChar
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|leftarea
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|+=
name|fd
operator|.
name|f_fixedWidth
expr_stmt|;
block|}
block|}
comment|/* 	 * Make a copy of the left array for future use 	 */
name|bcopy
argument_list|(
name|leftarea
argument_list|,
name|leftarray
argument_list|,
name|tablesize
argument_list|)
expr_stmt|;
comment|/* 	 * Close the font file 	 */
name|close
argument_list|(
name|fontfile
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for FONT structure 	 */
name|font
operator|=
operator|(
name|FONT
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FONT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in FONT structure with data obtained from font file 	 */
name|font
operator|->
name|height
operator|=
name|chars
operator|->
name|bm_height
expr_stmt|;
name|font
operator|->
name|first
operator|=
name|fd
operator|.
name|f_firstChar
expr_stmt|;
name|font
operator|->
name|last
operator|=
name|fd
operator|.
name|f_lastChar
expr_stmt|;
name|font
operator|->
name|base
operator|=
name|fd
operator|.
name|f_baseline
expr_stmt|;
name|font
operator|->
name|space
operator|=
name|fd
operator|.
name|f_spaceIndex
expr_stmt|;
name|font
operator|->
name|space
operator|+=
name|font
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|fd
operator|.
name|f_fixedWidth
condition|)
block|{
name|font
operator|->
name|fixed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|font
operator|->
name|fixed
operator|=
literal|0
expr_stmt|;
block|}
name|font
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|font
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|Xalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|font
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for the fonts private data structure 	 */
name|fpriv
operator|=
operator|(
name|FontPriv
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FontPriv
argument_list|)
argument_list|)
expr_stmt|;
name|font
operator|->
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|fpriv
expr_stmt|;
comment|/* 	 * Save pointers to left array, width table , and font bitmap 	 */
name|fpriv
operator|->
name|widths
operator|=
name|leftarea
expr_stmt|;
name|fpriv
operator|->
name|leftarray
operator|=
name|leftarray
expr_stmt|;
comment|/* 	 * Allocate a temporary buffer for the strike bitmap. 	 */
if|if
condition|(
operator|(
name|strike_bm
operator|=
operator|(
name|BITMAP
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BITMAP
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fontarea
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarea
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarray
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|font
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|fpriv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strike_bm
operator|->
name|width
operator|=
name|chars
operator|->
name|bm_width
expr_stmt|;
name|strike_bm
operator|->
name|height
operator|=
name|chars
operator|->
name|bm_height
expr_stmt|;
name|strike_bm
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|strike_bm
operator|->
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|fontarea
expr_stmt|;
comment|/* 	 * Convert leftarray to the width table 	 */
name|fpriv
operator|->
name|maxwidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|font
operator|->
name|first
init|;
name|i
operator|<
name|font
operator|->
name|last
condition|;
name|i
operator|++
control|)
block|{
name|width
operator|=
name|fpriv
operator|->
name|leftarray
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|fpriv
operator|->
name|leftarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|fpriv
operator|->
name|maxwidth
condition|)
block|{
name|fpriv
operator|->
name|maxwidth
operator|=
name|width
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
comment|/* font sanity check */
name|DeviceError
argument_list|(
literal|"Bad font leftarray!"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|VisibleChars
operator|++
expr_stmt|;
block|}
name|fpriv
operator|->
name|widths
index|[
name|i
index|]
operator|=
name|width
expr_stmt|;
block|}
name|fpriv
operator|->
name|widths
index|[
name|i
index|]
operator|=
name|strike_bm
operator|->
name|width
operator|-
name|fpriv
operator|->
name|leftarray
index|[
name|i
index|]
expr_stmt|;
name|font
operator|->
name|avg_width
operator|=
name|strike_bm
operator|->
name|width
operator|/
name|VisibleChars
expr_stmt|;
comment|/* 	 * Make individual bitmaps of each character in font 	 */
if|if
condition|(
name|StrikeToBitmaps
argument_list|(
name|font
argument_list|,
name|strike_bm
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fontarea
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarea
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|leftarray
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|strike_bm
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|fpriv
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|font
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Set up offscr if the font will fit into the offscreen 	 * buffer. 	 */
if|if
condition|(
name|font
operator|->
name|height
operator|>
name|MAX_OFFSCR_HT
condition|)
block|{
name|fpriv
operator|->
name|offscr
operator|=
name|NILBITMAP
expr_stmt|;
block|}
else|else
block|{
name|fpriv
operator|->
name|offscr
operator|=
operator|&
name|txtbm
expr_stmt|;
block|}
comment|/* 	 * Don't need the temporary strike bitmap. 	 */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|strike_bm
argument_list|)
expr_stmt|;
comment|/* 	 * Return pointer to FONT stucture 	 */
return|return
operator|(
name|font
operator|)
return|;
undef|#
directive|undef
name|chars
block|}
end_function

begin_comment
comment|/*  * Free all allocated space used by font  */
end_comment

begin_expr_stmt
name|FreeFont
argument_list|(
name|font
argument_list|)
specifier|register
name|FONT
operator|*
name|font
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FontPriv
modifier|*
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In FreeFont\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
name|data
operator|=
name|FDATA
argument_list|(
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|widths
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
operator|->
name|widths
argument_list|)
expr_stmt|;
block|}
name|FreeBitmap
argument_list|(
name|data
operator|->
name|chrs
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|font
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|font
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine converts strike format into an array of bitmaps  */
end_comment

begin_macro
name|StrikeToBitmaps
argument_list|(
argument|font
argument_list|,
argument|sbm
argument_list|)
end_macro

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|sbm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FontPriv
modifier|*
name|fpriv
init|=
name|FDATA
argument_list|(
name|font
argument_list|)
decl_stmt|;
specifier|register
name|BITMAP
modifier|*
name|cbm
decl_stmt|;
specifier|register
name|charwidth
expr_stmt|;
specifier|register
name|charoffset
expr_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|desty
operator|=
literal|0
expr_stmt|;
name|int
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In StrikeToBitmaps\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Allocate bitmap structure for character bitmap 	 */
if|if
condition|(
operator|(
name|cbm
operator|=
name|fpriv
operator|->
name|chrs
operator|=
operator|(
name|BITMAP
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BITMAP
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Allocate all of the individual character bitmaps in one shot 	 */
name|cbm
operator|->
name|width
operator|=
operator|(
operator|(
operator|(
name|fpriv
operator|->
name|maxwidth
operator|+
literal|15
operator|)
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|cbm
operator|->
name|height
operator|=
operator|(
name|font
operator|->
name|last
operator|-
name|font
operator|->
name|first
operator|+
literal|1
operator|)
operator|*
name|font
operator|->
name|height
expr_stmt|;
name|size
operator|=
name|BitmapSize
argument_list|(
name|cbm
operator|->
name|width
argument_list|,
name|cbm
operator|->
name|height
argument_list|)
expr_stmt|;
name|cbm
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cbm
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|Xalloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cbm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|cbm
operator|->
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Loop thru font and blt each character into its  	 * apporpriate bitmap 	 */
for|for
control|(
name|i
operator|=
name|font
operator|->
name|first
init|;
name|i
operator|<=
name|font
operator|->
name|last
condition|;
name|i
operator|++
control|)
block|{
name|charwidth
operator|=
name|fpriv
operator|->
name|widths
index|[
name|i
index|]
expr_stmt|;
name|charoffset
operator|=
name|fpriv
operator|->
name|leftarray
index|[
name|i
index|]
expr_stmt|;
comment|/*                  * make source and destination rectangles                  */
name|FillInRect
argument_list|(
name|charoffset
argument_list|,
literal|0
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|)
expr_stmt|;
name|FillInRect
argument_list|(
literal|0
argument_list|,
name|desty
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|)
expr_stmt|;
comment|/*                  * blt character to bitmap                  */
name|CopyBits
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|sbm
operator|->
name|data
argument_list|,
name|sbm
operator|->
name|width
argument_list|,
name|sbm
operator|->
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|cbm
operator|->
name|data
argument_list|,
name|cbm
operator|->
name|width
argument_list|,
name|cbm
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|,
name|NILMASK
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|GXcopy
argument_list|,
literal|0
argument_list|,
name|NILCLIP
argument_list|)
expr_stmt|;
comment|/*                  * adjust destination address                  */
name|desty
operator|+=
name|font
operator|->
name|height
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

