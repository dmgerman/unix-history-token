begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_comment
comment|/*  * Author: Peter J. Nicklin  */
end_comment

begin_comment
comment|/*  * xppath() expands project pathname ppathname into regular pathname. Both  * the pathname type labels and description are ignored for efficiency.  * Returns -1 on error, otherwise zero.  */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"pdb.h"
end_include

begin_include
include|#
directive|include
file|"pld.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_comment
comment|/*  * pathname states  */
end_comment

begin_define
define|#
directive|define
name|START
value|0001
end_define

begin_define
define|#
directive|define
name|HDIR
value|0002
end_define

begin_define
define|#
directive|define
name|PDIR1
value|0004
end_define

begin_define
define|#
directive|define
name|PDIR2
value|0010
end_define

begin_define
define|#
directive|define
name|DIR1
value|0020
end_define

begin_define
define|#
directive|define
name|DIR2
value|0040
end_define

begin_define
define|#
directive|define
name|EOP
value|0100
end_define

begin_define
define|#
directive|define
name|ERROR
value|0200
end_define

begin_comment
comment|/*  * pathname errors  */
end_comment

begin_define
define|#
directive|define
name|E_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|E_SYNTAX
value|1
end_define

begin_define
define|#
directive|define
name|E_NOTPDIR
value|2
end_define

begin_define
define|#
directive|define
name|E_NOTDIR
value|3
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|PDBERR
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project link dir error message */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project pathname pointer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|perrlist
index|[]
init|=
block|{
literal|"unknown error"
block|,
literal|"pathname syntax error"
block|,
literal|"no such project directory"
block|,
literal|"no such file, directory, or project"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|PATHERR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current pathname error condition */
end_comment

begin_decl_stmt
name|int
name|PPDEBUG
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project pathname debug flag */
end_comment

begin_macro
name|xppath
argument_list|(
argument|ppathname
argument_list|,
argument|pb
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ppathname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project pathname */
end_comment

begin_decl_stmt
specifier|register
name|PATH
modifier|*
name|pb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname struct pointer */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* regular pathname pointer */
specifier|register
name|short
name|pstat
decl_stmt|;
comment|/* pathname state */
name|char
modifier|*
name|getcwp
parameter_list|()
function_decl|;
comment|/* get current project pathname */
name|char
modifier|*
name|gethdir
parameter_list|()
function_decl|;
comment|/* get home directory pathname */
name|char
modifier|*
name|hdir
decl_stmt|;
comment|/* home directory pointer */
name|char
modifier|*
name|mkalias
parameter_list|()
function_decl|;
comment|/* construct alias from pathname */
name|char
modifier|*
name|optpath
parameter_list|()
function_decl|;
comment|/* optimize pathname */
name|char
modifier|*
name|pathcat
parameter_list|()
function_decl|;
comment|/* pathname concatenation */
name|char
modifier|*
name|pbgetstring
parameter_list|()
function_decl|;
comment|/* get specified string field */
name|char
modifier|*
name|pdir
decl_stmt|;
comment|/* project directory pathname */
name|char
name|pplex
parameter_list|()
function_decl|;
comment|/* pathname lexical analyzer */
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* string copy */
name|char
modifier|*
name|strpcpy
parameter_list|()
function_decl|;
comment|/* copy string to pathname */
name|char
name|token
index|[
name|PATHSIZE
index|]
decl_stmt|;
comment|/* receiving token */
name|int
name|closepdb
parameter_list|()
function_decl|;
comment|/* close database */
name|int
name|pbfndflag
parameter_list|()
function_decl|;
comment|/* find flag field */
name|int
name|pfndent
parameter_list|()
function_decl|;
comment|/* find and load database entry */
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* string length */
name|PDB
modifier|*
name|openpdb
parameter_list|()
function_decl|;
comment|/* open database */
name|PDB
modifier|*
name|pdbp
decl_stmt|;
comment|/* database stream */
name|struct
name|passwd
modifier|*
name|getpwdir
parameter_list|()
function_decl|;
comment|/* get password file entry for dir */
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* file state buffer */
name|PATHERR
operator|=
name|perrlist
index|[
name|E_UNKNOWN
index|]
expr_stmt|;
name|pstat
operator|=
name|START
expr_stmt|;
name|pp
operator|=
name|ppathname
expr_stmt|;
name|pb
operator|->
name|p_mode
operator|=
name|P_IFREG
expr_stmt|;
name|pb
operator|->
name|p_alias
operator|=
name|optpath
argument_list|(
name|strcpy
argument_list|(
name|pb
operator|->
name|p_buf
argument_list|,
name|mkalias
argument_list|(
name|ppathname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|pb
operator|->
name|p_path
operator|=
name|pb
operator|->
name|p_buf
operator|+
name|strlen
argument_list|(
name|pb
operator|->
name|p_buf
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|pb
operator|->
name|p_project
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|pstat
operator|!=
name|EOP
condition|)
block|{
switch|switch
condition|(
name|pplex
argument_list|(
name|token
argument_list|)
condition|)
block|{
case|case
name|_HDIRC
case|:
comment|/* user's home directory */
if|if
condition|(
name|pstat
operator|==
name|START
condition|)
block|{
if|if
condition|(
operator|(
name|hdir
operator|=
name|gethdir
argument_list|(
name|token
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|hdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pb
operator|->
name|p_project
argument_list|,
name|pb
operator|->
name|p_path
argument_list|)
expr_stmt|;
name|pb
operator|->
name|p_mode
operator|=
name|P_IFHOME
expr_stmt|;
name|pstat
operator|=
name|HDIR
expr_stmt|;
break|break;
block|}
block|}
name|PATHERR
operator|=
name|perrlist
index|[
name|E_SYNTAX
index|]
expr_stmt|;
name|pstat
operator|=
name|ERROR
expr_stmt|;
break|break;
case|case
name|_PPSC
case|:
comment|/* project pathname separator char */
if|if
condition|(
operator|(
name|pstat
operator|&
operator|(
name|START
operator||
name|HDIR
operator||
name|PDIR2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pstat
operator|&
name|DIR1
operator|)
operator|!=
literal|0
condition|)
name|PATHERR
operator|=
name|perrlist
index|[
name|E_SYNTAX
index|]
expr_stmt|;
else|else
name|PATHERR
operator|=
name|perrlist
index|[
name|E_NOTDIR
index|]
expr_stmt|;
name|pstat
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pstat
operator|==
name|START
condition|)
block|{
name|pb
operator|->
name|p_mode
operator|=
name|P_IFHOME
expr_stmt|;
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|gethdir
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pb
operator|->
name|p_project
argument_list|,
name|pb
operator|->
name|p_path
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|PATHSEP
argument_list|)
expr_stmt|;
name|pstat
operator|=
name|PDIR1
expr_stmt|;
break|break;
case|case
name|_PSC
case|:
comment|/* pathname separator character */
if|if
condition|(
operator|(
name|pstat
operator|&
operator|(
name|START
operator||
name|HDIR
operator||
name|PDIR2
operator||
name|DIR2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|PATHERR
operator|=
name|perrlist
index|[
name|E_SYNTAX
index|]
expr_stmt|;
name|pstat
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pstat
operator|==
name|START
operator|&&
operator|(
name|pdir
operator|=
name|getcwp
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|pb
operator|->
name|p_project
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|PATHSEP
argument_list|)
expr_stmt|;
name|pstat
operator|=
name|DIR1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|pstat
operator|=
name|EOP
expr_stmt|;
break|break;
default|default:
comment|/* project dir, regular dir, or file */
if|if
condition|(
operator|(
name|pstat
operator|&
operator|(
name|START
operator||
name|PDIR1
operator||
name|DIR1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|PATHERR
operator|=
name|perrlist
index|[
name|E_SYNTAX
index|]
expr_stmt|;
name|pstat
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pstat
operator|==
name|DIR1
condition|)
block|{
name|regdir
label|:
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|pb
operator|->
name|p_mode
operator|=
name|P_IFREG
expr_stmt|;
name|pstat
operator|=
name|DIR2
expr_stmt|;
break|break;
block|}
comment|/* initialize pathname */
if|if
condition|(
name|pstat
operator|==
name|START
condition|)
block|{
if|if
condition|(
operator|(
name|pdir
operator|=
name|getcwp
argument_list|()
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|regdir
goto|;
name|strcpy
argument_list|(
name|pb
operator|->
name|p_project
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pdir
operator|=
name|pb
operator|->
name|p_path
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pdbp
operator|=
name|openpdb
argument_list|(
name|PLDNAME
argument_list|,
name|pdir
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|PATHERR
operator|=
name|PDBERR
expr_stmt|;
name|pstat
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
comment|/* project directory? */
if|if
condition|(
name|pfndent
argument_list|(
name|token
argument_list|,
name|pdbp
argument_list|)
operator|==
name|NO
condition|)
block|{
name|closepdb
argument_list|(
name|pdbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pstat
operator|&
name|PDIR1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* project dir must follow ^ */
name|PATHERR
operator|=
name|perrlist
index|[
name|E_NOTPDIR
index|]
expr_stmt|;
name|pstat
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
goto|goto
name|regdir
goto|;
block|}
if|if
condition|(
name|pstat
operator|==
name|START
condition|)
block|{
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
name|p
operator|=
name|strpcpy
argument_list|(
name|p
argument_list|,
name|PATHSEP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pbfndflag
argument_list|(
name|PROOTDIR
argument_list|)
operator|==
name|YES
condition|)
block|{
name|pb
operator|->
name|p_mode
operator|=
name|P_IFPROOT
expr_stmt|;
name|pstat
operator|=
name|PDIR2
expr_stmt|;
block|}
else|else
block|{
name|pb
operator|->
name|p_mode
operator|=
name|P_IFPDIR
expr_stmt|;
name|pstat
operator|=
name|DIR2
expr_stmt|;
block|}
comment|/* is new pathname absolute? */
if|if
condition|(
operator|*
name|pbgetstring
argument_list|(
name|PDIRPATH
argument_list|,
name|p
argument_list|)
operator|==
name|_RDIRC
condition|)
name|p
operator|=
name|strpcpy
argument_list|(
name|pb
operator|->
name|p_path
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
name|closepdb
argument_list|(
name|pdbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|p_mode
operator|==
name|P_IFPROOT
condition|)
name|strcpy
argument_list|(
name|pb
operator|->
name|p_project
argument_list|,
name|pb
operator|->
name|p_path
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pstat
operator|==
name|ERROR
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pstat
operator|!=
name|ERROR
condition|)
block|{
name|optpath
argument_list|(
name|pb
operator|->
name|p_path
argument_list|)
expr_stmt|;
name|optpath
argument_list|(
name|pb
operator|->
name|p_project
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pb
operator|->
name|p_path
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * a regular dir may be a root project directory 			 * specified as ~user, but expanded by the shell. 			 */
if|if
condition|(
name|pb
operator|->
name|p_mode
operator|==
name|P_IFREG
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|char
name|pathbuf
index|[
name|PATHSIZE
index|]
decl_stmt|;
name|pathcat
argument_list|(
name|pathbuf
argument_list|,
name|pb
operator|->
name|p_path
argument_list|,
name|PLDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILEXIST
argument_list|(
name|pathbuf
argument_list|)
operator|&&
name|getpwdir
argument_list|(
name|pb
operator|->
name|p_path
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|pb
operator|->
name|p_project
argument_list|,
name|pb
operator|->
name|p_path
argument_list|)
expr_stmt|;
name|pb
operator|->
name|p_mode
operator|=
name|P_IFHOME
expr_stmt|;
block|}
block|}
name|pb
operator|->
name|p_mode
operator||=
operator|(
name|unsigned
name|long
operator|)
name|stbuf
operator|.
name|st_mode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|PATHERR
operator|=
name|sys_errlist
index|[
name|errno
index|]
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|p_mode
operator|==
name|P_IFREG
condition|)
name|pb
operator|->
name|p_mode
operator|=
name|P_IFNEW
expr_stmt|;
else|else
block|{
comment|/* a project directory must exist */
name|pstat
operator|=
name|ERROR
expr_stmt|;
block|}
block|}
name|pb
operator|->
name|p_type
operator|=
name|pb
operator|->
name|p_path
operator|+
name|strlen
argument_list|(
name|pb
operator|->
name|p_path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pb
operator|->
name|p_desc
operator|=
name|pb
operator|->
name|p_type
operator|+
literal|1
expr_stmt|;
operator|*
name|pb
operator|->
name|p_type
operator|=
operator|*
name|pb
operator|->
name|p_desc
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|PPDEBUG
operator|==
name|YES
condition|)
name|warn
argument_list|(
literal|"%s --> %s"
argument_list|,
name|ppathname
argument_list|,
name|pb
operator|->
name|p_path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|pstat
operator|==
name|ERROR
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * pplex() gets next token. Returns first character of token.  */
end_comment

begin_function
specifier|static
name|char
name|pplex
parameter_list|(
name|token
parameter_list|)
specifier|register
name|char
modifier|*
name|token
decl_stmt|;
comment|/* receiving token */
block|{
specifier|register
name|char
modifier|*
name|rpp
decl_stmt|;
comment|/* project pathname pointer */
name|char
name|t
decl_stmt|;
comment|/* 1st token character */
name|rpp
operator|=
name|pp
expr_stmt|;
name|t
operator|=
operator|*
name|rpp
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|_PPSC
case|:
operator|*
name|token
operator|++
operator|=
operator|*
name|rpp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|rpp
operator|==
name|_PPSC
condition|)
name|rpp
operator|++
expr_stmt|;
break|break;
case|case
name|_PSC
case|:
operator|*
name|token
operator|++
operator|=
operator|*
name|rpp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|rpp
operator|==
name|_PSC
condition|)
name|rpp
operator|++
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
break|break;
default|default:
while|while
condition|(
operator|*
name|rpp
operator|!=
name|_PPSC
operator|&&
operator|*
name|rpp
operator|!=
name|_PSC
operator|&&
operator|*
name|rpp
operator|!=
literal|'\0'
condition|)
operator|*
name|token
operator|++
operator|=
operator|*
name|rpp
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|token
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|=
name|rpp
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * patherr() prints the error message PATHERR to stderr stream and  * returns constant 1.  */
end_comment

begin_macro
name|patherr
argument_list|(
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error message */
end_comment

begin_block
block|{
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* string length */
if|if
condition|(
name|strlen
argument_list|(
name|mesg
argument_list|)
operator|>
literal|0
condition|)
name|warn
argument_list|(
literal|"%s: %s"
argument_list|,
name|mesg
argument_list|,
name|PATHERR
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|PATHERR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

