begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1nuI.c,v 1.4 85/08/22 16:51:13 timo Exp $ */
end_comment

begin_comment
comment|/* Multi-precision integer arithmetic */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1num.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_comment
comment|/*  * Number representation:  * ======================  *  * (Think of BASE = 10 for ordinary decimal notation.)  * A number is a sequence of N "digits" b1, b2, ..., bN  * where each bi is in {0..BASE-1}, except for negative numbers,  * where bN = -1.  * The number represented by b1, ..., bN is  *      b1*BASE**(N-1) + b2*BASE**(N-2) + ... + bN .  * The base BASE is chosen so that multiplication of two positive  * integers up to BASE-1 can be multiplied exactly using double  * precision floating point arithmetic.  * Also it must be possible to add two long integers between  * -BASE and +BASE (exclusive), giving a result between -2BASE and  * +2BASE.  * BASE must be even (so we can easily decide whether the whole  * number is even), and positive (to avoid all kinds of other trouble).  * Presently, it is restricted to a power of 10 by the I/O-conversion  * routines (file "b1nuC.c").  *  * Canonical representation:  * bN is never zero (for the number zero itself, N is zero).  * If bN is -1, b[N-1] is never BASE-1 .  * All operands are assumed te be in canonical representation.  * Routine "int_canon" brings a number in canonical representation.  *  * Mapping to C objects:  * A "digit" is an integer of type "digit", probably an "int".  * A number is represented as a "B-integer", i.e. something  * of type "integer" (which is actually a pointer to some struct).  * The number of digits N is extracted through the macro Length(v).  * The i-th digit is extracted through the macro Digit(v,N-i).  * (So in C, we count in a backwards direction from 0 ... n-1 !)  * A number is created through a call to grab_num(N), which sets  * N zero digits (thus not in canonical form!).  */
end_comment

begin_comment
comment|/*  * Bring an integer into canonical form.  * Make a SmallInt if at all possible.  * NB: Work done by int_canon is duplicated by mk_integer for optimization;  *     if the strategy here changes, look at mk_integer, too!  */
end_comment

begin_function
name|Visible
name|integer
name|int_canon
parameter_list|(
name|v
parameter_list|)
name|integer
name|v
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|v
return|;
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
name|int_0
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|digit
name|dig
init|=
name|Digit
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|integer
operator|)
name|MkSmallInt
argument_list|(
name|dig
argument_list|)
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|-
literal|1
argument_list|)
operator|==
name|BASE
operator|-
literal|1
condition|)
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|integer
operator|)
name|MkSmallInt
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|digit
name|dig
init|=
name|Digit
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
operator|-
name|BASE
decl_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|integer
operator|)
name|MkSmallInt
argument_list|(
name|dig
argument_list|)
return|;
block|}
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|Length
argument_list|(
name|v
argument_list|)
condition|)
return|return
operator|(
name|integer
operator|)
name|regrab_num
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|,
name|i
operator|+
literal|1
argument_list|)
return|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* General add/subtract subroutine */
end_comment

begin_typedef
typedef|typedef
name|double
name|twodigit
typedef|;
end_typedef

begin_comment
comment|/* Might be long on 16 bit machines */
end_comment

begin_comment
comment|/* Should be in b0con.h */
end_comment

begin_function
name|Hidden
name|twodigit
name|fmodulo
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|twodigit
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
name|x
operator|-
name|y
operator|*
operator|(
name|twodigit
operator|)
name|floor
argument_list|(
operator|(
name|double
operator|)
name|x
operator|/
operator|(
name|double
operator|)
name|y
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|dig_gadd
parameter_list|(
name|to
parameter_list|,
name|nto
parameter_list|,
name|from
parameter_list|,
name|nfrom
parameter_list|,
name|ffactor
parameter_list|)
name|digit
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|intlet
name|nto
decl_stmt|,
name|nfrom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|digit
name|ffactor
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|twodigit
name|carry
init|=
literal|0
decl_stmt|;
name|twodigit
name|factor
init|=
name|ffactor
decl_stmt|;
name|digit
name|save
decl_stmt|;
name|nto
operator|-=
name|nfrom
expr_stmt|;
if|if
condition|(
name|nto
operator|<
literal|0
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1000
argument_list|,
literal|"dig_gadd: nto< nfrom"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nfrom
operator|>
literal|0
condition|;
operator|++
name|to
operator|,
operator|++
name|from
operator|,
operator|--
name|nfrom
control|)
block|{
name|carry
operator|+=
operator|*
name|to
operator|+
operator|*
name|from
operator|*
name|factor
expr_stmt|;
operator|*
name|to
operator|=
name|save
operator|=
name|fmodulo
argument_list|(
name|carry
argument_list|,
operator|(
name|twodigit
operator|)
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|-
name|save
operator|)
operator|/
name|BASE
expr_stmt|;
block|}
for|for
control|(
init|;
name|nto
operator|>
literal|0
condition|;
operator|++
name|to
operator|,
operator|--
name|nto
control|)
block|{
if|if
condition|(
name|carry
operator|==
literal|0
condition|)
return|return;
name|carry
operator|+=
operator|*
name|to
expr_stmt|;
operator|*
name|to
operator|=
name|save
operator|=
name|fmodulo
argument_list|(
name|carry
argument_list|,
operator|(
name|twodigit
operator|)
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|-
name|save
operator|)
operator|/
name|BASE
expr_stmt|;
block|}
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
name|to
index|[
operator|-
literal|1
index|]
operator|+=
name|carry
operator|*
name|BASE
expr_stmt|;
comment|/* Assume it's -1 */
block|}
end_block

begin_comment
comment|/* Sum or difference of two integers */
end_comment

begin_comment
comment|/* Should have its own version of dig-gadd without double precision */
end_comment

begin_function
name|Visible
name|integer
name|int_gadd
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|,
name|factor
parameter_list|)
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
name|intlet
name|factor
decl_stmt|;
block|{
name|struct
name|integer
name|vv
decl_stmt|,
name|ww
decl_stmt|;
name|integer
name|s
decl_stmt|;
name|int
name|len
decl_stmt|,
name|lenv
decl_stmt|,
name|i
decl_stmt|;
name|FreezeSmallInt
argument_list|(
name|v
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|FreezeSmallInt
argument_list|(
name|w
argument_list|,
name|ww
argument_list|)
expr_stmt|;
name|lenv
operator|=
name|len
operator|=
name|Length
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
argument_list|(
name|w
argument_list|)
operator|>
name|len
condition|)
name|len
operator|=
name|Length
argument_list|(
name|w
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|s
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lenv
condition|;
operator|++
name|i
control|)
name|Digit
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
operator|=
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|Digit
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dig_gadd
argument_list|(
operator|&
name|Digit
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
argument_list|,
operator|&
name|Digit
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
argument_list|,
operator|(
name|digit
operator|)
name|factor
argument_list|)
expr_stmt|;
return|return
name|int_canon
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Product of two integers */
end_comment

begin_function
name|Visible
name|integer
name|int_prod
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|integer
name|a
decl_stmt|;
name|struct
name|integer
name|vv
decl_stmt|,
name|ww
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|int_0
operator|||
name|w
operator|==
name|int_0
condition|)
return|return
name|int_0
return|;
if|if
condition|(
name|v
operator|==
name|int_1
condition|)
return|return
operator|(
name|integer
operator|)
name|Copy
argument_list|(
name|w
argument_list|)
return|;
if|if
condition|(
name|w
operator|==
name|int_1
condition|)
return|return
operator|(
name|integer
operator|)
name|Copy
argument_list|(
name|v
argument_list|)
return|;
name|FreezeSmallInt
argument_list|(
name|v
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|FreezeSmallInt
argument_list|(
name|w
argument_list|,
name|ww
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
name|Length
argument_list|(
name|v
argument_list|)
operator|+
name|Length
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|a
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|Digit
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|interrupted
condition|;
operator|++
name|i
control|)
name|dig_gadd
argument_list|(
operator|&
name|Digit
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|Digit
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
argument_list|,
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|int_canon
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two integers */
end_comment

begin_function
name|Visible
name|relation
name|int_comp
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|int
name|sv
decl_stmt|,
name|sw
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|integer
name|vv
decl_stmt|,
name|ww
decl_stmt|;
comment|/* 1. Compare pointers and equal SmallInts */
if|if
condition|(
name|v
operator|==
name|w
condition|)
return|return
literal|0
return|;
comment|/* 1a. Handle SmallInts */
if|if
condition|(
name|IsSmallInt
argument_list|(
name|v
argument_list|)
operator|&&
name|IsSmallInt
argument_list|(
name|w
argument_list|)
condition|)
return|return
name|SmallIntVal
argument_list|(
name|v
argument_list|)
operator|-
name|SmallIntVal
argument_list|(
name|w
argument_list|)
return|;
name|FreezeSmallInt
argument_list|(
name|v
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|FreezeSmallInt
argument_list|(
name|w
argument_list|,
name|ww
argument_list|)
expr_stmt|;
comment|/* 2. Extract signs */
name|sv
operator|=
name|Length
argument_list|(
name|v
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
name|Digit
argument_list|(
name|v
argument_list|,
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|sw
operator|=
name|Length
argument_list|(
name|w
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
name|Digit
argument_list|(
name|w
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
comment|/* 3. Compare signs */
if|if
condition|(
name|sv
operator|!=
name|sw
condition|)
return|return
operator|(
name|sv
operator|>
name|sw
operator|)
operator|-
operator|(
name|sv
operator|<
name|sw
operator|)
return|;
comment|/* 4. Compare sizes */
if|if
condition|(
name|Length
argument_list|(
name|v
argument_list|)
operator|!=
name|Length
argument_list|(
name|w
argument_list|)
condition|)
return|return
name|sv
operator|*
operator|(
operator|(
name|Length
argument_list|(
name|v
argument_list|)
operator|>
name|Length
argument_list|(
name|w
argument_list|)
operator|)
operator|-
operator|(
name|Length
argument_list|(
name|v
argument_list|)
operator|<
name|Length
argument_list|(
name|w
argument_list|)
operator|)
operator|)
return|;
comment|/* 5. Compare individual digits */
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|==
name|Digit
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
comment|/* 6. All digits equal? */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Yes */
comment|/* 7. Compare leftmost different digits */
if|if
condition|(
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|<
name|Digit
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct an integer out of a floating point number */
end_comment

begin_define
define|#
directive|define
name|GRAN
value|8
end_define

begin_comment
comment|/* Granularity used when requesting more storage */
end_comment

begin_comment
comment|/* MOVE TO MEM! */
end_comment

begin_function
name|Visible
name|integer
name|mk_int
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
specifier|register
name|integer
name|a
decl_stmt|;
name|integer
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|negate
decl_stmt|;
if|if
condition|(
name|MinSmallInt
operator|<=
name|x
operator|&&
name|x
operator|<=
name|MaxSmallInt
condition|)
return|return
operator|(
name|integer
operator|)
name|MkSmallInt
argument_list|(
operator|(
name|int
operator|)
name|x
argument_list|)
return|;
name|a
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|negate
operator|=
name|x
operator|<
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|negate
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|x
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|double
name|z
init|=
name|floor
argument_list|(
name|x
operator|/
name|BASE
argument_list|)
decl_stmt|;
name|digit
name|save
init|=
name|Modulo
argument_list|(
call|(
name|digit
call|)
argument_list|(
name|x
operator|-
name|z
operator|*
name|BASE
argument_list|)
argument_list|,
name|BASE
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|Length
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|=
operator|(
name|integer
operator|)
name|regrab_num
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|,
name|Length
argument_list|(
name|a
argument_list|)
operator|+
name|GRAN
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|Length
argument_list|(
name|a
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
operator|--
name|j
control|)
name|Digit
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* clear higher digits */
block|}
name|Digit
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|save
expr_stmt|;
name|x
operator|=
name|floor
argument_list|(
operator|(
name|x
operator|-
name|save
operator|)
operator|/
name|BASE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|negate
condition|)
block|{
name|b
operator|=
name|int_neg
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
return|return
name|int_canon
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct an integer out of a C int.  Like mk_int, but optimized. */
end_comment

begin_function
name|Visible
name|value
name|mk_integer
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
if|if
condition|(
name|MinSmallInt
operator|<=
name|x
operator|&&
name|x
operator|<=
name|MaxSmallInt
condition|)
return|return
name|MkSmallInt
argument_list|(
name|x
argument_list|)
return|;
return|return
operator|(
name|value
operator|)
name|mk_int
argument_list|(
operator|(
name|double
operator|)
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Efficiently compute 10**n as a B integer, where n is a C int>= 0 */
end_comment

begin_function
name|Visible
name|integer
name|int_tento
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|integer
name|i
decl_stmt|;
name|digit
name|msd
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1001
argument_list|,
literal|"int_tento(-n)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|tenlogBASE
condition|)
block|{
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
name|msd
operator|*=
literal|10
operator|,
operator|--
name|n
expr_stmt|;
return|return
operator|(
name|integer
operator|)
name|MkSmallInt
argument_list|(
name|msd
argument_list|)
return|;
block|}
name|i
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
name|n
operator|/
name|tenlogBASE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|%=
name|tenlogBASE
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
name|msd
operator|*=
literal|10
operator|,
operator|--
name|n
expr_stmt|;
name|Digit
argument_list|(
name|i
argument_list|,
name|Length
argument_list|(
name|i
argument_list|)
operator|-
literal|1
argument_list|)
operator|=
name|msd
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_comment
comment|/* Approximate ceiling(10 log abs(u/v)), as C int.    It only works for v> 0, u, v both integers.    The result may be one too large or too small */
end_comment

begin_function
name|Visible
name|int
name|scale
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|integer
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|double
name|z
decl_stmt|;
name|struct
name|integer
name|uu
decl_stmt|,
name|vv
decl_stmt|;
if|if
condition|(
name|Msd
argument_list|(
name|v
argument_list|)
operator|<=
literal|0
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1002
argument_list|,
literal|"scale(u,v<=0)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|int_0
condition|)
return|return
literal|0
return|;
comment|/* `Don't care' case */
name|FreezeSmallInt
argument_list|(
name|u
argument_list|,
name|uu
argument_list|)
expr_stmt|;
name|FreezeSmallInt
argument_list|(
name|v
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|Length
argument_list|(
name|u
argument_list|)
operator|-
name|Length
argument_list|(
name|v
argument_list|)
operator|)
operator|*
name|tenlogBASE
expr_stmt|;
if|if
condition|(
name|Digit
argument_list|(
name|u
argument_list|,
name|Length
argument_list|(
name|u
argument_list|)
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
name|z
operator|=
name|Digit
argument_list|(
name|u
argument_list|,
name|Length
argument_list|(
name|u
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|-=
name|tenlogBASE
expr_stmt|;
if|if
condition|(
name|Length
argument_list|(
name|u
argument_list|)
operator|==
literal|1
condition|)
name|z
operator|=
literal|1
expr_stmt|;
else|else
name|z
operator|=
name|BASE
operator|-
name|Digit
argument_list|(
name|u
argument_list|,
name|Length
argument_list|(
name|u
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|z
operator|/=
name|Digit
argument_list|(
name|v
argument_list|,
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|z
operator|>=
literal|10
condition|)
name|z
operator|/=
literal|10
operator|,
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|z
operator|<
literal|1
condition|)
name|z
operator|*=
literal|10
operator|,
operator|--
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|NOT_USED
end_endif

end_unit

