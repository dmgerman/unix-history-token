begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1nuR.c,v 1.4 85/08/22 16:51:49 timo Exp $ */
end_comment

begin_comment
comment|/* Rational arithmetic */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1num.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_comment
comment|/* Length calculations used for fraction sizes: */
end_comment

begin_define
define|#
directive|define
name|Maxlen
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
define|\
value|(Roundsize(u)> Roundsize(v) ? Roundsize(u) : Roundsize(v))
end_define

begin_define
define|#
directive|define
name|Sumlen
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
value|(Roundsize(u)+Roundsize(v))
end_define

begin_define
define|#
directive|define
name|Difflen
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
value|(Roundsize(u)-Roundsize(v))
end_define

begin_comment
comment|/* To shut off lint and other warnings: */
end_comment

begin_undef
undef|#
directive|undef
name|Copy
end_undef

begin_define
define|#
directive|define
name|Copy
parameter_list|(
name|x
parameter_list|)
value|((integer)copy((value)(x)))
end_define

begin_comment
comment|/* Globally used constants */
end_comment

begin_decl_stmt
name|rational
name|rat_zero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rational
name|rat_half
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a normalized rational from two integers */
end_comment

begin_function
name|Visible
name|rational
name|mk_rat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|len
parameter_list|)
name|integer
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|rational
name|a
decl_stmt|;
name|integer
name|u
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|y
operator|==
name|int_0
condition|)
block|{
if|if
condition|(
name|interrupted
condition|)
return|return
name|rat_zero
return|;
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1200
argument_list|,
literal|"mk_rat(x, y) with y=0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|int_0
operator|&&
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|rat_zero
argument_list|)
return|;
if|if
condition|(
name|Msd
argument_list|(
name|y
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* interchange signs */
name|u
operator|=
name|int_neg
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|v
operator|=
name|int_neg
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|Copy
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|v
operator|=
name|Copy
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|rational
operator|)
name|grab_rat
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|+
literal|2
operator|<=
name|Maxintlet
condition|)
name|Length
argument_list|(
name|a
argument_list|)
operator|=
operator|-
literal|2
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|int_0
operator|||
name|v
operator|==
name|int_1
condition|)
block|{
comment|/* No simplification possible */
name|Numerator
argument_list|(
name|a
argument_list|)
operator|=
name|Copy
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|Denominator
argument_list|(
name|a
argument_list|)
operator|=
name|int_1
expr_stmt|;
block|}
else|else
block|{
name|integer
name|g
decl_stmt|,
name|abs_u
decl_stmt|;
if|if
condition|(
name|Msd
argument_list|(
name|u
argument_list|)
operator|<
literal|0
condition|)
name|abs_u
operator|=
name|int_neg
argument_list|(
name|u
argument_list|)
expr_stmt|;
else|else
name|abs_u
operator|=
name|Copy
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|g
operator|=
name|int_gcd
argument_list|(
name|abs_u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|abs_u
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|!=
name|int_1
condition|)
block|{
name|Numerator
argument_list|(
name|a
argument_list|)
operator|=
name|int_quot
argument_list|(
name|u
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|Denominator
argument_list|(
name|a
argument_list|)
operator|=
name|int_quot
argument_list|(
name|v
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Numerator
argument_list|(
name|a
argument_list|)
operator|=
name|Copy
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|Denominator
argument_list|(
name|a
argument_list|)
operator|=
name|Copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
operator|(
name|value
operator|)
name|g
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
operator|(
name|value
operator|)
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* Arithmetic on rational numbers */
end_comment

begin_comment
comment|/* Shorthands: */
end_comment

begin_define
define|#
directive|define
name|N
parameter_list|(
name|u
parameter_list|)
value|Numerator(u)
end_define

begin_define
define|#
directive|define
name|D
parameter_list|(
name|u
parameter_list|)
value|Denominator(u)
end_define

begin_function
name|Visible
name|rational
name|rat_sum
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
specifier|register
name|rational
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|integer
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|rational
name|a
decl_stmt|;
name|t2
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|v
argument_list|)
argument_list|,
name|D
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|int_sum
argument_list|(
name|t2
argument_list|,
name|t3
argument_list|)
expr_stmt|;
name|t4
operator|=
name|int_prod
argument_list|(
name|D
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|mk_rat
argument_list|(
name|t1
argument_list|,
name|t4
argument_list|,
name|Maxlen
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t2
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t3
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t4
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|Visible
name|rational
name|rat_diff
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
specifier|register
name|rational
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|integer
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|rational
name|a
decl_stmt|;
name|t2
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|v
argument_list|)
argument_list|,
name|D
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|int_diff
argument_list|(
name|t2
argument_list|,
name|t3
argument_list|)
expr_stmt|;
name|t4
operator|=
name|int_prod
argument_list|(
name|D
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|mk_rat
argument_list|(
name|t1
argument_list|,
name|t4
argument_list|,
name|Maxlen
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t2
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t3
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t4
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|Visible
name|rational
name|rat_prod
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
specifier|register
name|rational
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|integer
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|rational
name|a
decl_stmt|;
name|t1
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|,
name|N
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|int_prod
argument_list|(
name|D
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|mk_rat
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|Sumlen
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t2
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|Visible
name|rational
name|rat_quot
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
specifier|register
name|rational
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|integer
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|rational
name|a
decl_stmt|;
if|if
condition|(
name|Numerator
argument_list|(
name|v
argument_list|)
operator|==
name|int_0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|1201
argument_list|,
literal|"in u/v, v is zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|rat_zero
argument_list|)
return|;
block|}
name|t1
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|int_prod
argument_list|(
name|D
argument_list|(
name|u
argument_list|)
argument_list|,
name|N
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|mk_rat
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|Difflen
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|t2
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|Visible
name|rational
name|rat_neg
parameter_list|(
name|u
parameter_list|)
specifier|register
name|rational
name|u
decl_stmt|;
block|{
specifier|register
name|rational
name|a
decl_stmt|;
comment|/* Avoid a real subtraction from zero */
if|if
condition|(
name|Numerator
argument_list|(
name|u
argument_list|)
operator|==
name|int_0
condition|)
return|return
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
return|;
name|a
operator|=
operator|(
name|rational
operator|)
name|grab_rat
argument_list|()
expr_stmt|;
name|N
argument_list|(
name|a
argument_list|)
operator|=
name|int_neg
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|D
argument_list|(
name|a
argument_list|)
operator|=
name|Copy
argument_list|(
name|D
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|Length
argument_list|(
name|a
argument_list|)
operator|=
name|Length
argument_list|(
name|u
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* Rational number to the integral power */
end_comment

begin_function
name|Visible
name|rational
name|rat_power
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|rational
name|a
decl_stmt|;
name|integer
name|n
decl_stmt|;
block|{
name|integer
name|u
decl_stmt|,
name|v
decl_stmt|,
name|tu
decl_stmt|,
name|tv
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|int_0
condition|)
return|return
name|mk_rat
argument_list|(
name|int_1
argument_list|,
name|int_1
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|Msd
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|Numerator
argument_list|(
name|a
argument_list|)
operator|==
name|int_0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|1202
argument_list|,
literal|"in 0**n, n is negative"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|a
argument_list|)
return|;
block|}
if|if
condition|(
name|Msd
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|u
operator|=
name|int_neg
argument_list|(
name|Denominator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|int_neg
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|Copy
argument_list|(
name|Denominator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|Copy
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|int_neg
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Numerator
argument_list|(
name|a
argument_list|)
operator|==
name|int_0
condition|)
return|return
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|a
argument_list|)
return|;
comment|/* To avoid necessary simplification later on */
name|u
operator|=
name|Copy
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|Copy
argument_list|(
name|Denominator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|Copy
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|tu
operator|=
name|int_1
expr_stmt|;
name|tv
operator|=
name|int_1
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|int_0
operator|&&
operator|!
name|interrupted
condition|)
block|{
if|if
condition|(
name|Odd
argument_list|(
name|Lsd
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|u
operator|!=
name|int_1
condition|)
block|{
name|temp
operator|=
name|tu
expr_stmt|;
name|tu
operator|=
name|int_prod
argument_list|(
name|u
argument_list|,
name|tu
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
name|int_1
condition|)
block|{
name|temp
operator|=
name|tv
expr_stmt|;
name|tv
operator|=
name|int_prod
argument_list|(
name|v
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|int_1
condition|)
break|break;
comment|/* Avoid useless last squaring */
block|}
comment|/* Square u, v */
if|if
condition|(
name|u
operator|!=
name|int_1
condition|)
block|{
name|temp
operator|=
name|u
expr_stmt|;
name|u
operator|=
name|int_prod
argument_list|(
name|u
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
name|int_1
condition|)
block|{
name|temp
operator|=
name|v
expr_stmt|;
name|v
operator|=
name|int_prod
argument_list|(
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|int_half
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* while (n!=0) */
name|release
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|rational
operator|)
name|grab_rat
argument_list|()
expr_stmt|;
name|Numerator
argument_list|(
name|a
argument_list|)
operator|=
name|tu
expr_stmt|;
name|Denominator
argument_list|(
name|a
argument_list|)
operator|=
name|tv
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* Compare two rational numbers */
end_comment

begin_function
name|Visible
name|relation
name|rat_comp
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
specifier|register
name|rational
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|int
name|sd
decl_stmt|,
name|su
decl_stmt|,
name|sv
decl_stmt|;
name|integer
name|nu
decl_stmt|,
name|nv
decl_stmt|;
comment|/* 1. Compare pointers */
if|if
condition|(
name|u
operator|==
name|v
operator|||
name|N
argument_list|(
name|u
argument_list|)
operator|==
name|N
argument_list|(
name|v
argument_list|)
operator|&&
name|D
argument_list|(
name|u
argument_list|)
operator|==
name|D
argument_list|(
name|v
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 2. Either zero? */
if|if
condition|(
name|N
argument_list|(
name|u
argument_list|)
operator|==
name|int_0
condition|)
return|return
name|int_comp
argument_list|(
name|int_0
argument_list|,
name|N
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|N
argument_list|(
name|v
argument_list|)
operator|==
name|int_0
condition|)
return|return
name|int_comp
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|,
name|int_0
argument_list|)
return|;
comment|/* 3. Compare signs */
name|su
operator|=
name|Msd
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|sv
operator|=
name|Msd
argument_list|(
name|N
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|su
operator|=
operator|(
name|su
operator|>
literal|0
operator|)
operator|-
operator|(
name|su
operator|<
literal|0
operator|)
expr_stmt|;
name|sv
operator|=
operator|(
name|sv
operator|>
literal|0
operator|)
operator|-
operator|(
name|sv
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|su
operator|!=
name|sv
condition|)
return|return
name|su
operator|>
name|sv
condition|?
literal|1
else|:
operator|-
literal|1
return|;
comment|/* 4. Compute numerator of difference and return sign */
name|nu
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|u
argument_list|)
argument_list|,
name|D
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nv
operator|=
name|int_prod
argument_list|(
name|N
argument_list|(
name|v
argument_list|)
argument_list|,
name|D
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|=
name|int_comp
argument_list|(
name|nu
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|nu
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|nv
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|rat_init
parameter_list|()
block|{
name|rat_zero
operator|=
operator|(
name|rational
operator|)
name|grab_rat
argument_list|()
expr_stmt|;
name|Numerator
argument_list|(
name|rat_zero
argument_list|)
operator|=
name|int_0
expr_stmt|;
name|Denominator
argument_list|(
name|rat_zero
argument_list|)
operator|=
name|int_1
expr_stmt|;
name|rat_half
operator|=
operator|(
name|rational
operator|)
name|grab_rat
argument_list|()
expr_stmt|;
name|Numerator
argument_list|(
name|rat_half
argument_list|)
operator|=
name|int_1
expr_stmt|;
name|Denominator
argument_list|(
name|rat_half
argument_list|)
operator|=
name|int_2
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|endrat
parameter_list|()
block|{
name|release
argument_list|(
operator|(
name|value
operator|)
name|rat_zero
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|rat_half
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

