begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1nuA.c,v 1.4 85/08/22 16:50:25 timo Exp $ */
end_comment

begin_comment
comment|/* Approximate arithmetic */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1num.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_comment
comment|/* For still_ok */
end_comment

begin_comment
comment|/* For various reasons, on some machines (notably the VAX), the range of the exponent is too small (ca. 1.7E38), and we cope with this by adding a second word which holds the exponent. However, on other machines (notably the IBM PC), the range is sufficient (ca. 1E300), and here we try to save as much code as possible by not doing our own exponent handling.  (To be fair, we also don't check certain error conditions, to save more code.) The difference is made by #defining EXT_RANGE (in b1num.h), meaning we have to EXTend the RANGE of the exponent. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_RANGE
end_ifdef

begin_decl_stmt
name|Hidden
name|struct
name|real
name|app_0_buf
init|=
block|{
name|Num
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0.0
block|,
operator|-
operator|(
name|double
operator|)
name|Maxint
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exponent must be less than any realistic exponent! */
end_comment

begin_else
else|#
directive|else
else|!EXT_RANGE
end_else

begin_decl_stmt
name|Hidden
name|struct
name|real
name|app_0_buf
init|=
block|{
name|Num
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0.0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|!EXT_RANGE
end_endif

begin_decl_stmt
name|Visible
name|real
name|app_0
init|=
operator|&
name|app_0_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Build an approximate number.  */
end_comment

begin_function
name|Visible
name|real
name|mk_approx
parameter_list|(
name|frac
parameter_list|,
name|expo
parameter_list|)
name|double
name|frac
decl_stmt|,
name|expo
decl_stmt|;
block|{
name|real
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|EXT_RANGE
name|expint
name|e
decl_stmt|;
if|if
condition|(
name|frac
operator|!=
literal|0
condition|)
name|frac
operator|=
name|frexp
argument_list|(
name|frac
argument_list|,
operator|&
name|e
argument_list|)
operator|,
name|expo
operator|+=
name|e
expr_stmt|;
if|if
condition|(
name|frac
operator|==
literal|0.5
condition|)
name|frac
operator|=
literal|1
operator|,
operator|--
name|expo
expr_stmt|;
comment|/* Assert 0.5< frac<= 1 */
if|if
condition|(
name|frac
operator|==
literal|0
operator|||
name|expo
operator|<
operator|-
name|BIG
condition|)
return|return
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|app_0
argument_list|)
return|;
if|if
condition|(
name|expo
operator|>
name|BIG
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|700
argument_list|,
literal|"approximate number too large"
argument_list|)
argument_list|)
expr_stmt|;
name|expo
operator|=
name|BIG
expr_stmt|;
block|}
else|#
directive|else
else|!EXT_RANGE
if|if
condition|(
name|frac
operator|==
literal|0.0
condition|)
return|return
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|app_0
argument_list|)
return|;
name|frac
operator|=
name|ldexp
argument_list|(
name|frac
argument_list|,
operator|(
name|int
operator|)
name|expo
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|EXT_RANGE
name|u
operator|=
operator|(
name|real
operator|)
name|grab_num
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Frac
argument_list|(
name|u
argument_list|)
operator|=
name|frac
expr_stmt|;
ifdef|#
directive|ifdef
name|EXT_RANGE
name|Expo
argument_list|(
name|u
argument_list|)
operator|=
name|expo
expr_stmt|;
endif|#
directive|endif
endif|EXT_RANGE
return|return
name|u
return|;
block|}
end_function

begin_comment
comment|/*  * Approximate arithmetic.  */
end_comment

begin_function
name|Visible
name|real
name|app_sum
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|real
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EXT_RANGE
name|real
name|w
decl_stmt|;
if|if
condition|(
name|Expo
argument_list|(
name|u
argument_list|)
operator|<
name|Expo
argument_list|(
name|v
argument_list|)
condition|)
name|w
operator|=
name|u
operator|,
name|u
operator|=
name|v
operator|,
name|v
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|Expo
argument_list|(
name|v
argument_list|)
operator|-
name|Expo
argument_list|(
name|u
argument_list|)
operator|<
name|Minexpo
condition|)
return|return
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
return|;
return|return
name|mk_approx
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
operator|+
name|ldexp
argument_list|(
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|Expo
argument_list|(
name|v
argument_list|)
operator|-
name|Expo
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|Expo
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
else|#
directive|else
else|!EXT_RANGE
return|return
name|mk_approx
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
operator|+
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
endif|#
directive|endif
endif|!EXT_RANGE
block|}
end_function

begin_function
name|Visible
name|real
name|app_diff
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|real
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EXT_RANGE
name|real
name|w
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|Expo
argument_list|(
name|u
argument_list|)
operator|<
name|Expo
argument_list|(
name|v
argument_list|)
condition|)
name|w
operator|=
name|u
operator|,
name|u
operator|=
name|v
operator|,
name|v
operator|=
name|w
operator|,
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Expo
argument_list|(
name|v
argument_list|)
operator|-
name|Expo
argument_list|(
name|u
argument_list|)
operator|<
name|Minexpo
condition|)
return|return
name|sign
operator|<
literal|0
condition|?
name|app_neg
argument_list|(
name|u
argument_list|)
else|:
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
return|;
return|return
name|mk_approx
argument_list|(
name|sign
operator|*
operator|(
name|Frac
argument_list|(
name|u
argument_list|)
operator|-
name|ldexp
argument_list|(
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|Expo
argument_list|(
name|v
argument_list|)
operator|-
name|Expo
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|,
name|Expo
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
else|#
directive|else
else|!EXT_RANGE
return|return
name|mk_approx
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
operator|-
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
endif|#
directive|endif
endif|!EXT_RANGE
block|}
end_function

begin_function
name|Visible
name|real
name|app_neg
parameter_list|(
name|u
parameter_list|)
name|real
name|u
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
operator|-
name|Frac
argument_list|(
name|u
argument_list|)
argument_list|,
name|Expo
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|real
name|app_prod
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|real
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
operator|*
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|,
name|Expo
argument_list|(
name|u
argument_list|)
operator|+
name|Expo
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|real
name|app_quot
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|real
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
if|if
condition|(
name|Frac
argument_list|(
name|v
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|701
argument_list|,
literal|"in u/v, v is zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
return|;
block|}
return|return
name|mk_approx
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
operator|/
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|,
name|Expo
argument_list|(
name|u
argument_list|)
operator|-
name|Expo
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* 	YIELD log"(frac, expo): 		CHECK frac> 0 		RETURN normalize"(expo*logtwo + log(frac), 0) */
end_comment

begin_function
name|Visible
name|real
name|app_log
parameter_list|(
name|v
parameter_list|)
name|real
name|v
decl_stmt|;
block|{
name|double
name|frac
init|=
name|Frac
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|expo
init|=
name|Expo
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|frac
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|702
argument_list|,
literal|"in log x, x is<= 0"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|app_0
argument_list|)
return|;
block|}
return|return
name|mk_approx
argument_list|(
name|expo
operator|*
name|logtwo
operator|+
name|log
argument_list|(
name|frac
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* 	YIELD exp"(frac, expo): 		IF expo< minexpo: RETURN zero" 		WHILE expo< 0: PUT frac/2, expo+1 IN frac, expo 		PUT exp frac IN f 		PUT normalize"(f, 0) IN f, e 		WHILE expo> 0: 			PUT (f, e) prod" (f, e) IN f, e 			PUT expo-1 IN expo 		RETURN f, e */
end_comment

begin_function
name|Visible
name|real
name|app_exp
parameter_list|(
name|v
parameter_list|)
name|real
name|v
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EXT_RANGE
name|expint
name|ei
decl_stmt|;
name|double
name|frac
init|=
name|Frac
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|expo
init|=
name|Expo
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|new_expo
decl_stmt|;
specifier|static
name|double
name|canexp
decl_stmt|;
if|if
condition|(
operator|!
name|canexp
condition|)
name|canexp
operator|=
name|floor
argument_list|(
name|log
argument_list|(
name|log
argument_list|(
name|Maxreal
argument_list|)
argument_list|)
operator|/
name|logtwo
argument_list|)
expr_stmt|;
if|if
condition|(
name|expo
operator|<=
name|canexp
condition|)
block|{
if|if
condition|(
name|expo
operator|<
name|Minexpo
condition|)
return|return
name|mk_approx
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
return|;
name|frac
operator|=
name|ldexp
argument_list|(
name|frac
argument_list|,
operator|(
name|int
operator|)
name|expo
argument_list|)
expr_stmt|;
name|expo
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expo
operator|>=
name|Maxexpo
condition|)
block|{
comment|/* Definitely too big (the real boundary is much smaller 		   but here we are in danger of overflowing new_expo 		   in the loop below) */
return|return
name|mk_approx
argument_list|(
literal|1.0
argument_list|,
name|Maxreal
argument_list|)
return|;
comment|/* Force an error! */
block|}
else|else
block|{
name|frac
operator|=
name|ldexp
argument_list|(
name|frac
argument_list|,
operator|(
name|int
operator|)
name|canexp
argument_list|)
expr_stmt|;
name|expo
operator|-=
name|canexp
expr_stmt|;
block|}
name|frac
operator|=
name|exp
argument_list|(
name|frac
argument_list|)
expr_stmt|;
name|new_expo
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|expo
operator|>
literal|0
operator|&&
name|frac
operator|!=
literal|0
condition|)
block|{
name|frac
operator|=
name|frexp
argument_list|(
name|frac
argument_list|,
operator|&
name|ei
argument_list|)
expr_stmt|;
name|new_expo
operator|+=
name|ei
expr_stmt|;
name|frac
operator|*=
name|frac
expr_stmt|;
name|new_expo
operator|+=
name|new_expo
expr_stmt|;
operator|--
name|expo
expr_stmt|;
block|}
return|return
name|mk_approx
argument_list|(
name|frac
argument_list|,
name|new_expo
argument_list|)
return|;
else|#
directive|else
else|!EXT_RANGE
return|return
name|mk_approx
argument_list|(
name|exp
argument_list|(
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
endif|#
directive|endif
endif|!EXT_RANGE
block|}
end_function

begin_comment
comment|/* 	YIELD (frac, expo) power" v": 		\   (f*2**e)**v = 		\ = f**v * 2**(e*v) = 		\ = f**v * 2**((e*v) mod 1) * 2**floor(e*v) . 		PUT exp"(v" prod" normalize"(log frac, 0)) IN temp1" \ = f**v 		PUT expo*numval(v") IN ev \ = e*v 		PUT exp(logtwo * (ev - floor ev))) IN temp2 \ = 2**(ev mod 1) 		PUT temp1" IN f, e 		RETURN normalize"(f*temp2, e + floor ev) */
end_comment

begin_function
name|Visible
name|real
name|app_power
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|real
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|double
name|frac
init|=
name|Frac
argument_list|(
name|u
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|EXT_RANGE
name|real
name|logfrac
decl_stmt|,
name|vlogfrac
decl_stmt|,
name|result
decl_stmt|;
name|double
name|expo
init|=
name|Expo
argument_list|(
name|u
argument_list|)
decl_stmt|,
name|rest
decl_stmt|;
endif|#
directive|endif
endif|!EXT_RANGE
if|if
condition|(
name|frac
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|frac
operator|<
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|703
argument_list|,
literal|"in 0**v, v is negative"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|app_0
condition|)
return|return
name|mk_approx
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
return|;
comment|/* 0**0 = 1 */
return|return
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|app_0
argument_list|)
return|;
comment|/* 0**x = 0 */
block|}
ifdef|#
directive|ifdef
name|EXT_RANGE
name|frac
operator|*=
literal|2
operator|,
name|expo
operator|-=
literal|1
expr_stmt|;
comment|/* Renormalize to 1< frac<= 2, so log frac> 0 */
name|logfrac
operator|=
name|mk_approx
argument_list|(
name|log
argument_list|(
name|frac
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|vlogfrac
operator|=
name|app_prod
argument_list|(
name|v
argument_list|,
name|logfrac
argument_list|)
expr_stmt|;
name|result
operator|=
name|app_exp
argument_list|(
name|vlogfrac
argument_list|)
expr_stmt|;
comment|/* But what if result overflows but expo is very negative??? */
if|if
condition|(
name|still_ok
condition|)
block|{
name|expo
operator|*=
name|numval
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
name|rest
operator|=
name|expo
operator|-
name|floor
argument_list|(
name|expo
argument_list|)
expr_stmt|;
name|frac
operator|=
name|Frac
argument_list|(
name|result
argument_list|)
operator|*
name|exp
argument_list|(
name|logtwo
operator|*
name|rest
argument_list|)
expr_stmt|;
name|expo
operator|=
name|Expo
argument_list|(
name|result
argument_list|)
operator|+
name|floor
argument_list|(
name|expo
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
operator|(
name|value
operator|)
name|logfrac
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|vlogfrac
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|result
argument_list|)
expr_stmt|;
return|return
name|mk_approx
argument_list|(
name|frac
argument_list|,
name|expo
argument_list|)
return|;
else|#
directive|else
else|!EXT_RANGE
return|return
name|mk_approx
argument_list|(
name|exp
argument_list|(
name|log
argument_list|(
name|frac
argument_list|)
operator|*
name|Frac
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
endif|#
directive|endif
endif|!EXT_RANGE
block|}
end_function

begin_function
name|Visible
name|int
name|app_comp
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|real
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|double
name|xu
decl_stmt|,
name|xv
decl_stmt|;
ifdef|#
directive|ifdef
name|EXT_RANGE
name|double
name|eu
decl_stmt|,
name|ev
decl_stmt|;
endif|#
directive|endif
endif|EXT_RANGE
if|if
condition|(
name|u
operator|==
name|v
condition|)
return|return
literal|0
return|;
name|xu
operator|=
name|Frac
argument_list|(
name|u
argument_list|)
operator|,
name|xv
operator|=
name|Frac
argument_list|(
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXT_RANGE
if|if
condition|(
name|xu
operator|*
name|xv
operator|>
literal|0
condition|)
block|{
name|eu
operator|=
name|Expo
argument_list|(
name|u
argument_list|)
operator|,
name|ev
operator|=
name|Expo
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|eu
operator|<
name|ev
condition|)
return|return
name|xu
operator|<
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|eu
operator|>
name|ev
condition|)
return|return
name|xu
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
endif|#
directive|endif
endif|EXT_RANGE
if|if
condition|(
name|xu
operator|<
name|xv
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|xu
operator|>
name|xv
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|app_floor
parameter_list|(
name|u
parameter_list|)
name|real
name|u
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EXT_RANGE
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
name|value
name|twotow
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|Expo
argument_list|(
name|u
argument_list|)
operator|<=
name|Dblbits
condition|)
return|return
operator|(
name|value
operator|)
name|mk_int
argument_list|(
name|floor
argument_list|(
name|ldexp
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|Expo
argument_list|(
name|u
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|Expo
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
name|v
operator|=
name|mk_int
argument_list|(
name|ldexp
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
argument_list|,
name|Dblbits
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|mk_int
argument_list|(
name|Expo
argument_list|(
name|u
argument_list|)
operator|-
name|Dblbits
argument_list|)
expr_stmt|;
name|twotow
operator|=
name|power
argument_list|(
operator|(
name|value
operator|)
name|int_2
argument_list|,
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
name|result
operator|=
name|prod
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|,
name|twotow
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
operator|,
name|release
argument_list|(
name|twotow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Integral
argument_list|(
name|result
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|704
argument_list|,
literal|"app_floor: result not integral"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
else|!EXT_RANGE
return|return
operator|(
name|value
operator|)
name|mk_int
argument_list|(
name|floor
argument_list|(
name|Frac
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
endif|!EXT_RANGE
block|}
end_function

end_unit

