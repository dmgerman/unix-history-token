begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1nuQ.c,v 1.4 85/08/22 16:51:40 timo Exp $ */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1num.h"
end_include

begin_comment
comment|/* Product of integer and single "digit" */
end_comment

begin_function
name|Visible
name|integer
name|int1mul
parameter_list|(
name|v
parameter_list|,
name|n1
parameter_list|)
name|integer
name|v
decl_stmt|;
name|digit
name|n1
decl_stmt|;
block|{
name|integer
name|a
decl_stmt|;
name|digit
name|save
decl_stmt|,
name|bigcarry
decl_stmt|,
name|carry
init|=
literal|0
decl_stmt|;
name|double
name|z
decl_stmt|,
name|zz
decl_stmt|,
name|n
init|=
name|n1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|integer
name|vv
decl_stmt|;
name|FreezeSmallInt
argument_list|(
name|v
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
name|Length
argument_list|(
name|v
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
argument_list|(
name|v
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|z
operator|=
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|*
name|n
expr_stmt|;
name|bigcarry
operator|=
name|zz
operator|=
name|floor
argument_list|(
name|z
operator|/
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|+=
name|z
operator|-
name|zz
operator|*
name|BASE
expr_stmt|;
name|Digit
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|save
operator|=
name|Modulo
argument_list|(
name|carry
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|-
name|save
operator|)
operator|/
name|BASE
operator|+
name|bigcarry
expr_stmt|;
block|}
name|Digit
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|save
operator|=
name|Modulo
argument_list|(
name|carry
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
name|Digit
argument_list|(
name|a
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
operator|(
name|carry
operator|-
name|save
operator|)
operator|/
name|BASE
expr_stmt|;
return|return
name|int_canon
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Quotient of positive integer and single "digit"> 0 */
end_comment

begin_function
name|Hidden
name|integer
name|int1div
parameter_list|(
name|v
parameter_list|,
name|n1
parameter_list|,
name|prem
parameter_list|)
name|integer
name|v
decl_stmt|;
name|digit
name|n1
decl_stmt|,
decl|*
name|prem
decl_stmt|;
end_function

begin_block
block|{
name|integer
name|q
decl_stmt|;
name|double
name|r_over_n
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|,
name|n
init|=
name|n1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|integer
name|vv
decl_stmt|;
name|FreezeSmallInt
argument_list|(
name|v
argument_list|,
name|vv
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
name|Length
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
operator|=
name|r
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Digit
argument_list|(
name|q
argument_list|,
name|i
argument_list|)
operator|=
name|r_over_n
operator|=
name|floor
argument_list|(
name|r
operator|/
name|n
argument_list|)
expr_stmt|;
name|r
operator|-=
name|r_over_n
operator|*
name|n
expr_stmt|;
block|}
if|if
condition|(
name|prem
condition|)
operator|*
name|prem
operator|=
name|r
expr_stmt|;
return|return
name|int_canon
argument_list|(
name|q
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Long division routine, gives access to division algorithm. */
end_comment

begin_function
name|Visible
name|digit
name|int_ldiv
parameter_list|(
name|v1
parameter_list|,
name|w1
parameter_list|,
name|pquot
parameter_list|,
name|prem
parameter_list|)
name|integer
name|v1
decl_stmt|,
name|w1
decl_stmt|,
decl|*
name|pquot
decl_stmt|,
modifier|*
name|prem
decl_stmt|;
end_function

begin_block
block|{
name|integer
name|a
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|,
name|rel_v
init|=
literal|0
decl_stmt|,
name|rel_w
init|=
literal|0
decl_stmt|;
name|digit
name|div
decl_stmt|,
name|rem
decl_stmt|;
name|struct
name|integer
name|vv1
decl_stmt|,
name|ww1
decl_stmt|;
if|if
condition|(
name|w1
operator|==
name|int_0
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1100
argument_list|,
literal|"zero division (int_ldiv)"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make v, w positive */
if|if
condition|(
name|Msd
argument_list|(
name|v1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|rel_v
expr_stmt|;
name|v1
operator|=
name|int_neg
argument_list|(
name|v1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Msd
argument_list|(
name|w1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sign
operator|*=
operator|-
literal|1
expr_stmt|;
operator|++
name|rel_w
expr_stmt|;
name|w1
operator|=
name|int_neg
argument_list|(
name|w1
argument_list|)
expr_stmt|;
block|}
name|FreezeSmallInt
argument_list|(
name|v1
argument_list|,
name|vv1
argument_list|)
expr_stmt|;
name|FreezeSmallInt
argument_list|(
name|w1
argument_list|,
name|ww1
argument_list|)
expr_stmt|;
name|div
operator|=
name|sign
expr_stmt|;
comment|/* Check v<< w or single-digit w */
if|if
condition|(
name|Length
argument_list|(
name|v1
argument_list|)
operator|<
name|Length
argument_list|(
name|w1
argument_list|)
operator|||
name|Length
argument_list|(
name|v1
argument_list|)
operator|==
name|Length
argument_list|(
name|w1
argument_list|)
operator|&&
name|Digit
argument_list|(
name|v1
argument_list|,
name|Length
argument_list|(
name|v1
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
name|Digit
argument_list|(
name|w1
argument_list|,
name|Length
argument_list|(
name|w1
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|a
operator|=
name|int_0
expr_stmt|;
if|if
condition|(
name|prem
condition|)
block|{
if|if
condition|(
name|v1
operator|==
operator|&
name|vv1
condition|)
operator|*
name|prem
operator|=
operator|(
name|integer
operator|)
name|MkSmallInt
argument_list|(
name|Digit
argument_list|(
name|v1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|prem
operator|=
operator|(
name|integer
operator|)
name|Copy
argument_list|(
name|v1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|w1
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Single-precision division */
name|a
operator|=
name|int1div
argument_list|(
name|v1
argument_list|,
name|Digit
argument_list|(
name|w1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|prem
condition|)
operator|*
name|prem
operator|=
name|mk_int
argument_list|(
operator|(
name|double
operator|)
name|rem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Multi-precision division */
comment|/* Cf. Knuth II Sec. 4.3.1. Algorithm D */
comment|/* Note that we count in the reverse direction (not easier!) */
name|double
name|z
decl_stmt|,
name|zz
decl_stmt|;
name|digit
name|carry
decl_stmt|,
name|save
decl_stmt|,
name|bigcarry
decl_stmt|;
name|double
name|q
decl_stmt|,
name|d
init|=
name|BASE
operator|/
operator|(
name|Digit
argument_list|(
name|w1
argument_list|,
name|Length
argument_list|(
name|w1
argument_list|)
operator|-
literal|1
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
name|digit
name|vj
decl_stmt|;
comment|/* Normalize: make Msd(w)>= BASE/2 by multiplying 		   both v and w by d */
name|v
operator|=
name|int1mul
argument_list|(
name|v1
argument_list|,
operator|(
name|digit
operator|)
name|d
argument_list|)
expr_stmt|;
comment|/* v is used as accumulator, must make a copy */
comment|/* v cannot be int_1 */
comment|/* (then it would be one of the cases above) */
if|if
condition|(
name|d
operator|==
literal|1
condition|)
name|w
operator|=
operator|(
name|integer
operator|)
name|Copy
argument_list|(
name|w1
argument_list|)
expr_stmt|;
else|else
name|w
operator|=
name|int1mul
argument_list|(
name|w1
argument_list|,
operator|(
name|digit
operator|)
name|d
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
name|Length
argument_list|(
name|v1
argument_list|)
operator|-
name|Length
argument_list|(
name|w
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Division loop */
for|for
control|(
name|j
operator|=
name|Length
argument_list|(
name|v1
argument_list|)
operator|,
name|k
operator|=
name|Length
argument_list|(
name|a
argument_list|)
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|j
operator|,
operator|--
name|k
control|)
block|{
name|vj
operator|=
name|j
operator|>=
name|Length
argument_list|(
name|v
argument_list|)
condition|?
literal|0
else|:
name|Digit
argument_list|(
name|v
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Find trial digit */
if|if
condition|(
name|vj
operator|==
name|Digit
argument_list|(
name|w
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|q
operator|=
name|BASE
operator|-
literal|1
expr_stmt|;
else|else
name|q
operator|=
name|floor
argument_list|(
operator|(
operator|(
name|double
operator|)
name|vj
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|v
argument_list|,
name|j
operator|-
literal|1
argument_list|)
operator|)
operator|/
name|Digit
argument_list|(
name|w
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Correct trial digit */
while|while
condition|(
name|Digit
argument_list|(
name|w
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
operator|-
literal|2
argument_list|)
operator|*
name|q
operator|>
operator|(
operator|(
name|double
operator|)
name|vj
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|v
argument_list|,
name|j
operator|-
literal|1
argument_list|)
operator|-
name|q
operator|*
name|Digit
argument_list|(
name|w
argument_list|,
name|Length
argument_list|(
name|w
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|v
argument_list|,
name|j
operator|-
literal|2
argument_list|)
condition|)
operator|--
name|q
expr_stmt|;
comment|/* Subtract q*w from v */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
argument_list|(
name|w
argument_list|)
operator|&&
name|i
operator|+
name|k
operator|<
name|Length
argument_list|(
name|v
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|z
operator|=
name|Digit
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
operator|*
name|q
expr_stmt|;
name|bigcarry
operator|=
name|zz
operator|=
name|floor
argument_list|(
name|z
operator|/
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|+=
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|+
name|k
argument_list|)
operator|-
name|z
operator|+
name|zz
operator|*
name|BASE
expr_stmt|;
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|+
name|k
argument_list|)
operator|=
name|save
operator|=
name|Modulo
argument_list|(
name|carry
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|-
name|save
operator|)
operator|/
name|BASE
operator|-
name|bigcarry
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
name|k
operator|<
name|Length
argument_list|(
name|v
argument_list|)
condition|)
name|carry
operator|+=
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|+
name|k
argument_list|)
operator|,
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|+
name|k
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Add back necessary? */
comment|/* It is very difficult to find test cases 				   where add back is necessary if BASE is large. 				   Thanks to Arjen Lenstra, we have v=n*n-1, w=n, 				   where n = 8109636009903000000 (the last six 				   digits are not important). */
if|if
condition|(
name|carry
operator|==
literal|0
condition|)
comment|/* No */
name|Digit
argument_list|(
name|a
argument_list|,
name|k
argument_list|)
operator|=
name|q
expr_stmt|;
else|else
block|{
comment|/* Yes, add back */
if|if
condition|(
name|carry
operator|!=
operator|-
literal|1
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1101
argument_list|,
literal|"int_ldiv internal failure"
argument_list|)
argument_list|)
expr_stmt|;
name|Digit
argument_list|(
name|a
argument_list|,
name|k
argument_list|)
operator|=
name|q
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
argument_list|(
name|w
argument_list|)
operator|&&
name|i
operator|+
name|k
operator|<
name|Length
argument_list|(
name|v
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|carry
operator|+=
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|+
name|k
argument_list|)
operator|+
name|Digit
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Digit
argument_list|(
name|v
argument_list|,
name|i
operator|+
name|k
argument_list|)
operator|=
name|save
operator|=
name|Modulo
argument_list|(
name|carry
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|-
name|save
operator|)
operator|/
name|BASE
expr_stmt|;
block|}
block|}
block|}
comment|/* End for(j) */
if|if
condition|(
name|prem
condition|)
operator|*
name|prem
operator|=
name|int_canon
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* Store remainder */
else|else
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
name|div
operator|=
name|sign
operator|*
name|d
expr_stmt|;
comment|/* Store normalization factor */
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
name|a
operator|=
name|int_canon
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rel_v
condition|)
name|release
argument_list|(
operator|(
name|value
operator|)
name|v1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_w
condition|)
name|release
argument_list|(
operator|(
name|value
operator|)
name|w1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|integer
name|temp
init|=
name|a
decl_stmt|;
name|a
operator|=
name|int_neg
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pquot
condition|)
operator|*
name|pquot
operator|=
name|a
expr_stmt|;
else|else
name|release
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|)
expr_stmt|;
return|return
name|div
return|;
block|}
end_block

begin_function
name|Visible
name|integer
name|int_quot
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|integer
name|quo
decl_stmt|;
name|VOID
name|int_ldiv
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
operator|&
name|quo
argument_list|,
operator|(
name|integer
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
return|return
name|quo
return|;
block|}
end_function

begin_function
name|Visible
name|integer
name|int_mod
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|integer
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|integer
name|rem
decl_stmt|;
name|digit
name|div
decl_stmt|;
name|bool
name|flag
decl_stmt|;
name|div
operator|=
name|int_ldiv
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
operator|(
name|integer
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
comment|/* Rem. is always positive */
if|if
condition|(
name|rem
operator|==
name|int_0
condition|)
return|return
name|rem
return|;
comment|/* v mod w = 0 */
name|flag
operator|=
operator|(
name|div
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|flag
operator|||
name|Msd
argument_list|(
name|w
argument_list|)
operator|<
literal|0
condition|)
name|div
operator|=
operator|-
name|div
expr_stmt|;
if|if
condition|(
name|div
operator|!=
literal|1
condition|)
block|{
comment|/* Divide by div to get proper remainder back */
name|v
operator|=
name|int1div
argument_list|(
name|rem
argument_list|,
name|div
argument_list|,
operator|(
name|digit
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|rem
argument_list|)
expr_stmt|;
name|rem
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
comment|/* Make same sign as w */
if|if
condition|(
name|Msd
argument_list|(
name|w
argument_list|)
operator|<
literal|0
condition|)
name|v
operator|=
name|int_sum
argument_list|(
name|w
argument_list|,
name|rem
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|int_diff
argument_list|(
name|w
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|rem
argument_list|)
expr_stmt|;
name|rem
operator|=
name|v
expr_stmt|;
block|}
return|return
name|rem
return|;
block|}
end_function

end_unit

