begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3sig.c,v 1.4 85/08/27 10:56:21 timo Exp $ */
end_comment

begin_comment
comment|/*Handle interrupts and signals*/
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b3scr.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SETJMP
end_ifdef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNAL
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*The operating system provides a function signal(s,f)   that associates function f with the signal s, and returns   a pointer to the previous function associated with s.   Then, when signal s occurs, f is called and the function associated with s   may or may not be reset. Thus f may need to call signal(s,f) again to.   The code here doesn't depend on either interpretation, always being explicit   about which handler to use.    There are two signals that can come from the user: quit and interrupt.   Interrupt should just stop the interpreter and return to B command level;   quit should stop the B system completely.   All other signals are caused by errors (eg memory exhausted)   or come from outside the program, and are therefore fatal.    SIG_IGN is the system supplied routine to ignore a signal.   SIG_DFL is the system supplied default for a signal.   kill(getpid(), signal) kills the program according to 'signal'    On BSD systems, SIGTSTP and other signals causing the process to be   suspended, and SIGCONT and others that are ignored by default,   must not be caught.  It is assumed that all these are defined   when SIGTSTP is defined. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_function
name|Hidden
name|bool
name|must_handle
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* Shouldn't we enumerate the list of signals we *do* want to catch? */
comment|/* It seems that new signals are all of the type that should be 	   ignored by most processes... */
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGURG
case|:
case|case
name|SIGSTOP
case|:
case|case
name|SIGTSTP
case|:
case|case
name|SIGCONT
case|:
case|case
name|SIGCHLD
case|:
case|case
name|SIGTTIN
case|:
case|case
name|SIGTTOU
case|:
case|case
name|SIGIO
case|:
return|return
name|No
return|;
default|default:
return|return
name|Yes
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCLD
end_ifdef

begin_comment
comment|/* System V */
end_comment

begin_define
define|#
directive|define
name|must_handle
parameter_list|(
name|sig
parameter_list|)
value|((sig) != SIGCLD)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|must_handle
parameter_list|(
name|sig
parameter_list|)
value|Yes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Visible
name|Procedure
name|dump
parameter_list|()
block|{
if|if
condition|(
name|cntxt
operator|!=
name|In_prmnv
condition|)
name|putprmnv
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|KILL
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
endif|NOT_USED
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNAL
end_ifdef

begin_function
name|Hidden
name|Procedure
name|oops
parameter_list|(
name|sig
parameter_list|,
name|m
parameter_list|)
name|int
name|sig
decl_stmt|;
name|string
name|m
decl_stmt|;
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Don't call handler recursive -- just die... */
ifdef|#
directive|ifdef
name|sigmask
comment|/* 4.2 BSD */
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't block signals in handler -- just die... */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXT_COMMAND
name|e_done
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"*** Oops, %s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_prmnv
condition|)
name|putprmnv
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|KILL
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|burp
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|oops
argument_list|(
name|sig
argument_list|,
literal|"I feel suddenly (BURP!) indisposed. I'll call it a day. Sorry."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|aog
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|oops
argument_list|(
name|sig
argument_list|,
literal|"an act of God has occurred compelling me to discontinue service."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|fpe_signal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|sig
comment|/* == SIGFPE*/
argument_list|,
name|fpe_signal
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3900
argument_list|,
literal|"unexpected arithmetic overflow"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SETJMP
end_ifdef

begin_decl_stmt
specifier|extern
name|bool
name|awaiting_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|read_interrupt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Hidden
name|Procedure
name|intsig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/*sig==SIGINT*/
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|int_signal
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP
if|if
condition|(
name|awaiting_input
condition|)
name|longjmp
argument_list|(
name|read_interrupt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INTEGRATION
end_ifdef

begin_function
name|Visible
name|Procedure
name|bint_interrupt
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
name|intsig
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Hidden
name|int
argument_list|(
operator|*
name|setsig
argument_list|(
name|sig
argument_list|,
name|func
argument_list|)
argument_list|)
argument_list|()
name|int
name|sig
decl_stmt|,
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*Set a signal, unless it's being ignored*/
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
if|if
condition|(
name|f
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Visible
name|Procedure
name|initsig
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGNAL
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSIG
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|must_handle
argument_list|(
name|i
argument_list|)
condition|)
name|VOID
name|setsig
argument_list|(
name|i
argument_list|,
name|burp
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|INTEGRATION
if|if
condition|(
name|filtered
condition|)
block|{
name|VOID
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGTRAP
argument_list|,
name|intsig
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|VOID
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGTRAP
argument_list|,
name|burp
argument_list|)
decl_stmt|;
block|}
else|#
directive|else
name|VOID
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|VOID
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|aog
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGTERM
argument_list|,
name|aog
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGFPE
argument_list|,
name|fpe_signal
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGPIPE
argument_list|,
name|bye
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|SIGNAL
block|}
end_function

end_unit

