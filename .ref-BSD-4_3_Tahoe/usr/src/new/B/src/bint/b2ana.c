begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/* $Header: b2ana.c,v 1.4 85/08/22 16:54:05 timo Exp $ */
end_comment

begin_comment
comment|/* Prepare for code generation -- find out which tags are targets */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b2gen.h"
end_include

begin_comment
comment|/* Must be after b2nod.h */
end_comment

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_comment
comment|/* For get_pname */
end_comment

begin_decl_stmt
name|Visible
name|int
name|nextvarnumber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counts local targets (including formals) */
end_comment

begin_decl_stmt
name|Visible
name|value
name|formals
decl_stmt|,
name|locals
decl_stmt|,
name|globals
decl_stmt|,
name|mysteries
decl_stmt|,
name|refinements
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|value
modifier|*
name|setup
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|typenode
name|n
init|=
name|Nodetype
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bool
name|in_prmnv
init|=
operator|!
name|Unit
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|nextvarnumber
operator|=
literal|0
expr_stmt|;
name|formals
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|mysteries
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_prmnv
condition|)
block|{
name|globals
operator|=
name|copy
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|locals
operator|=
name|Vnil
expr_stmt|;
name|refinements
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
return|return
name|Command
argument_list|(
name|n
argument_list|)
condition|?
operator|&
name|globals
else|:
name|Pnil
return|;
block|}
else|else
block|{
name|globals
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|locals
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|refinements
operator|=
name|copy
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
operator|==
name|HOW_TO
condition|?
name|HOW_R_NAMES
else|:
name|FPR_R_NAMES
argument_list|)
argument_list|)
expr_stmt|;
name|unit_context
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|&
name|locals
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|unit_context
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|get_pname
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|cleanup
parameter_list|()
block|{
name|release
argument_list|(
name|formals
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|locals
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|mysteries
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|refinements
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ********************************************************************	*/
end_comment

begin_comment
comment|/* Analyze parse tree, finding the targets and formal parameters.    Formal parameters of HOW'TO's are of course found in the unit heading.    Formal parameters of YIELDs and TESTs are treated as local targets.    Global targets are also easily found: they are mentioned in a SHARE command.    Local targets appear on their own or in collateral forms after PUT IN,    DRAW or CHOOSE, or as bound tags after FOR, SOME, EACH or NO.    Note that DELETE x, REMOVE e FROM x, or PUT e IN x[k] (etc.) don't    introduce local targets, because in all these cases x must have been    initialized first.  This speeds up our task of finding targets,    since we don't have to visit all nodes: only nodes that may contain    commands or tests, and the positions mentioned here, need be visited.    (And of course unit headings).    We don't have to look for refinements since these are already known    from the unit heading.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|a_tag
parameter_list|(
name|name
parameter_list|,
name|targs
parameter_list|)
name|value
name|name
decl_stmt|;
name|value
modifier|*
name|targs
decl_stmt|;
block|{
name|value
modifier|*
name|aa
decl_stmt|;
name|int
name|varnumber
decl_stmt|;
if|if
condition|(
name|locals
operator|!=
name|Vnil
operator|&&
name|envassoc
argument_list|(
name|locals
argument_list|,
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
name|envassoc
argument_list|(
name|globals
argument_list|,
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
name|envassoc
argument_list|(
name|formals
argument_list|,
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
name|envassoc
argument_list|(
name|refinements
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|targs
operator|!=
operator|&
name|mysteries
condition|)
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|4600
argument_list|,
literal|"a refinement may not be used as a target"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aa
operator|=
name|envassoc
argument_list|(
name|mysteries
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|targs
operator|==
operator|&
name|mysteries
condition|)
return|return;
name|varnumber
operator|=
name|SmallIntVal
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
name|e_delete
argument_list|(
operator|&
name|mysteries
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targs
operator|!=
operator|&
name|globals
condition|)
name|varnumber
operator|=
name|nextvarnumber
operator|++
expr_stmt|;
else|else
name|varnumber
operator|=
literal|0
expr_stmt|;
name|e_replace
argument_list|(
name|MkSmallInt
argument_list|(
name|varnumber
argument_list|)
argument_list|,
name|targs
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|a_fpr_formals
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|typenode
name|n
init|=
name|Nodetype
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|TAG
case|:
break|break;
case|case
name|MONF
case|:
case|case
name|MONPRD
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|MON_RIGHT
argument_list|)
argument_list|,
operator|&
name|locals
argument_list|)
expr_stmt|;
break|break;
case|case
name|DYAF
case|:
case|case
name|DYAPRD
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_LEFT
argument_list|)
argument_list|,
operator|&
name|locals
argument_list|)
expr_stmt|;
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_RIGHT
argument_list|)
argument_list|,
operator|&
name|locals
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4601
argument_list|,
literal|"a_fpr_formals"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|analyze
parameter_list|(
name|t
parameter_list|,
name|targs
parameter_list|)
name|parsetree
name|t
decl_stmt|;
name|value
modifier|*
name|targs
decl_stmt|;
block|{
name|typenode
name|nt
decl_stmt|;
name|string
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|;
name|value
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|Is_node
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|still_ok
condition|)
return|return;
name|nt
operator|=
name|Nodetype
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|<
literal|0
operator|||
name|nt
operator|>=
name|NTYPES
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4602
argument_list|,
literal|"analyze bad tree"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|gentab
index|[
name|nt
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|n
operator|=
name|First_fieldnr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|still_ok
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|+
name|First_fieldnr
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|v
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|Vnil
condition|)
block|{
name|len
operator|=
name|Nfields
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
operator|++
name|k
control|)
name|analyze
argument_list|(
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|targs
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|curlino
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
literal|'l'
case|:
case|case
literal|'v'
case|:
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|,
operator|&
name|mysteries
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|,
operator|&
name|globals
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|,
name|locals
operator|!=
name|Vnil
condition|?
operator|&
name|locals
else|:
operator|&
name|globals
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|curline
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
literal|'a'
case|:
case|case
literal|'u'
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|,
name|targs
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|analyze
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|,
name|Pnil
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|a_fpr_formals
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|v
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|Vnil
operator|&&
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
name|a_tag
argument_list|(
name|v
argument_list|,
operator|&
name|formals
argument_list|)
expr_stmt|;
else|else
name|analyze
argument_list|(
name|v
argument_list|,
operator|&
name|formals
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'='
case|:
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
operator|=
name|MkSmallInt
argument_list|(
name|nextvarnumber
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|targs
operator|!=
name|Pnil
condition|)
name|a_tag
argument_list|(
operator|(
name|value
operator|)
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|TAG_NAME
argument_list|)
argument_list|,
name|targs
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************************	*/
end_comment

begin_comment
comment|/* Table describing the actions of the fixer for each node type */
end_comment

begin_comment
comment|/* 	LIST OF CODES AND THEIR MEANING  	char	fix		n?	analyze  	0-9			n= c-'0'  	#	set curlino	++n	set curlino 	=			++n	set to nextvarnum 	!	locate		++n	analyze; force targs=&local 	a	locate		++n	analyze 	c	collateral	++n	analyze collateral 	f	fpr_formals	++n	a_fpr_formals 	g			++n	global 	h			++n	how'to formal 	l	locate		++n 	m	actual param	++n	mystery 	t	test		++n	analyze; set targs= 0 	u	unit		++n	analyze 	v	evaluate	++n 	x	execute		++n	analyze  	?	special code for UNPARSED 	C	special code for comparison 	D	special code for DYAF 	E	special code for DYAPRD 	G	jumpto(l1) 	H	here(&l1) 	I	if (*Branch(t, n) != NilTree) jump2here(t) 	J	jump2here(t) 	K	hold(&st) 	L	let_go(&st) 	M	special code for MONF 	N	special code for MONPRD 	R	if (!reachable()) error("command cannot be reached") 	S	jumpto(Stop) 	T	special code for TAG 	U	special code for user-defined-command 	V	visit(t) 	W	visit2(t, seterr(1)) 	X	visit(t) or lvisit(t) depending on flag 	Y	special code for YIELD/TEST 	Z	special code for refinement 	  */
end_comment

begin_decl_stmt
name|Visible
name|string
name|gentab
index|[]
init|=
block|{
comment|/* HOW_TO */
literal|"1h3xSu6="
block|,
comment|/* YIELD */
literal|"2fV4xYu7="
block|,
comment|/* TEST */
literal|"2fV4xYu7="
block|,
comment|/* REFINEMENT */
literal|"H2xZSu"
block|,
comment|/* Commands */
comment|/* SUITE */
literal|"#RVx3x"
block|,
comment|/* PUT */
literal|"vaV"
block|,
comment|/* INSERT */
literal|"vlV"
block|,
comment|/* REMOVE */
literal|"vlV"
block|,
comment|/* CHOOSE */
literal|"avV"
block|,
comment|/* DRAW */
literal|"aV"
block|,
comment|/* SET_RANDOM */
literal|"vV"
block|,
comment|/* DELETE */
literal|"lV"
block|,
comment|/* CHECK */
literal|"tV"
block|,
comment|/* SHARE */
literal|"g"
block|,
comment|/* WRITE */
literal|"1vV"
block|,
comment|/* READ */
literal|"avV"
block|,
comment|/* READ_RAW */
literal|"aV"
block|,
comment|/* IF */
literal|"tV2xJ"
block|,
comment|/* WHILE */
literal|"HtV2xGJ"
block|,
comment|/* FOR */
literal|"avHV3xGJ"
block|,
comment|/* SELECT */
literal|"1x"
block|,
comment|/* TEST_SUITE */
literal|"#tW3xKIxL"
block|,
comment|/* ELSE */
literal|"#2x"
block|,
comment|/* QUIT */
literal|"VS"
block|,
comment|/* RETURN */
literal|"vVS"
block|,
comment|/* REPORT */
literal|"tVS"
block|,
comment|/* SUCCEED */
literal|"VS"
block|,
comment|/* FAIL */
literal|"VS"
block|,
comment|/* USER_COMMAND */
literal|"1mUV"
block|,
comment|/* EXTENDED_COMMAND */
literal|"1cV"
block|,
comment|/* Expressions, targets, tests */
comment|/* TAG */
literal|"T"
block|,
comment|/* COMPOUND */
literal|"a"
block|,
comment|/* Expressions, targets */
comment|/* COLLATERAL */
literal|"cX"
block|,
comment|/* SELECTION */
literal|"lvX"
block|,
comment|/* BEHEAD */
literal|"lvX"
block|,
comment|/* CURTAIL */
literal|"lvX"
block|,
comment|/* Expressions, tests */
comment|/* UNPARSED */
literal|"?"
block|,
comment|/* Expressions */
comment|/* MONF */
literal|"M1vV"
block|,
comment|/* DYAF */
literal|"Dv2vV"
block|,
comment|/* NUMBER */
literal|"V"
block|,
comment|/* TEXT_DIS */
literal|"1v"
block|,
comment|/* TEXT_LIT */
literal|"1vV"
block|,
comment|/* TEXT_CONV */
literal|"vvV"
block|,
comment|/* ELT_DIS */
literal|"V"
block|,
comment|/* LIST_DIS */
literal|"cV"
block|,
comment|/* RANGE_DIS */
literal|"vvV"
block|,
comment|/* TAB_DIS */
literal|"cV"
block|,
comment|/* Tests */
comment|/* AND */
literal|"tVtJ"
block|,
comment|/* OR */
literal|"tVtJ"
block|,
comment|/* NOT */
literal|"tV"
block|,
comment|/* SOME_IN */
literal|"!vHVtGJ"
block|,
comment|/* EACH_IN */
literal|"!vHVtGJ"
block|,
comment|/* NO_IN */
literal|"!vHVtGJ"
block|,
comment|/* SOME_PARSING */
literal|"!vHVtGJ"
block|,
comment|/* EACH_PARSING */
literal|"!vHVtGJ"
block|,
comment|/* NO_PARSING */
literal|"!vHVtGJ"
block|,
comment|/* MONPRD */
literal|"N1vV"
block|,
comment|/* DYAPRD */
literal|"Ev2vV"
block|,
comment|/* LESS_THAN */
literal|"vvVC"
block|,
comment|/* AT_MOST */
literal|"vvVC"
block|,
comment|/* GREATER_THAN */
literal|"vvVC"
block|,
comment|/* AT_LEAST */
literal|"vvVC"
block|,
comment|/* EQUAL */
literal|"vvVC"
block|,
comment|/* UNEQUAL */
literal|"vvVC"
block|,
comment|/* Nonode */
literal|""
block|,
comment|/* TAGformal */
literal|"T"
block|,
comment|/* TAGlocal */
literal|"T"
block|,
comment|/* TAGglobal */
literal|"T"
block|,
comment|/* TAGmystery */
literal|"T"
block|,
comment|/* TAGrefinement */
literal|"T"
block|,
comment|/* TAGzerfun */
literal|"T"
block|,
comment|/* TAGzerprd */
literal|"T"
block|,
comment|/* ACTUAL */
literal|"1mm"
block|,
comment|/* FORMAL */
literal|"1hh"
block|, }
decl_stmt|;
end_decl_stmt

end_unit

