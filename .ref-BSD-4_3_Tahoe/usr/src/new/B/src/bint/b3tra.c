begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3tra.c,v 1.4 85/08/22 16:59:43 timo Exp $ */
end_comment

begin_comment
comment|/* Trace facility for interpreter */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_comment
comment|/* For 'tracing' */
end_comment

begin_include
include|#
directive|include
file|"b3int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_COMMAND
end_ifdef

begin_function
name|Visible
name|Procedure
name|tr_on
parameter_list|()
block|{
name|tracing
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|tr_off
parameter_list|()
block|{
name|tracing
operator|=
name|No
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|EXT_COMMAND
end_endif

begin_decl_stmt
name|Visible
name|string
name|opcodes
index|[]
init|=
block|{
literal|"HOW_TO"
block|,
literal|"YIELD"
block|,
literal|"TEST"
block|,
literal|"REFINEMENT"
block|,
comment|/* Commands */
literal|"SUITE"
block|,
literal|"PUT"
block|,
literal|"INSERT"
block|,
literal|"REMOVE"
block|,
literal|"CHOOSE"
block|,
literal|"DRAW"
block|,
literal|"SET_RANDOM"
block|,
literal|"DELETE"
block|,
literal|"CHECK"
block|,
literal|"SHARE"
block|,
literal|"WRITE"
block|,
literal|"READ"
block|,
literal|"READ_RAW"
block|,
literal|"IF"
block|,
literal|"WHILE"
block|,
literal|"FOR"
block|,
literal|"SELECT"
block|,
literal|"TEST_SUITE"
block|,
literal|"ELSE"
block|,
literal|"QUIT"
block|,
literal|"RETURN"
block|,
literal|"REPORT"
block|,
literal|"SUCCEED"
block|,
literal|"FAIL"
block|,
literal|"USER_COMMAND"
block|,
literal|"EXTENDED_COMMAND"
block|,
comment|/* Expressions, targets, tests */
literal|"TAG"
block|,
literal|"COMPOUND"
block|,
comment|/* Expressions, targets */
literal|"COLLATERAL"
block|,
literal|"SELECTION"
block|,
literal|"BEHEAD"
block|,
literal|"CURTAIL"
block|,
comment|/* Expressions, tests */
literal|"UNPARSED"
block|,
comment|/* Expressions */
literal|"MONF"
block|,
literal|"DYAF"
block|,
literal|"NUMBER"
block|,
literal|"TEXT_DIS"
block|,
literal|"TEXT_LIT"
block|,
literal|"TEXT_CONV"
block|,
literal|"ELT_DIS"
block|,
literal|"LIST_DIS"
block|,
literal|"RANGE_DIS"
block|,
literal|"TAB_DIS"
block|,
comment|/* Tests */
literal|"AND"
block|,
literal|"OR"
block|,
literal|"NOT"
block|,
literal|"SOME_IN"
block|,
literal|"EACH_IN"
block|,
literal|"NO_IN"
block|,
literal|"SOME_PARSING"
block|,
literal|"EACH_PARSING"
block|,
literal|"NO_PARSING"
block|,
literal|"MONPRD"
block|,
literal|"DYAPRD"
block|,
literal|"LESS_THAN"
block|,
literal|"AT_MOST"
block|,
literal|"GREATER_THAN"
block|,
literal|"AT_LEAST"
block|,
literal|"EQUAL"
block|,
literal|"UNEQUAL"
block|,
literal|"Nonode"
block|,
literal|"TAGformal"
block|,
literal|"TAGlocal"
block|,
literal|"TAGglobal"
block|,
literal|"TAGmystery"
block|,
literal|"TAGrefinement"
block|,
literal|"TAGzerfun"
block|,
literal|"TAGzerprd"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOPCODES
value|((sizeof opcodes) / (sizeof opcodes[0]))
end_define

begin_function
name|Visible
name|Procedure
name|tr_node
parameter_list|(
name|p
parameter_list|)
name|parsetree
name|p
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %8x "
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|Halt
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Halt\r\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|Stop
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stop\r\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Is_parsetree
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|IsSmallInt
argument_list|(
name|p
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d\r\n"
argument_list|,
name|SmallIntVal
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Trace bad node\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|Nodetype
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|NOPCODES
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Opcode %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|opcodes
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Thread2
argument_list|(
name|p
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [*]"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|tr_jump
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Jump\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|tr_call
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Call\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|tr_ret
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Return\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

