begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1nuC.c,v 1.4 85/08/22 16:50:36 timo Exp $ */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_include
include|#
directive|include
file|"b1num.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_comment
comment|/* temporary until numconst is fixed */
end_comment

begin_function_decl
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* OS */
end_comment

begin_function_decl
specifier|extern
name|value
name|tento
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|integer
name|int_tento
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EXPDIGITS
value|10
end_define

begin_comment
comment|/* Extra positions to allow for exponent part */
end_comment

begin_comment
comment|/* -- must be larger than tenlogBASE */
end_comment

begin_define
define|#
directive|define
name|MAXDIGITS
value|(MAXNUMDIG-1)
end_define

begin_comment
comment|/* Max precision for fixed/floating numbers */
end_comment

begin_define
define|#
directive|define
name|CONVBUFSIZE
value|(MAXDIGITS+4)
end_define

begin_comment
comment|/* Maximum number of digits to print in integer notation */
end_comment

begin_comment
comment|/* (4 is the size of 'e+00' added by sprintf) */
end_comment

begin_comment
comment|/* Convert an integer to a C character string.    The character string is overwritten on each next call.    It assumes BASE is a power of 10. */
end_comment

begin_function
name|Hidden
name|char
modifier|*
name|convint
parameter_list|(
name|v
parameter_list|)
specifier|register
name|integer
name|v
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|,
name|shortbuffer
index|[
name|tenlogBASE
operator|+
literal|3
index|]
decl_stmt|;
specifier|static
name|char
name|fmt
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|neg
init|=
name|No
decl_stmt|;
if|if
condition|(
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|shortbuffer
argument_list|,
literal|"%d"
argument_list|,
name|SmallIntVal
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|shortbuffer
return|;
block|}
if|if
condition|(
name|Digit
argument_list|(
name|v
argument_list|,
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|neg
operator|=
name|Yes
expr_stmt|;
name|v
operator|=
name|int_neg
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buffer
condition|)
name|freemem
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|getmem
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|Length
argument_list|(
name|v
argument_list|)
operator|*
name|tenlogBASE
operator|+
literal|1
operator|+
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|neg
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|,
name|Msd
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%0%dd"
argument_list|,
name|tenlogBASE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
operator|++
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
operator|,
name|cp
operator|+=
name|tenlogBASE
control|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|fmt
argument_list|,
name|Digit
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|release
argument_list|(
operator|(
name|value
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_RANGE
end_ifdef

begin_comment
comment|/* This is terrible.  But never mind, it'll all change (sometimes). */
end_comment

begin_function
name|Hidden
name|bool
name|hugenumber
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|bool
name|huge
decl_stmt|;
name|real
name|w
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|huge
operator|=
name|Expo
argument_list|(
name|w
argument_list|)
operator|>
name|Maxexpo
operator|||
name|Expo
argument_list|(
name|w
argument_list|)
operator|<
name|Minexpo
operator|&&
name|Frac
argument_list|(
name|w
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
return|return
name|huge
return|;
block|}
end_function

begin_function
name|Hidden
name|string
name|convapp
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|value
name|absv
decl_stmt|,
name|tenlogv
decl_stmt|,
name|expo
decl_stmt|,
name|tentoexpo
decl_stmt|,
name|frac
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|fmt
index|[
literal|15
index|]
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|double
name|fracval
decl_stmt|,
name|expoval
decl_stmt|,
name|i
decl_stmt|;
name|absv
operator|=
name|absval
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|tenlogv
operator|=
name|log2
argument_list|(
operator|(
name|value
operator|)
name|int_10
argument_list|,
name|absv
argument_list|)
operator|,
name|release
argument_list|(
name|absv
argument_list|)
expr_stmt|;
name|expo
operator|=
name|floorf
argument_list|(
name|tenlogv
argument_list|)
operator|,
name|release
argument_list|(
name|tenlogv
argument_list|)
expr_stmt|;
name|expoval
operator|=
name|numval
argument_list|(
name|expo
argument_list|)
operator|,
name|release
argument_list|(
name|expo
argument_list|)
expr_stmt|;
if|if
condition|(
name|expoval
operator|*
name|tenlogBASE
operator|>=
name|Maxintlet
operator|||
name|expoval
operator|*
name|tenlogBASE
operator|<=
operator|-
name|Maxintlet
condition|)
block|{
name|expo
operator|=
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
name|expoval
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|tentoexpo
operator|=
name|power
argument_list|(
operator|(
name|value
operator|)
name|int_10
argument_list|,
name|expo
argument_list|)
operator|,
name|release
argument_list|(
name|expo
argument_list|)
expr_stmt|;
block|}
else|else
name|tentoexpo
operator|=
name|tento
argument_list|(
operator|(
name|int
operator|)
name|expoval
argument_list|)
expr_stmt|;
name|frac
operator|=
name|quot
argument_list|(
name|v
argument_list|,
name|tentoexpo
argument_list|)
operator|,
name|release
argument_list|(
name|tentoexpo
argument_list|)
expr_stmt|;
name|fracval
operator|=
name|numval
argument_list|(
name|frac
argument_list|)
operator|,
name|release
argument_list|(
name|frac
argument_list|)
expr_stmt|;
while|while
condition|(
name|fabs
argument_list|(
name|fracval
argument_list|)
operator|>=
literal|10
condition|)
name|fracval
operator|/=
literal|10
operator|,
operator|++
name|expoval
expr_stmt|;
while|while
condition|(
name|fabs
argument_list|(
name|fracval
argument_list|)
operator|<
literal|1
condition|)
name|fracval
operator|*=
literal|10
operator|,
operator|--
name|expoval
expr_stmt|;
name|precision
operator|=
name|MAXDIGITS
expr_stmt|;
name|i
operator|=
name|expoval
operator|<
literal|0
condition|?
operator|-
name|expoval
else|:
name|expoval
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|10
operator|&&
name|precision
operator|>
literal|2
condition|)
operator|--
name|precision
operator|,
name|i
operator|/=
literal|10
expr_stmt|;
comment|/* Loose precision for large exponents! */
comment|/* :-( But keep some too! )-: */
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%.%dlgE%%s%%2.0lf"
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|fracval
argument_list|,
name|expoval
operator|>=
literal|0
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|expoval
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|EXT_RANGE
end_endif

begin_comment
comment|/* Convert a numeric value to a C character string.    The character string is overwritten on each next call. */
end_comment

begin_function
name|Visible
name|string
name|convnum
parameter_list|(
name|v
parameter_list|)
specifier|register
name|value
name|v
decl_stmt|;
block|{
specifier|static
name|char
name|convbuf
index|[
literal|3
operator|+
name|CONVBUFSIZE
operator|+
name|EXPDIGITS
index|]
decl_stmt|;
comment|/* 3 extra for things (sign, 0.) to be stuck on front of it */
specifier|static
name|char
name|fmt
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|bufstart
init|=
name|convbuf
operator|+
literal|3
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|bufstart
decl_stmt|;
name|double
name|x
decl_stmt|;
if|if
condition|(
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|convint
argument_list|(
operator|(
name|integer
operator|)
name|v
argument_list|)
return|;
ifdef|#
directive|ifdef
name|EXT_RANGE
if|if
condition|(
name|hugenumber
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|convapp
argument_list|(
name|v
argument_list|)
return|;
endif|#
directive|endif
comment|/* Reasonably-sized reals and rationals are treated alike. 	   However, not-too-large rationals resulting from 	   'n round x' are transformed to f-format. */
name|x
operator|=
name|numval
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%.%dlg"
argument_list|,
name|MAXDIGITS
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bufstart
argument_list|,
name|fmt
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|bufstart
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
operator|++
name|cp
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'e'
condition|)
block|{
comment|/* change sprintf's 'e' to 'E' */
operator|*
name|cp
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'E'
condition|)
block|{
comment|/* Delete trailing zeros after decimal pt; don't rely on %g */
for|for
control|(
name|cp
operator|=
name|bufstart
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|;
operator|++
name|cp
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
for|for
control|(
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'E'
condition|;
operator|++
name|cp
control|)
empty_stmt|;
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|++
name|cp
operator|<
name|ep
condition|)
block|{
while|while
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
endif|IBMPC
if|if
condition|(
name|Rational
argument_list|(
name|v
argument_list|)
operator|&&
name|Roundsize
argument_list|(
name|v
argument_list|)
operator|>
literal|0
operator|&&
operator|*
name|cp
operator|!=
literal|'E'
condition|)
block|{
name|int
name|i
init|=
name|Roundsize
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|int
name|j
init|=
literal|1
decl_stmt|;
comment|/* Counts digits allowed beyond MAXDIGITS, 1 for '.' */
for|for
control|(
name|cp
operator|=
name|bufstart
init|;
operator|*
name|cp
operator|==
literal|'0'
condition|;
operator|++
name|cp
control|)
operator|++
name|j
expr_stmt|;
comment|/* Allow a trailing zero for each leading zero */
for|for
control|(
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|;
operator|++
name|cp
control|)
empty_stmt|;
comment|/* Find '.' or end of string */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
comment|/* Append '.' if not found */
operator|*
operator|++
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|cp
operator|==
literal|'0'
condition|)
comment|/* Allow more precision if leading zeros */
operator|++
name|j
operator|,
operator|--
name|i
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|--
name|i
operator|,
operator|++
name|cp
expr_stmt|;
comment|/* Find last digit */
block|}
comment|/* Append extra zeros (but don't show more precision 		   than sprintf can!) */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
operator|&&
name|cp
operator|<
name|bufstart
operator|+
name|MAXDIGITS
operator|+
name|j
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Append new terminating null byte */
block|}
return|return
name|bufstart
return|;
block|}
end_function

begin_comment
comment|/* Convert a string to a number (assume it's syntactically correct!).    Pointers to the first and last+1 characters are given.    Again, BASE must be a power of 10.    ********** NEW **********    If E_EXACT is defined, all numbers input are made exact, even if    E-notation is used.    ********** WARNING **********    This routine must be fixed, because it accesses the source buffer    and it shouldn't because it's in the wrong place in the hierarchy */
end_comment

begin_function
name|Visible
name|value
name|numconst
parameter_list|(
name|text
parameter_list|,
name|end
parameter_list|)
specifier|register
name|txptr
name|text
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|txptr
name|tp
decl_stmt|;
specifier|register
name|int
name|numdigs
decl_stmt|,
name|fraclen
decl_stmt|;
name|integer
name|a
decl_stmt|;
specifier|register
name|digit
name|accu
decl_stmt|;
name|value
name|c
decl_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|text
argument_list|)
operator|==
literal|'E'
condition|)
name|a
operator|=
name|int_1
expr_stmt|;
else|else
block|{
while|while
condition|(
name|text
operator|<
name|end
operator|&&
name|Char
argument_list|(
name|text
argument_list|)
operator|==
literal|'0'
condition|)
operator|++
name|text
expr_stmt|;
comment|/* Skip leading zeros */
for|for
control|(
name|tp
operator|=
name|text
init|;
name|tp
operator|<
name|end
operator|&&
name|isdigit
argument_list|(
name|Char
argument_list|(
name|tp
argument_list|)
argument_list|)
condition|;
operator|++
name|tp
control|)
empty_stmt|;
comment|/* Count integral digits */
name|numdigs
operator|=
name|tp
operator|-
name|text
expr_stmt|;
name|fraclen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|<
name|end
operator|&&
name|Char
argument_list|(
name|tp
argument_list|)
operator|==
literal|'.'
condition|)
block|{
operator|++
name|tp
expr_stmt|;
for|for
control|(
init|;
name|tp
operator|<
name|end
operator|&&
name|isdigit
argument_list|(
name|Char
argument_list|(
name|tp
argument_list|)
argument_list|)
condition|;
operator|++
name|tp
control|)
operator|++
name|fraclen
expr_stmt|;
comment|/* Count fractional digits */
name|numdigs
operator|+=
name|fraclen
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|integer
operator|)
name|grab_num
argument_list|(
operator|(
name|numdigs
operator|+
name|tenlogBASE
operator|-
literal|1
operator|)
operator|/
name|tenlogBASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|Vnil
return|;
comment|/* Recovered error */
name|accu
operator|=
literal|0
expr_stmt|;
comment|/* Integer part: */
for|for
control|(
init|;
name|text
operator|<
name|end
operator|&&
name|isdigit
argument_list|(
name|Char
argument_list|(
name|text
argument_list|)
argument_list|)
condition|;
operator|++
name|text
control|)
block|{
name|accu
operator|=
name|accu
operator|*
literal|10
operator|+
name|Char
argument_list|(
name|text
argument_list|)
operator|-
literal|'0'
expr_stmt|;
operator|--
name|numdigs
expr_stmt|;
if|if
condition|(
name|numdigs
operator|%
name|tenlogBASE
operator|==
literal|0
condition|)
block|{
name|Digit
argument_list|(
name|a
argument_list|,
name|numdigs
operator|/
name|tenlogBASE
argument_list|)
operator|=
name|accu
expr_stmt|;
name|accu
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Fraction: */
if|if
condition|(
name|text
operator|<
name|end
operator|&&
name|Char
argument_list|(
name|text
argument_list|)
operator|==
literal|'.'
condition|)
block|{
operator|++
name|text
expr_stmt|;
for|for
control|(
init|;
name|text
operator|<
name|end
operator|&&
name|isdigit
argument_list|(
name|Char
argument_list|(
name|text
argument_list|)
argument_list|)
condition|;
operator|++
name|text
control|)
block|{
name|accu
operator|=
name|accu
operator|*
literal|10
operator|+
name|Char
argument_list|(
name|text
argument_list|)
operator|-
literal|'0'
expr_stmt|;
operator|--
name|numdigs
expr_stmt|;
if|if
condition|(
name|numdigs
operator|%
name|tenlogBASE
operator|==
literal|0
condition|)
block|{
name|Digit
argument_list|(
name|a
argument_list|,
name|numdigs
operator|/
name|tenlogBASE
argument_list|)
operator|=
name|accu
expr_stmt|;
name|accu
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|numdigs
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|800
argument_list|,
literal|"numconst: can't happen"
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|int_canon
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* Exponent: */
if|if
condition|(
name|text
operator|>=
name|end
operator|||
name|Char
argument_list|(
name|text
argument_list|)
operator|!=
literal|'E'
condition|)
block|{
name|integer
name|b
init|=
name|int_tento
argument_list|(
name|fraclen
argument_list|)
decl_stmt|;
name|c
operator|=
name|mk_exact
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|fraclen
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|expo
init|=
literal|0
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|value
name|b
decl_stmt|;
operator|++
name|text
expr_stmt|;
if|if
condition|(
name|text
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|Char
argument_list|(
name|text
argument_list|)
operator|==
literal|'+'
condition|)
operator|++
name|text
expr_stmt|;
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|text
argument_list|)
operator|==
literal|'-'
condition|)
block|{
operator|++
name|text
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|text
operator|<
name|end
operator|&&
name|isdigit
argument_list|(
name|Char
argument_list|(
name|text
argument_list|)
argument_list|)
condition|;
operator|++
name|text
control|)
block|{
name|expo
operator|=
name|expo
operator|*
literal|10
operator|+
name|Char
argument_list|(
name|text
argument_list|)
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|expo
operator|>
name|Maxint
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|801
argument_list|,
literal|"excessive exponent in E-notation"
argument_list|)
argument_list|)
expr_stmt|;
name|expo
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|b
operator|=
name|tento
argument_list|(
operator|(
name|int
operator|)
name|expo
operator|*
name|sign
operator|-
name|fraclen
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|E_EXACT
comment|/* Make approximate number if E-notation used */
name|c
operator|=
name|approximate
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|==
name|int_1
condition|)
name|c
operator|=
name|b
expr_stmt|;
else|else
name|c
operator|=
name|prod
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|,
name|b
argument_list|)
operator|,
name|release
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * printnum(f, v) writes a number v on file f in such a way that it  * can be read back identically, assuming integral powers of ~2 can be  * computed exactly.  (This is necessary for the permanent environment.)  */
end_comment

begin_function
name|Visible
name|Procedure
name|printnum
parameter_list|(
name|f
parameter_list|,
name|v
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
name|Approximate
argument_list|(
name|v
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PRINT_APPROX
if|if
condition|(
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|v
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"~0"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
name|char
name|fmt
index|[
literal|25
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%.%dlgE0*~2**%%.0lf"
argument_list|,
name|MAXDIGITS
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|fmt
argument_list|,
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|v
argument_list|)
argument_list|,
name|Expo
argument_list|(
operator|(
name|real
operator|)
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
else|#
directive|else
name|fputc
argument_list|(
literal|'~'
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|Rational
argument_list|(
name|v
argument_list|)
operator|&&
name|Denominator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
operator|!=
name|int_1
condition|)
block|{
name|int
name|i
init|=
name|Roundsize
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|convnum
argument_list|(
operator|(
name|value
operator|)
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<=
name|MAXDIGITS
condition|)
block|{
comment|/* The assumption here is that in u/v, the Roundsize 			   of the result is the sum of that of the operands. */
name|putc
argument_list|(
literal|'.'
argument_list|,
name|f
argument_list|)
expr_stmt|;
do|do
name|putc
argument_list|(
literal|'0'
argument_list|,
name|f
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
block|}
name|putc
argument_list|(
literal|'/'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|value
operator|)
name|Denominator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|convnum
argument_list|(
name|v
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

