begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2sou.c,v 1.1 84/06/28 00:49:20 timo Exp $ */
end_comment

begin_comment
comment|/* Sources: maintaining units and values on external files */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_comment
comment|/* shouldn't really */
end_comment

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2scr.h"
end_include

begin_include
include|#
directive|include
file|"b2err.h"
end_include

begin_include
include|#
directive|include
file|"b2key.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_include
include|#
directive|include
file|"b2fil.h"
end_include

begin_include
include|#
directive|include
file|"b2sou.h"
end_include

begin_comment
comment|/************************** UNITS ************************************/
end_comment

begin_decl_stmt
name|value
name|defunits
decl_stmt|,
name|aster
decl_stmt|,
name|global
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|value
modifier|*
name|unit_defn
parameter_list|(
name|fn
parameter_list|)
name|value
name|fn
decl_stmt|;
block|{
return|return
name|envassoc
argument_list|(
name|defunits
argument_list|,
name|fn
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|def_unit
parameter_list|(
name|u
parameter_list|,
name|un
parameter_list|,
name|ut
parameter_list|)
name|value
name|u
decl_stmt|,
name|un
decl_stmt|;
name|literal
name|ut
decl_stmt|;
block|{
name|value
name|fn
init|=
name|f_uname
argument_list|(
name|un
argument_list|,
name|ut
argument_list|)
decl_stmt|;
name|e_replace
argument_list|(
name|u
argument_list|,
operator|&
name|defunits
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|value
name|unit_info
parameter_list|(
name|un
parameter_list|,
name|ut
parameter_list|)
name|value
name|un
decl_stmt|;
name|literal
name|ut
decl_stmt|;
block|{
name|value
name|fn
init|=
name|f_uname
argument_list|(
name|un
argument_list|,
name|ut
argument_list|)
decl_stmt|;
name|value
modifier|*
name|aa
init|=
name|unit_defn
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|aa
operator|==
name|Pnil
condition|)
name|syserr
argument_list|(
literal|"undefined function"
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|*
name|aa
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|is_loaded
parameter_list|(
name|un
parameter_list|,
name|ut
parameter_list|,
name|aa
parameter_list|)
name|value
name|un
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|ut
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|value
name|fn
init|=
name|f_uname
argument_list|(
name|un
argument_list|,
name|ut
argument_list|)
decl_stmt|;
name|txptr
name|tx0
decl_stmt|,
name|txstart0
decl_stmt|;
operator|*
name|aa
operator|=
name|unit_defn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|aa
operator|!=
name|Pnil
condition|)
block|{
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
comment|/*already loaded*/
name|release
argument_list|(
name|iname
argument_list|)
expr_stmt|;
name|iname
operator|=
name|fn
expr_stmt|;
name|ifile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|iname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|==
name|NULL
condition|)
block|{
name|vs_ifile
argument_list|()
expr_stmt|;
return|return
name|No
return|;
block|}
name|tx0
operator|=
name|tx
expr_stmt|;
name|txstart0
operator|=
name|txstart
expr_stmt|;
name|open_stream
argument_list|()
expr_stmt|;
name|Eof
operator|=
name|Eof0
operator|=
name|No
expr_stmt|;
name|ilev
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
name|get_unit
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
operator|*
name|aa
operator|=
name|unit_defn
argument_list|(
name|iname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|aa
operator|)
operator|==
name|Pnil
condition|)
block|{
name|uname
operator|=
name|un
expr_stmt|;
comment|/*utype= ???*/
name|parerr
argument_list|(
literal|"filename and unit name incompatible"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|close_stream
argument_list|(
name|tx0
argument_list|,
name|txstart0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
name|Eof
operator|=
name|Eof0
operator|=
name|No
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_unit
parameter_list|(
name|un
parameter_list|,
name|ut
parameter_list|,
name|aa
parameter_list|)
name|value
name|un
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|ut
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|context
name|c
decl_stmt|;
name|bool
name|is
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|is
operator|=
name|is_loaded
argument_list|(
name|un
argument_list|,
name|ut
argument_list|,
name|aa
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|is
return|;
block|}
end_block

begin_define
define|#
directive|define
name|DISCARD
value|"the unit name is already in use; should the old unit be discarded?"
end_define

begin_define
define|#
directive|define
name|CANT_WRITE
value|"cannot open file for editing; you need write permission in directory"
end_define

begin_define
define|#
directive|define
name|CANT_READ
value|"unable to find file"
end_define

begin_function
name|Visible
name|bool
name|unit
parameter_list|()
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|FILE
modifier|*
name|ofile
decl_stmt|;
if|if
condition|(
name|atkw
argument_list|(
name|HOW_TO
argument_list|)
operator|||
name|atkw
argument_list|(
name|YIELD
argument_list|)
operator|||
name|atkw
argument_list|(
name|TEST
argument_list|)
condition|)
block|{
name|tx
operator|=
name|tx0
expr_stmt|;
name|uheading
argument_list|(
name|aster
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|fname
operator|=
name|f_uname
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_defn
argument_list|(
name|fname
argument_list|)
operator|!=
name|Pnil
condition|)
block|{
if|if
condition|(
name|is_intended
argument_list|(
name|DISCARD
argument_list|)
condition|)
name|free_unit
argument_list|(
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
name|tx
operator|=
name|ceol
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
if|if
condition|(
name|interactive
condition|)
block|{
name|ofile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofile
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|CANT_WRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
name|Eotc
condition|)
name|putc
argument_list|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
name|tx
operator|--
expr_stmt|;
name|fclose
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|ed_unit
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
name|get_unit
argument_list|(
name|No
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
else|else
return|return
name|No
return|;
block|}
end_function

begin_define
define|#
directive|define
name|On_file
value|Vnil
end_define

begin_decl_stmt
name|value
name|last_tname
init|=
name|Vnil
decl_stmt|,
name|last_tfname
init|=
name|Vnil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*target*/
end_comment

begin_function
name|Visible
name|Procedure
name|special
parameter_list|()
block|{
switch|switch
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
condition|)
block|{
case|case
literal|':'
case|:
name|ediuni
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|editar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|shellcmd
argument_list|()
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"edit"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FnSwitch
parameter_list|(
name|X
parameter_list|)
value|{release(fname); type= X; fname= f_uname(name, X);}
end_define

begin_define
define|#
directive|define
name|MONADIC
define|\
value|"the unit name is in use both for a monadic and a dyadic version;\n\ *** do you want to edit the monadic version?"
end_define

begin_function
name|Hidden
name|Procedure
name|ediuni
parameter_list|()
block|{
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|lst_uhds
argument_list|()
expr_stmt|;
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Ceol
argument_list|(
name|tx
argument_list|)
condition|)
block|{
if|if
condition|(
name|erruname
operator|==
name|Vnil
condition|)
name|parerr
argument_list|(
literal|"no current unit name known"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|name
operator|=
name|copy
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
name|type
operator|=
name|errutype
expr_stmt|;
name|fname
operator|=
name|f_uname
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Cap
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|name
operator|=
name|keyword
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|type
operator|=
name|FHW
expr_stmt|;
name|fname
operator|=
name|f_uname
argument_list|(
name|name
argument_list|,
name|FHW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|name
operator|=
name|tag
argument_list|()
expr_stmt|;
name|type
operator|=
name|FZR
expr_stmt|;
name|fname
operator|=
name|f_uname
argument_list|(
name|name
argument_list|,
name|FZR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_exists
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|bool
name|is_mon
decl_stmt|,
name|is_dya
decl_stmt|;
name|FnSwitch
argument_list|(
name|FMN
argument_list|)
expr_stmt|;
name|is_mon
operator|=
name|f_exists
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|FnSwitch
argument_list|(
name|FDY
argument_list|)
expr_stmt|;
name|is_dya
operator|=
name|f_exists
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mon
operator|&&
operator|(
operator|!
name|is_dya
operator|||
name|is_intended
argument_list|(
name|MONADIC
argument_list|)
operator|)
condition|)
name|FnSwitch
argument_list|(
name|FMN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|parerr
argument_list|(
literal|"I find nothing editible here"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_exists
argument_list|(
name|fname
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"no such unit in this workspace"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ens_filed
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ed_unit
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|Forward
name|bool
name|still_there
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|intlet
name|err_line
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Edit a unit.    It is possible that the user messes things up with the w command:    this is not checked. However it is allowed to rename the unit,    or delete it completely. If the file is empty, the unit is disposed of.    Otherwise, uheading is used to work out the name and adicity:    if these have changed, the new unit is written out to a new file,    and the original is written back. Thus the original is not lost.    Inability to find the file at all leads to the main_loop,    so that nothing is changed. */
end_comment

begin_function
name|Hidden
name|Procedure
name|ed_unit
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|fname
parameter_list|)
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
name|literal
name|type
decl_stmt|;
block|{
name|intlet
name|el
init|=
name|err_line
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|value
name|nname
decl_stmt|,
name|nfname
decl_stmt|,
name|sname
decl_stmt|;
name|literal
name|ntype
decl_stmt|;
name|sname
operator|=
name|f_save
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/*in case the unit gets renamed*/
name|f_edit
argument_list|(
name|fname
argument_list|,
name|el
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_there
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|ilev
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
name|uheading
argument_list|(
name|name
argument_list|,
operator|&
name|nname
argument_list|,
operator|&
name|ntype
argument_list|)
expr_stmt|;
name|nfname
operator|=
name|f_uname
argument_list|(
name|nname
argument_list|,
name|ntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|fname
argument_list|,
name|nfname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* unit heading was changed */
name|f_rename
argument_list|(
name|fname
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|f_rename
argument_list|(
name|sname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
name|erruname
operator|=
name|copy
argument_list|(
name|nname
argument_list|)
expr_stmt|;
name|errutype
operator|=
name|ntype
expr_stmt|;
block|}
else|else
block|{
name|release
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
name|erruname
operator|=
name|copy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|errutype
operator|=
name|type
expr_stmt|;
name|f_delete
argument_list|(
name|sname
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|nname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|nfname
argument_list|)
expr_stmt|;
name|get_unit
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
comment|/* file is still open */
block|}
else|else
block|{
name|free_unit
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|f_delete
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
name|erruname
operator|=
name|Vnil
expr_stmt|;
name|errlino
operator|=
literal|0
expr_stmt|;
block|}
name|release
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|inistreams
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|uheading
parameter_list|(
name|oname
parameter_list|,
name|nname
parameter_list|,
name|ntype
parameter_list|)
name|value
name|oname
decl_stmt|,
decl|*
name|nname
decl_stmt|;
end_function

begin_decl_stmt
name|literal
modifier|*
name|ntype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|context
name|ic
decl_stmt|;
name|bool
name|hu
init|=
name|No
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|uname
operator|=
name|oname
expr_stmt|;
name|lino
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|hu
operator|=
name|atkw
argument_list|(
name|HOW_TO
argument_list|)
operator|)
operator|||
name|atkw
argument_list|(
name|YIELD
argument_list|)
operator|||
name|atkw
argument_list|(
name|TEST
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur_ilev
operator|!=
literal|0
condition|)
name|parerr
argument_list|(
literal|"unit starts with indentation"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|hu
condition|)
block|{
name|uname
operator|=
name|keyword
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|utype
operator|=
name|FHW
expr_stmt|;
block|}
else|else
block|{
name|literal
name|adic
decl_stmt|;
name|ytu_heading
argument_list|(
operator|&
name|uname
argument_list|,
operator|&
name|adic
argument_list|,
name|ceol
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|utype
operator|=
operator|(
name|adic
operator|==
name|Zer
condition|?
name|FZR
else|:
name|adic
operator|==
name|Mon
condition|?
name|FMN
else|:
name|FDY
operator|)
expr_stmt|;
block|}
operator|*
name|nname
operator|=
name|uname
expr_stmt|;
comment|/*should really be n=copy(u); release(u);*/
operator|*
name|ntype
operator|=
name|utype
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"no HOW'TO, YIELD or TEST where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Hidden
name|bool
name|still_there
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
comment|/* Find out if the file exists, and is not empty. 	   Some editors don't allow a file to be edited to empty, 	   but insist it should be at least one empty line. 	   Because it is hard to unget 2 chars, an initial empty line 	   may be disregarded, but this is not harmful. */
name|int
name|k
decl_stmt|;
name|ifile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|==
name|NULL
condition|)
block|{
name|vs_ifile
argument_list|()
expr_stmt|;
name|error
argument_list|(
name|CANT_READ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|==
name|EOF
operator|||
operator|(
name|k
operator|==
literal|'\n'
operator|&&
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|f_delete
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
return|return
name|No
return|;
block|}
name|ungetc
argument_list|(
name|k
argument_list|,
name|ifile
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|ens_filed
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
name|value
modifier|*
name|aa
init|=
name|unit_defn
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|how
modifier|*
name|du
decl_stmt|;
if|if
condition|(
name|aa
operator|!=
name|Pnil
condition|)
block|{
name|du
operator|=
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|filed
operator|==
name|No
condition|)
block|{
name|txptr
name|ux
init|=
name|du
operator|->
name|fux
decl_stmt|,
name|lux
init|=
name|du
operator|->
name|lux
decl_stmt|;
name|FILE
modifier|*
name|ofile
init|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ofile
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|CANT_WRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|ux
operator|<
name|lux
condition|)
block|{
name|char
name|c
init|=
operator|*
name|ux
operator|++
decl_stmt|;
name|putc
argument_list|(
name|c
operator|==
name|Eouc
condition|?
literal|'\n'
else|:
name|c
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|du
operator|->
name|filed
operator|=
name|Yes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|Hidden
name|intlet
name|err_line
parameter_list|(
name|name
parameter_list|)
name|value
name|name
decl_stmt|;
block|{
name|intlet
name|el
decl_stmt|;
if|if
condition|(
name|errlino
operator|==
literal|0
operator|||
name|compare
argument_list|(
name|erruname
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|el
operator|=
name|errlino
expr_stmt|;
name|errlino
operator|=
literal|0
expr_stmt|;
return|return
name|el
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|free_unit
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
name|e_delete
argument_list|(
operator|&
name|defunits
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|shellcmd
parameter_list|()
block|{
name|system
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************** VALUES ***************************************/
end_comment

begin_comment
comment|/* The permanent environment in the old format was kept as a single file */
end_comment

begin_comment
comment|/* but this caused slow start ups if the file was big.			 */
end_comment

begin_comment
comment|/* Thus the new version stores each permanent target on a separate file, */
end_comment

begin_comment
comment|/* that furthermore is only loaded on demand.				 */
end_comment

begin_comment
comment|/* To achieve this, a directory is kept of the permanent tags and their	 */
end_comment

begin_comment
comment|/* file names. Care has to be taken that user interrupts occurring in	 */
end_comment

begin_comment
comment|/* the middle of an update of this directory do the least harm.		 */
end_comment

begin_comment
comment|/* Having the directory refer to a non-existent file is considered less	 */
end_comment

begin_comment
comment|/* harmful than leaving a file around that can never be accessed, for	 */
end_comment

begin_comment
comment|/* instance, so a file is deleted before its directory entry,		 */
end_comment

begin_comment
comment|/* and so forth.							 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_decl_stmt
name|value
name|b_perm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*The table that maps tags to their file names*/
end_comment

begin_function
name|Visible
name|bool
name|is_tloaded
parameter_list|(
name|name
parameter_list|,
name|aa
parameter_list|)
name|value
name|name
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_block
block|{
return|return
name|No
return|;
comment|/*for now*/
block|}
end_block

begin_function
name|Hidden
name|bool
name|new_tname
parameter_list|(
name|name
parameter_list|,
name|fname
parameter_list|)
name|value
name|name
decl_stmt|,
decl|*
name|fname
decl_stmt|;
end_function

begin_block
block|{
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
name|in_env
argument_list|(
name|b_perm
argument_list|,
name|name
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
operator|*
name|fname
operator|=
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
else|else
block|{
operator|*
name|fname
operator|=
name|f_tname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|e_replace
argument_list|(
operator|*
name|fname
argument_list|,
operator|&
name|b_perm
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
end_block

begin_function
name|Hidden
name|Procedure
name|editar
parameter_list|()
block|{
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'='
condition|)
block|{
name|lst_ttgs
argument_list|()
expr_stmt|;
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Ceol
argument_list|(
name|tx
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_tfname
operator|==
name|Vnil
condition|)
name|parerr
argument_list|(
literal|"no current target name known"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fname
operator|=
name|copy
argument_list|(
name|last_tfname
argument_list|)
expr_stmt|;
name|name
operator|=
name|copy
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|name
operator|=
name|tag
argument_list|()
expr_stmt|;
name|VOID
name|new_tname
argument_list|(
name|name
argument_list|,
operator|&
name|fname
argument_list|)
decl_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"I find nothing editible here"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_exists
argument_list|(
name|fname
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"no such target in this workspace"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ens_tfiled
argument_list|(
name|name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ed_target
argument_list|(
name|name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|lst_ttgs
parameter_list|()
block|{
name|int
name|k
decl_stmt|,
name|len
decl_stmt|;
name|len
operator|=
name|length
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|writ
argument_list|(
operator|*
name|key
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|wri_space
argument_list|()
expr_stmt|;
block|}
name|newline
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|ed_target
parameter_list|(
name|name
parameter_list|,
name|fname
parameter_list|)
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
block|{
comment|/* Edit a target. The value in the target is written to the file, 	   and then removed from the internal permanent environment so that 	   if a syntax error occurs when reading the value back, the value is 	   absent from the internal permanent environment. 	   Thus when editing the file to correct the syntax error, the 	   file doesn't get overwritten. 	   The contents may be completely deleted in which case the target is 	   deleted. 	*/
name|value
name|v
decl_stmt|,
name|p
decl_stmt|;
name|context
name|c
decl_stmt|;
name|bool
name|wia
decl_stmt|;
name|f_edit
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_there
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|last_tfname
argument_list|)
expr_stmt|;
name|last_tfname
operator|=
name|copy
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
name|last_tname
operator|=
name|copy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
comment|/*since still_there leaves it open*/
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|wia
operator|=
name|interactive
expr_stmt|;
name|cntxt
operator|=
name|In_value
expr_stmt|;
name|getval
argument_list|(
name|fname
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/*		p= mk_per(v); */
name|p
operator|=
name|v
expr_stmt|;
name|e_replace
argument_list|(
name|p
argument_list|,
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|wia
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/*		release(v); */
block|}
else|else
block|{
name|e_delete
argument_list|(
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|e_delete
argument_list|(
operator|&
name|b_perm
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|last_tfname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
name|last_tfname
operator|=
name|Vnil
expr_stmt|;
name|last_tname
operator|=
name|Vnil
expr_stmt|;
block|}
name|f_delete
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|ens_tfiled
parameter_list|(
name|name
parameter_list|,
name|fname
parameter_list|)
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
block|{
name|value
name|p
decl_stmt|,
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
name|in_env
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|,
operator|&
name|aa
argument_list|)
operator|&&
operator|!
name|Is_filed
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
name|putval
argument_list|(
name|fname
argument_list|,
operator|*
name|aa
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|p
operator|=
name|mk_per
argument_list|(
name|Vnil
argument_list|)
expr_stmt|;
name|e_replace
argument_list|(
name|p
argument_list|,
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|getval
parameter_list|(
name|nm
parameter_list|,
name|v
parameter_list|)
name|value
name|nm
decl_stmt|,
decl|*
name|v
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|buf
init|=
name|Nil
decl_stmt|;
name|int
name|k
decl_stmt|;
name|release
argument_list|(
name|iname
argument_list|)
expr_stmt|;
name|iname
operator|=
name|copy
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|ifile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|iname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|!=
name|NULL
condition|)
block|{
name|interactive
operator|=
name|No
expr_stmt|;
name|alino
operator|=
literal|0
expr_stmt|;
name|xeq
operator|=
name|Yes
expr_stmt|;
name|active_reads
operator|=
literal|0
expr_stmt|;
comment|/*CHANGE*/
name|buf
operator|=
name|getmem
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|f_size
argument_list|(
name|ifile
argument_list|)
operator|+
literal|2
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|Nil
condition|)
name|syserr
argument_list|(
literal|"can't get buffer to read file"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|txend
operator|=
name|buf
operator|)
operator|=
name|Eotc
expr_stmt|;
name|tx
operator|=
name|ceol
operator|=
name|txend
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|k
operator|!=
literal|'\n'
condition|)
operator|*
name|ceol
operator|++
operator|=
name|k
expr_stmt|;
operator|*
name|ceol
operator|=
literal|'\n'
expr_stmt|;
name|alino
operator|=
literal|1
expr_stmt|;
operator|*
name|v
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|Nil
condition|)
name|freemem
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
name|CANT_READ
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Visible
name|Procedure
name|getprmnv
parameter_list|()
block|{
name|value
name|fn
init|=
name|mk_text
argument_list|(
literal|".prmnv"
argument_list|)
decl_stmt|;
name|cntxt
operator|=
name|In_prmnv
expr_stmt|;
if|if
condition|(
name|f_exists
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* convert from old to new format */
name|getval
argument_list|(
name|fn
argument_list|,
operator|&
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|b_perm
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
comment|/*		putprmnv(); 		f_delete(fn); /*after writing the new one, for safety*/
comment|/* */
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prmnv
operator|->
name|tab
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|b_perm
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
comment|/*		release(fn); 		fn= mk_text(".b_perm"); 		if (f_exists(fn)) { 			getval(fn,&b_perm); 			create_prmnv(); 		} else { 			b_perm= mk_elt(); 			prmnv->tab= mk_elt(); 		} */
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|putval
parameter_list|(
name|nm
parameter_list|,
name|v
parameter_list|,
name|silently
parameter_list|)
name|value
name|nm
decl_stmt|,
name|v
decl_stmt|;
name|bool
name|silently
decl_stmt|;
block|{
name|FILE
modifier|*
name|ofile
decl_stmt|;
name|ofile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|nm
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofile
operator|!=
name|NULL
condition|)
block|{
name|redirect
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|wri
argument_list|(
name|v
argument_list|,
name|No
argument_list|,
name|No
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|redirect
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|silently
condition|)
name|error
argument_list|(
name|CANT_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|putprmnv
parameter_list|()
block|{
name|bool
name|changed
init|=
name|No
decl_stmt|;
name|value
name|fn
decl_stmt|;
name|value
name|pt1
decl_stmt|,
name|pt2
decl_stmt|;
name|env
name|c
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
init|=
name|length
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
decl_stmt|;
name|ignsigs
argument_list|()
expr_stmt|;
comment|/*because files are created before the directory is written*/
name|pt1
operator|=
name|prmnv
operator|->
name|tab
expr_stmt|;
name|pt2
operator|=
name|prmnvtab
expr_stmt|;
name|c
operator|=
name|curnv
expr_stmt|;
name|setprmnv
argument_list|()
expr_stmt|;
name|k_Over_len
block|{
name|value
name|v
init|=
name|copy
argument_list|(
operator|*
name|assoc
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Is_filed
argument_list|(
name|v
argument_list|)
condition|)
block|{
comment|/*			value t= copy(*key(prmnv->tab, k)); 			wri_target(t, v,&changed); 			release(t); */
block|}
else|else
block|{
name|e_delete
argument_list|(
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
operator|*
name|key
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|mk_text
argument_list|(
literal|".prmnv"
argument_list|)
expr_stmt|;
name|putval
argument_list|(
name|fn
argument_list|,
name|prmnv
operator|->
name|tab
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|fn
operator|=
name|mk_text
argument_list|(
literal|".b_perm"
argument_list|)
expr_stmt|;
name|putval
argument_list|(
name|fn
argument_list|,
name|b_perm
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
name|prmnv
operator|->
name|tab
operator|=
name|pt1
expr_stmt|;
name|prmnvtab
operator|=
name|pt2
expr_stmt|;
name|curnv
operator|=
name|c
expr_stmt|;
comment|/* kludgy */
name|re_sigs
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|wri_target
parameter_list|(
name|t
parameter_list|,
name|v
parameter_list|,
name|changed
parameter_list|)
name|value
name|t
decl_stmt|,
name|v
decl_stmt|;
name|bool
modifier|*
name|changed
decl_stmt|;
block|{
name|value
name|fn
decl_stmt|,
name|p
decl_stmt|;
name|bool
name|new
init|=
name|new_tname
argument_list|(
name|t
argument_list|,
operator|&
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
operator|*
name|changed
operator|=
name|Yes
expr_stmt|;
name|putval
argument_list|(
name|fn
argument_list|,
name|v
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|p
operator|=
name|mk_per
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|e_replace
argument_list|(
name|p
argument_list|,
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/*after writing file*/
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|create_prmnv
parameter_list|()
block|{
name|value
name|p
init|=
name|mk_per
argument_list|(
name|Vnil
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
init|=
name|length
argument_list|(
name|b_perm
argument_list|)
decl_stmt|;
name|k_Over_len
block|{
name|e_replace
argument_list|(
name|copy
argument_list|(
name|p
argument_list|)
argument_list|,
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
operator|*
name|key
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|initsou
parameter_list|()
block|{
name|defunits
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

