begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2fpr.c,v 1.1 84/06/28 00:49:12 timo Exp $ */
end_comment

begin_comment
comment|/* B formula/predicate invocation */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2fil.h"
end_include

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2sou.h"
end_include

begin_define
define|#
directive|define
name|Other
value|0
end_define

begin_define
define|#
directive|define
name|Nume
value|1
end_define

begin_define
define|#
directive|define
name|In
value|('[')
end_define

begin_define
define|#
directive|define
name|Not_in
value|(']')
end_define

begin_comment
comment|/*  * Table defining all predefined functions (not propositions).  */
end_comment

begin_struct
struct|struct
name|funtab
block|{
name|char
modifier|*
name|f_name
decl_stmt|;
name|char
name|f_lopri
decl_stmt|,
name|f_hipri
decl_stmt|;
name|char
name|f_adic
decl_stmt|;
name|char
name|f_flag
decl_stmt|;
name|value
function_decl|(
modifier|*
name|f_fun
function_decl|)
parameter_list|()
function_decl|;
block|}
name|funtab
index|[]
init|=
block|{
block|{
literal|"~"
block|,
literal|8
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|approximate
block|}
block|,
block|{
literal|"+"
block|,
literal|8
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|copy
block|}
block|,
block|{
literal|"+"
block|,
literal|2
block|,
literal|2
block|,
name|Dya
block|,
name|Nume
block|,
name|sum
block|}
block|,
block|{
literal|"-"
block|,
literal|5
block|,
literal|5
block|,
name|Mon
block|,
name|Nume
block|,
name|negated
block|}
block|,
block|{
literal|"-"
block|,
literal|2
block|,
literal|2
block|,
name|Dya
block|,
name|Nume
block|,
name|diff
block|}
block|,
block|{
literal|"*/"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|numerator
block|}
block|,
block|{
literal|"/*"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|denominator
block|}
block|,
block|{
literal|"*"
block|,
literal|4
block|,
literal|4
block|,
name|Dya
block|,
name|Nume
block|,
name|prod
block|}
block|,
block|{
literal|"/"
block|,
literal|3
block|,
literal|4
block|,
name|Dya
block|,
name|Nume
block|,
name|quot
block|}
block|,
block|{
literal|"**"
block|,
literal|6
block|,
literal|7
block|,
name|Dya
block|,
name|Nume
block|,
name|power
block|}
block|,
block|{
literal|"^"
block|,
literal|2
block|,
literal|2
block|,
name|Dya
block|,
name|Other
block|,
name|concat
block|}
block|,
block|{
literal|"^^"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|repeat
block|}
block|,
block|{
literal|"<<"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|adjleft
block|}
block|,
block|{
literal|"><"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|centre
block|}
block|,
block|{
literal|">>"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|adjright
block|}
block|,
block|{
literal|"#"
block|,
literal|7
block|,
literal|7
block|,
name|Mon
block|,
name|Other
block|,
name|size
block|}
block|,
block|{
literal|"#"
block|,
literal|7
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|size2
block|}
block|,
block|{
literal|"pi"
block|,
literal|8
block|,
literal|8
block|,
name|Zer
block|,
name|Other
block|,
name|pi
block|}
block|,
block|{
literal|"e"
block|,
literal|8
block|,
literal|8
block|,
name|Zer
block|,
name|Other
block|,
name|e
block|}
block|,
block|{
literal|"abs"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|absval
block|}
block|,
block|{
literal|"sign"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|signum
block|}
block|,
block|{
literal|"floor"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|floorf
block|}
block|,
block|{
literal|"ceiling"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|ceilf
block|}
block|,
block|{
literal|"round"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|round1
block|}
block|,
block|{
literal|"round"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Nume
block|,
name|round2
block|}
block|,
block|{
literal|"mod"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Nume
block|,
name|mod
block|}
block|,
block|{
literal|"root"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|root1
block|}
block|,
block|{
literal|"root"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Nume
block|,
name|root2
block|}
block|,
block|{
literal|"sin"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|sin1
block|}
block|,
block|{
literal|"cos"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|cos1
block|}
block|,
block|{
literal|"tan"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|tan1
block|}
block|,
block|{
literal|"atan"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|atn1
block|}
block|,
block|{
literal|"atan"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|atn2
block|}
block|,
block|{
literal|"exp"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|exp1
block|}
block|,
block|{
literal|"log"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Nume
block|,
name|log1
block|}
block|,
block|{
literal|"log"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|log2
block|}
block|,
block|{
literal|"keys"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Other
block|,
name|keys
block|}
block|,
block|{
literal|"th'of"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|th_of
block|}
block|,
block|{
literal|"min"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Other
block|,
name|min1
block|}
block|,
block|{
literal|"min"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|min2
block|}
block|,
block|{
literal|"max"
block|,
literal|1
block|,
literal|8
block|,
name|Mon
block|,
name|Other
block|,
name|max1
block|}
block|,
block|{
literal|"max"
block|,
literal|1
block|,
literal|8
block|,
name|Dya
block|,
name|Other
block|,
name|max2
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|,
name|Dya
block|,
name|Other
block|,
name|NULL
block|}
comment|/*sentinel*/
block|}
struct|;
end_struct

begin_function
name|Visible
name|Procedure
name|initfprs
parameter_list|()
block|{
name|struct
name|funtab
modifier|*
name|fp
decl_stmt|;
name|value
name|r
decl_stmt|,
name|f
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|funtab
init|;
name|fp
operator|->
name|f_lopri
operator|!=
literal|0
condition|;
operator|++
name|fp
control|)
block|{
comment|/* Define function */
name|r
operator|=
name|mk_text
argument_list|(
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
name|f
operator|=
name|mk_fun
argument_list|(
name|fp
operator|->
name|f_lopri
argument_list|,
name|fp
operator|->
name|f_hipri
argument_list|,
name|fp
operator|->
name|f_adic
argument_list|,
name|Pre
argument_list|,
call|(
name|txptr
call|)
argument_list|(
name|fp
operator|-
name|funtab
argument_list|)
argument_list|,
comment|/*NON-PORTABLE: remove the cast*/
operator|(
name|txptr
operator|)
name|Dummy
argument_list|,
operator|(
name|value
operator|)
name|Dummy
argument_list|,
operator|(
name|bool
operator|)
name|Dummy
argument_list|)
expr_stmt|;
name|def_unit
argument_list|(
name|f
argument_list|,
name|r
argument_list|,
name|fp
operator|->
name|f_adic
operator|==
name|Zer
condition|?
name|FZR
else|:
name|fp
operator|->
name|f_adic
operator|==
name|Mon
condition|?
name|FMN
else|:
name|FDY
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|defprd
argument_list|(
literal|"in"
argument_list|,
name|Dya
argument_list|,
name|Pre
argument_list|,
name|In
argument_list|)
expr_stmt|;
name|defprd
argument_list|(
literal|"not'in"
argument_list|,
name|Dya
argument_list|,
name|Pre
argument_list|,
name|Not_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|defprd
parameter_list|(
name|repr
parameter_list|,
name|adic
parameter_list|,
name|def
parameter_list|,
name|fux
parameter_list|)
name|string
name|repr
decl_stmt|;
name|literal
name|adic
decl_stmt|,
name|def
decl_stmt|,
name|fux
decl_stmt|;
block|{
name|literal
name|ad
init|=
name|adic
operator|==
name|Zer
condition|?
name|FZR
else|:
name|adic
operator|==
name|Mon
condition|?
name|FMN
else|:
name|FDY
decl_stmt|;
name|value
name|r
init|=
name|mk_text
argument_list|(
name|repr
argument_list|)
decl_stmt|,
name|p
init|=
name|mk_prd
argument_list|(
name|adic
argument_list|,
name|def
argument_list|,
operator|(
name|txptr
operator|)
name|fux
comment|/*nasty*/
argument_list|,
operator|(
name|txptr
operator|)
name|Dummy
argument_list|,
operator|(
name|value
operator|)
name|Dummy
argument_list|,
operator|(
name|bool
operator|)
name|Dummy
argument_list|)
decl_stmt|;
name|def_unit
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|ad
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|is_funprd
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|,
name|adicity
parameter_list|,
name|func
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|adicity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|value
modifier|*
name|aa
decl_stmt|,
modifier|*
name|sl
init|=
name|lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|sl
operator|!=
name|Pnil
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
name|is_unit
argument_list|(
name|t
argument_list|,
name|adicity
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|func
condition|)
block|{
if|if
condition|(
operator|!
name|Is_function
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|Is_predicate
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
block|}
operator|*
name|f
operator|=
operator|*
name|aa
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_zerfun
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|FZR
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_monfun
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|FMN
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_dyafun
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|FDY
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_zerprd
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|FZR
argument_list|,
name|No
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_monprd
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|FMN
argument_list|,
name|No
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_dyaprd
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|FDY
argument_list|,
name|No
argument_list|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|torbuf
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Tor
value|*tb++= Char(tx++)
end_define

begin_define
define|#
directive|define
name|Rot
value|*tb= '\0'
end_define

begin_function
name|Visible
name|value
name|montor
parameter_list|()
block|{
name|txptr
name|tb
init|=
name|torbuf
decl_stmt|;
name|value
name|r
decl_stmt|,
name|f
decl_stmt|;
switch|switch
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
condition|)
block|{
case|case
literal|'~'
case|:
name|Tor
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|Tor
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|Tor
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|Tor
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|'/'
condition|)
name|pprerr
argument_list|(
literal|"function * is not monadic"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Tor
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|Tor
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|'*'
condition|)
name|pprerr
argument_list|(
literal|"function / is not monadic"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Tor
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|Tor
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"unhandled Montormark"
argument_list|)
expr_stmt|;
block|}
name|Rot
expr_stmt|;
name|r
operator|=
name|mk_text
argument_list|(
name|torbuf
argument_list|)
expr_stmt|;
name|f
operator|=
name|unit_info
argument_list|(
name|r
argument_list|,
name|FMN
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|dyator
parameter_list|()
block|{
name|txptr
name|tb
init|=
name|torbuf
decl_stmt|;
name|value
name|r
decl_stmt|,
name|f
decl_stmt|;
switch|switch
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
condition|)
block|{
case|case
literal|'+'
case|:
name|Tor
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|Tor
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|Tor
expr_stmt|;
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
name|loop
label|:
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
operator|!=
literal|'*'
condition|)
block|{
name|tx
operator|=
name|tx0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|tx
operator|=
name|tx0
expr_stmt|;
name|Tor
expr_stmt|;
break|break;
block|}
goto|goto
name|loop
goto|;
block|}
case|case
literal|'/'
case|:
name|Tor
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|Tor
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'^'
condition|)
name|Tor
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|Tor
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|'<'
condition|)
name|pprerr
argument_list|(
literal|"order-relator instead of function"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Tor
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|Tor
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|'<'
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|'>'
condition|)
name|pprerr
argument_list|(
literal|"order-relator instead of function"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Tor
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|Tor
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"unhandled Dyatormark"
argument_list|)
expr_stmt|;
block|}
name|Rot
expr_stmt|;
name|r
operator|=
name|mk_text
argument_list|(
name|torbuf
argument_list|)
expr_stmt|;
name|f
operator|=
name|unit_info
argument_list|(
name|r
argument_list|,
name|FDY
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|formula
parameter_list|(
name|nd1
parameter_list|,
name|tor
parameter_list|,
name|nd2
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|tor
decl_stmt|,
name|nd2
decl_stmt|;
block|{
name|funprd
modifier|*
name|t
decl_stmt|;
name|struct
name|funtab
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|Is_function
argument_list|(
name|tor
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"formula called with non-function"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xeq
condition|)
return|return
operator|(
name|value
operator|)
name|Dummy
return|;
name|t
operator|=
name|Funprd
argument_list|(
name|tor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|adic
operator|==
name|Zer
condition|?
name|nd2
operator|==
name|Vnil
else|:
operator|(
name|t
operator|->
name|adic
operator|==
name|Mon
operator|)
operator|==
operator|(
name|nd1
operator|==
name|Vnil
operator|)
operator|)
condition|)
name|syserr
argument_list|(
literal|"invoked formula has other adicity than invoker"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|def
operator|==
name|Use
condition|)
block|{
name|value
name|r
decl_stmt|;
name|udfpr
argument_list|(
name|nd1
argument_list|,
name|t
argument_list|,
name|nd2
argument_list|,
name|Ret
argument_list|)
expr_stmt|;
name|r
operator|=
name|resval
expr_stmt|;
name|resval
operator|=
name|Vnil
expr_stmt|;
return|return
name|r
return|;
block|}
name|fp
operator|=
operator|&
name|funtab
index|[
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|fux
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|==
name|Nume
operator|&&
name|t
operator|->
name|adic
operator|!=
name|Zer
condition|)
block|{
comment|/* check types */
if|if
condition|(
name|t
operator|->
name|adic
operator|==
name|Dya
operator|&&
operator|!
name|Is_number
argument_list|(
name|nd1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"left operand not a number"
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|nd2
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"right operand not a number"
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|adic
operator|==
name|Zer
condition|)
return|return
operator|(
call|(
modifier|*
name|fp
operator|->
name|f_fun
call|)
argument_list|()
operator|)
return|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|f_adic
operator|==
name|Mon
condition|)
return|return
operator|(
call|(
modifier|*
name|fp
operator|->
name|f_fun
call|)
argument_list|(
name|nd2
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
call|(
modifier|*
name|fp
operator|->
name|f_fun
call|)
argument_list|(
name|nd1
argument_list|,
name|nd2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Visible
name|outcome
name|proposition
parameter_list|(
name|nd1
parameter_list|,
name|pred
parameter_list|,
name|nd2
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|pred
decl_stmt|,
name|nd2
decl_stmt|;
block|{
name|funprd
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|Is_predicate
argument_list|(
name|pred
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"proposition called with non-predicate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xeq
condition|)
return|return
operator|(
name|outcome
operator|)
name|Dummy
return|;
name|p
operator|=
name|Funprd
argument_list|(
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|adic
operator|==
name|Zer
condition|?
name|nd2
operator|==
name|Vnil
else|:
operator|(
name|p
operator|->
name|adic
operator|==
name|Mon
operator|)
operator|==
operator|(
name|nd1
operator|==
name|Vnil
operator|)
operator|)
condition|)
name|syserr
argument_list|(
literal|"invoked proposition has other adicity than invoker"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|def
operator|==
name|Use
condition|)
block|{
name|outcome
name|o
decl_stmt|;
name|udfpr
argument_list|(
name|nd1
argument_list|,
name|p
argument_list|,
name|nd2
argument_list|,
name|Rep
argument_list|)
expr_stmt|;
name|o
operator|=
name|resout
expr_stmt|;
name|resout
operator|=
name|Und
expr_stmt|;
return|return
name|o
return|;
block|}
switch|switch
condition|(
name|p
operator|->
name|fux
condition|)
block|{
case|case
name|In
case|:
return|return
name|in
argument_list|(
name|nd1
argument_list|,
name|nd2
argument_list|)
return|;
case|case
name|Not_in
case|:
return|return
operator|!
name|in
argument_list|(
name|nd1
argument_list|,
name|nd2
argument_list|)
return|;
default|default:
name|syserr
argument_list|(
literal|"predicate not covered by proposition"
argument_list|)
expr_stmt|;
return|return
operator|(
name|outcome
operator|)
name|Dummy
return|;
block|}
block|}
end_function

end_unit

