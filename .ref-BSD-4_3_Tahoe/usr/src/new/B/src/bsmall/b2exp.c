begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2exp.c,v 1.1 84/06/28 00:49:08 timo Exp $ */
end_comment

begin_comment
comment|/* B expression evaluation */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_comment
comment|/* for ptr */
end_comment

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_include
include|#
directive|include
file|"b2sou.h"
end_include

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/*                                                           */
end_comment

begin_comment
comment|/* The operand and operator stacks are modelled as compounds */
end_comment

begin_comment
comment|/* whose first field is the top and whose second field is    */
end_comment

begin_comment
comment|/* the remainder of the stack (i.e., linked lists).          */
end_comment

begin_comment
comment|/* A cleaner and more efficient implementation of            */
end_comment

begin_comment
comment|/* these heavily used stacks would be in order.              */
end_comment

begin_comment
comment|/*                                                           */
end_comment

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* nd = operand, tor = operator (function) */
end_comment

begin_decl_stmt
name|value
name|ndstack
decl_stmt|,
name|torstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Bot
value|Vnil
end_define

begin_decl_stmt
name|fun
name|Bra
decl_stmt|,
name|Ket
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|inittors
parameter_list|()
block|{
name|ndstack
operator|=
name|torstack
operator|=
name|Vnil
expr_stmt|;
name|Bra
operator|=
name|mk_fun
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|Mon
argument_list|,
operator|(
name|literal
operator|)
name|Dummy
argument_list|,
operator|(
name|txptr
operator|)
name|Dummy
argument_list|,
operator|(
name|txptr
operator|)
name|Dummy
argument_list|,
operator|(
name|value
operator|)
name|Dummy
argument_list|,
operator|(
name|bool
operator|)
name|Dummy
argument_list|)
expr_stmt|;
name|Ket
operator|=
name|mk_fun
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|Dya
argument_list|,
operator|(
name|literal
operator|)
name|Dummy
argument_list|,
operator|(
name|txptr
operator|)
name|Dummy
argument_list|,
operator|(
name|txptr
operator|)
name|Dummy
argument_list|,
operator|(
name|value
operator|)
name|Dummy
argument_list|,
operator|(
name|bool
operator|)
name|Dummy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|pop_stack
parameter_list|(
name|stack
parameter_list|)
name|value
modifier|*
name|stack
decl_stmt|;
block|{
name|value
name|oldstack
init|=
operator|*
name|stack
decl_stmt|;
operator|*
name|stack
operator|=
operator|*
name|field
argument_list|(
operator|*
name|stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|Vnil
argument_list|,
operator|&
name|oldstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|Vnil
argument_list|,
operator|&
name|oldstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|oldstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|value
name|popnd
parameter_list|()
block|{
name|value
name|r
decl_stmt|;
if|if
condition|(
name|ndstack
operator|==
name|Vnil
condition|)
name|syserr
argument_list|(
literal|"operand stack underflow"
argument_list|)
expr_stmt|;
name|r
operator|=
operator|*
name|field
argument_list|(
name|ndstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_stack
argument_list|(
operator|&
name|ndstack
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|pushnd
parameter_list|(
name|nd
parameter_list|)
name|value
name|nd
decl_stmt|;
block|{
name|value
name|s
init|=
name|ndstack
decl_stmt|;
name|ndstack
operator|=
name|mk_compound
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|nd
argument_list|,
operator|&
name|ndstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|s
argument_list|,
operator|&
name|ndstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|pushmontor
parameter_list|(
name|tor
parameter_list|)
name|value
name|tor
decl_stmt|;
block|{
name|value
name|s
init|=
name|torstack
decl_stmt|;
name|torstack
operator|=
name|mk_compound
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|tor
argument_list|,
operator|&
name|torstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|s
argument_list|,
operator|&
name|torstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|pushdyator
parameter_list|(
name|tor2
parameter_list|)
name|value
name|tor2
decl_stmt|;
block|{
name|value
name|tor1
decl_stmt|;
name|funprd
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
init|=
name|Funprd
argument_list|(
name|tor2
argument_list|)
decl_stmt|;
name|intlet
name|L1
decl_stmt|,
name|H1
decl_stmt|,
name|L2
init|=
name|t2
operator|->
name|L
decl_stmt|,
name|H2
init|=
name|t2
operator|->
name|H
decl_stmt|;
name|prio
label|:
if|if
condition|(
name|torstack
operator|==
name|Vnil
condition|)
name|syserr
argument_list|(
literal|"operator stack underflow"
argument_list|)
expr_stmt|;
name|tor1
operator|=
operator|*
name|field
argument_list|(
name|torstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t1
operator|=
name|Funprd
argument_list|(
name|tor1
argument_list|)
operator|,
name|L1
operator|=
name|t1
operator|->
name|L
expr_stmt|;
name|H1
operator|=
name|t1
operator|->
name|H
expr_stmt|;
if|if
condition|(
name|L2
operator|>
name|H1
condition|)
if|if
condition|(
name|tor2
operator|==
name|Ket
condition|)
block|{
if|if
condition|(
name|tor1
operator|!=
name|Bra
condition|)
name|syserr
argument_list|(
literal|"local operator stack underflow"
argument_list|)
expr_stmt|;
name|pop_stack
argument_list|(
operator|&
name|torstack
argument_list|)
expr_stmt|;
block|}
else|else
name|pushmontor
argument_list|(
name|tor2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|L1
operator|>=
name|H2
condition|)
block|{
name|value
name|nd1
init|=
name|Vnil
decl_stmt|,
name|nd2
init|=
name|popnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|->
name|adic
operator|==
name|Dya
condition|)
name|nd1
operator|=
name|popnd
argument_list|()
expr_stmt|;
name|pushnd
argument_list|(
name|formula
argument_list|(
name|nd1
argument_list|,
name|tor1
argument_list|,
name|nd2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|release
argument_list|(
name|nd2
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|nd1
argument_list|)
expr_stmt|;
block|}
name|pop_stack
argument_list|(
operator|&
name|torstack
argument_list|)
expr_stmt|;
goto|goto
name|prio
goto|;
block|}
else|else
name|pprerr
argument_list|(
literal|"priorities? use ( and ) to resolve"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|Forward
name|value
name|basexpr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|value
name|text_dis
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|value
name|tl_dis
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|value
name|statabsel
parameter_list|(
name|t
parameter_list|,
name|k
parameter_list|)
name|value
name|t
decl_stmt|,
name|k
decl_stmt|;
block|{
comment|/* temporary, while no static type check */
return|return
name|mk_elt
argument_list|()
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|expr
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|value
name|c
decl_stmt|,
name|v
decl_stmt|;
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
name|intlet
name|len
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
literal|1
operator|+
name|count
argument_list|(
literal|","
argument_list|,
name|q
argument_list|)
operator|)
operator|==
literal|1
condition|)
return|return
name|basexpr
argument_list|(
name|q
argument_list|)
return|;
name|c
operator|=
name|mk_compound
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|k_Overfields
block|{
if|if
condition|(
name|Lastfield
argument_list|(
name|k
argument_list|)
condition|)
name|i
operator|=
name|q
expr_stmt|;
else|else
name|req
argument_list|(
literal|","
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|v
operator|=
name|basexpr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|put_in_field
argument_list|(
name|v
argument_list|,
operator|&
name|c
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lastfield
argument_list|(
name|k
argument_list|)
condition|)
name|tx
operator|=
name|j
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|basexpr
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|value
name|v
init|=
name|obasexpr
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|','
condition|)
name|parerr
argument_list|(
literal|"no commas allowed in this context"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|q
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_decl_stmt
name|Forward
name|bool
name|primary
argument_list|()
decl_stmt|,
name|clocondis
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Pbot
value|{pushnd(Bot); pushmontor(Bra);}
end_define

begin_define
define|#
directive|define
name|Ipush
value|if (!pushing) {Pbot; pushing= Yes;}
end_define

begin_define
define|#
directive|define
name|Fpush
value|if (pushing) {                                    \ 		      pushnd(v); pushdyator(Ket); v= popnd();   \ 		      if (popnd() != Bot) syserr(               \ 			      xeq ? "formula evaluation awry" : \ 				      "formula parsing awry");  \ 	      }
end_define

begin_function
name|Visible
name|value
name|obasexpr
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
name|bool
name|pushing
init|=
name|No
decl_stmt|;
name|nxtnd
label|:
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nothing
argument_list|(
name|q
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
name|t
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|primary
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|&
name|v
argument_list|,
name|Yes
argument_list|)
condition|)
comment|/* then t is released */
empty_stmt|;
elseif|else
if|if
condition|(
name|t
operator|!=
name|Vnil
condition|)
block|{
name|value
name|f
decl_stmt|;
if|if
condition|(
name|is_monfun
argument_list|(
name|t
argument_list|,
operator|&
name|f
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|Ipush
expr_stmt|;
name|pushmontor
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|nxtnd
goto|;
block|}
else|else
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"target has not yet received a value"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Montormark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|Ipush
expr_stmt|;
name|pushmontor
argument_list|(
name|montor
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|nxtnd
goto|;
block|}
else|else
name|parerr
argument_list|(
literal|"no expression where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* We are past an operand and look for an operator */
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|<
name|q
condition|)
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
name|bool
name|lt
decl_stmt|,
name|eq
decl_stmt|,
name|gt
decl_stmt|;
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|fun
name|f
decl_stmt|;
name|t
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_dyafun
argument_list|(
name|t
argument_list|,
operator|&
name|f
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|Ipush
expr_stmt|;
name|pushnd
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|pushdyator
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|nxtnd
goto|;
block|}
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|relop
argument_list|(
operator|&
name|lt
argument_list|,
operator|&
name|eq
argument_list|,
operator|&
name|gt
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|Dyatormark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|Ipush
expr_stmt|;
name|pushnd
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|pushdyator
argument_list|(
name|dyator
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|nxtnd
goto|;
block|}
name|tx
operator|=
name|tx0
expr_stmt|;
block|}
name|Fpush
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|clocondis
parameter_list|(
name|q
parameter_list|,
name|p
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|value
modifier|*
name|p
decl_stmt|;
block|{
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nothing
argument_list|(
name|q
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|tx
operator|++
expr_stmt|;
name|req
argument_list|(
literal|")"
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|expr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tx
operator|=
name|j
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|Dig
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'.'
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'E'
operator|&&
operator|(
name|Dig
argument_list|(
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
argument_list|)
operator|||
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
operator|==
literal|'+'
operator|||
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|p
operator|=
name|constant
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'\''
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'"'
condition|)
block|{
operator|*
name|p
operator|=
name|text_dis
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'{'
condition|)
block|{
operator|*
name|p
operator|=
name|tl_dis
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|primary
parameter_list|(
name|q
parameter_list|,
name|t
parameter_list|,
name|p
parameter_list|,
name|tri
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_decl_stmt
name|bool
name|tri
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If a tag has been seen, it is held in t.    Releasing t is a task of primary, but only if the call succeeds. */
name|fun
name|f
decl_stmt|;
name|value
name|tt
decl_stmt|,
name|relt
init|=
name|Vnil
decl_stmt|;
name|value
modifier|*
name|aa
init|=
operator|&
name|t
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|Vnil
condition|)
comment|/* tag */
block|{
if|if
condition|(
name|xeq
condition|)
block|{
name|tt
operator|=
name|t
expr_stmt|;
name|aa
operator|=
name|lookup
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|Pnil
condition|)
block|{
if|if
condition|(
name|is_zerfun
argument_list|(
name|t
argument_list|,
operator|&
name|f
argument_list|)
condition|)
block|{
name|t
operator|=
name|formula
argument_list|(
name|Vnil
argument_list|,
name|f
argument_list|,
name|Vnil
argument_list|)
expr_stmt|;
name|aa
operator|=
operator|&
name|t
expr_stmt|;
block|}
else|else
return|return
name|No
return|;
block|}
elseif|else
if|if
condition|(
name|Is_refinement
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
name|ref_et
argument_list|(
operator|*
name|aa
argument_list|,
name|Ret
argument_list|)
expr_stmt|;
name|t
operator|=
name|resval
expr_stmt|;
name|resval
operator|=
name|Vnil
expr_stmt|;
name|aa
operator|=
operator|&
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_formal
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
name|t
operator|=
name|eva_formal
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
name|aa
operator|=
operator|&
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_shared
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|in_env
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|t
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|Is_filed
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
if|if
condition|(
operator|!
name|is_tloaded
argument_list|(
name|t
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
name|t
operator|=
name|Vnil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_filed
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_tloaded
argument_list|(
name|t
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
name|t
operator|=
name|Vnil
expr_stmt|;
block|}
else|else
name|t
operator|=
name|Vnil
expr_stmt|;
name|release
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clocondis
argument_list|(
name|q
argument_list|,
operator|&
name|t
argument_list|)
condition|)
name|aa
operator|=
operator|&
name|t
expr_stmt|;
else|else
return|return
name|No
return|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'['
condition|)
block|{
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
name|value
name|s
decl_stmt|;
name|tx
operator|++
expr_stmt|;
name|req
argument_list|(
literal|"]"
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tx
operator|=
name|j
expr_stmt|;
comment|/* don't copy table for selection */
if|if
condition|(
name|xeq
condition|)
block|{
name|aa
operator|=
name|adrassoc
argument_list|(
operator|*
name|aa
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|relt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|Pnil
condition|)
name|error
argument_list|(
literal|"key not in table"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|statabsel
argument_list|(
name|tt
operator|=
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tri
operator|&&
name|tx
operator|<
name|q
operator|&&
operator|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'@'
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'|'
operator|)
condition|)
block|{
name|intlet
name|B
decl_stmt|,
name|C
decl_stmt|;
if|if
condition|(
name|xeq
operator|&&
operator|!
name|Is_text
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
name|parerr
argument_list|(
literal|"in t@p or t|p, t is not a text"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|trimbc
argument_list|(
name|q
argument_list|,
name|xeq
condition|?
name|length
argument_list|(
operator|*
name|aa
argument_list|)
else|:
literal|0
argument_list|,
operator|&
name|B
argument_list|,
operator|&
name|C
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|relt
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|trim
argument_list|(
operator|*
name|aa
argument_list|,
name|B
argument_list|,
name|C
argument_list|)
expr_stmt|;
name|aa
operator|=
operator|&
name|t
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
name|t
operator|==
name|Vnil
operator|||
name|relt
operator|!=
name|Vnil
condition|?
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
else|:
name|t
expr_stmt|;
name|release
argument_list|(
name|relt
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_block

begin_function_decl
name|Forward
name|intlet
name|trimi
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Visible
name|Procedure
name|trimbc
parameter_list|(
name|q
parameter_list|,
name|len
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|intlet
name|len
decl_stmt|,
decl|*
name|B
decl_stmt|,
modifier|*
name|C
decl_stmt|;
end_function

begin_block
block|{
name|char
name|bc
decl_stmt|;
name|intlet
name|N
decl_stmt|;
operator|*
name|B
operator|=
operator|*
name|C
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
operator|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'@'
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'|'
operator|)
condition|)
block|{
name|bc
operator|=
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
expr_stmt|;
name|N
operator|=
name|trimi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|==
literal|'@'
condition|)
operator|*
name|B
operator|+=
name|N
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|C
operator|+=
operator|(
name|len
operator|-
operator|*
name|B
operator|-
operator|*
name|C
operator|)
operator|-
name|N
expr_stmt|;
if|if
condition|(
operator|*
name|B
operator|<
literal|0
operator|||
operator|*
name|C
operator|<
literal|0
operator|||
operator|*
name|B
operator|+
operator|*
name|C
operator|>
name|len
condition|)
name|error
argument_list|(
literal|"in t@p or t|p, p is out of bounds"
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Hidden
name|intlet
name|trimi
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
name|bool
name|pushing
init|=
name|No
decl_stmt|;
name|nxtnd
label|:
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nothing
argument_list|(
name|q
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
name|t
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|primary
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|&
name|v
argument_list|,
name|No
argument_list|)
condition|)
empty_stmt|;
comment|/* then t is released */
elseif|else
if|if
condition|(
name|t
operator|!=
name|Vnil
condition|)
block|{
name|value
name|f
decl_stmt|;
if|if
condition|(
name|is_monfun
argument_list|(
name|t
argument_list|,
operator|&
name|f
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|Ipush
expr_stmt|;
name|pushmontor
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|nxtnd
goto|;
block|}
else|else
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"target has not yet received a value"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Montormark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|Ipush
expr_stmt|;
name|pushmontor
argument_list|(
name|montor
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|nxtnd
goto|;
block|}
else|else
name|parerr
argument_list|(
literal|"no expression where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Fpush
expr_stmt|;
block|{
name|int
name|ii
decl_stmt|;
name|intlet
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|ii
operator|=
name|intval
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"in t@p or t|p, p is negative"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|>
name|Maxintlet
condition|)
name|error
argument_list|(
literal|"in t@p or t|p, p is excessive"
argument_list|)
expr_stmt|;
name|i
operator|=
name|ii
expr_stmt|;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|constant
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|bool
name|dig
init|=
name|No
decl_stmt|;
name|txptr
name|first
init|=
name|tx
decl_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
name|Dig
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|tx
expr_stmt|;
name|dig
operator|=
name|Yes
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'.'
condition|)
block|{
name|tx
operator|++
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
name|Dig
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|dig
operator|=
name|Yes
expr_stmt|;
operator|++
name|tx
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dig
condition|)
name|pprerr
argument_list|(
literal|"point without digits"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'E'
condition|)
block|{
name|tx
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Dig
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
operator|)
operator|&&
name|Keymark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|tx
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
operator|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'+'
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'-'
operator|)
condition|)
operator|++
name|tx
expr_stmt|;
name|dig
operator|=
name|No
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
name|Dig
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|dig
operator|=
name|Yes
expr_stmt|;
operator|++
name|tx
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dig
condition|)
name|parerr
argument_list|(
literal|"E not followed by exponent"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|done
label|:
return|return
name|numconst
argument_list|(
name|first
argument_list|,
name|tx
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|char
name|txdbuf
index|[
name|TXDBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|txptr
name|txdbufend
init|=
operator|&
name|txdbuf
index|[
name|TXDBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|concat_to
parameter_list|(
name|v
parameter_list|,
name|s
parameter_list|)
name|value
modifier|*
name|v
decl_stmt|;
name|string
name|s
decl_stmt|;
block|{
comment|/*TEMPORARY*/
name|value
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
name|Vnil
condition|)
operator|*
name|v
operator|=
name|mk_text
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|v
operator|=
name|concat
argument_list|(
name|v1
operator|=
operator|*
name|v
argument_list|,
name|v2
operator|=
name|mk_text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|value
name|text_dis
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|char
name|aq
index|[
literal|2
index|]
decl_stmt|;
name|txptr
name|tp
init|=
name|txdbuf
decl_stmt|;
name|value
name|t
init|=
name|Vnil
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|aq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|aq
operator|=
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
expr_stmt|;
name|fbuf
label|:
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
operator|*
name|aq
condition|)
block|{
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'`'
condition|)
block|{
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
operator|==
literal|'`'
condition|)
name|tx
operator|++
expr_stmt|;
else|else
block|{
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|t
argument_list|,
name|txdbuf
argument_list|)
expr_stmt|;
name|t
operator|=
name|concat
argument_list|(
name|t1
operator|=
name|t
argument_list|,
name|t2
operator|=
name|conversion
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|tp
operator|=
name|txdbuf
expr_stmt|;
goto|goto
name|fbuf
goto|;
block|}
block|}
operator|*
name|tp
operator|++
operator|=
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|+
literal|1
operator|>=
name|txdbufend
condition|)
block|{
operator|*
operator|(
name|txdbufend
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|t
argument_list|,
name|txdbuf
argument_list|)
expr_stmt|;
name|tp
operator|=
name|txdbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tx
operator|>=
name|q
condition|)
name|parerr
argument_list|(
literal|"cannot find matching "
argument_list|,
name|aq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|tx
operator|<
name|q
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
operator|*
name|aq
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
expr_stmt|;
goto|goto
name|fbuf
goto|;
block|}
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|t
argument_list|,
name|txdbuf
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|conversion
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|txptr
name|f
decl_stmt|,
name|t
decl_stmt|;
name|value
name|v
decl_stmt|,
name|c
decl_stmt|;
name|thought
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
name|req
argument_list|(
literal|"`"
argument_list|,
name|q
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|Ifxeq
argument_list|(
name|convert
argument_list|(
name|v
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|tx
operator|=
name|t
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|tl_dis
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|txptr
name|f
decl_stmt|,
name|t
decl_stmt|,
name|ff
decl_stmt|,
name|tt
decl_stmt|;
name|intlet
name|len
decl_stmt|,
name|k
decl_stmt|;
name|thought
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|tx
operator|++
expr_stmt|;
return|return
name|Ifxeq
argument_list|(
name|mk_elt
argument_list|()
argument_list|)
return|;
block|}
name|req
argument_list|(
literal|"}"
argument_list|,
name|q
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
literal|".."
argument_list|,
name|f
argument_list|,
operator|&
name|ff
argument_list|,
operator|&
name|tt
argument_list|)
condition|)
block|{
name|value
name|enu
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
name|basexpr
argument_list|(
name|ff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xeq
operator|||
name|Is_number
argument_list|(
name|lo
argument_list|)
condition|)
block|{
name|tx
operator|=
name|tt
expr_stmt|;
while|while
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'.'
condition|)
name|tx
operator|++
expr_stmt|;
name|hi
operator|=
name|basexpr
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|value
name|entries
decl_stmt|;
if|if
condition|(
operator|!
name|integral
argument_list|(
name|lo
argument_list|)
condition|)
name|error
argument_list|(
literal|"in {p..q}, p is a number but not an integer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
literal|"in {p..q}, p is a number but q is not"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integral
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
literal|"in {p..q}, q is a number but not an integer"
argument_list|)
expr_stmt|;
name|entries
operator|=
name|diff
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|entries
argument_list|,
name|one
argument_list|)
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"in {p..q}, integer q< x< p"
argument_list|)
expr_stmt|;
name|enu
operator|=
name|mk_numrange
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
name|enu
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|release
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|lo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_text
argument_list|(
name|lo
argument_list|)
condition|)
block|{
name|char
name|a
decl_stmt|,
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|character
argument_list|(
name|lo
argument_list|)
condition|)
name|error
argument_list|(
literal|"in {p..q}, p is a text but not a character"
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tt
expr_stmt|;
name|hi
operator|=
name|basexpr
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
literal|"in {p..q}, p is a text but q is not"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|character
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
literal|"in {p..q}, q is a text but not a character"
argument_list|)
expr_stmt|;
name|a
operator|=
name|charval
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|z
operator|=
name|charval
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|<
name|a
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"in {p..q}, character q< x< p"
argument_list|)
expr_stmt|;
name|enu
operator|=
name|mk_charrange
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"in {p..q}, p is neither a number nor a text"
argument_list|)
expr_stmt|;
name|tx
operator|=
name|t
expr_stmt|;
return|return
name|enu
return|;
block|}
name|len
operator|=
literal|1
operator|+
name|count
argument_list|(
literal|";"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'['
condition|)
block|{
name|value
name|ta
decl_stmt|,
name|ke
decl_stmt|,
name|a
decl_stmt|;
name|ta
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|k_Over_len
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|need
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|req
argument_list|(
literal|"]"
argument_list|,
name|f
argument_list|,
operator|&
name|ff
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|expr
argument_list|(
name|ff
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tt
expr_stmt|;
name|need
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Last
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|ff
operator|=
name|f
expr_stmt|;
name|tt
operator|=
name|t
expr_stmt|;
block|}
else|else
name|req
argument_list|(
literal|";"
argument_list|,
name|f
argument_list|,
operator|&
name|ff
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
name|a
operator|=
name|basexpr
argument_list|(
name|ff
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tt
expr_stmt|;
name|replace
argument_list|(
name|a
argument_list|,
operator|&
name|ta
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
name|ta
return|;
block|}
block|{
name|value
name|l
decl_stmt|,
name|v
decl_stmt|;
name|l
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|k_Over_len
block|{
if|if
condition|(
name|Last
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|ff
operator|=
name|f
expr_stmt|;
name|tt
operator|=
name|t
expr_stmt|;
block|}
else|else
name|req
argument_list|(
literal|";"
argument_list|,
name|f
argument_list|,
operator|&
name|ff
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
name|v
operator|=
name|basexpr
argument_list|(
name|ff
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tt
expr_stmt|;
name|insert
argument_list|(
name|v
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
block|}
end_function

end_unit

