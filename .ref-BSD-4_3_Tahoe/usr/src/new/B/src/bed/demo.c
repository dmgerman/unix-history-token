begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: demo.c,v 2.6 85/08/22 16:01:21 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Editor command processor.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_include
include|#
directive|include
file|"erro.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"keys.h"
end_include

begin_include
include|#
directive|include
file|"supr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BTOP
end_ifdef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CMDPROMPT
end_ifndef

begin_define
define|#
directive|define
name|CMDPROMPT
value|">>> "
end_define

begin_comment
comment|/* Prompt user for immediate command */
end_comment

begin_endif
endif|#
directive|endif
endif|CMDPROMPT
end_endif

begin_endif
endif|#
directive|endif
endif|BTOP
end_endif

begin_function_decl
name|value
name|editqueue
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Command line flags */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|dflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|slowterminal
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SAVEBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|copysavefile
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|SAVEBUF
end_endif

begin_decl_stmt
name|Visible
name|bool
name|lefttorite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saves some time in nosuggtoqueue() for read from file */
end_comment

begin_define
define|#
directive|define
name|MAXHIST
value|101
end_define

begin_comment
comment|/* One more than the number of UNDO's allowed. */
end_comment

begin_define
define|#
directive|define
name|Mod
parameter_list|(
name|k
parameter_list|)
value|(((k)+MAXHIST) % MAXHIST)
end_define

begin_define
define|#
directive|define
name|Succ
parameter_list|(
name|k
parameter_list|)
value|(((k)+1) % MAXHIST)
end_define

begin_define
define|#
directive|define
name|Pred
parameter_list|(
name|k
parameter_list|)
value|(((k)+MAXHIST-1) % MAXHIST)
end_define

begin_decl_stmt
name|Hidden
name|environ
modifier|*
name|tobesaved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|string
name|savewhere
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BTOP
end_ifdef

begin_decl_stmt
specifier|extern
name|jmp_buf
name|jumpback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|interrupted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|canjump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main loop, called from main program if -t option present.  */
end_comment

begin_function
name|Visible
name|Procedure
name|mainloop
parameter_list|()
block|{
name|environ
name|env
decl_stmt|;
name|environ
modifier|*
name|ep
init|=
operator|&
name|env
decl_stmt|;
name|FILE
modifier|*
name|pdown
decl_stmt|;
name|FILE
modifier|*
name|pup
decl_stmt|;
name|int
name|cmdchar
decl_stmt|;
name|savewhere
operator|=
operator|(
name|string
operator|)
name|NULL
expr_stmt|;
name|tobesaved
operator|=
operator|(
name|environ
operator|*
operator|)
name|NULL
expr_stmt|;
name|start_b
argument_list|(
operator|&
name|pdown
argument_list|,
operator|&
name|pup
argument_list|)
expr_stmt|;
name|clrenv
argument_list|(
name|ep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVEBUF
name|ep
operator|->
name|copybuffer
operator|=
name|editqueue
argument_list|(
name|copysavefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|copybuffer
condition|)
name|ep
operator|->
name|copyflag
operator|=
name|Yes
expr_stmt|;
endif|#
directive|endif
endif|SAVEBUF
for|for
control|(
init|;
condition|;
control|)
block|{
name|cmdchar
operator|=
name|sleur
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmdchar
operator|==
name|EOF
condition|)
break|break;
name|getinput
argument_list|(
name|ep
argument_list|,
name|cmdchar
argument_list|,
name|pdown
argument_list|,
name|pup
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SAVEBUF
if|if
condition|(
name|ep
operator|->
name|copyflag
condition|)
name|savequeue
argument_list|(
name|ep
operator|->
name|copybuffer
argument_list|,
name|copysavefile
argument_list|)
expr_stmt|;
else|else
name|savequeue
argument_list|(
name|Vnil
argument_list|,
name|copysavefile
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SAVEBUF
name|Erelease
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Provide input for the interpreter.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|getinput
parameter_list|(
name|ep
parameter_list|,
name|cmdchar
parameter_list|,
name|pdown
parameter_list|,
name|pup
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
name|int
name|cmdchar
decl_stmt|;
name|FILE
modifier|*
name|pdown
decl_stmt|;
name|FILE
modifier|*
name|pup
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|char
name|filename
index|[
literal|100
index|]
decl_stmt|;
name|int
name|lineno
decl_stmt|;
switch|switch
condition|(
name|cmdchar
condition|)
block|{
case|case
literal|'>'
case|:
comment|/* Immediate command */
case|case
literal|'E'
case|:
comment|/* Expression */
case|case
literal|'R'
case|:
comment|/* Raw input */
case|case
literal|'Y'
case|:
comment|/* Yes/No */
if|if
condition|(
name|cmdchar
operator|==
literal|'>'
condition|)
name|setroot
argument_list|(
literal|"Imm_cmd"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmdchar
operator|==
literal|'E'
condition|)
name|setroot
argument_list|(
literal|"Expression"
argument_list|)
expr_stmt|;
else|else
name|setroot
argument_list|(
literal|"Raw_input"
argument_list|)
expr_stmt|;
name|delfocus
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|initshow
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmdchar
operator|==
literal|'>'
condition|)
name|cmdprompt
argument_list|(
name|CMDPROMPT
argument_list|)
expr_stmt|;
name|editdocument
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|endshow
argument_list|()
expr_stmt|;
name|top
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
if|if
condition|(
operator|!
name|interrupted
condition|)
name|send
argument_list|(
name|ep
operator|->
name|focus
argument_list|,
name|pdown
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
case|case
literal|'='
case|:
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|pup
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|buffer
argument_list|,
literal|'+'
argument_list|)
condition|)
name|n
operator|=
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|" +%d %s"
argument_list|,
operator|&
name|lineno
argument_list|,
name|filename
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|n
operator|=
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|" %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|initshow
argument_list|()
expr_stmt|;
name|dofile
argument_list|(
name|ep
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|endshow
argument_list|()
expr_stmt|;
name|top
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
name|delete
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|copyflag
condition|)
block|{
name|release
argument_list|(
name|ep
operator|->
name|copybuffer
argument_list|)
expr_stmt|;
name|ep
operator|->
name|copybuffer
operator|=
name|Vnil
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pdown
argument_list|)
expr_stmt|;
name|interrupted
operator|=
name|No
expr_stmt|;
comment|/* Interrupts handled locally in editdocument! */
break|break;
default|default:
name|printf
argument_list|(
literal|"[Unrecognized command character '%c' (0%o)]\n"
argument_list|,
name|cmdchar
operator|&
literal|0177
argument_list|,
name|cmdchar
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|BTOP
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FILEARGS
end_ifdef

begin_comment
comment|/*  * Edit a single unit or target, called from main program if file name  * arguments are present.  */
end_comment

begin_function
name|Visible
name|Procedure
name|demo
parameter_list|(
name|filename
parameter_list|,
name|linenumber
parameter_list|)
name|string
name|filename
decl_stmt|;
name|int
name|linenumber
decl_stmt|;
block|{
name|environ
name|env
decl_stmt|;
name|environ
modifier|*
name|ep
init|=
operator|&
name|env
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|clrenv
argument_list|(
name|ep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVEBUF
name|ep
operator|->
name|copybuffer
operator|=
name|editqueue
argument_list|(
name|copysavefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|copybuffer
condition|)
name|ep
operator|->
name|copyflag
operator|=
name|Yes
expr_stmt|;
endif|#
directive|endif
endif|SAVEBUF
name|initshow
argument_list|()
expr_stmt|;
name|ok
operator|=
name|dofile
argument_list|(
name|ep
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
name|endshow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|No
return|;
ifdef|#
directive|ifdef
name|SAVEBUF
if|if
condition|(
name|ep
operator|->
name|copyflag
condition|)
name|savequeue
argument_list|(
name|ep
operator|->
name|copybuffer
argument_list|,
name|copysavefile
argument_list|)
expr_stmt|;
else|else
name|savequeue
argument_list|(
name|Vnil
argument_list|,
name|copysavefile
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SAVEBUF
name|Erelease
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|!FILEARGS
end_endif

begin_comment
comment|/*  * Edit a unit or target, using the environment offered as a parameter.  */
end_comment

begin_function
name|Hidden
name|bool
name|dofile
parameter_list|(
name|ep
parameter_list|,
name|filename
parameter_list|,
name|linenumber
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
name|string
name|filename
decl_stmt|;
name|int
name|linenumber
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HELPFUL
specifier|static
name|bool
name|didmessage
decl_stmt|;
if|if
condition|(
operator|!
name|didmessage
condition|)
block|{
name|didmessage
operator|=
name|Yes
expr_stmt|;
name|message
argument_list|(
literal|"[Press ? or ESC-? for help]"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|HELPFUL
ifdef|#
directive|ifdef
name|SAVEPOS
if|if
condition|(
name|linenumber
operator|<=
literal|0
condition|)
name|linenumber
operator|=
name|getpos
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SAVEPOS
name|setroot
argument_list|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'='
condition|?
literal|"Target_edit"
else|:
literal|"Unit_edit"
argument_list|)
expr_stmt|;
name|savewhere
operator|=
name|filename
expr_stmt|;
name|tobesaved
operator|=
operator|(
name|environ
operator|*
operator|)
name|NULL
expr_stmt|;
name|lefttorite
operator|=
name|Yes
expr_stmt|;
name|edit
argument_list|(
name|ep
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERSUGG
name|readsugg
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|USERSUGG
name|lefttorite
operator|=
name|No
expr_stmt|;
name|ep
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|editdocument
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|ep
operator|->
name|generation
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|save
argument_list|(
name|ep
operator|->
name|focus
argument_list|,
name|filename
argument_list|)
condition|)
name|error
argument_list|(
literal|"Cannot save unit: %s"
argument_list|,
name|unixerror
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERSUGG
name|writesugg
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|USERSUGG
block|}
ifdef|#
directive|ifdef
name|SAVEPOS
name|savepos
argument_list|(
name|filename
argument_list|,
name|lineno
argument_list|(
name|ep
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SAVEPOS
name|savewhere
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|tobesaved
operator|=
operator|(
name|environ
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Call the editor for a given document.  */
end_comment

begin_function
name|Hidden
name|bool
name|editdocument
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
literal|0
decl_stmt|;
name|int
name|current
init|=
literal|0
decl_stmt|;
name|int
name|onscreen
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|reverse
init|=
name|No
decl_stmt|;
name|environ
name|newenv
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|bool
name|errors
init|=
name|No
decl_stmt|;
name|int
name|undoage
init|=
literal|0
decl_stmt|;
name|bool
name|done
init|=
name|No
decl_stmt|;
name|environ
name|history
index|[
name|MAXHIST
index|]
decl_stmt|;
name|Ecopy
argument_list|(
operator|*
name|ep
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Command interpretation loop */
if|if
condition|(
name|onscreen
operator|!=
name|current
condition|)
name|virtupdate
argument_list|(
name|onscreen
operator|<
literal|0
condition|?
operator|(
name|environ
operator|*
operator|)
name|NULL
else|:
operator|&
name|history
index|[
name|onscreen
index|]
argument_list|,
operator|&
name|history
index|[
name|current
index|]
argument_list|,
name|reverse
operator|&&
name|onscreen
operator|>=
literal|0
condition|?
name|history
index|[
name|onscreen
index|]
operator|.
name|highest
else|:
name|history
index|[
name|current
index|]
operator|.
name|highest
argument_list|)
expr_stmt|;
name|onscreen
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|done
condition|)
break|break;
ifdef|#
directive|ifdef
name|BTOP
if|if
condition|(
operator|!
name|interrupted
operator|&&
operator|!
name|moreinput
argument_list|()
condition|)
else|#
directive|else
else|BTOP
if|if
condition|(
operator|!
name|moreinput
argument_list|()
condition|)
endif|#
directive|endif
endif|BTOP
name|actupdate
argument_list|(
name|history
index|[
name|current
index|]
operator|.
name|copyflag
condition|?
name|history
index|[
name|current
index|]
operator|.
name|copybuffer
else|:
name|Vnil
argument_list|,
ifdef|#
directive|ifdef
name|RECORDING
name|history
index|[
name|current
index|]
operator|.
name|newmacro
operator|!=
name|Vnil
argument_list|,
else|#
directive|else
else|!RECORDING
name|No
argument_list|,
endif|#
directive|endif
endif|!RECORDING
name|No
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BTOP
if|if
condition|(
name|interrupted
operator|||
name|setjmp
argument_list|(
name|jumpback
argument_list|)
condition|)
break|break;
name|canjump
operator|=
name|Yes
expr_stmt|;
endif|#
directive|endif
endif|BTOP
name|cmd
operator|=
name|inchar
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BTOP
name|canjump
operator|=
name|No
expr_stmt|;
endif|#
directive|endif
endif|BTOP
name|errors
operator|=
name|No
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
case|case
name|Ctl
argument_list|(
argument|@
argument_list|)
case|:
comment|/* Debug exit with variable dump */
name|tobesaved
operator|=
operator|(
name|environ
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|No
return|;
endif|#
directive|endif
endif|NDEBUG
ifndef|#
directive|ifndef
name|SMALLSYS
case|case
name|Ctl
argument_list|(
operator|^
argument_list|)
case|:
comment|/* Debug status message */
name|dbmess
argument_list|(
operator|&
name|history
index|[
name|current
index|]
argument_list|)
expr_stmt|;
name|errors
operator|=
name|Yes
expr_stmt|;
comment|/* Causes clear after new keystroke seen */
continue|continue;
endif|#
directive|endif
endif|!SMALLSYS
case|case
name|UNDO
case|:
if|if
condition|(
name|current
operator|==
name|first
condition|)
name|errors
operator|=
name|Yes
expr_stmt|;
else|else
block|{
if|if
condition|(
name|onscreen
operator|==
name|current
condition|)
name|reverse
operator|=
name|Yes
expr_stmt|;
name|current
operator|=
name|Pred
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|undoage
operator|=
name|Mod
argument_list|(
name|last
operator|-
name|current
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REDO
case|:
if|if
condition|(
name|current
operator|==
name|last
condition|)
name|errors
operator|=
name|Yes
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current
operator|==
name|onscreen
condition|)
name|reverse
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|history
index|[
name|Succ
argument_list|(
name|current
argument_list|)
index|]
operator|.
name|generation
operator|<
name|history
index|[
name|current
index|]
operator|.
name|generation
condition|)
name|error
argument_list|(
name|REDO_OLD
argument_list|)
expr_stmt|;
comment|/***** Should refuse altogether??? *****/
name|current
operator|=
name|Succ
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|undoage
operator|=
name|Mod
argument_list|(
name|last
operator|-
name|current
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HELPFUL
case|case
name|HELP
case|:
if|if
condition|(
name|help
argument_list|()
condition|)
name|onscreen
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
endif|HELPFUL
case|case
name|REDRAW
case|:
name|onscreen
operator|=
operator|-
literal|1
expr_stmt|;
name|trmundefined
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOF
case|:
name|done
operator|=
name|Yes
expr_stmt|;
break|break;
default|default:
name|Ecopy
argument_list|(
name|history
index|[
name|current
index|]
argument_list|,
name|newenv
argument_list|)
expr_stmt|;
name|newenv
operator|.
name|highest
operator|=
name|Maxintlet
expr_stmt|;
name|newenv
operator|.
name|changed
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|EXIT
condition|)
name|errors
operator|=
operator|!
name|execute
argument_list|(
operator|&
name|newenv
argument_list|,
name|cmd
argument_list|)
operator|||
operator|!
name|checkep
argument_list|(
operator|&
name|newenv
argument_list|)
expr_stmt|;
else|else
name|done
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|errors
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|newenv
operator|.
name|mode
operator|==
name|ATEND
operator|&&
operator|!
name|parent
argument_list|(
name|newenv
operator|.
name|focus
argument_list|)
condition|)
block|{
name|errors
operator|=
operator|!
name|checkep
argument_list|(
operator|&
name|newenv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errors
condition|)
name|done
operator|=
name|Yes
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HELPFUL
case|case
literal|'?'
case|:
if|if
condition|(
name|help
argument_list|()
condition|)
name|onscreen
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|HELPFUL
block|}
block|}
if|if
condition|(
name|errors
condition|)
name|Erelease
argument_list|(
name|newenv
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|SMALLSYS
if|if
condition|(
name|done
condition|)
name|done
operator|=
name|canexit
argument_list|(
operator|&
name|newenv
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SMALLSYS
if|if
condition|(
name|newenv
operator|.
name|changed
condition|)
operator|++
name|newenv
operator|.
name|generation
expr_stmt|;
name|last
operator|=
name|Succ
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|current
operator|=
name|Succ
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|first
condition|)
block|{
comment|/* Array full (always after a while). Discard "oldest". */
if|if
condition|(
name|current
operator|==
name|last
operator|||
name|undoage
operator|<
name|Mod
argument_list|(
name|current
operator|-
name|first
argument_list|)
condition|)
block|{
name|Erelease
argument_list|(
name|history
index|[
name|first
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
name|Succ
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|undoage
operator|<
name|MAXHIST
condition|)
operator|++
name|undoage
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|Pred
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|Erelease
argument_list|(
name|history
index|[
name|last
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current
operator|!=
name|last
operator|&&
name|newenv
operator|.
name|highest
operator|<
name|history
index|[
name|current
index|]
operator|.
name|highest
condition|)
name|history
index|[
name|current
index|]
operator|.
name|highest
operator|=
name|newenv
operator|.
name|highest
expr_stmt|;
comment|/* Move entries beyond current one up. */
for|for
control|(
name|k
operator|=
name|last
init|;
name|k
operator|!=
name|current
condition|;
name|k
operator|=
name|Pred
argument_list|(
name|k
argument_list|)
control|)
block|{
if|if
condition|(
name|Pred
argument_list|(
name|k
argument_list|)
operator|==
name|onscreen
condition|)
name|onscreen
operator|=
name|k
expr_stmt|;
name|Emove
argument_list|(
name|history
index|[
name|Pred
argument_list|(
name|k
argument_list|)
index|]
argument_list|,
name|history
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|Ecopy
argument_list|(
name|newenv
argument_list|,
name|history
index|[
name|current
index|]
argument_list|)
expr_stmt|;
name|Erelease
argument_list|(
name|history
index|[
name|current
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* default */
block|}
comment|/* switch */
if|if
condition|(
name|errors
operator|&&
name|cmd
operator|!=
literal|'?'
condition|)
block|{
if|if
condition|(
operator|!
name|slowterminal
operator|&&
name|isascii
argument_list|(
name|cmd
argument_list|)
operator|&&
operator|(
name|isprint
argument_list|(
name|cmd
argument_list|)
operator|||
name|cmd
operator|==
literal|' '
operator|)
condition|)
name|error
argument_list|(
name|INS_BAD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|savewhere
condition|)
name|tobesaved
operator|=
operator|&
name|history
index|[
name|current
index|]
expr_stmt|;
block|}
comment|/* for (;;) */
name|actupdate
argument_list|(
name|Vnil
argument_list|,
name|No
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|Erelease
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
name|Ecopy
argument_list|(
name|history
index|[
name|current
index|]
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|savewhere
condition|)
name|tobesaved
operator|=
name|ep
expr_stmt|;
for|for
control|(
name|current
operator|=
name|first
init|;
name|current
operator|!=
name|last
condition|;
name|current
operator|=
name|Succ
argument_list|(
name|current
argument_list|)
control|)
name|Erelease
argument_list|(
name|history
index|[
name|current
index|]
argument_list|)
expr_stmt|;
name|Erelease
argument_list|(
name|history
index|[
name|last
index|]
argument_list|)
expr_stmt|;
comment|/* endshow(); */
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Execute a command, return success or failure.  */
end_comment

begin_function
name|Hidden
name|bool
name|execute
parameter_list|(
name|ep
parameter_list|,
name|cmd
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|cmd
decl_stmt|;
block|{
specifier|register
name|bool
name|spflag
init|=
name|ep
operator|->
name|spflag
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|environ
name|env
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|USERSUGG
name|bool
name|sugg
init|=
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
operator|==
name|Suggestion
decl_stmt|;
define|#
directive|define
name|ACCSUGG
parameter_list|(
name|ep
parameter_list|)
value|if (sugg) accsugg(ep)
define|#
directive|define
name|KILLSUGG
parameter_list|(
name|ep
parameter_list|)
value|if (sugg) killsugg(ep)
else|#
directive|else
else|!USERSUGG
define|#
directive|define
name|ACCSUGG
parameter_list|(
name|ep
parameter_list|)
comment|/* NULL */
define|#
directive|define
name|KILLSUGG
parameter_list|(
name|ep
parameter_list|)
comment|/* NULL */
endif|#
directive|endif
endif|!USERSUGG
ifdef|#
directive|ifdef
name|RECORDING
if|if
condition|(
name|ep
operator|->
name|newmacro
operator|&&
name|cmd
operator|!=
name|USEMACRO
operator|&&
name|cmd
operator|!=
name|SAVEMACRO
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|concato
argument_list|(
operator|&
name|ep
operator|->
name|newmacro
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|RECORDING
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|RECORDING
case|case
name|SAVEMACRO
case|:
name|ep
operator|->
name|spflag
operator|=
name|spflag
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|newmacro
condition|)
block|{
comment|/* End definition */
name|release
argument_list|(
name|ep
operator|->
name|oldmacro
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|newmacro
operator|&&
name|Length
argument_list|(
name|ep
operator|->
name|newmacro
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ep
operator|->
name|oldmacro
operator|=
name|ep
operator|->
name|newmacro
expr_stmt|;
name|message
argument_list|(
name|REC_OK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|release
argument_list|(
name|ep
operator|->
name|newmacro
argument_list|)
expr_stmt|;
name|ep
operator|->
name|oldmacro
operator|=
name|Vnil
expr_stmt|;
block|}
name|ep
operator|->
name|newmacro
operator|=
name|Vnil
expr_stmt|;
block|}
else|else
comment|/* Start definition */
name|ep
operator|->
name|newmacro
operator|=
name|mk_text
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
case|case
name|USEMACRO
case|:
if|if
condition|(
operator|!
name|ep
operator|->
name|oldmacro
operator|||
name|Length
argument_list|(
name|ep
operator|->
name|oldmacro
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|PLB_NOK
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|ep
operator|->
name|spflag
operator|=
name|spflag
expr_stmt|;
name|cp
operator|=
name|Str
argument_list|(
name|ep
operator|->
name|oldmacro
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
argument_list|(
name|ep
operator|->
name|oldmacro
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|Ecopy
argument_list|(
operator|*
name|ep
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|execute
argument_list|(
name|ep
argument_list|,
name|cp
index|[
name|i
index|]
operator|&
literal|0377
argument_list|)
operator|&&
name|checkep
argument_list|(
name|ep
argument_list|)
condition|)
name|Erelease
argument_list|(
name|env
argument_list|)
expr_stmt|;
else|else
block|{
name|Erelease
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
name|Emove
argument_list|(
name|env
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return
name|No
return|;
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Just a bell */
comment|/* The error must be signalled here, because the overall 				   command (USEMACRO) succeeds, so the main loop 				   doesn't ring the bell; but we want to inform the 				   that not everything was done either. */
return|return
name|Yes
return|;
block|}
block|}
return|return
name|Yes
return|;
endif|#
directive|endif
endif|RECORDING
ifndef|#
directive|ifndef
name|SMALLSYS
case|case
name|Ctl
argument_list|(
name|_
argument_list|)
case|:
comment|/* 'Touch', i.e. set modified flag */
name|ep
operator|->
name|changed
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
endif|#
directive|endif
endif|SMALLSYS
case|case
name|GOTO
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RECORDING
if|if
condition|(
name|ep
operator|->
name|newmacro
condition|)
block|{
name|error
argument_list|(
name|GOTO_REC
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
endif|#
directive|endif
endif|RECORDING
return|return
name|gotocursor
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|NEXT
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|next
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|PREVIOUS
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|previous
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|LEFTARROW
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|leftarrow
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|RITEARROW
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|ritearrow
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|WIDEN
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|widen
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|EXTEND
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|extend
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|NARROW
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|narrow
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|RNARROW
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|rnarrow
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|UPARROW
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|uparrow
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|DOWNARROW
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|downarrow
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|UPLINE
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|upline
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|DOWNLINE
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|downline
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|COPY
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|spflag
operator|=
name|spflag
expr_stmt|;
return|return
name|copyinout
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|DELETE
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|delete
argument_list|(
name|ep
argument_list|)
return|;
case|case
name|ACCEPT
case|:
name|ACCSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|accept
argument_list|(
name|ep
argument_list|)
return|;
default|default:
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|cmd
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|cmd
argument_list|)
condition|)
return|return
name|No
return|;
name|ep
operator|->
name|spflag
operator|=
name|spflag
expr_stmt|;
return|return
name|ins_char
argument_list|(
name|ep
argument_list|,
name|cmd
argument_list|,
name|islower
argument_list|(
name|cmd
argument_list|)
condition|?
name|toupper
argument_list|(
name|cmd
argument_list|)
else|:
operator|-
literal|1
argument_list|)
return|;
case|case
literal|' '
case|:
name|ep
operator|->
name|spflag
operator|=
name|spflag
expr_stmt|;
return|return
name|ins_char
argument_list|(
name|ep
argument_list|,
literal|' '
argument_list|,
operator|-
literal|1
argument_list|)
return|;
case|case
name|RETURN
case|:
case|case
name|NEWLINE
case|:
name|KILLSUGG
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|ins_newline
argument_list|(
name|ep
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize an environment variable.  Most things are set to 0 or NULL.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|clrenv
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
name|ep
operator|->
name|focus
operator|=
name|newpath
argument_list|(
name|Pnil
argument_list|,
name|gram
argument_list|(
name|Optional
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
name|ep
operator|->
name|copyflag
operator|=
name|ep
operator|->
name|spflag
operator|=
name|ep
operator|->
name|changed
operator|=
name|No
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
name|ep
operator|->
name|s2
operator|=
name|ep
operator|->
name|s3
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|highest
operator|=
name|Maxintlet
expr_stmt|;
name|ep
operator|->
name|copybuffer
operator|=
name|Vnil
expr_stmt|;
ifdef|#
directive|ifdef
name|RECORDING
name|ep
operator|->
name|oldmacro
operator|=
name|ep
operator|->
name|newmacro
operator|=
name|Vnil
expr_stmt|;
endif|#
directive|endif
endif|RECORDING
name|ep
operator|->
name|generation
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|changed
operator|=
name|No
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save parse tree and copy buffer.  */
end_comment

begin_function
name|Visible
name|Procedure
name|enddemo
parameter_list|()
block|{
specifier|register
name|environ
modifier|*
name|ep
init|=
name|tobesaved
decl_stmt|;
name|tobesaved
operator|=
operator|(
name|environ
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* To avoid loops if saving is interrupted. */
if|if
condition|(
name|savewhere
operator|&&
name|ep
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|generation
operator|>
literal|0
condition|)
block|{
name|save
argument_list|(
name|ep
operator|->
name|focus
argument_list|,
name|savewhere
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERSUGG
name|writesugg
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|USERSUGG
block|}
ifdef|#
directive|ifdef
name|SAVEBUF
if|if
condition|(
name|ep
operator|->
name|copyflag
condition|)
name|savequeue
argument_list|(
name|ep
operator|->
name|copybuffer
argument_list|,
name|copysavefile
argument_list|)
expr_stmt|;
else|else
name|savequeue
argument_list|(
name|Vnil
argument_list|,
name|copysavefile
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SAVEBUF
ifdef|#
directive|ifdef
name|SAVEPOS
name|savepos
argument_list|(
name|savewhere
argument_list|,
name|lineno
argument_list|(
name|ep
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SAVEPOS
block|}
ifdef|#
directive|ifdef
name|BTOP
name|waitchild
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|BTOP
block|}
end_function

begin_comment
comment|/*  * Find out if the current position is higher in the tree  * than `ever' before (as remembered in ep->highest).  * The algorithm of pathlength() is repeated here to gain  * some efficiency by stopping as soon as it is clear  * no change can occur.  * (Higher() is called VERY often, so this pays).  */
end_comment

begin_function
name|Visible
name|Procedure
name|higher
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|path
name|p
init|=
name|ep
operator|->
name|focus
decl_stmt|;
specifier|register
name|int
name|pl
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|max
init|=
name|ep
operator|->
name|highest
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
operator|++
name|pl
expr_stmt|;
if|if
condition|(
name|pl
operator|>=
name|max
condition|)
return|return;
name|p
operator|=
name|parent
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|highest
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue debug status message.  */
end_comment

begin_function
name|Visible
name|Procedure
name|dbmess
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SMALLSYS
name|char
name|stuff
index|[
literal|80
index|]
decl_stmt|;
specifier|register
name|string
name|str
init|=
name|stuff
decl_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|VHOLE
case|:
name|sprintf
argument_list|(
name|stuff
argument_list|,
literal|"VHOLE:%d.%d"
argument_list|,
name|ep
operator|->
name|s1
argument_list|,
name|ep
operator|->
name|s2
argument_list|)
expr_stmt|;
break|break;
case|case
name|FHOLE
case|:
name|sprintf
argument_list|(
name|stuff
argument_list|,
literal|"FHOLE:%d.%d"
argument_list|,
name|ep
operator|->
name|s1
argument_list|,
name|ep
operator|->
name|s2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATBEGIN
case|:
name|str
operator|=
literal|"ATBEGIN"
expr_stmt|;
break|break;
case|case
name|ATEND
case|:
name|str
operator|=
literal|"ATEND"
expr_stmt|;
break|break;
case|case
name|WHOLE
case|:
name|str
operator|=
literal|"WHOLE"
expr_stmt|;
break|break;
case|case
name|SUBRANGE
case|:
name|sprintf
argument_list|(
name|stuff
argument_list|,
literal|"SUBRANGE:%d.%d-%d"
argument_list|,
name|ep
operator|->
name|s1
argument_list|,
name|ep
operator|->
name|s2
argument_list|,
name|ep
operator|->
name|s3
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBSET
case|:
name|sprintf
argument_list|(
name|stuff
argument_list|,
literal|"SUBSET:%d-%d"
argument_list|,
name|ep
operator|->
name|s1
argument_list|,
name|ep
operator|->
name|s2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBLIST
case|:
name|sprintf
argument_list|(
name|stuff
argument_list|,
literal|"SUBLIST...%d"
argument_list|,
name|ep
operator|->
name|s3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|stuff
argument_list|,
literal|"UNKNOWN:%d,%d,%d,%d"
argument_list|,
name|ep
operator|->
name|mode
argument_list|,
name|ep
operator|->
name|s1
argument_list|,
name|ep
operator|->
name|s2
argument_list|,
name|ep
operator|->
name|s3
argument_list|)
expr_stmt|;
block|}
name|message
argument_list|(
ifdef|#
directive|ifdef
name|SAVEBUF
literal|"%s, %s, wi=%d, hi=%d, (y,x,l)=(%d,%d,%d) %s"
argument_list|,
name|symname
argument_list|(
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
argument_list|)
argument_list|,
else|#
directive|else
else|!SAVEBUF
literal|"%d, %s, wi=%d, hi=%d, (y,x,l)=(%d,%d,%d) %s"
argument_list|,
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
argument_list|,
endif|#
directive|endif
endif|SAVEBUF
name|str
argument_list|,
name|width
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
argument_list|,
name|ep
operator|->
name|highest
argument_list|,
name|Ycoord
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|,
name|Xcoord
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|,
name|Level
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|,
name|ep
operator|->
name|spflag
condition|?
literal|"spflag on"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!SMALLSYS
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALLSYS
end_ifndef

begin_function
name|Hidden
name|bool
name|canexit
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
name|environ
name|env
decl_stmt|;
name|shrink
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishole
argument_list|(
name|ep
argument_list|)
condition|)
name|delete
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|Ecopy
argument_list|(
operator|*
name|ep
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|top
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
if|if
condition|(
name|findhole
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
block|{
name|Erelease
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|EXIT_HOLES
argument_list|)
expr_stmt|;
comment|/* There are holes left */
return|return
name|No
return|;
block|}
name|Erelease
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
name|Emove
argument_list|(
name|env
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|findhole
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|node
name|n
init|=
name|tree
argument_list|(
operator|*
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|)
return|return
name|No
return|;
if|if
condition|(
name|symbol
argument_list|(
name|n
argument_list|)
operator|==
name|Hole
condition|)
return|return
name|Yes
return|;
if|if
condition|(
operator|!
name|down
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|findhole
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|Yes
return|;
if|if
condition|(
operator|!
name|rite
argument_list|(
name|pp
argument_list|)
condition|)
break|break;
block|}
name|up
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
return|return
name|No
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|!SMALLSYS
end_endif

end_unit

