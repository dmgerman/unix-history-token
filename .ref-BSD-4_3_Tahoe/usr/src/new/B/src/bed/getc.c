begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/* $Header: getc.c,v 2.5 85/08/22 16:02:44 timo Exp $ */
end_comment

begin_comment
comment|/* B editor -- read key definitions from file */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LINDA
end_ifdef

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_define
define|#
directive|define
name|syserr
value|EDsyserr
end_define

begin_else
else|#
directive|else
else|!LINDA
end_else

begin_define
define|#
directive|define
name|freemem
parameter_list|(
name|p
parameter_list|)
value|free(p)
end_define

begin_endif
endif|#
directive|endif
endif|!LINDA
end_endif

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"keys.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|extern
name|bool
name|dflag
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ESC
value|'\033'
end_define

begin_comment
comment|/* This file contains a little parser for key definition files. To allow sufficient freedom in preparing such a file, a simple grammar has been defined according to which the file is parsed. The parsing process is extremely simple, as it can be done top-down using recursive descent.   Lexical conventions:  - Blanks between lexical symbols are gnored. - From '#' to end of line is comment (except inside strings). - Strings are delimited by single or double quotes and   use the same escape sequences as C strings, plus:   \e or \E means an ESCape ('\033'). - Command names are like C identifiers ([a-zA-Z_][a-zA-Z0-9_]*).   Upper/lower case distinction is significant. - numbers are octal or decimal integers in C-style (leading zero means octal) - After '^' a character is expected, this must be a letter or one of @^_[]\ .  Syntax in modified BNF ([] mean 0 or 1, * means 0 or more, + means 1 or more):     file: line*    line: [def] [comment]    def: commandname '=' rhs    rhs: item+    item: string | '^' character | number   Notes:  - A definition for command "term_init" defines a string to be sent   TO the terminal at initialization time, e.g. to set programmable   function key definitions.  Similar for "term_done" on exiting. - Command names are  conventional editor commands.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINDA
end_ifndef

begin_comment
comment|/* Defines subroutine that used to be in the support levels: */
end_comment

begin_function
name|Hidden
name|string
name|getmem
parameter_list|(
name|nbytes
parameter_list|)
name|unsigned
name|nbytes
decl_stmt|;
block|{
name|string
name|malloc
parameter_list|()
function_decl|;
name|string
name|pointer
init|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointer
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"memory full in initkeys"
argument_list|)
expr_stmt|;
return|return
name|pointer
return|;
block|}
end_function

begin_function
name|Hidden
name|string
name|regetmem
parameter_list|(
name|pp
parameter_list|,
name|nbytes
parameter_list|)
name|string
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|nbytes
decl_stmt|;
block|{
operator|*
name|pp
operator|=
name|realloc
argument_list|(
operator|*
name|pp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"memory full in initkeys (regetmem)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|!LINDA
end_endif

begin_define
define|#
directive|define
name|COMMENT
value|'#'
end_define

begin_comment
comment|/* Not B-like but very UNIX-like */
end_comment

begin_define
define|#
directive|define
name|MAXDEFS
value|100
end_define

begin_decl_stmt
name|Hidden
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File from which to read */
end_comment

begin_decl_stmt
name|Hidden
name|string
name|filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name for error messages */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next character to be analyzed */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF seen? */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|lcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line number */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|errcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of errors detected */
end_comment

begin_struct
struct|struct
name|tabent
block|{
name|int
name|code
decl_stmt|;
name|string
name|name
decl_stmt|;
name|string
name|def
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Table of key definitions, mostly filled by reading definitions from a file.    The "I" macro has two arguments: the default for termcap and that for    the IBM PC.  It expands to either depending on whether IBMPC is defined.    'def' fields initialized with a string starting with '=' are termcap names,    and are replaced by the corresponding termcap entry (NULL if none).    On the IBM PC, 'extended codes' are by convention a null character    followed by another character (usually the scan code).  Since the null    character is rather unsuitable for use in C strings, we use \377 (hex FF)    instead, a code which has no assigned graphic is the extended IBM PC    character set.  E.g., F1 is 0-59, which we encode as \377\073 (since    \073 is octal for 59 decimal).  For the exact codes, see for instance the    BASIC 2.0 manual, appendix G, or the XT Technical Reference, page 2-14. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_define
define|#
directive|define
name|I
parameter_list|(
name|tc
parameter_list|,
name|ibm
parameter_list|)
value|ibm
end_define

begin_else
else|#
directive|else
else|!IBMPC
end_else

begin_define
define|#
directive|define
name|I
parameter_list|(
name|tc
parameter_list|,
name|ibm
parameter_list|)
value|tc
end_define

begin_endif
endif|#
directive|endif
endif|!IBMPC
end_endif

begin_decl_stmt
name|Visible
name|struct
name|tabent
name|deftab
index|[
name|MAXDEFS
index|]
init|=
block|{
comment|/* General rule: 	   unix => ctrl-x 	   IBM  => alt-x 	   where x is first letter of command name 	*/
block|{
literal|0377
block|,
literal|"ignore"
block|,
name|NULL
block|}
block|,
comment|/* Entry to ignore a key */
block|{
name|COPY
block|,
literal|"copy"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\056"
argument_list|)
block|}
block|,
block|{
name|DELETE
block|,
literal|"delete"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\040"
argument_list|)
block|}
block|,
block|{
name|DELETE
block|,
literal|"delete"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\123"
argument_list|)
block|}
block|,
comment|/* IBM DEL key */
block|{
name|ACCEPT
block|,
literal|"accept"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\022"
argument_list|)
block|}
block|,
comment|/* ^E, alt-E */
block|{
name|ACCEPT
block|,
literal|"end"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\117"
argument_list|)
block|}
block|,
comment|/* IBM END key */
block|{
literal|'\t'
block|,
literal|"tab"
block|,
name|NULL
block|}
block|,
comment|/* = ACCEPT in Bed, insert tab in Linda */
block|{
name|UNDO
block|,
literal|"undo"
block|}
block|,
comment|/* Always backspace = ^H */
block|{
name|REDRAW
block|,
literal|"redraw"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\046"
argument_list|)
block|}
block|,
comment|/* ^L, alt-L */
block|{
name|REDRAW
block|,
literal|"look"
block|}
block|,
block|{
name|RETURN
block|,
literal|"newline"
block|}
block|,
comment|/* Always ^M */
block|{
name|REDO
block|,
literal|"redo"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\177"
argument_list|)
block|}
block|,
comment|/* IBM ctrl-BS = ASCII 177 (DEL) */
block|{
name|EXIT
block|,
literal|"exit"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\055"
argument_list|)
block|}
block|,
comment|/* ^X, alt-X */
ifdef|#
directive|ifdef
name|RECORDING
comment|/* 	 * The IBM-PC has a problem here in ANSI.SYS mode: ctrl-P is 	 * unusable because it means Print Screen, and alt-R is unusable 	 * because it transmits 0, 19 but 19 is ctrl-S which means stop 	 * output :-(. 	 * The only reasonable place to put the things would then be on 	 * function keys.  You should do this in the key definitions file. (?) 	 */
block|{
name|PLAYBACK
block|,
literal|"play"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\031"
argument_list|)
block|}
block|,
block|{
name|PLAYBACK
block|,
literal|"playback"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\031"
argument_list|)
block|}
block|,
block|{
name|RECORD
block|,
literal|"record"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\023"
argument_list|)
block|}
block|,
endif|#
directive|endif
endif|RECORDING
ifdef|#
directive|ifdef
name|LINDA
block|{
name|BFIND
block|,
literal|"bfind"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\060"
argument_list|)
block|}
block|,
block|{
name|FIND
block|,
literal|"find"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\041"
argument_list|)
block|}
block|,
block|{
name|GLOBAL
block|,
literal|"global"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\042"
argument_list|)
block|}
block|,
block|{
name|JOIN
block|,
literal|"join"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\044"
argument_list|)
block|}
block|,
block|{
name|TOGGLE
block|,
literal|"toggle"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\024"
argument_list|)
block|}
block|,
block|{
name|YANK
block|,
literal|"yank"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\025"
argument_list|)
block|}
block|,
block|{
name|LITERAL
block|,
literal|"literal"
block|,
name|I
argument_list|(
argument|NULL
argument_list|,
literal|"\377\057"
argument_list|)
block|}
block|,
comment|/* ^V, alt-V */
endif|#
directive|endif
endif|LINDA
block|{
name|WIDEN
block|,
literal|"widen"
block|,
name|I
argument_list|(
literal|"=k1"
argument_list|,
literal|"\377\073"
argument_list|)
block|}
block|,
comment|/* IBM F1 */
block|{
name|NARROW
block|,
literal|"narrow"
block|,
name|I
argument_list|(
literal|"=k2"
argument_list|,
literal|"\377\075"
argument_list|)
block|}
block|,
comment|/* IBM F3 (!!!) */
block|{
name|NARROW
block|,
literal|"first"
block|}
block|,
block|{
name|RNARROW
block|,
literal|"rnarrow"
block|,
name|I
argument_list|(
literal|"=k3"
argument_list|,
literal|"\377\076"
argument_list|)
block|}
block|,
comment|/* IBM F4 (!!!) */
block|{
name|RNARROW
block|,
literal|"last"
block|}
block|,
block|{
name|EXTEND
block|,
literal|"extend"
block|,
name|I
argument_list|(
literal|"=k4"
argument_list|,
literal|"\377\074"
argument_list|)
block|}
block|,
comment|/* IBM F2 (!!!) */
block|{
name|UPARROW
block|,
literal|"up"
block|,
name|I
argument_list|(
literal|"=ku"
argument_list|,
literal|"\377\110"
argument_list|)
block|}
block|,
block|{
name|UPLINE
block|,
literal|"upline"
block|,
name|I
argument_list|(
literal|"=k5"
argument_list|,
literal|"\377\110"
argument_list|)
block|}
block|,
block|{
name|LEFTARROW
block|,
literal|"left"
block|,
name|I
argument_list|(
literal|"=kl"
argument_list|,
literal|"\377\113"
argument_list|)
block|}
block|,
block|{
name|PREVIOUS
block|,
literal|"previous"
block|,
name|I
argument_list|(
literal|"=k6"
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
block|{
name|RITEARROW
block|,
literal|"right"
block|,
name|I
argument_list|(
literal|"=kr"
argument_list|,
literal|"\377\115"
argument_list|)
block|}
block|,
block|{
name|NEXT
block|,
literal|"next"
block|,
name|I
argument_list|(
literal|"=k7"
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
block|{
name|DOWNARROW
block|,
literal|"down"
block|,
name|I
argument_list|(
literal|"=kd"
argument_list|,
literal|"\377\120"
argument_list|)
block|}
block|,
block|{
name|DOWNLINE
block|,
literal|"downline"
block|,
name|I
argument_list|(
literal|"=k8"
argument_list|,
literal|"\377\120"
argument_list|)
block|}
block|,
block|{
name|GOTO
block|,
literal|"goto"
block|,
name|I
argument_list|(
literal|"\033g"
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
comment|/* Doesn't exist on IBM */
ifdef|#
directive|ifdef
name|HELPFUL
block|{
name|HELP
block|,
literal|"help"
block|,
name|I
argument_list|(
literal|"\033?"
argument_list|,
literal|"\377\104"
argument_list|)
block|}
block|,
comment|/* ESC ?, IBM F10 */
endif|#
directive|endif
endif|HELPFUL
block|{
literal|0
block|,
literal|"term_init"
block|,
name|I
argument_list|(
literal|"=ks"
argument_list|,
argument|NULL
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|"term_done"
block|,
name|I
argument_list|(
literal|"=ke"
argument_list|,
argument|NULL
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|I
end_undef

begin_decl_stmt
name|Hidden
name|int
name|ndefs
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|Procedure
name|err
parameter_list|(
name|fmt
parameter_list|,
name|arg
parameter_list|)
name|string
name|fmt
decl_stmt|,
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|errcount
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Errors in key definitions file:\n"
argument_list|)
expr_stmt|;
operator|++
name|errcount
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|filename
argument_list|,
name|lcount
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|adv
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|eof
condition|)
return|return;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|nextc
operator|=
literal|'\n'
expr_stmt|;
name|eof
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|lcount
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|skipsp
parameter_list|()
block|{
while|while
condition|(
name|nextc
operator|==
literal|' '
operator|||
name|nextc
operator|==
literal|'\t'
condition|)
name|adv
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|int
name|lookup
parameter_list|(
name|name
parameter_list|)
name|string
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndefs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|deftab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|deftab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|store
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|def
parameter_list|)
name|int
name|code
decl_stmt|;
name|string
name|name
decl_stmt|;
name|string
name|def
decl_stmt|;
block|{
name|struct
name|tabent
modifier|*
name|d
decl_stmt|,
modifier|*
name|last
init|=
name|deftab
operator|+
name|ndefs
decl_stmt|;
name|string
name|p
decl_stmt|,
name|q
decl_stmt|;
comment|/* Undefine conflicting definitions.  Conflicts arise 	   when a command definition is an initial subsequence 	   of another, or vice versa.  Key definitions (code< 0) 	   are not undefined. */
if|if
condition|(
name|code
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|deftab
init|;
name|d
operator|<
name|last
condition|;
operator|++
name|d
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|>=
literal|0
operator|&&
name|d
operator|->
name|def
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|def
operator|,
name|q
operator|=
name|d
operator|->
name|def
init|;
operator|*
name|p
operator|==
operator|*
name|q
condition|;
operator|++
name|p
operator|,
operator|++
name|q
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|d
operator|->
name|def
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Find a free slot with the same code and NULL definition */
comment|/* (For code == 0, the name must match instead of the code, 	   and the definition need not be NULL) */
for|for
control|(
name|d
operator|=
name|deftab
init|;
name|d
operator|<
name|last
condition|;
operator|++
name|d
control|)
block|{
if|if
condition|(
name|code
operator|==
literal|0
condition|?
name|strcmp
argument_list|(
name|name
argument_list|,
name|d
operator|->
name|name
argument_list|)
operator|==
literal|0
else|:
operator|(
name|d
operator|->
name|code
operator|==
name|code
operator|&&
name|d
operator|->
name|def
operator|==
name|NULL
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|d
operator|==
name|last
condition|)
block|{
comment|/* Extend definition table */
if|if
condition|(
name|ndefs
operator|>=
name|MAXDEFS
condition|)
block|{
name|err
argument_list|(
literal|"Too many key definitions"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|ndefs
expr_stmt|;
name|d
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|d
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
name|d
operator|->
name|def
operator|=
name|def
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|string
name|savestr
parameter_list|(
name|s
parameter_list|)
name|string
name|s
decl_stmt|;
block|{
name|string
name|new
decl_stmt|;
name|new
operator|=
name|getmem
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|append
parameter_list|(
name|to
parameter_list|,
name|item
parameter_list|)
name|string
modifier|*
name|to
decl_stmt|,
name|item
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
operator|*
name|to
argument_list|)
operator|+
name|strlen
argument_list|(
name|item
argument_list|)
operator|+
literal|1
decl_stmt|;
name|regetmem
argument_list|(
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|to
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|string
name|getname
parameter_list|()
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|string
name|bp
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|nextc
argument_list|)
operator|&&
name|nextc
operator|!=
literal|'_'
condition|)
block|{
name|err
argument_list|(
literal|"No name where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|bp
operator|=
name|buffer
init|;
name|isalnum
argument_list|(
name|nextc
argument_list|)
operator|||
name|nextc
operator|==
literal|'_'
condition|;
control|)
block|{
if|if
condition|(
name|bp
operator|<
name|buffer
operator|+
sizeof|sizeof
name|buffer
operator|-
literal|1
condition|)
operator|*
name|bp
operator|++
operator|=
name|nextc
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|savestr
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|int
name|getnumber
parameter_list|()
block|{
name|int
name|base
init|=
operator|(
name|nextc
operator|==
literal|'0'
operator|)
condition|?
literal|8
else|:
literal|10
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|d
decl_stmt|;
for|for
control|(
init|;
condition|;
name|adv
argument_list|()
control|)
block|{
name|d
operator|=
name|nextc
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
operator|||
name|d
operator|>
literal|9
condition|)
break|break;
if|if
condition|(
name|d
operator|>
name|base
condition|)
block|{
name|err
argument_list|(
literal|"8 or 9 in octal number"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
name|i
operator|*
name|base
operator|+
name|d
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|Hidden
name|string
name|getstring
parameter_list|()
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* Arbitrary limit */
name|char
name|quote
init|=
name|nextc
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|adv
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextc
operator|!=
name|quote
condition|)
block|{
if|if
condition|(
name|nextc
operator|==
literal|'\n'
condition|)
block|{
name|err
argument_list|(
literal|"closing string quote not found"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|nextc
operator|!=
literal|'\\'
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|adv
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|nextc
condition|)
block|{
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|c
operator|=
name|ESC
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|c
operator|=
name|nextc
operator|-
literal|'0'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextc
operator|>=
literal|'0'
operator|&&
name|nextc
operator|<
literal|'8'
condition|)
block|{
name|c
operator|=
literal|8
operator|*
name|c
operator|+
name|nextc
operator|-
literal|'0'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextc
operator|>=
literal|'0'
operator|&&
name|nextc
operator|<
literal|'8'
condition|)
block|{
name|c
operator|=
literal|8
operator|*
name|c
operator|+
name|nextc
operator|-
literal|'0'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|c
operator|=
name|nextc
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|buf
condition|)
block|{
name|err
argument_list|(
literal|"string too long"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|adv
argument_list|()
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|savestr
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|string
name|getitem
parameter_list|()
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|string
name|keyname
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|nextc
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
return|return
name|getstring
argument_list|()
return|;
case|case
literal|'^'
case|:
name|adv
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|nextc
argument_list|)
operator|||
name|index
argument_list|(
literal|"@^_[]\\?"
argument_list|,
name|nextc
argument_list|)
condition|)
block|{
if|if
condition|(
name|nextc
operator|==
literal|'?'
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\177'
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
name|nextc
operator|&
literal|037
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|adv
argument_list|()
expr_stmt|;
return|return
name|savestr
argument_list|(
name|buf
argument_list|)
return|;
block|}
name|err
argument_list|(
literal|"Invalid character after '^'"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|nextc
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|getnumber
argument_list|()
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|savestr
argument_list|(
name|buf
argument_list|)
return|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|nextc
argument_list|)
operator|||
name|nextc
operator|==
literal|'_'
condition|)
block|{
name|keyname
operator|=
name|getname
argument_list|()
expr_stmt|;
comment|/* Cannot fail */
if|if
condition|(
name|strlen
argument_list|(
name|keyname
argument_list|)
operator|==
literal|1
condition|)
return|return
name|savestr
argument_list|(
name|keyname
argument_list|)
return|;
comment|/* Single letters stand for themselves */
name|i
operator|=
name|lookup
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|deftab
index|[
name|i
index|]
operator|.
name|code
operator|<=
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"%s: not a key name"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|freemem
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|deftab
index|[
name|i
index|]
operator|.
name|def
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"%s: undefined key"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|freemem
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|savestr
argument_list|(
name|deftab
index|[
name|i
index|]
operator|.
name|def
argument_list|)
return|;
block|}
name|err
argument_list|(
literal|"Invalid item"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|string
name|getrhs
parameter_list|()
block|{
name|string
name|first
decl_stmt|,
name|item
decl_stmt|;
name|skipsp
argument_list|()
expr_stmt|;
name|first
operator|=
name|getitem
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|skipsp
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextc
operator|==
literal|'\n'
operator|||
name|nextc
operator|==
name|COMMENT
condition|)
break|break;
name|item
operator|=
name|getitem
argument_list|()
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|freemem
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|append
argument_list|(
operator|&
name|first
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|freemem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|first
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|getdef
parameter_list|()
block|{
name|string
name|name
decl_stmt|;
name|int
name|key
decl_stmt|;
name|string
name|rhs
decl_stmt|;
name|name
operator|=
name|getname
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return;
name|skipsp
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextc
operator|!=
literal|'='
condition|)
block|{
name|err
argument_list|(
literal|"Command name %s not followed by '='"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|key
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"Unknown command: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|deftab
index|[
name|key
index|]
operator|.
name|code
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"No redefinition of %s allowed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|adv
argument_list|()
expr_stmt|;
name|rhs
operator|=
name|getrhs
argument_list|()
expr_stmt|;
if|if
condition|(
name|rhs
operator|!=
name|NULL
condition|)
name|store
argument_list|(
name|deftab
index|[
name|key
index|]
operator|.
name|code
argument_list|,
name|name
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|getline
parameter_list|()
block|{
name|adv
argument_list|()
expr_stmt|;
name|skipsp
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextc
operator|!=
name|COMMENT
operator|&&
name|nextc
operator|!=
literal|'\n'
condition|)
name|getdef
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextc
operator|!=
literal|'\n'
condition|)
name|adv
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_function
name|Hidden
name|Procedure
name|dump
parameter_list|(
name|where
parameter_list|)
name|string
name|where
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|string
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"\nDump of key definitions %s.\n\n"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Code    Name            Definition\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndefs
condition|;
operator|++
name|i
control|)
block|{
name|printf
argument_list|(
literal|"%04o    "
argument_list|,
name|deftab
index|[
name|i
index|]
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|deftab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%-15s "
argument_list|,
name|deftab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%16s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|s
operator|=
name|deftab
index|[
name|i
index|]
operator|.
name|def
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
name|isprint
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|' '
operator|)
condition|)
name|fputc
argument_list|(
operator|*
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|*
name|s
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|!NDEBUG
end_endif

begin_function
name|Hidden
name|Procedure
name|countdefs
parameter_list|()
block|{
name|struct
name|tabent
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|deftab
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|name
operator|!=
name|NULL
operator|||
name|d
operator|->
name|code
operator|!=
literal|0
operator|||
name|d
operator|->
name|def
operator|!=
name|NULL
condition|)
block|{
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|deftab
operator|+
name|MAXDEFS
condition|)
name|syserr
argument_list|(
literal|"too many predefined keys"
argument_list|)
expr_stmt|;
block|}
name|ndefs
operator|=
name|d
operator|-
name|deftab
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|process
parameter_list|()
block|{
name|errcount
operator|=
literal|0
expr_stmt|;
name|lcount
operator|=
literal|1
expr_stmt|;
name|eof
operator|=
name|No
expr_stmt|;
do|do
block|{
name|getline
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|try
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|,
name|type
parameter_list|)
name|string
name|dir
decl_stmt|,
name|file
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%.150s\\%.9s%.3s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
else|!IBMPC
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%.150s/%.20s%.20s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!IBMPC
name|fp
operator|=
name|fopen
argument_list|(
name|buffer
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|No
return|;
name|filename
operator|=
name|buffer
expr_stmt|;
name|process
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|dump
argument_list|(
literal|"after try"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
return|return
name|Yes
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_function
name|Hidden
name|Procedure
name|readtermcap
parameter_list|()
block|{
name|string
name|tgetstr
parameter_list|()
function_decl|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
comment|/* Constant dictated by termcap manual entry */
specifier|static
name|char
name|area
index|[
literal|1024
index|]
decl_stmt|;
name|string
name|endarea
init|=
name|area
decl_stmt|;
name|string
name|anentry
decl_stmt|;
name|struct
name|tabent
modifier|*
name|d
decl_stmt|,
modifier|*
name|last
decl_stmt|;
switch|switch
condition|(
name|tgetent
argument_list|(
name|buffer
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Bad tgetent() return value.\n"
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't read termcap.\n"
argument_list|)
expr_stmt|;
comment|/* Fall through again */
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** No description for your terminal.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
break|break;
block|}
name|last
operator|=
name|deftab
operator|+
name|ndefs
expr_stmt|;
for|for
control|(
name|d
operator|=
name|deftab
init|;
name|d
operator|<
name|last
condition|;
operator|++
name|d
control|)
block|{
if|if
condition|(
name|d
operator|->
name|def
operator|!=
name|NULL
operator|&&
name|d
operator|->
name|def
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|anentry
operator|=
name|tgetstr
argument_list|(
name|d
operator|->
name|def
operator|+
literal|1
argument_list|,
operator|&
name|endarea
argument_list|)
expr_stmt|;
if|if
condition|(
name|anentry
operator|!=
name|NULL
operator|&&
name|anentry
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|d
operator|->
name|def
operator|=
name|anentry
expr_stmt|;
else|else
name|d
operator|->
name|def
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|!IBMPC
end_endif

begin_function
name|Visible
name|Procedure
name|initkeys
parameter_list|()
block|{
name|string
name|term
init|=
name|NULL
decl_stmt|;
name|countdefs
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|dump
argument_list|(
literal|"before termcap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
ifndef|#
directive|ifndef
name|IBMPC
name|readtermcap
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|dump
argument_list|(
literal|"after termcap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|!=
name|NULL
operator|&&
name|term
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|term
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
endif|!IBMPC
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Try in the current directory. Only for debugging porpoises. */
if|if
condition|(
name|term
operator|!=
name|NULL
condition|)
if|if
condition|(
name|try
argument_list|(
literal|"."
argument_list|,
name|keyfile
argument_list|,
name|term
argument_list|)
condition|)
return|return;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|term
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|try
argument_list|(
name|homedir
argument_list|,
name|keyfile
argument_list|,
name|term
argument_list|)
condition|)
return|return;
if|if
condition|(
name|try
argument_list|(
name|libdir
argument_list|,
name|keyfile
argument_list|,
name|term
argument_list|)
condition|)
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|try
argument_list|(
literal|"."
argument_list|,
name|keyfile
argument_list|,
name|deftype
argument_list|)
condition|)
return|return;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|try
argument_list|(
name|homedir
argument_list|,
name|keyfile
argument_list|,
name|deftype
argument_list|)
condition|)
return|return;
if|if
condition|(
name|try
argument_list|(
name|libdir
argument_list|,
name|keyfile
argument_list|,
name|deftype
argument_list|)
condition|)
return|return;
ifndef|#
directive|ifndef
name|NDEBUG
name|printf
argument_list|(
literal|"[No key definitions file found, using defaults.]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!NDEBUG
block|}
end_function

begin_comment
comment|/* Output a named string to the terminal */
end_comment

begin_function
name|Hidden
name|Procedure
name|outstring
parameter_list|(
name|name
parameter_list|)
name|string
name|name
decl_stmt|;
block|{
name|int
name|i
init|=
name|lookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|string
name|def
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
operator|(
name|def
operator|=
name|deftab
index|[
name|i
index|]
operator|.
name|def
operator|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|def
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the terminal's initialization sequence, if any. */
end_comment

begin_function
name|Visible
name|Procedure
name|initgetc
parameter_list|()
block|{
name|outstring
argument_list|(
literal|"term_init"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a sequence, if any, to return the terminal to a 'normal' state. */
end_comment

begin_function
name|Visible
name|Procedure
name|endgetc
parameter_list|()
block|{
name|outstring
argument_list|(
literal|"term_done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a command from the keyboard, decoding composite key definitions. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_comment
comment|/* Strip high bit from input characters (matters only on PWB systems?) */
end_comment

begin_define
define|#
directive|define
name|getch
parameter_list|()
value|(getchar()& 0177)
end_define

begin_endif
endif|#
directive|endif
endif|!IBMPC
end_endif

begin_function
name|Visible
name|int
name|inchar
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|struct
name|tabent
modifier|*
name|d
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|c
return|;
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
endif|IBMPC
name|last
operator|=
name|deftab
operator|+
name|ndefs
expr_stmt|;
for|for
control|(
name|d
operator|=
name|deftab
init|;
name|d
operator|<
name|last
condition|;
operator|++
name|d
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|>
literal|0
operator|&&
name|d
operator|->
name|def
operator|!=
name|NULL
operator|&&
name|c
operator|==
operator|(
name|d
operator|->
name|def
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|d
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
comment|/* Kludge to make ESC-char by default equal to 			   char|MASK -- the command definitions do the rest: 			   e.g. WIDEN is 'w'|MASK, so ESC-w means WIDEN. */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
operator|(
name|c
operator|&
literal|0177
operator|)
operator||
name|MASK
return|;
block|}
return|return
name|c
return|;
block|}
if|if
condition|(
name|d
operator|->
name|def
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|d
operator|->
name|code
return|;
name|buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|buffer
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
name|buffer
operator|-
literal|1
condition|)
operator|++
name|len
expr_stmt|;
for|for
control|(
name|d
operator|=
name|deftab
init|;
name|d
operator|<
name|last
condition|;
operator|++
name|d
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|>
literal|0
operator|&&
name|d
operator|->
name|def
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
name|d
operator|->
name|def
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|d
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
name|ESC
operator|&&
name|len
operator|==
literal|2
condition|)
block|{
comment|/* Same kludge as above */
return|return
name|c
operator|&
literal|0177
operator||
name|MASK
return|;
block|}
return|return
literal|0377
return|;
comment|/* Hope this rings a bell */
block|}
if|if
condition|(
name|d
operator|->
name|def
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
return|return
name|d
operator|->
name|code
return|;
block|}
block|}
end_function

end_unit

