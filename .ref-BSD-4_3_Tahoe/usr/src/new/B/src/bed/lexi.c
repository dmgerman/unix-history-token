begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: lexi.c,v 2.4 84/10/26 12:01:34 guido Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Lexical elements (identifiers, keywords, numbers etc.)  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_comment
comment|/*  * Table defining lexical elements.  *  * ********** Indexed by (symbol-LEXICAL).  */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|lowercase
index|[]
init|=
literal|"0123456789'\"abcdefghijklmnopqrstuvwxyz"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|uppercase
index|[]
init|=
literal|"0123456789'\"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|digits
index|[]
init|=
literal|"0123456789"
decl_stmt|;
end_decl_stmt

begin_macro
name|Hidden
end_macro

begin_struct
struct|struct
block|{
name|string
name|l_start
decl_stmt|;
name|string
name|l_continue
decl_stmt|;
block|}
name|chclass
index|[]
init|=
block|{
block|{
name|lowercase
operator|+
literal|12
block|,
name|lowercase
block|,}
block|,
comment|/* IDENT */
block|{
name|uppercase
operator|+
literal|12
block|,
name|uppercase
block|,}
block|,
comment|/* KEYWORD */
block|{
name|digits
block|,
name|digits
block|,}
block|,
comment|/* NUMBER */
block|{
literal|"\\"
block|,
literal|"^"
block|,}
block|,
comment|/* COMMENT */
block|{
literal|"^`'"
block|,
literal|"^`'"
block|,}
block|,
comment|/* TEXT1 */
block|{
literal|"^`\""
block|,
literal|"^`\""
block|,}
block|,
comment|/* TEXT2 */
block|{
literal|".+-*/#^~@|<=>"
block|,
literal|""
block|,}
block|,
comment|/* OPERATORS */
block|{
literal|"^"
block|,
literal|"^"
block|,}
block|,
comment|/* RAW_INPUT */
block|{
literal|""
block|,
literal|""
block|,}
block|,
comment|/* SUGGESTION (dummy) */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NCHCLASS
value|(sizeof(chclass)/sizeof(chclass[0]))
end_define

begin_comment
comment|/*  * Test whether character `c' may start a lexical element with  * symbolic name `lex'.  */
end_comment

begin_function
name|Visible
name|bool
name|maystart
parameter_list|(
name|c
parameter_list|,
name|lex
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|lex
decl_stmt|;
block|{
name|string
name|cp
decl_stmt|;
name|lex
operator|-=
name|LEXICAL
expr_stmt|;
name|Assert
argument_list|(
name|lex
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex
operator|>=
name|NCHCLASS
operator|||
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|!=
literal|' '
operator|&&
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|No
return|;
name|cp
operator|=
name|chclass
index|[
name|lex
index|]
operator|.
name|l_start
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'^'
condition|)
return|return
operator|!
name|index
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|c
argument_list|)
return|;
return|return
name|index
argument_list|(
name|cp
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether character `c' may continue a lexical element with  * symbolic name `lex'.  */
end_comment

begin_function
name|Visible
name|bool
name|maycontinue
parameter_list|(
name|c
parameter_list|,
name|lex
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|lex
decl_stmt|;
block|{
name|string
name|cp
decl_stmt|;
name|lex
operator|-=
name|LEXICAL
expr_stmt|;
name|Assert
argument_list|(
name|lex
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex
operator|>=
name|NCHCLASS
operator|||
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|!=
literal|' '
operator|&&
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|No
return|;
name|cp
operator|=
name|chclass
index|[
name|lex
index|]
operator|.
name|l_continue
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'^'
condition|)
return|return
operator|!
name|index
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|c
argument_list|)
return|;
return|return
name|index
argument_list|(
name|cp
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

end_unit

