begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: unix.c,v 2.6 85/08/22 16:09:38 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- UNIX interface, i.e. signal and tty fiddling.  */
end_comment

begin_comment
comment|/* #define BADTABSTOPS /* Obsolete -- "b" doesn't set the tabs any more */
end_comment

begin_comment
comment|/* Defined if (soft) tabs may have been placed at strange positions. */
end_comment

begin_comment
comment|/* Actually this has only effect if curses(3) is used. 	   However this source file doesn't #include "curses.h" so we can't 	   check for that, and will assume curses(3) is always used. 	   For very slow baudrates when curses(3) is used, it may prove useful 	   to undefine BADTABSTOPS.  The "b" shell script must then be modified 	   to keep the tabs at the UNIX 8 space apart default. */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_comment
comment|/* Only for definitions like bool, string, Hidden etc. */
end_comment

begin_include
include|#
directive|include
file|"unix.h"
end_include

begin_comment
comment|/* What kind of UNIX is this? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNAL
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
endif|SIGNAL
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY_H
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
endif|SGTTY_H
end_endif

begin_decl_stmt
specifier|extern
name|bool
name|slowterminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set for speeds<= 600 baud */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|hushbaby
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if no bells are to be heard */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging mode */
end_comment

begin_define
define|#
directive|define
name|COPYSAVEFILE
value|".Bed_buf"
end_define

begin_decl_stmt
name|Visible
name|char
name|copysavefile
index|[
literal|200
index|]
init|=
name|COPYSAVEFILE
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Ctl
parameter_list|(
name|x
parameter_list|)
value|('x'&037)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|QUITCHAR
end_ifndef

begin_define
define|#
directive|define
name|QUITCHAR
value|Ctl(\\)
end_define

begin_endif
endif|#
directive|endif
endif|QUITCHAR
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INTRCHAR
end_ifndef

begin_define
define|#
directive|define
name|INTRCHAR
value|Ctl(])
end_define

begin_endif
endif|#
directive|endif
endif|INTRCHAR
end_endif

begin_define
define|#
directive|define
name|REDRAW
value|Ctl(L)
end_define

begin_comment
comment|/* From "keys.h" */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNAL
end_ifdef

begin_comment
comment|/*  * Call exit code when signal arrives, then resend the signal.  */
end_comment

begin_macro
name|catch
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Caught signal %d \n\r"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGQUIT
condition|)
block|{
comment|/* QUIT only resets terminal modes */
name|endterm
argument_list|()
expr_stmt|;
name|endunix
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|NDEBUG
name|endall
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BTOP
name|termchild
argument_list|()
expr_stmt|;
comment|/* Kill possible child, but don't wait for it */
endif|#
directive|endif
endif|BTOP
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|SIGNAL
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/* I.e., only on BSD systems with job control. */
end_comment

begin_comment
comment|/*  * Reset tty modes etc. when STOP signal arrives (control-Z).  * This is like interrupt but the program may continue later  * so we must not do all exit code).  *  * In order that the code works for 4.1 and 4.2 BSD Unix (V7 and sys III/V  * don't have the SIGTSTP signal at all, so there wo don't bother), we use  * neither the awkward "-ljobs" mechanism nor the nicer but (yet!) even  * less portable sigmask/sigblock system calls.  Rather, to kill ourselves  * again after the screen and tty modes have been restored, we use another  * signal, i.e., SIGSTOP (which is uncatchable).  *  * Note! Since curses' initscr() also executes signal(SIGTSTP, tstp),  * and initscr() is called after initunix(), the name of this routine  * must be tstp, overriding a routine of the same name in the curses  * library which does not do what we want.  */
end_comment

begin_macro
name|tstp
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
function_decl|(
modifier|*
name|prevttousig
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
comment|/* Ignore SIGTTOU so stty calls won't stop us again! */
name|char
name|cread
init|=
name|REDRAW
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Caught stop signal %d \n\r"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|endterm
argument_list|()
expr_stmt|;
name|unfixttymodes
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|prevttousig
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
comment|/* Hard stop */
comment|/* 	 * A stop signal made us go to sleep in Tumbolia. 	 * When we awake, we continue at this point. 	 * The world may well have changed a little bit, 	 * so do the tty initializations anew. 	 */
name|fixttymodes
argument_list|()
expr_stmt|;
name|initterm
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSTI
comment|/* Simulate receipt of REDRAW initially so we come up 	   with a nice display. */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSTI
argument_list|,
operator|&
name|cread
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TIOCSTI
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|SIGTSTP
end_endif

begin_comment
comment|/*  * Prepare for interrupts (UNIX `signals') to be caught so  * we can reset the tty modes and perform miscellaneous other  * exit routines.  * Note -- if a signal arrives before the call to fixttymodes,  * the unfixttymodes may render the terminal useless.  The fix is  * easy, but I'm too lazy now (just read the statuses BEFORE,  * but change them only AFTER signal setting).  */
end_comment

begin_macro
name|initunix
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGNAL
specifier|register
name|int
name|i
decl_stmt|;
endif|#
directive|endif
endif|SIGNAL
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** initunix();\n\r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
ifdef|#
directive|ifdef
name|SIGNAL
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSIG
condition|;
operator|++
name|i
control|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|i
operator|==
name|SIGQUIT
condition|)
continue|continue;
endif|#
directive|endif
endif|NDEBUG
ifdef|#
directive|ifdef
name|SIGCONT
if|if
condition|(
name|i
operator|==
name|SIGCONT
condition|)
continue|continue;
endif|#
directive|endif
endif|SIGCONT
ifdef|#
directive|ifdef
name|SIGCHLD
if|if
condition|(
name|i
operator|==
name|SIGCHLD
condition|)
continue|continue;
endif|#
directive|endif
endif|SIGCHLD
if|if
condition|(
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|i
argument_list|,
name|catch
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Catching signal %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
block|}
block|}
comment|/* Stop/continue must be handled differently, see stop() above. */
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGTSTP
endif|#
directive|endif
endif|SIGNAL
ifdef|#
directive|ifdef
name|SGTTY_H
name|fixttymodes
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|SGTTY_H
name|setcopybuffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The last termination routine to be called.  * It also resets all signals to their default status.  */
end_comment

begin_macro
name|endunix
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGNAL
name|int
name|i
decl_stmt|;
endif|#
directive|endif
endif|SIGNAL
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** endunix();\n\r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
ifdef|#
directive|ifdef
name|SGTTY_H
name|unfixttymodes
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|SGTTY_H
ifdef|#
directive|ifdef
name|SIGNAL
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSIG
condition|;
operator|++
name|i
control|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGNAL
block|}
end_block

begin_comment
comment|/*  * Determine the name of the file where the copy buffer is saved.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|setcopybuffer
parameter_list|()
block|{
name|string
name|home
init|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|home
condition|)
name|sprintf
argument_list|(
name|copysavefile
argument_list|,
literal|"%.150s/%.40s"
argument_list|,
name|home
argument_list|,
name|COPYSAVEFILE
argument_list|)
expr_stmt|;
comment|/* Else, retain default initialization! */
block|}
end_function

begin_comment
comment|/*  * Return a string like the one that perror(arg) would print  * (see UNIX manual page perror(3) for details).  * Like all C library routines returning strings, the string points  * to static storage that is overwritten on each call.  * If arg is fairly long, it may get truncated.  */
end_comment

begin_function
name|string
name|unixerror
parameter_list|(
name|arg
parameter_list|)
name|string
name|arg
decl_stmt|;
block|{
specifier|static
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PERROR
specifier|extern
name|int
name|sys_nerr
decl_stmt|,
name|errno
decl_stmt|;
specifier|extern
name|string
name|sys_errlist
index|[]
decl_stmt|;
if|if
condition|(
name|errno
operator|>
literal|0
operator|&&
name|errno
operator|<
name|sys_nerr
condition|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%.80s: %.80s"
argument_list|,
name|arg
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%.80s: UNIX error %d"
argument_list|,
name|arg
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|#
directive|else
else|!PERROR
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%.68s: I/O error"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!PERROR
name|msg
index|[
literal|80
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY_H
end_ifdef

begin_comment
comment|/*  * Hacks to fix certain peculiarities due to the hostile environment  * in which the editor lives.  */
end_comment

begin_decl_stmt
name|Hidden
name|struct
name|sgttyb
name|oldtty
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSETC
end_ifdef

begin_decl_stmt
name|Hidden
name|struct
name|tchars
name|oldtchars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSLTC
end_ifdef

begin_decl_stmt
name|Hidden
name|struct
name|ltchars
name|oldltchars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Hidden
name|Procedure
name|fixttymodes
parameter_list|()
block|{
name|gtty
argument_list|(
literal|2
argument_list|,
operator|&
name|oldtty
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtty
operator|.
name|sg_ospeed
operator|<=
name|B600
condition|)
name|slowterminal
operator|=
name|Yes
expr_stmt|;
ifdef|#
directive|ifdef
name|BADTABSTOPS
comment|/* 	 * Turn on XTABS mode, to be able to live when terminal tabs are 	 * set at 4 rather than 8 columns (the B interpreter used to set 	 * this). 	 */
if|if
condition|(
operator|!
operator|(
name|oldtty
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
condition|)
block|{
name|struct
name|sgttyb
name|newtty
decl_stmt|;
name|gtty
argument_list|(
literal|2
argument_list|,
operator|&
name|newtty
argument_list|)
expr_stmt|;
name|newtty
operator|.
name|sg_flags
operator||=
name|XTABS
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|newtty
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|BADTABSTOPS
ifdef|#
directive|ifdef
name|TIOCSETC
comment|/* I.e., not at pre-version 7 UNIX systems */
comment|/* 	 * Set the quit character to ^\ and the interrupt at DEL. 	 * The start/stop characters are kept only if they are ^S/^Q. 	 */
block|{
name|struct
name|tchars
name|newtchars
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|oldtchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|newtchars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newtchars
operator|.
name|t_intrc
operator|&
literal|0377
operator|)
operator|!=
literal|0377
operator|&&
name|newtchars
operator|.
name|t_intrc
operator|!=
literal|0177
comment|/*DEL*/
condition|)
name|newtchars
operator|.
name|t_intrc
operator|=
name|INTRCHAR
expr_stmt|;
if|if
condition|(
operator|(
name|newtchars
operator|.
name|t_quitc
operator|&
literal|0377
operator|)
operator|!=
literal|0377
condition|)
name|newtchars
operator|.
name|t_quitc
operator|=
name|QUITCHAR
expr_stmt|;
if|if
condition|(
name|newtchars
operator|.
name|t_startc
operator|!=
name|Ctl
argument_list|(
name|Q
argument_list|)
condition|)
name|newtchars
operator|.
name|t_startc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newtchars
operator|.
name|t_stopc
operator|!=
name|Ctl
argument_list|(
name|S
argument_list|)
condition|)
name|newtchars
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|newtchars
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|TIOCSETC
ifdef|#
directive|ifdef
name|TIOCSLTC
comment|/* I.e., at 4.xBSD systems */
comment|/* 	 * Turn off all local control characters except keep stop (^Z) and delayed 	 * stop (^Y) when these are the originals. 	 */
block|{
specifier|static
name|struct
name|ltchars
name|newltchars
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|oldltchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldltchars
operator|.
name|t_suspc
operator|==
name|Ctl
argument_list|(
name|Z
argument_list|)
condition|)
name|newltchars
operator|.
name|t_dsuspc
operator|=
name|Ctl
argument_list|(
name|Z
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|newltchars
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Undo the effects of fixttymodes(), see comments there.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|unfixttymodes
parameter_list|()
block|{
if|if
condition|(
operator|!
name|oldtty
operator|.
name|sg_ospeed
condition|)
return|return;
comment|/* Not yet initialized! */
ifdef|#
directive|ifdef
name|BADTABSTOPS
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|oldtty
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSETC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|oldtchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|oldltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SGTTY_H
end_endif

begin_comment
comment|/*  * Return Yes if more input immediately available  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_function
name|Visible
name|bool
name|moreinput
parameter_list|()
block|{
return|return
name|kbhit
argument_list|()
return|;
block|}
end_function

begin_else
else|#
directive|else
else|!IBMPC
end_else

begin_comment
comment|/*  * ***** UNIX DEPENDENCE *****  * Assumes the standard UNIX definition of FILE: assumes there is  * buffered input if stdin->_cnt> 0, so uses the `_cnt' field.  *  * ***** 4.2 BSD DEPENDENCE *****  * If the symbol SIGNAL is defined, uses the select() system call to determine  * whether more input is available; see select(2) in 4.2 BSD manual.  *  * ***** 4.1 BSD DEPENDENCE *****  * If the symbol FIONREAD is defined, uses the correponding ioctl call to  * determine whether more input is available; see tty(4) in 4.1 BSD manual.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SELECT
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
endif|SELECT
end_endif

begin_function
name|Visible
name|bool
name|moreinput
parameter_list|()
block|{
if|if
condition|(
name|stdin
operator|->
name|_cnt
operator|>
literal|0
condition|)
return|return
name|Yes
return|;
ifdef|#
directive|ifdef
name|SELECT
block|{
name|int
name|readfds
decl_stmt|;
name|int
name|nfds
decl_stmt|;
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|readfds
operator|=
literal|1
operator|<<
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|nfds
operator|=
literal|1
operator|+
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|nfds
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
name|fputc
argument_list|(
literal|'\07'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
else|#
directive|else
else|SELECT
ifdef|#
directive|ifdef
name|FIONREAD
block|{
name|long
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|n
operator|>
literal|0
condition|)
return|return
name|Yes
return|;
block|}
endif|#
directive|endif
endif|FIONREAD
endif|#
directive|endif
endif|SELECT
return|return
name|No
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|!IBMPC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SETENV
end_ifdef

begin_comment
comment|/*  * Routine to add or change an environment variable.  * (No longer used.)  */
end_comment

begin_decl_stmt
specifier|extern
name|string
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_macro
name|setenv
argument_list|(
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|string
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|string
name|equals
init|=
name|index
argument_list|(
name|entry
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|string
modifier|*
name|ep
decl_stmt|;
specifier|static
name|string
modifier|*
name|myenviron
decl_stmt|;
if|if
condition|(
operator|!
name|equals
condition|)
name|syserr
argument_list|(
literal|"setenv: no = sign"
argument_list|)
expr_stmt|;
name|len
operator|=
name|equals
operator|-
name|entry
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|environ
init|;
operator|*
name|ep
operator|&&
operator|!
name|Strnequ
argument_list|(
operator|*
name|ep
argument_list|,
name|entry
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|;
operator|++
name|ep
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
block|{
operator|*
name|ep
operator|=
name|entry
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|ep
operator|-
name|environ
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|myenviron
condition|)
block|{
name|myenviron
operator|=
operator|(
name|string
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|string
operator|)
name|myenviron
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myenviron
condition|)
name|syserr
argument_list|(
literal|"setenv: realloc"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|myenviron
operator|=
operator|(
name|string
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myenviron
condition|)
name|syserr
argument_list|(
literal|"setenv: malloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|environ
init|;
operator|*
name|ep
condition|;
operator|++
name|ep
control|)
name|myenviron
index|[
name|ep
operator|-
name|environ
index|]
operator|=
operator|*
name|ep
expr_stmt|;
block|}
name|myenviron
index|[
name|len
operator|-
literal|1
index|]
operator|=
operator|(
name|string
operator|)
name|NULL
expr_stmt|;
name|myenviron
index|[
name|len
operator|-
literal|2
index|]
operator|=
name|entry
expr_stmt|;
name|environ
operator|=
name|myenviron
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|SETENV
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PWB
end_ifdef

begin_comment
comment|/*  * Substitute getenv routine - there is no environment on PWB systems,  * but as a substitute (not te be encouraged!) we allow a file with the  * name of the environment variable to contain the desired value;  * e.g. the file "TERM" may contain a line saying hp2621 or hp etc.  */
end_comment

begin_function
name|Visible
name|string
name|getenv
parameter_list|(
name|name
parameter_list|)
name|string
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|string
name|cp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|PWB
end_endif

end_unit

