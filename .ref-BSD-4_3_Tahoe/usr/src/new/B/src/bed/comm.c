begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: comm.c,v 2.4 85/08/22 16:00:49 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Communication with B interpreter.  */
end_comment

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BTOP
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"supr.h"
end_include

begin_include
include|#
directive|include
file|"unix.h"
end_include

begin_include
include|#
directive|include
file|"cell.h"
end_include

begin_comment
comment|/* For winheight */
end_comment

begin_define
define|#
directive|define
name|TABS
value|8
end_define

begin_function_decl
name|string
name|unixerror
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Communication to other modules (demo, getc, ...):  */
end_comment

begin_decl_stmt
name|Visible
name|bool
name|interrupted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when interrupt caught but not propagated */
end_comment

begin_decl_stmt
name|Visible
name|bool
name|canjump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when disrupt() can safely longjmp(jumpback) */
end_comment

begin_decl_stmt
name|Visible
name|jmp_buf
name|jumpback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by other module where to jump */
end_comment

begin_comment
comment|/*  * Pipeline protocol with interpreter:  */
end_comment

begin_define
define|#
directive|define
name|ESCAPE
value|'\001'
end_define

begin_comment
comment|/* Character signalling special function */
end_comment

begin_define
define|#
directive|define
name|RESYNC
value|'\177'
end_define

begin_comment
comment|/* Character signalling acknowledge of interrupt */
end_comment

begin_define
define|#
directive|define
name|INTRCHILD
value|SIGTRAP
end_define

begin_comment
comment|/* Signal to send as interrupt */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTERPRETER
end_ifndef

begin_define
define|#
directive|define
name|INTERPRETER
value|"/usr/new/lib/B/bint"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local definitions:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTRMSG
end_ifndef

begin_define
define|#
directive|define
name|INTRMSG
value|"*** Interrupted"
end_define

begin_comment
comment|/* Acknowledges interrupt */
end_comment

begin_endif
endif|#
directive|endif
endif|INTRMSG
end_endif

begin_define
define|#
directive|define
name|Moreinput
parameter_list|(
name|stream
parameter_list|)
value|((stream)->_cnt> 0)
end_define

begin_decl_stmt
name|Hidden
name|int
name|fdown
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptors for pipe down */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|fup
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pipe up */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process id of child */
end_comment

begin_decl_stmt
name|Hidden
name|FILE
modifier|*
name|pdown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FILE pointer for pipe down to child process */
end_comment

begin_decl_stmt
name|Hidden
name|FILE
modifier|*
name|pup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pipe up */
end_comment

begin_decl_stmt
name|Hidden
name|string
name|interpreter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of interpreter to be used */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|pushback
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Limited pushback facility */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|npushback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters pushed back */
end_comment

begin_comment
comment|/*  * Routine to set canjump, do a getc, and clear canjump.  */
end_comment

begin_function
name|Visible
name|int
name|ffgetc
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|canjump
operator|=
name|Yes
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|canjump
operator|=
name|No
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Similar for fgets.  */
end_comment

begin_function
name|Visible
name|string
name|ffgets
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|)
name|string
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|canjump
operator|=
name|Yes
expr_stmt|;
name|buf
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|canjump
operator|=
name|No
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Assign values to `fdown' and `fup'.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|getdevices
parameter_list|()
block|{
if|if
condition|(
name|pipe
argument_list|(
name|fdown
argument_list|)
operator|<
literal|0
operator|||
name|pipe
argument_list|(
name|fup
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"%s"
argument_list|,
name|unixerror
argument_list|(
literal|"can't pipe"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the magic required for child-birth.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|makechild
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|VFORK
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
else|VFORK
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|VFORK
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"%s"
argument_list|,
name|unixerror
argument_list|(
literal|"can't fork"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* Child */
name|exec_b
argument_list|()
expr_stmt|;
comment|/* Does not return */
comment|/* Parent */
name|close
argument_list|(
name|fdown
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Code executed in the child process.  Never returns.  * Just dup the pipe ends to files 0, a and 2 (stdin, stdout and stderr),  * then close the original pipes.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|exec_b
parameter_list|()
block|{
name|close
argument_list|(
name|fdown
index|[
literal|1
index|]
argument_list|)
operator|,
name|close
argument_list|(
name|fup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
operator|,
name|close
argument_list|(
literal|1
argument_list|)
operator|,
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|fdown
index|[
literal|0
index|]
argument_list|)
operator|,
name|dup
argument_list|(
name|fup
index|[
literal|1
index|]
argument_list|)
operator|,
name|dup
argument_list|(
name|fup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fdown
index|[
literal|0
index|]
argument_list|)
operator|,
name|close
argument_list|(
name|fup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|interpreter
argument_list|,
name|interpreter
argument_list|,
literal|"-i"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|interpreter
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  * Usually only the flag `interrupted' is set.  *  * When `canjump' is on, it is cleared and we do a longjmp  * back to where jumpbuf leads us (usually done when a read  * system call is interrupted, as 4.2BSD tends to continue  * these rather than have them return with errno = EINTR).  */
end_comment

begin_function
name|Hidden
name|Procedure
name|disrupt
parameter_list|()
block|{
name|interrupted
operator|=
name|Yes
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|disrupt
argument_list|)
expr_stmt|;
if|if
condition|(
name|canjump
condition|)
block|{
name|canjump
operator|=
name|No
expr_stmt|;
name|longjmp
argument_list|(
name|jumpback
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start the B interpreter as a subprocess.  * Set up communication pipes in pdown, pup.  */
end_comment

begin_function
name|Visible
name|Procedure
name|start_b
parameter_list|(
name|ppdown
parameter_list|,
name|ppup
parameter_list|)
name|FILE
modifier|*
modifier|*
name|ppdown
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|ppup
decl_stmt|;
block|{
name|interpreter
operator|=
name|getenv
argument_list|(
literal|"B_INTERPRETER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interpreter
condition|)
name|interpreter
operator|=
name|INTERPRETER
expr_stmt|;
name|getdevices
argument_list|()
expr_stmt|;
name|makechild
argument_list|()
expr_stmt|;
name|pdown
operator|=
name|fdopen
argument_list|(
name|fdown
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|pup
operator|=
name|fdopen
argument_list|(
name|fup
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pdown
operator|||
operator|!
name|pup
condition|)
name|syserr
argument_list|(
literal|"%s"
argument_list|,
name|unixerror
argument_list|(
literal|"can't fdopen"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ppdown
operator|=
name|pdown
expr_stmt|;
operator|*
name|ppup
operator|=
name|pup
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|disrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to be called after each line of data has been passed  * to the B interpreter; it checks whether the immediate next  * output is a request for an immediate command, and if so,  * eats the request and returns Yes.  Otherwise it pushes back the  * request for later processing by sleur(), and returns No.  * ***** The prompt parameter is a relict of old times. *****  */
end_comment

begin_function
name|Visible
name|bool
name|expect
parameter_list|(
name|prompt
parameter_list|)
name|string
name|prompt
decl_stmt|;
comment|/* Only first char used; should be ">" */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|fflush
argument_list|(
name|pdown
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jumpback
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|npushback
condition|)
name|c
operator|=
name|pushback
index|[
operator|--
name|npushback
index|]
expr_stmt|;
else|else
name|c
operator|=
name|ffgetc
argument_list|(
name|pup
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ESCAPE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|pushback
index|[
name|npushback
operator|++
index|]
operator|=
name|c
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
name|npushback
condition|)
name|c
operator|=
name|pushback
index|[
operator|--
name|npushback
index|]
expr_stmt|;
else|else
name|c
operator|=
name|ffgetc
argument_list|(
name|pup
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|prompt
condition|)
return|return
name|Yes
return|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|pushback
index|[
name|npushback
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|pushback
index|[
name|npushback
operator|++
index|]
operator|=
name|ESCAPE
expr_stmt|;
return|return
name|No
return|;
block|}
end_function

begin_function
name|Visible
name|int
name|sleur
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|x
init|=
literal|0
decl_stmt|;
name|bool
name|show
init|=
name|Yes
decl_stmt|;
comment|/* No when looking for interrupt sync char */
name|bool
name|idle
init|=
name|Yes
decl_stmt|;
comment|/* Yes when no output done yet this call */
name|fflush
argument_list|(
name|pdown
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|interrupted
operator|=
name|No
expr_stmt|;
name|intrchild
argument_list|()
expr_stmt|;
name|show
operator|=
name|No
expr_stmt|;
block|}
if|if
condition|(
name|show
operator|&&
name|npushback
operator|==
literal|0
operator|&&
operator|!
name|Moreinput
argument_list|(
name|pup
argument_list|)
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jumpback
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|npushback
operator|>
literal|0
condition|)
name|c
operator|=
name|pushback
index|[
operator|--
name|npushback
index|]
expr_stmt|;
else|else
name|c
operator|=
name|ffgetc
argument_list|(
name|pup
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* End-of-file: B interpreter has terminated. */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|c
operator|==
name|RESYNC
condition|)
block|{
comment|/* B interpreter acknowledges interrupt. */
if|if
condition|(
operator|!
name|show
condition|)
block|{
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|INTRMSG
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|show
operator|=
name|Yes
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|show
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|ESCAPE
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|x
operator|=
operator|(
name|x
operator|/
name|TABS
operator|+
literal|1
operator|)
operator|*
name|TABS
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|x
operator|>
literal|0
condition|)
operator|--
name|x
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|x
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|' '
condition|)
operator|++
name|x
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Control-A: B interpreter needs input. */
if|if
condition|(
name|setjmp
argument_list|(
name|jumpback
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|npushback
condition|)
name|c
operator|=
name|pushback
index|[
operator|--
name|npushback
index|]
expr_stmt|;
else|else
block|{
name|c
operator|=
name|ffgetc
argument_list|(
name|pup
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
return|return
name|EOF
return|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
comment|/* Newline before command prompt */
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
name|setindent
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send the child a termination signal (SIGTERM).  */
end_comment

begin_function
name|Visible
name|Procedure
name|termchild
parameter_list|()
block|{
if|if
condition|(
name|pid
condition|)
block|{
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send the child an interrupt signal.  (By convention, this is SIGTRAP).  */
end_comment

begin_function
name|Visible
name|Procedure
name|intrchild
parameter_list|()
block|{
if|if
condition|(
name|pid
condition|)
block|{
name|kill
argument_list|(
name|pid
argument_list|,
name|INTRCHILD
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for child process and report abnormal exit statuses.  */
end_comment

begin_function
name|Visible
name|Procedure
name|waitchild
parameter_list|()
block|{
name|int
name|k
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
while|while
condition|(
operator|(
name|k
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|k
operator|!=
name|pid
condition|)
ifndef|#
directive|ifndef
name|SMALLSYS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** [Pid %d status 0%o]\n"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
endif|#
directive|endif
endif|SMALLSYS
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|SMALLSYS
if|if
condition|(
name|status
operator|&
literal|0377
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Interpreter killed by signal %d%s\n"
argument_list|,
name|status
operator|&
literal|0177
argument_list|,
name|status
operator|&
literal|0200
condition|?
literal|" - core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Interpreter exit(%d)\n"
argument_list|,
name|status
operator|>>
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SMALLSYS
name|pid
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|SMALLSYS
if|if
condition|(
name|pid
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't get interpreter status\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SMALLSYS
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|BTOP
end_endif

end_unit

