begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: que2.c,v 2.3 84/07/23 13:02:38 guido Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Manipulate queues of nodes, higher levels.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"supr.h"
end_include

begin_include
include|#
directive|include
file|"queu.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"tabl.h"
end_include

begin_decl_stmt
specifier|extern
name|bool
name|lefttorite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by edit() to signal we parse purely left-to-right */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug mode even if NDEBUG on */
end_comment

begin_comment
comment|/*  * Insert a queue of nodes at the focus  * (which had better be some kind of a hole).  * The nodes may also be a text, in which case the individual characters  * are inserted.  * Extensive changes to the parse tree may occur, and the node may be  * broken up in its constituent parts (texts and other nodes) which  * are then inserted individually.  */
end_comment

begin_function
name|Visible
name|bool
name|ins_queue
parameter_list|(
name|ep
parameter_list|,
name|pq
parameter_list|,
name|pq2
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
specifier|register
name|queue
modifier|*
name|pq
decl_stmt|;
specifier|register
name|queue
modifier|*
name|pq2
decl_stmt|;
block|{
specifier|register
name|bool
name|ok
init|=
name|Yes
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
specifier|register
name|queue
name|oldq2
decl_stmt|;
name|environ
name|saveenv
decl_stmt|;
name|int
name|oldindentation
init|=
name|focindent
argument_list|(
name|ep
argument_list|)
decl_stmt|;
name|int
name|indentation
init|=
name|oldindentation
decl_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
while|while
condition|(
name|ok
operator|&&
operator|!
name|emptyqueue
argument_list|(
operator|*
name|pq
argument_list|)
condition|)
block|{
name|n
operator|=
name|queuebehead
argument_list|(
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|)
block|{
name|ok
operator|=
name|ins_string
argument_list|(
name|ep
argument_list|,
name|Str
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
argument_list|,
name|pq2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Str
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
index|[
name|Length
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
comment|/* Last char */
case|case
literal|'\t'
case|:
operator|++
name|indentation
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
operator|--
name|indentation
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
while|while
condition|(
name|focindent
argument_list|(
name|ep
argument_list|)
operator|>
name|indentation
condition|)
block|{
if|if
condition|(
operator|!
name|ins_newline
argument_list|(
name|ep
argument_list|)
condition|)
break|break;
block|}
break|break;
block|}
block|}
else|else
block|{
name|Ecopy
argument_list|(
operator|*
name|ep
argument_list|,
name|saveenv
argument_list|)
expr_stmt|;
name|oldq2
operator|=
name|qcopy
argument_list|(
operator|*
name|pq2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ins_node
argument_list|(
operator|&
name|saveenv
argument_list|,
name|n
argument_list|,
name|pq2
argument_list|)
condition|)
block|{
name|Erelease
argument_list|(
name|saveenv
argument_list|)
expr_stmt|;
name|qrelease
argument_list|(
operator|*
name|pq2
argument_list|)
expr_stmt|;
operator|*
name|pq2
operator|=
name|oldq2
expr_stmt|;
if|if
condition|(
name|symbol
argument_list|(
name|n
argument_list|)
operator|==
name|Hole
condition|)
name|ok
operator|=
name|ins_string
argument_list|(
name|ep
argument_list|,
literal|"?"
argument_list|,
name|pq2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|splitnode
argument_list|(
name|n
argument_list|,
name|pq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Erelease
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
name|Emove
argument_list|(
name|saveenv
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
name|qrelease
argument_list|(
name|oldq2
argument_list|)
expr_stmt|;
block|}
block|}
name|noderelease
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|qshow
argument_list|(
operator|*
name|pq
argument_list|,
literal|"ins_queue"
argument_list|)
expr_stmt|;
name|qrelease
argument_list|(
operator|*
name|pq
argument_list|)
expr_stmt|;
for|for
control|(
name|indentation
operator|=
name|focindent
argument_list|(
name|ep
argument_list|)
init|;
name|indentation
operator|>
name|oldindentation
condition|;
operator|--
name|indentation
control|)
name|stringtoqueue
argument_list|(
literal|"\b"
argument_list|,
name|pq2
argument_list|)
expr_stmt|;
comment|/* Pass on indentation to outer level */
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/*  * Subroutine to insert a queue to the right of the focus  * without affecting the focus position.  */
end_comment

begin_function
name|Visible
name|bool
name|app_queue
parameter_list|(
name|ep
parameter_list|,
name|pq
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
name|queue
modifier|*
name|pq
decl_stmt|;
block|{
name|int
name|where
decl_stmt|;
specifier|static
name|int
name|markbit
init|=
literal|1
decl_stmt|;
comment|/* To properly handle recursive calls */
if|if
condition|(
name|emptyqueue
argument_list|(
operator|*
name|pq
argument_list|)
condition|)
return|return
name|Yes
return|;
name|where
operator|=
name|focoffset
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|markbit
operator|<<=
literal|1
expr_stmt|;
name|markpath
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|markbit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ins_queue
argument_list|(
name|ep
argument_list|,
name|pq
argument_list|,
name|pq
argument_list|)
condition|)
block|{
name|markbit
operator|>>=
literal|1
expr_stmt|;
return|return
name|No
return|;
block|}
name|firstmarked
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|markbit
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
name|unmkpath
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|markbit
argument_list|)
expr_stmt|;
name|markbit
operator|>>=
literal|1
expr_stmt|;
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
name|fixfocus
argument_list|(
name|ep
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Advance to next thing after current position.  */
end_comment

begin_function
name|Visible
name|bool
name|move_on
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|node
name|n
decl_stmt|;
specifier|register
name|string
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|sym
decl_stmt|;
specifier|register
name|int
name|ich
init|=
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|up
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
return|return
name|No
return|;
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|n
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fw_positive
argument_list|(
name|rp
index|[
name|ich
index|]
argument_list|)
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|FHOLE
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
literal|2
operator|*
name|ich
operator|+
literal|1
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|spflag
condition|)
block|{
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|rp
index|[
name|ich
index|]
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
operator|++
name|ep
operator|->
name|s2
expr_stmt|;
if|if
condition|(
name|fwidth
argument_list|(
name|rp
index|[
name|ich
index|]
argument_list|)
operator|>
literal|1
condition|)
return|return
name|Yes
return|;
block|}
else|else
return|return
name|Yes
return|;
block|}
else|else
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|ich
operator|<
name|nchildren
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|s_downi
argument_list|(
name|ep
argument_list|,
name|ich
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|Hole
operator|||
name|sym
operator|==
name|Optional
condition|)
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
else|else
name|ep
operator|->
name|mode
operator|=
name|ATBEGIN
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Like move_on but moves through fixed texts, skipping only spaces  * and empty strings.  *<<<<< This code is a dinosaur and should be revised.>>>>>  */
end_comment

begin_function
name|Visible
name|bool
name|fix_move
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|ich
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|string
modifier|*
name|rp
decl_stmt|;
specifier|register
name|string
name|cp
decl_stmt|;
name|Assert
argument_list|(
name|ep
operator|->
name|mode
operator|==
name|FHOLE
argument_list|)
expr_stmt|;
name|ich
operator|=
name|ep
operator|->
name|s1
operator|/
literal|2
expr_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rp
index|[
name|ich
index|]
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|i
operator|=
name|ep
operator|->
name|s2
expr_stmt|;
name|Assert
argument_list|(
name|i
operator|<=
name|Fwidth
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
do|do
block|{
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|cp
index|[
name|i
index|]
operator|==
literal|' '
condition|)
do|;
block|}
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|==
literal|'\b'
operator|||
name|cp
index|[
name|i
index|]
operator|==
literal|'\t'
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|Assert
argument_list|(
operator|!
name|cp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|ep
operator|->
name|s2
condition|)
return|return
name|No
return|;
name|ep
operator|->
name|s2
operator|=
name|i
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
if|if
condition|(
name|ich
operator|>=
name|nchildren
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
condition|)
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
else|else
block|{
name|s_downi
argument_list|(
name|ep
argument_list|,
name|ich
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
operator|==
name|Hole
operator|||
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
operator|==
name|Optional
condition|)
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
else|else
name|ep
operator|->
name|mode
operator|=
name|ATBEGIN
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a node in the parse tree.  */
end_comment

begin_function
name|Hidden
name|bool
name|ins_node
parameter_list|(
name|ep
parameter_list|,
name|n
parameter_list|,
name|pq
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
specifier|register
name|queue
modifier|*
name|pq
decl_stmt|;
block|{
specifier|register
name|int
name|sym
decl_stmt|;
specifier|register
name|node
name|nn
decl_stmt|;
specifier|register
name|markbits
name|x
decl_stmt|;
name|string
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|symbol
argument_list|(
name|n
argument_list|)
operator|==
name|Optional
condition|)
return|return
name|Yes
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|FHOLE
case|:
if|if
condition|(
name|ep
operator|->
name|s2
operator|<
name|lenitem
argument_list|(
name|ep
argument_list|)
operator|||
operator|!
name|fix_move
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
continue|continue;
case|case
name|VHOLE
case|:
if|if
condition|(
name|ep
operator|->
name|s2
operator|<
name|lenitem
argument_list|(
name|ep
argument_list|)
operator|||
operator|!
name|move_on
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
continue|continue;
case|case
name|ATBEGIN
case|:
name|sym
operator|=
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|Optional
operator|||
name|sym
operator|==
name|Hole
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
continue|continue;
block|}
name|x
operator|=
name|marks
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|joinnodes
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|n
argument_list|,
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|,
name|No
argument_list|)
condition|)
block|{
if|if
condition|(
name|x
condition|)
block|{
name|s_downi
argument_list|(
name|ep
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|markpath
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|s_down
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|nn
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchildren
argument_list|(
name|nn
argument_list|)
operator|>=
literal|1
operator|&&
name|Fw_zero
argument_list|(
name|rp
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|sym
operator|=
name|symbol
argument_list|(
name|firstchild
argument_list|(
name|nn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|Hole
operator|||
name|sym
operator|==
name|Optional
condition|)
block|{
name|s_down
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|fitnode
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
name|nn
operator|=
name|nodecopy
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fitnode
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|addtoqueue
argument_list|(
name|pq
argument_list|,
name|nn
argument_list|)
expr_stmt|;
name|noderelease
argument_list|(
name|nn
argument_list|)
expr_stmt|;
name|delfocus
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|downrite
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
block|{
if|if
condition|(
name|Type
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
operator|!=
name|Tex
condition|)
block|{
name|sym
operator|=
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|Hole
operator|||
name|sym
operator|==
name|Optional
condition|)
block|{
if|if
condition|(
name|fitnode
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|nn
argument_list|)
condition|)
block|{
name|noderelease
argument_list|(
name|nn
argument_list|)
expr_stmt|;
name|nn
operator|=
name|Nnil
expr_stmt|;
block|}
block|}
block|}
else|else
name|up
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nn
condition|)
block|{
name|addtoqueue
argument_list|(
name|pq
argument_list|,
name|nn
argument_list|)
expr_stmt|;
name|noderelease
argument_list|(
name|nn
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
case|case
name|WHOLE
case|:
name|sym
operator|=
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|sym
operator|==
name|Optional
operator|||
name|sym
operator|==
name|Hole
argument_list|)
expr_stmt|;
do|do
block|{
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* Only for second time around */
if|if
condition|(
name|fitnode
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
do|while
condition|(
name|resttoqueue
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|pq
argument_list|)
condition|)
do|;
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
comment|/* Fall through */
case|case
name|ATEND
case|:
do|do
block|{
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* Only for second time around */
if|if
condition|(
name|joinnodes
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|,
name|n
argument_list|,
name|ep
operator|->
name|spflag
argument_list|)
condition|)
block|{
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
do|while
condition|(
name|resttoqueue
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|pq
argument_list|)
operator|||
name|move_on
argument_list|(
name|ep
argument_list|)
operator|&&
name|ep
operator|->
name|mode
operator|==
name|ATEND
condition|)
do|;
return|return
name|No
return|;
default|default:
return|return
name|No
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Insert a string in the parse tree.  */
end_comment

begin_define
define|#
directive|define
name|NEXT
value|(++str, alt_c = 0)
end_define

begin_function
name|Visible
name|bool
name|ins_string
parameter_list|(
name|ep
parameter_list|,
name|str
parameter_list|,
name|pq
parameter_list|,
name|alt_c
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
comment|/*auto*/
name|string
name|str
decl_stmt|;
specifier|register
name|queue
modifier|*
name|pq
decl_stmt|;
name|int
name|alt_c
decl_stmt|;
block|{
specifier|register
name|node
name|nn
decl_stmt|;
specifier|auto
name|value
name|v
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|register
name|string
name|repr
decl_stmt|;
name|string
name|oldstr
decl_stmt|;
specifier|register
name|int
name|sym
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|bool
name|interactive
init|=
name|alt_c
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|alt_c
operator|<
literal|0
condition|)
name|alt_c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|ins_newline
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
comment|/* Fall through */
case|case
literal|'\t'
case|:
case|case
literal|'\b'
case|:
name|NEXT
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|ATBEGIN
case|:
name|nn
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|nn
argument_list|)
operator|==
name|Tex
condition|)
block|{
name|ep
operator|->
name|s1
operator|=
literal|2
operator|*
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|VHOLE
expr_stmt|;
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sym
operator|=
name|symbol
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|Optional
operator|&&
name|sym
operator|!=
name|Hole
condition|)
block|{
if|if
condition|(
name|fwidth
argument_list|(
name|noderepr
argument_list|(
name|nn
argument_list|)
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|down
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
break|break;
block|}
name|addtoqueue
argument_list|(
name|pq
argument_list|,
name|nn
argument_list|)
expr_stmt|;
name|delfocus
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
comment|/* Fall through */
case|case
name|WHOLE
case|:
name|nn
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol
argument_list|(
name|nn
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|sym
operator|==
name|Hole
operator|||
name|sym
operator|==
name|Optional
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|fitstring
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|str
argument_list|,
name|alt_c
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sym
operator|==
name|Optional
condition|)
block|{
if|if
condition|(
operator|!
name|move_on
argument_list|(
name|ep
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|NEXT
expr_stmt|;
else|else
return|return
name|No
return|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|interactive
operator|&&
operator|*
name|str
operator|==
literal|'?'
condition|)
block|{
name|NEXT
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|resttoqueue
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|pq
argument_list|)
condition|)
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spacefix
argument_list|(
name|ep
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
block|{
name|NEXT
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|interactive
condition|)
return|return
name|No
return|;
else|else
block|{
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|str
operator|+=
name|len
expr_stmt|;
name|alt_c
operator|=
literal|0
expr_stmt|;
name|fixfocus
argument_list|(
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ATEND
case|:
if|if
condition|(
name|add_string
argument_list|(
name|ep
argument_list|,
operator|&
name|str
argument_list|,
name|alt_c
argument_list|)
condition|)
block|{
name|alt_c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|joinstring
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|str
argument_list|,
name|ep
operator|->
name|spflag
argument_list|,
name|alt_c
condition|?
name|alt_c
else|:
name|interactive
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|s_downi
argument_list|(
name|ep
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
name|fixfocus
argument_list|(
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|resttoqueue
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|pq
argument_list|)
condition|)
block|{
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|move_on
argument_list|(
name|ep
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
block|{
name|NEXT
expr_stmt|;
break|break;
block|}
return|return
name|No
return|;
block|}
name|str
operator|+=
name|len
expr_stmt|;
name|alt_c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FHOLE
case|:
name|nn
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|repr
operator|=
name|noderepr
argument_list|(
name|nn
argument_list|)
index|[
name|ep
operator|->
name|s1
operator|/
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|s2
operator|>=
name|fwidth
argument_list|(
name|repr
argument_list|)
operator|&&
operator|(
name|ep
operator|->
name|s2
operator|<=
literal|0
operator|||
name|ep
operator|->
name|spflag
operator|||
operator|!
name|isalpha
argument_list|(
name|repr
index|[
literal|0
index|]
argument_list|)
operator|||
name|repr
index|[
name|ep
operator|->
name|s2
operator|-
literal|1
index|]
operator|==
literal|' '
operator|)
condition|)
block|{
comment|/* At end */
if|if
condition|(
name|ep
operator|->
name|s1
operator|/
literal|2
operator|<
name|nchildren
argument_list|(
name|nn
argument_list|)
condition|)
block|{
name|s_downi
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|ATBEGIN
expr_stmt|;
comment|/* Of next child */
block|}
else|else
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|str
operator|==
literal|':'
operator|||
operator|*
name|str
operator|==
literal|' '
operator|)
operator|&&
operator|*
name|str
operator|==
name|repr
index|[
name|ep
operator|->
name|s2
index|]
condition|)
block|{
comment|/***** 				 * Quick hack for insertion of test-suites and refinements: 				 *****/
operator|++
name|ep
operator|->
name|s2
expr_stmt|;
name|NEXT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|lefttorite
condition|)
name|nosuggtoqueue
argument_list|(
name|ep
argument_list|,
name|pq
argument_list|)
expr_stmt|;
name|oldstr
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|resuggest
argument_list|(
name|ep
argument_list|,
operator|&
name|str
argument_list|,
name|alt_c
argument_list|)
operator|||
name|soften
argument_list|(
name|ep
argument_list|,
operator|&
name|str
argument_list|,
name|alt_c
argument_list|)
condition|)
block|{
if|if
condition|(
name|str
operator|>
name|oldstr
condition|)
name|alt_c
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fix_move
argument_list|(
name|ep
argument_list|)
condition|)
continue|continue;
return|return
name|No
return|;
case|case
name|VHOLE
case|:
name|Assert
argument_list|(
operator|!
operator|(
name|ep
operator|->
name|s1
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|nn
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERSUGG
if|if
condition|(
name|symbol
argument_list|(
name|nn
argument_list|)
operator|==
name|Suggestion
condition|)
block|{
if|if
condition|(
name|newsugg
argument_list|(
name|ep
argument_list|,
operator|&
name|str
argument_list|,
name|alt_c
argument_list|)
condition|)
name|alt_c
operator|=
literal|0
expr_stmt|;
else|else
name|killsugg
argument_list|(
name|ep
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
endif|USERSUGG
name|s_downi
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|)
expr_stmt|;
name|v
operator|=
name|copy
argument_list|(
operator|(
name|value
operator|)
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|spflag
condition|)
block|{
for|for
control|(
init|;
name|len
operator|<
sizeof|sizeof
name|buf
operator|-
literal|1
operator|&&
name|str
index|[
name|len
index|]
operator|&&
name|mayinsert
argument_list|(
name|nn
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|,
operator|!
operator|!
operator|(
name|ep
operator|->
name|s2
operator|+
name|len
operator|)
argument_list|,
name|str
index|[
name|len
index|]
argument_list|)
condition|;
operator|++
name|len
control|)
block|{
name|buf
index|[
name|len
index|]
operator|=
name|str
index|[
name|len
index|]
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
operator|&&
name|alt_c
operator|&&
name|mayinsert
argument_list|(
name|nn
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|,
operator|!
operator|!
operator|(
name|ep
operator|->
name|s2
operator|+
name|len
operator|)
argument_list|,
name|alt_c
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|alt_c
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Effectuate change */
name|str
operator|+=
name|len
expr_stmt|;
name|alt_c
operator|=
literal|0
expr_stmt|;
name|Assert
argument_list|(
name|Type
argument_list|(
name|v
argument_list|)
operator|==
name|Tex
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|putintrim
argument_list|(
operator|&
name|v
argument_list|,
name|ep
operator|->
name|s2
argument_list|,
name|Length
argument_list|(
name|v
argument_list|)
operator|-
name|ep
operator|->
name|s2
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|replace
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
operator|(
name|node
operator|)
name|v
argument_list|)
expr_stmt|;
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
name|ep
operator|->
name|s2
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Nothing inserted */
if|if
condition|(
name|ep
operator|->
name|s2
operator|==
literal|0
condition|)
block|{
comment|/* Whole string rejected */
name|addtoqueue
argument_list|(
name|pq
argument_list|,
operator|(
name|node
operator|)
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|delfocus
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ep
operator|->
name|s2
operator|<
name|Length
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|addstringtoqueue
argument_list|(
name|pq
argument_list|,
name|Str
argument_list|(
name|v
argument_list|)
operator|+
name|ep
operator|->
name|s2
argument_list|)
expr_stmt|;
name|putintrim
argument_list|(
operator|&
name|v
argument_list|,
name|ep
operator|->
name|s2
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|replace
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
operator|(
name|node
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|move_on
argument_list|(
name|ep
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
comment|/* ==> up, cancelling s_downi! */
block|}
break|break;
default|default:
name|Abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * See if two nodes can be joined in a hole.  * 'Spflag' indicates whether a space must be present between the nodes  * (required or forbidden).  * Either of n1, n2 may actually be the current contents of the hole.  */
end_comment

begin_function
name|Hidden
name|bool
name|joinnodes
parameter_list|(
name|pp
parameter_list|,
name|n1
parameter_list|,
name|n2
parameter_list|,
name|spflag
parameter_list|)
name|path
modifier|*
name|pp
decl_stmt|;
name|node
name|n1
decl_stmt|;
name|node
name|n2
decl_stmt|;
name|bool
name|spflag
decl_stmt|;
block|{
name|path
name|pa
init|=
name|parent
argument_list|(
operator|*
name|pp
argument_list|)
decl_stmt|;
name|int
name|sympa
init|=
name|pa
condition|?
name|symbol
argument_list|(
name|tree
argument_list|(
name|pa
argument_list|)
argument_list|)
else|:
name|Rootsymbol
decl_stmt|;
name|struct
name|table
modifier|*
name|tp
init|=
operator|&
name|table
index|[
name|sympa
index|]
decl_stmt|;
name|struct
name|classinfo
modifier|*
name|ci
init|=
name|tp
operator|->
name|r_class
index|[
name|ichild
argument_list|(
operator|*
name|pp
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
name|classptr
name|cp
init|=
name|ci
operator|->
name|c_join
decl_stmt|;
name|int
name|sym1
init|=
name|symbol
argument_list|(
name|n1
argument_list|)
decl_stmt|;
name|int
name|sym2
init|=
name|symbol
argument_list|(
name|n2
argument_list|)
decl_stmt|;
name|int
name|symcp
decl_stmt|;
name|int
name|symfound
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|No
return|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
name|spflag
operator|+
literal|1
condition|)
continue|continue;
name|symcp
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|table
index|[
name|symcp
index|]
expr_stmt|;
if|if
condition|(
name|isinclass
argument_list|(
name|sym1
argument_list|,
name|tp
operator|->
name|r_class
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isinclass
argument_list|(
name|sym2
argument_list|,
name|tp
operator|->
name|r_class
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|symfound
operator|=
name|symcp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|symfound
operator|<
literal|0
condition|)
return|return
name|No
return|;
name|n1
operator|=
name|nodecopy
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|n2
operator|=
name|nodecopy
argument_list|(
name|n2
argument_list|)
expr_stmt|;
comment|/* 'Cause one of them may overlap tree(*pp) */
name|replace
argument_list|(
name|pp
argument_list|,
name|table
index|[
name|symfound
index|]
operator|.
name|r_node
argument_list|)
expr_stmt|;
name|down
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
name|replace
argument_list|(
name|pp
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|rite
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
name|replace
argument_list|(
name|pp
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|up
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Try to join a node (implicit as tree(*pp)) with some text.  * That is, try to replace the node by one with it as first child,  * (some of) the text as second child, and nothing or a space in between.  *  * 'Spflag' indicates whether a space is desirable between the nodes  * (but if No it is only used as advice).  *  * Returns the number of characters consumed from str.  */
end_comment

begin_function
name|Visible
name|int
name|joinstring
parameter_list|(
name|pp
parameter_list|,
name|str
parameter_list|,
name|spflag
parameter_list|,
name|alt_c
parameter_list|,
name|mayindent
parameter_list|)
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|string
name|str
decl_stmt|;
specifier|register
name|bool
name|spflag
decl_stmt|;
name|int
name|alt_c
decl_stmt|;
name|bool
name|mayindent
decl_stmt|;
block|{
specifier|register
name|struct
name|table
modifier|*
name|tp
decl_stmt|;
name|path
name|pa
init|=
name|parent
argument_list|(
operator|*
name|pp
argument_list|)
decl_stmt|;
name|node
name|n1
decl_stmt|;
name|struct
name|classinfo
modifier|*
name|ci
decl_stmt|;
specifier|register
name|classptr
name|cp
decl_stmt|;
name|int
name|sympa
init|=
name|pa
condition|?
name|symbol
argument_list|(
name|tree
argument_list|(
name|pa
argument_list|)
argument_list|)
else|:
name|Rootsymbol
decl_stmt|;
specifier|register
name|int
name|sym1
decl_stmt|;
specifier|register
name|int
name|symcp
decl_stmt|;
name|int
name|symfound
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|interactive
init|=
name|alt_c
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|alt_c
operator|<
literal|0
condition|)
name|alt_c
operator|=
literal|0
expr_stmt|;
name|ci
operator|=
name|table
index|[
name|sympa
index|]
operator|.
name|r_class
index|[
name|ichild
argument_list|(
operator|*
name|pp
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|Assert
argument_list|(
name|ci
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ci
operator|->
name|c_join
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
literal|0
return|;
name|n1
operator|=
name|tree
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
name|sym1
operator|=
name|symbol
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|symfound
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|<
name|spflag
operator|+
literal|1
condition|)
continue|continue;
name|symcp
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|table
index|[
name|symcp
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mayindent
operator|&&
name|tp
operator|->
name|r_repr
index|[
literal|1
index|]
operator|&&
name|index
argument_list|(
name|tp
operator|->
name|r_repr
index|[
literal|1
index|]
argument_list|,
literal|'\t'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isinclass
argument_list|(
name|sym1
argument_list|,
name|tp
operator|->
name|r_class
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|canfitchar
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|,
name|tp
operator|->
name|r_class
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|'?'
operator|&&
operator|!
name|interactive
operator|)
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
name|spflag
operator|+
literal|1
condition|)
block|{
name|symfound
operator|=
name|symcp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|symfound
operator|<
literal|0
condition|)
name|symfound
operator|=
name|symcp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symfound
operator|<
literal|0
condition|)
block|{
comment|/* 1-level recursion */
if|if
condition|(
operator|!
name|alt_c
condition|)
return|return
literal|0
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|alt_c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|joinstring
argument_list|(
name|pp
argument_list|,
name|buf
argument_list|,
name|spflag
argument_list|,
literal|0
argument_list|,
name|mayindent
argument_list|)
return|;
block|}
name|n1
operator|=
name|nodecopy
argument_list|(
name|n1
argument_list|)
expr_stmt|;
comment|/* 'Cause it overlaps tree(*pp) */
name|replace
argument_list|(
name|pp
argument_list|,
name|table
index|[
name|symfound
index|]
operator|.
name|r_node
argument_list|)
expr_stmt|;
name|down
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
name|replace
argument_list|(
name|pp
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|rite
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
name|len
operator|=
name|fitstring
argument_list|(
name|pp
argument_list|,
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|str
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|len
operator|=
literal|1
expr_stmt|;
name|Assert
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Disagreement between canfitchar and fitstring */
name|up
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to joinstring, but now the string must match the delimiter  * rather than being acceptable as second child.  * (Interface has changed to resemble resuggest/soften.)  */
end_comment

begin_function
name|Hidden
name|bool
name|add_string
parameter_list|(
name|ep
parameter_list|,
name|pstr
parameter_list|,
name|alt_c
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
name|string
modifier|*
name|pstr
decl_stmt|;
name|int
name|alt_c
decl_stmt|;
comment|/* Yet unused */
block|{
specifier|register
name|struct
name|table
modifier|*
name|tp
decl_stmt|;
name|path
name|pa
init|=
name|parent
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
decl_stmt|;
name|node
name|n1
decl_stmt|;
name|struct
name|classinfo
modifier|*
name|ci
decl_stmt|;
specifier|register
name|classptr
name|cp
decl_stmt|;
name|int
name|sympa
init|=
name|pa
condition|?
name|symbol
argument_list|(
name|tree
argument_list|(
name|pa
argument_list|)
argument_list|)
else|:
name|Rootsymbol
decl_stmt|;
specifier|register
name|int
name|sym1
decl_stmt|;
specifier|register
name|int
name|symcp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|ci
operator|=
name|table
index|[
name|sympa
index|]
operator|.
name|r_class
index|[
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|Assert
argument_list|(
name|ci
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ci
operator|->
name|c_append
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|No
return|;
name|n1
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|sym1
operator|=
name|symbol
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|pstr
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
literal|0177
operator|)
operator|!=
name|c
condition|)
continue|continue;
name|symcp
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|table
index|[
name|symcp
index|]
expr_stmt|;
if|if
condition|(
name|isinclass
argument_list|(
name|sym1
argument_list|,
name|tp
operator|->
name|r_class
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
return|return
name|No
return|;
operator|++
operator|*
name|pstr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
name|ep
operator|->
name|spflag
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|n1
operator|=
name|nodecopy
argument_list|(
name|n1
argument_list|)
expr_stmt|;
comment|/* 'Cause it overlaps tree(ep->focus) */
name|replace
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|table
index|[
name|symcp
index|]
operator|.
name|r_node
argument_list|)
expr_stmt|;
name|s_down
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|replace
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|FHOLE
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
literal|3
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
operator|(
operator|*
name|cp
operator|&
literal|0200
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|ep
operator|->
name|spflag
operator|=
name|No
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * See whether a character may start a new node in a hole with given class.  */
end_comment

begin_function
name|Visible
name|bool
name|canfitchar
parameter_list|(
name|c
parameter_list|,
name|ci
parameter_list|)
name|int
name|c
decl_stmt|;
name|struct
name|classinfo
modifier|*
name|ci
decl_stmt|;
block|{
specifier|register
name|classptr
name|cp
decl_stmt|;
specifier|register
name|int
name|code
init|=
name|Code
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|Assert
argument_list|(
name|ci
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ci
operator|->
name|c_insert
expr_stmt|;
name|Assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
name|code
condition|)
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_comment
comment|/*  * Debug routine to print a queue.  */
end_comment

begin_function
name|Visible
name|Procedure
name|qshow
parameter_list|(
name|q
parameter_list|,
name|where
parameter_list|)
name|queue
name|q
decl_stmt|;
name|string
name|where
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|node
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|string
name|cp
decl_stmt|;
name|string
name|sp
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|q_link
control|)
block|{
name|n
operator|=
name|q
operator|->
name|q_data
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|Str
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
init|;
operator|*
name|sp
condition|;
operator|++
name|sp
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|sp
argument_list|)
operator|||
operator|*
name|sp
operator|==
literal|' '
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'"'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|sp
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|cp
argument_list|,
name|table
index|[
name|symbol
argument_list|(
name|n
argument_list|)
index|]
operator|.
name|r_name
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
literal|80
condition|)
block|{
name|strcpy
argument_list|(
name|buf
operator|+
literal|76
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
block|}
end_function

end_unit

