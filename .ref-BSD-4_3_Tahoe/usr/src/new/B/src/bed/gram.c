begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: gram.c,v 2.5 85/08/22 16:03:16 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- All routines referencing the grammar table are in this file.  */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"supr.h"
end_include

begin_include
include|#
directive|include
file|"tabl.h"
end_include

begin_decl_stmt
specifier|extern
name|bool
name|dflag
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * Test whether sym is in the given class.  */
end_comment

begin_function
name|Visible
name|bool
name|isinclass
parameter_list|(
name|sym
parameter_list|,
name|ci
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
name|struct
name|classinfo
modifier|*
name|ci
decl_stmt|;
block|{
specifier|register
name|classptr
name|cp
decl_stmt|;
name|Assert
argument_list|(
name|ci
operator|&&
name|ci
operator|->
name|c_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|Hole
condition|)
return|return
operator|!
name|isinclass
argument_list|(
name|Optional
argument_list|,
name|ci
argument_list|)
return|;
for|for
control|(
name|cp
operator|=
name|ci
operator|->
name|c_class
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
if|if
condition|(
name|sym
operator|==
operator|*
name|cp
condition|)
return|return
name|Yes
return|;
return|return
name|No
return|;
block|}
end_function

begin_comment
comment|/*  * Deliver the representation array for the given node.  * If the node is actually just a "text" value, construct  * one in static storage -- which is overwritten at each call.  * In this case there are two deficiencies: the next call to  * noderepr which uses the same feature overwrites the reply  * value of the previous call, AND if the text value itself  * is changed, the representation may change, too.  * In practical use this is no problem at all, however.  */
end_comment

begin_function
name|Visible
name|string
modifier|*
name|noderepr
parameter_list|(
name|n
parameter_list|)
specifier|register
name|node
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|sym
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|)
block|{
specifier|static
name|string
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|Str
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|sym
operator|=
name|symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|table
index|[
name|sym
index|]
operator|.
name|r_repr
return|;
block|}
end_function

begin_comment
comment|/*  * Deliver the prototype node for the given symbol.  */
end_comment

begin_function
name|Visible
name|node
name|gram
parameter_list|(
name|sym
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
block|{
name|Assert
argument_list|(
name|sym
operator|==
literal|0
operator|||
name|sym
operator|>
literal|0
operator|&&
name|sym
operator|<
name|TABLEN
operator|&&
name|table
index|[
name|sym
index|]
operator|.
name|r_symbol
argument_list|)
expr_stmt|;
return|return
name|table
index|[
name|sym
index|]
operator|.
name|r_node
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SAVEBUF
end_ifdef

begin_comment
comment|/*  * Deliver the name of a symbol.  */
end_comment

begin_function
name|Visible
name|string
name|symname
parameter_list|(
name|sym
parameter_list|)
name|int
name|sym
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|sym
operator|>=
literal|0
operator|&&
name|sym
operator|<
name|TABLEN
operator|&&
name|table
index|[
name|sym
index|]
operator|.
name|r_name
condition|)
return|return
name|table
index|[
name|sym
index|]
operator|.
name|r_name
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Find the symbol corresponding to a given name.  * Return -1 if not found.  */
end_comment

begin_function
name|Visible
name|int
name|nametosym
parameter_list|(
name|str
parameter_list|)
specifier|register
name|string
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|sym
decl_stmt|;
specifier|register
name|string
name|name
decl_stmt|;
for|for
control|(
name|sym
operator|=
literal|0
init|;
name|sym
operator|<
name|TABLEN
condition|;
operator|++
name|sym
control|)
block|{
name|name
operator|=
name|table
index|[
name|sym
index|]
operator|.
name|r_name
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|Strequ
argument_list|(
name|name
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|sym
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SAVEBUF
end_endif

begin_comment
comment|/*  * Test whether `sym' may replace the node in the path `p'.  */
end_comment

begin_function
name|Visible
name|bool
name|allowed
parameter_list|(
name|p
parameter_list|,
name|sym
parameter_list|)
specifier|register
name|path
name|p
decl_stmt|;
specifier|register
name|int
name|sym
decl_stmt|;
block|{
specifier|register
name|path
name|pa
init|=
name|parent
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ich
init|=
name|ichild
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|register
name|int
name|sympa
init|=
name|pa
condition|?
name|symbol
argument_list|(
name|tree
argument_list|(
name|pa
argument_list|)
argument_list|)
else|:
name|Rootsymbol
decl_stmt|;
name|Assert
argument_list|(
name|sympa
operator|>=
literal|0
operator|&&
name|sympa
operator|<
name|TABLEN
operator|&&
name|ich
operator|>
literal|0
operator|&&
name|ich
operator|<=
name|MAXCHILD
argument_list|)
expr_stmt|;
return|return
name|isinclass
argument_list|(
name|sym
argument_list|,
name|table
index|[
name|sympa
index|]
operator|.
name|r_class
index|[
name|ich
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize (and verify) the grammar table.  */
end_comment

begin_function
name|Visible
name|Procedure
name|initgram
parameter_list|()
block|{
specifier|register
name|int
name|sym
decl_stmt|;
specifier|register
name|int
name|nch
decl_stmt|;
specifier|register
name|struct
name|classinfo
modifier|*
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|classinfo
modifier|*
name|sp
decl_stmt|;
name|node
name|ch
index|[
name|MAXCHILD
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** initgram();\n\r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
comment|/* Set the node pointers in the table and check the representations. 	   The code assumes Optional and Hole are the last 	   symbols in the table, i.e. the first processed by the loop. */
for|for
control|(
name|sym
operator|=
name|TABLEN
operator|-
literal|1
init|;
name|sym
operator|>=
literal|0
condition|;
operator|--
name|sym
control|)
block|{
if|if
condition|(
name|table
index|[
name|sym
index|]
operator|.
name|r_symbol
operator|!=
name|sym
condition|)
block|{
if|if
condition|(
name|sym
operator|!=
name|Hole
operator|&&
name|sym
operator|!=
name|Optional
operator|&&
name|table
index|[
name|sym
index|]
operator|.
name|r_symbol
operator|==
literal|0
condition|)
continue|continue;
comment|/* Disabled table entry */
name|syserr
argument_list|(
literal|"initgram: table order (%s=%d, should be %d)"
argument_list|,
name|table
index|[
name|sym
index|]
operator|.
name|r_name
argument_list|,
name|table
index|[
name|sym
index|]
operator|.
name|r_symbol
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|table
index|[
name|sym
index|]
operator|.
name|r_class
expr_stmt|;
for|for
control|(
name|nch
operator|=
literal|0
init|;
name|nch
operator|<
name|MAXCHILD
operator|&&
operator|(
name|sp
operator|=
name|cp
index|[
name|nch
index|]
operator|)
condition|;
operator|++
name|nch
control|)
name|ch
index|[
name|nch
index|]
operator|=
name|table
index|[
name|sp
operator|->
name|c_class
index|[
literal|0
index|]
operator|==
name|Optional
condition|?
name|Optional
else|:
name|Hole
index|]
operator|.
name|r_node
expr_stmt|;
name|table
index|[
name|sym
index|]
operator|.
name|r_node
operator|=
name|newnode
argument_list|(
name|nch
argument_list|,
name|sym
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|fix
argument_list|(
operator|(
name|value
operator|)
name|table
index|[
name|sym
index|]
operator|.
name|r_node
argument_list|)
expr_stmt|;
block|}
name|initcodes
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USERSUGG
name|initclasses
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|USERSUGG
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USERSUGG
end_ifdef

begin_comment
comment|/*  * Add built-in commands to the suggestion tables.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|initclasses
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|table
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABLEN
condition|;
operator|++
name|i
control|)
block|{
name|tp
operator|=
operator|&
name|table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|r_symbol
operator|!=
name|i
operator|||
name|i
operator|==
name|Suggestion
condition|)
continue|continue;
comment|/* Dead entry */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXCHILD
operator|&&
name|tp
operator|->
name|r_class
index|[
name|j
index|]
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|isinclass
argument_list|(
name|Suggestion
argument_list|,
name|tp
operator|->
name|r_class
index|[
name|j
index|]
argument_list|)
condition|)
name|makesugg
argument_list|(
name|tp
operator|->
name|r_class
index|[
name|j
index|]
operator|->
name|c_class
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Extract suggestions from class list.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|makesugg
parameter_list|(
name|cp
parameter_list|)
name|classptr
name|cp
decl_stmt|;
block|{
name|struct
name|table
modifier|*
name|tp
decl_stmt|;
name|string
modifier|*
name|rp
decl_stmt|;
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|string
name|bp
decl_stmt|;
name|string
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nch
decl_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|>=
name|TABLEN
operator|||
operator|*
name|cp
operator|<
literal|0
condition|)
continue|continue;
name|tp
operator|=
operator|&
name|table
index|[
operator|*
name|cp
index|]
expr_stmt|;
name|rp
operator|=
name|tp
operator|->
name|r_repr
expr_stmt|;
if|if
condition|(
name|rp
index|[
literal|0
index|]
operator|&&
name|isupper
argument_list|(
name|rp
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|bp
operator|=
name|buffer
expr_stmt|;
name|nch
operator|=
name|nchildren
argument_list|(
name|tp
operator|->
name|r_node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nch
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rp
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|rp
index|[
name|i
index|]
init|;
operator|*
name|sp
operator|>=
literal|' '
condition|;
operator|++
name|sp
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|nch
operator|&&
operator|!
name|isinclass
argument_list|(
name|Optional
argument_list|,
name|tp
operator|->
name|r_class
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>
name|buffer
condition|)
block|{
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|addsugg
argument_list|(
name|buffer
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|USERSUGG
end_endif

begin_comment
comment|/*  * Compaction scheme for characters to save space in grammar tables  * by combining characters with similar properties (digits, l.c. letters).  */
end_comment

begin_define
define|#
directive|define
name|RANGE
value|128
end_define

begin_comment
comment|/* ASCII characters are in {0 .. RANGE-1} */
end_comment

begin_decl_stmt
name|Visible
name|char
name|code_array
index|[
name|RANGE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|char
name|invcode_array
index|[
name|RANGE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|int
name|lastcode
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|Procedure
name|initcodes
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|code_array
index|[
literal|'\n'
index|]
operator|=
operator|++
name|lastcode
expr_stmt|;
name|invcode_array
index|[
name|lastcode
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|' '
init|;
name|c
operator|<=
literal|'0'
condition|;
operator|++
name|c
control|)
block|{
name|code_array
index|[
name|c
index|]
operator|=
operator|++
name|lastcode
expr_stmt|;
name|invcode_array
index|[
name|lastcode
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
init|;
name|c
operator|<=
literal|'9'
condition|;
operator|++
name|c
control|)
name|code_array
index|[
name|c
index|]
operator|=
name|lastcode
expr_stmt|;
for|for
control|(
init|;
name|c
operator|<=
literal|'a'
condition|;
operator|++
name|c
control|)
block|{
name|code_array
index|[
name|c
index|]
operator|=
operator|++
name|lastcode
expr_stmt|;
name|invcode_array
index|[
name|lastcode
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
init|;
name|c
operator|<=
literal|'z'
condition|;
operator|++
name|c
control|)
name|code_array
index|[
name|c
index|]
operator|=
name|lastcode
expr_stmt|;
for|for
control|(
init|;
name|c
operator|<
name|RANGE
condition|;
operator|++
name|c
control|)
block|{
name|code_array
index|[
name|c
index|]
operator|=
operator|++
name|lastcode
expr_stmt|;
name|invcode_array
index|[
name|lastcode
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the root of the grammar to the given symbol.  It must exist.  */
end_comment

begin_function
name|Visible
name|Procedure
name|setroot
parameter_list|(
name|name
parameter_list|)
name|string
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|TABLEN
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|table
index|[
name|k
index|]
operator|.
name|r_name
operator|&&
name|Strequ
argument_list|(
name|name
argument_list|,
name|table
index|[
name|k
index|]
operator|.
name|r_name
argument_list|)
condition|)
block|{
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_symbol
operator|=
name|table
index|[
name|k
index|]
operator|.
name|r_symbol
expr_stmt|;
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_name
operator|=
name|table
index|[
name|k
index|]
operator|.
name|r_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCHILD
condition|;
operator|++
name|i
control|)
block|{
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_repr
index|[
name|i
index|]
operator|=
name|table
index|[
name|k
index|]
operator|.
name|r_repr
index|[
name|i
index|]
expr_stmt|;
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_class
index|[
name|i
index|]
operator|=
name|table
index|[
name|k
index|]
operator|.
name|r_class
index|[
name|i
index|]
expr_stmt|;
block|}
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_repr
index|[
name|i
index|]
operator|=
name|table
index|[
name|k
index|]
operator|.
name|r_repr
index|[
name|i
index|]
expr_stmt|;
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_node
operator|=
name|table
index|[
name|k
index|]
operator|.
name|r_node
expr_stmt|;
name|table
index|[
name|Rootsymbol
index|]
operator|.
name|r_symbol
operator|=
name|Rootsymbol
expr_stmt|;
return|return;
block|}
block|}
name|syserr
argument_list|(
literal|"Can't set root of grammar to<%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The remainder of this file is specific for the currently used grammar.  */
end_comment

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_comment
comment|/* Has static data, so should be included only once! */
end_comment

begin_include
include|#
directive|include
file|"syms.h"
end_include

begin_decl_stmt
name|Visible
name|struct
name|table
modifier|*
name|table
init|=
name|b_grammar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table indicating which symbols are used to form lists of items.  * Consulted via predicate 'issublist' in "gram.c".  */
end_comment

begin_decl_stmt
name|Hidden
name|classelem
name|Asublists
index|[]
init|=
block|{
name|E_plus
block|,
name|F_e_plus
block|,
name|And
block|,
name|And_kw
block|,
name|Or
block|,
name|Or_kw
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|struct
name|classinfo
name|sublists
index|[]
init|=
block|{
name|Asublists
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Predicate telling whether two symbols can form lists together.  * This is important for list whose elements must alternate in some  * way, as is the case for [KEYWORD [expression] ]*.  *  * This code must be in this file, otherwise the names and values  * of the symbols would have to be made public.  */
end_comment

begin_function
name|Visible
name|bool
name|samelevel
parameter_list|(
name|sym
parameter_list|,
name|sym1
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
specifier|register
name|int
name|sym1
decl_stmt|;
block|{
specifier|register
name|int
name|zzz
decl_stmt|;
if|if
condition|(
name|sym1
operator|==
name|sym
condition|)
return|return
name|Yes
return|;
if|if
condition|(
name|sym1
operator|<
name|sym
condition|)
name|zzz
operator|=
name|sym
operator|,
name|sym
operator|=
name|sym1
operator|,
name|sym1
operator|=
name|zzz
expr_stmt|;
comment|/* Ensure sym<= sym1 */
comment|/* Now always sym< sym1 */
return|return
name|sym
operator|==
name|Kw_plus
operator|&&
name|sym1
operator|==
name|E_plus
operator|||
name|sym
operator|==
name|F_kw_plus
operator|&&
name|sym1
operator|==
name|F_e_plus
operator|||
name|sym
operator|==
name|And
operator|&&
name|sym1
operator|==
name|And_kw
operator|||
name|sym
operator|==
name|Or
operator|&&
name|sym1
operator|==
name|Or_kw
return|;
block|}
end_function

begin_comment
comment|/*  * Predicate to tell whether a symbol can form chained lists.  * By definition, all right-recursive symbols can do so;  * in addition, those listed in the class 'sublists' can do  * it, too (this is used for lists formed of alternating members  * such as KW expr KW ...).  */
end_comment

begin_function
name|Visible
name|bool
name|issublist
parameter_list|(
name|sym
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|string
name|repr
decl_stmt|;
name|Assert
argument_list|(
name|sym
operator|<
name|TABLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinclass
argument_list|(
name|sym
argument_list|,
name|sublists
argument_list|)
condition|)
return|return
name|Yes
return|;
name|repr
operator|=
name|table
index|[
name|sym
index|]
operator|.
name|r_repr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Fw_positive
argument_list|(
name|repr
argument_list|)
condition|)
return|return
name|No
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCHILD
operator|&&
name|table
index|[
name|sym
index|]
operator|.
name|r_class
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
name|No
return|;
name|repr
operator|=
name|table
index|[
name|sym
index|]
operator|.
name|r_repr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Fw_zero
argument_list|(
name|repr
argument_list|)
condition|)
return|return
name|No
return|;
return|return
name|isinclass
argument_list|(
name|sym
argument_list|,
name|table
index|[
name|sym
index|]
operator|.
name|r_class
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_function

end_unit

