begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: vtrm.c,v 1.3 85/08/30 10:11:04 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* History:  *	21-aug-85 GvR	added support for AL and DL (parametrized al and dl).  *	The Epoch tk	created and modified.  */
end_comment

begin_comment
comment|/*  * Virtual TeRMinal package.  *  * This package uses termcap to determine the terminal capabilities.  *  * The lines and columns of our virtual terminal are numbered   *	y = {0...lines-1} from top to bottom, and  *	x = {0...cols-1} from left to right,  * respectively.  *  * The Visible Procedures in this package are:  *  * trmstart(&lines,&cols,&flags)  * 	Obligatory initialization call (sets tty modes etc.),  * 	Returns the height and width of the screen to the integers  * 	whose addresses are passed as parameters, and a flag that  *	describes some capabilities.  *	Function return value: Yes if all went well, No if the terminal  *	is not supported.  An error message has already been displayed.  *  * trmundefined()  *	Sets internal representation of screen and attributes to undefined.  *	This is necessary for a hard redraw, which would get optimised to  *	oblivion,  *  * trmsense(&y,&x)  *	Returns the cursor position through its parameters  *	after a possible manual change by the user.  *  * trmputdata(yfirst, ylast, indent, data)  * 	Fill lines {yfirst..ylast} with data, after skipping the initial  *	'indent' positions. It is assumed that these positions do not contain  *	anything dangerous (like standout cookies or null characters).  *  * trmscrollup(yfirst, ylast, by)  * 	Shift lines {yfirst..ylast} up by lines (down |by| if by< 0).  *  * trmsync(y, x)  * 	Call to output data to the terminal and set cursor position.  *  * trmbell()  *	Send a (possibly visible) bell, immediately (flushing stdout).  *  * trmend()  * 	Obligatory termination call (resets tty modes etc.).  *  * You may call these as one or more cycles of:  * 	+ trmstart  * 	+    zero or more times any of the other routines  * 	+ trmend  * To catch interrupts and the like, you may call trmend even in the middle  * of trmstart.  */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Includes and data definitions.                                           */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TERMIO
end_ifndef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
endif|TERMIO
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* for isprint() */
end_comment

begin_include
include|#
directive|include
file|"vtrm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|VOID
value|(void)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VOID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Forward
end_define

begin_define
define|#
directive|define
name|Visible
end_define

begin_define
define|#
directive|define
name|Hidden
value|static
end_define

begin_define
define|#
directive|define
name|Procedure
end_define

begin_typedef
typedef|typedef
name|short
name|intlet
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|string
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
name|bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|Yes
value|((bool) 1)
end_define

begin_define
define|#
directive|define
name|No
value|((bool) 0)
end_define

begin_define
define|#
directive|define
name|Min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<= (b) ? (a) : (b))
end_define

begin_comment
comment|/* tty modes */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TERMIO
end_ifndef

begin_comment
comment|/* v7/BSD tty control */
end_comment

begin_decl_stmt
name|Hidden
name|struct
name|sgttyb
name|oldtty
decl_stmt|,
name|newtty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to enable type ahead for abled persons on systems that provide this: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSETN
end_ifdef

begin_define
define|#
directive|define
name|stty
parameter_list|(
name|fd
parameter_list|,
name|bp
parameter_list|)
value|VOID ioctl(fd, TIOCSETN, bp)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* AT&T tty control */
end_comment

begin_decl_stmt
name|Hidden
name|struct
name|termio
name|oldtty
decl_stmt|,
name|newtty
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gtty
parameter_list|(
name|fd
parameter_list|,
name|bp
parameter_list|)
value|ioctl(fd, TCGETA, bp)
end_define

begin_define
define|#
directive|define
name|stty
parameter_list|(
name|fd
parameter_list|,
name|bp
parameter_list|)
value|VOID ioctl(fd, TCSETAW, bp)
end_define

begin_endif
endif|#
directive|endif
endif|TERMIO
end_endif

begin_decl_stmt
name|Hidden
name|bool
name|know_ttys
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* visible data for termcap */
end_comment

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Forward
name|int
name|outchar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* procedure for termcap's tputs */
end_comment

begin_define
define|#
directive|define
name|Putstr
parameter_list|(
name|str
parameter_list|)
value|tputs((str), 1, outchar)
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* termcap terminal capabilities */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|int
name|cols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|bool
name|has_am
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has automatic margins */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|has_da
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display may be retained above screen */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|has_db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display may be retained below screen */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|has_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not save to have null chars on the screen */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|has_mi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move safely in insert (and delete?) mode */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|has_ms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move safely in standout mode */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|has_xs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* standout not erased by overwriting */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|al_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add new blank line */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|par_al_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parametrized al (AL) */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|cd_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear to end of display */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ce_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear to end of line */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|cl_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor home and clear screen */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|cm_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor motion */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|cr_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* carriage return */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|cs_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* change scrolling region */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|dc_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delete character */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|dl_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delete line */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|par_dl_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parametrized dl (DL) */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|do_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor down one line */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|dm_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enter delete mode */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ed_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end delete mode */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ei_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end insert mode */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ho_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor home */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ic_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* insert character (iff necessary, maybe pad) */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|im_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enter insert mode */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|le_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor left */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|nd_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor right (non-destructive space) */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|se_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end standout mode */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|sf_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scroll text up (from bottom of region) */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|so_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* begin standout mode */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|sr_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scroll text down (from top of region) */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|te_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end termcap */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ti_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start termcap */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|up_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor up */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|vb_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* visible bell */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|ve_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make cursor visible again */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|vi_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make cursor invisible */
end_comment

begin_comment
comment|/* sense cursor position, addition to termcap */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|cp_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format of returned Cursor Position string */
end_comment

begin_decl_stmt
name|Hidden
name|char
modifier|*
name|sp_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sense cursor Position from terminal */
end_comment

begin_comment
comment|/* terminal status */
end_comment

begin_comment
comment|/* calling order of Visible Procs */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|started
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to exports the capabilities mentioned in vtrm.h: */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost for impossible operations */
end_comment

begin_define
define|#
directive|define
name|Infinity
value|9999
end_define

begin_comment
comment|/* Allow for adding Infinity+Infinity within range */
end_comment

begin_comment
comment|/* (Range is assumed at least 2**15 - 1) */
end_comment

begin_comment
comment|/* The following for all sorts of undefined things (except for UNKNOWN char) */
end_comment

begin_define
define|#
directive|define
name|Undefined
value|(-1)
end_define

begin_comment
comment|/* current mode of putting char's */
end_comment

begin_define
define|#
directive|define
name|Normal
value|0
end_define

begin_define
define|#
directive|define
name|Insert
value|1
end_define

begin_define
define|#
directive|define
name|Delete
value|2
end_define

begin_decl_stmt
name|Hidden
name|short
name|mode
init|=
name|Normal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current standout mode */
end_comment

begin_define
define|#
directive|define
name|Off
value|0
end_define

begin_define
define|#
directive|define
name|On
value|0200
end_define

begin_decl_stmt
name|Hidden
name|short
name|so_mode
init|=
name|Off
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* masks for char's and intlet's */
end_comment

begin_define
define|#
directive|define
name|NULCHAR
value|'\000'
end_define

begin_define
define|#
directive|define
name|CHAR
value|0177
end_define

begin_define
define|#
directive|define
name|SOBIT
value|On
end_define

begin_define
define|#
directive|define
name|SOCHAR
value|0377
end_define

begin_comment
comment|/* if (has_xs) record cookies placed on screen in extra bit */
end_comment

begin_comment
comment|/* type of cookie is determined by the SO bit */
end_comment

begin_define
define|#
directive|define
name|XSBIT
value|0400
end_define

begin_define
define|#
directive|define
name|SOCOOK
value|0600
end_define

begin_define
define|#
directive|define
name|COOKBITS
value|SOCOOK
end_define

begin_define
define|#
directive|define
name|UNKNOWN
value|1
end_define

begin_define
define|#
directive|define
name|NOCOOK
value|UNKNOWN
end_define

begin_comment
comment|/* current cursor position */
end_comment

begin_decl_stmt
name|Hidden
name|intlet
name|cur_y
init|=
name|Undefined
decl_stmt|,
name|cur_x
init|=
name|Undefined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "line[y][x]" holds the char on the terminal, with the SOBIT and XSBIT.  * the SOBIT tells whether the character is standing out, the XSBIT whether  * there is a cookie on the screen at this position.  * In particular a standend-cookie may be recorded AFTER the line  * (just in case some trmputdata will write after that position).  * "lenline[y]" holds the length of the line.  * Unknown chars will be 1, so the optimising compare in putline will fail.  * (Partially) empty lines are distinghuished by "lenline[y]< cols".  */
end_comment

begin_decl_stmt
name|Hidden
name|intlet
modifier|*
modifier|*
name|line
init|=
literal|0
decl_stmt|,
modifier|*
name|lenline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear the screen initially iff only memory cursor addressing available */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|mustclear
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make the cursor invisible when trmsync() tries to move outside the screen */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|no_cursor
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optimise cursor motion */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|abs_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost of absolute cursor motion */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|cr_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost of carriage return */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|do_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost of down */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|le_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost of left */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|nd_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost of right */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|up_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cost of up */
end_comment

begin_comment
comment|/* Optimise trailing match in put_line, iff the terminal can insert and delete  * characters; the cost per n characters will be:  * 	n * MultiplyFactor + OverHead  */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|ins_mf
decl_stmt|,
name|ins_oh
decl_stmt|,
name|del_mf
decl_stmt|,
name|del_oh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|int
name|ed_cost
decl_stmt|,
name|ei_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used in move() */
end_comment

begin_comment
comment|/* The type of scrolling possible determines which routines get used;  * these may be:  * (1) with addline and deleteline (termcap: al_str& dl_str);  * (2) with a settable scrolling region, like VT100 (cs_str, sr_str, sf_str);  * (3) no scrolling available. (NOT YET IMPLEMENTED)  */
end_comment

begin_function_decl
name|Hidden
name|Procedure
function_decl|(
modifier|*
name|scr_up
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Hidden
name|Procedure
function_decl|(
modifier|*
name|scr_down
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|Procedure
name|scr1up
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|Procedure
name|scr1down
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|Procedure
name|scr2up
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|Procedure
name|scr2down
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*Forward Procedure scr3up(); */
end_comment

begin_comment
comment|/*Forward Procedure scr3down(); */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Starting, Ending and (fatal) Error.                                      */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*   * Initialization call.  * Determine terminal capabilities from termcap.  * Set up tty modes.  * Start up terminal and internal administration.  * Return Yes if succeeded, No if trouble (e.g., bad terminal type).  */
end_comment

begin_function
name|Visible
name|int
name|trmstart
parameter_list|(
name|plines
parameter_list|,
name|pcols
parameter_list|,
name|pflags
parameter_list|)
name|int
modifier|*
name|plines
decl_stmt|;
name|int
modifier|*
name|pcols
decl_stmt|;
name|int
modifier|*
name|pflags
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmstart(&li,&co,&fl);\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|started
condition|)
name|trmerr
argument_list|(
literal|"trmstart called twice in succession"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gettermcaps
argument_list|()
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
name|setttymode
argument_list|()
condition|)
return|return
name|No
return|;
name|start_trm
argument_list|()
expr_stmt|;
operator|*
name|plines
operator|=
name|lines
expr_stmt|;
operator|*
name|pcols
operator|=
name|cols
expr_stmt|;
operator|*
name|pflags
operator|=
name|flags
expr_stmt|;
name|started
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Termination call.  * Reset tty modes, etc.  * Beware that it might be called by a catched interrupt even in the middle  * of trmstart()!  */
end_comment

begin_function
name|Visible
name|Procedure
name|trmend
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmend();\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_mode
operator|!=
name|Off
condition|)
name|standend
argument_list|()
expr_stmt|;
name|Putstr
argument_list|(
name|te_str
argument_list|)
expr_stmt|;
name|VOID
name|fflush
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
name|resetttymode
argument_list|()
expr_stmt|;
name|started
operator|=
name|No
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set all internal statuses to undefined, especially the contents of  * the screen, so a hard redraw will not be optimised to heaven.  */
end_comment

begin_function
name|Visible
name|Procedure
name|trmundefined
parameter_list|()
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmundefined();\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cur_y
operator|=
name|cur_x
operator|=
name|Undefined
expr_stmt|;
name|mode
operator|=
name|so_mode
operator|=
name|Undefined
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|lines
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|cols
condition|;
name|x
operator|++
control|)
name|line
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
literal|1
expr_stmt|;
comment|/* impossible char, no so bits */
name|lenline
index|[
name|y
index|]
operator|=
name|cols
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Give an error message, and abort.  * The abort can be catched by the calling process.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|trmerr
parameter_list|(
name|mess
parameter_list|)
name|string
name|mess
decl_stmt|;
block|{
name|trmreset
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** System error in screen output module:\n*** %s\n"
argument_list|,
name|mess
argument_list|)
expr_stmt|;
name|VOID
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Give an error message and reset the tty modes (but don't abort).  */
end_comment

begin_function
name|Hidden
name|Procedure
name|trmmess
parameter_list|(
name|mess
parameter_list|)
name|string
name|mess
decl_stmt|;
block|{
name|trmreset
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Fatal error: %s\n"
argument_list|,
name|mess
argument_list|)
expr_stmt|;
name|VOID
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complain about a missing terminal feature.  Otherwise like trmmess.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|trmsorry
parameter_list|(
name|mess
parameter_list|)
name|string
name|mess
decl_stmt|;
block|{
name|trmreset
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
ifdef|#
directive|ifdef
name|BED
literal|"*** Sorry, this terminal isn't powerful enough to run the B editor.\n"
else|#
directive|else
literal|"*** Sorry, this terminal isn't powerful emough.\n"
endif|#
directive|endif
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** The problem is: %s.\n"
argument_list|,
name|mess
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BED
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** (You might try 'b -e' to use a standard editor instead.)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VOID
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare for giving a (more or less fatal) error message.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|trmreset
parameter_list|()
block|{
if|if
condition|(
name|started
condition|)
block|{
name|move
argument_list|(
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_lines
argument_list|(
name|lines
operator|-
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOID
name|fflush
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
name|resetttymode
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|check_started
parameter_list|(
name|m
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
block|{
name|char
name|s
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
block|{
name|VOID
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s called outside trmstart/trmend"
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|trmerr
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|ccc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|Hidden
name|Procedure
name|countchar
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|ccc
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|int
name|strcost
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|Infinity
return|;
return|return
name|str0cost
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|int
name|str0cost
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|ccc
operator|=
literal|0
expr_stmt|;
name|tputs
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|countchar
argument_list|)
expr_stmt|;
return|return
name|ccc
return|;
block|}
end_function

begin_function
name|Hidden
name|int
name|gettermcaps
parameter_list|()
comment|/* get terminal capabilities from termcap 				 * and related static properties 				 */
block|{
name|string
name|trmname
decl_stmt|;
name|char
name|tc_buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
name|strbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|area
init|=
name|strbuf
decl_stmt|;
name|char
modifier|*
name|xPC
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|tgetent
parameter_list|()
function_decl|;
name|int
name|tgetnum
parameter_list|()
function_decl|;
name|int
name|tgetflag
parameter_list|()
function_decl|;
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
name|int
name|sg
decl_stmt|;
specifier|static
name|bool
name|tc_initialized
init|=
name|No
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|win
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tc_initialized
condition|)
return|return
name|Yes
return|;
if|if
condition|(
operator|(
name|trmname
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|trmmess
argument_list|(
literal|"terminal type not exported in $TERM variable"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
name|tgetent
argument_list|(
name|tc_buf
argument_list|,
name|trmname
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|trmmess
argument_list|(
literal|"unknown terminal type in $TERM envariable"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"hc"
argument_list|)
condition|)
block|{
name|trmsorry
argument_list|(
literal|"can't use a hardcopy terminal"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"le"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|BC
operator|==
name|NULL
condition|)
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|BC
operator|==
name|NULL
condition|)
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|BC
operator|=
literal|"\b"
expr_stmt|;
else|else
block|{
name|trmsorry
argument_list|(
literal|"no LEFT cursor motion"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|UP
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|UP
operator|==
name|NULL
condition|)
block|{
name|trmsorry
argument_list|(
literal|"no UP cursor motion"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|xPC
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|PC
operator|=
operator|(
name|xPC
operator|!=
name|NULL
condition|?
name|xPC
index|[
literal|0
index|]
else|:
name|NULCHAR
operator|)
expr_stmt|;
name|ho_str
operator|=
name|tgetstr
argument_list|(
literal|"ho"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|do_str
operator|=
name|tgetstr
argument_list|(
literal|"do"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|nd_str
operator|=
name|tgetstr
argument_list|(
literal|"nd"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|cm_str
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_str
operator|==
name|NULL
condition|)
block|{
name|cm_str
operator|=
name|tgetstr
argument_list|(
literal|"CM"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_str
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ho_str
operator|==
name|NULL
operator|||
name|do_str
operator|==
name|NULL
operator|||
name|nd_str
operator|==
name|NULL
condition|)
block|{
name|trmsorry
argument_list|(
literal|"no absolute cursor motion"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
block|}
else|else
name|mustclear
operator|=
name|Yes
expr_stmt|;
block|}
name|al_str
operator|=
name|tgetstr
argument_list|(
literal|"al"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|dl_str
operator|=
name|tgetstr
argument_list|(
literal|"dl"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|par_al_str
operator|=
name|tgetstr
argument_list|(
literal|"AL"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|par_dl_str
operator|=
name|tgetstr
argument_list|(
literal|"DL"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|al_str
operator|&&
name|dl_str
condition|)
block|{
name|scr_up
operator|=
name|scr1up
expr_stmt|;
name|scr_down
operator|=
name|scr1down
expr_stmt|;
name|flags
operator||=
name|CAN_SCROLL
expr_stmt|;
block|}
else|else
block|{
name|cs_str
operator|=
name|tgetstr
argument_list|(
literal|"cs"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|sf_str
operator|=
name|tgetstr
argument_list|(
literal|"sf"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf_str
operator|==
name|NULL
condition|)
name|sf_str
operator|=
literal|"\n"
expr_stmt|;
name|sr_str
operator|=
name|tgetstr
argument_list|(
literal|"sr"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs_str
operator|&&
name|sr_str
condition|)
block|{
name|scr_up
operator|=
name|scr2up
expr_stmt|;
name|scr_down
operator|=
name|scr2down
expr_stmt|;
name|flags
operator||=
name|CAN_SCROLL
expr_stmt|;
block|}
else|else
block|{
name|trmsorry
argument_list|(
literal|"can't scroll"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
block|}
name|lines
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|cols
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|win
operator|.
name|ws_col
condition|)
name|cols
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
if|if
condition|(
name|win
operator|.
name|ws_row
condition|)
name|lines
operator|=
name|win
operator|.
name|ws_row
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lines
operator|==
operator|-
literal|1
condition|)
name|lines
operator|=
literal|24
expr_stmt|;
if|if
condition|(
name|cols
operator|==
operator|-
literal|1
condition|)
name|cols
operator|=
literal|80
expr_stmt|;
name|has_am
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|has_db
operator|=
name|tgetflag
argument_list|(
literal|"db"
argument_list|)
expr_stmt|;
name|has_in
operator|=
name|tgetflag
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|has_mi
operator|=
name|tgetflag
argument_list|(
literal|"mi"
argument_list|)
expr_stmt|;
name|has_ms
operator|=
name|tgetflag
argument_list|(
literal|"ms"
argument_list|)
expr_stmt|;
name|has_xs
operator|=
name|tgetflag
argument_list|(
literal|"xs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sg
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|has_xs
operator|=
name|Yes
expr_stmt|;
elseif|else
if|if
condition|(
name|sg
operator|>
literal|0
condition|)
block|{
name|trmsorry
argument_list|(
literal|"video attributes take up space on the screen"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|cd_str
operator|=
name|tgetstr
argument_list|(
literal|"cd"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|ce_str
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_str
condition|)
block|{
name|trmsorry
argument_list|(
literal|"can't clear to end of line"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|cl_str
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|cr_str
operator|=
name|tgetstr
argument_list|(
literal|"cr"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr_str
operator|==
name|NULL
condition|)
name|cr_str
operator|=
literal|"\r"
expr_stmt|;
name|dc_str
operator|=
name|tgetstr
argument_list|(
literal|"dc"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|dm_str
operator|=
name|tgetstr
argument_list|(
literal|"dm"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_str
operator|==
name|NULL
condition|)
name|do_str
operator|=
name|tgetstr
argument_list|(
literal|"nl"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_str
operator|==
name|NULL
condition|)
name|do_str
operator|=
literal|"\n"
expr_stmt|;
name|ed_str
operator|=
name|tgetstr
argument_list|(
literal|"ed"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|ei_str
operator|=
name|tgetstr
argument_list|(
literal|"ei"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|ic_str
operator|=
name|tgetstr
argument_list|(
literal|"ic"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|im_str
operator|=
name|tgetstr
argument_list|(
literal|"im"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|le_str
operator|=
name|BC
expr_stmt|;
name|se_str
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|so_str
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|te_str
operator|=
name|tgetstr
argument_list|(
literal|"te"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|ti_str
operator|=
name|tgetstr
argument_list|(
literal|"ti"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|up_str
operator|=
name|UP
expr_stmt|;
name|vb_str
operator|=
name|tgetstr
argument_list|(
literal|"vb"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|vb_str
operator|==
name|NULL
condition|)
comment|/* then we will do with the audible bell */
name|vb_str
operator|=
literal|"\007"
expr_stmt|;
name|ve_str
operator|=
name|tgetstr
argument_list|(
literal|"ve"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|vi_str
operator|=
name|tgetstr
argument_list|(
literal|"vi"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
comment|/* cursor sensing (non standard) */
name|cp_str
operator|=
name|tgetstr
argument_list|(
literal|"cp"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
name|sp_str
operator|=
name|tgetstr
argument_list|(
literal|"sp"
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_str
operator|!=
name|NULL
operator|&&
name|sp_str
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|CAN_SENSE
expr_stmt|;
if|if
condition|(
name|so_str
operator|!=
name|NULL
operator|&&
name|se_str
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|HAS_STANDOUT
expr_stmt|;
comment|/* calculate costs of local and absolute cursor motions */
if|if
condition|(
name|cm_str
operator|==
name|NULL
condition|)
name|abs_cost
operator|=
name|Infinity
expr_stmt|;
else|else
name|abs_cost
operator|=
name|strcost
argument_list|(
name|tgoto
argument_list|(
name|cm_str
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cr_cost
operator|=
name|strcost
argument_list|(
name|cr_str
argument_list|)
expr_stmt|;
name|do_cost
operator|=
name|strcost
argument_list|(
name|do_str
argument_list|)
expr_stmt|;
name|le_cost
operator|=
name|strcost
argument_list|(
name|le_str
argument_list|)
expr_stmt|;
name|nd_cost
operator|=
name|strcost
argument_list|(
name|nd_str
argument_list|)
expr_stmt|;
name|up_cost
operator|=
name|strcost
argument_list|(
name|up_str
argument_list|)
expr_stmt|;
comment|/* cost of leaving insert or delete mode, used in move() */
name|ei_cost
operator|=
name|str0cost
argument_list|(
name|ei_str
argument_list|)
expr_stmt|;
name|ed_cost
operator|=
name|str0cost
argument_list|(
name|ed_str
argument_list|)
expr_stmt|;
comment|/* calculate insert and delete cost multiply_factor and overhead */
if|if
condition|(
operator|(
operator|(
name|im_str
operator|&&
name|ei_str
operator|)
operator|||
name|ic_str
operator|)
operator|&&
name|dc_str
condition|)
block|{
name|flags
operator||=
name|CAN_OPTIMISE
expr_stmt|;
name|ins_mf
operator|=
literal|1
operator|+
name|str0cost
argument_list|(
name|ic_str
argument_list|)
expr_stmt|;
name|ins_oh
operator|=
name|str0cost
argument_list|(
name|im_str
argument_list|)
operator|+
name|ei_cost
expr_stmt|;
name|del_mf
operator|=
name|str0cost
argument_list|(
name|dc_str
argument_list|)
expr_stmt|;
name|del_oh
operator|=
name|str0cost
argument_list|(
name|dm_str
argument_list|)
operator|+
name|ed_cost
expr_stmt|;
block|}
name|tc_initialized
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|int
name|setttymode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|know_ttys
condition|)
block|{
if|if
condition|(
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|oldtty
argument_list|)
operator|!=
literal|0
operator|||
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|newtty
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|trmmess
argument_list|(
literal|"can't get tty modes (output not a terminal)"
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
ifndef|#
directive|ifndef
name|TERMIO
name|ospeed
operator|=
name|oldtty
operator|.
name|sg_ospeed
expr_stmt|;
ifdef|#
directive|ifdef
name|PWB
name|newtty
operator|.
name|sg_flags
operator|=
operator|(
name|newtty
operator|.
name|sg_flags
operator|&
operator|~
name|ECHO
operator|&
operator|~
name|CRMOD
operator|&
operator|~
name|XTABS
operator|)
operator||
name|RAW
expr_stmt|;
else|#
directive|else
else|PWB
name|newtty
operator|.
name|sg_flags
operator|=
operator|(
name|newtty
operator|.
name|sg_flags
operator|&
operator|~
name|ECHO
operator|&
operator|~
name|CRMOD
operator|&
operator|~
name|XTABS
operator|)
operator||
name|CBREAK
expr_stmt|;
endif|#
directive|endif
endif|PWB
else|#
directive|else
else|TERMIO
name|ospeed
operator|=
name|oldtty
operator|.
name|c_lflag
operator|&
name|CBAUD
expr_stmt|;
name|newtty
operator|.
name|c_iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
comment|/* No CR->NL mapping on input */
name|newtty
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
comment|/* NL doesn't output CR */
name|newtty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
comment|/* No line editing, no echo */
name|newtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|3
expr_stmt|;
comment|/* wait for 3 characters */
name|newtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
comment|/* or 0.1 sec. */
endif|#
directive|endif
endif|TERMIO
name|know_ttys
operator|=
name|Yes
expr_stmt|;
block|}
name|stty
argument_list|(
literal|1
argument_list|,
operator|&
name|newtty
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|resetttymode
parameter_list|()
block|{
if|if
condition|(
name|know_ttys
condition|)
name|stty
argument_list|(
literal|1
argument_list|,
operator|&
name|oldtty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|char
modifier|*
name|lalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|l
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|l
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
name|trmerr
argument_list|(
literal|"not enough memory for screen buffer"
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|start_trm
parameter_list|()
block|{
specifier|register
name|int
name|y
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|line
operator|=
operator|(
name|intlet
operator|*
operator|*
operator|)
name|lalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|lines
operator|*
sizeof|sizeof
argument_list|(
name|intlet
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|lines
condition|;
name|y
operator|++
control|)
name|line
index|[
name|y
index|]
operator|=
operator|(
name|intlet
operator|*
operator|)
name|lalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|cols
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|intlet
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lenline
operator|==
literal|0
condition|)
name|lenline
operator|=
operator|(
name|intlet
operator|*
operator|)
name|lalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|lines
operator|*
sizeof|sizeof
argument_list|(
name|intlet
argument_list|)
argument_list|)
expr_stmt|;
name|trmundefined
argument_list|()
expr_stmt|;
name|Putstr
argument_list|(
name|ti_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs_str
condition|)
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|cs_str
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mustclear
condition|)
name|clear_lines
argument_list|(
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Sensing and moving the cursor.                                           */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * Sense the current (y, x) cursor position, after a possible manual  * change by the user with local cursor motions.  * If the terminal cannot be asked for the current cursor position,  * or if the string returned by the terminal is garbled,  * the position is made Undefined.  */
end_comment

begin_function
name|Visible
name|Procedure
name|trmsense
parameter_list|(
name|py
parameter_list|,
name|px
parameter_list|)
name|int
modifier|*
name|py
decl_stmt|;
name|int
modifier|*
name|px
decl_stmt|;
block|{
name|bool
name|getpos
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmsense(&yy,&xx);\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|check_started
argument_list|(
literal|"trmsense"
argument_list|)
expr_stmt|;
operator|*
name|py
operator|=
operator|*
name|px
operator|=
name|Undefined
expr_stmt|;
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_mode
operator|!=
name|Off
condition|)
name|standend
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CAN_SENSE
operator|&&
name|getpos
argument_list|(
name|py
argument_list|,
name|px
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|py
operator|<
literal|0
operator|||
name|lines
operator|<=
operator|*
name|py
operator|||
operator|*
name|px
operator|<
literal|0
operator|||
name|cols
operator|<=
operator|*
name|px
condition|)
operator|*
name|py
operator|=
operator|*
name|px
operator|=
name|Undefined
expr_stmt|;
block|}
name|cur_y
operator|=
operator|*
name|py
expr_stmt|;
name|cur_x
operator|=
operator|*
name|px
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|getpos
parameter_list|(
name|py
parameter_list|,
name|px
parameter_list|)
name|int
modifier|*
name|py
decl_stmt|,
decl|*
name|px
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|format
init|=
name|cp_str
decl_stmt|;
name|int
name|fc
decl_stmt|;
comment|/* current format character */
name|int
name|ic
decl_stmt|;
comment|/* current input character */
name|int
name|num
decl_stmt|;
name|int
name|on_y
init|=
literal|1
decl_stmt|;
name|bool
name|incr_orig
init|=
name|No
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ni
decl_stmt|;
name|Putstr
argument_list|(
name|sp_str
argument_list|)
expr_stmt|;
name|VOID
name|fflush
parameter_list|(
name|stdout
parameter_list|)
function_decl|;
while|while
condition|(
name|fc
operator|=
operator|*
name|format
operator|++
condition|)
block|{
if|if
condition|(
name|fc
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|getchar
argument_list|()
operator|!=
name|fc
condition|)
return|return
name|No
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|fc
operator|=
operator|*
name|format
operator|++
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'%'
condition|)
return|return
name|No
return|;
continue|continue;
case|case
literal|'r'
case|:
name|on_y
operator|=
literal|1
operator|-
name|on_y
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|incr_orig
operator|=
name|Yes
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|ic
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|ic
argument_list|)
condition|)
return|return
name|No
return|;
name|num
operator|=
name|ic
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|ic
operator|=
name|getchar
argument_list|()
argument_list|)
condition|)
name|num
operator|=
literal|10
operator|*
name|num
operator|+
name|ic
operator|-
literal|'0'
expr_stmt|;
name|VOID
name|ungetc
parameter_list|(
name|ic
parameter_list|,
name|stdin
parameter_list|)
function_decl|;
break|break;
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
name|ni
operator|=
name|fc
operator|-
literal|'0'
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
condition|;
name|i
operator|++
control|)
block|{
name|ic
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|ic
argument_list|)
condition|)
name|num
operator|=
literal|10
operator|*
name|num
operator|+
name|ic
operator|-
literal|'0'
expr_stmt|;
else|else
return|return
name|No
return|;
block|}
break|break;
case|case
literal|'+'
case|:
name|num
operator|=
name|getchar
argument_list|()
operator|-
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|num
operator|=
name|getchar
argument_list|()
operator|+
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
return|return
name|No
return|;
block|}
comment|/* assign num to parameter */
if|if
condition|(
name|incr_orig
condition|)
name|num
operator|--
expr_stmt|;
if|if
condition|(
name|on_y
condition|)
operator|*
name|py
operator|=
name|num
expr_stmt|;
else|else
operator|*
name|px
operator|=
name|num
expr_stmt|;
name|on_y
operator|=
literal|1
operator|-
name|on_y
expr_stmt|;
block|}
block|}
return|return
name|Yes
return|;
block|}
end_block

begin_comment
comment|/*   * To move over characters by rewriting them, we have to check:  * (1) that the screen has been initialised on these positions;  * (2) we do not screw up characters  * when rewriting line[y] from x_from upto x_to  */
end_comment

begin_function
name|Hidden
name|bool
name|rewrite_ok
parameter_list|(
name|y
parameter_list|,
name|xfrom
parameter_list|,
name|xto
parameter_list|)
name|int
name|y
decl_stmt|,
name|xfrom
decl_stmt|,
name|xto
decl_stmt|;
block|{
specifier|register
name|intlet
modifier|*
name|plnyx
decl_stmt|,
modifier|*
name|plnyto
decl_stmt|;
if|if
condition|(
name|xto
operator|>
name|lenline
index|[
name|y
index|]
condition|)
return|return
name|No
return|;
name|plnyto
operator|=
operator|&
name|line
index|[
name|y
index|]
index|[
name|xto
index|]
expr_stmt|;
for|for
control|(
name|plnyx
operator|=
operator|&
name|line
index|[
name|y
index|]
index|[
name|xfrom
index|]
init|;
name|plnyx
operator|<=
name|plnyto
condition|;
name|plnyx
operator|++
control|)
if|if
condition|(
operator|*
name|plnyx
operator|==
name|UNKNOWN
operator|||
operator|(
operator|!
name|has_xs
operator|&&
operator|(
operator|*
name|plnyx
operator|&
name|SOBIT
operator|)
operator|!=
name|so_mode
operator|)
condition|)
return|return
name|No
return|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Move to position y,x on the screen  */
end_comment

begin_comment
comment|/* possible move types for y and x respectively: */
end_comment

begin_define
define|#
directive|define
name|None
value|0
end_define

begin_define
define|#
directive|define
name|Down
value|1
end_define

begin_define
define|#
directive|define
name|Up
value|2
end_define

begin_define
define|#
directive|define
name|Right
value|1
end_define

begin_define
define|#
directive|define
name|ReWrite
value|2
end_define

begin_define
define|#
directive|define
name|Left
value|3
end_define

begin_define
define|#
directive|define
name|CrWrite
value|4
end_define

begin_function
name|Hidden
name|Procedure
name|move
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
name|int
name|dy
decl_stmt|,
name|dx
decl_stmt|;
name|int
name|y_cost
decl_stmt|,
name|x_cost
decl_stmt|,
name|y_move
decl_stmt|,
name|x_move
decl_stmt|;
name|int
name|mode_cost
decl_stmt|;
name|int
name|xi
decl_stmt|;
if|if
condition|(
name|cur_y
operator|==
name|y
operator|&&
name|cur_x
operator|==
name|x
condition|)
return|return;
if|if
condition|(
operator|!
name|has_mi
operator|||
name|mode
operator|==
name|Undefined
condition|)
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_xs
operator|&&
operator|(
operator|(
operator|!
name|has_ms
operator|&&
name|so_mode
operator|!=
name|Off
operator|)
operator|||
name|so_mode
operator|==
name|Undefined
operator|)
condition|)
name|standend
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_y
operator|==
name|Undefined
operator|||
name|cur_x
operator|==
name|Undefined
condition|)
goto|goto
name|absmove
goto|;
name|dy
operator|=
name|y
operator|-
name|cur_y
expr_stmt|;
name|dx
operator|=
name|x
operator|-
name|cur_x
expr_stmt|;
if|if
condition|(
name|dy
operator|>
literal|0
condition|)
block|{
name|y_move
operator|=
name|Down
expr_stmt|;
name|y_cost
operator|=
name|dy
operator|*
name|do_cost
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|y_move
operator|=
name|Up
expr_stmt|;
name|y_cost
operator|=
operator|-
name|dy
operator|*
name|up_cost
expr_stmt|;
block|}
else|else
block|{
name|y_move
operator|=
name|None
expr_stmt|;
name|y_cost
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|y_cost
operator|<
name|abs_cost
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|Normal
case|:
name|mode_cost
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Insert
case|:
name|mode_cost
operator|=
name|ei_cost
expr_stmt|;
break|break;
case|case
name|Delete
case|:
name|mode_cost
operator|=
name|ed_cost
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dx
operator|>
literal|0
condition|)
block|{
name|x_cost
operator|=
name|dx
operator|+
name|mode_cost
expr_stmt|;
if|if
condition|(
name|dx
operator|*
name|nd_cost
operator|<
name|x_cost
operator|||
operator|!
name|rewrite_ok
argument_list|(
name|y
argument_list|,
name|cur_x
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|x_cost
operator|=
name|dx
operator|*
name|nd_cost
expr_stmt|;
name|x_move
operator|=
name|Right
expr_stmt|;
block|}
else|else
name|x_move
operator|=
name|ReWrite
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|x_cost
operator|=
operator|-
name|dx
operator|*
name|le_cost
expr_stmt|;
name|x_move
operator|=
name|Left
expr_stmt|;
block|}
else|else
block|{
name|x_cost
operator|=
literal|0
expr_stmt|;
name|x_move
operator|=
name|None
expr_stmt|;
block|}
if|if
condition|(
name|cr_cost
operator|+
name|x
operator|+
name|mode_cost
operator|<
name|x_cost
operator|&&
name|rewrite_ok
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|x_move
operator|=
name|CrWrite
expr_stmt|;
name|x_cost
operator|=
name|cr_cost
operator|+
name|x
operator|+
name|mode_cost
expr_stmt|;
block|}
block|}
else|else
name|x_cost
operator|=
name|abs_cost
expr_stmt|;
if|if
condition|(
name|y_cost
operator|+
name|x_cost
operator|<
name|abs_cost
condition|)
block|{
switch|switch
condition|(
name|y_move
condition|)
block|{
case|case
name|Down
case|:
while|while
condition|(
name|dy
operator|--
operator|>
literal|0
condition|)
name|Putstr
argument_list|(
name|do_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|Up
case|:
while|while
condition|(
name|dy
operator|++
operator|<
literal|0
condition|)
name|Putstr
argument_list|(
name|up_str
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|x_move
condition|)
block|{
case|case
name|Right
case|:
while|while
condition|(
name|dx
operator|--
operator|>
literal|0
condition|)
name|Putstr
argument_list|(
name|nd_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|Left
case|:
while|while
condition|(
name|dx
operator|++
operator|<
literal|0
condition|)
name|Putstr
argument_list|(
name|le_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|CrWrite
case|:
name|Putstr
argument_list|(
name|cr_str
argument_list|)
expr_stmt|;
name|cur_x
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ReWrite
case|:
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
for|for
control|(
name|xi
operator|=
name|cur_x
init|;
name|xi
operator|<
name|x
condition|;
name|xi
operator|++
control|)
name|putchar
argument_list|(
name|line
index|[
name|y
index|]
index|[
name|xi
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|absmove
label|:
if|if
condition|(
name|cm_str
operator|==
name|NULL
condition|)
block|{
name|Putstr
argument_list|(
name|ho_str
argument_list|)
expr_stmt|;
for|for
control|(
name|cur_y
operator|=
literal|0
init|;
name|cur_y
operator|<
name|y
condition|;
operator|++
name|cur_y
control|)
name|Putstr
argument_list|(
name|do_str
argument_list|)
expr_stmt|;
comment|/* Should try to use tabs here: */
for|for
control|(
name|cur_x
operator|=
literal|0
init|;
name|cur_x
operator|<
name|x
condition|;
operator|++
name|cur_x
control|)
name|Putstr
argument_list|(
name|nd_str
argument_list|)
expr_stmt|;
block|}
else|else
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|cm_str
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cur_y
operator|=
name|y
expr_stmt|;
name|cur_x
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Putting data on the screen.                                              */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * Fill screen area with given data.  * Characters with the SO-bit (0200) set are put in standout mode.  */
end_comment

begin_function
name|Visible
name|Procedure
name|trmputdata
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|,
name|indent
parameter_list|,
name|data
parameter_list|)
name|int
name|yfirst
decl_stmt|;
name|int
name|ylast
decl_stmt|;
specifier|register
name|int
name|indent
decl_stmt|;
specifier|register
name|string
name|data
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|;
name|int
name|x
decl_stmt|,
name|len
decl_stmt|,
name|lendata
decl_stmt|,
name|space
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmputdata(%d, %d, %d, \"%s\");\n"
argument_list|,
name|yfirst
argument_list|,
name|ylast
argument_list|,
name|indent
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|check_started
argument_list|(
literal|"trmputdata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yfirst
operator|<
literal|0
condition|)
name|yfirst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ylast
operator|>=
name|lines
condition|)
name|ylast
operator|=
name|lines
operator|-
literal|1
expr_stmt|;
name|space
operator|=
name|cols
operator|*
operator|(
name|ylast
operator|-
name|yfirst
operator|+
literal|1
operator|)
operator|-
name|indent
expr_stmt|;
if|if
condition|(
name|space
operator|<=
literal|0
condition|)
return|return;
name|yfirst
operator|+=
name|indent
operator|/
name|cols
expr_stmt|;
name|indent
operator|%=
name|cols
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|x
operator|=
name|indent
expr_stmt|;
name|lendata
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ylast
operator|==
name|lines
operator|-
literal|1
operator|&&
name|lendata
operator|>=
name|space
condition|)
name|lendata
operator|=
name|space
operator|-
literal|1
expr_stmt|;
name|len
operator|=
name|Min
argument_list|(
name|lendata
argument_list|,
name|cols
operator|-
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yfirst
init|;
name|y
operator|<=
name|ylast
condition|;
control|)
block|{
name|put_line
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|y
operator|++
expr_stmt|;
name|lendata
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|lendata
operator|>
literal|0
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
name|data
operator|+=
name|len
expr_stmt|;
name|len
operator|=
name|Min
argument_list|(
name|lendata
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
if|if
condition|(
name|y
operator|<=
name|ylast
condition|)
name|clear_lines
argument_list|(
name|y
argument_list|,
name|ylast
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * We will first try to get the picture:  *  *                  op>>>>>>>>>>>op          oq<<<<<<<<<<<<<<<<<<<<<<<<oq  *                  ^            ^           ^                         ^  *<xskip><-----m1----><----od-----><-----------m2----------->  *   OLD:   "You're in a maze of twisty little pieces of code, all alike"  *   NEW:          "in a maze of little twisting pieces of code, all alike"  *<-----m1----><-----nd------><-----------m2----------->  *                  ^            ^             ^                         ^  *                  np>>>>>>>>>>>np            nq<<<<<<<<<<<<<<<<<<<<<<<<nq  * where  *	op, oq, np, nq are pointers to start and end of Old and New data,  * and  *	xskip = length of indent to be skipped,  *	m1 = length of Matching part at start,  *	od = length of Differing mid on screen,  *	nd = length of Differing mid in data to be put,  *	m2 = length of Matching trail.  *  * Then we will try to find a long blank-or-cleared piece in<nd+m2>:  *  *<---m1---><---d1---><---nb---><---d2---><---m2--->  *              ^         ^         ^        ^         ^  *              np        bp        bq1      nq        nend  * where  *	bp, bq are pointers to start and AFTER end of blank piece,  * and  *	d1 = length of differing part before blank piece,  *	nb = length of blank piece to be skipped,  *	d2 = length of differing part after blank piece.  * Remarks:  *	d1 + nb + d2 == nd,  * and  *	d2 maybe less than 0.  */
end_comment

begin_function
name|Hidden
name|int
name|put_line
parameter_list|(
name|y
parameter_list|,
name|xskip
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|int
name|y
decl_stmt|,
name|xskip
decl_stmt|;
name|string
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|intlet
modifier|*
name|op
decl_stmt|,
modifier|*
name|oq
decl_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|nq
decl_stmt|,
modifier|*
name|nend
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bq1
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|od
decl_stmt|,
name|nd
decl_stmt|,
name|delta
decl_stmt|,
name|dd
decl_stmt|,
name|d1
decl_stmt|,
name|nb
decl_stmt|,
name|d2
decl_stmt|;
name|bool
name|skipping
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|o_cost
decl_stmt|;
comment|/* normal and optimising cost */
comment|/* calculate the magic parameters */
name|op
operator|=
operator|&
name|line
index|[
name|y
index|]
index|[
name|xskip
index|]
expr_stmt|;
name|oq
operator|=
operator|&
name|line
index|[
name|y
index|]
index|[
name|lenline
index|[
name|y
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|np
operator|=
name|data
expr_stmt|;
name|nq
operator|=
name|nend
operator|=
name|data
operator|+
name|len
operator|-
literal|1
expr_stmt|;
name|m1
operator|=
name|m2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|op
operator|&
name|SOCHAR
operator|)
operator|==
operator|(
operator|(
operator|(
name|intlet
operator|)
operator|*
name|np
operator|)
operator|&
name|SOCHAR
operator|)
operator|&&
name|op
operator|<=
name|oq
operator|&&
name|np
operator|<=
name|nq
condition|)
name|op
operator|++
operator|,
name|np
operator|++
operator|,
name|m1
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CAN_OPTIMISE
condition|)
while|while
condition|(
operator|(
operator|*
name|oq
operator|&
name|SOCHAR
operator|)
operator|==
operator|(
operator|(
operator|(
name|intlet
operator|)
operator|*
name|nq
operator|)
operator|&
name|SOCHAR
operator|)
operator|&&
name|op
operator|<=
name|oq
operator|&&
name|np
operator|<=
name|nq
condition|)
name|oq
operator|--
operator|,
name|nq
operator|--
operator|,
name|m2
operator|++
expr_stmt|;
name|od
operator|=
name|oq
operator|-
name|op
operator|+
literal|1
expr_stmt|;
name|nd
operator|=
name|nq
operator|-
name|np
operator|+
literal|1
expr_stmt|;
comment|/* now we have the first picture above */
if|if
condition|(
name|od
operator|==
literal|0
operator|&&
name|nd
operator|==
literal|0
condition|)
return|return;
name|delta
operator|=
name|nd
operator|-
name|od
expr_stmt|;
comment|/* find the blank piece */
name|p
operator|=
name|q
operator|=
name|bp
operator|=
name|bq1
operator|=
name|np
expr_stmt|;
name|oq
operator|+=
name|m2
expr_stmt|;
comment|/* back to current eol */
if|if
condition|(
operator|!
name|has_in
condition|)
block|{
while|while
condition|(
name|p
operator|<=
name|nend
condition|)
block|{
while|while
condition|(
name|q
operator|<=
name|nend
operator|&&
operator|*
name|q
operator|==
literal|' '
operator|&&
operator|(
name|op
operator|>
name|oq
operator|||
operator|*
name|op
operator|==
literal|' '
operator|)
condition|)
name|q
operator|++
operator|,
name|op
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|-
name|p
operator|>
name|bq1
operator|-
name|bp
condition|)
name|bp
operator|=
name|p
operator|,
name|bq1
operator|=
name|q
expr_stmt|;
name|p
operator|=
operator|++
name|q
expr_stmt|;
name|op
operator|++
expr_stmt|;
block|}
block|}
name|d1
operator|=
name|bp
operator|-
name|np
expr_stmt|;
name|nb
operator|=
name|bq1
operator|-
name|bp
expr_stmt|;
name|d2
operator|=
name|nq
operator|-
name|bq1
operator|+
literal|1
expr_stmt|;
comment|/* what is cheapest: 	 *	normal: put nd+m2;                         (dd = nd+m2) 	 *	skipping: put d1, skip nb, put d2+m2;      (dd = d2+m2) 	 *	optimise: put dd, insert or delete delta.  (dd = min(od,nd)) 	 */
name|cost
operator|=
name|nd
operator|+
name|m2
expr_stmt|;
comment|/* normal cost */
if|if
condition|(
name|nb
operator|>
name|abs_cost
operator|||
operator|(
name|d1
operator|==
literal|0
operator|&&
name|nb
operator|>
literal|0
operator|)
condition|)
block|{
name|skipping
operator|=
name|Yes
expr_stmt|;
name|cost
operator|-=
name|nb
operator|-
operator|(
name|d1
operator|>
literal|0
condition|?
name|abs_cost
else|:
literal|0
operator|)
expr_stmt|;
comment|/* skipping cost */
name|dd
operator|=
name|d2
expr_stmt|;
block|}
else|else
block|{
name|skipping
operator|=
name|No
expr_stmt|;
name|dd
operator|=
name|nd
expr_stmt|;
block|}
if|if
condition|(
name|m2
operator|!=
literal|0
condition|)
block|{
comment|/* try optimising */
name|o_cost
operator|=
name|Min
argument_list|(
name|od
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
name|o_cost
operator|+=
name|delta
operator|*
name|ins_mf
operator|+
name|ins_oh
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|o_cost
operator|+=
operator|-
name|delta
operator|*
name|del_mf
operator|+
name|del_oh
expr_stmt|;
if|if
condition|(
name|o_cost
operator|>=
name|cost
condition|)
block|{
comment|/* discard m2, no optimise */
name|dd
operator|+=
name|m2
expr_stmt|;
name|m2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dd
operator|=
name|Min
argument_list|(
name|od
argument_list|,
name|nd
argument_list|)
expr_stmt|;
name|skipping
operator|=
name|No
expr_stmt|;
block|}
block|}
comment|/* and now for the real work */
if|if
condition|(
operator|!
name|skipping
operator|||
name|d1
operator|>
literal|0
condition|)
name|move
argument_list|(
name|y
argument_list|,
name|xskip
operator|+
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
name|get_so_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|skipping
condition|)
block|{
if|if
condition|(
name|d1
operator|>
literal|0
condition|)
block|{
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|np
argument_list|,
name|d1
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_xs
operator|&&
name|so_mode
operator|!=
name|Off
condition|)
name|standend
argument_list|()
expr_stmt|;
name|set_blanks
argument_list|(
name|y
argument_list|,
name|xskip
operator|+
name|m1
operator|+
name|d1
argument_list|,
name|xskip
operator|+
name|m1
operator|+
name|d1
operator|+
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|!=
literal|0
operator|||
name|delta
operator|<
literal|0
condition|)
block|{
name|move
argument_list|(
name|y
argument_list|,
name|xskip
operator|+
name|m1
operator|+
name|d1
operator|+
name|nb
argument_list|)
expr_stmt|;
name|np
operator|=
name|bq1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dd
operator|>
literal|0
condition|)
block|{
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|np
argument_list|,
name|dd
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|set_mode
argument_list|(
name|Insert
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|np
operator|+
name|dd
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|set_mode
argument_list|(
name|Delete
argument_list|)
expr_stmt|;
name|del_str
argument_list|(
operator|-
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|clr_to_eol
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|lenline
index|[
name|y
index|]
operator|=
name|xskip
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|cur_x
operator|==
name|cols
condition|)
block|{
if|if
condition|(
operator|!
name|has_mi
condition|)
name|set_mode
argument_list|(
name|Normal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_ms
condition|)
name|so_mode
operator|=
name|Undefined
expr_stmt|;
if|if
condition|(
name|has_am
condition|)
name|cur_y
operator|++
expr_stmt|;
else|else
name|Putstr
argument_list|(
name|cr_str
argument_list|)
expr_stmt|;
name|cur_x
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_xs
condition|)
block|{
if|if
condition|(
name|m2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so_mode
operator|==
name|On
condition|)
name|standend
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|&
name|XSBIT
operator|)
condition|)
block|{
if|if
condition|(
name|so_mode
operator|!=
operator|(
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|&
name|SOBIT
operator|)
condition|)
operator|(
name|so_mode
condition|?
name|standend
argument_list|()
else|:
name|standout
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|set_mode
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
if|if
condition|(
name|m
operator|==
name|mode
condition|)
return|return;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|Insert
case|:
name|Putstr
argument_list|(
name|ei_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|Delete
case|:
name|Putstr
argument_list|(
name|ed_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|Undefined
case|:
name|Putstr
argument_list|(
name|ei_str
argument_list|)
expr_stmt|;
name|Putstr
argument_list|(
name|ed_str
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|Insert
case|:
name|Putstr
argument_list|(
name|im_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|Delete
case|:
name|Putstr
argument_list|(
name|dm_str
argument_list|)
expr_stmt|;
break|break;
block|}
name|mode
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|get_so_mode
parameter_list|()
block|{
if|if
condition|(
name|cur_x
operator|>=
name|lenline
index|[
name|cur_y
index|]
operator|||
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|==
name|UNKNOWN
condition|)
name|so_mode
operator|=
name|Off
expr_stmt|;
else|else
name|so_mode
operator|=
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|&
name|SOBIT
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|standout
parameter_list|()
block|{
name|Putstr
argument_list|(
name|so_str
argument_list|)
expr_stmt|;
name|so_mode
operator|=
name|On
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator||=
name|SOCOOK
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|standend
parameter_list|()
block|{
name|Putstr
argument_list|(
name|se_str
argument_list|)
expr_stmt|;
name|so_mode
operator|=
name|Off
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|=
operator|(
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|&
operator|~
name|SOBIT
operator|)
operator||
name|XSBIT
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|put_str
parameter_list|(
name|data
parameter_list|,
name|n
parameter_list|,
name|inserting
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bool
name|inserting
decl_stmt|;
block|{
specifier|register
name|intlet
name|c
decl_stmt|,
name|so
decl_stmt|;
name|intlet
modifier|*
name|ln_y_x
decl_stmt|,
modifier|*
name|ln_y_end
decl_stmt|;
name|so
operator|=
name|so_mode
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
block|{
name|ln_y_x
operator|=
operator|&
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
expr_stmt|;
name|ln_y_end
operator|=
operator|&
name|line
index|[
name|cur_y
index|]
index|[
name|lenline
index|[
name|cur_y
index|]
index|]
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|has_xs
operator|&&
name|ln_y_x
operator|<=
name|ln_y_end
operator|&&
operator|(
operator|(
operator|*
name|ln_y_x
operator|)
operator|&
name|XSBIT
operator|)
condition|)
name|so
operator|=
name|so_mode
operator|=
operator|(
operator|*
name|ln_y_x
operator|)
operator|&
name|SOBIT
expr_stmt|;
comment|/* this also checks for the standend cookie AFTER */
comment|/* the line because off the equals sign in<= */
name|c
operator|=
operator|(
call|(
name|intlet
call|)
argument_list|(
operator|*
name|data
operator|++
argument_list|)
operator|)
operator|&
name|SOCHAR
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|SOBIT
operator|)
operator|!=
name|so
condition|)
block|{
name|so
operator|=
name|c
operator|&
name|SOBIT
expr_stmt|;
name|so
condition|?
name|standout
argument_list|()
else|:
name|standend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inserting
condition|)
name|Putstr
argument_list|(
name|ic_str
argument_list|)
expr_stmt|;
name|put_c
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
name|ln_y_x
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|ins_str
parameter_list|(
name|data
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
comment|/* x will start AFTER the line, because there might be a cookie */
for|for
control|(
name|x
operator|=
name|lenline
index|[
name|cur_y
index|]
init|;
name|x
operator|>=
name|cur_x
condition|;
name|x
operator|--
control|)
name|line
index|[
name|cur_y
index|]
index|[
name|x
operator|+
name|n
index|]
operator|=
name|line
index|[
name|cur_y
index|]
index|[
name|x
index|]
expr_stmt|;
name|put_str
argument_list|(
name|data
argument_list|,
name|n
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|del_str
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|xto
decl_stmt|;
name|xto
operator|=
name|lenline
index|[
name|cur_y
index|]
operator|-
name|n
expr_stmt|;
comment|/* again one too far because of cookie */
if|if
condition|(
name|has_xs
condition|)
block|{
for|for
control|(
name|x
operator|=
name|cur_x
operator|+
name|n
init|;
name|x
operator|>=
name|cur_x
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
name|line
index|[
name|cur_y
index|]
index|[
name|x
index|]
operator|&
name|XSBIT
condition|)
break|break;
block|}
if|if
condition|(
name|x
operator|>=
name|cur_x
condition|)
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
operator|+
name|n
index|]
operator|=
operator|(
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
operator|+
name|n
index|]
operator|&
name|CHAR
operator|)
operator||
operator|(
name|line
index|[
name|cur_y
index|]
index|[
name|x
index|]
operator|&
name|COOKBITS
operator|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|cur_x
init|;
name|x
operator|<=
name|xto
condition|;
name|x
operator|++
control|)
name|line
index|[
name|cur_y
index|]
index|[
name|x
index|]
operator|=
name|line
index|[
name|cur_y
index|]
index|[
name|x
operator|+
name|n
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|Putstr
argument_list|(
name|dc_str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|put_c
parameter_list|(
name|c
parameter_list|)
name|intlet
name|c
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
name|intlet
name|xs_flag
decl_stmt|;
name|ch
operator|=
name|c
operator|&
name|CHAR
expr_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
operator|&&
name|ch
operator|!=
literal|' '
condition|)
block|{
comment|/* V7 isprint doesn't include blank */
name|ch
operator|=
literal|'?'
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|&
name|SOBIT
operator|)
operator||
literal|'?'
expr_stmt|;
block|}
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
name|xs_flag
operator|=
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|&
name|XSBIT
expr_stmt|;
else|else
name|xs_flag
operator|=
literal|0
expr_stmt|;
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
index|]
operator|=
operator|(
name|c
operator|&
name|SOCHAR
operator|)
operator||
name|xs_flag
expr_stmt|;
name|cur_x
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|clear_lines
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|)
name|int
name|yfirst
decl_stmt|,
name|ylast
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|;
if|if
condition|(
operator|!
name|has_xs
operator|&&
name|so_mode
operator|!=
name|Off
condition|)
name|standend
argument_list|()
expr_stmt|;
if|if
condition|(
name|cl_str
operator|&&
name|yfirst
operator|==
literal|0
operator|&&
name|ylast
operator|==
name|lines
operator|-
literal|1
condition|)
block|{
name|Putstr
argument_list|(
name|cl_str
argument_list|)
expr_stmt|;
name|cur_y
operator|=
name|cur_x
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|y
operator|=
name|yfirst
init|;
name|y
operator|<=
name|ylast
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|lenline
index|[
name|y
index|]
operator|>
literal|0
condition|)
block|{
name|move
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ylast
operator|==
name|lines
operator|-
literal|1
operator|&&
name|cd_str
condition|)
block|{
name|Putstr
argument_list|(
name|cd_str
argument_list|)
expr_stmt|;
while|while
condition|(
name|y
operator|<=
name|ylast
condition|)
block|{
if|if
condition|(
name|has_xs
condition|)
name|line
index|[
name|y
index|]
index|[
literal|0
index|]
operator|=
name|NOCOOK
expr_stmt|;
name|lenline
index|[
name|y
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|clr_to_eol
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|clr_to_eol
parameter_list|()
block|{
name|lenline
index|[
name|cur_y
index|]
operator|=
name|cur_x
expr_stmt|;
if|if
condition|(
operator|!
name|has_xs
operator|&&
name|so_mode
operator|!=
name|Off
condition|)
name|standend
argument_list|()
expr_stmt|;
name|Putstr
argument_list|(
name|ce_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
block|{
if|if
condition|(
name|cur_x
operator|==
literal|0
condition|)
name|line
index|[
name|cur_y
index|]
index|[
literal|0
index|]
operator|=
name|NOCOOK
expr_stmt|;
elseif|else
if|if
condition|(
name|line
index|[
name|cur_y
index|]
index|[
name|cur_x
operator|-
literal|1
index|]
operator|&
name|SOBIT
condition|)
name|standend
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|set_blanks
parameter_list|(
name|y
parameter_list|,
name|xfrom
parameter_list|,
name|xto
parameter_list|)
name|int
name|y
decl_stmt|,
name|xfrom
decl_stmt|,
name|xto
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|xfrom
init|;
name|x
operator|<
name|xto
condition|;
name|x
operator|++
control|)
block|{
name|line
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
operator|(
name|line
index|[
name|y
index|]
index|[
name|x
index|]
operator|&
name|XSBIT
operator|)
operator||
literal|' '
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * outchar() is used by termcap's tputs;  * we can't use putchar because that's probably a macro  */
end_comment

begin_function
name|Hidden
name|int
name|outchar
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Scrolling (part of) the screen up (or down, dy<0).                       */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_function
name|Visible
name|Procedure
name|trmscrollup
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|,
name|by
parameter_list|)
specifier|register
name|int
name|yfirst
decl_stmt|;
specifier|register
name|int
name|ylast
decl_stmt|;
specifier|register
name|int
name|by
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmscrollup(%d, %d, %d);\n"
argument_list|,
name|yfirst
argument_list|,
name|ylast
argument_list|,
name|by
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|check_started
argument_list|(
literal|"trmscrollup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yfirst
operator|<
literal|0
condition|)
name|yfirst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ylast
operator|>=
name|lines
condition|)
name|ylast
operator|=
name|lines
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yfirst
operator|>
name|ylast
condition|)
return|return;
if|if
condition|(
operator|!
name|has_xs
operator|&&
name|so_mode
operator|!=
name|Off
condition|)
name|standend
argument_list|()
expr_stmt|;
if|if
condition|(
name|by
operator|>
literal|0
operator|&&
name|yfirst
operator|+
name|by
operator|>
name|ylast
operator|||
name|by
operator|<
literal|0
operator|&&
name|yfirst
operator|-
name|by
operator|>
name|ylast
condition|)
block|{
name|clear_lines
argument_list|(
name|yfirst
argument_list|,
name|ylast
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|by
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|scr_up
call|)
argument_list|(
name|yfirst
argument_list|,
name|ylast
argument_list|,
name|by
argument_list|)
expr_stmt|;
name|scr_lines
argument_list|(
name|yfirst
argument_list|,
name|ylast
argument_list|,
name|by
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|by
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|scr_down
call|)
argument_list|(
name|yfirst
argument_list|,
name|ylast
argument_list|,
operator|-
name|by
argument_list|)
expr_stmt|;
name|scr_lines
argument_list|(
name|ylast
argument_list|,
name|yfirst
argument_list|,
operator|-
name|by
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|scr_lines
parameter_list|(
name|yfrom
parameter_list|,
name|yto
parameter_list|,
name|n
parameter_list|,
name|dy
parameter_list|)
name|int
name|yfrom
decl_stmt|,
name|yto
decl_stmt|,
name|n
decl_stmt|,
name|dy
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|;
name|intlet
modifier|*
name|saveln
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|saveln
operator|=
name|line
index|[
name|yfrom
index|]
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yfrom
init|;
name|y
operator|!=
name|yto
condition|;
name|y
operator|+=
name|dy
control|)
block|{
name|line
index|[
name|y
index|]
operator|=
name|line
index|[
name|y
operator|+
name|dy
index|]
expr_stmt|;
name|lenline
index|[
name|y
index|]
operator|=
name|lenline
index|[
name|y
operator|+
name|dy
index|]
expr_stmt|;
block|}
name|line
index|[
name|yto
index|]
operator|=
name|saveln
expr_stmt|;
name|lenline
index|[
name|yto
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_xs
condition|)
name|line
index|[
name|yto
index|]
index|[
literal|0
index|]
operator|=
name|NOCOOK
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|scr1up
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|,
name|n
parameter_list|)
name|int
name|yfirst
decl_stmt|;
name|int
name|ylast
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|move
argument_list|(
name|yfirst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dellines
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ylast
operator|<
name|lines
operator|-
literal|1
condition|)
block|{
name|move
argument_list|(
name|ylast
operator|-
name|n
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addlines
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|scr1down
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|,
name|n
parameter_list|)
name|int
name|yfirst
decl_stmt|;
name|int
name|ylast
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|ylast
operator|==
name|lines
operator|-
literal|1
condition|)
block|{
name|clear_lines
argument_list|(
name|ylast
operator|-
name|n
operator|+
literal|1
argument_list|,
name|ylast
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|move
argument_list|(
name|ylast
operator|-
name|n
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dellines
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|yfirst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addlines
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|addlines
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|par_al_str
operator|&&
name|n
operator|>
literal|1
condition|)
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|par_al_str
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|Putstr
argument_list|(
name|al_str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|dellines
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|par_dl_str
operator|&&
name|n
operator|>
literal|1
condition|)
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|par_dl_str
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|Putstr
argument_list|(
name|dl_str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|scr2up
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|,
name|n
parameter_list|)
name|int
name|yfirst
decl_stmt|,
name|ylast
decl_stmt|,
name|n
decl_stmt|;
block|{
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|cs_str
argument_list|,
name|ylast
argument_list|,
name|yfirst
argument_list|)
argument_list|)
expr_stmt|;
name|cur_y
operator|=
name|cur_x
operator|=
name|Undefined
expr_stmt|;
name|move
argument_list|(
name|ylast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|Putstr
argument_list|(
name|sf_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_db
operator|&&
name|ylast
operator|==
name|lines
operator|-
literal|1
condition|)
name|clr_to_eol
argument_list|()
expr_stmt|;
block|}
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|cs_str
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur_y
operator|=
name|cur_x
operator|=
name|Undefined
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|scr2down
parameter_list|(
name|yfirst
parameter_list|,
name|ylast
parameter_list|,
name|n
parameter_list|)
name|int
name|yfirst
decl_stmt|,
name|ylast
decl_stmt|,
name|n
decl_stmt|;
block|{
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|cs_str
argument_list|,
name|ylast
argument_list|,
name|yfirst
argument_list|)
argument_list|)
expr_stmt|;
name|cur_y
operator|=
name|cur_x
operator|=
name|Undefined
expr_stmt|;
name|move
argument_list|(
name|yfirst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|Putstr
argument_list|(
name|sr_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_da
operator|&&
name|yfirst
operator|==
literal|0
condition|)
name|clr_to_eol
argument_list|()
expr_stmt|;
block|}
name|Putstr
argument_list|(
name|tgoto
argument_list|(
name|cs_str
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur_y
operator|=
name|cur_x
operator|=
name|Undefined
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Synchronization, move cursor to given position (or previous if< 0).     */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_function
name|Visible
name|Procedure
name|trmsync
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
name|int
name|y
decl_stmt|;
name|int
name|x
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmsync(%d, %d);\n"
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|check_started
argument_list|(
literal|"trmsync"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|y
operator|&&
name|y
operator|<
name|lines
operator|&&
literal|0
operator|<=
name|x
operator|&&
name|x
operator|<
name|cols
condition|)
block|{
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_cursor
condition|)
block|{
name|Putstr
argument_list|(
name|ve_str
argument_list|)
expr_stmt|;
name|no_cursor
operator|=
name|No
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|no_cursor
operator|==
name|No
condition|)
block|{
name|Putstr
argument_list|(
name|vi_str
argument_list|)
expr_stmt|;
name|no_cursor
operator|=
name|Yes
expr_stmt|;
block|}
name|VOID
name|fflush
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Send a bell, visible if possible.                                        */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_function
name|Visible
name|Procedure
name|trmbell
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttrmbell();\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|check_started
argument_list|(
literal|"trmbell"
argument_list|)
expr_stmt|;
name|Putstr
argument_list|(
name|vb_str
argument_list|)
expr_stmt|;
name|VOID
name|fflush
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/* Show the current internal statuses of the screen on stderr.              */
end_comment

begin_comment
comment|/* For debugging only.                                                      */
end_comment

begin_comment
comment|/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SHOW
end_ifdef

begin_function
name|Visible
name|Procedure
name|trmshow
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<<< %s>>>\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|lines
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|lenline
index|[
name|y
index|]
comment|/***&& x< cols-1 ***/
condition|;
name|x
operator|++
control|)
block|{
name|fputc
argument_list|(
name|line
index|[
name|y
index|]
index|[
name|x
index|]
operator|&
name|CHAR
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|lenline
index|[
name|y
index|]
operator|&&
name|x
operator|<
name|cols
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|line
index|[
name|y
index|]
index|[
name|x
index|]
operator|&
name|SOBIT
condition|)
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|lenline
index|[
name|y
index|]
operator|&&
name|x
operator|<
name|cols
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|line
index|[
name|y
index|]
index|[
name|x
index|]
operator|&
name|XSBIT
condition|)
name|fputc
argument_list|(
literal|'+'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CUR_Y = %d, CUR_X = %d.\n"
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|VOID
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

