begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: node.c,v 2.4 85/08/22 16:05:27 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Parse tree and Focus stack.  */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_define
define|#
directive|define
name|Register
value|register
end_define

begin_comment
comment|/* Used for registers 4-6.  Define as empty macro on PDP */
end_comment

begin_comment
comment|/*  * Lowest level routines for 'node' data type.  */
end_comment

begin_define
define|#
directive|define
name|Isnode
parameter_list|(
name|n
parameter_list|)
value|((n)&& (n)->type == Nod)
end_define

begin_define
define|#
directive|define
name|Nchildren
parameter_list|(
name|n
parameter_list|)
value|((n)->len)
end_define

begin_define
define|#
directive|define
name|Symbol
parameter_list|(
name|n
parameter_list|)
value|((n)->n_symbol)
end_define

begin_define
define|#
directive|define
name|Child
parameter_list|(
name|n
parameter_list|,
name|i
parameter_list|)
value|((n)->n_child[(i)-1])
end_define

begin_define
define|#
directive|define
name|Marks
parameter_list|(
name|n
parameter_list|)
value|((n)->n_marks)
end_define

begin_define
define|#
directive|define
name|Width
parameter_list|(
name|n
parameter_list|)
value|((n)->n_width)
end_define

begin_comment
comment|/*  * Routines which are macros for the compiler but real functions for lint,  * so it will check the argument types more strictly.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_function
name|node
name|nodecopy
parameter_list|(
name|n
parameter_list|)
name|node
name|n
decl_stmt|;
block|{
return|return
operator|(
name|node
operator|)
name|copy
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
return|;
block|}
end_function

begin_macro
name|noderelease
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|node
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|release
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nodeuniql
argument_list|(
argument|pn
argument_list|)
end_macro

begin_decl_stmt
name|node
modifier|*
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|uniql
argument_list|(
operator|(
name|value
operator|*
operator|)
name|pn
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * Allocate a new node.  */
end_comment

begin_function
name|Visible
name|node
name|newnode
parameter_list|(
name|nch
parameter_list|,
name|sym
parameter_list|,
name|children
parameter_list|)
specifier|register
name|int
name|nch
decl_stmt|;
name|Register
name|int
name|sym
decl_stmt|;
specifier|register
name|node
name|children
index|[]
decl_stmt|;
block|{
specifier|register
name|node
name|n
init|=
operator|(
name|node
operator|)
name|grab_node
argument_list|(
name|nch
argument_list|)
decl_stmt|;
comment|/* Must preset with zeros! */
name|Symbol
argument_list|(
name|n
argument_list|)
operator|=
name|sym
expr_stmt|;
for|for
control|(
init|;
name|nch
operator|>
literal|0
condition|;
operator|--
name|nch
control|)
name|Child
argument_list|(
name|n
argument_list|,
name|nch
argument_list|)
operator|=
name|children
index|[
name|nch
operator|-
literal|1
index|]
expr_stmt|;
name|Width
argument_list|(
name|n
argument_list|)
operator|=
name|evalwidth
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Macros to change the fields of a node.  */
end_comment

begin_define
define|#
directive|define
name|Locchild
parameter_list|(
name|pn
parameter_list|,
name|i
parameter_list|)
define|\
value|(Refcnt(*(pn)) == 1 || nodeuniql(pn),&Child(*(pn), i))
end_define

begin_define
define|#
directive|define
name|Setmarks
parameter_list|(
name|pn
parameter_list|,
name|x
parameter_list|)
define|\
value|(Refcnt(*(pn)) == 1 || nodeuniql(pn), Marks(*(pn))=(x))
end_define

begin_define
define|#
directive|define
name|Setwidth
parameter_list|(
name|pn
parameter_list|,
name|w
parameter_list|)
value|(Refcnt(*(pn)) == 1 || nodeuniql(pn), Width(*(pn))=w)
end_define

begin_comment
comment|/*  * Change a child of a node.  * Like replace(), it does not increase the reference count of n.  */
end_comment

begin_function
name|Visible
name|Procedure
name|setchild
parameter_list|(
name|pn
parameter_list|,
name|i
parameter_list|,
name|n
parameter_list|)
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Register
name|node
name|n
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|pch
decl_stmt|;
specifier|register
name|node
name|oldchild
decl_stmt|;
name|Assert
argument_list|(
name|Isnode
argument_list|(
operator|*
name|pn
argument_list|)
argument_list|)
expr_stmt|;
name|pch
operator|=
name|Locchild
argument_list|(
name|pn
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|oldchild
operator|=
operator|*
name|pch
expr_stmt|;
operator|*
name|pch
operator|=
name|n
expr_stmt|;
name|repwidth
argument_list|(
name|pn
argument_list|,
name|oldchild
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|noderelease
argument_list|(
name|oldchild
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lowest level routines for 'path' data type.  */
end_comment

begin_define
define|#
directive|define
name|NPATHFIELDS
value|6
end_define

begin_define
define|#
directive|define
name|Parent
parameter_list|(
name|p
parameter_list|)
value|((p)->p_parent)
end_define

begin_define
define|#
directive|define
name|Tree
parameter_list|(
name|p
parameter_list|)
value|((p)->p_tree)
end_define

begin_define
define|#
directive|define
name|Ichild
parameter_list|(
name|p
parameter_list|)
value|((p)->p_ichild)
end_define

begin_define
define|#
directive|define
name|Ycoord
parameter_list|(
name|p
parameter_list|)
value|((p)->p_ycoord)
end_define

begin_define
define|#
directive|define
name|Xcoord
parameter_list|(
name|p
parameter_list|)
value|((p)->p_xcoord)
end_define

begin_define
define|#
directive|define
name|Level
parameter_list|(
name|p
parameter_list|)
value|((p)->p_level)
end_define

begin_comment
comment|/*  * Routines which are macros for the compiler but real functions for lint,  * so it will check the argument types more strictly.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_function
name|Visible
name|path
name|pathcopy
parameter_list|(
name|p
parameter_list|)
name|path
name|p
decl_stmt|;
block|{
return|return
operator|(
name|path
operator|)
name|copy
argument_list|(
operator|(
name|value
operator|)
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|pathrelease
parameter_list|(
name|p
parameter_list|)
name|path
name|p
decl_stmt|;
block|{
name|release
argument_list|(
operator|(
name|value
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|pathuniql
parameter_list|(
name|pp
parameter_list|)
name|path
modifier|*
name|pp
decl_stmt|;
block|{
name|uniql
argument_list|(
operator|(
name|value
operator|*
operator|)
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * Allocate a new path entry.  */
end_comment

begin_function
name|Visible
name|path
name|newpath
parameter_list|(
name|pa
parameter_list|,
name|n
parameter_list|,
name|i
parameter_list|)
specifier|register
name|path
name|pa
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
name|Register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|path
name|p
init|=
operator|(
name|path
operator|)
name|grab_path
argument_list|()
decl_stmt|;
name|Parent
argument_list|(
name|p
argument_list|)
operator|=
name|pa
expr_stmt|;
name|Tree
argument_list|(
name|p
argument_list|)
operator|=
name|n
expr_stmt|;
name|Ichild
argument_list|(
name|p
argument_list|)
operator|=
name|i
expr_stmt|;
name|Ycoord
argument_list|(
name|p
argument_list|)
operator|=
name|Xcoord
argument_list|(
name|p
argument_list|)
operator|=
name|Level
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Macros to change the fields of a path entry.  */
end_comment

begin_define
define|#
directive|define
name|Uniqp
parameter_list|(
name|pp
parameter_list|)
value|(Refcnt(*(pp)) == 1 || pathuniql(pp))
end_define

begin_define
define|#
directive|define
name|Setcoord
parameter_list|(
name|pp
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|level
parameter_list|)
value|(Uniqp(pp), \ 	(*(pp))->p_ycoord = y, (*(pp))->p_xcoord = x, (*(pp))->p_level = level)
end_define

begin_define
define|#
directive|define
name|Locparent
parameter_list|(
name|pp
parameter_list|)
value|(Uniqp(pp),&Parent(*(pp)))
end_define

begin_define
define|#
directive|define
name|Loctree
parameter_list|(
name|pp
parameter_list|)
value|(Uniqp(pp),&Tree(*(pp)))
end_define

begin_define
define|#
directive|define
name|Addmarks
parameter_list|(
name|pp
parameter_list|,
name|x
parameter_list|)
value|(Uniqp(pp), \ 	(*(pp))->p_addmarks |= (x), (*(pp))->p_delmarks&= ~(x))
end_define

begin_define
define|#
directive|define
name|Delmarks
parameter_list|(
name|pp
parameter_list|,
name|x
parameter_list|)
value|(Uniqp(pp), \ 	(*(pp))->p_delmarks |= (x), (*(pp))->p_addmarks&= ~(x))
end_define

begin_function
name|Hidden
name|Procedure
name|connect
parameter_list|(
name|pp
parameter_list|)
name|path
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|path
name|p
init|=
operator|*
name|pp
decl_stmt|;
specifier|register
name|path
name|pa
init|=
name|Parent
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|register
name|path
modifier|*
name|ppa
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
specifier|register
name|node
name|npa
decl_stmt|;
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
name|node
name|oldchild
decl_stmt|;
name|node
modifier|*
name|pnpa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|markbits
name|add
decl_stmt|;
name|markbits
name|del
decl_stmt|;
if|if
condition|(
operator|!
name|pa
condition|)
return|return;
name|i
operator|=
name|ichild
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|Tree
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|Child
argument_list|(
name|Tree
argument_list|(
name|pa
argument_list|)
argument_list|,
name|i
argument_list|)
operator|==
name|n
condition|)
return|return;
comment|/* Still connected */
name|n
operator|=
name|nodecopy
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ppa
operator|=
name|Locparent
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pnpa
operator|=
name|Loctree
argument_list|(
name|ppa
argument_list|)
expr_stmt|;
name|pn
operator|=
name|Locchild
argument_list|(
name|pnpa
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|oldchild
operator|=
operator|*
name|pn
expr_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
name|repwidth
argument_list|(
name|pnpa
argument_list|,
name|oldchild
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|noderelease
argument_list|(
name|oldchild
argument_list|)
expr_stmt|;
name|add
operator|=
name|p
operator|->
name|p_addmarks
expr_stmt|;
name|del
operator|=
name|p
operator|->
name|p_delmarks
expr_stmt|;
if|if
condition|(
name|add
operator||
name|del
condition|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
name|p
operator|->
name|p_addmarks
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_delmarks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|Addmarks
argument_list|(
name|ppa
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|npa
operator|=
operator|*
name|pnpa
expr_stmt|;
if|if
condition|(
name|del
condition|)
block|{
for|for
control|(
name|i
operator|=
name|Nchildren
argument_list|(
name|npa
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|ichild
argument_list|(
name|p
argument_list|)
condition|)
name|del
operator|&=
operator|~
name|marks
argument_list|(
name|Child
argument_list|(
name|npa
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|Delmarks
argument_list|(
name|ppa
argument_list|,
name|del
argument_list|)
expr_stmt|;
block|}
name|Setmarks
argument_list|(
name|pnpa
argument_list|,
name|Marks
argument_list|(
name|npa
argument_list|)
operator|&
operator|~
name|del
operator||
name|add
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The following procedure sets the new width of node *pn when child  * oldchild is replaced by child newchild.  * This was added because the original call to evalwidth seemed to  * be the major caller of noderepr() and fwidth().  */
end_comment

begin_function
name|Hidden
name|Procedure
name|repwidth
parameter_list|(
name|pn
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|)
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
name|Register
name|node
name|old
decl_stmt|;
name|Register
name|node
name|new
decl_stmt|;
block|{
specifier|register
name|int
name|w
init|=
name|Width
argument_list|(
operator|*
name|pn
argument_list|)
decl_stmt|;
specifier|register
name|int
name|oldwidth
init|=
name|width
argument_list|(
name|old
argument_list|)
decl_stmt|;
specifier|register
name|int
name|newwidth
init|=
name|width
argument_list|(
name|new
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|oldwidth
operator|>
literal|0
condition|)
name|oldwidth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newwidth
operator|>
literal|0
condition|)
name|newwidth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Assert
argument_list|(
name|oldwidth
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newwidth
operator|<
literal|0
condition|)
block|{
name|Setwidth
argument_list|(
name|pn
argument_list|,
name|newwidth
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|newwidth
operator|-=
name|oldwidth
expr_stmt|;
if|if
condition|(
name|newwidth
condition|)
name|Setwidth
argument_list|(
name|pn
argument_list|,
name|w
operator|+
name|newwidth
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|markpath
parameter_list|(
name|pp
parameter_list|,
name|new
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|markbits
name|new
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
specifier|register
name|markbits
name|old
decl_stmt|;
name|Assert
argument_list|(
name|Type
argument_list|(
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
operator|==
name|Nod
argument_list|)
expr_stmt|;
name|old
operator|=
name|Marks
argument_list|(
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator||
name|new
operator|)
operator|==
name|old
condition|)
return|return;
comment|/* Bits already set */
name|pn
operator|=
name|Loctree
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|Setmarks
argument_list|(
name|pn
argument_list|,
name|old
operator||
name|new
argument_list|)
expr_stmt|;
name|Addmarks
argument_list|(
name|pp
argument_list|,
name|new
operator|&
operator|~
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|unmkpath
parameter_list|(
name|pp
parameter_list|,
name|del
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|del
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
specifier|register
name|markbits
name|old
decl_stmt|;
name|Assert
argument_list|(
name|Type
argument_list|(
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
operator|==
name|Nod
argument_list|)
expr_stmt|;
name|old
operator|=
name|Marks
argument_list|(
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|&
operator|~
name|del
operator|)
operator|==
name|del
condition|)
return|return;
name|pn
operator|=
name|Loctree
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|Setmarks
argument_list|(
name|pn
argument_list|,
name|old
operator|&
operator|~
name|del
argument_list|)
expr_stmt|;
name|Delmarks
argument_list|(
name|pp
argument_list|,
name|del
operator|&
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|clearmarks
parameter_list|(
name|pn
parameter_list|)
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|Marks
argument_list|(
operator|*
name|pn
argument_list|)
condition|)
return|return;
if|if
condition|(
name|Isnode
argument_list|(
operator|*
name|pn
argument_list|)
condition|)
block|{
name|Setmarks
argument_list|(
name|pn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Nchildren
argument_list|(
operator|*
name|pn
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|clearmarks
argument_list|(
name|Locchild
argument_list|(
name|pn
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Replace the focus' tree by a new node.  * WARNING: n's reference count is not increased!  * You can also think of this as: replace(pp, n) implies noderelease(n).  * Mark bits are copied from the node being replaced.  */
end_comment

begin_function
name|Visible
name|Procedure
name|replace
parameter_list|(
name|pp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|pn
decl_stmt|;
specifier|register
name|markbits
name|old
decl_stmt|;
name|pn
operator|=
name|Loctree
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
operator|*
name|pn
argument_list|)
operator|==
name|Nod
condition|)
name|old
operator|=
name|Marks
argument_list|(
operator|*
name|pn
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
literal|0
expr_stmt|;
name|noderelease
argument_list|(
operator|*
name|pn
argument_list|)
expr_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Nod
condition|)
block|{
name|clearmarks
argument_list|(
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
name|Setmarks
argument_list|(
name|pn
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old
condition|)
name|Addmarks
argument_list|(
name|pp
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|up
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|path
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|Parent
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|No
return|;
name|connect
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|p
operator|=
name|pathcopy
argument_list|(
name|Parent
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|pathrelease
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|downi
parameter_list|(
name|pp
parameter_list|,
name|i
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|node
name|n
decl_stmt|;
specifier|auto
name|int
name|y
decl_stmt|;
specifier|auto
name|int
name|x
decl_stmt|;
specifier|auto
name|int
name|level
decl_stmt|;
name|n
operator|=
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Isnode
argument_list|(
name|n
argument_list|)
operator|||
name|i
operator|<
literal|1
operator|||
name|i
operator|>
name|Nchildren
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|No
return|;
name|y
operator|=
name|Ycoord
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
name|x
operator|=
name|Xcoord
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
name|level
operator|=
name|Level
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|newpath
argument_list|(
operator|*
name|pp
argument_list|,
name|nodecopy
argument_list|(
name|Child
argument_list|(
name|n
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|evalcoord
argument_list|(
name|n
argument_list|,
name|i
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
name|Setcoord
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|downrite
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Isnode
argument_list|(
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
condition|)
return|return
name|No
return|;
return|return
name|downi
argument_list|(
name|pp
argument_list|,
name|Nchildren
argument_list|(
name|Tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|left
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ichild
argument_list|(
operator|*
name|pp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
name|up
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
return|return
name|downi
argument_list|(
name|pp
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|rite
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|path
name|pa
init|=
name|Parent
argument_list|(
operator|*
name|pp
argument_list|)
decl_stmt|;
name|i
operator|=
name|ichild
argument_list|(
operator|*
name|pp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pa
operator|||
name|i
operator|>
name|Nchildren
argument_list|(
name|Tree
argument_list|(
name|pa
argument_list|)
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
name|up
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
return|return
name|downi
argument_list|(
name|pp
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Highest level: small utilities.  *  * WARNING: Several of the following routines may change their argument  * even if they return No.  * HINT: Some of these routines are not used; they are included for  * completeness of the provided set of operators only.  If you have  * space problems (as, e.g., on a PDP-11), you can delete the superfluous  * ones (lint will tell you which they are).  */
end_comment

begin_function
name|Visible
name|Procedure
name|top
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
while|while
condition|(
name|up
argument_list|(
name|pp
argument_list|)
condition|)
empty_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|nextnode
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|rite
argument_list|(
name|pp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|up
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|firstleaf
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
while|while
condition|(
name|down
argument_list|(
name|pp
argument_list|)
condition|)
empty_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NOT_USED
end_if

begin_function
name|Visible
name|bool
name|nextleaf
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|nextnode
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
name|firstleaf
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|NOT_USED
end_endif

begin_function
name|Visible
name|bool
name|prevnode
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|left
argument_list|(
name|pp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|up
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|lastleaf
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
while|while
condition|(
name|downrite
argument_list|(
name|pp
argument_list|)
condition|)
empty_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Visible
name|bool
name|prevleaf
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|prevnode
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
name|lastleaf
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|nextmarked
parameter_list|(
name|pp
parameter_list|,
name|x
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|markbits
name|x
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|!
name|nextnode
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
block|}
do|while
condition|(
operator|!
name|marked
argument_list|(
operator|*
name|pp
argument_list|,
name|x
argument_list|)
condition|)
do|;
while|while
condition|(
name|down
argument_list|(
name|pp
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|marked
argument_list|(
operator|*
name|pp
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rite
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|up
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|NOT_UED
end_endif

begin_function
name|Visible
name|bool
name|firstmarked
parameter_list|(
name|pp
parameter_list|,
name|x
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|markbits
name|x
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|marked
argument_list|(
operator|*
name|pp
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|up
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
block|}
while|while
condition|(
name|down
argument_list|(
name|pp
argument_list|)
condition|)
block|{
while|while
condition|(
name|Type
argument_list|(
name|tree
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
operator|==
name|Tex
operator|||
operator|!
name|marked
argument_list|(
operator|*
name|pp
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rite
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|up
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|prevmarked
parameter_list|(
name|pp
parameter_list|,
name|x
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
specifier|register
name|markbits
name|x
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|!
name|prevnode
argument_list|(
name|pp
argument_list|)
condition|)
return|return
name|No
return|;
block|}
do|while
condition|(
operator|!
name|marked
argument_list|(
operator|*
name|pp
argument_list|,
name|x
argument_list|)
condition|)
do|;
while|while
condition|(
name|downrite
argument_list|(
name|pp
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|marked
argument_list|(
operator|*
name|pp
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|left
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|up
argument_list|(
name|pp
argument_list|)
operator|||
name|Abort
argument_list|()
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Deliver the path length to the root.  */
end_comment

begin_function
name|Visible
name|Procedure
name|pathlength
parameter_list|(
name|p
parameter_list|)
specifier|register
name|path
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
condition|;
operator|++
name|n
control|)
name|p
operator|=
name|parent
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Put a C string in a trimmed location (this name should change,  * the 'official' routine of this name has quite different parameters).  */
end_comment

begin_function
name|Visible
name|Procedure
name|putintrim
parameter_list|(
name|pn
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|,
name|str
parameter_list|)
specifier|register
name|value
modifier|*
name|pn
decl_stmt|;
specifier|register
name|int
name|head
decl_stmt|;
name|Register
name|int
name|tail
decl_stmt|;
name|Register
name|string
name|str
decl_stmt|;
block|{
specifier|register
name|value
name|v
init|=
operator|*
name|pn
decl_stmt|;
name|value
name|w
init|=
name|head
operator|==
literal|0
condition|?
name|mk_text
argument_list|(
literal|""
argument_list|)
else|:
name|head
operator|==
name|Length
argument_list|(
name|v
argument_list|)
condition|?
name|copy
argument_list|(
name|v
argument_list|)
else|:
name|trim
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|Length
argument_list|(
name|v
argument_list|)
operator|-
name|head
argument_list|)
decl_stmt|;
name|Assert
argument_list|(
name|head
operator|>=
literal|0
operator|&&
name|tail
operator|>=
literal|0
operator|&&
name|head
operator|+
name|tail
operator|<=
name|Length
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
name|concato
argument_list|(
operator|&
name|w
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|>
literal|0
condition|)
name|concato
argument_list|(
operator|&
name|w
argument_list|,
name|Str
argument_list|(
name|v
argument_list|)
operator|+
operator|(
name|Length
argument_list|(
name|v
argument_list|)
operator|-
name|tail
operator|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
operator|*
name|pn
operator|=
name|w
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Touch the node in focus.  */
end_comment

begin_function
name|Visible
name|Procedure
name|touchpath
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|path
modifier|*
name|pp
decl_stmt|;
block|{
name|nodeuniql
argument_list|(
name|Loctree
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

