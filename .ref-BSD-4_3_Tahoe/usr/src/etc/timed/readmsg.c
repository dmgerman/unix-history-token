begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)readmsg.c	2.11 (Berkeley) 6/18/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<protocols/timed.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tsptype
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * LOOKAT checks if the message is of the requested type and comes from  * the right machine, returning 1 in case of affirmative answer   */
end_comment

begin_define
define|#
directive|define
name|LOOKAT
parameter_list|(
name|msg
parameter_list|,
name|mtype
parameter_list|,
name|mfrom
parameter_list|,
name|netp
parameter_list|,
name|froms
parameter_list|)
define|\
value|(((((mtype) == TSP_ANY) || ((mtype) == (msg).tsp_type))&& \ 	(((mfrom) == NULL) || (strcmp((mfrom), (msg).tsp_name) == 0))&& \ 	(((netp) == NULL) || \ 	(((netp)->mask& (froms).sin_addr.s_addr) == (netp)->net))) \ 	? 1 : 0)
end_define

begin_define
define|#
directive|define
name|MORETIME
parameter_list|(
name|rtime
parameter_list|,
name|rtout
parameter_list|)
define|\
value|(((rtime).tv_sec> (rtout).tv_sec || \ 	    ((rtime).tv_sec == (rtout).tv_sec&& \ 		(rtime).tv_usec>= (rtout).tv_usec)) \ 	? 0 : 1)
end_define

begin_decl_stmt
name|struct
name|timeval
name|rtime
decl_stmt|,
name|rwait
decl_stmt|,
name|rtout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tsp
name|msgin
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|tsplist
block|{
name|struct
name|tsp
name|info
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|struct
name|tsplist
modifier|*
name|p
decl_stmt|;
block|}
name|msgslist
struct|;
end_struct

begin_decl_stmt
name|struct
name|sockaddr_in
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|fromnet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * `readmsg' returns message `type' sent by `machfrom' if it finds it   * either in the receive queue, or in a linked list of previously received   * messages that it maintains.  * Otherwise it waits to see if the appropriate message arrives within  * `intvl' seconds. If not, it returns NULL.  */
end_comment

begin_function
name|struct
name|tsp
modifier|*
name|readmsg
parameter_list|(
name|type
parameter_list|,
name|machfrom
parameter_list|,
name|intvl
parameter_list|,
name|netfrom
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|machfrom
decl_stmt|;
name|struct
name|timeval
modifier|*
name|intvl
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|netfrom
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|fd_set
name|ready
decl_stmt|;
specifier|static
name|struct
name|tsplist
modifier|*
name|head
init|=
operator|&
name|msgslist
decl_stmt|;
specifier|static
name|struct
name|tsplist
modifier|*
name|tail
init|=
operator|&
name|msgslist
decl_stmt|;
name|struct
name|tsplist
modifier|*
name|prev
decl_stmt|;
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
specifier|register
name|struct
name|tsplist
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"looking for %s from %s\n"
argument_list|,
name|tsptype
index|[
name|type
index|]
argument_list|,
name|machfrom
operator|==
name|NULL
condition|?
literal|"ANY"
else|:
name|machfrom
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|head
operator|->
name|p
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"msgqueue:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|ptr
operator|->
name|info
argument_list|,
operator|&
name|ptr
operator|->
name|addr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|p
expr_stmt|;
block|}
block|}
name|ptr
operator|=
name|head
operator|->
name|p
expr_stmt|;
name|prev
operator|=
name|head
expr_stmt|;
comment|/* 	 * Look for the requested message scanning through the  	 * linked list. If found, return it and free the space  	 */
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LOOKAT
argument_list|(
name|ptr
operator|->
name|info
argument_list|,
name|type
argument_list|,
name|machfrom
argument_list|,
name|netfrom
argument_list|,
name|ptr
operator|->
name|addr
argument_list|)
condition|)
block|{
name|msgin
operator|=
name|ptr
operator|->
name|info
expr_stmt|;
name|from
operator|=
name|ptr
operator|->
name|addr
expr_stmt|;
name|prev
operator|->
name|p
operator|=
name|ptr
operator|->
name|p
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|tail
condition|)
name|tail
operator|=
name|prev
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|fromnet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|netfrom
operator|==
name|NULL
condition|)
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|ntp
operator|->
name|mask
operator|&
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|==
name|ntp
operator|->
name|net
condition|)
block|{
name|fromnet
operator|=
name|ntp
expr_stmt|;
break|break;
block|}
block|}
else|else
name|fromnet
operator|=
name|netfrom
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"readmsg: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|msgin
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|msgin
operator|)
return|;
block|}
else|else
block|{
name|prev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|p
expr_stmt|;
block|}
block|}
comment|/* 	 * If the message was not in the linked list, it may still be 	 * coming from the network. Set the timer and wait  	 * on a select to read the next incoming message: if it is the 	 * right one, return it, otherwise insert it in the linked list. 	 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|rtime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rtout
operator|.
name|tv_sec
operator|=
name|rtime
operator|.
name|tv_sec
operator|+
name|intvl
operator|->
name|tv_sec
expr_stmt|;
name|rtout
operator|.
name|tv_usec
operator|=
name|rtime
operator|.
name|tv_usec
operator|+
name|intvl
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|rtout
operator|.
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|rtout
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|rtout
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
name|FD_ZERO
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|MORETIME
argument_list|(
name|rtime
argument_list|,
name|rtout
argument_list|)
condition|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|rtime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
control|)
block|{
name|rwait
operator|.
name|tv_sec
operator|=
name|rtout
operator|.
name|tv_sec
operator|-
name|rtime
operator|.
name|tv_sec
expr_stmt|;
name|rwait
operator|.
name|tv_usec
operator|=
name|rtout
operator|.
name|tv_usec
operator|-
name|rtime
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|rwait
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|rwait
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|rwait
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rwait
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|rwait
operator|.
name|tv_sec
operator|=
name|rwait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"readmsg: wait: (%d %d)\n"
argument_list|,
name|rwait
operator|.
name|tv_sec
argument_list|,
name|rwait
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|ready
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rwait
argument_list|)
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvfrom
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msgin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"receiving datagram packet: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bytehostorder
argument_list|(
operator|&
name|msgin
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgin
operator|.
name|tsp_vers
operator|>
name|TSPVERSION
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"readmsg: version mismatch\n"
argument_list|)
expr_stmt|;
comment|/* should do a dump of the packet, but... */
block|}
continue|continue;
block|}
name|fromnet
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|ntp
operator|->
name|mask
operator|&
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|==
name|ntp
operator|->
name|net
condition|)
block|{
name|fromnet
operator|=
name|ntp
expr_stmt|;
break|break;
block|}
comment|/* 			 * drop packets from nets we are ignoring permanently 			 */
if|if
condition|(
name|fromnet
operator|==
name|NULL
condition|)
block|{
comment|/*  				 * The following messages may originate on 				 * this host with an ignored network address 				 */
if|if
condition|(
name|msgin
operator|.
name|tsp_type
operator|!=
name|TSP_TRACEON
operator|&&
name|msgin
operator|.
name|tsp_type
operator|!=
name|TSP_SETDATE
operator|&&
name|msgin
operator|.
name|tsp_type
operator|!=
name|TSP_MSITE
operator|&&
ifdef|#
directive|ifdef
name|TESTING
name|msgin
operator|.
name|tsp_type
operator|!=
name|TSP_TEST
operator|&&
endif|#
directive|endif
name|msgin
operator|.
name|tsp_type
operator|!=
name|TSP_TRACEOFF
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"readmsg: discarded: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|msgin
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|/* 			 * Throw away messages coming from this machine, unless 			 * they are of some particular type. 			 * This gets rid of broadcast messages and reduces 			 * master processing time. 			 */
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|msgin
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
operator|!=
literal|0
operator|||
name|msgin
operator|.
name|tsp_type
operator|==
name|TSP_SETDATE
operator|||
ifdef|#
directive|ifdef
name|TESTING
name|msgin
operator|.
name|tsp_type
operator|==
name|TSP_TEST
operator|||
endif|#
directive|endif
name|msgin
operator|.
name|tsp_type
operator|==
name|TSP_MSITE
operator|||
operator|(
name|msgin
operator|.
name|tsp_type
operator|==
name|TSP_LOOP
operator|&&
name|msgin
operator|.
name|tsp_hopcnt
operator|!=
literal|10
operator|)
operator|||
name|msgin
operator|.
name|tsp_type
operator|==
name|TSP_TRACEON
operator|||
name|msgin
operator|.
name|tsp_type
operator|==
name|TSP_TRACEOFF
operator|)
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"readmsg: discarded: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|msgin
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 			 * Send acknowledgements here; this is faster and avoids 			 * deadlocks that would occur if acks were sent from a  			 * higher level routine.  Different acknowledgements are 			 * necessary, depending on status. 			 */
if|if
condition|(
name|fromnet
operator|->
name|status
operator|==
name|MASTER
condition|)
name|masterack
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|fromnet
operator|->
name|status
operator|==
name|SLAVE
condition|)
name|slaveack
argument_list|()
expr_stmt|;
else|else
name|ignoreack
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOOKAT
argument_list|(
name|msgin
argument_list|,
name|type
argument_list|,
name|machfrom
argument_list|,
name|netfrom
argument_list|,
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"readmsg: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|msgin
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|msgin
operator|)
return|;
block|}
else|else
block|{
name|tail
operator|->
name|p
operator|=
operator|(
expr|struct
name|tsplist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tsplist
argument_list|)
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|p
expr_stmt|;
name|tail
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
name|tail
operator|->
name|info
operator|=
name|msgin
expr_stmt|;
name|tail
operator|->
name|addr
operator|=
name|from
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
operator|(
operator|(
expr|struct
name|tsp
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * `slaveack' sends the necessary acknowledgements:   * only the type ACK is to be sent by a slave   */
end_comment

begin_macro
name|slaveack
argument_list|()
end_macro

begin_block
block|{
name|int
name|length
decl_stmt|;
name|struct
name|tsp
name|resp
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msgin
operator|.
name|tsp_type
condition|)
block|{
case|case
name|TSP_ADJTIME
case|:
case|case
name|TSP_SETTIME
case|:
case|case
name|TSP_ACCEPT
case|:
case|case
name|TSP_REFUSE
case|:
case|case
name|TSP_TRACEON
case|:
case|case
name|TSP_TRACEOFF
case|:
case|case
name|TSP_QUIT
case|:
name|resp
operator|=
name|msgin
expr_stmt|;
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_ACK
expr_stmt|;
name|resp
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Slaveack: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
name|bytenetorder
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* this is not really necessary here */
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Certain packets may arrive from this machine on ignored networks.  * These packets should be acknowledged.  */
end_comment

begin_macro
name|ignoreack
argument_list|()
end_macro

begin_block
block|{
name|int
name|length
decl_stmt|;
name|struct
name|tsp
name|resp
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msgin
operator|.
name|tsp_type
condition|)
block|{
case|case
name|TSP_TRACEON
case|:
case|case
name|TSP_TRACEOFF
case|:
name|resp
operator|=
name|msgin
expr_stmt|;
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_ACK
expr_stmt|;
name|resp
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Ignoreack: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
name|bytenetorder
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* this is not really necessary here */
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * `masterack' sends the necessary acknowledgments   * to the messages received by a master   */
end_comment

begin_macro
name|masterack
argument_list|()
end_macro

begin_block
block|{
name|int
name|length
decl_stmt|;
name|struct
name|tsp
name|resp
decl_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|resp
operator|=
name|msgin
expr_stmt|;
name|resp
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msgin
operator|.
name|tsp_type
condition|)
block|{
case|case
name|TSP_QUIT
case|:
case|case
name|TSP_TRACEON
case|:
case|case
name|TSP_TRACEOFF
case|:
case|case
name|TSP_MSITE
case|:
case|case
name|TSP_MSITEREQ
case|:
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_ACK
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Masterack: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TSP_RESOLVE
case|:
case|case
name|TSP_MASTERREQ
case|:
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_MASTERACK
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Masterack: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TSP_SETDATEREQ
case|:
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_DATEACK
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Masterack: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Print a TSP message   */
end_comment

begin_macro
name|print
argument_list|(
argument|msg
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|msg
operator|->
name|tsp_type
condition|)
block|{
case|case
name|TSP_LOOP
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s %d %d (#%d) %s %s\n"
argument_list|,
name|tsptype
index|[
name|msg
operator|->
name|tsp_type
index|]
argument_list|,
name|msg
operator|->
name|tsp_vers
argument_list|,
name|msg
operator|->
name|tsp_seq
argument_list|,
name|msg
operator|->
name|tsp_hopcnt
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_SETTIME
case|:
case|case
name|TSP_ADJTIME
case|:
case|case
name|TSP_SETDATE
case|:
case|case
name|TSP_SETDATEREQ
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s %d %d (%d, %d) %s %s\n"
argument_list|,
name|tsptype
index|[
name|msg
operator|->
name|tsp_type
index|]
argument_list|,
name|msg
operator|->
name|tsp_vers
argument_list|,
name|msg
operator|->
name|tsp_seq
argument_list|,
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|,
name|msg
operator|->
name|tsp_time
operator|.
name|tv_usec
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s %d %d %s %s\n"
argument_list|,
name|tsptype
index|[
name|msg
operator|->
name|tsp_type
index|]
argument_list|,
name|msg
operator|->
name|tsp_vers
argument_list|,
name|msg
operator|->
name|tsp_seq
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

