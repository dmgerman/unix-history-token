begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)zic.c	1.3 (Berkeley) 10/22/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/stat.h"
end_include

begin_include
include|#
directive|include
file|"sys/file.h"
end_include

begin_include
include|#
directive|include
file|"strings.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"tzfile.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BUFSIZ
end_ifndef

begin_define
define|#
directive|define
name|BUFSIZ
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|icpyalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|imalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|irealloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|scheck
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|addtt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|addtype
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|associate
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|charcnt
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|ciequal
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|long
name|eitol
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|getfields
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|gethms
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|infile
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|inlink
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|inrule
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|inzcont
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|inzone
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|inzsub
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|lowerit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|time_t
name|max_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|min_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_year
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|mkdirs
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|newabbr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|noise
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|nondunlink
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|long
name|oadd
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|outzone
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rlinenum
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|time_t
name|rpytime
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|rulesub
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|setboundaries
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|time_t
name|tadd
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|timecnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tt_signed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typecnt
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|yearistype
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Line codes. */
end_comment

begin_define
define|#
directive|define
name|LC_RULE
value|0
end_define

begin_define
define|#
directive|define
name|LC_ZONE
value|1
end_define

begin_define
define|#
directive|define
name|LC_LINK
value|2
end_define

begin_comment
comment|/* ** Which fields are which on a Zone line. */
end_comment

begin_define
define|#
directive|define
name|ZF_NAME
value|1
end_define

begin_define
define|#
directive|define
name|ZF_GMTOFF
value|2
end_define

begin_define
define|#
directive|define
name|ZF_RULE
value|3
end_define

begin_define
define|#
directive|define
name|ZF_FORMAT
value|4
end_define

begin_define
define|#
directive|define
name|ZF_UNTILYEAR
value|5
end_define

begin_define
define|#
directive|define
name|ZF_UNTILMONTH
value|6
end_define

begin_define
define|#
directive|define
name|ZF_UNTILDAY
value|7
end_define

begin_define
define|#
directive|define
name|ZF_UNTILTIME
value|8
end_define

begin_define
define|#
directive|define
name|ZONE_MINFIELDS
value|5
end_define

begin_define
define|#
directive|define
name|ZONE_MAXFIELDS
value|9
end_define

begin_comment
comment|/* ** Which fields are which on a Zone continuation line. */
end_comment

begin_define
define|#
directive|define
name|ZFC_GMTOFF
value|0
end_define

begin_define
define|#
directive|define
name|ZFC_RULE
value|1
end_define

begin_define
define|#
directive|define
name|ZFC_FORMAT
value|2
end_define

begin_define
define|#
directive|define
name|ZFC_UNTILYEAR
value|3
end_define

begin_define
define|#
directive|define
name|ZFC_UNTILMONTH
value|4
end_define

begin_define
define|#
directive|define
name|ZFC_UNTILDAY
value|5
end_define

begin_define
define|#
directive|define
name|ZFC_UNTILTIME
value|6
end_define

begin_define
define|#
directive|define
name|ZONEC_MINFIELDS
value|3
end_define

begin_define
define|#
directive|define
name|ZONEC_MAXFIELDS
value|7
end_define

begin_comment
comment|/* ** Which files are which on a Rule line. */
end_comment

begin_define
define|#
directive|define
name|RF_NAME
value|1
end_define

begin_define
define|#
directive|define
name|RF_LOYEAR
value|2
end_define

begin_define
define|#
directive|define
name|RF_HIYEAR
value|3
end_define

begin_define
define|#
directive|define
name|RF_COMMAND
value|4
end_define

begin_define
define|#
directive|define
name|RF_MONTH
value|5
end_define

begin_define
define|#
directive|define
name|RF_DAY
value|6
end_define

begin_define
define|#
directive|define
name|RF_TOD
value|7
end_define

begin_define
define|#
directive|define
name|RF_STDOFF
value|8
end_define

begin_define
define|#
directive|define
name|RF_ABBRVAR
value|9
end_define

begin_define
define|#
directive|define
name|RULE_FIELDS
value|10
end_define

begin_comment
comment|/* ** Which fields are which on a Link line. */
end_comment

begin_define
define|#
directive|define
name|LF_FROM
value|1
end_define

begin_define
define|#
directive|define
name|LF_TO
value|2
end_define

begin_define
define|#
directive|define
name|LINK_FIELDS
value|3
end_define

begin_struct
struct|struct
name|rule
block|{
name|char
modifier|*
name|r_filename
decl_stmt|;
name|int
name|r_linenum
decl_stmt|;
name|char
modifier|*
name|r_name
decl_stmt|;
name|int
name|r_loyear
decl_stmt|;
comment|/* for example, 1986 */
name|int
name|r_hiyear
decl_stmt|;
comment|/* for example, 1986 */
name|char
modifier|*
name|r_yrtype
decl_stmt|;
name|int
name|r_month
decl_stmt|;
comment|/* 0..11 */
name|int
name|r_dycode
decl_stmt|;
comment|/* see below */
name|int
name|r_dayofmonth
decl_stmt|;
name|int
name|r_wday
decl_stmt|;
name|long
name|r_tod
decl_stmt|;
comment|/* time from midnight */
name|int
name|r_todisstd
decl_stmt|;
comment|/* above is standard time if TRUE */
comment|/* above is wall clock time if FALSE */
name|long
name|r_stdoff
decl_stmt|;
comment|/* offset from standard time */
name|char
modifier|*
name|r_abbrvar
decl_stmt|;
comment|/* variable part of time zone abbreviation */
name|int
name|r_todo
decl_stmt|;
comment|/* a rule to do (used in outzone) */
name|time_t
name|r_temp
decl_stmt|;
comment|/* used in outzone */
block|}
struct|;
end_struct

begin_comment
comment|/* **	r_dycode		r_dayofmonth	r_wday */
end_comment

begin_define
define|#
directive|define
name|DC_DOM
value|0
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* unused */
end_comment

begin_define
define|#
directive|define
name|DC_DOWGEQ
value|1
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* 0..6 (Sun..Sat) */
end_comment

begin_define
define|#
directive|define
name|DC_DOWLEQ
value|2
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* 0..6 (Sun..Sat) */
end_comment

begin_comment
comment|/* ** Year synonyms. */
end_comment

begin_define
define|#
directive|define
name|YR_MINIMUM
value|0
end_define

begin_define
define|#
directive|define
name|YR_MAXIMUM
value|1
end_define

begin_define
define|#
directive|define
name|YR_ONLY
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|rule
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nrules
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of rules */
end_comment

begin_struct
struct|struct
name|zone
block|{
name|char
modifier|*
name|z_filename
decl_stmt|;
name|int
name|z_linenum
decl_stmt|;
name|char
modifier|*
name|z_name
decl_stmt|;
name|long
name|z_gmtoff
decl_stmt|;
name|char
modifier|*
name|z_rule
decl_stmt|;
name|char
modifier|*
name|z_format
decl_stmt|;
name|long
name|z_stdoff
decl_stmt|;
name|struct
name|rule
modifier|*
name|z_rules
decl_stmt|;
name|int
name|z_nrules
decl_stmt|;
name|struct
name|rule
name|z_untilrule
decl_stmt|;
name|time_t
name|z_untiltime
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|zone
modifier|*
name|zones
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nzones
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of zones */
end_comment

begin_struct
struct|struct
name|link
block|{
name|char
modifier|*
name|l_filename
decl_stmt|;
name|int
name|l_linenum
decl_stmt|;
name|char
modifier|*
name|l_from
decl_stmt|;
name|char
modifier|*
name|l_to
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|link
modifier|*
name|links
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlinks
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lookup
block|{
name|char
modifier|*
name|l_word
decl_stmt|;
name|int
name|l_value
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|lookup
modifier|*
name|byword
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|lookup
name|line_codes
index|[]
init|=
block|{
literal|"Rule"
block|,
name|LC_RULE
block|,
literal|"Zone"
block|,
name|LC_ZONE
block|,
literal|"Link"
block|,
name|LC_LINK
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
name|mon_names
index|[]
init|=
block|{
literal|"January"
block|,
name|TM_JANUARY
block|,
literal|"February"
block|,
name|TM_FEBRUARY
block|,
literal|"March"
block|,
name|TM_MARCH
block|,
literal|"April"
block|,
name|TM_APRIL
block|,
literal|"May"
block|,
name|TM_MAY
block|,
literal|"June"
block|,
name|TM_JUNE
block|,
literal|"July"
block|,
name|TM_JULY
block|,
literal|"August"
block|,
name|TM_AUGUST
block|,
literal|"September"
block|,
name|TM_SEPTEMBER
block|,
literal|"October"
block|,
name|TM_OCTOBER
block|,
literal|"November"
block|,
name|TM_NOVEMBER
block|,
literal|"December"
block|,
name|TM_DECEMBER
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
name|wday_names
index|[]
init|=
block|{
literal|"Sunday"
block|,
name|TM_SUNDAY
block|,
literal|"Monday"
block|,
name|TM_MONDAY
block|,
literal|"Tuesday"
block|,
name|TM_TUESDAY
block|,
literal|"Wednesday"
block|,
name|TM_WEDNESDAY
block|,
literal|"Thursday"
block|,
name|TM_THURSDAY
block|,
literal|"Friday"
block|,
name|TM_FRIDAY
block|,
literal|"Saturday"
block|,
name|TM_SATURDAY
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
name|lasts
index|[]
init|=
block|{
literal|"last-Sunday"
block|,
name|TM_SUNDAY
block|,
literal|"last-Monday"
block|,
name|TM_MONDAY
block|,
literal|"last-Tuesday"
block|,
name|TM_TUESDAY
block|,
literal|"last-Wednesday"
block|,
name|TM_WEDNESDAY
block|,
literal|"last-Thursday"
block|,
name|TM_THURSDAY
block|,
literal|"last-Friday"
block|,
name|TM_FRIDAY
block|,
literal|"last-Saturday"
block|,
name|TM_SATURDAY
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
name|begin_years
index|[]
init|=
block|{
literal|"minimum"
block|,
name|YR_MINIMUM
block|,
literal|"maximum"
block|,
name|YR_MAXIMUM
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
name|end_years
index|[]
init|=
block|{
literal|"minimum"
block|,
name|YR_MINIMUM
block|,
literal|"maximum"
block|,
name|YR_MAXIMUM
block|,
literal|"only"
block|,
name|YR_ONLY
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|len_months
index|[
literal|2
index|]
index|[
name|MONS_PER_YEAR
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|len_years
index|[
literal|2
index|]
init|=
block|{
name|DAYS_PER_NYEAR
block|,
name|DAYS_PER_LYEAR
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|ats
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|types
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|gmtoffs
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|isdsts
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|abbrinds
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|chars
index|[
name|TZ_MAX_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Memory allocation. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|memcheck
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_define
define|#
directive|define
name|emalloc
parameter_list|(
name|size
parameter_list|)
value|memcheck(imalloc(size))
end_define

begin_define
define|#
directive|define
name|erealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|memcheck(irealloc(ptr, size))
end_define

begin_define
define|#
directive|define
name|ecpyalloc
parameter_list|(
name|ptr
parameter_list|)
value|memcheck(icpyalloc(ptr))
end_define

begin_comment
comment|/* ** Error handling. */
end_comment

begin_expr_stmt
specifier|static
name|eats
argument_list|(
argument|name
argument_list|,
argument|num
argument_list|,
argument|rname
argument_list|,
argument|rnum
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|rname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|filename
operator|=
name|name
expr_stmt|;
name|linenum
operator|=
name|num
expr_stmt|;
name|rfilename
operator|=
name|rname
expr_stmt|;
name|rlinenum
operator|=
name|rnum
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|eat
argument_list|(
argument|name
argument_list|,
argument|num
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|eats
argument_list|(
name|name
argument_list|,
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|error
argument_list|(
argument|string
argument_list|)
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	** Match the format of "cc" to allow sh users to 	** 	zic ... 2>&1 | error -t "*" -v 	** on BSD systems. 	*/
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %d: %s"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfilename
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (rule from \"%s\", line %d)"
argument_list|,
name|rfilename
argument_list|,
name|rlinenum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|++
name|errors
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|usage
argument_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: usage is %s [ -v ] [ -l localtime ] [ -d directory ] [ filename ... ]\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; }
specifier|static
name|char
operator|*
name|lcltime
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|directory
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|unix
name|umask
argument_list|(
name|umask
argument_list|(
literal|022
argument_list|)
operator||
literal|022
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:l:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'d'
case|:
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
name|optarg
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: More than one -d option specified\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|lcltime
operator|==
name|NULL
condition|)
name|lcltime
operator|=
name|optarg
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: More than one -l option specified\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|noise
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* usage message by request */
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
name|TZDIR
expr_stmt|;
name|setboundaries
argument_list|()
expr_stmt|;
name|zones
operator|=
operator|(
expr|struct
name|zone
operator|*
operator|)
name|emalloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rules
operator|=
operator|(
expr|struct
name|rule
operator|*
operator|)
name|emalloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|links
operator|=
operator|(
expr|struct
name|link
operator|*
operator|)
name|emalloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|infile
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|associate
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
name|i
operator|=
name|j
control|)
block|{
comment|/* 		 * Find the next non-continuation zone entry. 		 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nzones
operator|&&
name|zones
index|[
name|j
index|]
operator|.
name|z_name
operator|==
name|NULL
condition|;
operator|++
name|j
control|)
empty_stmt|;
name|outzone
argument_list|(
operator|&
name|zones
index|[
name|i
index|]
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	** We'll take the easy way out on this last part. 	*/
if|if
condition|(
name|chdir
argument_list|(
name|directory
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't chdir to "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlinks
condition|;
operator|++
name|i
control|)
block|{
name|nondunlink
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_from
argument_list|,
name|links
index|[
name|i
index|]
operator|.
name|l_to
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't link %s to "
argument_list|,
name|progname
argument_list|,
name|links
index|[
name|i
index|]
operator|.
name|l_from
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_to
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lcltime
operator|!=
name|NULL
condition|)
block|{
name|nondunlink
argument_list|(
name|TZDEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|lcltime
argument_list|,
name|TZDEFAULT
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't link %s to "
argument_list|,
name|progname
argument_list|,
name|lcltime
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|TZDEFAULT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
operator|(
name|errors
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|setboundaries
argument_list|()
block|{
specifier|register
name|time_t
name|bit
block|;
for|for
control|(
name|bit
operator|=
literal|1
init|;
name|bit
operator|>
literal|0
condition|;
name|bit
operator|<<=
literal|1
control|)
empty_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
comment|/* time_t is an unsigned type */
name|tt_signed
operator|=
name|FALSE
expr_stmt|;
name|min_time
operator|=
literal|0
expr_stmt|;
name|max_time
operator|=
operator|~
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tt_signed
operator|=
name|TRUE
expr_stmt|;
name|min_time
operator|=
name|bit
expr_stmt|;
name|max_time
operator|=
name|bit
expr_stmt|;
operator|++
name|max_time
expr_stmt|;
name|max_time
operator|=
operator|-
name|max_time
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|min_year
operator|=
name|TM_YEAR_BASE
operator|+
name|gmtime
argument_list|(
operator|&
name|min_time
argument_list|)
operator|->
name|tm_year
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|max_year
operator|=
name|TM_YEAR_BASE
operator|+
name|gmtime
argument_list|(
operator|&
name|max_time
argument_list|)
operator|->
name|tm_year
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* ** We get to be careful here since there's a fair chance of root running us. */
end_comment

begin_macro
unit|static
name|nondunlink
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
return|return;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Associate sets of rules with zones. */
end_comment

begin_comment
comment|/* ** Sort by rule name. */
end_comment

begin_expr_stmt
specifier|static
name|rcomp
argument_list|(
argument|cp1
argument_list|,
argument|cp2
argument_list|)
name|char
operator|*
name|cp1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|cp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
expr|struct
name|rule
operator|*
operator|)
name|cp1
operator|)
operator|->
name|r_name
argument_list|,
operator|(
operator|(
expr|struct
name|rule
operator|*
operator|)
name|cp2
operator|)
operator|->
name|r_name
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|associate
argument_list|()
block|{
specifier|register
expr|struct
name|zone
operator|*
name|zp
block|;
specifier|register
expr|struct
name|rule
operator|*
name|rp
block|;
specifier|register
name|int
name|base
block|,
name|out
block|;
specifier|register
name|int
name|i
block|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rules
argument_list|,
name|nrules
argument_list|,
sizeof|sizeof
expr|*
name|rules
argument_list|,
name|rcomp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
name|zp
operator|->
name|z_rules
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_nrules
operator|=
literal|0
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|base
operator|=
literal|0
init|;
name|base
operator|<
name|nrules
condition|;
name|base
operator|=
name|out
control|)
block|{
name|rp
operator|=
operator|&
name|rules
index|[
name|base
index|]
expr_stmt|;
for|for
control|(
name|out
operator|=
name|base
operator|+
literal|1
init|;
name|out
operator|<
name|nrules
condition|;
operator|++
name|out
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rp
operator|->
name|r_name
argument_list|,
name|rules
index|[
name|out
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zp
operator|->
name|z_rule
argument_list|,
name|rp
operator|->
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|zp
operator|->
name|z_rules
operator|=
name|rp
expr_stmt|;
name|zp
operator|->
name|z_nrules
operator|=
name|out
operator|-
name|base
expr_stmt|;
block|}
block|}
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_nrules
operator|==
literal|0
condition|)
block|{
comment|/* 			** Maybe we have a local standard time offset. 			*/
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_stdoff
operator|=
name|gethms
argument_list|(
name|zp
operator|->
name|z_rule
argument_list|,
literal|"unruly zone"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			** Note, though, that if there's no rule, 			** a '%s' in the format is a bad thing. 			*/
if|if
condition|(
name|index
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'%'
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"%s in ruleless zone"
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_if

begin_macro
unit|}  static
name|infile
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|fields
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nfields
decl_stmt|;
specifier|register
name|int
name|wantcont
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
literal|"standard input"
expr_stmt|;
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wantcont
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|num
operator|=
literal|1
init|;
condition|;
operator|++
name|num
control|)
block|{
name|eat
argument_list|(
name|name
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|buf
condition|)
break|break;
name|cp
operator|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"line too long"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|fields
operator|=
name|getfields
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nfields
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fields
index|[
name|nfields
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ciequal
argument_list|(
name|fields
index|[
name|nfields
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|fields
index|[
name|nfields
index|]
operator|=
literal|""
expr_stmt|;
operator|++
name|nfields
expr_stmt|;
block|}
if|if
condition|(
name|nfields
operator|==
literal|0
condition|)
block|{
comment|/* nothing to do */
block|}
elseif|else
if|if
condition|(
name|wantcont
condition|)
block|{
name|wantcont
operator|=
name|inzcont
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|,
name|line_codes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"input line of unknown type"
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|lp
operator|->
name|l_value
argument_list|)
condition|)
block|{
case|case
name|LC_RULE
case|:
name|inrule
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LC_ZONE
case|:
name|wantcont
operator|=
name|inzone
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|LC_LINK
case|:
name|inlink
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: panic: Invalid l_value %d\n"
argument_list|,
name|progname
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error reading "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|stdin
operator|&&
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error closing "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wantcont
condition|)
name|error
argument_list|(
literal|"expected continuation line not found"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Convert a string of one of the forms **	h	-h 	hh:mm	-hh:mm	hh:mm:ss	-hh:mm:ss ** into a number of seconds. ** A null string maps to zero. ** Call error with errstring and return zero on errors. */
end_comment

begin_function
specifier|static
name|long
name|gethms
parameter_list|(
name|string
parameter_list|,
name|errstring
parameter_list|,
name|signable
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|errstring
decl_stmt|;
block|{
name|int
name|hh
decl_stmt|,
name|mm
decl_stmt|,
name|ss
decl_stmt|,
name|sign
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
operator|||
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|signable
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|string
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|)
operator|==
literal|1
condition|)
name|mm
operator|=
name|ss
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%d:%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|,
operator|&
name|mm
argument_list|)
operator|==
literal|2
condition|)
name|ss
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%d:%d:%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|,
operator|&
name|mm
argument_list|,
operator|&
name|ss
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hh
operator|<
literal|0
operator|||
name|hh
operator|>=
name|HOURS_PER_DAY
operator|||
name|mm
operator|<
literal|0
operator|||
name|mm
operator|>=
name|MINS_PER_HOUR
operator|||
name|ss
operator|<
literal|0
operator|||
name|ss
operator|>=
name|SECS_PER_MIN
condition|)
block|{
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|eitol
argument_list|(
name|sign
argument_list|)
operator|*
operator|(
name|eitol
argument_list|(
name|hh
operator|*
name|MINS_PER_HOUR
operator|+
name|mm
argument_list|)
operator|*
name|eitol
argument_list|(
name|SECS_PER_MIN
argument_list|)
operator|+
name|eitol
argument_list|(
name|ss
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|inrule
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|fields
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|struct
name|rule
name|r
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|RULE_FIELDS
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of fields on Rule line"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|RF_NAME
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"nameless rule"
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|.
name|r_filename
operator|=
name|filename
expr_stmt|;
name|r
operator|.
name|r_linenum
operator|=
name|linenum
expr_stmt|;
name|r
operator|.
name|r_stdoff
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|RF_STDOFF
index|]
argument_list|,
literal|"invalid saved time"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rulesub
argument_list|(
operator|&
name|r
argument_list|,
name|fields
index|[
name|RF_LOYEAR
index|]
argument_list|,
name|fields
index|[
name|RF_HIYEAR
index|]
argument_list|,
name|fields
index|[
name|RF_COMMAND
index|]
argument_list|,
name|fields
index|[
name|RF_MONTH
index|]
argument_list|,
name|fields
index|[
name|RF_DAY
index|]
argument_list|,
name|fields
index|[
name|RF_TOD
index|]
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_name
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|RF_NAME
index|]
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_abbrvar
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|RF_ABBRVAR
index|]
argument_list|)
expr_stmt|;
name|rules
operator|=
operator|(
expr|struct
name|rule
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rules
argument_list|,
operator|(
name|nrules
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|rules
argument_list|)
expr_stmt|;
name|rules
index|[
name|nrules
operator|++
index|]
operator|=
name|r
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|inzone
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|fields
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|132
index|]
decl_stmt|;
if|if
condition|(
name|nfields
operator|<
name|ZONE_MINFIELDS
operator|||
name|nfields
operator|>
name|ZONE_MAXFIELDS
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of fields on Zone line"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|TZDEFAULT
argument_list|)
operator|==
literal|0
operator|&&
name|lcltime
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"Zone %s\" line and -l option are mutually exclusive"
argument_list|,
name|TZDEFAULT
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|zones
index|[
name|i
index|]
operator|.
name|z_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zones
index|[
name|i
index|]
operator|.
name|z_name
argument_list|,
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"duplicate zone name %s (file \"%s\", line %d)"
argument_list|,
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|zones
index|[
name|i
index|]
operator|.
name|z_filename
argument_list|,
name|zones
index|[
name|i
index|]
operator|.
name|z_linenum
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|inzcont
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|fields
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|nfields
operator|<
name|ZONEC_MINFIELDS
operator|||
name|nfields
operator|>
name|ZONEC_MAXFIELDS
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of fields on Zone continuation line"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|iscont
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|fields
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|struct
name|zone
name|z
decl_stmt|;
specifier|register
name|int
name|i_gmtoff
decl_stmt|,
name|i_rule
decl_stmt|,
name|i_format
decl_stmt|;
specifier|register
name|int
name|i_untilyear
decl_stmt|,
name|i_untilmonth
decl_stmt|;
specifier|register
name|int
name|i_untilday
decl_stmt|,
name|i_untiltime
decl_stmt|;
specifier|register
name|int
name|hasuntil
decl_stmt|;
if|if
condition|(
name|iscont
condition|)
block|{
name|i_gmtoff
operator|=
name|ZFC_GMTOFF
expr_stmt|;
name|i_rule
operator|=
name|ZFC_RULE
expr_stmt|;
name|i_format
operator|=
name|ZFC_FORMAT
expr_stmt|;
name|i_untilyear
operator|=
name|ZFC_UNTILYEAR
expr_stmt|;
name|i_untilmonth
operator|=
name|ZFC_UNTILMONTH
expr_stmt|;
name|i_untilday
operator|=
name|ZFC_UNTILDAY
expr_stmt|;
name|i_untiltime
operator|=
name|ZFC_UNTILTIME
expr_stmt|;
name|z
operator|.
name|z_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|i_gmtoff
operator|=
name|ZF_GMTOFF
expr_stmt|;
name|i_rule
operator|=
name|ZF_RULE
expr_stmt|;
name|i_format
operator|=
name|ZF_FORMAT
expr_stmt|;
name|i_untilyear
operator|=
name|ZF_UNTILYEAR
expr_stmt|;
name|i_untilmonth
operator|=
name|ZF_UNTILMONTH
expr_stmt|;
name|i_untilday
operator|=
name|ZF_UNTILDAY
expr_stmt|;
name|i_untiltime
operator|=
name|ZF_UNTILTIME
expr_stmt|;
name|z
operator|.
name|z_name
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
expr_stmt|;
block|}
name|z
operator|.
name|z_filename
operator|=
name|filename
expr_stmt|;
name|z
operator|.
name|z_linenum
operator|=
name|linenum
expr_stmt|;
name|z
operator|.
name|z_gmtoff
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|i_gmtoff
index|]
argument_list|,
literal|"invalid GMT offset"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|fields
index|[
name|i_format
index|]
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
literal|'s'
operator|||
name|index
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid abbreviation format"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|z
operator|.
name|z_rule
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|i_rule
index|]
argument_list|)
expr_stmt|;
name|z
operator|.
name|z_format
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|i_format
index|]
argument_list|)
expr_stmt|;
name|hasuntil
operator|=
name|nfields
operator|>
name|i_untilyear
expr_stmt|;
if|if
condition|(
name|hasuntil
condition|)
block|{
name|z
operator|.
name|z_untilrule
operator|.
name|r_filename
operator|=
name|filename
expr_stmt|;
name|z
operator|.
name|z_untilrule
operator|.
name|r_linenum
operator|=
name|linenum
expr_stmt|;
name|rulesub
argument_list|(
operator|&
name|z
operator|.
name|z_untilrule
argument_list|,
name|fields
index|[
name|i_untilyear
index|]
argument_list|,
literal|"only"
argument_list|,
literal|""
argument_list|,
operator|(
name|nfields
operator|>
name|i_untilmonth
operator|)
condition|?
name|fields
index|[
name|i_untilmonth
index|]
else|:
literal|"Jan"
argument_list|,
operator|(
name|nfields
operator|>
name|i_untilday
operator|)
condition|?
name|fields
index|[
name|i_untilday
index|]
else|:
literal|"1"
argument_list|,
operator|(
name|nfields
operator|>
name|i_untiltime
operator|)
condition|?
name|fields
index|[
name|i_untiltime
index|]
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|z
operator|.
name|z_untiltime
operator|=
name|rpytime
argument_list|(
operator|&
name|z
operator|.
name|z_untilrule
argument_list|,
name|z
operator|.
name|z_untilrule
operator|.
name|r_loyear
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscont
operator|&&
name|nzones
operator|>
literal|0
operator|&&
name|z
operator|.
name|z_untiltime
operator|<
name|max_time
operator|&&
name|z
operator|.
name|z_untiltime
operator|>
name|min_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|>=
name|z
operator|.
name|z_untiltime
condition|)
block|{
name|error
argument_list|(
literal|"Zone continuation line end time is not after end time of previous line"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zones
operator|=
operator|(
expr|struct
name|zone
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zones
argument_list|,
operator|(
name|nzones
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|zones
argument_list|)
expr_stmt|;
name|zones
index|[
name|nzones
operator|++
index|]
operator|=
name|z
expr_stmt|;
comment|/* 	** If there was an UNTIL field on this line, 	** there's more information about the zone on the next line. 	*/
return|return
name|hasuntil
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|inlink
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|fields
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|link
name|l
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|LINK_FIELDS
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of fields on Link line"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|LF_FROM
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"blank FROM field on Link line"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|LF_TO
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"blank TO field on Link line"
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|.
name|l_filename
operator|=
name|filename
expr_stmt|;
name|l
operator|.
name|l_linenum
operator|=
name|linenum
expr_stmt|;
name|l
operator|.
name|l_from
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|LF_FROM
index|]
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_to
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|LF_TO
index|]
argument_list|)
expr_stmt|;
name|links
operator|=
operator|(
expr|struct
name|link
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|links
argument_list|,
operator|(
name|nlinks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|links
argument_list|)
expr_stmt|;
name|links
index|[
name|nlinks
operator|++
index|]
operator|=
name|l
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|rulesub
argument_list|(
name|rp
argument_list|,
name|loyearp
argument_list|,
name|hiyearp
argument_list|,
name|typep
argument_list|,
name|monthp
argument_list|,
name|dayp
argument_list|,
name|timep
argument_list|)
specifier|register
expr|struct
name|rule
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|loyearp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hiyearp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|typep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|monthp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dayp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|timep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|monthp
argument_list|,
name|mon_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"invalid month name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_month
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|rp
operator|->
name|r_todisstd
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|timep
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|lowerit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
case|case
literal|'s'
case|:
name|rp
operator|->
name|r_todisstd
operator|=
name|TRUE
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|rp
operator|->
name|r_todisstd
operator|=
name|FALSE
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|rp
operator|->
name|r_tod
operator|=
name|gethms
argument_list|(
name|timep
argument_list|,
literal|"invalid time of day"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	** Year work. 	*/
name|cp
operator|=
name|loyearp
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|cp
argument_list|,
name|begin_years
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|lp
operator|->
name|l_value
condition|)
block|{
case|case
name|YR_MINIMUM
case|:
name|rp
operator|->
name|r_loyear
operator|=
name|min_year
expr_stmt|;
break|break;
case|case
name|YR_MAXIMUM
case|:
name|rp
operator|->
name|r_loyear
operator|=
name|max_year
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: panic: Invalid l_value %d\n"
argument_list|,
name|progname
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_loyear
argument_list|)
operator|!=
literal|1
operator|||
name|rp
operator|->
name|r_loyear
operator|<
name|min_year
operator|||
name|rp
operator|->
name|r_loyear
operator|>
name|max_year
condition|)
block|{
if|if
condition|(
name|noise
condition|)
name|error
argument_list|(
literal|"invalid starting year"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|>
name|max_year
condition|)
return|return;
block|}
name|cp
operator|=
name|hiyearp
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|cp
argument_list|,
name|end_years
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|lp
operator|->
name|l_value
condition|)
block|{
case|case
name|YR_MINIMUM
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|min_year
expr_stmt|;
break|break;
case|case
name|YR_MAXIMUM
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|max_year
expr_stmt|;
break|break;
case|case
name|YR_ONLY
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|rp
operator|->
name|r_loyear
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: panic: Invalid l_value %d\n"
argument_list|,
name|progname
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_hiyear
argument_list|)
operator|!=
literal|1
operator|||
name|rp
operator|->
name|r_hiyear
operator|<
name|min_year
operator|||
name|rp
operator|->
name|r_hiyear
operator|>
name|max_year
condition|)
block|{
if|if
condition|(
name|noise
condition|)
name|error
argument_list|(
literal|"invalid ending year"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_hiyear
operator|<
name|min_year
condition|)
return|return;
block|}
if|if
condition|(
name|rp
operator|->
name|r_hiyear
operator|<
name|min_year
condition|)
return|return;
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|<
name|min_year
condition|)
name|rp
operator|->
name|r_loyear
operator|=
name|min_year
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_hiyear
operator|>
name|max_year
condition|)
name|rp
operator|->
name|r_hiyear
operator|=
name|max_year
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|>
name|rp
operator|->
name|r_hiyear
condition|)
block|{
name|error
argument_list|(
literal|"starting year greater than ending year"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|typep
operator|==
literal|'\0'
condition|)
name|rp
operator|->
name|r_yrtype
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|==
name|rp
operator|->
name|r_hiyear
condition|)
block|{
name|error
argument_list|(
literal|"typed single year"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_yrtype
operator|=
name|ecpyalloc
argument_list|(
name|typep
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Day work. 	** Accept things such as: 	**	1 	**	last-Sunday 	**	Sun<=20 	**	Sun>=7 	*/
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|dayp
argument_list|,
name|lasts
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWLEQ
expr_stmt|;
name|rp
operator|->
name|r_wday
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|rp
operator|->
name|r_dayofmonth
operator|=
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|dayp
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWLEQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|dayp
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWGEQ
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|dayp
expr_stmt|;
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOM
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|!=
name|DC_DOM
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'='
condition|)
block|{
name|error
argument_list|(
literal|"invalid day of month"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|dayp
argument_list|,
name|wday_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"invalid weekday name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_wday
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_dayofmonth
argument_list|)
operator|!=
literal|1
operator|||
name|rp
operator|->
name|r_dayofmonth
operator|<=
literal|0
operator|||
operator|(
name|rp
operator|->
name|r_dayofmonth
operator|>
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid day of month"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|puttzcode
argument_list|(
argument|val
argument_list|,
argument|fp
argument_list|)
name|long
name|val
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|shift
decl_stmt|;
for|for
control|(
name|shift
operator|=
literal|24
init|;
name|shift
operator|>=
literal|0
condition|;
name|shift
operator|-=
literal|8
control|)
block|{
name|c
operator|=
name|val
operator|>>
name|shift
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|writezone
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|fullname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|directory
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
sizeof|sizeof
name|fullname
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: File name %s/%s too long\n"
argument_list|,
name|progname
argument_list|,
name|directory
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s/%s"
argument_list|,
name|directory
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mkdirs
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't create "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
operator|(
expr|struct
name|tzhead
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|tzh_reserved
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|puttzcode
argument_list|(
name|eitol
argument_list|(
name|timecnt
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|puttzcode
argument_list|(
name|eitol
argument_list|(
name|typecnt
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|puttzcode
argument_list|(
name|eitol
argument_list|(
name|charcnt
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timecnt
condition|;
operator|++
name|i
control|)
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|ats
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timecnt
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|types
argument_list|,
sizeof|sizeof
name|types
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|timecnt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
block|{
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|gmtoffs
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|isdsts
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|abbrinds
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charcnt
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|chars
argument_list|,
sizeof|sizeof
name|chars
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|charcnt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Write error on "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|outzone
argument_list|(
argument|zpfirst
argument_list|,
argument|zonecount
argument_list|)
expr|struct
name|zone
operator|*
name|zpfirst
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|zone
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|usestart
decl_stmt|,
name|useuntil
decl_stmt|;
specifier|register
name|time_t
name|starttime
decl_stmt|,
name|untiltime
decl_stmt|;
specifier|register
name|long
name|gmtoff
decl_stmt|;
specifier|register
name|long
name|stdoff
decl_stmt|;
specifier|register
name|int
name|year
decl_stmt|;
specifier|register
name|long
name|startoff
decl_stmt|;
specifier|register
name|int
name|startisdst
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|char
name|startbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	** Now. . .finally. . .generate some useful data! 	*/
name|timecnt
operator|=
literal|0
expr_stmt|;
name|typecnt
operator|=
literal|0
expr_stmt|;
name|charcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	** Two guesses. . .the second may well be corrected later. 	*/
name|gmtoff
operator|=
name|zpfirst
operator|->
name|z_gmtoff
expr_stmt|;
name|stdoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
operator|++
name|i
control|)
block|{
name|usestart
operator|=
name|i
operator|>
literal|0
expr_stmt|;
name|useuntil
operator|=
name|i
operator|<
operator|(
name|zonecount
operator|-
literal|1
operator|)
expr_stmt|;
name|zp
operator|=
operator|&
name|zpfirst
index|[
name|i
index|]
expr_stmt|;
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
name|startisdst
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_nrules
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|addtype
argument_list|(
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|zp
operator|->
name|z_stdoff
argument_list|)
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|zp
operator|->
name|z_stdoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|usestart
condition|)
name|addtt
argument_list|(
name|starttime
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|gmtoff
operator|=
name|zp
operator|->
name|z_gmtoff
expr_stmt|;
name|stdoff
operator|=
name|zp
operator|->
name|z_stdoff
expr_stmt|;
block|}
else|else
for|for
control|(
name|year
operator|=
name|min_year
init|;
name|year
operator|<=
name|max_year
condition|;
operator|++
name|year
control|)
block|{
if|if
condition|(
name|useuntil
operator|&&
name|year
operator|>
name|zp
operator|->
name|z_untilrule
operator|.
name|r_hiyear
condition|)
break|break;
comment|/* 			** Mark which rules to do in the current year. 			** For those to do, calculate rpytime(rp, year); 			*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_todo
operator|=
name|year
operator|>=
name|rp
operator|->
name|r_loyear
operator|&&
name|year
operator|<=
name|rp
operator|->
name|r_hiyear
operator|&&
name|yearistype
argument_list|(
name|year
argument_list|,
name|rp
operator|->
name|r_yrtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_todo
condition|)
name|rp
operator|->
name|r_temp
operator|=
name|rpytime
argument_list|(
name|rp
argument_list|,
name|year
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|time_t
name|jtime
decl_stmt|,
name|ktime
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|useuntil
condition|)
block|{
comment|/* 					** Turn untiltime into GMT 					** assuming the current gmtoff and 					** stdoff values. 					*/
name|offset
operator|=
name|gmtoff
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisstd
condition|)
name|offset
operator|=
name|oadd
argument_list|(
name|offset
argument_list|,
name|stdoff
argument_list|)
expr_stmt|;
name|untiltime
operator|=
name|tadd
argument_list|(
name|zp
operator|->
name|z_untiltime
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* 				** Find the rule (of those to do, if any) 				** that takes effect earliest in the year. 				*/
name|k
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_todo
condition|)
continue|continue;
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gmtoff
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_todisstd
condition|)
name|offset
operator|=
name|oadd
argument_list|(
name|offset
argument_list|,
name|stdoff
argument_list|)
expr_stmt|;
name|jtime
operator|=
name|rp
operator|->
name|r_temp
expr_stmt|;
if|if
condition|(
name|jtime
operator|==
name|min_time
operator|||
name|jtime
operator|==
name|max_time
condition|)
continue|continue;
name|jtime
operator|=
name|tadd
argument_list|(
name|jtime
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
name|jtime
operator|<
name|ktime
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|ktime
operator|=
name|jtime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|<
literal|0
condition|)
break|break;
comment|/* go on to next year */
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|k
index|]
expr_stmt|;
name|rp
operator|->
name|r_todo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|useuntil
operator|&&
name|ktime
operator|>=
name|untiltime
condition|)
break|break;
if|if
condition|(
name|usestart
condition|)
block|{
if|if
condition|(
name|ktime
operator|<
name|starttime
condition|)
block|{
name|stdoff
operator|=
name|rp
operator|->
name|r_stdoff
expr_stmt|;
name|startoff
operator|=
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|rp
operator|->
name|r_stdoff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|)
expr_stmt|;
name|startisdst
operator|=
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ktime
operator|!=
name|starttime
operator|&&
name|startisdst
operator|>=
literal|0
condition|)
name|addtt
argument_list|(
name|starttime
argument_list|,
name|addtype
argument_list|(
name|startoff
argument_list|,
name|startbuf
argument_list|,
name|startisdst
argument_list|)
argument_list|)
expr_stmt|;
name|usestart
operator|=
name|FALSE
expr_stmt|;
block|}
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|)
expr_stmt|;
name|offset
operator|=
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|rp
operator|->
name|r_stdoff
argument_list|)
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timecnt
operator|!=
literal|0
operator|||
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
condition|)
name|addtt
argument_list|(
name|ktime
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|gmtoff
operator|=
name|zp
operator|->
name|z_gmtoff
expr_stmt|;
name|stdoff
operator|=
name|rp
operator|->
name|r_stdoff
expr_stmt|;
block|}
block|}
comment|/* 		** Now we may get to set starttime for the next zone line. 		*/
if|if
condition|(
name|useuntil
condition|)
name|starttime
operator|=
name|tadd
argument_list|(
name|zp
operator|->
name|z_untiltime
argument_list|,
operator|-
name|gmtoffs
index|[
name|types
index|[
name|timecnt
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|writezone
argument_list|(
name|zpfirst
operator|->
name|z_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|addtt
argument_list|(
argument|starttime
argument_list|,
argument|type
argument_list|)
name|time_t
name|starttime
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|timecnt
operator|!=
literal|0
operator|&&
name|type
operator|==
name|types
index|[
name|timecnt
operator|-
literal|1
index|]
condition|)
return|return;
comment|/* easy enough! */
if|if
condition|(
name|timecnt
operator|>=
name|TZ_MAX_TIMES
condition|)
block|{
name|error
argument_list|(
literal|"too many transitions?!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ats
index|[
name|timecnt
index|]
operator|=
name|starttime
expr_stmt|;
name|types
index|[
name|timecnt
index|]
operator|=
name|type
expr_stmt|;
operator|++
name|timecnt
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|addtype
argument_list|(
argument|gmtoff
argument_list|,
argument|abbr
argument_list|,
argument|isdst
argument_list|)
name|long
name|gmtoff
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|abbr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	** See if there's already an entry for this zone type. 	** If so, just return its index. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|gmtoff
operator|==
name|gmtoffs
index|[
name|i
index|]
operator|&&
name|isdst
operator|==
name|isdsts
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|abbr
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|i
index|]
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
comment|/* 	** There isn't one; add a new one, unless there are already too 	** many. 	*/
if|if
condition|(
name|typecnt
operator|>=
name|TZ_MAX_TYPES
condition|)
block|{
name|error
argument_list|(
literal|"too many local time types"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gmtoffs
index|[
name|i
index|]
operator|=
name|gmtoff
expr_stmt|;
name|isdsts
index|[
name|i
index|]
operator|=
name|isdst
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|charcnt
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chars
index|[
name|j
index|]
argument_list|,
name|abbr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|charcnt
condition|)
name|newabbr
argument_list|(
name|abbr
argument_list|)
expr_stmt|;
name|abbrinds
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
operator|++
name|typecnt
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|yearistype
argument_list|(
argument|year
argument_list|,
argument|type
argument_list|)
name|char
operator|*
name|type
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
operator|*
name|type
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"uspres"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|year
operator|%
literal|4
operator|)
operator|==
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"nonpres"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|year
operator|%
literal|4
operator|)
operator|!=
literal|0
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"yearistype %d %s"
argument_list|,
name|year
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|result
operator|==
literal|1
operator|<<
literal|8
condition|)
return|return
name|FALSE
return|;
name|error
argument_list|(
literal|"Wild result from command execution"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: command was '%s', result was %d\n"
argument_list|,
name|progname
argument_list|,
name|buf
argument_list|,
name|result
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|lowerit
argument_list|(
argument|a
argument_list|)
block|{
return|return
operator|(
name|isascii
argument_list|(
name|a
argument_list|)
operator|&&
name|isupper
argument_list|(
name|a
argument_list|)
operator|)
operator|?
name|tolower
argument_list|(
name|a
argument_list|)
operator|:
name|a
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|ciequal
argument_list|(
name|ap
argument_list|,
name|bp
argument_list|)
comment|/* case-insensitive equality */
specifier|register
name|char
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|lowerit
argument_list|(
operator|*
name|ap
argument_list|)
operator|==
name|lowerit
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
condition|)
if|if
condition|(
operator|*
name|ap
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|isabbr
argument_list|(
name|abbr
argument_list|,
name|word
argument_list|)
specifier|register
name|char
operator|*
name|abbr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lowerit
argument_list|(
operator|*
name|abbr
argument_list|)
operator|!=
name|lowerit
argument_list|(
operator|*
name|word
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|++
name|word
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|abbr
operator|!=
literal|'\0'
condition|)
do|do
if|if
condition|(
operator|*
name|word
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
do|while
condition|(
name|lowerit
argument_list|(
operator|*
name|word
operator|++
argument_list|)
operator|!=
name|lowerit
argument_list|(
operator|*
name|abbr
argument_list|)
condition|)
do|;
return|return
name|TRUE
return|;
block|}
end_block

begin_function
specifier|static
name|struct
name|lookup
modifier|*
name|byword
parameter_list|(
name|word
parameter_list|,
name|table
parameter_list|)
specifier|register
name|char
modifier|*
name|word
decl_stmt|;
specifier|register
name|struct
name|lookup
modifier|*
name|table
decl_stmt|;
block|{
specifier|register
name|struct
name|lookup
modifier|*
name|foundlp
decl_stmt|;
specifier|register
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|NULL
operator|||
name|table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* 	** Look for exact match. 	*/
for|for
control|(
name|lp
operator|=
name|table
init|;
name|lp
operator|->
name|l_word
operator|!=
name|NULL
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|ciequal
argument_list|(
name|word
argument_list|,
name|lp
operator|->
name|l_word
argument_list|)
condition|)
return|return
name|lp
return|;
comment|/* 	** Look for inexact match. 	*/
name|foundlp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|table
init|;
name|lp
operator|->
name|l_word
operator|!=
name|NULL
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|isabbr
argument_list|(
name|word
argument_list|,
name|lp
operator|->
name|l_word
argument_list|)
condition|)
if|if
condition|(
name|foundlp
operator|==
name|NULL
condition|)
name|foundlp
operator|=
name|lp
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/* multiple inexact matches */
return|return
name|foundlp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|getfields
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
specifier|register
name|int
name|nsubs
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|array
argument_list|)
expr_stmt|;
name|nsubs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
operator|*
name|cp
operator|==
literal|'#'
condition|)
break|break;
name|array
index|[
name|nsubs
operator|++
index|]
operator|=
name|dp
operator|=
name|cp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'"'
condition|)
operator|++
name|dp
expr_stmt|;
else|else
while|while
condition|(
operator|(
operator|*
name|dp
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'"'
condition|)
if|if
condition|(
operator|*
name|dp
operator|!=
literal|'\0'
condition|)
operator|++
name|dp
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Odd number of quotation marks"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'#'
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|array
index|[
name|nsubs
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oadd
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|long
name|t1
decl_stmt|;
name|long
name|t2
decl_stmt|;
block|{
specifier|register
name|long
name|t
decl_stmt|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
name|t2
operator|>
literal|0
operator|&&
name|t
operator|<=
name|t1
operator|||
name|t2
operator|<
literal|0
operator|&&
name|t
operator|>=
name|t1
condition|)
block|{
name|error
argument_list|(
literal|"time overflow"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|tadd
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|time_t
name|t1
decl_stmt|;
name|long
name|t2
decl_stmt|;
block|{
specifier|register
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|max_time
operator|&&
name|t2
operator|>
literal|0
condition|)
return|return
name|max_time
return|;
if|if
condition|(
name|t1
operator|==
name|min_time
operator|&&
name|t2
operator|<
literal|0
condition|)
return|return
name|min_time
return|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
name|t2
operator|>
literal|0
operator|&&
name|t
operator|<=
name|t1
operator|||
name|t2
operator|<
literal|0
operator|&&
name|t
operator|>=
name|t1
condition|)
block|{
name|error
argument_list|(
literal|"time overflow"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* ** Given a rule, and a year, compute the date - in seconds since January 1, ** 1970, 00:00 LOCAL time - in that year that the rule refers to. */
end_comment

begin_function
specifier|static
name|time_t
name|rpytime
parameter_list|(
name|rp
parameter_list|,
name|wantedy
parameter_list|)
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|wantedy
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|long
name|dayoff
decl_stmt|;
comment|/* with a nod to Margaret O. */
specifier|register
name|time_t
name|t
decl_stmt|;
name|dayoff
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|TM_JANUARY
expr_stmt|;
name|y
operator|=
name|EPOCH_YEAR
expr_stmt|;
while|while
condition|(
name|wantedy
operator|!=
name|y
condition|)
block|{
if|if
condition|(
name|wantedy
operator|>
name|y
condition|)
block|{
name|i
operator|=
name|len_years
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
operator|++
name|y
expr_stmt|;
block|}
else|else
block|{
operator|--
name|y
expr_stmt|;
name|i
operator|=
operator|-
name|len_years
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m
operator|!=
name|rp
operator|->
name|r_month
condition|)
block|{
name|i
operator|=
name|len_months
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
index|[
name|m
index|]
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
name|i
operator|=
name|rp
operator|->
name|r_dayofmonth
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|TM_FEBRUARY
operator|&&
name|i
operator|==
literal|29
operator|&&
operator|!
name|isleap
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
operator|--
name|i
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"use of 2/29 in non leap-year"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
operator|||
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
block|{
specifier|register
name|long
name|wday
decl_stmt|;
define|#
directive|define
name|LDAYS_PER_WEEK
value|((long) DAYS_PER_WEEK)
name|wday
operator|=
name|eitol
argument_list|(
name|EPOCH_WDAY
argument_list|)
expr_stmt|;
comment|/* 		** Don't trust mod of negative numbers. 		*/
if|if
condition|(
name|dayoff
operator|>=
literal|0
condition|)
name|wday
operator|=
operator|(
name|wday
operator|+
name|dayoff
operator|)
operator|%
name|LDAYS_PER_WEEK
expr_stmt|;
else|else
block|{
name|wday
operator|-=
operator|(
operator|(
operator|-
name|dayoff
operator|)
operator|%
name|LDAYS_PER_WEEK
operator|)
expr_stmt|;
if|if
condition|(
name|wday
operator|<
literal|0
condition|)
name|wday
operator|+=
name|LDAYS_PER_WEEK
expr_stmt|;
block|}
while|while
condition|(
name|wday
operator|!=
name|eitol
argument_list|(
name|rp
operator|->
name|r_wday
argument_list|)
condition|)
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
condition|)
block|{
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wday
operator|>=
name|LDAYS_PER_WEEK
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|wday
operator|<
literal|0
condition|)
name|wday
operator|=
name|LDAYS_PER_WEEK
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|len_months
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
index|[
name|m
index|]
condition|)
block|{
name|error
argument_list|(
literal|"no day in month matches rule"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dayoff
operator|<
literal|0
operator|&&
operator|!
name|tt_signed
condition|)
block|{
if|if
condition|(
name|wantedy
operator|==
name|rp
operator|->
name|r_loyear
condition|)
return|return
name|min_time
return|;
name|error
argument_list|(
literal|"time before zero"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
operator|(
name|time_t
operator|)
name|dayoff
operator|*
name|SECS_PER_DAY
expr_stmt|;
comment|/* 	** Cheap overflow check. 	*/
if|if
condition|(
name|t
operator|/
name|SECS_PER_DAY
operator|!=
name|dayoff
condition|)
block|{
if|if
condition|(
name|wantedy
operator|==
name|rp
operator|->
name|r_hiyear
condition|)
return|return
name|max_time
return|;
if|if
condition|(
name|wantedy
operator|==
name|rp
operator|->
name|r_loyear
condition|)
return|return
name|min_time
return|;
name|error
argument_list|(
literal|"time overflow"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|tadd
argument_list|(
name|t
argument_list|,
name|rp
operator|->
name|r_tod
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|newabbr
argument_list|(
argument|string
argument_list|)
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|charcnt
operator|+
name|i
operator|>=
name|TZ_MAX_CHARS
condition|)
block|{
name|error
argument_list|(
literal|"too many, or too long, time zone abbreviations"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|chars
index|[
name|charcnt
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|charcnt
operator|+=
name|eitol
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|mkdirs
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|name
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
operator|&&
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0755
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|long
name|eitol
parameter_list|(
name|i
parameter_list|)
block|{
name|long
name|l
decl_stmt|;
name|l
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|l
operator|>=
literal|0
operator|||
name|i
operator|==
literal|0
operator|&&
name|l
operator|!=
literal|0
operator|||
name|i
operator|>
literal|0
operator|&&
name|l
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d did not sign extend correctly\n"
argument_list|,
name|progname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* ** UNIX is a registered trademark of AT&T. */
end_comment

end_unit

