begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)answer.c	5.2 (Berkeley) 6/27/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  */
end_comment

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|MAXPERMACH
value|3
end_define

begin_comment
comment|/* Max player/monitor per machine */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Ttyname
index|[
name|NAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|answer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|newsock
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|tmpfd
decl_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
specifier|static
name|FLAG
name|monitor
decl_stmt|;
endif|#
directive|endif
endif|MONITOR
specifier|static
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|static
name|int
name|socklen
decl_stmt|;
specifier|static
name|u_long
name|machine
decl_stmt|;
specifier|static
name|u_long
name|uid
decl_stmt|;
specifier|static
name|SOCKET
name|sockstruct
decl_stmt|;
ifdef|#
directive|ifdef
name|OLDIPC
specifier|extern
name|SOCKET
name|Daemon
decl_stmt|;
endif|#
directive|endif
endif|OLDIPC
ifdef|#
directive|ifdef
name|INTERNET
name|socklen
operator|=
sizeof|sizeof
name|sockstruct
expr_stmt|;
else|#
directive|else
name|socklen
operator|=
sizeof|sizeof
name|sockstruct
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|errno
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OLDIPC
if|if
condition|(
operator|(
name|newsock
operator|=
name|accept
argument_list|(
name|Socket
argument_list|,
operator|&
name|sockstruct
argument_list|,
operator|&
name|socklen
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
else|OLDIPC
if|if
condition|(
name|accept
argument_list|(
name|Socket
argument_list|,
operator|&
name|sockstruct
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
endif|OLDIPC
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OLDIPC
name|newsock
operator|=
name|Socket
expr_stmt|;
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
name|SO_ACCEPTCONN
argument_list|)
expr_stmt|;
if|if
condition|(
name|Socket
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"new accept socket"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Sock_mask
operator|=
operator|(
literal|1
operator|<<
name|Socket
operator|)
expr_stmt|;
name|Fds_mask
operator||=
name|Sock_mask
expr_stmt|;
if|if
condition|(
name|Socket
operator|>=
name|Num_fds
condition|)
name|Num_fds
operator|=
name|Socket
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
name|tmpfd
operator|=
name|fdopen
argument_list|(
name|newsock
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|machine
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sockstruct
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
else|#
directive|else
else|INTERNET
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|machine
operator|=
name|gethostid
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
operator|(
name|void
operator|)
name|putw
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|tmpfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|uid
argument_list|,
sizeof|sizeof
name|uid
argument_list|)
expr_stmt|;
name|uid
operator|=
name|ntohl
argument_list|(
name|uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
name|name
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
name|Ttyname
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|monitor
argument_list|,
sizeof|sizeof
name|monitor
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
if|if
condition|(
name|reached_limit
argument_list|(
name|machine
argument_list|)
condition|)
block|{
name|socklen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|socklen
argument_list|,
sizeof|sizeof
name|socklen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDIPC
name|Fds_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|newsock
operator|)
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
return|return;
block|}
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|monitor
condition|)
if|if
condition|(
name|End_monitor
operator|<
operator|&
name|Monitor
index|[
name|MAXMON
index|]
condition|)
name|pp
operator|=
name|End_monitor
operator|++
expr_stmt|;
else|else
block|{
name|socklen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|socklen
argument_list|,
sizeof|sizeof
name|socklen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
endif|#
directive|endif
endif|MONITOR
if|if
condition|(
name|End_player
operator|<
operator|&
name|Player
index|[
name|MAXPL
index|]
condition|)
name|pp
operator|=
name|End_player
operator|++
expr_stmt|;
else|else
block|{
name|socklen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|socklen
argument_list|,
sizeof|sizeof
name|socklen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|p_ident
operator|=
name|get_ident
argument_list|(
name|machine
argument_list|,
name|uid
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_output
operator|=
name|tmpfd
expr_stmt|;
name|pp
operator|->
name|p_death
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|->
name|p_fd
operator|=
name|newsock
expr_stmt|;
name|pp
operator|->
name|p_mask
operator|=
operator|(
literal|1
operator|<<
name|pp
operator|->
name|p_fd
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OLDIPC
name|Fds_mask
operator||=
name|pp
operator|->
name|p_mask
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_fd
operator|>=
name|Num_fds
condition|)
name|Num_fds
operator|=
name|pp
operator|->
name|p_fd
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
name|pp
operator|->
name|p_y
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|p_x
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|monitor
condition|)
name|stmonitor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|MONITOR
name|stplayer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MONITOR
end_ifdef

begin_expr_stmt
name|stmonitor
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|line
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|npp
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Maze
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pp
operator|->
name|p_maze
argument_list|,
sizeof|sizeof
name|Maze
argument_list|)
expr_stmt|;
name|drawmaze
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.5s%c%-10.10s"
argument_list|,
literal|" "
argument_list|,
name|stat_char
argument_list|(
name|pp
argument_list|)
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|)
expr_stmt|;
name|line
operator|=
name|STAT_MON_ROW
operator|+
literal|1
operator|+
operator|(
name|pp
operator|-
name|Monitor
operator|)
expr_stmt|;
for|for
control|(
name|npp
operator|=
name|Player
init|;
name|npp
operator|<
name|End_player
condition|;
name|npp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|npp
argument_list|,
name|line
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|npp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|npp
operator|=
name|Monitor
init|;
name|npp
operator|<
name|End_monitor
condition|;
name|npp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|npp
argument_list|,
name|line
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|npp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MONITOR
end_endif

begin_expr_stmt
name|stplayer
argument_list|(
name|newpp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|newpp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
name|Nplayer
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|UBOUND
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|WIDTH
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
init|;
name|y
operator|<
name|DBOUND
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|LBOUND
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
init|;
name|x
operator|<
name|RBOUND
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
for|for
control|(
init|;
name|x
operator|<
name|WIDTH
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|<
name|HEIGHT
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|WIDTH
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|newpp
operator|->
name|p_over
operator|=
name|SPACE
expr_stmt|;
name|newpp
operator|->
name|p_x
operator|=
name|x
expr_stmt|;
name|newpp
operator|->
name|p_y
operator|=
name|y
expr_stmt|;
name|newpp
operator|->
name|p_undershot
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|START_FLYING
comment|/* This is only for debugging */
name|newpp
operator|->
name|p_flying
operator|=
name|rand_num
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|newpp
operator|->
name|p_flyx
operator|=
literal|2
operator|*
name|rand_num
argument_list|(
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|newpp
operator|->
name|p_flyy
operator|=
literal|2
operator|*
name|rand_num
argument_list|(
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|newpp
operator|->
name|p_face
operator|=
name|FLYER
expr_stmt|;
else|#
directive|else
else|START_FLYING
name|newpp
operator|->
name|p_flying
operator|=
operator|-
literal|1
expr_stmt|;
name|rand_face
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|START_FLYING
name|newpp
operator|->
name|p_damage
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_damcap
operator|=
name|MAXDAM
expr_stmt|;
name|newpp
operator|->
name|p_nchar
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_ncount
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_nexec
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_ammo
operator|=
name|ISHOTS
expr_stmt|;
name|newpp
operator|->
name|p_scan
operator|=
operator|-
literal|1
expr_stmt|;
name|newpp
operator|->
name|p_cloak
operator|=
name|CLOAKLEN
expr_stmt|;
name|newpp
operator|->
name|p_ncshot
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|GMINE
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|MINE
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.2f%c%-10.10s"
argument_list|,
name|newpp
operator|->
name|p_ident
operator|->
name|i_score
argument_list|,
name|stat_char
argument_list|(
name|newpp
argument_list|)
argument_list|,
name|newpp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|)
expr_stmt|;
name|y
operator|=
name|STAT_PLAY_ROW
operator|+
literal|1
operator|+
operator|(
name|newpp
operator|-
name|Player
operator|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|!=
name|newpp
condition|)
block|{
name|char
name|smallbuf
index|[
literal|10
index|]
decl_stmt|;
name|pp
operator|->
name|p_ammo
operator|+=
name|NSHOTS
expr_stmt|;
name|newpp
operator|->
name|p_ammo
operator|+=
name|NSHOTS
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|smallbuf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|smallbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
name|drawmaze
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
name|drawplayer
argument_list|(
name|newpp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|look
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|START_FLYING
comment|/* Make sure that the position you enter in will be erased */
name|showexpl
argument_list|(
name|newpp
operator|->
name|p_y
argument_list|,
name|newpp
operator|->
name|p_x
argument_list|,
name|FLYER
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|START_FLYING
name|sendcom
argument_list|(
name|newpp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|newpp
argument_list|,
name|READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|newpp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * rand_face:  *	Give the player a random facing direction  */
end_comment

begin_expr_stmt
name|rand_face
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|rand_num
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pp
operator|->
name|p_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pp
operator|->
name|p_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pp
operator|->
name|p_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pp
operator|->
name|p_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * get_ident:  *	Get the score structure of a player  */
end_comment

begin_function
name|IDENT
modifier|*
name|get_ident
parameter_list|(
name|machine
parameter_list|,
name|uid
parameter_list|,
name|name
parameter_list|)
name|u_long
name|machine
decl_stmt|;
name|u_long
name|uid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|IDENT
modifier|*
name|ip
decl_stmt|;
specifier|static
name|IDENT
name|punt
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|Scores
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
if|if
condition|(
name|ip
operator|->
name|i_machine
operator|==
name|machine
operator|&&
name|ip
operator|->
name|i_uid
operator|==
name|uid
operator|&&
name|strncmp
argument_list|(
name|ip
operator|->
name|i_name
argument_list|,
name|name
argument_list|,
name|NAMELEN
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|i_entries
operator|++
expr_stmt|;
name|ip
operator|->
name|i_score
operator|=
name|ip
operator|->
name|i_kills
operator|/
operator|(
name|double
operator|)
name|ip
operator|->
name|i_entries
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
operator|(
name|IDENT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IDENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
comment|/* Fourth down, time to punt */
name|ip
operator|=
operator|&
name|punt
expr_stmt|;
block|}
name|ip
operator|->
name|i_machine
operator|=
name|machine
expr_stmt|;
name|ip
operator|->
name|i_uid
operator|=
name|uid
expr_stmt|;
name|strncpy
argument_list|(
name|ip
operator|->
name|i_name
argument_list|,
name|name
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_kills
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_entries
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|i_score
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_next
operator|=
name|Scores
expr_stmt|;
name|Scores
operator|=
name|ip
expr_stmt|;
block|}
return|return
name|ip
return|;
block|}
end_function

begin_comment
comment|/*  * reached_limit:  *	Returns whether the limit of x persons per machine has been reached  */
end_comment

begin_macro
name|reached_limit
argument_list|(
argument|machine
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_ident
operator|->
name|i_machine
operator|==
name|machine
condition|)
name|count
operator|++
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_ident
operator|->
name|i_machine
operator|==
name|machine
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
operator|>=
name|MAXPERMACH
return|;
block|}
end_block

end_unit

