begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)finger.c	5.10 (Berkeley) 4/26/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * This is a finger program.  It prints out useful information about users  * by digging it up from various system files.  It is not very portable  * because the most useful parts of the information (the full user name,  * office, and phone numbers) are all stored in the VAX-unused gecos field  * of /etc/passwd, which, unfortunately, other UNIXes use for other things.  *  * There are three output formats, all of which give login name, teletype  * line number, and login time.  The short output format is reminiscent  * of finger on ITS, and gives one line of information per user containing  * in addition to the minimum basic requirements (MBR), the full name of  * the user, his idle time and office location and phone number.  The  * quick style output is UNIX who-like, giving only name, teletype and  * login time.  Finally, the long style output give the same information  * as the short (in more legible format), the home directory and shell  * of the user, and, if it exits, a copy of the file .plan in the users  * home directory.  Finger may be called with or without a list of people  * to finger -- if no list is given, all the people currently logged in  * are fingered.  *  * The program is validly called by one of the following:  *  *	finger			{short form list of users}  *	finger -l		{long form list of users}  *	finger -b		{briefer long form list of users}  *	finger -q		{quick list of users}  *	finger -i		{quick list of users with idle times}  *	finger namelist		{long format list of specified users}  *	finger -s namelist	{short format list of specified users}  *	finger -w namelist	{narrow short format list of specified users}  *  * where 'namelist' is a list of users login names.  * The other options can all be given after one '-', or each can have its  * own '-'.  The -f option disables the printing of headers for short and  * quick outputs.  The -b option briefens long format outputs.  The -p  * option turns off plans for long format outputs.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<lastlog.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_define
define|#
directive|define
name|ASTERISK
value|'*'
end_define

begin_comment
comment|/* ignore this in real name */
end_comment

begin_define
define|#
directive|define
name|COMMA
value|','
end_define

begin_comment
comment|/* separator in pw_gecos field */
end_comment

begin_define
define|#
directive|define
name|COMMAND
value|'-'
end_define

begin_comment
comment|/* command line flag char */
end_comment

begin_define
define|#
directive|define
name|CORY
value|'C'
end_define

begin_comment
comment|/* cory hall office */
end_comment

begin_define
define|#
directive|define
name|EVANS
value|'E'
end_define

begin_comment
comment|/* evans hall office */
end_comment

begin_define
define|#
directive|define
name|SAMENAME
value|'&'
end_define

begin_comment
comment|/* repeat login name in real name */
end_comment

begin_define
define|#
directive|define
name|TALKABLE
value|0220
end_define

begin_comment
comment|/* tty is writable if 220 mode */
end_comment

begin_decl_stmt
name|struct
name|utmp
name|user
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMAX
value|sizeof(user.ut_name)
end_define

begin_define
define|#
directive|define
name|LMAX
value|sizeof(user.ut_line)
end_define

begin_define
define|#
directive|define
name|HMAX
value|sizeof(user.ut_host)
end_define

begin_struct
struct|struct
name|person
block|{
comment|/* one for each person fingered */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name */
name|char
name|tty
index|[
name|LMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* null terminated tty line */
name|char
name|host
index|[
name|HMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* null terminated remote host name */
name|long
name|loginat
decl_stmt|;
comment|/* time of (last) login */
name|long
name|idletime
decl_stmt|;
comment|/* how long idle (if logged in) */
name|char
modifier|*
name|realname
decl_stmt|;
comment|/* pointer to full name */
name|char
modifier|*
name|office
decl_stmt|;
comment|/* pointer to office name */
name|char
modifier|*
name|officephone
decl_stmt|;
comment|/* pointer to office phone no. */
name|char
modifier|*
name|homephone
decl_stmt|;
comment|/* pointer to home phone no. */
name|char
modifier|*
name|random
decl_stmt|;
comment|/* for any random stuff in pw_gecos */
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
comment|/* structure of /etc/passwd stuff */
name|char
name|loggedin
decl_stmt|;
comment|/* person is logged in */
name|char
name|writable
decl_stmt|;
comment|/* tty is writable */
name|char
name|original
decl_stmt|;
comment|/* this is not a duplicate entry */
name|struct
name|person
modifier|*
name|link
decl_stmt|;
comment|/* link to next person */
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|LASTLOG
index|[]
init|=
literal|"/usr/adm/lastlog"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last login info */
end_comment

begin_decl_stmt
name|char
name|USERLOG
index|[]
init|=
literal|"/etc/utmp"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* who is logged in */
end_comment

begin_decl_stmt
name|char
name|PLAN
index|[]
init|=
literal|"/.plan"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what plan file is */
end_comment

begin_decl_stmt
name|char
name|PROJ
index|[]
init|=
literal|"/.project"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what project file */
end_comment

begin_decl_stmt
name|int
name|unbrief
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -b option default */
end_comment

begin_decl_stmt
name|int
name|header
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -f option default */
end_comment

begin_decl_stmt
name|int
name|hack
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -h option default */
end_comment

begin_decl_stmt
name|int
name|idle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i option default */
end_comment

begin_decl_stmt
name|int
name|large
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l option default */
end_comment

begin_decl_stmt
name|int
name|match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -m option default */
end_comment

begin_decl_stmt
name|int
name|plan
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -p option default */
end_comment

begin_decl_stmt
name|int
name|unquick
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -q option default */
end_comment

begin_decl_stmt
name|int
name|small
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s option default */
end_comment

begin_decl_stmt
name|int
name|wide
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w option default */
end_comment

begin_decl_stmt
name|int
name|unshort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LASTLOG file descriptor */
end_comment

begin_decl_stmt
name|struct
name|person
modifier|*
name|person1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of people */
end_comment

begin_decl_stmt
name|long
name|tloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|pwdcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* parse command line for (optional) arguments */
while|while
condition|(
operator|*
operator|++
name|argv
operator|&&
operator|*
operator|*
name|argv
operator|==
name|COMMAND
condition|)
for|for
control|(
name|s
operator|=
operator|*
name|argv
operator|+
literal|1
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'b'
case|:
name|unbrief
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|header
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hack
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|idle
operator|=
literal|1
expr_stmt|;
name|unquick
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|large
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|plan
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|unquick
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|small
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wide
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: finger [-bfhilmpqsw] [login1 [login2 ...] ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unquick
operator|||
name|idle
condition|)
name|time
argument_list|(
operator|&
name|tloc
argument_list|)
expr_stmt|;
comment|/* 	 * *argv == 0 means no names given 	 */
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
name|doall
argument_list|()
expr_stmt|;
else|else
name|donames
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|person1
condition|)
name|print
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|doall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|person
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|uf
decl_stmt|;
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
name|unshort
operator|=
name|large
expr_stmt|;
if|if
condition|(
operator|(
name|uf
operator|=
name|open
argument_list|(
name|USERLOG
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finger: error opening %s\n"
argument_list|,
name|USERLOG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unquick
condition|)
block|{
extern|extern _pw_stayopen;
name|setpwent
argument_list|()
expr_stmt|;
name|_pw_stayopen
operator|=
literal|1
expr_stmt|;
name|fwopen
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|read
argument_list|(
name|uf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|user
argument_list|,
sizeof|sizeof
name|user
argument_list|)
operator|==
sizeof|sizeof
name|user
condition|)
block|{
if|if
condition|(
name|user
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|person1
operator|==
literal|0
condition|)
name|p
operator|=
name|person1
operator|=
operator|(
expr|struct
name|person
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|->
name|link
operator|=
operator|(
expr|struct
name|person
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|user
operator|.
name|ut_name
argument_list|,
name|name
argument_list|,
name|NMAX
argument_list|)
expr_stmt|;
name|name
index|[
name|NMAX
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|user
operator|.
name|ut_line
argument_list|,
name|p
operator|->
name|tty
argument_list|,
name|LMAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|tty
index|[
name|LMAX
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|user
operator|.
name|ut_host
argument_list|,
name|p
operator|->
name|host
argument_list|,
name|HMAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|host
index|[
name|HMAX
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|loginat
operator|=
name|user
operator|.
name|ut_time
expr_stmt|;
name|p
operator|->
name|pwd
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|loggedin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unquick
operator|&&
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|p
operator|->
name|pwd
operator|=
name|pwdcopy
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|p
operator|->
name|pwd
operator|->
name|pw_name
expr_stmt|;
block|}
else|else
name|p
operator|->
name|name
operator|=
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unquick
condition|)
block|{
name|fwclose
argument_list|()
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
block|}
name|close
argument_list|(
name|uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|person1
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No one logged on\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|link
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|donames
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|person
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|uf
decl_stmt|;
comment|/* 	 * get names from command line and check to see if they're 	 * logged in 	 */
name|unshort
operator|=
operator|!
name|small
expr_stmt|;
for|for
control|(
init|;
operator|*
name|argv
operator|!=
literal|0
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|netfinger
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|person1
operator|==
literal|0
condition|)
name|p
operator|=
name|person1
operator|=
operator|(
expr|struct
name|person
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|->
name|link
operator|=
operator|(
expr|struct
name|person
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
name|p
operator|->
name|name
operator|=
operator|*
name|argv
expr_stmt|;
name|p
operator|->
name|loggedin
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|original
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|pwd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|person1
operator|==
literal|0
condition|)
return|return;
name|p
operator|->
name|link
operator|=
literal|0
expr_stmt|;
comment|/* 	 * if we are doing it, read /etc/passwd for the useful info 	 */
if|if
condition|(
name|unquick
condition|)
block|{
name|setpwent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
extern|extern _pw_stayopen;
name|_pw_stayopen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|person1
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
name|p
operator|->
name|pwd
operator|=
name|pwdcopy
argument_list|(
name|pw
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|person1
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|original
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|matchcmp
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|pwd
operator|==
literal|0
condition|)
name|p
operator|->
name|pwd
operator|=
name|pwdcopy
argument_list|(
name|pw
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|person
modifier|*
name|new
decl_stmt|;
comment|/* 					 * handle multiple login names, insert 					 * new "duplicate" entry behind 					 */
name|new
operator|=
operator|(
expr|struct
name|person
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|pwd
operator|=
name|pwdcopy
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|new
operator|->
name|original
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|loggedin
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|p
operator|->
name|original
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|new
expr_stmt|;
name|p
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
name|endpwent
argument_list|()
expr_stmt|;
block|}
comment|/* Now get login information */
if|if
condition|(
operator|(
name|uf
operator|=
name|open
argument_list|(
name|USERLOG
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finger: error opening %s\n"
argument_list|,
name|USERLOG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|read
argument_list|(
name|uf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|user
argument_list|,
sizeof|sizeof
name|user
argument_list|)
operator|==
sizeof|sizeof
name|user
condition|)
block|{
if|if
condition|(
operator|*
name|user
operator|.
name|ut_name
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|person1
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|loggedin
operator|==
literal|2
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|pwd
condition|?
name|p
operator|->
name|pwd
operator|->
name|pw_name
else|:
name|p
operator|->
name|name
argument_list|,
name|user
operator|.
name|ut_name
argument_list|,
name|NMAX
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|loggedin
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|user
operator|.
name|ut_line
argument_list|,
name|p
operator|->
name|tty
argument_list|,
name|LMAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|tty
index|[
name|LMAX
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|user
operator|.
name|ut_host
argument_list|,
name|p
operator|->
name|host
argument_list|,
name|HMAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|host
index|[
name|HMAX
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|loginat
operator|=
name|user
operator|.
name|ut_time
expr_stmt|;
name|p
operator|->
name|loggedin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* p->loggedin == 1 */
name|struct
name|person
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|person
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|bcopy
argument_list|(
name|user
operator|.
name|ut_line
argument_list|,
name|new
operator|->
name|tty
argument_list|,
name|LMAX
argument_list|)
expr_stmt|;
name|new
operator|->
name|tty
index|[
name|LMAX
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|user
operator|.
name|ut_host
argument_list|,
name|new
operator|->
name|host
argument_list|,
name|HMAX
argument_list|)
expr_stmt|;
name|new
operator|->
name|host
index|[
name|HMAX
index|]
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|loginat
operator|=
name|user
operator|.
name|ut_time
expr_stmt|;
name|new
operator|->
name|pwd
operator|=
name|p
operator|->
name|pwd
expr_stmt|;
name|new
operator|->
name|loggedin
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|original
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|p
operator|->
name|loggedin
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|new
expr_stmt|;
name|p
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|unquick
condition|)
block|{
name|fwopen
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|person1
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
name|decode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fwclose
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|print
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|person
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|c
expr_stmt|;
comment|/* 	 * print out what we got 	 */
if|if
condition|(
name|header
condition|)
block|{
if|if
condition|(
name|unquick
condition|)
block|{
if|if
condition|(
operator|!
name|unshort
condition|)
if|if
condition|(
name|wide
condition|)
name|printf
argument_list|(
literal|"Login       Name              TTY Idle    When            Office\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Login    TTY Idle    When            Office\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Login      TTY            When"
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle
condition|)
name|printf
argument_list|(
literal|"             Idle"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|person1
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
operator|!
name|unquick
condition|)
block|{
name|quickprint
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|unshort
condition|)
block|{
name|shortprint
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|personprint
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pwd
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hack
condition|)
block|{
name|s
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|+
sizeof|sizeof
name|PROJ
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|PROJ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Project: "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|c
operator|^
literal|100
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|plan
condition|)
block|{
name|s
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|+
sizeof|sizeof
name|PLAN
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|PLAN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"No Plan.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Plan:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|c
operator|^
literal|100
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|link
operator|!=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Duplicate a pwd entry.  * Note: Only the useful things (what the program currently uses) are copied.  */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|pwdcopy
parameter_list|(
name|pfrom
parameter_list|)
specifier|register
name|struct
name|passwd
modifier|*
name|pfrom
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pto
decl_stmt|;
name|pto
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pto
argument_list|)
expr_stmt|;
define|#
directive|define
name|savestr
parameter_list|(
name|s
parameter_list|)
value|strcpy(malloc(strlen(s) + 1), s)
name|pto
operator|->
name|pw_name
operator|=
name|savestr
argument_list|(
name|pfrom
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|pto
operator|->
name|pw_uid
operator|=
name|pfrom
operator|->
name|pw_uid
expr_stmt|;
name|pto
operator|->
name|pw_gecos
operator|=
name|savestr
argument_list|(
name|pfrom
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|pto
operator|->
name|pw_dir
operator|=
name|savestr
argument_list|(
name|pfrom
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|pto
operator|->
name|pw_shell
operator|=
name|savestr
argument_list|(
name|pfrom
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|savestr
return|return
name|pto
return|;
block|}
end_function

begin_comment
comment|/*  * print out information on quick format giving just name, tty, login time  * and idle time if idle is set.  */
end_comment

begin_expr_stmt
name|quickprint
argument_list|(
name|pers
argument_list|)
specifier|register
expr|struct
name|person
operator|*
name|pers
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%-*.*s  "
argument_list|,
name|NMAX
argument_list|,
name|NMAX
argument_list|,
name|pers
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|loggedin
condition|)
block|{
if|if
condition|(
name|idle
condition|)
block|{
name|findidle
argument_list|(
name|pers
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%-*s %-16.16s"
argument_list|,
name|pers
operator|->
name|writable
condition|?
literal|' '
else|:
literal|'*'
argument_list|,
name|LMAX
argument_list|,
name|pers
operator|->
name|tty
argument_list|,
name|ctime
argument_list|(
operator|&
name|pers
operator|->
name|loginat
argument_list|)
argument_list|)
expr_stmt|;
name|ltimeprint
argument_list|(
literal|"   "
argument_list|,
operator|&
name|pers
operator|->
name|idletime
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" %-*s %-16.16s"
argument_list|,
name|LMAX
argument_list|,
name|pers
operator|->
name|tty
argument_list|,
name|ctime
argument_list|(
operator|&
name|pers
operator|->
name|loginat
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"          Not Logged In\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out information in short format, giving login name, full name,  * tty, idle time, login time, office location and phone.  */
end_comment

begin_expr_stmt
name|shortprint
argument_list|(
name|pers
argument_list|)
specifier|register
expr|struct
name|person
operator|*
name|pers
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|dialup
decl_stmt|;
if|if
condition|(
name|pers
operator|->
name|pwd
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%-15s       ???\n"
argument_list|,
name|pers
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|NMAX
argument_list|,
name|pers
operator|->
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|dialup
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wide
condition|)
block|{
if|if
condition|(
name|pers
operator|->
name|realname
condition|)
name|printf
argument_list|(
literal|" %-20.20s"
argument_list|,
name|pers
operator|->
name|realname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"        ???          "
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|loggedin
operator|&&
operator|!
name|pers
operator|->
name|writable
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pers
operator|->
name|tty
condition|)
block|{
if|if
condition|(
name|pers
operator|->
name|tty
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|pers
operator|->
name|tty
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|pers
operator|->
name|tty
index|[
literal|2
index|]
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|pers
operator|->
name|tty
index|[
literal|3
index|]
operator|==
literal|'d'
operator|&&
name|pers
operator|->
name|loggedin
condition|)
name|dialup
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%-2.2s "
argument_list|,
name|pers
operator|->
name|tty
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%-2.2s "
argument_list|,
name|pers
operator|->
name|tty
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|pers
operator|->
name|loginat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|loggedin
condition|)
block|{
name|stimeprint
argument_list|(
operator|&
name|pers
operator|->
name|idletime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3.3s %-5.5s "
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|11
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pers
operator|->
name|loginat
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"< .  .  .  .>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tloc
operator|-
name|pers
operator|->
name|loginat
operator|>=
literal|180
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
condition|)
name|printf
argument_list|(
literal|"<%-6.6s, %-4.4s>"
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<%-12.12s>"
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialup
operator|&&
name|pers
operator|->
name|homephone
condition|)
name|printf
argument_list|(
literal|" %20s"
argument_list|,
name|pers
operator|->
name|homephone
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pers
operator|->
name|office
condition|)
name|printf
argument_list|(
literal|" %-11.11s"
argument_list|,
name|pers
operator|->
name|office
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pers
operator|->
name|officephone
operator|||
name|pers
operator|->
name|homephone
condition|)
name|printf
argument_list|(
literal|"            "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|officephone
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pers
operator|->
name|officephone
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pers
operator|->
name|homephone
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pers
operator|->
name|homephone
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out a person in long format giving all possible information.  * directory and shell are inhibited if unbrief is clear.  */
end_comment

begin_expr_stmt
name|personprint
argument_list|(
name|pers
argument_list|)
specifier|register
expr|struct
name|person
operator|*
name|pers
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|pers
operator|->
name|pwd
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Login name: %-10s\t\t\tIn real life: ???\n"
argument_list|,
name|pers
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Login name: %-10s"
argument_list|,
name|pers
operator|->
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|loggedin
operator|&&
operator|!
name|pers
operator|->
name|writable
condition|)
name|printf
argument_list|(
literal|"	(messages off)	"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"			"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|realname
condition|)
name|printf
argument_list|(
literal|"In real life: %s"
argument_list|,
name|pers
operator|->
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|office
condition|)
block|{
name|printf
argument_list|(
literal|"\nOffice: %-.11s"
argument_list|,
name|pers
operator|->
name|office
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|officephone
condition|)
block|{
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|pers
operator|->
name|officephone
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|homephone
condition|)
name|printf
argument_list|(
literal|"\t\tHome phone: %s"
argument_list|,
name|pers
operator|->
name|homephone
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pers
operator|->
name|random
condition|)
name|printf
argument_list|(
literal|"\t\t%s"
argument_list|,
name|pers
operator|->
name|random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pers
operator|->
name|homephone
condition|)
name|printf
argument_list|(
literal|"\t\t\tHome phone: %s"
argument_list|,
name|pers
operator|->
name|homephone
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pers
operator|->
name|random
condition|)
name|printf
argument_list|(
literal|"\t\t\t%s"
argument_list|,
name|pers
operator|->
name|random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pers
operator|->
name|officephone
condition|)
block|{
name|printf
argument_list|(
literal|"\nPhone: %s"
argument_list|,
name|pers
operator|->
name|officephone
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|homephone
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|pers
operator|->
name|homephone
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|random
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|pers
operator|->
name|random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pers
operator|->
name|homephone
condition|)
block|{
name|printf
argument_list|(
literal|"\nPhone: %s"
argument_list|,
name|pers
operator|->
name|homephone
argument_list|)
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|random
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|pers
operator|->
name|random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pers
operator|->
name|random
condition|)
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|pers
operator|->
name|random
argument_list|)
expr_stmt|;
if|if
condition|(
name|unbrief
condition|)
block|{
name|printf
argument_list|(
literal|"\nDirectory: %-25s"
argument_list|,
name|pers
operator|->
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pers
operator|->
name|pwd
operator|->
name|pw_shell
condition|)
name|printf
argument_list|(
literal|"\tShell: %-s"
argument_list|,
name|pers
operator|->
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pers
operator|->
name|loggedin
condition|)
block|{
specifier|register
name|char
modifier|*
name|ep
init|=
name|ctime
argument_list|(
operator|&
name|pers
operator|->
name|loginat
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|pers
operator|->
name|host
condition|)
block|{
name|printf
argument_list|(
literal|"\nOn since %15.15s on %s from %s"
argument_list|,
operator|&
name|ep
index|[
literal|4
index|]
argument_list|,
name|pers
operator|->
name|tty
argument_list|,
name|pers
operator|->
name|host
argument_list|)
expr_stmt|;
name|ltimeprint
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|pers
operator|->
name|idletime
argument_list|,
literal|" Idle Time"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nOn since %15.15s on %-*s"
argument_list|,
operator|&
name|ep
index|[
literal|4
index|]
argument_list|,
name|LMAX
argument_list|,
name|pers
operator|->
name|tty
argument_list|)
expr_stmt|;
name|ltimeprint
argument_list|(
literal|"\t"
argument_list|,
operator|&
name|pers
operator|->
name|idletime
argument_list|,
literal|" Idle Time"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pers
operator|->
name|loginat
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\nNever logged in."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tloc
operator|-
name|pers
operator|->
name|loginat
operator|>
literal|180
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
condition|)
block|{
specifier|register
name|char
modifier|*
name|ep
init|=
name|ctime
argument_list|(
operator|&
name|pers
operator|->
name|loginat
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"\nLast login %10.10s, %4.4s on %s"
argument_list|,
name|ep
argument_list|,
name|ep
operator|+
literal|20
argument_list|,
name|pers
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pers
operator|->
name|host
condition|)
name|printf
argument_list|(
literal|" from %s"
argument_list|,
name|pers
operator|->
name|host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|ep
init|=
name|ctime
argument_list|(
operator|&
name|pers
operator|->
name|loginat
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"\nLast login %16.16s on %s"
argument_list|,
name|ep
argument_list|,
name|pers
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pers
operator|->
name|host
condition|)
name|printf
argument_list|(
literal|" from %s"
argument_list|,
name|pers
operator|->
name|host
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  very hacky section of code to format phone numbers.  filled with  *  magic constants like 4, 7 and 10.  */
end_comment

begin_function
name|char
modifier|*
name|phone
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|alldigits
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|alldigits
decl_stmt|;
block|{
name|char
name|fonebuf
index|[
literal|15
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|fonebuf
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|alldigits
condition|)
return|return
operator|(
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'x'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|5
case|:
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'x'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|7
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|10
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
return|return
literal|0
return|;
default|default:
return|return
operator|(
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|p
operator|-
name|fonebuf
argument_list|)
argument_list|,
name|fonebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * decode the information in the gecos field of /etc/passwd  */
end_comment

begin_expr_stmt
name|decode
argument_list|(
name|pers
argument_list|)
specifier|register
expr|struct
name|person
operator|*
name|pers
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|gp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|alldigits
decl_stmt|;
name|int
name|hasspace
decl_stmt|;
name|int
name|len
decl_stmt|;
name|pers
operator|->
name|realname
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|office
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|officephone
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|homephone
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|random
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pers
operator|->
name|pwd
operator|==
literal|0
condition|)
return|return;
name|gp
operator|=
name|pers
operator|->
name|pwd
operator|->
name|pw_gecos
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
operator|*
name|gp
operator|==
name|ASTERISK
condition|)
name|gp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|gp
operator|&&
operator|*
name|gp
operator|!=
name|COMMA
condition|)
comment|/* name */
if|if
condition|(
operator|*
name|gp
operator|==
name|SAMENAME
condition|)
block|{
name|lp
operator|=
name|pers
operator|->
name|pwd
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
name|toupper
argument_list|(
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|lp
operator|++
condition|)
empty_stmt|;
name|bp
operator|--
expr_stmt|;
name|gp
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|bp
operator|-
name|buffer
operator|)
operator|>
literal|1
condition|)
name|pers
operator|->
name|realname
operator|=
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|len
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|gp
operator|==
name|COMMA
condition|)
block|{
comment|/* office */
name|gp
operator|++
expr_stmt|;
name|hasspace
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|*
name|gp
operator|&&
operator|*
name|gp
operator|!=
name|COMMA
condition|)
block|{
operator|*
name|bp
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|' '
condition|)
name|hasspace
operator|=
literal|1
expr_stmt|;
comment|/* leave 5 for Cory and Evans expansion */
if|if
condition|(
name|bp
operator|<
name|buffer
operator|+
sizeof|sizeof
name|buffer
operator|-
literal|6
condition|)
name|bp
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|bp
operator|-
name|buffer
expr_stmt|;
name|bp
operator|--
expr_stmt|;
comment|/* point to last character */
if|if
condition|(
name|hasspace
operator|||
name|len
operator|==
literal|0
condition|)
name|len
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
name|CORY
condition|)
block|{
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|" Cory"
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
name|EVANS
condition|)
block|{
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|" Evans"
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|6
expr_stmt|;
block|}
else|else
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|pers
operator|->
name|office
operator|=
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|len
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|gp
operator|==
name|COMMA
condition|)
block|{
comment|/* office phone */
name|gp
operator|++
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|alldigits
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|gp
operator|&&
operator|*
name|gp
operator|!=
name|COMMA
condition|)
block|{
operator|*
name|bp
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|alldigits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|<
name|buffer
operator|+
sizeof|sizeof
name|buffer
operator|-
literal|1
condition|)
name|bp
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|officephone
operator|=
name|phone
argument_list|(
name|buffer
argument_list|,
name|bp
operator|-
name|buffer
argument_list|,
name|alldigits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|gp
operator|==
name|COMMA
condition|)
block|{
comment|/* home phone */
name|gp
operator|++
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|alldigits
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|gp
operator|&&
operator|*
name|gp
operator|!=
name|COMMA
condition|)
block|{
operator|*
name|bp
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|alldigits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|<
name|buffer
operator|+
sizeof|sizeof
name|buffer
operator|-
literal|1
condition|)
name|bp
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|homephone
operator|=
name|phone
argument_list|(
name|buffer
argument_list|,
name|bp
operator|-
name|buffer
argument_list|,
name|alldigits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pers
operator|->
name|loggedin
condition|)
name|findidle
argument_list|(
name|pers
argument_list|)
expr_stmt|;
else|else
name|findwhen
argument_list|(
name|pers
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find the last log in of a user by checking the LASTLOG file.  * the entry is indexed by the uid, so this can only be done if  * the uid is known (which it isn't in quick mode)  */
end_comment

begin_macro
name|fwopen
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|lf
operator|=
name|open
argument_list|(
name|LASTLOG
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finger: %s open error\n"
argument_list|,
name|LASTLOG
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|findwhen
argument_list|(
name|pers
argument_list|)
specifier|register
expr|struct
name|person
operator|*
name|pers
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|lastlog
name|ll
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lf
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|lf
argument_list|,
operator|(
name|long
operator|)
name|pers
operator|->
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
name|ll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|lf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
operator|)
operator|==
sizeof|sizeof
name|ll
condition|)
block|{
name|bcopy
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|,
name|pers
operator|->
name|tty
argument_list|,
name|LMAX
argument_list|)
expr_stmt|;
name|pers
operator|->
name|tty
index|[
name|LMAX
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|,
name|pers
operator|->
name|host
argument_list|,
name|HMAX
argument_list|)
expr_stmt|;
name|pers
operator|->
name|host
index|[
name|HMAX
index|]
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|loginat
operator|=
name|ll
operator|.
name|ll_time
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finger: %s read error\n"
argument_list|,
name|LASTLOG
argument_list|)
expr_stmt|;
name|pers
operator|->
name|tty
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|host
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|loginat
operator|=
literal|0L
expr_stmt|;
block|}
block|}
else|else
block|{
name|pers
operator|->
name|tty
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|host
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pers
operator|->
name|loginat
operator|=
literal|0L
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fwclose
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|lf
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find the idle time of a user by doing a stat on /dev/tty??,  * where tty?? has been gotten from USERLOG, supposedly.  */
end_comment

begin_expr_stmt
name|findidle
argument_list|(
name|pers
argument_list|)
specifier|register
expr|struct
name|person
operator|*
name|pers
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|ttystatus
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
init|=
literal|"/dev/"
decl_stmt|;
name|long
name|t
decl_stmt|;
define|#
directive|define
name|TTYLEN
value|5
name|strcpy
argument_list|(
name|buffer
operator|+
name|TTYLEN
argument_list|,
name|pers
operator|->
name|tty
argument_list|)
expr_stmt|;
name|buffer
index|[
name|TTYLEN
operator|+
name|LMAX
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buffer
argument_list|,
operator|&
name|ttystatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finger: Can't stat %s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|ttystatus
operator|.
name|st_atime
condition|)
name|pers
operator|->
name|idletime
operator|=
literal|0L
expr_stmt|;
else|else
name|pers
operator|->
name|idletime
operator|=
name|t
operator|-
name|ttystatus
operator|.
name|st_atime
expr_stmt|;
name|pers
operator|->
name|writable
operator|=
operator|(
name|ttystatus
operator|.
name|st_mode
operator|&
name|TALKABLE
operator|)
operator|==
name|TALKABLE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print idle time in short format; this program always prints 4 characters;  * if the idle time is zero, it prints 4 blanks.  */
end_comment

begin_macro
name|stimeprint
argument_list|(
argument|dt
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tm
modifier|*
name|delta
decl_stmt|;
name|delta
operator|=
name|gmtime
argument_list|(
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|tm_yday
operator|==
literal|0
condition|)
if|if
condition|(
name|delta
operator|->
name|tm_hour
operator|==
literal|0
condition|)
if|if
condition|(
name|delta
operator|->
name|tm_min
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %2d"
argument_list|,
name|delta
operator|->
name|tm_min
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|->
name|tm_hour
operator|>=
literal|10
condition|)
name|printf
argument_list|(
literal|"%3d:"
argument_list|,
name|delta
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%1d:%02d"
argument_list|,
name|delta
operator|->
name|tm_hour
argument_list|,
name|delta
operator|->
name|tm_min
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%3dd"
argument_list|,
name|delta
operator|->
name|tm_yday
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print idle time in long format with care being taken not to pluralize  * 1 minutes or 1 hours or 1 days.  * print "prefix" first.  */
end_comment

begin_macro
name|ltimeprint
argument_list|(
argument|before
argument_list|,
argument|dt
argument_list|,
argument|after
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|before
decl_stmt|,
modifier|*
name|after
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tm
modifier|*
name|delta
decl_stmt|;
name|delta
operator|=
name|gmtime
argument_list|(
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|tm_yday
operator|==
literal|0
operator|&&
name|delta
operator|->
name|tm_hour
operator|==
literal|0
operator|&&
name|delta
operator|->
name|tm_min
operator|==
literal|0
operator|&&
name|delta
operator|->
name|tm_sec
operator|<=
literal|10
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|tm_yday
operator|>=
literal|10
condition|)
name|printf
argument_list|(
literal|"%d days"
argument_list|,
name|delta
operator|->
name|tm_yday
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|->
name|tm_yday
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d day%s %d hour%s"
argument_list|,
name|delta
operator|->
name|tm_yday
argument_list|,
name|delta
operator|->
name|tm_yday
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|delta
operator|->
name|tm_hour
argument_list|,
name|delta
operator|->
name|tm_hour
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|->
name|tm_hour
operator|>=
literal|10
condition|)
name|printf
argument_list|(
literal|"%d hours"
argument_list|,
name|delta
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|->
name|tm_hour
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d hour%s %d minute%s"
argument_list|,
name|delta
operator|->
name|tm_hour
argument_list|,
name|delta
operator|->
name|tm_hour
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|delta
operator|->
name|tm_min
argument_list|,
name|delta
operator|->
name|tm_min
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|->
name|tm_min
operator|>=
literal|10
condition|)
name|printf
argument_list|(
literal|"%2d minutes"
argument_list|,
name|delta
operator|->
name|tm_min
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|->
name|tm_min
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%2d seconds"
argument_list|,
name|delta
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d minute%s %d second%s"
argument_list|,
name|delta
operator|->
name|tm_min
argument_list|,
name|delta
operator|->
name|tm_min
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|delta
operator|->
name|tm_sec
argument_list|,
name|delta
operator|->
name|tm_sec
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|matchcmp
argument_list|(
name|gname
argument_list|,
name|login
argument_list|,
name|given
argument_list|)
specifier|register
name|char
operator|*
name|gname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|login
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|given
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|gname
operator|==
name|ASTERISK
condition|)
name|gname
operator|++
expr_stmt|;
name|lp
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|gname
operator|++
condition|)
block|{
case|case
name|SAMENAME
case|:
for|for
control|(
name|lp
operator|=
name|login
init|;
name|bp
operator|<
name|buffer
operator|+
sizeof|sizeof
name|buffer
operator|&&
operator|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|lp
operator|++
operator|)
condition|;
control|)
empty_stmt|;
name|bp
operator|--
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
name|COMMA
case|:
case|case
literal|'\0'
case|:
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namecmp
argument_list|(
name|buffer
argument_list|,
name|given
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|COMMA
operator|||
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bp
operator|=
name|buffer
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|bp
operator|<
name|buffer
operator|+
sizeof|sizeof
name|buffer
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_expr_stmt
name|namecmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
specifier|register
name|char
operator|*
name|name1
operator|,
operator|*
name|name2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c1
operator|,
name|c2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c1
operator|=
operator|*
name|name1
operator|++
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|toupper
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|c2
operator|=
operator|*
name|name2
operator|++
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|toupper
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
if|if
condition|(
name|c1
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|c1
condition|)
block|{
for|for
control|(
name|name2
operator|--
init|;
name|isdigit
argument_list|(
operator|*
name|name2
argument_list|)
condition|;
name|name2
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|name2
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c2
condition|)
block|{
for|for
control|(
name|name1
operator|--
init|;
name|isdigit
argument_list|(
operator|*
name|name1
argument_list|)
condition|;
name|name1
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|name2
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|netfinger
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|host
decl_stmt|;
name|char
name|fname
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|;
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|lastc
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|host
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|host
operator|++
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
specifier|static
name|struct
name|hostent
name|def
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|defaddr
decl_stmt|;
specifier|static
name|char
modifier|*
name|alist
index|[
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|namebuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|inet_addr
parameter_list|()
function_decl|;
name|defaddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaddr
operator|.
name|s_addr
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"unknown host: %s\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|namebuf
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|def
operator|.
name|h_name
operator|=
name|namebuf
expr_stmt|;
name|def
operator|.
name|h_addr_list
operator|=
name|alist
operator|,
name|def
operator|.
name|h_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|defaddr
expr_stmt|;
name|def
operator|.
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|def
operator|.
name|h_addrtype
operator|=
name|AF_INET
expr_stmt|;
name|def
operator|.
name|h_aliases
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
operator|&
name|def
expr_stmt|;
block|}
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"finger"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"tcp/finger: unknown service\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|hp
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"[%s]\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|large
condition|)
name|write
argument_list|(
name|s
argument_list|,
literal|"/W "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|s
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|s
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|f
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0210
case|:
case|case
literal|0211
case|:
case|case
literal|0212
case|:
case|case
literal|0214
case|:
name|c
operator|-=
literal|0200
expr_stmt|;
break|break;
case|case
literal|0215
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
name|lastc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|c
operator|^
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastc
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

