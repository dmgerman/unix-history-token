begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)more.c	5.19 (Berkeley) 6/29/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* ** more.c - General purpose tty output filter and file perusal program ** **	by Eric Shienbrood, UC Berkeley ** **	modified by Geoff Peck, UCB to add underlining, single spacing **	modified by John Foderaro, UCB to add -c and MORE environment variable */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|HELPFILE
value|"/usr/lib/more.help"
end_define

begin_define
define|#
directive|define
name|VI
value|"/usr/ucb/vi"
end_define

begin_define
define|#
directive|define
name|Fopen
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
value|(Currline = 0,file_pos=0,fopen(s,m))
end_define

begin_define
define|#
directive|define
name|Ftell
parameter_list|(
name|f
parameter_list|)
value|file_pos
end_define

begin_define
define|#
directive|define
name|Fseek
parameter_list|(
name|f
parameter_list|,
name|off
parameter_list|)
value|(file_pos=off,fseek(f,off,0))
end_define

begin_define
define|#
directive|define
name|Getc
parameter_list|(
name|f
parameter_list|)
value|(++file_pos, getc(f))
end_define

begin_define
define|#
directive|define
name|Ungetc
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
value|(--file_pos, ungetc(c,f))
end_define

begin_define
define|#
directive|define
name|MBIT
value|CBREAK
end_define

begin_define
define|#
directive|define
name|stty
parameter_list|(
name|fd
parameter_list|,
name|argp
parameter_list|)
value|ioctl(fd,TIOCSETN,argp)
end_define

begin_define
define|#
directive|define
name|TBUFSIZ
value|1024
end_define

begin_define
define|#
directive|define
name|LINSIZ
value|256
end_define

begin_define
define|#
directive|define
name|ctrl
parameter_list|(
name|letter
parameter_list|)
value|(letter& 077)
end_define

begin_define
define|#
directive|define
name|RUBOUT
value|'\177'
end_define

begin_define
define|#
directive|define
name|ESC
value|'\033'
end_define

begin_define
define|#
directive|define
name|QUIT
value|'\034'
end_define

begin_decl_stmt
name|struct
name|sgttyb
name|otty
decl_stmt|,
name|savetty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|file_pos
decl_stmt|,
name|file_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fnum
decl_stmt|,
name|no_intty
decl_stmt|,
name|no_tty
decl_stmt|,
name|slow_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dum_opt
decl_stmt|,
name|dlines
decl_stmt|,
name|onquit
argument_list|()
decl_stmt|,
name|end_it
argument_list|()
decl_stmt|,
name|chgwinsz
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|onsusp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nscroll
init|=
literal|11
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines scrolled by 'd' */
end_comment

begin_decl_stmt
name|int
name|fold_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fold long lines */
end_comment

begin_decl_stmt
name|int
name|stop_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop after form feeds */
end_comment

begin_decl_stmt
name|int
name|ssp_opt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress white space */
end_comment

begin_decl_stmt
name|int
name|ul_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Underline as best we can */
end_comment

begin_decl_stmt
name|int
name|promptlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Currline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line we are currently at */
end_comment

begin_decl_stmt
name|int
name|startup
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|firstf
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|notell
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|docrterase
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|docrtkill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bad_so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if overwriting does not turn off standout */
end_comment

begin_decl_stmt
name|int
name|inwait
decl_stmt|,
name|Pause
decl_stmt|,
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|within
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we are within a file, 			false if we are between files */
end_comment

begin_decl_stmt
name|int
name|hard
decl_stmt|,
name|dumb
decl_stmt|,
name|noscroll
decl_stmt|,
name|hardtabs
decl_stmt|,
name|clreol
decl_stmt|,
name|eatnl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|catch_susp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We should catch the SIGTSTP signal */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|fnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of file names */
end_comment

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of files left to process */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the shell to use */
end_comment

begin_decl_stmt
name|int
name|shellp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A previous shell command exists */
end_comment

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|restore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Line
index|[
name|LINSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line buffer */
end_comment

begin_decl_stmt
name|int
name|Lpp
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines per page */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Clear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear screen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|eraseln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* erase line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Senter
decl_stmt|,
modifier|*
name|Sexit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enter and exit standout mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ULenter
decl_stmt|,
modifier|*
name|ULexit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enter and exit underline mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|chUL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* underline character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|chBS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backspace character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Home
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* go to home */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cursorm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor movement */
end_comment

begin_decl_stmt
name|char
name|cursorhome
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contains cursor movement to home */
end_comment

begin_decl_stmt
name|char
modifier|*
name|EodClr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear rest of screen */
end_comment

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|Mcol
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of columns */
end_comment

begin_decl_stmt
name|int
name|Wrap
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if automargins */
end_comment

begin_decl_stmt
name|int
name|soglitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal has standout mode glitch */
end_comment

begin_decl_stmt
name|int
name|ulglitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal has underline mode glitch */
end_comment

begin_decl_stmt
name|int
name|pstate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current UL state */
end_comment

begin_function_decl
name|long
name|fseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
block|{
name|long
name|chrctr
decl_stmt|,
name|line
decl_stmt|;
block|}
name|context
struct|,
name|screen_start
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pad character */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|left
decl_stmt|;
name|int
name|prnames
init|=
literal|0
decl_stmt|;
name|int
name|initopt
init|=
literal|0
decl_stmt|;
name|int
name|srchopt
init|=
literal|0
decl_stmt|;
name|int
name|clearit
init|=
literal|0
decl_stmt|;
name|int
name|initline
decl_stmt|;
name|char
name|initbuf
index|[
literal|80
index|]
decl_stmt|;
name|FILE
modifier|*
name|checkf
parameter_list|()
function_decl|;
name|nfiles
operator|=
name|argc
expr_stmt|;
name|fnames
operator|=
name|argv
expr_stmt|;
name|initterm
argument_list|()
expr_stmt|;
name|nscroll
operator|=
name|Lpp
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nscroll
operator|<=
literal|0
condition|)
name|nscroll
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|getenv
argument_list|(
literal|"MORE"
argument_list|)
condition|)
name|argscan
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nfiles
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|(
operator|*
operator|++
name|fnames
operator|)
index|[
literal|0
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
name|argscan
argument_list|(
operator|*
name|fnames
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|s
operator|=
operator|*
name|fnames
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'/'
condition|)
block|{
name|srchopt
operator|++
expr_stmt|;
for|for
control|(
operator|++
name|s
operator|,
name|p
operator|=
name|initbuf
init|;
name|p
operator|<
name|initbuf
operator|+
literal|79
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|initopt
operator|++
expr_stmt|;
for|for
control|(
name|initline
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|initline
operator|=
name|initline
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|--
name|initline
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
comment|/* allow clreol only if Home and eraseln and EodClr strings are      *  defined, and in that case, make sure we are in noscroll mode      */
if|if
condition|(
name|clreol
condition|)
block|{
if|if
condition|(
operator|(
name|Home
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|Home
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|eraseln
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|eraseln
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|EodClr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|EodClr
operator|==
literal|'\0'
operator|)
condition|)
name|clreol
operator|=
literal|0
expr_stmt|;
else|else
name|noscroll
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dlines
operator|==
literal|0
condition|)
name|dlines
operator|=
name|Lpp
operator|-
operator|(
name|noscroll
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|left
operator|=
name|dlines
expr_stmt|;
if|if
condition|(
name|nfiles
operator|>
literal|1
condition|)
name|prnames
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
operator|&&
name|nfiles
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|p
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"usage: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" [-dfln] [+linenum | +/pattern] name1 name2 ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|no_tty
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|end_it
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|chgwinsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_DFL
condition|)
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
name|catch_susp
operator|++
expr_stmt|;
block|}
name|stty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_intty
condition|)
block|{
if|if
condition|(
name|no_tty
condition|)
name|copy_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'\f'
condition|)
name|doclear
argument_list|()
expr_stmt|;
else|else
block|{
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
operator|&&
operator|(
name|ch
operator|!=
name|EOF
operator|)
condition|)
block|{
if|if
condition|(
name|clreol
condition|)
name|home
argument_list|()
expr_stmt|;
else|else
name|doclear
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|srchopt
condition|)
block|{
name|search
argument_list|(
name|initbuf
argument_list|,
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
name|left
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initopt
condition|)
name|skiplns
argument_list|(
name|initline
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|stdin
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
name|no_intty
operator|=
literal|0
expr_stmt|;
name|prnames
operator|++
expr_stmt|;
name|firstf
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|fnum
operator|<
name|nfiles
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|checkf
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|,
operator|&
name|clearit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|context
operator|.
name|line
operator|=
name|context
operator|.
name|chrctr
operator|=
literal|0
expr_stmt|;
name|Currline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|firstf
condition|)
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstf
condition|)
block|{
name|firstf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|srchopt
condition|)
block|{
name|search
argument_list|(
name|initbuf
argument_list|,
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
name|left
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initopt
condition|)
name|skiplns
argument_list|(
name|initline
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fnum
operator|<
name|nfiles
operator|&&
operator|!
name|no_tty
condition|)
block|{
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|left
operator|=
name|command
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|noscroll
operator|||
name|clearit
operator|)
operator|&&
operator|(
name|file_size
operator|!=
name|LONG_MAX
operator|)
condition|)
if|if
condition|(
name|clreol
condition|)
name|home
argument_list|()
expr_stmt|;
else|else
name|doclear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prnames
condition|)
block|{
if|if
condition|(
name|bad_so
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"::::::::::::::"
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptlen
operator|>
literal|14
condition|)
name|erase
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"::::::::::::::\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|Lpp
operator|-
literal|4
condition|)
name|left
operator|=
name|Lpp
operator|-
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|no_tty
condition|)
name|copy_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|within
operator|++
expr_stmt|;
name|screen
argument_list|(
name|f
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|within
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|screen_start
operator|.
name|line
operator|=
name|screen_start
operator|.
name|chrctr
operator|=
literal|0L
expr_stmt|;
name|context
operator|.
name|line
operator|=
name|context
operator|.
name|chrctr
operator|=
literal|0L
expr_stmt|;
block|}
name|fnum
operator|++
expr_stmt|;
name|firstf
operator|=
literal|0
expr_stmt|;
block|}
name|reset_tty
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|argscan
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|seen_num
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|!
name|seen_num
condition|)
block|{
name|dlines
operator|=
literal|0
expr_stmt|;
name|seen_num
operator|=
literal|1
expr_stmt|;
block|}
name|dlines
operator|=
name|dlines
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dum_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|stop_opt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fold_opt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|noscroll
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|clreol
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ssp_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ul_opt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** Check whether the file named by fs is an ASCII file which the user may ** access.  If it is, return the opened file. Otherwise return NULL. */
end_comment

begin_function
name|FILE
modifier|*
name|checkf
parameter_list|(
name|fs
parameter_list|,
name|clearfirst
parameter_list|)
specifier|register
name|char
modifier|*
name|fs
decl_stmt|;
name|int
modifier|*
name|clearfirst
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fs
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|perror
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|printf
argument_list|(
literal|"\n*** %s: directory ***\n\n"
argument_list|,
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|Fopen
argument_list|(
name|fs
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|magic
argument_list|(
name|f
argument_list|,
name|fs
argument_list|)
condition|)
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|*
name|clearfirst
operator|=
name|c
operator|==
literal|'\f'
expr_stmt|;
name|Ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file_size
operator|=
name|stbuf
operator|.
name|st_size
operator|)
operator|==
literal|0
condition|)
name|file_size
operator|=
name|LONG_MAX
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * magic --  *	check for file magic numbers.  This code would best be shared with  *	the file(1) program or, perhaps, more should not try and be so smart?  */
end_comment

begin_expr_stmt
specifier|static
name|magic
argument_list|(
argument|f
argument_list|,
argument|fs
argument_list|)
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|exec
name|ex
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|ex
argument_list|,
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|==
literal|1
condition|)
switch|switch
condition|(
name|ex
operator|.
name|a_magic
condition|)
block|{
case|case
name|OMAGIC
case|:
case|case
name|NMAGIC
case|:
case|case
name|ZMAGIC
case|:
case|case
literal|0405
case|:
case|case
literal|0411
case|:
case|case
literal|0177545
case|:
name|printf
argument_list|(
literal|"\n******** %s: Not a text file ********\n\n"
argument_list|,
name|fs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
comment|/* rewind() not necessary */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** A real function, for the tputs routine in termlib */
end_comment

begin_macro
name|putch
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Print out the contents of the file f, one screenful at a time. */
end_comment

begin_define
define|#
directive|define
name|STOP
value|-10
end_define

begin_expr_stmt
name|screen
argument_list|(
name|f
argument_list|,
name|num_lines
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|num_lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|nchars
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of current line */
specifier|static
name|int
name|prev_len
init|=
literal|1
decl_stmt|;
comment|/* length of previous line */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|num_lines
operator|>
literal|0
operator|&&
operator|!
name|Pause
condition|)
block|{
if|if
condition|(
operator|(
name|nchars
operator|=
name|getline
argument_list|(
name|f
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|clreol
condition|)
name|clreos
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ssp_opt
operator|&&
name|length
operator|==
literal|0
operator|&&
name|prev_len
operator|==
literal|0
condition|)
continue|continue;
name|prev_len
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|bad_so
operator|||
operator|(
name|Senter
operator|&&
operator|*
name|Senter
operator|==
literal|' '
operator|)
operator|&&
name|promptlen
operator|>
literal|0
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* must clear before drawing line since tabs on some terminals 	     * do not erase what they tab over. 	     */
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|prbuf
argument_list|(
name|Line
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
name|promptlen
condition|)
name|erase
argument_list|(
name|nchars
argument_list|)
expr_stmt|;
comment|/* erase () sets promptlen to 0 */
else|else
name|promptlen
operator|=
literal|0
expr_stmt|;
comment|/* is this needed? 	     * if (clreol) 	     *	cleareol();	/* must clear again in case we wrapped * 	     */
if|if
condition|(
name|nchars
operator|<
name|Mcol
operator|||
operator|!
name|fold_opt
condition|)
name|prbuf
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* will turn off UL if necessary */
if|if
condition|(
name|nchars
operator|==
name|STOP
condition|)
break|break;
name|num_lines
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pstate
condition|)
block|{
name|tputs
argument_list|(
name|ULexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|pstate
operator|=
literal|0
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|clreol
condition|)
name|clreos
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Pause
operator|&&
name|clreol
condition|)
name|clreos
argument_list|()
expr_stmt|;
name|Ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|Pause
operator|=
literal|0
expr_stmt|;
name|startup
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|num_lines
operator|=
name|command
argument_list|(
name|NULL
argument_list|,
name|f
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hard
operator|&&
name|promptlen
operator|>
literal|0
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
operator|&&
name|num_lines
operator|>=
name|dlines
condition|)
block|{
if|if
condition|(
name|clreol
condition|)
name|home
argument_list|()
expr_stmt|;
else|else
name|doclear
argument_list|()
expr_stmt|;
block|}
name|screen_start
operator|.
name|line
operator|=
name|Currline
expr_stmt|;
name|screen_start
operator|.
name|chrctr
operator|=
name|Ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** Come here if a quit signal is received */
end_comment

begin_macro
name|onquit
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inwait
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startup
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|Pause
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dum_opt
operator|&&
name|notell
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"[Use q or Q to quit]"
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|promptlen
operator|+=
literal|20
expr_stmt|;
name|notell
operator|=
literal|0
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Come here if a signal for a window size change is received */
end_comment

begin_macro
name|chgwinsz
argument_list|()
end_macro

begin_block
block|{
name|struct
name|winsize
name|win
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|win
operator|.
name|ws_row
operator|!=
literal|0
condition|)
block|{
name|Lpp
operator|=
name|win
operator|.
name|ws_row
expr_stmt|;
name|nscroll
operator|=
name|Lpp
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nscroll
operator|<=
literal|0
condition|)
name|nscroll
operator|=
literal|1
expr_stmt|;
name|dlines
operator|=
name|Lpp
operator|-
operator|(
name|noscroll
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|win
operator|.
name|ws_col
operator|!=
literal|0
condition|)
name|Mcol
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|chgwinsz
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Clean up terminal state and exit. Also come here if interrupt signal received */
end_comment

begin_macro
name|end_it
argument_list|()
end_macro

begin_block
block|{
name|reset_tty
argument_list|()
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|clreos
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|clreol
operator|&&
operator|(
name|promptlen
operator|>
literal|0
operator|)
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|copy_file
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Simplified printf function */
end_comment

begin_expr_stmt
name|printf
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
specifier|register
name|char
operator|*
name|fmt
expr_stmt|;
end_expr_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|ccount
decl_stmt|;
name|ccount
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
condition|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ccount
operator|)
return|;
name|ccount
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'d'
case|:
name|ccount
operator|+=
name|printd
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ccount
operator|+=
name|pr
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|ccount
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
return|return
operator|(
name|ccount
operator|)
return|;
default|default:
break|break;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccount
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Print an integer as a string of decimal digits, ** returning the length of the print representation. */
end_comment

begin_macro
name|printd
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|a
decl_stmt|,
name|nchars
decl_stmt|;
if|if
condition|(
name|a
operator|=
name|n
operator|/
literal|10
condition|)
name|nchars
operator|=
literal|1
operator|+
name|printd
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|nchars
operator|=
literal|1
expr_stmt|;
name|putchar
argument_list|(
name|n
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|nchars
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Put the print representation of an integer into a string */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_macro
name|scanstr
argument_list|(
argument|n
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sptr
operator|=
name|str
expr_stmt|;
name|Sprintf
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|sptr
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|Sprintf
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|int
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|=
name|n
operator|/
literal|10
condition|)
name|Sprintf
argument_list|(
name|a
argument_list|)
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|bell
init|=
name|ctrl
argument_list|(
literal|'G'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|strlen
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|p
operator|-
name|s
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* See whether the last component of the path name "path" is equal to the ** string "string" */
end_comment

begin_macro
name|tailequ
argument_list|(
argument|path
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tail
decl_stmt|;
name|tail
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|tail
operator|>=
name|path
condition|)
if|if
condition|(
operator|*
operator|(
operator|--
name|tail
operator|)
operator|==
literal|'/'
condition|)
break|break;
operator|++
name|tail
expr_stmt|;
while|while
condition|(
operator|*
name|tail
operator|++
operator|==
operator|*
name|string
operator|++
condition|)
if|if
condition|(
operator|*
name|tail
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|prompt
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|promptlen
operator|>
literal|0
condition|)
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hard
condition|)
block|{
name|promptlen
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
block|{
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|promptlen
operator|+=
operator|(
literal|2
operator|*
name|soglitch
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"--More--"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
block|{
name|promptlen
operator|+=
name|printf
argument_list|(
literal|"(Next file: %s)"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|promptlen
operator|+=
name|printf
argument_list|(
literal|"(%d%%)"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|file_pos
operator|*
literal|100
operator|)
operator|/
name|file_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dum_opt
condition|)
block|{
name|promptlen
operator|+=
name|pr
argument_list|(
literal|"[Press space to continue, 'q' to quit.]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|clreos
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inwait
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Get a logical line */
end_comment

begin_expr_stmt
name|getline
argument_list|(
name|f
argument_list|,
name|length
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|column
decl_stmt|;
specifier|static
name|int
name|colflg
decl_stmt|;
name|p
operator|=
name|Line
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|colflg
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
name|Currline
operator|++
expr_stmt|;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
operator|&
name|Line
index|[
name|LINSIZ
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|Line
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|Currline
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
if|if
condition|(
operator|!
name|hardtabs
operator|||
name|column
operator|<
name|promptlen
operator|&&
operator|!
name|hard
condition|)
block|{
if|if
condition|(
name|hardtabs
operator|&&
name|eraseln
operator|&&
operator|!
name|dumb
condition|)
block|{
name|column
operator|=
literal|1
operator|+
operator|(
name|column
operator||
literal|7
operator|)
expr_stmt|;
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
operator|--
name|p
init|;
name|p
operator|<
operator|&
name|Line
index|[
name|LINSIZ
operator|-
literal|1
index|]
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|column
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|column
operator|>=
name|promptlen
condition|)
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|column
operator|=
literal|1
operator|+
operator|(
name|column
operator||
literal|7
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\b'
operator|&&
name|column
operator|>
literal|0
condition|)
name|column
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|column
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\f'
operator|&&
name|stop_opt
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
name|column
operator|+=
literal|2
expr_stmt|;
name|Pause
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|!=
name|RUBOUT
condition|)
name|column
operator|++
expr_stmt|;
if|if
condition|(
name|column
operator|>=
name|Mcol
operator|&&
name|fold_opt
condition|)
break|break;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|>=
name|Mcol
operator|&&
name|Mcol
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Wrap
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
name|colflg
operator|=
name|column
operator|==
name|Mcol
operator|&&
name|fold_opt
expr_stmt|;
if|if
condition|(
name|colflg
operator|&&
name|eatnl
operator|&&
name|Wrap
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* simulate normal wrap */
block|}
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Erase the rest of the prompt, assuming we are starting at column col. */
end_comment

begin_expr_stmt
name|erase
argument_list|(
name|col
argument_list|)
specifier|register
name|int
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|promptlen
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hard
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumb
operator|&&
name|eraseln
condition|)
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|col
operator|=
name|promptlen
operator|-
name|col
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Erase the current line entirely */
end_comment

begin_macro
name|kill_line
argument_list|()
end_macro

begin_block
block|{
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eraseln
operator|||
name|dumb
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * force clear to end of line  */
end_comment

begin_macro
name|cleareol
argument_list|()
end_macro

begin_block
block|{
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|clreos
argument_list|()
end_macro

begin_block
block|{
name|tputs
argument_list|(
name|EodClr
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  Print string and return number of characters */
end_comment

begin_macro
name|pr
argument_list|(
argument|s1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|s
operator|=
name|s1
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|-
name|s1
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Print a buffer of n characters */
end_comment

begin_expr_stmt
name|prbuf
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
comment|/* next output character */
specifier|register
name|int
name|state
decl_stmt|;
comment|/* next output char's UL state */
define|#
directive|define
name|wouldul
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|((n)>= 2&& (((s)[0] == '_'&& (s)[1] == '\b') || ((s)[1] == '\b'&& (s)[2] == '_')))
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|ul_opt
condition|)
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|&&
name|pstate
operator|==
literal|0
operator|&&
name|ulglitch
operator|&&
name|wouldul
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|=
name|wouldul
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|c
operator|=
operator|(
operator|*
name|s
operator|==
literal|'_'
operator|)
condition|?
name|s
index|[
literal|2
index|]
else|:
operator|*
name|s
expr_stmt|;
name|n
operator|-=
literal|2
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|pstate
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|state
operator|==
literal|0
operator|&&
name|ulglitch
operator|&&
name|wouldul
argument_list|(
name|s
argument_list|,
name|n
operator|-
literal|1
argument_list|)
condition|)
name|state
operator|=
literal|1
expr_stmt|;
else|else
name|tputs
argument_list|(
name|state
condition|?
name|ULenter
else|:
name|ULexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|' '
operator|||
name|pstate
operator|==
literal|0
operator|||
name|state
operator|!=
literal|0
operator|||
name|ulglitch
operator|==
literal|0
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|&&
operator|*
name|chUL
condition|)
block|{
name|pr
argument_list|(
name|chBS
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|chUL
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
name|pstate
operator|=
name|state
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* **  Clear the screen */
end_comment

begin_macro
name|doclear
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Clear
operator|&&
operator|!
name|hard
condition|)
block|{
name|tputs
argument_list|(
name|Clear
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
comment|/* Put out carriage return so that system doesn't 	** get confused by escape sequences when expanding tabs 	*/
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Go to home position  */
end_comment

begin_macro
name|home
argument_list|()
end_macro

begin_block
block|{
name|tputs
argument_list|(
name|Home
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|lastcmd
decl_stmt|,
name|lastarg
decl_stmt|,
name|lastp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastcolon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shell_line
index|[
literal|132
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Read a command and do it. A command consists of an optional integer ** argument followed by the command character.  Return the number of lines ** to display in the next screenful.  If there is nothing more to display ** in the current file, zero is returned. */
end_comment

begin_macro
name|command
argument_list|(
argument|filename
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nlines
decl_stmt|;
specifier|register
name|int
name|retval
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
name|colonch
decl_stmt|;
name|FILE
modifier|*
name|helpf
decl_stmt|;
name|int
name|done
decl_stmt|;
name|char
name|comchar
decl_stmt|,
name|cmdbuf
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|ret
parameter_list|(
name|val
parameter_list|)
value|retval=val;done++;break
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
condition|)
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|errors
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|RAW
operator|&&
name|slow_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
name|stty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|nlines
operator|=
name|number
argument_list|(
operator|&
name|comchar
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|colonch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
literal|'.'
condition|)
block|{
comment|/* Repeat last command */
name|lastp
operator|++
expr_stmt|;
name|comchar
operator|=
name|lastcmd
expr_stmt|;
name|nlines
operator|=
name|lastarg
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|==
literal|':'
condition|)
name|colonch
operator|=
name|lastcolon
expr_stmt|;
block|}
name|lastcmd
operator|=
name|comchar
expr_stmt|;
name|lastarg
operator|=
name|nlines
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
name|otty
operator|.
name|sg_erase
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|comchar
condition|)
block|{
case|case
literal|':'
case|:
name|retval
operator|=
name|colon
argument_list|(
name|filename
argument_list|,
name|colonch
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>=
literal|0
condition|)
name|done
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
name|ctrl
argument_list|(
literal|'B'
argument_list|)
case|:
block|{
specifier|register
name|int
name|initline
decl_stmt|;
if|if
condition|(
name|no_intty
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"...back %d page"
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|1
condition|)
name|pr
argument_list|(
literal|"s\n"
argument_list|)
expr_stmt|;
else|else
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|initline
operator|=
name|Currline
operator|-
name|dlines
operator|*
operator|(
name|nlines
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|noscroll
condition|)
operator|--
name|initline
expr_stmt|;
if|if
condition|(
name|initline
operator|<
literal|0
condition|)
name|initline
operator|=
literal|0
expr_stmt|;
name|Fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|Currline
operator|=
literal|0
expr_stmt|;
comment|/* skiplns() will make Currline correct */
name|skiplns
argument_list|(
name|initline
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noscroll
condition|)
block|{
name|ret
argument_list|(
name|dlines
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
block|}
block|}
case|case
literal|' '
case|:
case|case
literal|'z'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|=
name|dlines
expr_stmt|;
elseif|else
if|if
condition|(
name|comchar
operator|==
literal|'z'
condition|)
name|dlines
operator|=
name|nlines
expr_stmt|;
name|ret
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
case|case
name|ctrl
argument_list|(
literal|'D'
argument_list|)
case|:
if|if
condition|(
name|nlines
operator|!=
literal|0
condition|)
name|nscroll
operator|=
name|nlines
expr_stmt|;
name|ret
argument_list|(
name|nscroll
argument_list|)
expr_stmt|;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|end_it
argument_list|()
expr_stmt|;
case|case
literal|'s'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
literal|'f'
condition|)
name|nlines
operator|*=
name|dlines
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"...skipping %d line"
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|1
condition|)
name|pr
argument_list|(
literal|"s\n"
argument_list|)
expr_stmt|;
else|else
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|done
operator|++
expr_stmt|;
goto|goto
name|endsw
goto|;
block|}
name|Currline
operator|++
expr_stmt|;
name|nlines
operator|--
expr_stmt|;
block|}
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|nlines
operator|!=
literal|0
condition|)
name|dlines
operator|=
name|nlines
expr_stmt|;
else|else
name|nlines
operator|=
literal|1
expr_stmt|;
name|ret
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
case|case
literal|'\f'
case|:
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|doclear
argument_list|()
expr_stmt|;
name|Fseek
argument_list|(
name|f
argument_list|,
name|screen_start
operator|.
name|chrctr
argument_list|)
expr_stmt|;
name|Currline
operator|=
name|screen_start
operator|.
name|line
expr_stmt|;
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"\n***Back***\n\n"
argument_list|)
expr_stmt|;
name|Fseek
argument_list|(
name|f
argument_list|,
name|context
operator|.
name|chrctr
argument_list|)
expr_stmt|;
name|Currline
operator|=
name|context
operator|.
name|line
expr_stmt|;
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'='
case|:
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|=
name|printd
argument_list|(
name|Currline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|lastp
operator|++
expr_stmt|;
case|case
literal|'/'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastp
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|NULL
argument_list|,
name|f
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
comment|/* Use previous r.e. */
block|}
else|else
block|{
name|ttyin
argument_list|(
name|cmdbuf
argument_list|,
literal|78
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|cmdbuf
argument_list|,
name|f
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
block|}
name|ret
argument_list|(
name|dlines
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|do_shell
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
operator|(
name|helpf
operator|=
name|fopen
argument_list|(
name|HELPFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't open help file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
name|doclear
argument_list|()
expr_stmt|;
name|copy_file
argument_list|(
name|helpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|helpf
argument_list|)
expr_stmt|;
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* This case should go right before default */
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|cmdbuf
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|scanstr
argument_list|(
name|Currline
operator|-
name|dlines
operator|<
literal|0
condition|?
literal|0
else|:
name|Currline
operator|-
operator|(
name|dlines
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|,
operator|&
name|cmdbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"vi "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|filename
argument_list|,
name|VI
argument_list|,
literal|"vi"
argument_list|,
name|cmdbuf
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
name|dum_opt
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
block|{
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|promptlen
operator|=
name|pr
argument_list|(
literal|"[Press 'h' for instructions.]"
argument_list|)
operator|+
operator|(
literal|2
operator|*
name|soglitch
operator|)
expr_stmt|;
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
else|else
name|promptlen
operator|=
name|pr
argument_list|(
literal|"[Press 'h' for instructions.]"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|endsw
label|:
name|inwait
operator|=
literal|0
expr_stmt|;
name|notell
operator|++
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|RAW
operator|&&
name|slow_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Execute a colon-prefixed command.  * Returns<0 if not a command that should cause  * more of the file to be printed.  */
end_comment

begin_macro
name|colon
argument_list|(
argument|filename
argument_list|,
argument|cmd
argument_list|,
argument|nlines
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
else|else
name|ch
operator|=
name|cmd
expr_stmt|;
name|lastcolon
operator|=
name|ch
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
condition|)
name|promptlen
operator|=
name|printf
argument_list|(
literal|"\"%s\" line %d"
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|,
name|Currline
argument_list|)
expr_stmt|;
else|else
name|promptlen
operator|=
name|printf
argument_list|(
literal|"[Not a file] line %d"
argument_list|,
name|Currline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'n'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fnum
operator|>=
name|nfiles
operator|-
literal|1
condition|)
name|end_it
argument_list|()
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skipf
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'p'
case|:
if|if
condition|(
name|no_intty
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|skipf
argument_list|(
operator|-
name|nlines
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'!'
case|:
name|do_shell
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|end_it
argument_list|()
expr_stmt|;
default|default:
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* ** Read a decimal number from the terminal. Set cmd to the non-digit which ** terminates the number. */
end_comment

begin_macro
name|number
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|otty
operator|.
name|sg_kill
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|cmd
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|do_shell
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdbuf
index|[
literal|80
index|]
decl_stmt|;
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lastp
condition|)
name|pr
argument_list|(
name|shell_line
argument_list|)
expr_stmt|;
else|else
block|{
name|ttyin
argument_list|(
name|cmdbuf
argument_list|,
literal|78
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
argument_list|(
name|shell_line
argument_list|,
name|cmdbuf
argument_list|)
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|=
name|printf
argument_list|(
literal|"!%s"
argument_list|,
name|shell_line
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
name|shellp
operator|=
literal|1
expr_stmt|;
name|execute
argument_list|(
name|filename
argument_list|,
name|shell
argument_list|,
name|shell
argument_list|,
literal|"-c"
argument_list|,
name|shell_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Search for nth ocurrence of regular expression contained in buf in the file */
end_comment

begin_macro
name|search
argument_list|(
argument|buf
argument_list|,
argument|file
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|startline
init|=
name|Ftell
argument_list|(
name|file
argument_list|)
decl_stmt|;
specifier|register
name|long
name|line1
init|=
name|startline
decl_stmt|;
specifier|register
name|long
name|line2
init|=
name|startline
decl_stmt|;
specifier|register
name|long
name|line3
init|=
name|startline
decl_stmt|;
specifier|register
name|int
name|lncount
decl_stmt|;
name|int
name|saveln
decl_stmt|,
name|rv
decl_stmt|,
name|re_exec
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|re_comp
argument_list|()
decl_stmt|;
name|context
operator|.
name|line
operator|=
name|saveln
operator|=
name|Currline
expr_stmt|;
name|context
operator|.
name|chrctr
operator|=
name|startline
expr_stmt|;
name|lncount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|re_comp
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|line3
operator|=
name|line2
expr_stmt|;
name|line2
operator|=
name|line1
expr_stmt|;
name|line1
operator|=
name|Ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|rdline
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|lncount
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|re_exec
argument_list|(
name|Line
argument_list|)
operator|)
operator|==
literal|1
condition|)
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lncount
operator|>
literal|3
operator|||
operator|(
name|lncount
operator|>
literal|1
operator|&&
name|no_intty
operator|)
condition|)
block|{
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"...skipping\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|Currline
operator|-=
operator|(
name|lncount
operator|>=
literal|3
condition|?
literal|3
else|:
name|lncount
operator|)
expr_stmt|;
name|Fseek
argument_list|(
name|file
argument_list|,
name|line3
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
if|if
condition|(
name|clreol
condition|)
block|{
name|home
argument_list|()
expr_stmt|;
name|cleareol
argument_list|()
expr_stmt|;
block|}
else|else
name|doclear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
if|if
condition|(
name|clreol
condition|)
block|{
name|home
argument_list|()
expr_stmt|;
name|cleareol
argument_list|()
expr_stmt|;
block|}
else|else
name|doclear
argument_list|()
expr_stmt|;
name|pr
argument_list|(
name|Line
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Regular expression botch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|file
operator|->
name|_flag
operator|&=
operator|~
name|_IOEOF
expr_stmt|;
comment|/* why doesn't fseek do this ??!!??! */
name|Currline
operator|=
name|saveln
expr_stmt|;
name|Fseek
argument_list|(
name|file
argument_list|,
name|startline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr
argument_list|(
literal|"\nPattern not found\n"
argument_list|)
expr_stmt|;
name|end_it
argument_list|()
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Pattern not found"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|execute
argument_list|(
argument|filename
argument_list|,
argument|cmd
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|int
name|id
decl_stmt|;
name|int
name|n
decl_stmt|;
name|va_list
name|argp
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reset_tty
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|10
init|;
operator|(
name|id
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
operator|&&
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|va_start
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|cmd
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"exec failed\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
comment|/* balance {}'s for some UNIX's */
block|}
if|if
condition|(
name|id
operator|>
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|catch_susp
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
while|while
condition|(
name|wait
argument_list|(
literal|0
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|end_it
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
if|if
condition|(
name|catch_susp
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
literal|"can't fork\n"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|set_tty
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"------------------------\n"
argument_list|)
expr_stmt|;
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Skip n lines in the file f */
end_comment

begin_expr_stmt
name|skiplns
argument_list|(
name|n
argument_list|,
name|f
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
name|n
operator|--
expr_stmt|;
name|Currline
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** Skip nskip files in the file list (from the command line). Nskip may be ** negative. */
end_comment

begin_expr_stmt
name|skipf
argument_list|(
name|nskip
argument_list|)
specifier|register
name|int
name|nskip
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|nskip
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|nskip
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fnum
operator|+
name|nskip
operator|>
name|nfiles
operator|-
literal|1
condition|)
name|nskip
operator|=
name|nfiles
operator|-
name|fnum
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|within
condition|)
operator|++
name|fnum
expr_stmt|;
name|fnum
operator|+=
name|nskip
expr_stmt|;
if|if
condition|(
name|fnum
operator|<
literal|0
condition|)
name|fnum
operator|=
literal|0
expr_stmt|;
name|pr
argument_list|(
literal|"\n...Skipping "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"...Skipping "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|nskip
operator|>
literal|0
condition|?
literal|"to file "
else|:
literal|"back to file "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|--
name|fnum
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------- Terminal I/O -------------------------------*/
end_comment

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|TBUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
name|clearbuf
index|[
name|TBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|clearptr
decl_stmt|,
modifier|*
name|padstr
decl_stmt|;
name|int
name|ldisc
decl_stmt|;
name|int
name|lmode
decl_stmt|;
name|char
modifier|*
name|term
decl_stmt|;
name|int
name|tgrp
decl_stmt|;
name|struct
name|winsize
name|win
decl_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
operator|(
name|no_tty
operator|=
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|lmode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"TIOCLGET"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|docrterase
operator|=
operator|(
operator|(
name|lmode
operator|&
name|LCRTERA
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|docrtkill
operator|=
operator|(
operator|(
name|lmode
operator|&
name|LCRTKIL
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Wait until we're in the foreground before we save the 	 * the terminal modes. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|tgrp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"TIOCGPGRP"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tgrp
operator|!=
name|getpgrp
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|tgetent
argument_list|(
name|buf
argument_list|,
name|term
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|dumb
operator|++
expr_stmt|;
name|ul_opt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Lpp
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|Mcol
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|Lpp
operator|=
name|win
operator|.
name|ws_row
operator|)
operator|==
literal|0
condition|)
name|Lpp
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Mcol
operator|=
name|win
operator|.
name|ws_col
operator|)
operator|==
literal|0
condition|)
name|Mcol
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Lpp
operator|<=
literal|0
operator|)
operator|||
name|tgetflag
argument_list|(
literal|"hc"
argument_list|)
condition|)
block|{
name|hard
operator|++
expr_stmt|;
comment|/* Hard copy terminal */
name|Lpp
operator|=
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
condition|)
name|eatnl
operator|++
expr_stmt|;
comment|/* Eat newline at last column + 1; dec, concept */
if|if
condition|(
name|Mcol
operator|<=
literal|0
condition|)
name|Mcol
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|tailequ
argument_list|(
name|fnames
index|[
literal|0
index|]
argument_list|,
literal|"page"
argument_list|)
operator|||
operator|!
name|hard
operator|&&
name|tgetflag
argument_list|(
literal|"ns"
argument_list|)
condition|)
name|noscroll
operator|++
expr_stmt|;
name|Wrap
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|bad_so
operator|=
name|tgetflag
argument_list|(
literal|"xs"
argument_list|)
expr_stmt|;
name|clearptr
operator|=
name|clearbuf
expr_stmt|;
name|eraseln
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Clear
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Senter
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Sexit
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|soglitch
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|soglitch
operator|=
literal|0
expr_stmt|;
comment|/* 	     *  Set up for underlining:  some terminals don't need it; 	     *  others have start/stop sequences, still others have an 	     *  underline char sequence which is assumed to move the 	     *  cursor forward one character.  If underline sequence 	     *  isn't available, settle for standout sequence. 	     */
if|if
condition|(
name|tgetflag
argument_list|(
literal|"ul"
argument_list|)
operator|||
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
condition|)
name|ul_opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|chUL
operator|=
name|tgetstr
argument_list|(
literal|"uc"
argument_list|,
operator|&
name|clearptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|chUL
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ULenter
operator|=
name|tgetstr
argument_list|(
literal|"us"
argument_list|,
operator|&
name|clearptr
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ULexit
operator|=
name|tgetstr
argument_list|(
literal|"ue"
argument_list|,
operator|&
name|clearptr
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|!
operator|*
name|chUL
condition|)
block|{
if|if
condition|(
operator|(
name|ULenter
operator|=
name|Senter
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ULexit
operator|=
name|Sexit
operator|)
operator|==
name|NULL
condition|)
block|{
name|ULenter
operator|=
literal|""
expr_stmt|;
name|ULexit
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|ulglitch
operator|=
name|soglitch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ulglitch
operator|=
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ulglitch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|padstr
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|clearptr
argument_list|)
condition|)
name|PC
operator|=
operator|*
name|padstr
expr_stmt|;
name|Home
operator|=
name|tgetstr
argument_list|(
literal|"ho"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Home
operator|==
literal|0
operator|||
operator|*
name|Home
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|cursorm
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|clearptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|cursorhome
argument_list|,
name|tgoto
argument_list|(
name|cursorm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|Home
operator|=
name|cursorhome
expr_stmt|;
block|}
block|}
name|EodClr
operator|=
name|tgetstr
argument_list|(
literal|"cd"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chBS
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|clearptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|chBS
operator|=
literal|"\b"
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
block|}
name|no_intty
operator|=
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|savetty
operator|=
name|otty
expr_stmt|;
name|ospeed
operator|=
name|otty
operator|.
name|sg_ospeed
expr_stmt|;
name|slow_tty
operator|=
name|ospeed
operator|<
name|B1200
expr_stmt|;
name|hardtabs
operator|=
operator|(
name|otty
operator|.
name|sg_flags
operator|&
name|TBDELAY
operator|)
operator|!=
name|XTABS
expr_stmt|;
if|if
condition|(
operator|!
name|no_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|CBREAK
operator|||
operator|!
name|slow_tty
condition|)
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|readch
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|2
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|end_it
argument_list|()
expr_stmt|;
else|else
name|ch
operator|=
name|otty
operator|.
name|sg_kill
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|BS
init|=
literal|'\b'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|BSB
init|=
literal|"\b \b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|CARAT
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ERASEONECHAR
define|\
value|if (docrterase) \ 	write (2, BSB, sizeof(BSB)); \     else \ 	write (2,&BS, sizeof(BS));
end_define

begin_macro
name|ttyin
argument_list|(
argument|buf
argument_list|,
argument|nmax
argument_list|,
argument|pchar
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|nmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|slash
init|=
literal|0
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|char
name|cbuf
decl_stmt|;
name|sptr
operator|=
name|buf
expr_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sptr
operator|-
name|buf
operator|<
name|nmax
condition|)
block|{
if|if
condition|(
name|promptlen
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|promptlen
expr_stmt|;
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|slash
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_erase
operator|)
operator|&&
operator|!
name|slash
condition|)
block|{
if|if
condition|(
name|sptr
operator|>
name|buf
condition|)
block|{
operator|--
name|promptlen
expr_stmt|;
name|ERASEONECHAR
operator|--
name|sptr
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sptr
operator|<
literal|' '
operator|&&
operator|*
name|sptr
operator|!=
literal|'\n'
operator|)
operator|||
operator|*
name|sptr
operator|==
name|RUBOUT
condition|)
block|{
operator|--
name|promptlen
expr_stmt|;
name|ERASEONECHAR
block|}
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|eraseln
condition|)
name|promptlen
operator|=
name|maxlen
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
operator|)
operator|&&
operator|!
name|slash
condition|)
block|{
if|if
condition|(
name|hard
condition|)
block|{
name|show
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|pchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|pchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|eraseln
condition|)
name|erase
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docrtkill
condition|)
while|while
condition|(
name|promptlen
operator|--
operator|>
literal|1
condition|)
name|write
argument_list|(
literal|2
argument_list|,
name|BSB
argument_list|,
sizeof|sizeof
argument_list|(
name|BSB
argument_list|)
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
block|}
name|sptr
operator|=
name|buf
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|slash
operator|&&
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
operator|||
name|ch
operator|==
name|otty
operator|.
name|sg_erase
operator|)
condition|)
block|{
name|ERASEONECHAR
operator|--
name|sptr
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'\\'
condition|)
name|slash
operator|=
literal|0
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|<
literal|' '
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
operator|)
operator|||
name|ch
operator|==
name|RUBOUT
condition|)
block|{
name|ch
operator|+=
name|ch
operator|==
name|RUBOUT
condition|?
operator|-
literal|0100
else|:
literal|0100
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|CARAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
name|cbuf
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|cbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
operator|*
operator|--
name|sptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|eraseln
condition|)
name|promptlen
operator|=
name|maxlen
expr_stmt|;
if|if
condition|(
name|sptr
operator|-
name|buf
operator|>=
name|nmax
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Line too long"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|expand
argument_list|(
argument|outbuf
argument_list|,
argument|inbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|outbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|instr
decl_stmt|;
specifier|register
name|char
modifier|*
name|outstr
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|char
name|temp
index|[
literal|200
index|]
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|instr
operator|=
name|inbuf
expr_stmt|;
name|outstr
operator|=
name|temp
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|instr
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|strcpy
argument_list|(
name|outstr
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|outstr
operator|+=
name|strlen
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|outstr
operator|++
operator|=
name|ch
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
operator|!
name|shellp
condition|)
name|error
argument_list|(
literal|"No previous command to substitute for"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|outstr
argument_list|,
name|shell_line
argument_list|)
expr_stmt|;
name|outstr
operator|+=
name|strlen
argument_list|(
name|shell_line
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|instr
operator|==
literal|'%'
operator|||
operator|*
name|instr
operator|==
literal|'!'
condition|)
block|{
operator|*
name|outstr
operator|++
operator|=
operator|*
name|instr
operator|++
expr_stmt|;
break|break;
block|}
default|default:
operator|*
name|outstr
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|outstr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|outbuf
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|show
argument_list|(
name|ch
argument_list|)
specifier|register
name|char
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|cbuf
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|<
literal|' '
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
operator|)
operator|||
name|ch
operator|==
name|RUBOUT
condition|)
block|{
name|ch
operator|+=
name|ch
operator|==
name|RUBOUT
condition|?
operator|-
literal|0100
else|:
literal|0100
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|CARAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
name|cbuf
operator|=
name|ch
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|cbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|mess
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mess
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|clreol
condition|)
name|cleareol
argument_list|()
expr_stmt|;
else|else
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|+=
name|strlen
argument_list|(
name|mess
argument_list|)
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
block|{
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
else|else
name|pr
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_tty
argument_list|()
end_macro

begin_block
block|{
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|stty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|reset_tty
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|no_tty
condition|)
return|return;
if|if
condition|(
name|pstate
condition|)
block|{
name|tputs
argument_list|(
name|ULexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pstate
operator|=
literal|0
expr_stmt|;
block|}
name|otty
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
operator|&
name|savetty
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdline
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|p
operator|-
name|Line
operator|<
name|LINSIZ
operator|-
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|Currline
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Come here when we get a suspend signal from the terminal */
end_comment

begin_macro
name|onsusp
argument_list|()
end_macro

begin_block
block|{
comment|/* ignore SIGTTOU so we don't get stopped if csh grabs the tty */
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|reset_tty
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Send the TSTP signal to suspend our process group */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Pause for station break */
comment|/* We're back */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
name|set_tty
argument_list|()
expr_stmt|;
if|if
condition|(
name|inwait
condition|)
name|longjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

