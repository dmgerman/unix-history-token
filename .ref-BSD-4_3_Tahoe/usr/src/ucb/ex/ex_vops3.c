begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_vops3.c	7.4 (Berkeley) 3/9/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Routines to handle structure.  * Operations supported are:  *	( ) { } [ ]  *  * These cover:		LISP		TEXT  *	( )		s-exprs		sentences  *	{ }		list at same	paragraphs  *	[ ]		defuns		sections  *  * { and } for C used to attempt to do something with matching {}'s, but  * I couldn't find definitions which worked intuitively very well, so I  * scrapped this.  *  * The code here is very hard to understand.  */
end_comment

begin_decl_stmt
name|line
modifier|*
name|llimit
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|lf
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LISPCODE
end_ifdef

begin_function_decl
name|int
name|lindent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|bool
name|wasend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Find over structure, repeated count times.  * Don't go past line limit.  F is the operation to  * be performed eventually.  If pastatom then the user said {}  * rather than (), implying past atoms in a list (or a paragraph  * rather than a sentence.  */
end_comment

begin_macro
name|lfind
argument_list|(
argument|pastatom
argument_list|,
argument|cnt
argument_list|,
argument|f
argument_list|,
argument|limit
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|pastatom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|,
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|line
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|char
name|save
index|[
name|LBSIZE
index|]
decl_stmt|;
comment|/* 	 * Initialize, saving the current line buffer state 	 * and computing the limit; a 0 argument means 	 * directional end of file. 	 */
name|wasend
operator|=
literal|0
expr_stmt|;
name|lf
operator|=
name|f
expr_stmt|;
name|strcpy
argument_list|(
name|save
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
name|dir
operator|<
literal|0
condition|?
name|one
else|:
name|dol
expr_stmt|;
name|llimit
operator|=
name|limit
expr_stmt|;
name|wdot
operator|=
name|dot
expr_stmt|;
name|wcursor
operator|=
name|cursor
expr_stmt|;
if|if
condition|(
name|pastatom
operator|>=
literal|2
condition|)
block|{
while|while
condition|(
name|cnt
operator|>
literal|0
operator|&&
name|word
argument_list|(
name|f
argument_list|,
name|cnt
argument_list|)
condition|)
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|pastatom
operator|==
literal|3
condition|)
name|eend
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|wdot
condition|)
block|{
name|wdot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
name|wcursor
condition|)
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LISPCODE
elseif|else
if|if
condition|(
operator|!
name|value
argument_list|(
name|LISP
argument_list|)
condition|)
block|{
else|#
directive|else
else|else
block|{
endif|#
directive|endif
name|char
modifier|*
name|icurs
decl_stmt|;
name|line
modifier|*
name|idot
decl_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
do|do
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
goto|goto
name|ret
goto|;
do|while
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|wdot
operator|--
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wcursor
operator|=
name|linebuf
expr_stmt|;
comment|/* 				 * If looking for sentence, next line 				 * starts one. 				 */
if|if
condition|(
operator|!
name|pastatom
condition|)
block|{
name|icurs
operator|=
name|wcursor
expr_stmt|;
name|idot
operator|=
name|wdot
expr_stmt|;
goto|goto
name|begin
goto|;
block|}
block|}
block|}
name|icurs
operator|=
name|wcursor
expr_stmt|;
name|idot
operator|=
name|wdot
expr_stmt|;
comment|/* 		 * Advance so as to not find same thing again. 		 */
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
block|{
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
else|else
name|ignore
argument_list|(
name|lskipa1
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Count times find end of sentence/paragraph. 		 */
name|begin
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|endsent
argument_list|(
name|pastatom
argument_list|)
condition|)
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
operator|!
name|pastatom
operator|||
name|wcursor
operator|==
name|linebuf
operator|&&
name|endPS
argument_list|()
condition|)
if|if
condition|(
operator|--
name|cnt
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
do|do
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
goto|goto
name|ret
goto|;
do|while
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
goto|goto
name|ret
goto|;
block|}
comment|/* 		 * If going backwards, and didn't hit the end of the buffer, 		 * then reverse direction. 		 */
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
operator|(
name|wdot
operator|!=
name|llimit
operator|||
name|wcursor
operator|!=
name|linebuf
operator|)
condition|)
block|{
name|dir
operator|=
literal|1
expr_stmt|;
name|llimit
operator|=
name|dot
expr_stmt|;
comment|/* 			 * Empty line needs special treatement. 			 * If moved to it from other than begining of next line, 			 * then a sentence starts on next line. 			 */
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|!
name|pastatom
operator|&&
operator|(
name|wdot
operator|!=
name|dot
operator|-
literal|1
operator|||
name|cursor
operator|!=
name|linebuf
operator|)
condition|)
block|{
name|ignore
argument_list|(
name|lnext
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
comment|/* 		 * If we are not at a section/paragraph division, 		 * advance to next. 		 */
if|if
condition|(
name|wcursor
operator|==
name|icurs
operator|&&
name|wdot
operator|==
name|idot
operator|||
name|wcursor
operator|!=
name|linebuf
operator|||
operator|!
name|endPS
argument_list|()
condition|)
name|ignore
argument_list|(
name|lskipa1
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LISPCODE
else|else
block|{
name|c
operator|=
operator|*
name|wcursor
expr_stmt|;
comment|/* 		 * Startup by skipping if at a ( going left or a ) going 		 * right to keep from getting stuck immediately. 		 */
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|c
operator|==
literal|'('
operator|||
name|dir
operator|>
literal|0
operator|&&
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
block|{
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
comment|/* 		 * Now chew up repitition count.  Each time around 		 * if at the beginning of an s-exp (going forwards) 		 * or the end of an s-exp (going backwards) 		 * skip the s-exp.  If not at beg/end resp, then stop 		 * if we hit a higher level paren, else skip an atom, 		 * counting it unless pastatom. 		 */
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|wcursor
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|c
operator|==
literal|')'
operator|||
name|dir
operator|>
literal|0
operator|&&
name|c
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
operator|!
name|lskipbal
argument_list|(
literal|"()"
argument_list|)
condition|)
goto|goto
name|ret
goto|;
comment|/*  				 * Unless this is the last time going 				 * backwards, skip past the matching paren 				 * so we don't think it is a higher level paren. 				 */
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|cnt
operator|==
literal|1
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
operator|!
name|lnext
argument_list|()
operator|||
operator|!
name|ltosolid
argument_list|()
condition|)
goto|goto
name|ret
goto|;
operator|--
name|cnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|c
operator|==
literal|'('
operator|||
name|dir
operator|>
literal|0
operator|&&
name|c
operator|==
literal|')'
condition|)
comment|/* Found a higher level paren */
goto|goto
name|ret
goto|;
else|else
block|{
if|if
condition|(
operator|!
name|lskipatom
argument_list|()
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
operator|!
name|pastatom
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|ret
label|:
name|strcLIN
argument_list|(
name|save
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/*  * Is this the end of a sentence?  */
comment|/* ARGSUSED */
name|endsent
argument_list|(
argument|pastatom
argument_list|)
name|bool
name|pastatom
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|wcursor
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
comment|/* 	 * If this is the beginning of a line, then 	 * check for the end of a paragraph or section. 	 */
if|if
condition|(
name|cp
operator|==
name|linebuf
condition|)
return|return
operator|(
name|endPS
argument_list|()
operator|)
return|;
comment|/* 	 * Sentences end with . ! ? not at the beginning 	 * of the line, and must be either at the end of the line, 	 * or followed by 2 spaces.  Any number of intervening ) ] ' " 	 * characters are allowed. 	 */
if|if
condition|(
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|".!?"
argument_list|)
condition|)
goto|goto
name|tryps
goto|;
do|do
if|if
condition|(
operator|(
name|d
operator|=
operator|*
operator|++
name|cp
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
do|while
condition|(
name|any
argument_list|(
name|d
argument_list|,
literal|")]'"
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|||
operator|*
name|cp
operator|++
operator|==
literal|' '
operator|&&
operator|*
name|cp
operator|==
literal|' '
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tryps
label|:
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|endPS
argument_list|()
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * End of paragraphs/sections are respective  * macros as well as blank lines and form feeds.  */
name|endPS
argument_list|()
block|{
return|return
operator|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|isa
argument_list|(
name|svalue
argument_list|(
name|PARAGRAPHS
argument_list|)
argument_list|)
operator|||
name|isa
argument_list|(
name|svalue
argument_list|(
name|SECTIONS
argument_list|)
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|LISPCODE
name|lindent
argument_list|(
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|swcurs
init|=
name|wcursor
decl_stmt|;
name|line
modifier|*
name|swdot
init|=
name|wdot
decl_stmt|;
name|again
label|:
if|if
condition|(
name|addr
operator|>
name|one
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|addr
operator|--
expr_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|linebuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
name|cnt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
condition|)
name|cnt
operator|--
expr_stmt|;
name|cp
operator|=
name|vpastwh
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|whitecnt
argument_list|(
name|linebuf
argument_list|)
operator|)
return|;
name|addr
operator|++
expr_stmt|;
block|}
name|wcursor
operator|=
name|linebuf
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wdot
operator|=
name|addr
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
name|llimit
operator|=
name|one
expr_stmt|;
name|lf
operator|=
name|lindent
expr_stmt|;
if|if
condition|(
operator|!
name|lskipbal
argument_list|(
literal|"()"
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wcursor
operator|==
name|linebuf
condition|)
name|i
operator|=
literal|2
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|wp
init|=
name|wcursor
decl_stmt|;
name|dir
operator|=
literal|1
expr_stmt|;
name|llimit
operator|=
name|wdot
expr_stmt|;
if|if
condition|(
operator|!
name|lnext
argument_list|()
operator|||
operator|!
name|ltosolid
argument_list|()
operator|||
operator|!
name|lskipatom
argument_list|()
condition|)
block|{
name|wcursor
operator|=
name|wp
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
name|column
argument_list|(
name|wcursor
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|inopen
condition|)
name|i
operator|--
expr_stmt|;
block|}
name|wdot
operator|=
name|swdot
expr_stmt|;
name|wcursor
operator|=
name|swcurs
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
endif|#
directive|endif
name|lmatchp
argument_list|(
name|addr
argument_list|)
name|line
operator|*
name|addr
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|parens
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cursor
init|;
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"({[)}]"
argument_list|)
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lf
operator|=
literal|0
expr_stmt|;
name|parens
operator|=
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"()"
argument_list|)
condition|?
literal|"()"
else|:
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"[]"
argument_list|)
condition|?
literal|"[]"
else|:
literal|"{}"
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|parens
index|[
literal|1
index|]
condition|)
block|{
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
name|llimit
operator|=
name|one
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
literal|1
expr_stmt|;
name|llimit
operator|=
name|dol
expr_stmt|;
block|}
if|if
condition|(
name|addr
condition|)
name|llimit
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|splitw
condition|)
name|llimit
operator|=
name|dot
expr_stmt|;
name|wcursor
operator|=
name|cp
expr_stmt|;
name|wdot
operator|=
name|dot
expr_stmt|;
name|i
operator|=
name|lskipbal
argument_list|(
name|parens
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|lsmatch
argument_list|(
argument|cp
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
name|save
index|[
name|LBSIZE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
init|=
name|save
decl_stmt|;
specifier|register
name|char
modifier|*
name|scurs
init|=
name|cursor
decl_stmt|;
name|wcursor
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
operator|*
name|wcursor
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|cursor
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|strend
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lmatchp
argument_list|(
name|dot
operator|-
name|vcline
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|insmode
decl_stmt|;
specifier|register
name|int
name|c
init|=
name|outcol
decl_stmt|;
specifier|register
name|int
name|l
init|=
name|outline
decl_stmt|;
if|if
condition|(
operator|!
name|MI
condition|)
name|endim
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|splitw
condition|?
name|WECHO
else|:
name|LINE
argument_list|(
name|wdot
operator|-
name|llimit
argument_list|)
argument_list|,
name|column
argument_list|(
name|wcursor
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|l
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|goim
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|strcLIN
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scurs
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lmatchp
argument_list|(
operator|(
name|line
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|beep
argument_list|()
expr_stmt|;
block|}
name|strcLIN
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|wdot
operator|=
literal|0
expr_stmt|;
name|wcursor
operator|=
literal|0
expr_stmt|;
name|cursor
operator|=
name|scurs
expr_stmt|;
block|}
name|ltosolid
argument_list|()
block|{
return|return
operator|(
name|ltosol1
argument_list|(
literal|"()"
argument_list|)
operator|)
return|;
block|}
name|ltosol1
argument_list|(
name|parens
argument_list|)
specifier|register
name|char
operator|*
name|parens
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
name|parens
operator|&&
operator|!
operator|*
name|wcursor
operator|&&
operator|!
name|lnext
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|wcursor
argument_list|)
operator|||
operator|(
operator|*
name|wcursor
operator|==
literal|0
operator|&&
operator|*
name|parens
operator|)
condition|)
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|any
argument_list|(
operator|*
name|wcursor
argument_list|,
name|parens
argument_list|)
operator|||
name|dir
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|cp
operator|=
name|wcursor
init|;
name|cp
operator|>
name|linebuf
condition|;
name|cp
operator|--
control|)
if|if
condition|(
name|isspace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|any
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|,
name|parens
argument_list|)
condition|)
break|break;
name|wcursor
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lskipbal
argument_list|(
name|parens
argument_list|)
specifier|register
name|char
operator|*
name|parens
expr_stmt|;
block|{
specifier|register
name|int
name|level
init|=
name|dir
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
block|{
name|wdot
operator|=
name|NOLINE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|=
operator|*
name|wcursor
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|parens
index|[
literal|1
index|]
condition|)
name|level
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|parens
index|[
literal|0
index|]
condition|)
name|level
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|level
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lskipatom
argument_list|()
block|{
return|return
operator|(
name|lskipa1
argument_list|(
literal|"()"
argument_list|)
operator|)
return|;
block|}
name|lskipa1
argument_list|(
name|parens
argument_list|)
specifier|register
name|char
operator|*
name|parens
expr_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|wcursor
operator|==
name|linebuf
condition|)
block|{
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|c
operator|=
operator|*
name|wcursor
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|any
argument_list|(
name|c
argument_list|,
name|parens
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|lnext
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
name|wcursor
operator|==
name|linebuf
condition|)
break|break;
block|}
return|return
operator|(
name|ltosol1
argument_list|(
name|parens
argument_list|)
operator|)
return|;
block|}
name|lnext
argument_list|()
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|wcursor
condition|)
name|wcursor
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|wcursor
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|wdot
operator|>=
name|llimit
condition|)
block|{
if|if
condition|(
name|lf
operator|==
name|vmove
operator|&&
name|wcursor
operator|>
name|linebuf
condition|)
name|wcursor
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wdot
operator|++
expr_stmt|;
name|getline
argument_list|(
operator|*
name|wdot
argument_list|)
expr_stmt|;
name|wcursor
operator|=
name|linebuf
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|--
name|wcursor
expr_stmt|;
if|if
condition|(
name|wcursor
operator|>=
name|linebuf
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|LISPCODE
if|if
condition|(
name|lf
operator|==
name|lindent
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
name|llimit
operator|=
name|wdot
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wdot
operator|<=
name|llimit
condition|)
block|{
name|wcursor
operator|=
name|linebuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wdot
operator|--
expr_stmt|;
name|getline
argument_list|(
operator|*
name|wdot
argument_list|)
expr_stmt|;
name|wcursor
operator|=
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|?
name|linebuf
else|:
name|strend
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|lbrack
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|dot
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|addr
operator|+=
name|dir
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|one
operator|||
name|addr
operator|>
name|dol
condition|)
block|{
name|addr
operator|-=
name|dir
expr_stmt|;
break|break;
block|}
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'{'
operator|||
ifdef|#
directive|ifdef
name|LISPCODE
name|value
argument_list|(
name|LISP
argument_list|)
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'('
operator|||
endif|#
directive|endif
name|isa
argument_list|(
name|svalue
argument_list|(
name|SECTIONS
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|f
operator|!=
name|vmove
condition|)
block|{
name|addr
operator|--
expr_stmt|;
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|']'
operator|&&
name|f
operator|!=
name|vmove
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'}'
condition|)
break|break;
block|}
if|if
condition|(
name|addr
operator|==
name|dot
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|f
operator|!=
name|vmove
condition|)
name|wcursor
operator|=
name|c
operator|==
literal|']'
condition|?
name|strend
argument_list|(
name|linebuf
argument_list|)
else|:
name|linebuf
expr_stmt|;
else|else
name|wcursor
operator|=
literal|0
expr_stmt|;
name|wdot
operator|=
name|addr
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isa
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
block|{
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
index|[
literal|1
index|]
condition|;
name|cp
operator|+=
literal|2
control|)
if|if
condition|(
name|linebuf
index|[
literal|1
index|]
operator|==
name|cp
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|linebuf
index|[
literal|2
index|]
operator|==
name|cp
index|[
literal|1
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|linebuf
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|' '
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

