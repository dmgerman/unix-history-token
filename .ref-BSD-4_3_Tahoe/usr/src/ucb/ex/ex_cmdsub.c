begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_cmdsub.c	7.9 (Berkeley) 1/2/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_argv.h"
end_include

begin_include
include|#
directive|include
file|"ex_temp.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Command mode subroutines implementing  *	append, args, copy, delete, join, move, put,  *	shift, tag, yank, z and undo  */
end_comment

begin_decl_stmt
name|bool
name|endline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|line
modifier|*
name|tad1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|jnoop
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Append after line a lines returned by function f.  * Be careful about intermediate states to avoid scramble  * if an interrupt comes in.  */
end_comment

begin_macro
name|append
argument_list|(
argument|f
argument_list|,
argument|a
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|line
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|rdot
decl_stmt|;
name|int
name|nline
decl_stmt|;
name|nline
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|FIXUNDO
operator|&&
operator|!
name|inopen
operator|&&
name|f
operator|!=
name|getsub
condition|)
block|{
name|undap1
operator|=
name|undap2
operator|=
name|dot
operator|+
literal|1
expr_stmt|;
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
block|}
while|while
condition|(
call|(
modifier|*
name|f
call|)
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|truedol
operator|>=
name|endcore
condition|)
block|{
if|if
condition|(
name|morelines
argument_list|()
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|FIXUNDO
operator|&&
name|f
operator|==
name|getsub
condition|)
block|{
name|undap1
operator|=
name|addr1
expr_stmt|;
name|undap2
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Out of memory@- too many lines in file"
argument_list|)
expr_stmt|;
block|}
block|}
name|nline
operator|++
expr_stmt|;
name|a1
operator|=
name|truedol
operator|+
literal|1
expr_stmt|;
name|a2
operator|=
name|a1
operator|+
literal|1
expr_stmt|;
name|dot
operator|++
expr_stmt|;
name|undap2
operator|++
expr_stmt|;
name|dol
operator|++
expr_stmt|;
name|unddol
operator|++
expr_stmt|;
name|truedol
operator|++
expr_stmt|;
for|for
control|(
name|rdot
operator|=
name|dot
init|;
name|a1
operator|>
name|rdot
condition|;
control|)
operator|*
operator|--
name|a2
operator|=
operator|*
operator|--
name|a1
expr_stmt|;
operator|*
name|rdot
operator|=
literal|0
expr_stmt|;
name|putmark
argument_list|(
name|rdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|gettty
condition|)
block|{
name|dirtcnt
operator|++
expr_stmt|;
name|TSYNC
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nline
operator|)
return|;
block|}
end_block

begin_macro
name|appendnone
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|FIXUNDO
condition|)
block|{
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
name|undap1
operator|=
name|undap2
operator|=
name|addr1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print out the argument list, with []'s around the current name.  */
end_comment

begin_macro
name|pargs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|av
init|=
name|argv0
decl_stmt|,
modifier|*
name|as
init|=
name|args0
decl_stmt|;
specifier|register
name|int
name|ac
decl_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|argc0
condition|;
name|ac
operator|++
control|)
block|{
if|if
condition|(
name|ac
operator|!=
literal|0
condition|)
name|ex_putchar
argument_list|(
literal|' '
operator||
name|QUOTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|+
name|argc
operator|==
name|argc0
operator|-
literal|1
condition|)
name|ex_printf
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"%s"
argument_list|,
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|+
name|argc
operator|==
name|argc0
operator|-
literal|1
condition|)
name|ex_printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|as
operator|=
name|av
condition|?
operator|*
operator|++
name|av
else|:
name|strend
argument_list|(
name|as
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|noonl
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Delete lines; two cases are if we are really deleting,  * more commonly we are just moving lines to the undo save area.  */
end_comment

begin_macro
name|ex_delete
argument_list|(
argument|hush
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|hush
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
block|{
specifier|register
name|int
function_decl|(
modifier|*
name|dsavint
function_decl|)
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"before delete"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|change
argument_list|()
expr_stmt|;
name|dsavint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|squish
argument_list|()
expr_stmt|;
name|a2
operator|=
name|addr2
expr_stmt|;
if|if
condition|(
name|a2
operator|++
operator|!=
name|dol
condition|)
block|{
name|reverse
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|a2
argument_list|,
name|dol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|a1
argument_list|,
name|dol
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dol
operator|-=
name|a2
operator|-
name|a1
expr_stmt|;
name|unddel
operator|=
name|a1
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|a1
operator|>
name|dol
condition|)
name|a1
operator|=
name|dol
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
name|pkill
index|[
literal|0
index|]
operator|=
name|pkill
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|dsavint
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"after delete"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
specifier|register
name|line
modifier|*
name|a3
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|change
argument_list|()
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|a2
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
name|a3
operator|=
name|truedol
expr_stmt|;
name|i
operator|=
name|a2
operator|-
name|a1
expr_stmt|;
name|unddol
operator|-=
name|i
expr_stmt|;
name|undap2
operator|-=
name|i
expr_stmt|;
name|dol
operator|-=
name|i
expr_stmt|;
name|truedol
operator|-=
name|i
expr_stmt|;
do|do
operator|*
name|a1
operator|++
operator|=
operator|*
name|a2
operator|++
expr_stmt|;
do|while
condition|(
name|a2
operator|<=
name|a3
condition|)
do|;
name|a1
operator|=
name|addr1
expr_stmt|;
if|if
condition|(
name|a1
operator|>
name|dol
condition|)
name|a1
operator|=
name|dol
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hush
condition|)
name|killed
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|deletenone
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|FIXUNDO
condition|)
block|{
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
name|squish
argument_list|()
expr_stmt|;
name|unddel
operator|=
name|addr1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Crush out the undo save area, moving the open/visual  * save area down in its place.  */
end_comment

begin_macro
name|squish
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|line
modifier|*
name|a1
init|=
name|dol
operator|+
literal|1
decl_stmt|,
modifier|*
name|a2
init|=
name|unddol
operator|+
literal|1
decl_stmt|,
modifier|*
name|a3
init|=
name|truedol
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
block|{
if|if
condition|(
name|inopen
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|a1
operator|<
name|a2
operator|&&
name|a2
operator|<
name|a3
condition|)
do|do
operator|*
name|a1
operator|++
operator|=
operator|*
name|a2
operator|++
expr_stmt|;
do|while
condition|(
name|a2
operator|<
name|a3
condition|)
do|;
name|truedol
operator|-=
name|unddol
operator|-
name|dol
expr_stmt|;
name|unddol
operator|=
name|dol
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Join lines.  Special hacks put in spaces, two spaces if  * preceding line ends with '.', or no spaces if next line starts with ).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|jcount
decl_stmt|,
name|jnoop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|join
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|a1
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|cp
operator|=
name|genbuf
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|addr1
init|;
name|a1
operator|<=
name|addr2
condition|;
name|a1
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|a1
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|a1
operator|!=
name|addr1
operator|&&
name|c
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp1
operator|==
literal|' '
operator|||
operator|*
name|cp1
operator|==
literal|'\t'
condition|)
name|cp1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|&&
name|cp
operator|>
name|genbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\t'
condition|)
block|{
if|if
condition|(
operator|*
name|cp1
operator|!=
literal|')'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
if|if
condition|(
name|cp
operator|>
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
name|error
argument_list|(
literal|"Line overflow|Result line of join would be too long"
argument_list|)
expr_stmt|;
name|cp
operator|--
expr_stmt|;
block|}
name|strcLIN
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|ex_delete
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|jcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|undap1
operator|=
name|undap2
operator|=
name|addr1
expr_stmt|;
name|ignore
argument_list|(
name|append
argument_list|(
name|jnoop
argument_list|,
operator|--
name|addr1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|vundkind
operator|=
name|VMANY
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|jnoop
argument_list|()
block|{
return|return
operator|(
operator|--
name|jcount
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Move and copy lines.  Hard work is done by move1 which  * is also called by undo.  */
end_comment

begin_function_decl
name|int
name|getcopy
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|move
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|line
modifier|*
name|adt
decl_stmt|;
name|bool
name|iscopy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Command
index|[
literal|0
index|]
operator|==
literal|'m'
condition|)
block|{
name|setdot1
argument_list|()
expr_stmt|;
name|markpr
argument_list|(
name|addr2
operator|==
name|dot
condition|?
name|addr1
operator|-
literal|1
else|:
name|addr2
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iscopy
operator|++
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
block|}
name|nonzero
argument_list|()
expr_stmt|;
name|adt
operator|=
name|address
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adt
operator|==
literal|0
condition|)
name|serror
argument_list|(
literal|"%s where?|%s requires a trailing address"
argument_list|,
name|Command
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|move1
argument_list|(
name|iscopy
argument_list|,
name|adt
argument_list|)
expr_stmt|;
name|killed
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|move1
argument_list|(
argument|cflag
argument_list|,
argument|addrt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|line
modifier|*
name|addrt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|adt
decl_stmt|,
modifier|*
name|ad1
decl_stmt|,
modifier|*
name|ad2
decl_stmt|;
name|int
name|lines
decl_stmt|;
name|adt
operator|=
name|addrt
expr_stmt|;
name|lines
operator|=
operator|(
name|addr2
operator|-
name|addr1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
block|{
name|tad1
operator|=
name|addr1
expr_stmt|;
name|ad1
operator|=
name|dol
expr_stmt|;
name|ignore
argument_list|(
name|append
argument_list|(
name|getcopy
argument_list|,
name|ad1
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|ad2
operator|=
name|dol
expr_stmt|;
block|}
else|else
block|{
name|ad2
operator|=
name|addr2
expr_stmt|;
for|for
control|(
name|ad1
operator|=
name|addr1
init|;
name|ad1
operator|<=
name|ad2
condition|;
control|)
operator|*
name|ad1
operator|++
operator|&=
operator|~
literal|01
expr_stmt|;
name|ad1
operator|=
name|addr1
expr_stmt|;
block|}
name|ad2
operator|++
expr_stmt|;
if|if
condition|(
name|adt
operator|<
name|ad1
condition|)
block|{
if|if
condition|(
name|adt
operator|+
literal|1
operator|==
name|ad1
operator|&&
operator|!
name|cflag
operator|&&
operator|!
name|inglobal
condition|)
name|error
argument_list|(
literal|"That move would do nothing!"
argument_list|)
expr_stmt|;
name|dot
operator|=
name|adt
operator|+
operator|(
name|ad2
operator|-
name|ad1
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|adt
operator|!=
name|ad1
condition|)
block|{
name|reverse
argument_list|(
name|adt
argument_list|,
name|ad1
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|ad1
argument_list|,
name|ad2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|adt
argument_list|,
name|ad2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|adt
operator|>=
name|ad2
condition|)
block|{
name|dot
operator|=
name|adt
operator|++
expr_stmt|;
name|reverse
argument_list|(
name|ad1
argument_list|,
name|ad2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|ad2
argument_list|,
name|adt
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|ad1
argument_list|,
name|adt
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Move to a moved line"
argument_list|)
expr_stmt|;
name|change
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inglobal
condition|)
if|if
condition|(
name|FIXUNDO
condition|)
block|{
if|if
condition|(
name|cflag
condition|)
block|{
name|undap1
operator|=
name|addrt
operator|+
literal|1
expr_stmt|;
name|undap2
operator|=
name|undap1
operator|+
name|lines
expr_stmt|;
name|deletenone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|undkind
operator|=
name|UNDMOVE
expr_stmt|;
name|undap1
operator|=
name|addr1
expr_stmt|;
name|undap2
operator|=
name|addr2
expr_stmt|;
name|unddel
operator|=
name|addrt
expr_stmt|;
name|squish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|getcopy
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|tad1
operator|>
name|addr2
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|getline
argument_list|(
operator|*
name|tad1
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Put lines in the buffer from the undo save area.  */
end_comment

begin_macro
name|getput
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|tad1
operator|>
name|unddol
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|getline
argument_list|(
operator|*
name|tad1
operator|++
argument_list|)
expr_stmt|;
name|tad1
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|put
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
if|if
condition|(
operator|!
name|FIXUNDO
condition|)
name|error
argument_list|(
literal|"Cannot put inside global/macro"
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|unddol
operator|-
name|dol
expr_stmt|;
if|if
condition|(
name|cnt
operator|&&
name|inopen
operator|&&
name|pkill
index|[
literal|0
index|]
operator|&&
name|pkill
index|[
literal|1
index|]
condition|)
block|{
name|pragged
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|tad1
operator|=
name|dol
operator|+
literal|1
expr_stmt|;
name|ignore
argument_list|(
name|append
argument_list|(
name|getput
argument_list|,
name|addr2
argument_list|)
argument_list|)
expr_stmt|;
name|undkind
operator|=
name|UNDPUT
expr_stmt|;
name|notecnt
operator|=
name|cnt
expr_stmt|;
name|netchange
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * A tricky put, of a group of lines in the middle  * of an existing line.  Only from open/visual.  * Argument says pkills have meaning, e.g. called from  * put; it is 0 on calls from putreg.  */
end_comment

begin_macro
name|pragged
argument_list|(
argument|kill
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|kill
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|cursor
decl_stmt|;
specifier|register
name|char
modifier|*
name|gp
init|=
operator|&
name|genbuf
index|[
name|cursor
operator|-
name|linebuf
index|]
decl_stmt|;
comment|/* 	 * This kind of stuff is TECO's forte. 	 * We just grunge along, since it cuts 	 * across our line-oriented model of the world 	 * almost scrambling our addled brain. 	 */
if|if
condition|(
operator|!
name|kill
condition|)
name|getDOT
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|unddol
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill
condition|)
operator|*
name|pkill
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|linebuf
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|putmark
argument_list|(
name|unddol
argument_list|)
expr_stmt|;
name|getline
argument_list|(
name|dol
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill
condition|)
name|strcLIN
argument_list|(
name|pkill
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|gp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|strcLIN
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|putmark
argument_list|(
name|dol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
name|undap1
operator|=
name|dot
expr_stmt|;
name|undap2
operator|=
name|dot
operator|+
literal|1
expr_stmt|;
name|unddel
operator|=
name|dot
operator|-
literal|1
expr_stmt|;
name|undo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Shift lines, based on c.  * If c is neither< nor>, then this is a lisp aligning =.  */
end_comment

begin_macro
name|shift
argument_list|(
argument|c
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|FIXUNDO
condition|)
name|save12
argument_list|()
operator|,
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
name|cnt
operator|*=
name|value
argument_list|(
name|SHIFTWIDTH
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|addr1
init|;
name|addr
operator|<=
name|addr2
condition|;
name|addr
operator|++
control|)
block|{
name|dot
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|LISPCODE
if|if
condition|(
name|c
operator|==
literal|'='
operator|&&
name|addr
operator|==
name|addr1
operator|&&
name|addr
operator|!=
name|addr2
condition|)
continue|continue;
endif|#
directive|endif
name|getDOT
argument_list|()
expr_stmt|;
name|i
operator|=
name|whitecnt
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'>'
case|:
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cp
operator|=
name|genindent
argument_list|(
name|i
operator|+
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
name|i
operator|-=
name|cnt
expr_stmt|;
name|cp
operator|=
name|i
operator|>
literal|0
condition|?
name|genindent
argument_list|(
name|i
argument_list|)
else|:
name|genbuf
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LISPCODE
default|default:
name|i
operator|=
name|lindent
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|cp
operator|=
name|genindent
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|cp
operator|+
name|strlen
argument_list|(
name|dp
operator|=
name|vpastwh
argument_list|(
name|linebuf
argument_list|)
argument_list|)
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
name|error
argument_list|(
literal|"Line too long|Result line after shift would be too long"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|strcLIN
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|putmark
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|killed
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find a tag in the tags file.  * Most work here is in parsing the tags file itself.  */
end_comment

begin_macro
name|tagfind
argument_list|(
argument|quick
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|quick
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|filebuf
index|[
name|FNSIZE
index|]
decl_stmt|;
name|char
name|tagfbuf
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
name|bool
name|samef
init|=
literal|1
decl_stmt|;
name|int
name|tfcount
init|=
literal|0
decl_stmt|;
name|int
name|omagic
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|fne
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|FASTTAG
name|int
name|iof
decl_stmt|;
name|char
name|iofbuf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
name|long
name|mid
decl_stmt|;
comment|/* assumed byte offset */
name|long
name|top
decl_stmt|,
name|bot
decl_stmt|;
comment|/* length of tag file */
endif|#
directive|endif
name|omagic
operator|=
name|value
argument_list|(
name|MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skipend
argument_list|()
condition|)
block|{
specifier|register
name|char
modifier|*
name|lp
init|=
name|lasttag
decl_stmt|;
while|while
condition|(
operator|!
name|iswhite
argument_list|(
name|peekchar
argument_list|()
argument_list|)
operator|&&
operator|!
name|endcmd
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
if|if
condition|(
name|lp
operator|<
operator|&
name|lasttag
index|[
sizeof|sizeof
name|lasttag
operator|-
literal|2
index|]
condition|)
operator|*
name|lp
operator|++
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
else|else
name|ignchar
argument_list|()
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|endcmd
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
name|badtag
label|:
name|error
argument_list|(
literal|"Bad tag|Give one tag per line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lasttag
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous tag"
argument_list|)
expr_stmt|;
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|endcmd
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|badtag
goto|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|clrstats
argument_list|()
expr_stmt|;
comment|/* 	 * Loop once for each file in tags "path". 	 */
name|CP
argument_list|(
name|tagfbuf
argument_list|,
name|svalue
argument_list|(
name|TAGS
argument_list|)
argument_list|)
expr_stmt|;
name|fne
operator|=
name|tagfbuf
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|fne
condition|)
block|{
name|fn
operator|=
operator|++
name|fne
expr_stmt|;
while|while
condition|(
operator|*
name|fne
operator|&&
operator|*
name|fne
operator|!=
literal|' '
condition|)
name|fne
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fne
operator|==
literal|0
condition|)
name|fne
operator|=
literal|0
expr_stmt|;
comment|/* done, quit after this time */
else|else
operator|*
name|fne
operator|=
literal|0
expr_stmt|;
comment|/* null terminate filename */
ifdef|#
directive|ifdef
name|FASTTAG
name|iof
operator|=
name|topen
argument_list|(
name|fn
argument_list|,
name|iofbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|iof
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|tfcount
operator|++
expr_stmt|;
name|fstat
argument_list|(
name|iof
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|top
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0L
condition|)
name|top
operator|=
operator|-
literal|1L
expr_stmt|;
name|bot
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
name|top
operator|>=
name|bot
condition|)
block|{
else|#
directive|else
comment|/* 		 * Avoid stdio and scan tag file linearly. 		 */
name|io
operator|=
name|open
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|<
literal|0
condition|)
continue|continue;
name|tfcount
operator|++
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|io
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|bsize
operator|=
name|LBSIZE
expr_stmt|;
else|else
block|{
name|bsize
operator|=
name|sbuf
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
name|bsize
operator|<=
literal|0
condition|)
name|bsize
operator|=
name|LBSIZE
expr_stmt|;
block|}
while|while
condition|(
name|getfile
argument_list|()
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* loop for each tags file entry */
specifier|register
name|char
modifier|*
name|cp
init|=
name|linebuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
init|=
name|lasttag
decl_stmt|;
name|char
modifier|*
name|oglobp
decl_stmt|;
ifdef|#
directive|ifdef
name|FASTTAG
name|mid
operator|=
operator|(
name|top
operator|+
name|bot
operator|)
operator|/
literal|2
expr_stmt|;
name|tseek
argument_list|(
name|iof
argument_list|,
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|>
literal|0
condition|)
comment|/* to get first tag in file to work */
comment|/* scan to next \n */
if|if
condition|(
name|tgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|iof
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|goleft
goto|;
comment|/* get the line itself */
if|if
condition|(
name|tgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|iof
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|goleft
goto|;
ifdef|#
directive|ifdef
name|TDEBUG
name|ex_printf
argument_list|(
literal|"tag: %o %o %o %s\n"
argument_list|,
name|bot
argument_list|,
name|mid
argument_list|,
name|top
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|lp
operator|==
operator|*
name|cp
condition|)
name|cp
operator|++
operator|,
name|lp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lp
operator|||
operator|!
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
operator|&&
operator|(
name|value
argument_list|(
name|TAGLENGTH
argument_list|)
operator|==
literal|0
operator|||
name|lp
operator|-
name|lasttag
operator|<
name|value
argument_list|(
name|TAGLENGTH
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FASTTAG
if|if
condition|(
operator|*
name|lp
operator|>
operator|*
name|cp
condition|)
name|bot
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|goleft
label|:
name|top
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Not this tag.  Try the next */
continue|continue;
block|}
comment|/* 			 * We found the tag.  Decode the line in the file. 			 */
ifdef|#
directive|ifdef
name|FASTTAG
name|tclose
argument_list|(
name|iof
argument_list|)
expr_stmt|;
else|#
directive|else
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Rest of tag if abbreviated */
while|while
condition|(
operator|!
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* name of file */
while|while
condition|(
operator|*
name|cp
operator|&&
name|iswhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
name|badtags
label|:
name|serror
argument_list|(
literal|"%s: Bad tags file entry"
argument_list|,
name|lasttag
argument_list|)
expr_stmt|;
name|lp
operator|=
name|filebuf
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
condition|)
block|{
if|if
condition|(
name|lp
operator|<
operator|&
name|filebuf
index|[
sizeof|sizeof
name|filebuf
operator|-
literal|2
index|]
condition|)
operator|*
name|lp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
goto|goto
name|badtags
goto|;
if|if
condition|(
name|dol
operator|!=
name|zero
condition|)
block|{
comment|/* 				 * Save current position in 't for ^^ in visual. 				 */
name|names
index|[
literal|'t'
operator|-
literal|'a'
index|]
operator|=
operator|*
name|dot
operator|&
operator|~
literal|01
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
block|{
specifier|extern
name|char
modifier|*
name|ncols
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|2
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|cursor
decl_stmt|;
name|ncols
index|[
literal|'t'
operator|-
literal|'a'
index|]
operator|=
name|cursor
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filebuf
argument_list|,
name|savedfile
argument_list|)
operator|||
operator|!
name|edited
condition|)
block|{
name|char
name|cmdbuf2
index|[
sizeof|sizeof
name|filebuf
operator|+
literal|10
index|]
decl_stmt|;
comment|/* Different file.  Do autowrite& get it. */
if|if
condition|(
operator|!
name|quick
condition|)
block|{
name|ckaw
argument_list|()
expr_stmt|;
if|if
condition|(
name|chng
operator|&&
name|dol
operator|>
name|zero
condition|)
name|error
argument_list|(
literal|"No write@since last change (:tag! overrides)"
argument_list|)
expr_stmt|;
block|}
name|oglobp
operator|=
name|globp
expr_stmt|;
name|strcpy
argument_list|(
name|cmdbuf2
argument_list|,
literal|"e! "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmdbuf2
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
name|globp
operator|=
name|cmdbuf2
expr_stmt|;
name|d
operator|=
name|peekc
expr_stmt|;
name|ungetchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peekc
operator|=
name|d
expr_stmt|;
name|globp
operator|=
name|oglobp
expr_stmt|;
name|value
argument_list|(
name|MAGIC
argument_list|)
operator|=
name|omagic
expr_stmt|;
name|samef
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Look for pattern in the current file. 			 */
name|oglobp
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
name|cmdbuf
expr_stmt|;
name|d
operator|=
name|peekc
expr_stmt|;
name|ungetchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|samef
condition|)
name|markpr
argument_list|(
name|dot
argument_list|)
expr_stmt|;
comment|/* 			 * BUG: if it isn't found (user edited header 			 * line) we get left in nomagic mode. 			 */
name|value
argument_list|(
name|MAGIC
argument_list|)
operator|=
literal|0
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|peekc
operator|=
name|d
expr_stmt|;
name|globp
operator|=
name|oglobp
expr_stmt|;
name|value
argument_list|(
name|MAGIC
argument_list|)
operator|=
name|omagic
expr_stmt|;
return|return;
block|}
comment|/* end of "for each tag in file" */
comment|/* 		 * No such tag in this file.  Close it and try the next. 		 */
ifdef|#
directive|ifdef
name|FASTTAG
name|tclose
argument_list|(
name|iof
argument_list|)
expr_stmt|;
else|#
directive|else
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* end of "for each file in path" */
if|if
condition|(
name|tfcount
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"No tags file"
argument_list|)
expr_stmt|;
else|else
name|serror
argument_list|(
literal|"%s: No such tag@in tags file"
argument_list|,
name|lasttag
argument_list|)
expr_stmt|;
block|}
comment|/*  * Save lines from addr1 thru addr2 as though  * they had been deleted.  */
name|yank
argument_list|()
block|{
if|if
condition|(
operator|!
name|FIXUNDO
condition|)
name|error
argument_list|(
literal|"Can't yank inside global/macro"
argument_list|)
expr_stmt|;
name|save12
argument_list|()
expr_stmt|;
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
name|killcnt
argument_list|(
name|addr2
operator|-
name|addr1
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * z command; print windows of text in the file.  *  * If this seems unreasonably arcane, the reasons  * are historical.  This is one of the first commands  * added to the first ex (then called en) and the  * number of facilities here were the major advantage  * of en over ed since they allowed more use to be  * made of fast terminals w/o typing .,.22p all the time.  */
name|bool
name|zhadpr
decl_stmt|;
name|bool
name|znoclear
decl_stmt|;
name|short
name|zweight
decl_stmt|;
name|zop
argument_list|(
argument|hadpr
argument_list|)
name|int
name|hadpr
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|lines
decl_stmt|,
name|op
decl_stmt|;
name|bool
name|excl
decl_stmt|;
name|zhadpr
operator|=
name|hadpr
expr_stmt|;
name|notempty
argument_list|()
expr_stmt|;
name|znoclear
operator|=
literal|0
expr_stmt|;
name|zweight
operator|=
literal|0
expr_stmt|;
name|excl
operator|=
name|exclam
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|op
operator|=
name|ex_getchar
argument_list|()
condition|)
block|{
case|case
literal|'^'
case|:
name|zweight
operator|=
literal|1
expr_stmt|;
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
while|while
condition|(
name|peekchar
argument_list|()
operator|==
name|op
condition|)
block|{
name|ignchar
argument_list|()
expr_stmt|;
name|zweight
operator|++
expr_stmt|;
block|}
case|case
literal|'='
case|:
case|case
literal|'.'
case|:
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOF
case|:
name|znoclear
operator|++
expr_stmt|;
break|break;
default|default:
name|op
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lines
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|lines
operator|*=
literal|10
expr_stmt|;
name|lines
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|lines
operator|<
name|LINES
condition|)
name|znoclear
operator|++
expr_stmt|;
name|value
argument_list|(
name|WINDOW
argument_list|)
operator|=
name|lines
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'='
condition|)
name|lines
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|lines
operator|=
name|op
operator|==
name|EOF
condition|?
name|value
argument_list|(
name|SCROLL
argument_list|)
else|:
name|excl
condition|?
name|LINES
operator|-
literal|1
else|:
literal|2
operator|*
name|value
argument_list|(
name|SCROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
operator|||
name|c
operator|!=
name|EOF
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
name|addr1
operator|=
name|addr2
expr_stmt|;
if|if
condition|(
name|addr2
operator|==
literal|0
operator|&&
name|dot
operator|<
name|dol
operator|&&
name|op
operator|==
literal|0
condition|)
name|addr1
operator|=
name|addr2
operator|=
name|dot
operator|+
literal|1
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|zop2
argument_list|(
name|lines
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|zop2
argument_list|(
name|lines
argument_list|,
name|op
argument_list|)
specifier|register
name|int
name|lines
expr_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
block|{
specifier|register
name|line
modifier|*
name|split
decl_stmt|;
name|split
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EOF
case|:
if|if
condition|(
name|addr2
operator|==
name|dol
condition|)
name|error
argument_list|(
literal|"\nAt EOF"
argument_list|)
expr_stmt|;
case|case
literal|'+'
case|:
if|if
condition|(
name|addr2
operator|==
name|dol
condition|)
name|error
argument_list|(
literal|"At EOF"
argument_list|)
expr_stmt|;
name|addr2
operator|+=
name|lines
operator|*
name|zweight
expr_stmt|;
if|if
condition|(
name|addr2
operator|>
name|dol
condition|)
name|error
argument_list|(
literal|"Hit BOTTOM"
argument_list|)
expr_stmt|;
name|addr2
operator|++
expr_stmt|;
default|default:
name|addr1
operator|=
name|addr2
expr_stmt|;
name|addr2
operator|+=
name|lines
operator|-
literal|1
expr_stmt|;
name|dot
operator|=
name|addr2
expr_stmt|;
break|break;
case|case
literal|'='
case|:
case|case
literal|'.'
case|:
name|znoclear
operator|=
literal|0
expr_stmt|;
name|lines
operator|--
expr_stmt|;
name|lines
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'='
condition|)
name|lines
operator|--
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|-
name|lines
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'='
condition|)
name|dot
operator|=
name|split
operator|=
name|addr2
expr_stmt|;
name|addr2
operator|+=
name|lines
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'.'
condition|)
block|{
name|markDOT
argument_list|()
expr_stmt|;
name|dot
operator|=
name|addr2
expr_stmt|;
block|}
break|break;
case|case
literal|'^'
case|:
case|case
literal|'-'
case|:
name|addr2
operator|-=
name|lines
operator|*
name|zweight
expr_stmt|;
if|if
condition|(
name|addr2
operator|<
name|one
condition|)
name|error
argument_list|(
literal|"Hit TOP"
argument_list|)
expr_stmt|;
name|lines
operator|--
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|-
name|lines
expr_stmt|;
name|dot
operator|=
name|addr2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addr1
operator|<=
name|zero
condition|)
name|addr1
operator|=
name|one
expr_stmt|;
if|if
condition|(
name|addr2
operator|>
name|dol
condition|)
name|addr2
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|dol
condition|)
name|dot
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|addr1
operator|>
name|addr2
condition|)
return|return;
if|if
condition|(
name|op
operator|==
name|EOF
operator|&&
name|zhadpr
condition|)
block|{
name|getline
argument_list|(
operator|*
name|addr1
argument_list|)
expr_stmt|;
name|ex_putchar
argument_list|(
literal|'\r'
operator||
name|QUOTE
argument_list|)
expr_stmt|;
name|shudclob
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|znoclear
operator|==
literal|0
operator|&&
name|CL
operator|!=
name|NOSTR
operator|&&
operator|!
name|inopen
condition|)
block|{
name|flush1
argument_list|()
expr_stmt|;
name|vclear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|addr2
operator|-
name|addr1
operator|>
literal|1
condition|)
name|pstart
argument_list|()
expr_stmt|;
if|if
condition|(
name|split
condition|)
block|{
name|plines
argument_list|(
name|addr1
argument_list|,
name|split
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splitit
argument_list|()
expr_stmt|;
name|plines
argument_list|(
name|split
argument_list|,
name|split
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splitit
argument_list|()
expr_stmt|;
name|addr1
operator|=
name|split
operator|+
literal|1
expr_stmt|;
block|}
name|plines
argument_list|(
name|addr1
argument_list|,
name|addr2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|splitit
argument_list|()
block|{
specifier|register
name|int
name|l
block|;
for|for
control|(
name|l
operator|=
name|COLUMNS
operator|>
literal|80
condition|?
literal|40
else|:
name|COLUMNS
operator|/
literal|2
init|;
name|l
operator|>
literal|0
condition|;
name|l
operator|--
control|)
name|ex_putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|putnl
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|plines
argument_list|(
name|adr1
argument_list|,
name|adr2
argument_list|,
name|movedot
argument_list|)
name|line
operator|*
name|adr1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|line
modifier|*
name|adr2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|movedot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
name|pofix
argument_list|()
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|adr1
init|;
name|addr
operator|<=
name|adr2
condition|;
name|addr
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|pline
argument_list|(
name|lineno
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|ex_putchar
argument_list|(
literal|'\n'
operator||
name|QUOTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|movedot
condition|)
name|dot
operator|=
name|addr
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pofix
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|inopen
operator|&&
name|Outchar
operator|!=
name|termchar
condition|)
block|{
name|vnfl
argument_list|()
expr_stmt|;
name|setoutt
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Dudley doright to the rescue.  * Undo saves the day again.  * A tip of the hatlo hat to Warren Teitleman  * who made undo as useful as do.  *  * Command level undo works easily because  * the editor has a unique temporary file  * index for every line which ever existed.  * We don't have to save large blocks of text,  * only the indices which are small.  We do this  * by moving them to after the last line in the  * line buffer array, and marking down info  * about whence they came.  *  * Undo is its own inverse.  */
end_comment

begin_macro
name|undo
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|line
modifier|*
name|jp
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|line
modifier|*
name|dolp1
decl_stmt|,
modifier|*
name|newdol
decl_stmt|,
modifier|*
name|newadot
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"before undo"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|inglobal
operator|&&
name|inopen
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Can't undo in global@commands"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|somechange
argument_list|()
expr_stmt|;
name|pkill
index|[
literal|0
index|]
operator|=
name|pkill
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|change
argument_list|()
expr_stmt|;
if|if
condition|(
name|undkind
operator|==
name|UNDMOVE
condition|)
block|{
comment|/* 		 * Command to be undone is a move command. 		 * This is handled as a special case by noting that 		 * a move "a,b m c" can be inverted by another move. 		 */
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|jp
operator|=
name|unddel
operator|)
operator|-
name|undap2
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * when c> b inverse is a+(c-b),c m a-1 			 */
name|addr2
operator|=
name|jp
expr_stmt|;
name|addr1
operator|=
operator|(
name|jp
operator|=
name|undap1
operator|)
operator|+
name|i
expr_stmt|;
name|unddel
operator|=
name|jp
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * when b> c inverse is  c+1,c+1+(b-a) m b 			 */
name|addr1
operator|=
operator|++
name|jp
expr_stmt|;
name|addr2
operator|=
name|jp
operator|+
operator|(
operator|(
name|unddel
operator|=
name|undap2
operator|)
operator|-
name|undap1
operator|)
expr_stmt|;
block|}
name|kp
operator|=
name|undap1
expr_stmt|;
name|move1
argument_list|(
literal|0
argument_list|,
name|unddel
argument_list|)
expr_stmt|;
name|dot
operator|=
name|kp
expr_stmt|;
name|Command
operator|=
literal|"move"
expr_stmt|;
name|killed
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|cnt
decl_stmt|;
name|newadot
operator|=
name|dot
expr_stmt|;
name|cnt
operator|=
name|lineDOL
argument_list|()
expr_stmt|;
name|newdol
operator|=
name|dol
expr_stmt|;
name|dolp1
operator|=
name|dol
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Command to be undone is a non-move. 		 * All such commands are treated as a combination of 		 * a delete command and a append command. 		 * We first move the lines appended by the last command 		 * from undap1 to undap2-1 so that they are just before the 		 * saved deleted lines. 		 */
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|kp
operator|=
name|undap2
operator|)
operator|-
operator|(
name|jp
operator|=
name|undap1
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|kp
operator|!=
name|dolp1
condition|)
block|{
name|reverse
argument_list|(
name|jp
argument_list|,
name|kp
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|kp
argument_list|,
name|dolp1
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|jp
argument_list|,
name|dolp1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Account for possible backward motion of target 			 * for restoration of saved deleted lines. 			 */
if|if
condition|(
name|unddel
operator|>=
name|jp
condition|)
name|unddel
operator|-=
name|i
expr_stmt|;
name|newdol
operator|-=
name|i
expr_stmt|;
comment|/* 			 * For the case where no lines are restored, dot 			 * is the line before the first line deleted. 			 */
name|dot
operator|=
name|jp
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 		 * Now put the deleted lines, if any, back where they were. 		 * Basic operation is: dol+1,unddol m unddel 		 */
if|if
condition|(
name|undkind
operator|==
name|UNDPUT
condition|)
block|{
name|unddel
operator|=
name|undap1
operator|-
literal|1
expr_stmt|;
name|squish
argument_list|()
expr_stmt|;
block|}
name|jp
operator|=
name|unddel
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|kp
operator|=
name|unddol
operator|)
operator|-
name|dol
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|jp
operator|!=
name|dolp1
condition|)
block|{
name|reverse
argument_list|(
name|jp
argument_list|,
name|dolp1
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|dolp1
argument_list|,
operator|++
name|kp
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|jp
argument_list|,
name|kp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Account for possible forward motion of the target 			 * for restoration of the deleted lines. 			 */
if|if
condition|(
name|undap1
operator|>=
name|jp
condition|)
name|undap1
operator|+=
name|i
expr_stmt|;
comment|/* 			 * Dot is the first resurrected line. 			 */
name|dot
operator|=
name|jp
expr_stmt|;
name|newdol
operator|+=
name|i
expr_stmt|;
block|}
comment|/* 		 * Clean up so we are invertible 		 */
name|unddel
operator|=
name|undap1
operator|-
literal|1
expr_stmt|;
name|undap1
operator|=
name|jp
expr_stmt|;
name|undap2
operator|=
name|jp
operator|+
name|i
expr_stmt|;
name|dol
operator|=
name|newdol
expr_stmt|;
name|netchHAD
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|undkind
operator|==
name|UNDALL
condition|)
block|{
name|dot
operator|=
name|undadot
expr_stmt|;
name|undadot
operator|=
name|newadot
expr_stmt|;
block|}
else|else
name|undkind
operator|=
name|UNDCHANGE
expr_stmt|;
block|}
comment|/* 	 * Defensive programming - after a munged undadot. 	 * Also handle empty buffer case. 	 */
if|if
condition|(
operator|(
name|dot
operator|<=
name|zero
operator|||
name|dot
operator|>
name|dol
operator|)
operator|&&
name|dot
operator|!=
name|dol
condition|)
name|dot
operator|=
name|one
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|vudump
argument_list|(
literal|"after undo"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Be (almost completely) sure there really  * was a change, before claiming to undo.  */
end_comment

begin_macro
name|somechange
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|line
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
switch|switch
condition|(
name|undkind
condition|)
block|{
case|case
name|UNDMOVE
case|:
return|return;
case|case
name|UNDCHANGE
case|:
if|if
condition|(
name|undap1
operator|==
name|undap2
operator|&&
name|dol
operator|==
name|unddol
condition|)
break|break;
return|return;
case|case
name|UNDPUT
case|:
if|if
condition|(
name|undap1
operator|!=
name|undap2
condition|)
return|return;
break|break;
case|case
name|UNDALL
case|:
if|if
condition|(
name|unddol
operator|-
name|dol
operator|!=
name|lineDOL
argument_list|()
condition|)
return|return;
for|for
control|(
name|ip
operator|=
name|one
operator|,
name|jp
operator|=
name|dol
operator|+
literal|1
init|;
name|ip
operator|<=
name|dol
condition|;
name|ip
operator|++
operator|,
name|jp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|ip
operator|&
operator|~
literal|01
operator|)
operator|!=
operator|(
operator|*
name|jp
operator|&
operator|~
literal|01
operator|)
condition|)
return|return;
break|break;
case|case
name|UNDNONE
case|:
name|error
argument_list|(
literal|"Nothing to undo"
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Nothing changed|Last undoable command didn't change anything"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map command:  * map src dest  */
end_comment

begin_macro
name|mapcmd
argument_list|(
argument|un
argument_list|,
argument|ab
argument_list|)
end_macro

begin_decl_stmt
name|int
name|un
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if this is unmap command */
end_comment

begin_decl_stmt
name|int
name|ab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if this is abbr command */
end_comment

begin_block
block|{
name|char
name|lhs
index|[
literal|100
index|]
decl_stmt|,
name|rhs
index|[
literal|100
index|]
decl_stmt|;
comment|/* max sizes resp. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* mjm: char --> int */
name|char
modifier|*
name|dname
decl_stmt|;
name|struct
name|maps
modifier|*
name|mp
decl_stmt|;
comment|/* the map structure we are working on */
name|mp
operator|=
name|ab
condition|?
name|abbrevs
else|:
name|exclam
argument_list|()
condition|?
name|immacs
else|:
name|arrows
expr_stmt|;
if|if
condition|(
name|skipend
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* print current mapping values */
if|if
condition|(
name|peekchar
argument_list|()
operator|!=
name|EOF
condition|)
name|ignchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|un
condition|)
name|error
argument_list|(
literal|"Missing lhs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
condition|)
name|pofix
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
index|[
name|i
index|]
operator|.
name|mapto
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mp
index|[
name|i
index|]
operator|.
name|cap
condition|)
block|{
name|lprintf
argument_list|(
literal|"%s"
argument_list|,
name|mp
index|[
name|i
index|]
operator|.
name|descr
argument_list|)
expr_stmt|;
name|ex_putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"%s"
argument_list|,
name|mp
index|[
name|i
index|]
operator|.
name|cap
argument_list|)
expr_stmt|;
name|ex_putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"%s"
argument_list|,
name|mp
index|[
name|i
index|]
operator|.
name|mapto
argument_list|)
expr_stmt|;
name|putNFL
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|ignore
argument_list|(
name|skipwh
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lhs
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CTRL
argument_list|(
literal|'v'
argument_list|)
condition|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|un
operator|&&
name|any
argument_list|(
name|c
argument_list|,
literal|" \t"
argument_list|)
condition|)
block|{
comment|/* End of lhs */
break|break;
block|}
elseif|else
if|if
condition|(
name|endcmd
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'"'
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
condition|)
block|{
name|newline
argument_list|()
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|addmac
argument_list|(
name|lhs
argument_list|,
name|NOSTR
argument_list|,
name|NOSTR
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|error
argument_list|(
literal|"Missing rhs"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skipend
argument_list|()
condition|)
name|error
argument_list|(
literal|"Missing rhs"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|rhs
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CTRL
argument_list|(
literal|'v'
argument_list|)
condition|)
block|{
name|c
operator|=
name|ex_getchar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endcmd
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'"'
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
comment|/* 	 * Special hack for function keys: #1 means key f1, etc. 	 * If the terminal doesn't have function keys, we just use #1. 	 */
if|if
condition|(
name|lhs
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|char
modifier|*
name|fnkey
decl_stmt|;
name|char
modifier|*
name|fkey
parameter_list|()
function_decl|;
name|char
name|funkey
index|[
literal|3
index|]
decl_stmt|;
name|fnkey
operator|=
name|fkey
argument_list|(
name|lhs
index|[
literal|1
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|funkey
index|[
literal|0
index|]
operator|=
literal|'f'
expr_stmt|;
name|funkey
index|[
literal|1
index|]
operator|=
name|lhs
index|[
literal|1
index|]
expr_stmt|;
name|funkey
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fnkey
condition|)
name|strcpy
argument_list|(
name|lhs
argument_list|,
name|fnkey
argument_list|)
expr_stmt|;
name|dname
operator|=
name|funkey
expr_stmt|;
block|}
else|else
block|{
name|dname
operator|=
name|lhs
expr_stmt|;
block|}
name|addmac
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|dname
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Add a macro definition to those that already exist. The sequence of  * chars "src" is mapped into "dest". If src is already mapped into something  * this overrides the mapping. There is no recursion. Unmap is done by  * using NOSTR for dest.  Dname is what to show in listings.  mp is  * the structure to affect (arrows, etc).  */
end_comment

begin_expr_stmt
name|addmac
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|dname
argument_list|,
name|mp
argument_list|)
specifier|register
name|char
operator|*
name|src
operator|,
operator|*
name|dest
operator|,
operator|*
name|dname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|maps
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|slot
decl_stmt|,
name|zer
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"addmac(src='%s', dest='%s', dname='%s', mp=%x\n"
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|dname
argument_list|,
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dest
operator|&&
name|mp
operator|==
name|arrows
condition|)
block|{
comment|/* Make sure user doesn't screw himself */
comment|/* 		 * Prevent tail recursion. We really should be 		 * checking to see if src is a suffix of dest 		 * but this makes mapping involving escapes that 		 * is reasonable mess up. 		 */
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|src
index|[
literal|0
index|]
operator|==
name|dest
index|[
name|strlen
argument_list|(
name|dest
argument_list|)
operator|-
literal|1
index|]
condition|)
name|error
argument_list|(
literal|"No tail recursion"
argument_list|)
expr_stmt|;
comment|/* 		 * We don't let the user rob himself of ":", and making 		 * multi char words is a bad idea so we don't allow it. 		 * Note that if user sets mapinput and maps all of return, 		 * linefeed, and escape, he can screw himself. This is 		 * so weird I don't bother to check for it. 		 */
if|if
condition|(
name|isalpha
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|&&
name|src
index|[
literal|1
index|]
operator|||
name|any
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|,
literal|":"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Too dangerous to map that"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
condition|)
block|{
comment|/* check for tail recursion in input mode: fussier */
if|if
condition|(
name|eq
argument_list|(
name|src
argument_list|,
name|dest
operator|+
name|strlen
argument_list|(
name|dest
argument_list|)
operator|-
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"No tail recursion"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the src were null it would cause the dest to 	 * be mapped always forever. This is not good. 	 */
if|if
condition|(
name|src
operator|==
name|NOSTR
operator|||
name|src
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Missing lhs"
argument_list|)
expr_stmt|;
comment|/* see if we already have a def for src */
name|zer
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|mp
index|[
name|slot
index|]
operator|.
name|mapto
condition|;
name|slot
operator|++
control|)
block|{
if|if
condition|(
name|mp
index|[
name|slot
index|]
operator|.
name|cap
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|src
argument_list|,
name|mp
index|[
name|slot
index|]
operator|.
name|cap
argument_list|)
operator|||
name|eq
argument_list|(
name|src
argument_list|,
name|mp
index|[
name|slot
index|]
operator|.
name|mapto
argument_list|)
condition|)
break|break;
comment|/* if so, reuse slot */
block|}
else|else
block|{
name|zer
operator|=
name|slot
expr_stmt|;
comment|/* remember an empty slot */
block|}
block|}
if|if
condition|(
name|dest
operator|==
name|NOSTR
condition|)
block|{
comment|/* unmap */
if|if
condition|(
name|mp
index|[
name|slot
index|]
operator|.
name|cap
condition|)
block|{
name|mp
index|[
name|slot
index|]
operator|.
name|cap
operator|=
name|NOSTR
expr_stmt|;
name|mp
index|[
name|slot
index|]
operator|.
name|descr
operator|=
name|NOSTR
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Not mapped|That macro wasn't mapped"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* reuse empty slot, if we found one and src isn't already defined */
if|if
condition|(
name|zer
operator|>=
literal|0
operator|&&
name|mp
index|[
name|slot
index|]
operator|.
name|mapto
operator|==
literal|0
condition|)
name|slot
operator|=
name|zer
expr_stmt|;
comment|/* if not, append to end */
if|if
condition|(
name|slot
operator|>=
name|MAXNOMACS
condition|)
name|error
argument_list|(
literal|"Too many macros"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msnext
operator|==
literal|0
condition|)
comment|/* first time */
name|msnext
operator|=
name|mapspace
expr_stmt|;
comment|/* Check is a bit conservative, we charge for dname even if reusing src */
if|if
condition|(
name|msnext
operator|-
name|mapspace
operator|+
name|strlen
argument_list|(
name|dest
argument_list|)
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
name|strlen
argument_list|(
name|dname
argument_list|)
operator|+
literal|3
operator|>
name|MAXCHARMACS
condition|)
name|error
argument_list|(
literal|"Too much macro text"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msnext
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|mp
index|[
name|slot
index|]
operator|.
name|cap
operator|=
name|msnext
expr_stmt|;
name|msnext
operator|+=
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* plus 1 for null on the end */
name|CP
argument_list|(
name|msnext
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|mp
index|[
name|slot
index|]
operator|.
name|mapto
operator|=
name|msnext
expr_stmt|;
name|msnext
operator|+=
name|strlen
argument_list|(
name|dest
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dname
condition|)
block|{
name|CP
argument_list|(
name|msnext
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|mp
index|[
name|slot
index|]
operator|.
name|descr
operator|=
name|msnext
expr_stmt|;
name|msnext
operator|+=
name|strlen
argument_list|(
name|dname
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* default descr to string user enters */
name|mp
index|[
name|slot
index|]
operator|.
name|descr
operator|=
name|src
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Implements macros from command mode. c is the buffer to  * get the macro from.  */
end_comment

begin_macro
name|cmdmac
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|macbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|line
modifier|*
name|ad
decl_stmt|,
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
name|char
modifier|*
name|oglobp
decl_stmt|;
name|short
name|pk
decl_stmt|;
name|bool
name|oinglobal
decl_stmt|;
name|lastmac
operator|=
name|c
expr_stmt|;
name|oglobp
operator|=
name|globp
expr_stmt|;
name|oinglobal
operator|=
name|inglobal
expr_stmt|;
name|pk
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inglobal
operator|<
literal|2
condition|)
name|inglobal
operator|=
literal|1
expr_stmt|;
name|regbuf
argument_list|(
name|c
argument_list|,
name|macbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|macbuf
argument_list|)
argument_list|)
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|a2
operator|=
name|addr2
expr_stmt|;
for|for
control|(
name|ad
operator|=
name|a1
init|;
name|ad
operator|<=
name|a2
condition|;
name|ad
operator|++
control|)
block|{
name|globp
operator|=
name|macbuf
expr_stmt|;
name|dot
operator|=
name|ad
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|globp
operator|=
name|oglobp
expr_stmt|;
name|inglobal
operator|=
name|oinglobal
expr_stmt|;
name|peekc
operator|=
name|pk
expr_stmt|;
block|}
end_block

end_unit

