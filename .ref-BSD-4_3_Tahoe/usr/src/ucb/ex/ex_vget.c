begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_vget.c	6.10 (Berkeley) 1/2/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Input routines for open/visual.  * We handle upper case only terminals in visual and reading from the  * echo area here as well as notification on large changes  * which appears in the echo area.  */
end_comment

begin_comment
comment|/*  * Return the key.  */
end_comment

begin_macro
name|ungetkey
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mjm: char --> int */
end_comment

begin_block
block|{
if|if
condition|(
name|Peek_key
operator|!=
name|ATTN
condition|)
name|Peek_key
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return a keystroke, but never a ^@.  */
end_comment

begin_macro
name|getkey
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* mjm: char --> int */
do|do
block|{
name|c
operator|=
name|getbr
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|0
condition|)
do|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Tell whether next keystroke would be a ^@.  */
end_comment

begin_macro
name|peekbr
argument_list|()
end_macro

begin_block
block|{
name|Peek_key
operator|=
name|getbr
argument_list|()
expr_stmt|;
return|return
operator|(
name|Peek_key
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|short
name|precbksl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|readbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doingread
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a keystroke, including a ^@.  * If an key was returned with ungetkey, that  * comes back first.  Next comes unread input (e.g.  * from repeating commands with .), and finally new  * keystrokes.  *  * The hard work here is in mapping of \ escaped  * characters on upper case only terminals.  */
end_comment

begin_macro
name|getbr
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|colp
decl_stmt|;
define|#
directive|define
name|BEEHIVE
ifdef|#
directive|ifdef
name|BEEHIVE
specifier|static
name|char
name|Peek2key
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|short
name|slevel
decl_stmt|,
name|ttyindes
decl_stmt|;
name|getATTN
label|:
if|if
condition|(
name|Peek_key
condition|)
block|{
name|c
operator|=
name|Peek_key
expr_stmt|;
name|Peek_key
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BEEHIVE
if|if
condition|(
name|Peek2key
condition|)
block|{
name|c
operator|=
name|Peek2key
expr_stmt|;
name|Peek2key
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|vglobp
condition|)
block|{
if|if
condition|(
operator|*
name|vglobp
condition|)
return|return
operator|(
name|lastvgk
operator|=
operator|*
name|vglobp
operator|++
operator|)
return|;
name|lastvgk
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ESCAPE
operator|)
return|;
block|}
if|if
condition|(
name|vmacp
condition|)
block|{
if|if
condition|(
operator|*
name|vmacp
condition|)
return|return
operator|(
operator|*
name|vmacp
operator|++
operator|)
return|;
comment|/* End of a macro or set of nested macros */
name|vmacp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inopen
operator|==
operator|-
literal|1
condition|)
comment|/* don't screw up undo for esc esc */
name|vundkind
operator|=
name|VMANY
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
comment|/* restore old setting now that macro done */
name|vch_mac
operator|=
name|VC_NOTINMAC
expr_stmt|;
block|}
name|flusho
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|setjmp
argument_list|(
name|readbuf
argument_list|)
condition|)
goto|goto
name|getATTN
goto|;
name|doingread
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|vms
name|c
operator|=
name|read
argument_list|(
name|slevel
operator|==
literal|0
condition|?
literal|0
else|:
name|ttyindes
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|vms_read
argument_list|(
name|slevel
operator|==
literal|0
condition|?
literal|0
else|:
name|ttyindes
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|doingread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|getATTN
goto|;
name|error
argument_list|(
literal|"Input read error"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|ch
operator|&
name|TRIM
expr_stmt|;
ifdef|#
directive|ifdef
name|BEEHIVE
if|if
condition|(
name|XB
operator|&&
name|slevel
operator|==
literal|0
operator|&&
name|c
operator|==
name|ESCAPE
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|Peek2key
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|getATTN
goto|;
name|Peek2key
operator|&=
name|TRIM
expr_stmt|;
switch|switch
condition|(
name|Peek2key
condition|)
block|{
case|case
literal|'C'
case|:
comment|/* SPOW mode sometimes sends \EC for space */
name|c
operator|=
literal|' '
expr_stmt|;
name|Peek2key
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* f2 -> ^C */
name|c
operator|=
name|CTRL
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|Peek2key
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* f1 -> esc */
name|Peek2key
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UCVISUAL
comment|/* 	 * The algorithm here is that of the UNIX kernel. 	 * See the description in the programmers manual. 	 */
if|if
condition|(
name|UPPERCASE
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|precbksl
operator|<
literal|2
condition|)
name|precbksl
operator|++
expr_stmt|;
if|if
condition|(
name|precbksl
operator|==
literal|1
condition|)
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|precbksl
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|d
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|colp
operator|=
literal|"({)}!|^~'~"
expr_stmt|;
while|while
condition|(
name|d
operator|=
operator|*
name|colp
operator|++
condition|)
if|if
condition|(
name|d
operator|==
name|c
condition|)
block|{
name|d
operator|=
operator|*
name|colp
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|colp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|precbksl
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|Peek_key
operator|=
name|c
expr_stmt|;
name|precbksl
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
condition|)
name|c
operator|=
name|d
expr_stmt|;
else|else
block|{
name|Peek_key
operator|=
name|c
expr_stmt|;
name|precbksl
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|precbksl
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
block|{
if|if
condition|(
operator|!
name|techoin
condition|)
block|{
name|tfixnl
argument_list|()
expr_stmt|;
name|techoin
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"*** Input: "
argument_list|)
expr_stmt|;
block|}
name|tracec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|lastvgk
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a key, but if a delete, quit or attention  * is typed return 0 so we will abort a partial command.  */
end_comment

begin_macro
name|getesc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'v'
argument_list|)
case|:
case|case
name|CTRL
argument_list|(
literal|'q'
argument_list|)
case|:
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
case|case
name|ATTN
case|:
case|case
name|QUIT
case|:
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ESCAPE
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Peek at the next keystroke.  */
end_comment

begin_macro
name|peekkey
argument_list|()
end_macro

begin_block
block|{
name|Peek_key
operator|=
name|getkey
argument_list|()
expr_stmt|;
return|return
operator|(
name|Peek_key
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read a line from the echo area, with single character prompt c.  * A return value of 1 means the user blewit or blewit away.  */
end_comment

begin_macro
name|readecho
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sc
init|=
name|cursor
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|OP
function_decl|)
parameter_list|()
function_decl|;
name|bool
name|waste
decl_stmt|;
specifier|register
name|int
name|OPeek
decl_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vclean
argument_list|()
expr_stmt|;
else|else
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splitw
operator|++
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ex_putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|genbuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|peekbr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|INS
index|[
literal|0
index|]
operator|||
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
goto|goto
name|blewit
goto|;
name|vglobp
operator|=
name|INS
expr_stmt|;
block|}
name|OP
operator|=
name|Pline
expr_stmt|;
name|Pline
operator|=
name|normline
expr_stmt|;
name|ignore
argument_list|(
name|vgetline
argument_list|(
literal|0
argument_list|,
name|genbuf
operator|+
literal|1
argument_list|,
operator|&
name|waste
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Outchar
operator|==
name|termchar
condition|)
name|ex_putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
name|Pline
operator|=
name|OP
expr_stmt|;
if|if
condition|(
name|Peek_key
operator|!=
name|ATTN
operator|&&
name|Peek_key
operator|!=
name|QUIT
operator|&&
name|Peek_key
operator|!=
name|CTRL
argument_list|(
literal|'h'
argument_list|)
condition|)
block|{
name|cursor
operator|=
name|sc
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|blewit
label|:
name|OPeek
operator|=
name|Peek_key
operator|==
name|CTRL
argument_list|(
literal|'h'
argument_list|)
condition|?
literal|0
else|:
name|Peek_key
expr_stmt|;
name|Peek_key
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
name|vshow
argument_list|(
name|dot
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|Peek_key
operator|=
name|OPeek
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A complete command has been defined for  * the purposes of repeat, so copy it from  * the working to the previous command buffer.  */
end_comment

begin_macro
name|setLAST
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|vglobp
operator|||
name|vmacp
condition|)
return|return;
name|lastreg
operator|=
name|vreg
expr_stmt|;
name|lasthad
operator|=
name|Xhadcnt
expr_stmt|;
name|lastcnt
operator|=
name|Xcnt
expr_stmt|;
operator|*
name|lastcp
operator|=
literal|0
expr_stmt|;
name|CP
argument_list|(
name|lastcmd
argument_list|,
name|workcmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Gather up some more text from an insert.  * If the insertion buffer oveflows, then destroy  * the repeatability of the insert.  */
end_comment

begin_macro
name|addtext
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|vglobp
condition|)
return|return;
name|addto
argument_list|(
name|INS
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
name|lastcmd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|setDEL
argument_list|()
end_macro

begin_block
block|{
name|ex_setBUF
argument_list|(
name|DEL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put text from cursor upto wcursor in BUF.  */
end_comment

begin_expr_stmt
name|ex_setBUF
argument_list|(
name|BUF
argument_list|)
specifier|register
name|char
operator|*
name|BUF
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|wp
init|=
name|wcursor
decl_stmt|;
name|c
operator|=
operator|*
name|wp
expr_stmt|;
operator|*
name|wp
operator|=
literal|0
expr_stmt|;
name|BUF
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addto
argument_list|(
name|BUF
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|wp
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|addto
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
specifier|register
name|char
operator|*
name|buf
operator|,
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
return|return;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|>=
name|VBSIZE
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|OVERBUF
expr_stmt|;
return|return;
block|}
name|ignore
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Note a change affecting a lot of lines, or non-visible  * lines.  If the parameter must is set, then we only want  * to do this for open modes now; return and save for later  * notification in visual.  */
end_comment

begin_macro
name|noteit
argument_list|(
argument|must
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|must
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|sdl
init|=
name|destline
decl_stmt|,
name|sdc
init|=
name|destcol
decl_stmt|;
if|if
condition|(
name|notecnt
operator|<
literal|2
operator|||
operator|!
name|must
operator|&&
name|state
operator|==
name|VISUAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|splitw
operator|++
expr_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vmoveitup
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vigoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ex_printf
argument_list|(
literal|"%d %sline"
argument_list|,
name|notecnt
argument_list|,
name|notesgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|notecnt
operator|>
literal|1
condition|)
name|ex_putchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|notenam
condition|)
block|{
name|ex_printf
argument_list|(
literal|" %s"
argument_list|,
name|notenam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|strend
argument_list|(
name|notenam
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'e'
condition|)
name|ex_putchar
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|ex_putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
block|}
name|vclreol
argument_list|()
expr_stmt|;
name|notecnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ONEOPEN
operator|||
name|state
operator|==
name|CRTOPEN
condition|)
name|vup1
argument_list|()
expr_stmt|;
name|destline
operator|=
name|sdl
expr_stmt|;
name|destcol
operator|=
name|sdc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Rrrrringgggggg.  * If possible, use flash (VB).  */
end_comment

begin_macro
name|beep
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|VB
condition|)
name|vputp
argument_list|(
name|VB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vputc
argument_list|(
name|CTRL
argument_list|(
literal|'g'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map the command input character c,  * for keypads and labelled keys which do cursor  * motions.  I.e. on an adm3a we might map ^K to ^P.  * DM1520 for example has a lot of mappable characters.  */
end_comment

begin_expr_stmt
name|map
argument_list|(
name|c
argument_list|,
name|maps
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|maps
modifier|*
name|maps
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|b
index|[
literal|10
index|]
decl_stmt|;
comment|/* Assumption: no keypad sends string longer than 10 */
comment|/* 	 * Mapping for special keys on the terminal only. 	 * BUG: if there's a long sequence and it matches 	 * some chars and then misses, we lose some chars. 	 * 	 * For this to work, some conditions must be met. 	 * 1) Keypad sends SHORT (2 or 3 char) strings 	 * 2) All strings sent are same length& similar 	 * 3) The user is unlikely to type the first few chars of 	 *    one of these strings very fast. 	 * Note: some code has been fixed up since the above was laid out, 	 * so conditions 1& 2 are probably not required anymore. 	 * However, this hasn't been tested with any first char 	 * that means anything else except escape. 	 */
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"map(%c): "
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If c==0, the char came from getesc typing escape.  Pass it through 	 * unchanged.  0 messes up the following code anyway. 	 */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|b
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|maps
index|[
name|d
index|]
operator|.
name|mapto
condition|;
name|d
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\ntry '%s', "
argument_list|,
name|maps
index|[
name|d
index|]
operator|.
name|cap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|=
name|maps
index|[
name|d
index|]
operator|.
name|cap
condition|)
block|{
for|for
control|(
name|q
operator|=
name|b
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"q->b[%d], "
argument_list|,
name|q
operator|-
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Is there another char waiting? 					 * 					 * This test is oversimplified, but 					 * should work mostly. It handles the 					 * case where we get an ESCAPE that 					 * wasn't part of a keypad string. 					 */
if|if
condition|(
operator|(
name|c
operator|==
literal|'#'
condition|?
name|peekkey
argument_list|()
else|:
name|fastpeekkey
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"fpk=0: will return '%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 						 * Nothing waiting.  Push back 						 * what we peeked at& return 						 * failure (c). 						 * 						 * We want to be able to undo 						 * commands, but it's nonsense 						 * to undo part of an insertion 						 * so if in input mode don't. 						 */
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"Call macpush, b %d %d %d\n"
argument_list|,
name|b
index|[
literal|0
index|]
argument_list|,
name|b
index|[
literal|1
index|]
argument_list|,
name|b
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|macpush
argument_list|(
operator|&
name|b
index|[
literal|1
index|]
argument_list|,
name|maps
operator|==
name|arrows
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"return %d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|*
name|q
operator|=
name|getkey
argument_list|()
expr_stmt|;
name|q
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
goto|goto
name|contin
goto|;
block|}
name|macpush
argument_list|(
name|maps
index|[
name|d
index|]
operator|.
name|mapto
argument_list|,
name|maps
operator|==
name|arrows
argument_list|)
expr_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"Success: push(%s), return %c"
argument_list|,
name|maps
index|[
name|d
index|]
operator|.
name|mapto
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
comment|/* first char of map string */
name|contin
label|:
empty_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"Fail: push(%s), return %c"
argument_list|,
operator|&
name|b
index|[
literal|1
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|macpush
argument_list|(
operator|&
name|b
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Push st onto the front of vmacp. This is tricky because we have to  * worry about where vmacp was previously pointing. We also have to  * check for overflow (which is typically from a recursive macro)  * Finally we have to set a flag so the whole thing can be undone.  * canundo is 1 iff we want to be able to undo the macro.  This  * is false for, for example, pushing back lookahead from fastpeekkey(),  * since otherwise two fast escapes can clobber our undo.  */
end_comment

begin_macro
name|macpush
argument_list|(
argument|st
argument_list|,
argument|canundo
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|canundo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tmpbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|st
operator|==
literal|0
operator|||
operator|*
name|st
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"macpush(%s), canundo=%d\n"
argument_list|,
name|st
argument_list|,
name|canundo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|vmacp
condition|?
name|strlen
argument_list|(
name|vmacp
argument_list|)
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|st
argument_list|)
operator|>
name|BUFSIZ
condition|)
name|error
argument_list|(
literal|"Macro too long@ - maybe recursive?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmacp
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|vmacp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FIXUNDO
condition|)
name|canundo
operator|=
literal|0
expr_stmt|;
comment|/* can't undo inside a macro anyway */
block|}
name|strcpy
argument_list|(
name|vmacbuf
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmacp
condition|)
name|strcat
argument_list|(
name|vmacbuf
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|vmacp
operator|=
name|vmacbuf
expr_stmt|;
comment|/* arrange to be able to undo the whole macro */
if|if
condition|(
name|canundo
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|otchng
operator|=
name|tchng
expr_stmt|;
name|vsave
argument_list|()
expr_stmt|;
name|saveall
argument_list|()
expr_stmt|;
name|inopen
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no need to save since it had to be 1 or -1 before */
name|vundkind
operator|=
name|VMANY
expr_stmt|;
endif|#
directive|endif
name|vch_mac
operator|=
name|VC_NOCHANGE
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_macro
name|visdump
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|trace
condition|)
return|return;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n%s: basWTOP=%d, basWLINES=%d, WTOP=%d, WBOT=%d, WLINES=%d, WCOLS=%d, WECHO=%d\n"
argument_list|,
name|s
argument_list|,
name|basWTOP
argument_list|,
name|basWLINES
argument_list|,
name|WTOP
argument_list|,
name|WBOT
argument_list|,
name|WLINES
argument_list|,
name|WCOLS
argument_list|,
name|WECHO
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"   vcnt=%d, vcline=%d, cursor=%d, wcursor=%d, wdot=%d\n"
argument_list|,
name|vcnt
argument_list|,
name|vcline
argument_list|,
name|cursor
operator|-
name|linebuf
argument_list|,
name|wcursor
operator|-
name|linebuf
argument_list|,
name|wdot
operator|-
name|zero
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TUBELINES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vtube
index|[
name|i
index|]
operator|&&
operator|*
name|vtube
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%d: '%s'\n"
argument_list|,
name|i
argument_list|,
name|vtube
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tvliny
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|vudump
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|p
decl_stmt|;
name|char
name|savelb
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|trace
condition|)
return|return;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n%s: undkind=%d, vundkind=%d, unddel=%d, undap1=%d, undap2=%d,\n"
argument_list|,
name|s
argument_list|,
name|undkind
argument_list|,
name|vundkind
argument_list|,
name|lineno
argument_list|(
name|unddel
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|undap1
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|undap2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"  undadot=%d, dot=%d, dol=%d, unddol=%d, truedol=%d\n"
argument_list|,
name|lineno
argument_list|(
name|undadot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dot
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|dol
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|unddol
argument_list|)
argument_list|,
name|lineno
argument_list|(
name|truedol
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"  [\n"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|savelb
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"linebuf = '%s'\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|zero
operator|+
literal|1
init|;
name|p
operator|<=
name|truedol
condition|;
name|p
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%o "
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"'%s'\n"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|linebuf
argument_list|,
name|savelb
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get a count from the keyed input stream.  * A zero count is indistinguishable from no count.  */
end_comment

begin_macro
name|vgetcnt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|cnt
operator|*=
literal|10
operator|,
name|cnt
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|Xhadcnt
operator|=
literal|1
expr_stmt|;
name|Xcnt
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * fastpeekkey is just like peekkey but insists the character come in  * fast (within 1 second). This will succeed if it is the 2nd char of  * a machine generated sequence (such as a function pad from an escape  * flavor terminal) but fail for a human hitting escape then waiting.  */
end_comment

begin_macro
name|fastpeekkey
argument_list|()
end_macro

begin_block
block|{
name|int
name|trapalarm
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|Oint
function_decl|)
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* 	 * If the user has set notimeout, we wait forever for a key. 	 * If we are in a macro we do too, but since it's already 	 * buffered internally it will return immediately. 	 * In other cases we force this to die in 1 second. 	 * This is pretty reliable (VMUNIX rounds it to .5 - 1.5 secs, 	 * but UNIX truncates it to 0 - 1 secs) but due to system delays 	 * there are times when arrow keys or very fast typing get counted 	 * as separate.  notimeout is provided for people who dislike such 	 * nondeterminism. 	 */
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\nfastpeekkey: "
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Oint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapalarm
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
argument_list|(
name|TIMEOUT
argument_list|)
operator|&&
name|inopen
operator|>=
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|trapalarm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"set alarm "
argument_list|)
expr_stmt|;
else|#
directive|else
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|CATCH
name|c
init|=
name|peekkey
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"[OK]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ONERR
name|c
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"[TIMEOUT]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ENDCATCH
ifdef|#
directive|ifdef
name|MDEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"[fpk:%o]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|Oint
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|trapalarm
argument_list|()
end_macro

begin_block
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcatch
condition|)
name|longjmp
argument_list|(
name|vreslab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

