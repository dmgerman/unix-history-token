begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tracestop.c	5.2 (Berkeley) 4/6/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Handle trace and stop commands.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"tree.rep"
end_include

begin_function_decl
name|LOCAL
name|SYM
modifier|*
name|tcontainer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Process a trace/untrace command, basically checking arguments  * and translate to a call of the appropriate routine.  */
end_comment

begin_macro
name|trace
argument_list|(
argument|cmd
argument_list|,
argument|exp
argument_list|,
argument|where
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|exp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|cond
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|exp
operator|==
name|NIL
condition|)
block|{
name|traceall
argument_list|(
name|cmd
argument_list|,
name|where
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_LCON
operator|||
name|exp
operator|->
name|op
operator|==
name|O_QLINE
condition|)
block|{
name|traceinst
argument_list|(
name|cmd
argument_list|,
name|exp
argument_list|,
name|where
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|!=
name|NIL
operator|&&
operator|(
name|where
operator|->
name|op
operator|==
name|O_QLINE
operator|||
name|where
operator|->
name|op
operator|==
name|O_LCON
operator|)
condition|)
block|{
name|traceat
argument_list|(
name|cmd
argument_list|,
name|exp
argument_list|,
name|where
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tracedata
argument_list|(
name|cmd
argument_list|,
name|exp
argument_list|,
name|where
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|where
operator|!=
name|NIL
condition|)
block|{
name|tfree
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Set a breakpoint that will turn on tracing.  *  * A line number of 0 in the breakpoint information structure  * means it's a normal trace.  *  * A line number of -1 indicates that we want to trace at the instruction  * rather than source line level.  *  * If location is NIL, turn on tracing because if the user  * has the program stopped somewhere and says "trace",  * he/she wants to see tracing after continuing execution.  */
end_comment

begin_function
name|LOCAL
name|traceall
parameter_list|(
name|cmd
parameter_list|,
name|where
parameter_list|,
name|cond
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|NODE
modifier|*
name|where
decl_stmt|;
name|NODE
modifier|*
name|cond
decl_stmt|;
block|{
name|SYM
modifier|*
name|s
decl_stmt|;
name|LINENO
name|line
decl_stmt|;
if|if
condition|(
name|where
operator|!=
name|NIL
operator|&&
name|where
operator|->
name|op
operator|!=
name|O_NAME
condition|)
block|{
name|error
argument_list|(
literal|"bad location for trace"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|O_TRACE
condition|)
block|{
name|line
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|where
operator|==
name|NIL
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|O_TRACE
case|:
if|if
condition|(
name|tracing
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"already tracing lines"
argument_list|)
expr_stmt|;
block|}
name|tracing
operator|++
expr_stmt|;
name|addcond
argument_list|(
name|TRPRINT
argument_list|,
name|cond
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_TRACEI
case|:
if|if
condition|(
name|inst_tracing
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"already tracing instructions"
argument_list|)
expr_stmt|;
block|}
name|inst_tracing
operator|++
expr_stmt|;
name|addcond
argument_list|(
name|TRPRINT
argument_list|,
name|cond
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad cmd in traceall"
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|program
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|->
name|op
operator|!=
name|O_NAME
condition|)
block|{
name|trerror
argument_list|(
literal|"found %t, expected procedure or function"
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|where
operator|->
name|nameval
expr_stmt|;
if|if
condition|(
operator|!
name|isblock
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|name
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|addbp
argument_list|(
name|codeloc
argument_list|(
name|s
argument_list|)
argument_list|,
name|ALL_ON
argument_list|,
name|s
argument_list|,
name|cond
argument_list|,
name|NIL
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the appropriate breakpoint for tracing an instruction.  */
end_comment

begin_function
name|LOCAL
name|traceinst
parameter_list|(
name|cmd
parameter_list|,
name|exp
parameter_list|,
name|where
parameter_list|,
name|cond
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|NODE
modifier|*
name|exp
decl_stmt|;
name|NODE
modifier|*
name|where
decl_stmt|;
name|NODE
modifier|*
name|cond
decl_stmt|;
block|{
name|LINENO
name|line
decl_stmt|;
name|ADDRESS
name|addr
decl_stmt|;
if|if
condition|(
name|where
operator|!=
name|NIL
condition|)
block|{
name|error
argument_list|(
literal|"unexpected \"at\" or \"in\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|O_TRACEI
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_QLINE
condition|)
block|{
name|addr
operator|=
operator|(
name|ADDRESS
operator|)
name|exp
operator|->
name|right
operator|->
name|lconval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_LCON
condition|)
block|{
name|addr
operator|=
operator|(
name|ADDRESS
operator|)
name|exp
operator|->
name|lconval
expr_stmt|;
block|}
else|else
block|{
name|trerror
argument_list|(
literal|"expected integer constant, found %t"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_QLINE
condition|)
block|{
name|line
operator|=
operator|(
name|LINENO
operator|)
name|exp
operator|->
name|right
operator|->
name|lconval
expr_stmt|;
name|addr
operator|=
name|objaddr
argument_list|(
name|line
argument_list|,
name|exp
operator|->
name|left
operator|->
name|sconval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|line
operator|=
operator|(
name|LINENO
operator|)
name|exp
operator|->
name|lconval
expr_stmt|;
name|addr
operator|=
name|objaddr
argument_list|(
name|line
argument_list|,
name|cursource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
operator|(
name|ADDRESS
operator|)
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"can't trace line %d"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|tfree
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|addbp
argument_list|(
name|addr
argument_list|,
name|INST
argument_list|,
name|NIL
argument_list|,
name|cond
argument_list|,
name|NIL
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set a breakpoint to print an expression at a given line or address  */
end_comment

begin_function
name|LOCAL
name|traceat
parameter_list|(
name|cmd
parameter_list|,
name|exp
parameter_list|,
name|where
parameter_list|,
name|cond
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|NODE
modifier|*
name|exp
decl_stmt|;
name|NODE
modifier|*
name|where
decl_stmt|;
name|NODE
modifier|*
name|cond
decl_stmt|;
block|{
name|LINENO
name|line
decl_stmt|;
name|ADDRESS
name|addr
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|O_TRACEI
condition|)
block|{
if|if
condition|(
name|where
operator|->
name|op
operator|!=
name|O_LCON
condition|)
block|{
name|trerror
argument_list|(
literal|"expected integer constant, found %t"
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
operator|-
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|ADDRESS
operator|)
name|where
operator|->
name|lconval
expr_stmt|;
block|}
else|else
block|{
name|line
operator|=
operator|(
name|LINENO
operator|)
name|where
operator|->
name|right
operator|->
name|lconval
expr_stmt|;
name|addr
operator|=
name|objaddr
argument_list|(
name|line
argument_list|,
name|where
operator|->
name|left
operator|->
name|sconval
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|ADDRESS
operator|)
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"can't trace at line %d"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|addbp
argument_list|(
name|addr
argument_list|,
name|AT_BP
argument_list|,
name|NIL
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up breakpoint for tracing data.  *  * The tracing of blocks lies somewhere between instruction and data;  * it's here since a block cannot be distinguished from other terms.  *  * As in "traceall", if the "block" is the main program then the  * user didn't actually specify a block.  This means we want to  * turn tracing on ourselves because if the program is stopped  * we want to be on regardless of whether they say "cont" or "run".  */
end_comment

begin_function
name|LOCAL
name|tracedata
parameter_list|(
name|cmd
parameter_list|,
name|exp
parameter_list|,
name|block
parameter_list|,
name|cond
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|NODE
modifier|*
name|exp
decl_stmt|;
name|NODE
modifier|*
name|block
decl_stmt|;
name|NODE
modifier|*
name|cond
decl_stmt|;
block|{
name|SYM
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|cmd
operator|=
name|cmd
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
operator|&&
name|exp
operator|->
name|op
operator|!=
name|O_CALL
condition|)
block|{
name|error
argument_list|(
literal|"can't trace expressions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|==
name|NIL
condition|)
block|{
name|t
operator|=
name|tcontainer
argument_list|(
name|exp
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
operator|->
name|op
operator|==
name|O_NAME
condition|)
block|{
name|t
operator|=
name|block
operator|->
name|nameval
expr_stmt|;
block|}
else|else
block|{
name|trerror
argument_list|(
literal|"found %t, expected procedure or function"
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|left
operator|->
name|op
operator|==
name|O_NAME
condition|)
block|{
name|s
operator|=
name|exp
operator|->
name|left
operator|->
name|nameval
expr_stmt|;
if|if
condition|(
name|isblock
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addbp
argument_list|(
name|codeloc
argument_list|(
name|t
argument_list|)
argument_list|,
name|BLOCK_ON
argument_list|,
name|t
argument_list|,
name|cond
argument_list|,
name|exp
operator|->
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|program
condition|)
block|{
name|addbp
argument_list|(
name|codeloc
argument_list|(
name|s
argument_list|)
argument_list|,
name|CALL
argument_list|,
name|s
argument_list|,
name|cond
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|addbp
argument_list|(
name|codeloc
argument_list|(
name|t
argument_list|)
argument_list|,
name|TERM_ON
argument_list|,
name|t
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfunc
operator|==
name|t
condition|)
block|{
name|var_tracing
operator|++
expr_stmt|;
name|addvar
argument_list|(
name|TRPRINT
argument_list|,
name|exp
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|addbp
argument_list|(
name|return_addr
argument_list|()
argument_list|,
name|TERM_OFF
argument_list|,
name|t
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setting and unsetting of stops.  */
end_comment

begin_macro
name|stop
argument_list|(
argument|cmd
argument_list|,
argument|exp
argument_list|,
argument|where
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|exp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|cond
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SYM
modifier|*
name|s
decl_stmt|;
name|LINENO
name|n
decl_stmt|;
if|if
condition|(
name|exp
operator|!=
name|NIL
condition|)
block|{
name|stopvar
argument_list|(
name|cmd
argument_list|,
name|exp
argument_list|,
name|where
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cond
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|where
operator|==
name|NIL
condition|)
block|{
name|s
operator|=
name|program
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|->
name|op
operator|==
name|O_NAME
condition|)
block|{
name|s
operator|=
name|where
operator|->
name|nameval
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"bad location for stop"
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|codeloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|addbp
argument_list|(
name|n
argument_list|,
name|STOP_ON
argument_list|,
name|s
argument_list|,
name|cond
argument_list|,
name|NIL
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|addcond
argument_list|(
name|TRSTOP
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|var_tracing
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|->
name|op
operator|==
name|O_NAME
condition|)
block|{
name|s
operator|=
name|where
operator|->
name|nameval
expr_stmt|;
if|if
condition|(
operator|!
name|isblock
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|name
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|codeloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|addbp
argument_list|(
name|n
argument_list|,
name|STOP_BP
argument_list|,
name|s
argument_list|,
name|cond
argument_list|,
name|NIL
argument_list|,
name|srcline
argument_list|(
name|firstline
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stopinst
argument_list|(
name|cmd
argument_list|,
name|where
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|where
operator|!=
name|NIL
condition|)
block|{
name|tfree
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|stopinst
parameter_list|(
name|cmd
parameter_list|,
name|where
parameter_list|,
name|cond
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|NODE
modifier|*
name|where
decl_stmt|;
name|NODE
modifier|*
name|cond
decl_stmt|;
block|{
name|LINENO
name|line
decl_stmt|;
name|ADDRESS
name|addr
decl_stmt|;
if|if
condition|(
name|where
operator|->
name|op
operator|!=
name|O_QLINE
condition|)
block|{
name|error
argument_list|(
literal|"expected line number"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|O_STOP
condition|)
block|{
name|line
operator|=
operator|(
name|LINENO
operator|)
name|where
operator|->
name|right
operator|->
name|lconval
expr_stmt|;
name|addr
operator|=
name|objaddr
argument_list|(
name|line
argument_list|,
name|where
operator|->
name|left
operator|->
name|sconval
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|ADDRESS
operator|)
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"can't stop at that line"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|line
operator|=
operator|-
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|ADDRESS
operator|)
name|where
operator|->
name|right
operator|->
name|lconval
expr_stmt|;
block|}
name|addbp
argument_list|(
name|addr
argument_list|,
name|STOP_BP
argument_list|,
name|NIL
argument_list|,
name|cond
argument_list|,
name|NIL
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement stopping on assignment to a variable by adding it to  * the variable list.  */
end_comment

begin_function
name|LOCAL
name|stopvar
parameter_list|(
name|cmd
parameter_list|,
name|exp
parameter_list|,
name|where
parameter_list|,
name|cond
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|NODE
modifier|*
name|exp
decl_stmt|;
name|NODE
modifier|*
name|where
decl_stmt|;
name|NODE
modifier|*
name|cond
decl_stmt|;
block|{
name|SYM
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
condition|)
block|{
name|trerror
argument_list|(
literal|"found %t, expected variable"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|O_STOPI
condition|)
block|{
name|inst_tracing
operator|++
expr_stmt|;
block|}
name|var_tracing
operator|++
expr_stmt|;
name|addvar
argument_list|(
name|TRSTOP
argument_list|,
name|exp
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|NIL
condition|)
block|{
name|s
operator|=
name|program
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|->
name|op
operator|==
name|O_NAME
condition|)
block|{
name|s
operator|=
name|where
operator|->
name|nameval
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"bad location for stop"
argument_list|)
expr_stmt|;
block|}
name|addbp
argument_list|(
name|codeloc
argument_list|(
name|s
argument_list|)
argument_list|,
name|STOP_ON
argument_list|,
name|s
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out the block that contains the symbols  * in the given variable expression.  */
end_comment

begin_function
name|LOCAL
name|SYM
modifier|*
name|tcontainer
parameter_list|(
name|var
parameter_list|)
name|NODE
modifier|*
name|var
decl_stmt|;
block|{
name|NODE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|var
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|op
operator|!=
name|O_NAME
condition|)
block|{
if|if
condition|(
name|isleaf
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"unexpected op %d in tcontainer"
argument_list|,
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
return|return
name|container
argument_list|(
name|p
operator|->
name|nameval
argument_list|)
return|;
block|}
end_function

end_unit

