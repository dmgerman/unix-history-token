begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sconv.c	5.2 (Berkeley) 11/12/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*      *	functions to help pi put out      *	polish postfix binary portable c compiler intermediate code      *	thereby becoming the portable pascal compiler      */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|<pcc.h>
end_include

begin_comment
comment|/*      *	this routine enforces ``the usual arithmetic conversions''      *	all integral operands are converted to ints.      *	if either operand is a double, both are made to be double.      *	this routine takes struct nl *'s for the types,      *	and returns both the struct nl * and the p2type for the result.      */
end_comment

begin_macro
name|tuac
argument_list|(
argument|thistype
argument_list|,
argument|thattype
argument_list|,
argument|resulttypep
argument_list|,
argument|resultp2typep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|thistype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|thattype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
modifier|*
name|resulttypep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|resultp2typep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|thisp2type
init|=
name|p2type
argument_list|(
name|thistype
argument_list|)
decl_stmt|;
name|int
name|thatp2type
init|=
name|p2type
argument_list|(
name|thattype
argument_list|)
decl_stmt|;
operator|*
name|resulttypep
operator|=
name|thistype
expr_stmt|;
operator|*
name|resultp2typep
operator|=
name|thisp2type
expr_stmt|;
comment|/* 	 *	should only be passed scalars 	 */
if|if
condition|(
name|isnta
argument_list|(
name|thistype
argument_list|,
literal|"sbcid"
argument_list|)
operator|||
name|isnta
argument_list|(
name|thattype
argument_list|,
literal|"sbcid"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|thisp2type
operator|==
name|PCCT_CHAR
operator|||
name|thisp2type
operator|==
name|PCCT_SHORT
condition|)
block|{
operator|*
name|resultp2typep
operator|=
name|PCCT_INT
expr_stmt|;
operator|*
name|resulttypep
operator|=
name|nl
operator|+
name|T4INT
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|resultp2typep
operator|==
name|PCCT_INT
operator|&&
name|thatp2type
operator|==
name|PCCT_DOUBLE
condition|)
block|{
operator|*
name|resultp2typep
operator|=
name|PCCT_DOUBLE
expr_stmt|;
operator|*
name|resulttypep
operator|=
name|nl
operator|+
name|TDOUBLE
expr_stmt|;
block|}
name|sconv
argument_list|(
name|thisp2type
argument_list|,
operator|*
name|resultp2typep
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	this routine will emit sconv operators when it thinks they are needed.      *	this is code generator specific, rather than machine-specific.      *	this routine takes p2types for arguments, not struct nl *'s.      */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_comment
comment|/*      *	the vax code genrator is very good, this routine is extremely boring.      */
end_comment

begin_macro
name|sconv
argument_list|(
argument|fromp2type
argument_list|,
argument|top2type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fromp2type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top2type
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|top2type
condition|)
block|{
case|case
name|PCCT_CHAR
case|:
case|case
name|PCCT_SHORT
case|:
case|case
name|PCCT_INT
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|PCCT_CHAR
case|:
case|case
name|PCCT_SHORT
case|:
case|case
name|PCCT_INT
case|:
case|case
name|PCCT_DOUBLE
case|:
return|return;
comment|/* pass1 knows how to do these */
default|default:
return|return;
block|}
case|case
name|PCCT_DOUBLE
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|PCCT_CHAR
case|:
case|case
name|PCCT_SHORT
case|:
case|case
name|PCCT_INT
case|:
name|putop
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_DOUBLE
argument_list|)
expr_stmt|;
return|return;
case|case
name|PCCT_DOUBLE
case|:
return|return;
default|default:
return|return;
block|}
default|default:
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|vax || tahoe
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|mc68000
end_ifdef

begin_comment
comment|/*      *	i don't know how much to trust the mc68000 compiler,      *	so this routine is full.      */
end_comment

begin_macro
name|sconv
argument_list|(
argument|fromp2type
argument_list|,
argument|top2type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fromp2type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top2type
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|top2type
condition|)
block|{
case|case
name|PCCT_CHAR
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|PCCT_CHAR
case|:
return|return;
case|case
name|PCCT_SHORT
case|:
case|case
name|PCCT_INT
case|:
case|case
name|PCCT_DOUBLE
case|:
name|putop
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_CHAR
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
case|case
name|PCCT_SHORT
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|PCCT_SHORT
case|:
return|return;
case|case
name|PCCT_CHAR
case|:
case|case
name|PCCT_INT
case|:
case|case
name|PCCT_DOUBLE
case|:
name|putop
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_SHORT
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
case|case
name|PCCT_INT
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|PCCT_INT
case|:
return|return;
case|case
name|PCCT_CHAR
case|:
case|case
name|PCCT_SHORT
case|:
case|case
name|PCCT_DOUBLE
case|:
name|putop
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
case|case
name|PCCT_DOUBLE
case|:
switch|switch
condition|(
name|fromp2type
condition|)
block|{
case|case
name|PCCT_DOUBLE
case|:
return|return;
case|case
name|PCCT_CHAR
case|:
case|case
name|PCCT_SHORT
case|:
case|case
name|PCCT_INT
case|:
name|putop
argument_list|(
name|PCC_SCONV
argument_list|,
name|PCCT_DOUBLE
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
default|default:
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|mc68000
end_endif

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

