begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)yyrecover.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree_ty.h"
end_include

begin_comment
comment|/* must be included for yy.h */
end_comment

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_comment
comment|/*  * Very simplified version of Graham-Rhodes error recovery  * method for LALR parsers.  Backward move is embodied in  * default reductions of the yacc parser until an error condition  * is reached.  Forward move is over a small number of input tokens  * and cannot "condense".  The basic corrections are:  *  *	1) Delete the input token.  *  *	2) Replace the current input with a legal input.  *  *	3) Insert a legal token.  *  * All corrections are weighted, considered only if they allow  * at least two shifts, and the cost of a correction increases if  * it allows shifting over only a part of the lookahead.  *  * Another error situation is that which occurs when an identifier "fails"  * a reduction because it is not the required "class".  * In this case, we also consider replacing this identifier, which has  * already been shifted over, with an identifier of the correct class.  *  * Another correction performed here is unique symbol insertion.  * If the current state admits only one input, and no other alternative  * correction presents itself, then that symbol will be inserted.  * There is a danger in this of looping, and it is handled  * by counting true shifts over input (see below).  *  *  * A final class of corrections, considered only when the error  * occurred immediately after a shift over a terminal, involves  * the three basic corrections above, but with the point of error  * considered to be before this terminal was shifted over, effectively  * "unreading" this terminal.  This is a feeble attempt at elimination  * of the left-right bias and because "if" has a low weight and some  * statements are quite simple i.e.  *  *	cse ch of ...  *  * we can get a small number of errors.  The major deficiency of  * this is that we back up only one token, and that the forward  * move is over a small number of tokens, often not enough to really  * tell what the input should be, e.g. in  *  *	a[i]> a[i - 1] ...  *  * In such cases a bad identifier (misspelled keyword) or omitted  * keyword will be change or inserted as "if" as it has the lowest cost.  * This is not terribly bad, as "if"s are most common.  * This also allows the correction of other errors.  *  * This recovery depends on the default reductions which delay  * noticing the error until the parse reaches a state where the  * relevant "alternatives" are visible.  Note that it does not  * consider tokens which will cause reductions before being  * shifted over.  This requires the grammar to be written in a  * certain way for the recovery to work correctly.  * In some sense, also, the recovery suffers because we have  * LALR(1) tables rather than LR(1) tables, e.g. in  *  *	if rec.field< rec2,field2 then  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Definitions of possible corrective actions  */
end_comment

begin_define
define|#
directive|define
name|CPANIC
value|0
end_define

begin_define
define|#
directive|define
name|CDELETE
value|1
end_define

begin_define
define|#
directive|define
name|CREPLACE
value|2
end_define

begin_define
define|#
directive|define
name|CINSERT
value|3
end_define

begin_define
define|#
directive|define
name|CUNIQUE
value|4
end_define

begin_define
define|#
directive|define
name|CCHIDENT
value|5
end_define

begin_comment
comment|/*  * Multiplicative cost factors for corrective actions.  *  * When an error occurs we take YCSIZ - 1 look-ahead tokens.  * If a correction being considered will shift over only part of  * that look-ahead, it is not completely discarded, but rather  * "weighted", its cost being multiplied by a weighting factor.  * For a correction to be considered its weighted cost must be less  * than CLIMIT.  *  * Non-weighted costs are considered:  *  *	LOW<= 3  *	MEDIUM	4,5  *	HIGH>= 6  *  * CURRENT WEIGHTING STRATEGY: Aug 20, 1977  *  * For all kinds of corrections we demand shifts over two symbols.  * Corrections have high weight even after two symbol  * shifts because the costs for deleting and inserting symbols are actually  * quite low; we do not want to change weighty symbols   * on inconclusive evidence.  *  * The weights are the same after the third look ahead.  * This prevents later, unrelated errors from causing "funny"  * biases of the weights toward one type of correction.  *  * Current look ahead is 5 symbols.  */
end_comment

begin_comment
comment|/*** CLIMIT is defined in yy.h for yycosts ***/
end_comment

begin_define
define|#
directive|define
name|CPRLIMIT
value|50
end_define

begin_define
define|#
directive|define
name|CCHIDCOST
value|3
end_define

begin_decl_stmt
name|char
name|insmult
index|[
literal|8
index|]
init|=
block|{
name|INFINITY
block|,
name|INFINITY
block|,
name|INFINITY
block|,
literal|15
block|,
literal|8
block|,
literal|6
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|repmult
index|[
literal|7
index|]
init|=
block|{
name|INFINITY
block|,
name|INFINITY
block|,
name|INFINITY
block|,
literal|8
block|,
literal|6
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|delmult
index|[
literal|6
index|]
init|=
block|{
name|INFINITY
block|,
name|INFINITY
block|,
name|INFINITY
block|,
literal|6
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|NOCHAR
value|-1
end_define

begin_define
define|#
directive|define
name|Eprintf
value|if (errtrace) printf
end_define

begin_define
define|#
directive|define
name|Tprintf
value|if (testtrace) printf
end_define

begin_comment
comment|/*  * Action arrays of the parser needed here  */
end_comment

begin_decl_stmt
name|union
name|semstack
modifier|*
name|yypv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyact
index|[]
decl_stmt|,
name|yypact
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Yytips is the tip of the stack when using  * the function loccor to check for local  * syntactic correctness. As we don't want  * to copy the whole parser stack, but want  * to simulate parser moves, we "split"  * the parser stack and keep the tip here.  */
end_comment

begin_define
define|#
directive|define
name|YYTIPSIZ
value|16
end_define

begin_decl_stmt
name|int
name|yytips
index|[
name|YYTIPSIZ
index|]
decl_stmt|,
name|yytipct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yytipv
index|[
name|YYTIPSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The array YC saves the lookahead tokens for the  * forward moves.  * Yccnt is the number of tokens in the YC array.  */
end_comment

begin_define
define|#
directive|define
name|YCSIZ
value|6
end_define

begin_decl_stmt
name|int
name|yCcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yytok
name|YC0
index|[
name|YCSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yytok
modifier|*
name|YC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * YCps gives the top of stack at  * the point of error.  */
end_comment

begin_decl_stmt
name|bool
name|yyunique
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|unsigned
name|yyTshifts
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Cact is the corrective action we have decided on  * so far, ccost its cost, and cchar the associated token.  * Cflag tells if the correction is over the previous input token.  */
end_comment

begin_decl_stmt
name|int
name|cact
decl_stmt|,
name|ccost
decl_stmt|,
name|cchar
decl_stmt|,
name|cflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ACtok holds the token under  * consideration when examining  * the lookaheads in a state.  */
end_comment

begin_decl_stmt
name|struct
name|yytok
name|ACtok
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|acchar
value|ACtok.Yychar
end_define

begin_define
define|#
directive|define
name|aclval
value|ACtok.Yylval
end_define

begin_comment
comment|/*  * Make a correction to the current stack which has  * top of stack pointer Ps.  */
end_comment

begin_macro
name|yyrecover
argument_list|(
argument|Ps0
argument_list|,
argument|idfail
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|Ps0
decl_stmt|,
name|idfail
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|yyrwant
decl_stmt|,
name|yyrhave
decl_stmt|;
ifdef|#
directive|ifdef
name|PI
name|Recovery
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|YC
operator|=
operator|&
name|YC0
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|errtrace
condition|)
block|{
name|setpfx
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|yerror
argument_list|(
literal|"Point of error"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"States %d %d ..."
argument_list|,
name|Ps0
index|[
literal|0
index|]
argument_list|,
name|Ps0
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idfail
condition|)
name|printf
argument_list|(
literal|" [Idfail]"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PXP
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|#
directive|else
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Input %s%s"
argument_list|,
name|tokname
argument_list|(
operator|&
name|Y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|Y
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * We first save the current input token 	 * and its associated semantic information. 	 */
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
sizeof|sizeof
name|Y
argument_list|)
expr_stmt|;
comment|/* 	 * Set the default action and cost 	 */
name|cact
operator|=
name|CPANIC
operator|,
name|ccost
operator|=
name|CLIMIT
operator|,
name|cflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Peek ahead 	 */
for|for
control|(
name|yCcnt
operator|=
literal|1
init|;
name|yCcnt
operator|<
name|YCSIZ
condition|;
name|yCcnt
operator|++
control|)
block|{
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
name|yCcnt
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
sizeof|sizeof
name|YC
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Eprintf
argument_list|(
literal|" | %s%s"
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
name|yCcnt
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
name|yCcnt
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|Eprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we are here because a reduction failed, try 	 * correcting that. 	 */
if|if
condition|(
name|idfail
condition|)
block|{
comment|/* 		 * Save the particulars about 		 * the kind of identifier we want/have. 		 */
name|yyrwant
operator|=
name|yyidwant
expr_stmt|;
name|yyrhave
operator|=
name|yyidhave
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"  Try Replace %s identifier with %s identifier cost=%d\n"
argument_list|,
name|classes
index|[
name|yyidhave
index|]
argument_list|,
name|classes
index|[
name|yyidwant
index|]
argument_list|,
name|CCHIDCOST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Save the semantics of the ID on the 		 * stack, and null them out to free 		 * up the reduction in question. 		 */
name|i
operator|=
name|yypv
index|[
literal|0
index|]
operator|.
name|i_entry
expr_stmt|;
name|yypv
index|[
literal|0
index|]
operator|.
name|i_entry
operator|=
name|nullsem
argument_list|(
name|YID
argument_list|)
expr_stmt|;
name|c
operator|=
name|correct
argument_list|(
name|NOCHAR
argument_list|,
literal|0
argument_list|,
name|CCHIDCOST
argument_list|,
operator|&
name|repmult
index|[
literal|2
index|]
argument_list|,
name|Ps0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|yypv
argument_list|)
expr_stmt|;
name|yypv
index|[
literal|0
index|]
operator|.
name|i_entry
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|CPRLIMIT
operator|||
name|fulltrace
condition|)
name|Eprintf
argument_list|(
literal|"Cost %2d Replace %s identifier with %s identifier\n"
argument_list|,
name|c
argument_list|,
name|classes
index|[
name|yyrhave
index|]
argument_list|,
name|classes
index|[
name|yyrwant
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
name|cact
operator|=
name|CCHIDENT
operator|,
name|ccost
operator|=
name|c
operator|,
name|cchar
operator|=
name|YID
expr_stmt|;
block|}
comment|/* 	 * First try correcting the state we are in 	 */
name|trystate
argument_list|(
name|Ps0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|yypv
argument_list|,
literal|0
argument_list|,
operator|&
name|insmult
index|[
literal|1
index|]
argument_list|,
operator|&
name|delmult
index|[
literal|1
index|]
argument_list|,
operator|&
name|repmult
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Now, if we just shifted over a terminal, try 	 * correcting it. 	 */
if|if
condition|(
name|OY
operator|.
name|Yychar
operator|!=
operator|-
literal|1
operator|&&
name|OY
operator|.
name|Yylval
operator|!=
name|nullsem
argument_list|(
name|OY
operator|.
name|Yychar
argument_list|)
condition|)
block|{
name|YC
operator|--
expr_stmt|;
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|OY
operator|)
argument_list|,
sizeof|sizeof
name|YC
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|trystate
argument_list|(
name|Ps0
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
name|yypv
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
name|insmult
argument_list|,
name|delmult
argument_list|,
name|repmult
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
name|YC
operator|++
expr_stmt|;
else|else
block|{
name|yypv
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|PXP
name|yypw
operator|--
expr_stmt|;
endif|#
directive|endif
name|Ps0
operator|--
expr_stmt|;
name|yCcnt
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Restoring the first look ahead into 	 * the scanner token allows the error message 	 * routine to print the error message with the text 	 * of the correct line. 	 */
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
name|Y
argument_list|)
expr_stmt|;
comment|/* 	 * Unique symbol insertion. 	 * 	 * If there was no reasonable correction found, 	 * but only one input to the parser is acceptable 	 * we report that, and try it. 	 * 	 * Special precautions here to prevent looping. 	 * The number of true inputs shifted over at the point 	 * of the last unique insertion is recorded in the 	 * variable yyTshifts.  If this is not less than 	 * the current number in yytshifts, we do not insert. 	 * Thus, after one unique insertion, no more unique 	 * insertions will be made until an input is shifted 	 * over.  This guarantees termination. 	 */
if|if
condition|(
name|cact
operator|==
name|CPANIC
operator|&&
operator|!
name|idfail
condition|)
block|{
specifier|register
name|int
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
operator|&
name|yyact
index|[
name|yypact
index|[
operator|*
name|Ps0
operator|+
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
operator|-
name|ERROR
condition|)
name|ap
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|<=
literal|0
operator|&&
name|ap
index|[
literal|2
index|]
operator|>
literal|0
condition|)
block|{
name|cchar
operator|=
operator|-
name|ap
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cchar
operator|==
name|YEOF
condition|)
name|yyexeof
argument_list|()
expr_stmt|;
if|if
condition|(
name|cchar
operator|!=
name|ERROR
operator|&&
name|yyTshifts
operator|<
name|yytshifts
condition|)
block|{
name|cact
operator|=
name|CUNIQUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Eprintf
argument_list|(
literal|"Unique symbol %s%s\n"
argument_list|,
name|charname
argument_list|(
name|cchar
argument_list|,
literal|0
argument_list|)
argument_list|,
name|charname
argument_list|(
name|cchar
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Note that the inserted symbol 				 * will not be counted as a true input 				 * (i.e. the "yytshifts--" below) 				 * so that a true shift will be needed 				 * to make yytshifts> yyTshifts. 				 */
name|yyTshifts
operator|=
name|yytshifts
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Set up to perform the correction. 	 * Build a token appropriate for replacement 	 * or insertion in the yytok structure ACchar 	 * having the attributes of the input at the 	 * point of error. 	 */
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ACtok
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
name|ACtok
argument_list|)
expr_stmt|;
name|acchar
operator|=
name|cchar
expr_stmt|;
name|aclval
operator|=
name|nullsem
argument_list|(
name|acchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclval
operator|!=
name|NIL
condition|)
name|recovered
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cact
condition|)
block|{
comment|/* 		 * Panic, just restore the 		 * lookahead and return. 		 */
case|case
name|CPANIC
case|:
name|setpfx
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|idfail
condition|)
block|{
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|OY
operator|)
argument_list|,
sizeof|sizeof
name|Y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyrhave
operator|==
name|NIL
condition|)
block|{
ifdef|#
directive|ifdef
name|PI
if|if
condition|(
name|yybaduse
argument_list|(
name|yypv
index|[
literal|0
index|]
operator|.
name|cptr
argument_list|,
name|yyeline
argument_list|,
name|ISUNDEF
argument_list|)
operator|==
name|NIL
condition|)
endif|#
directive|endif
name|yerror
argument_list|(
literal|"Undefined identifier"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yerror
argument_list|(
literal|"Improper %s identifier"
argument_list|,
name|classes
index|[
name|yyrhave
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI
operator|(
name|void
operator|)
name|yybaduse
argument_list|(
name|yypv
index|[
literal|0
index|]
operator|.
name|cptr
argument_list|,
name|yyeline
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 				 * Suppress message from panic routine 				 */
name|yyshifts
operator|=
literal|1
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Note that on one path we dont touch yyshifts ! */
break|break;
comment|/* 		 * Delete the input. 		 * Mark this as a shift over true input. 		 * Restore the lookahead starting at 		 * the second token. 		 */
case|case
name|CDELETE
case|:
if|if
condition|(
name|ccost
operator|!=
literal|0
condition|)
name|yerror
argument_list|(
literal|"Deleted %s%s"
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|yytshifts
operator|++
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|yyshifts
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * Replace the input with a new token. 		 */
case|case
name|CREPLACE
case|:
if|if
condition|(
name|acchar
operator|==
name|YEOF
condition|)
name|yyexeof
argument_list|()
expr_stmt|;
if|if
condition|(
name|acchar
operator|==
name|YEND
condition|)
name|aclval
operator|=
name|NIL
expr_stmt|;
name|yerror
argument_list|(
literal|"Replaced %s%s with a %s%s"
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ACtok
operator|)
argument_list|,
sizeof|sizeof
name|YC
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|yyshifts
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * Insert a token. 		 * Don't count this token as a true input shift. 		 * For inserted "end"s pas.y is responsible 		 * for the error message later so suppress it. 		 * Restore all the lookahead. 		 */
case|case
name|CINSERT
case|:
if|if
condition|(
name|acchar
operator|==
name|YEOF
condition|)
name|yyexeof
argument_list|()
expr_stmt|;
if|if
condition|(
name|acchar
operator|!=
name|YEND
condition|)
name|yerror
argument_list|(
literal|"Inserted %s%s"
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|yytshifts
operator|--
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|yyshifts
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * Make a unique symbol correction. 		 * Like an insertion but a different message. 		 */
case|case
name|CUNIQUE
case|:
name|setpfx
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|yerror
argument_list|(
literal|"Expected %s%s"
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|yytshifts
operator|--
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccost
operator|==
literal|0
operator|||
name|yyunique
condition|)
name|yyshifts
operator|=
literal|0
expr_stmt|;
else|else
name|yyshifts
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* 		 * Change an identifier's type 		 * to make it work. 		 */
case|case
name|CCHIDENT
case|:
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|OY
operator|)
argument_list|,
sizeof|sizeof
name|Y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI
name|i
operator|=
literal|1
operator|<<
name|yyrwant
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyrhave
operator|==
name|NIL
condition|)
block|{
name|yerror
argument_list|(
literal|"Undefined %s"
argument_list|,
name|classes
index|[
name|yyrwant
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI
name|i
operator||=
name|ISUNDEF
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|yerror
argument_list|(
literal|"Replaced %s id with a %s id"
argument_list|,
name|classes
index|[
name|yyrhave
index|]
argument_list|,
name|classes
index|[
name|yyrwant
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI
operator|(
name|void
operator|)
name|yybaduse
argument_list|(
name|yypv
index|[
literal|0
index|]
operator|.
name|cptr
argument_list|,
name|yyeline
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yypv
index|[
literal|0
index|]
operator|.
name|i_entry
operator|=
name|nullsem
argument_list|(
name|YID
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|yyshifts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * Restore the desired portion of the lookahead, 	 * and possibly the inserted or unique inserted token. 	 */
for|for
control|(
name|yCcnt
operator|--
init|;
name|yCcnt
operator|>=
name|i
condition|;
name|yCcnt
operator|--
control|)
name|unyylex
argument_list|(
operator|&
name|YC
index|[
name|yCcnt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cact
operator|==
name|CINSERT
operator|||
name|cact
operator|==
name|CUNIQUE
condition|)
name|unyylex
argument_list|(
operator|&
name|ACtok
argument_list|)
expr_stmt|;
comment|/* 	 * Put the scanner back in sync. 	 */
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
comment|/* 	 * We succeeded if we didn't "panic". 	 */
name|Recovery
operator|=
name|FALSE
expr_stmt|;
name|Ps
operator|=
name|Ps0
expr_stmt|;
return|return
operator|(
name|cact
operator|!=
name|CPANIC
operator|)
return|;
block|}
end_block

begin_macro
name|yyexeof
argument_list|()
end_macro

begin_block
block|{
name|yerror
argument_list|(
literal|"End-of-file expected - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|ERRS
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yyunexeof
argument_list|()
end_macro

begin_block
block|{
name|yerror
argument_list|(
literal|"Unexpected end-of-file - QUIT"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|ERRS
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Try corrections with the state at Ps0.  * Flag is 0 if this is the top of stack state,  * 1 if it is the state below.  */
end_comment

begin_macro
name|trystate
argument_list|(
argument|Ps0
argument_list|,
argument|Pv0
argument_list|,
argument|flag
argument_list|,
argument|insmult
argument_list|,
argument|delmult
argument_list|,
argument|repmult
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|Ps0
decl_stmt|,
modifier|*
name|Pv0
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|insmult
decl_stmt|,
modifier|*
name|delmult
decl_stmt|,
modifier|*
name|repmult
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * C is a working cost, ap a pointer into the action 	 * table for looking at feasible alternatives. 	 */
specifier|register
name|int
name|c
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Eprintf
argument_list|(
literal|"Trying state %d\n"
argument_list|,
operator|*
name|Ps0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Try deletion. 	 * Correct returns a cost. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"  Try Delete %s%s cost=%d\n"
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
name|delcost
argument_list|(
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|delcost
argument_list|(
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
block|{
endif|#
directive|endif
name|c
operator|=
name|correct
argument_list|(
name|NOCHAR
argument_list|,
literal|1
argument_list|,
name|c
argument_list|,
name|delmult
argument_list|,
name|Ps0
argument_list|,
name|Pv0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|CPRLIMIT
operator|||
name|fulltrace
condition|)
name|Eprintf
argument_list|(
literal|"Cost %2d Delete %s%s\n"
argument_list|,
name|c
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
name|cact
operator|=
name|CDELETE
operator|,
name|ccost
operator|=
name|c
operator|,
name|cflag
operator|=
name|flag
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
block|}
endif|#
directive|endif
comment|/* 	 * Look at the inputs to this state 	 * which will cause parse action shift. 	 */
name|aclval
operator|=
name|NIL
expr_stmt|;
name|ap
operator|=
operator|&
name|yyact
index|[
name|yypact
index|[
operator|*
name|Ps0
operator|+
literal|1
index|]
index|]
expr_stmt|;
comment|/* 	 * Skip action on error to 	 * detect true unique inputs. 	 * Error action is always first. 	 */
if|if
condition|(
operator|*
name|ap
operator|==
operator|-
name|ERROR
condition|)
name|ap
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * Loop through the test actions 	 * for this state. 	 */
for|for
control|(
init|;
operator|*
name|ap
operator|<=
literal|0
condition|;
name|ap
operator|+=
literal|2
control|)
block|{
comment|/* 		 * Extract the token of this action 		 */
name|acchar
operator|=
operator|-
operator|*
name|ap
expr_stmt|;
comment|/* 		 * Try insertion 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"  Try Insert %s%s cost=%d\n"
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|0
argument_list|)
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|1
argument_list|)
argument_list|,
name|inscost
argument_list|(
name|acchar
argument_list|,
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|inscost
argument_list|(
name|acchar
argument_list|,
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|correct
argument_list|(
name|acchar
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|insmult
operator|+
literal|1
argument_list|,
name|Ps0
argument_list|,
name|Pv0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Eprintf
argument_list|(
literal|"Cost %2d Freebie %s%s\n"
argument_list|,
name|c
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|0
argument_list|)
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
name|cact
operator|=
name|CUNIQUE
operator|,
name|ccost
operator|=
literal|0
operator|,
name|cchar
operator|=
name|acchar
operator|,
name|cflag
operator|=
name|flag
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|correct
argument_list|(
name|acchar
argument_list|,
literal|0
argument_list|,
name|c
argument_list|,
name|insmult
argument_list|,
name|Ps0
argument_list|,
name|Pv0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|CPRLIMIT
operator|||
name|fulltrace
condition|)
name|Eprintf
argument_list|(
literal|"Cost %2d Insert %s%s\n"
argument_list|,
name|c
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|0
argument_list|)
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
name|cact
operator|=
name|CINSERT
operator|,
name|ccost
operator|=
name|c
operator|,
name|cchar
operator|=
name|acchar
operator|,
name|cflag
operator|=
name|flag
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
block|}
endif|#
directive|endif
comment|/* 		 * Try replacement 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"  Try Replace %s%s with %s%s cost=%d\n"
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|0
argument_list|)
argument_list|,
name|charname
argument_list|(
name|acchar
argument_list|,
literal|1
argument_list|)
argument_list|,
name|repcost
argument_list|(
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|,
name|acchar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|repcost
argument_list|(
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|,
name|acchar
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
block|{
endif|#
directive|endif
name|c
operator|=
name|correct
argument_list|(
name|acchar
argument_list|,
literal|1
argument_list|,
name|repcost
argument_list|(
name|YC
index|[
literal|0
index|]
operator|.
name|Yychar
argument_list|,
name|acchar
argument_list|)
argument_list|,
name|repmult
argument_list|,
name|Ps0
argument_list|,
name|Pv0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|<
name|CPRLIMIT
operator|||
name|fulltrace
condition|)
name|Eprintf
argument_list|(
literal|"Cost %2d Replace %s%s with %s%s\n"
argument_list|,
name|c
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|YC
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tokname
argument_list|(
operator|&
name|ACtok
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|<
name|ccost
condition|)
name|cact
operator|=
name|CREPLACE
operator|,
name|ccost
operator|=
name|c
operator|,
name|cchar
operator|=
name|acchar
operator|,
name|cflag
operator|=
name|flag
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
block|}
endif|#
directive|endif
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|int
modifier|*
name|yCpv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|yyredfail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The ntok structure is used to build a  * scanner structure for tokens inserted  * from the argument "fchar" to "correct" below.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|yytok
name|ntok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compute the cost of a correction  * C is the base cost for it.  * Fchar is the first input character from  * the current state, NOCHAR if none.  * The rest of the inputs come from the array  * YC, starting at origin and continuing to the  * last character there, YC[yCcnt - 1].Yychar.  *  * The cost returned is INFINITE if this correction  * allows no shifts, otherwise is weighted based  * on the number of shifts this allows against the  * maximum number possible with the available lookahead.  */
end_comment

begin_expr_stmt
name|correct
argument_list|(
name|fchar
argument_list|,
name|origin
argument_list|,
name|c
argument_list|,
name|multvec
argument_list|,
name|Ps0
argument_list|,
name|Pv0
argument_list|)
specifier|register
name|int
name|fchar
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|multvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|Ps0
decl_stmt|,
modifier|*
name|Pv0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|mv
decl_stmt|;
specifier|extern
name|int
modifier|*
name|loccor
parameter_list|()
function_decl|;
comment|/* 	 * Ps is the top of the parse stack after the most 	 * recent local correctness check.  Loccor returns 	 * NIL when we cannot shift. 	 */
specifier|register
name|int
modifier|*
name|ps
decl_stmt|;
name|yyredfail
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the tip parse and semantic stacks. 	 */
name|ps
operator|=
name|Ps0
expr_stmt|;
name|yytips
index|[
literal|0
index|]
operator|=
operator|*
name|ps
expr_stmt|;
name|ps
operator|--
expr_stmt|;
name|yytipv
index|[
literal|0
index|]
operator|=
name|Pv0
index|[
literal|0
index|]
expr_stmt|;
name|yCpv
operator|=
name|Pv0
operator|-
literal|1
expr_stmt|;
name|yytipct
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Shift while possible. 	 * Adjust cost as necessary. 	 */
name|mv
operator|=
name|multvec
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fchar
operator|!=
name|NOCHAR
condition|)
block|{
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ntok
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|YC
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
name|ntok
argument_list|)
expr_stmt|;
name|ntok
operator|.
name|Yychar
operator|=
name|fchar
operator|,
name|ntok
operator|.
name|Yylval
operator|=
name|nullsem
argument_list|(
name|fchar
argument_list|)
expr_stmt|;
name|fchar
operator|=
name|NOCHAR
expr_stmt|;
name|ps
operator|=
name|loccor
argument_list|(
name|ps
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
block|}
else|else
name|ps
operator|=
name|loccor
argument_list|(
name|ps
argument_list|,
operator|&
name|YC
index|[
name|origin
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NIL
condition|)
block|{
if|if
condition|(
name|yyredfail
operator|&&
name|mv
operator|>
name|multvec
condition|)
name|mv
operator|--
expr_stmt|;
name|c
operator|*=
operator|*
name|mv
expr_stmt|;
break|break;
block|}
name|mv
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|mv
operator|!=
literal|1
condition|)
do|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|yygo
index|[]
decl_stmt|,
name|yypgo
index|[]
decl_stmt|,
name|yyr1
index|[]
decl_stmt|,
name|yyr2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local syntactic correctness check.  * The arguments to this routine are a  * top of stack pointer, ps, and an input  * token tok.  Also, implicitly, the contents  * of the yytips array which contains the tip  * of the stack, and into which the new top  * state on the stack will be placed if we shift.  *  * If we succeed, we return a new top of stack  * pointer, else we return NIL.  */
end_comment

begin_function
name|int
modifier|*
name|loccor
parameter_list|(
name|ps
parameter_list|,
name|ntok
parameter_list|)
name|int
modifier|*
name|ps
decl_stmt|;
name|struct
name|yytok
modifier|*
name|ntok
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|int
name|nchar
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ps
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|nchar
operator|=
name|ntok
operator|->
name|Yychar
expr_stmt|;
name|yyeline
operator|=
name|ntok
operator|->
name|Yyeline
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"    Stack "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|yytipct
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Tprintf
argument_list|(
literal|"%d "
argument_list|,
name|yytips
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Tprintf
argument_list|(
literal|"| %d, Input %s%s\n"
argument_list|,
operator|*
name|ps
argument_list|,
name|charname
argument_list|(
name|nchar
argument_list|,
literal|0
argument_list|)
argument_list|,
name|charname
argument_list|(
name|nchar
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * As in the yacc parser yyparse, 	 * p traces through the action list 	 * and "n" is the information associated 	 * with the action. 	 */
name|newstate
label|:
name|p
operator|=
operator|&
name|yyact
index|[
name|yypact
index|[
name|yytips
index|[
name|yytipct
operator|-
literal|1
index|]
operator|+
literal|1
index|]
index|]
expr_stmt|;
comment|/* 	 * Search the parse actions table 	 * for something useful to do. 	 * While n is non-positive, it is the 	 * arithmetic inverse of the token to be tested. 	 * This allows a fast check. 	 */
while|while
condition|(
operator|(
name|n
operator|=
operator|*
name|p
operator|++
operator|)
operator|<=
literal|0
condition|)
if|if
condition|(
operator|(
name|n
operator|+=
name|nchar
operator|)
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|n
operator|>>
literal|12
condition|)
block|{
comment|/* 		 * SHIFT 		 */
default|default:
name|panic
argument_list|(
literal|"loccor"
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|n
operator|&=
literal|07777
expr_stmt|;
name|yyredfail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nchar
operator|==
name|YID
condition|)
name|yyredfail
operator|++
expr_stmt|;
if|if
condition|(
name|yytipct
operator|==
name|YYTIPSIZ
condition|)
block|{
name|tipover
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"\tTIP OVFLO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|yytips
index|[
name|yytipct
index|]
operator|=
name|n
expr_stmt|;
name|yytipv
index|[
name|yytipct
index|]
operator|=
name|ntok
operator|->
name|Yylval
expr_stmt|;
name|yytipct
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"\tShift to state %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ps
operator|)
return|;
comment|/* 		 * REDUCE 		 */
case|case
literal|3
case|:
name|n
operator|&=
literal|07777
expr_stmt|;
if|if
condition|(
name|yyEactr
argument_list|(
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yytipv
index|[
name|yytipct
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"\tYyEactr objects: have %s id, want %s id\n"
argument_list|,
name|classes
index|[
name|yyidhave
index|]
argument_list|,
name|classes
index|[
name|yyidwant
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|yyredfail
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|yyr2
index|[
name|n
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"\tReduce, length %d,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
name|yytipct
condition|)
block|{
name|i
operator|-=
name|yytipct
expr_stmt|;
name|yytipct
operator|=
literal|0
expr_stmt|;
name|ps
operator|-=
name|i
expr_stmt|;
name|yCpv
operator|-=
name|i
expr_stmt|;
block|}
else|else
name|yytipct
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|yytipct
operator|>=
name|YYTIPSIZ
condition|)
goto|goto
name|tipover
goto|;
comment|/* 			 * Use goto table to find next state 			 */
name|p
operator|=
operator|&
name|yygo
index|[
name|yypgo
index|[
name|yyr1
index|[
name|n
index|]
index|]
index|]
expr_stmt|;
name|i
operator|=
name|yytipct
condition|?
name|yytips
index|[
name|yytipct
operator|-
literal|1
index|]
else|:
operator|*
name|ps
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|i
operator|&&
operator|*
name|p
operator|>=
literal|0
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|" new state %d\n"
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yytips
index|[
name|yytipct
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|yytipct
operator|++
expr_stmt|;
goto|goto
name|newstate
goto|;
comment|/* 		 * ACCEPT 		 */
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"\tAccept\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ps
operator|)
return|;
comment|/* 		 * ERROR 		 */
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|Tprintf
argument_list|(
literal|"\tError\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

