begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fdec.c	5.2 (Berkeley) 3/17/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * pxp - Pascal execution profiler  *  * Bill Joy UCB  * Version 1.2 January 1979  */
end_comment

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * Program, procedure or function "header", i.e.:  *  *	function sin: real;  */
end_comment

begin_macro
name|funchdr
argument_list|(
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
operator|*
name|rl
operator|,
operator|*
name|il
expr_stmt|;
if|if
condition|(
name|inpflist
argument_list|(
name|r
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|optstk
index|[
literal|'z'
operator|-
literal|'a'
index|]
operator|<<=
literal|1
expr_stmt|;
name|optstk
index|[
literal|'z'
operator|-
literal|'a'
index|]
operator||=
name|opts
index|[
literal|'z'
operator|-
literal|'a'
index|]
expr_stmt|;
name|opts
index|[
literal|'z'
operator|-
literal|'a'
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|cbn
operator|++
expr_stmt|;
name|lastbn
operator|=
name|cbn
expr_stmt|;
name|getcnt
argument_list|()
expr_stmt|;
if|if
condition|(
name|nojunk
operator|&&
operator|!
name|inpflist
argument_list|(
name|r
index|[
literal|2
index|]
argument_list|)
condition|)
name|setprint
argument_list|()
expr_stmt|;
else|else
name|printon
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
index|[
literal|0
index|]
operator|==
name|T_PROG
operator|&&
name|noinclude
operator|&&
name|bracket
condition|)
name|printoff
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbn
operator|>
literal|1
operator|&&
operator|!
name|justify
condition|)
name|ppgoin
argument_list|(
name|PRFN
argument_list|)
expr_stmt|;
name|puthedr
argument_list|()
expr_stmt|;
if|if
condition|(
name|noblank
argument_list|(
name|setline
argument_list|(
name|r
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|ppnl
argument_list|()
expr_stmt|;
name|cnttab
argument_list|(
name|r
index|[
literal|2
index|]
argument_list|,
name|pfcnt
operator|++
argument_list|)
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|r
index|[
literal|0
index|]
condition|)
block|{
case|case
name|T_PROG
case|:
name|ppkw
argument_list|(
literal|"program"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PDEC
case|:
name|ppkw
argument_list|(
literal|"procedure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_FDEC
case|:
name|ppkw
argument_list|(
literal|"function"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"funchdr"
argument_list|)
expr_stmt|;
block|}
name|ppspac
argument_list|()
expr_stmt|;
name|ppid
argument_list|(
name|r
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
index|[
literal|0
index|]
operator|!=
name|T_PROG
condition|)
block|{
name|rl
operator|=
name|r
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NIL
condition|)
block|{
name|ppbra
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rl
index|[
literal|1
index|]
operator|==
name|NIL
condition|)
block|{
name|rl
operator|=
name|rl
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|rl
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
name|T_PVAR
case|:
name|ppkw
argument_list|(
literal|"var"
argument_list|)
expr_stmt|;
name|ppspac
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_PPROC
case|:
name|ppkw
argument_list|(
literal|"procedure"
argument_list|)
expr_stmt|;
name|ppspac
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_PFUNC
case|:
name|ppkw
argument_list|(
literal|"function"
argument_list|)
expr_stmt|;
name|ppspac
argument_list|()
expr_stmt|;
break|break;
block|}
name|il
operator|=
name|rl
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|il
operator|!=
name|NIL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|ppid
argument_list|(
name|il
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|il
operator|=
name|il
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|il
operator|==
name|NIL
condition|)
break|break;
name|ppsep
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
name|ppid
argument_list|(
literal|"{identifier list}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
name|T_PPROC
condition|)
block|{
name|ppsep
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|gtype
argument_list|(
name|rl
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|rl
operator|=
name|rl
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NIL
condition|)
break|break;
name|ppsep
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|ppspac
argument_list|()
expr_stmt|;
block|}
name|ppket
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
index|[
literal|0
index|]
operator|==
name|T_FDEC
operator|&&
name|r
index|[
literal|4
index|]
operator|!=
name|NIL
condition|)
block|{
name|ppsep
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|gtype
argument_list|(
name|r
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|ppsep
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rl
operator|=
name|r
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NIL
condition|)
block|{
name|ppbra
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ppid
argument_list|(
name|rl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rl
operator|=
name|rl
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NIL
condition|)
break|break;
name|ppsep
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|ppket
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|ppsep
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|fhout
label|:
name|setline
argument_list|(
name|r
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|putcml
argument_list|()
expr_stmt|;
name|savecnt
argument_list|(
operator|&
name|pfcnts
index|[
name|cbn
index|]
argument_list|)
expr_stmt|;
name|setprint
argument_list|()
expr_stmt|;
operator|--
name|cbn
expr_stmt|;
if|if
condition|(
name|cbn
operator|&&
operator|!
name|justify
condition|)
name|ppgoout
argument_list|(
name|PRFN
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
index|[
literal|2
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Forward declaration i.e. the second line of  *  *	procedure fum(var i: integer);  *	    forward;  */
end_comment

begin_macro
name|funcfwd
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|baroff
argument_list|()
expr_stmt|;
name|ppgoin
argument_list|(
name|DECL
argument_list|)
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|ppkw
argument_list|(
literal|"forward"
argument_list|)
expr_stmt|;
name|ppsep
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|ppgoout
argument_list|(
name|DECL
argument_list|)
expr_stmt|;
name|baron
argument_list|()
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The "body" of a procedure, function, or program declaration,  * i.e. a non-forward definition encounter.  */
end_comment

begin_macro
name|funcbody
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cbn
operator|&&
operator|!
name|justify
condition|)
name|ppgoin
argument_list|(
name|PRFN
argument_list|)
expr_stmt|;
name|cbn
operator|++
expr_stmt|;
name|lastbn
operator|=
name|cbn
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The guts of the procedure, function or program, i.e.  * the part between the begin and the end.  */
end_comment

begin_macro
name|funcend
argument_list|(
argument|fp
argument_list|,
argument|bundle
argument_list|,
argument|binfo
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|bundle
decl_stmt|,
modifier|*
name|binfo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|blk
decl_stmt|;
specifier|extern
name|int
name|cntstat
decl_stmt|;
name|cntstat
operator|=
literal|0
expr_stmt|;
name|blk
operator|=
name|bundle
index|[
literal|2
index|]
expr_stmt|;
name|rescnt
argument_list|(
operator|&
name|pfcnts
index|[
name|cbn
index|]
argument_list|)
expr_stmt|;
name|setprint
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbn
operator|==
literal|1
operator|&&
name|noinclude
operator|&&
name|bracket
condition|)
name|printoff
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastbn
operator|>
name|cbn
condition|)
name|unprint
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbn
operator|==
literal|1
condition|)
name|puthedr
argument_list|()
expr_stmt|;
if|if
condition|(
name|noblank
argument_list|(
name|setline
argument_list|(
name|bundle
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|&&
name|lastbn
operator|>
name|cbn
condition|)
name|ppnl
argument_list|()
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|ppkw
argument_list|(
literal|"begin"
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|bundle
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|putcml
argument_list|()
operator|==
literal|0
operator|&&
name|lastbn
operator|>
name|cbn
condition|)
name|ppsname
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ppgoin
argument_list|(
name|DECL
argument_list|)
expr_stmt|;
name|statlist
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|setinfo
argument_list|(
name|bundle
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|putcmp
argument_list|()
expr_stmt|;
name|ppgoout
argument_list|(
name|DECL
argument_list|)
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|ppkw
argument_list|(
literal|"end"
argument_list|)
expr_stmt|;
name|ppsep
argument_list|(
name|cbn
operator|==
literal|1
condition|?
literal|"."
else|:
literal|";"
argument_list|)
expr_stmt|;
name|setinfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|putcml
argument_list|()
operator|==
literal|0
condition|)
name|ppsname
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|cbn
operator|--
expr_stmt|;
if|if
condition|(
name|cbn
operator|&&
operator|!
name|justify
condition|)
name|ppgoout
argument_list|(
name|PRFN
argument_list|)
expr_stmt|;
if|if
condition|(
name|inpflist
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|opts
index|[
literal|'z'
operator|-
literal|'a'
index|]
operator|=
name|optstk
index|[
literal|'z'
operator|-
literal|'a'
index|]
operator|&
literal|1
expr_stmt|;
name|optstk
index|[
literal|'z'
operator|-
literal|'a'
index|]
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cbn
operator|==
literal|0
condition|)
block|{
name|flushcm
argument_list|()
expr_stmt|;
name|printon
argument_list|()
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ppsname
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
return|return;
name|ppsep
argument_list|(
literal|" { "
argument_list|)
expr_stmt|;
name|ppid
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ppsep
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Segend is called at the end of a routine segment (a separately  * compiled segment that is not the main program). Since pxp only works  * with a single pascal file, this routine should never be called.  */
end_comment

begin_macro
name|segend
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|profile
condition|)
block|{
name|error
argument_list|(
literal|"Missing program statement and program body"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * External declaration i.e. the second line of  *  *	procedure fum(var i: integer);  *	    external;  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|funcext
parameter_list|(
name|fp
parameter_list|)
name|struct
name|nl
modifier|*
name|fp
decl_stmt|;
block|{
name|baroff
argument_list|()
expr_stmt|;
name|ppgoin
argument_list|(
name|DECL
argument_list|)
expr_stmt|;
name|ppnl
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|ppkw
argument_list|(
literal|"external"
argument_list|)
expr_stmt|;
name|ppsep
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|ppgoout
argument_list|(
name|DECL
argument_list|)
expr_stmt|;
name|baron
argument_list|()
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

end_unit

