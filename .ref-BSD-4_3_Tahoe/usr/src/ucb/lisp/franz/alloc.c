begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: alloc.c,v 1.13 87/12/11 17:27:45 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * 	alloc.c				$Locker:  $  * storage allocator and garbage collector  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|METER
end_ifdef

begin_include
include|#
directive|include
file|<sys/vtimes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUMWORDS
value|TTSIZE * 128
end_define

begin_comment
comment|/*  max number of words in P0 space  */
end_comment

begin_define
define|#
directive|define
name|BITQUADS
value|TTSIZE * 2
end_define

begin_comment
comment|/*  length of bit map in quad words  */
end_comment

begin_define
define|#
directive|define
name|BITLONGS
value|TTSIZE * 4
end_define

begin_comment
comment|/*  length of bit map in long words  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|ftstbit
value|asm("	ashl	$-2,r11,r3");\ 			asm("	bbcs	r3,_bitmapi,1f");\ 			asm("	ret"); \ 			asm("1:");
end_define

begin_comment
comment|/* setbit is a fast way of setting a bit, it is like ftstbit except it  * always continues on to the next instruction  */
end_comment

begin_define
define|#
directive|define
name|setbit
value|asm("	ashl	$-2,r11,r0"); \ 			asm("	bbcs	r0,_bitmapi,$0");
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|m_68k
end_if

begin_define
define|#
directive|define
name|ftstbit
value|{if(Itstbt()) return;}
end_define

begin_define
define|#
directive|define
name|setbit
value|Itstbt()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_define
define|#
directive|define
name|ftstbit
value|if( readbit(p) ) return; oksetbit;
end_define

begin_define
define|#
directive|define
name|setbit
value|{bitmapi[(int)p>>7] |= bitmsk[((int)p>> 2)&31];}
end_define

begin_define
define|#
directive|define
name|readbit
parameter_list|(
name|p
parameter_list|)
value|((int)bitmapi[r=(int)p>>7]& (s=bitmsk[((int)p>>2)&31]))
end_define

begin_define
define|#
directive|define
name|oksetbit
value|{bitmapi[r] |= s;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*	Unused bit macros # define lookbit(p)	(bbitmap[(int)p>>5]& bitmsk[((int)p>>2)& 7]) # define readchk(p)	((int)bitfre[(int)p>>5]& bitmsk[((int)p>>2)&7]) # define setchk(p)	{bitfre[(int)p>>5] |= bitmsk[((int)p>> 2)& 7];} */
end_comment

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|,
name|l
parameter_list|)
value|(((x - 1) | (l - 1)) + 1)
end_define

begin_define
define|#
directive|define
name|MARKVAL
parameter_list|(
name|v
parameter_list|)
value|if(((int)v)>= (int)beginsweep) markdp(v);
end_define

begin_define
define|#
directive|define
name|ATOLX
parameter_list|(
name|p
parameter_list|)
value|((((int)p)-OFFSET)>>7)
end_define

begin_comment
comment|/* the Vax hardware only allows 2^16-1 bytes to be accessed with one  * movc5 instruction.  We use the movc5 instruction to clear the   * bitmaps.  */
end_comment

begin_define
define|#
directive|define
name|MAXCLEAR
value|((1<<16)-1)
end_define

begin_comment
comment|/* METER denotes something added to help meter storage allocation. */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|beginsweep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first sweepable data		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
name|purepage
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fakettsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gcstrings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debugin
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp debug flag */
end_comment

begin_decl_stmt
specifier|extern
name|lispval
name|datalim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  end of data space */
end_comment

begin_decl_stmt
name|int
name|bitmapi
index|[
name|BITLONGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the bit map--one bit per long  */
end_comment

begin_decl_stmt
name|double
name|zeroq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  a quad word of zeros  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bbitmap
init|=
operator|(
name|char
operator|*
operator|)
name|bitmapi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  byte version of bit map array */
end_comment

begin_decl_stmt
name|double
modifier|*
name|qbitmap
init|=
operator|(
name|double
operator|*
operator|)
name|bitmapi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  integer version of bit map array */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|METER
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|gcstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|vtimes
name|premark
decl_stmt|,
name|presweep
decl_stmt|,
name|alldone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actually struct tbuffer's */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|mrkdpcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|conssame
decl_stmt|,
name|consdiff
decl_stmt|,
name|consnil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of cells whose cdr point 					 * to the same page and different 					 * pages respectively 					 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|bitmsk
index|[
literal|32
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
comment|/*  used by bit-marking macros  */
literal|0x100
block|,
literal|0x200
block|,
literal|0x400
block|,
literal|0x800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0x10000
block|,
literal|0x20000
block|,
literal|0x40000
block|,
literal|0x80000
block|,
literal|0x100000
block|,
literal|0x200000
block|,
literal|0x400000
block|,
literal|0x800000
block|,
literal|0x1000000
block|,
literal|0x2000000
block|,
literal|0x4000000
block|,
literal|0x8000000
block|,
literal|0x10000000
block|,
literal|0x20000000
block|,
literal|0x40000000
block|,
literal|0x80000000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|bind_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  lisp data for compiled code */
end_comment

begin_function_decl
name|char
modifier|*
name|xsbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|gethspace
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|types
name|atom_str
decl_stmt|,
name|strng_str
decl_stmt|,
name|int_str
decl_stmt|,
name|dtpr_str
decl_stmt|,
name|doub_str
decl_stmt|,
name|array_str
decl_stmt|,
name|sdot_str
decl_stmt|,
name|val_str
decl_stmt|,
name|funct_str
decl_stmt|,
name|hunk_str
index|[]
decl_stmt|,
name|vect_str
decl_stmt|,
name|vecti_str
decl_stmt|,
name|other_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|str_x
name|str_current
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|hunk_items
index|[
literal|7
index|]
decl_stmt|,
name|hunk_pages
index|[
literal|7
index|]
decl_stmt|,
name|hunk_name
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starts off TRUE: initially gc not allowed */
end_comment

begin_comment
comment|/* this is a table of pointers to all struct types objects  * the index is the type number.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|types
modifier|*
name|spaces
index|[
name|NUMSPACES
index|]
init|=
block|{
operator|&
name|strng_str
block|,
operator|&
name|atom_str
block|,
operator|&
name|int_str
block|,
operator|&
name|dtpr_str
block|,
operator|&
name|doub_str
block|,
operator|&
name|funct_str
block|,
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* port objects not allocated in this way  */
operator|&
name|array_str
block|,
operator|&
name|other_str
block|,
comment|/* other objects not allocated in this way  */
operator|&
name|sdot_str
block|,
operator|&
name|val_str
block|,
operator|&
name|hunk_str
index|[
literal|0
index|]
block|,
operator|&
name|hunk_str
index|[
literal|1
index|]
block|,
operator|&
name|hunk_str
index|[
literal|2
index|]
block|,
operator|&
name|hunk_str
index|[
literal|3
index|]
block|,
operator|&
name|hunk_str
index|[
literal|4
index|]
block|,
operator|&
name|hunk_str
index|[
literal|5
index|]
block|,
operator|&
name|hunk_str
index|[
literal|6
index|]
block|,
operator|&
name|vect_str
block|,
operator|&
name|vecti_str
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is a table of pointers to collectable struct types objects  * the index is the type number.  */
end_comment

begin_decl_stmt
name|struct
name|types
modifier|*
name|gcableptr
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|GCSTRINGS
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* strings not collectable */
else|#
directive|else
operator|&
name|strng_str
block|,
endif|#
directive|endif
operator|&
name|atom_str
block|,
operator|&
name|int_str
block|,
operator|&
name|dtpr_str
block|,
operator|&
name|doub_str
block|,
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* binary objects not collectable */
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* port objects not collectable */
operator|&
name|array_str
block|,
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* gap in the type number sequence */
operator|&
name|sdot_str
block|,
operator|&
name|val_str
block|,
operator|&
name|hunk_str
index|[
literal|0
index|]
block|,
operator|&
name|hunk_str
index|[
literal|1
index|]
block|,
operator|&
name|hunk_str
index|[
literal|2
index|]
block|,
operator|&
name|hunk_str
index|[
literal|3
index|]
block|,
operator|&
name|hunk_str
index|[
literal|4
index|]
block|,
operator|&
name|hunk_str
index|[
literal|5
index|]
block|,
operator|&
name|hunk_str
index|[
literal|6
index|]
block|,
operator|&
name|vect_str
block|,
operator|&
name|vecti_str
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *   get_more_space(type_struct,purep)   *									  *  Allocates and structures a new page, returning 0.  *  If no space is available, returns positive number.  *  If purep is TRUE, then pure space is allocated.  */
end_comment

begin_macro
name|get_more_space
argument_list|(
argument|type_struct
argument_list|,
argument|purep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cntr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
modifier|*
name|loop
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|lispval
name|p
decl_stmt|;
specifier|extern
name|char
name|holend
index|[]
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|datalim
operator|>=
name|TTSIZE
operator|*
name|LBPG
operator|+
name|OFFSET
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 	 * If the hole is defined, then we allocate binary objects 	 * and strings in the hole.  However we don't put strings in 	 * the hole if strings are gc'ed. 	 */
ifdef|#
directive|ifdef
name|HOLE
if|if
condition|(
name|purep
ifndef|#
directive|ifndef
name|GCSTRINGS
operator|||
name|type_struct
operator|==
operator|&
name|strng_str
endif|#
directive|endif
operator|||
name|type_struct
operator|==
operator|&
name|funct_str
condition|)
name|start
operator|=
name|gethspace
argument_list|(
name|LBPG
argument_list|,
name|type_struct
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|start
operator|=
name|xsbrk
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* get new page */
name|SETTYPE
argument_list|(
name|start
argument_list|,
name|type_struct
operator|->
name|type
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/*  set type of page  */
name|purepage
index|[
name|ATOX
argument_list|(
name|start
argument_list|)
index|]
operator|=
operator|(
name|char
operator|)
name|purep
expr_stmt|;
comment|/* remember if page was pure*/
comment|/* bump the page counter for this space if not pure */
if|if
condition|(
operator|!
name|purep
condition|)
operator|++
operator|(
operator|(
operator|*
operator|(
name|type_struct
operator|->
name|pages
operator|)
operator|)
operator|->
name|i
operator|)
expr_stmt|;
name|type_struct
operator|->
name|space_left
operator|=
name|type_struct
operator|->
name|space
expr_stmt|;
name|temp
operator|=
name|loop
operator|=
operator|(
name|int
operator|*
operator|)
name|start
expr_stmt|;
for|for
control|(
name|cntr
operator|=
literal|1
init|;
name|cntr
operator|<
name|type_struct
operator|->
name|space
condition|;
name|cntr
operator|++
control|)
name|loop
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|loop
operator|+
name|type_struct
operator|->
name|type_len
argument_list|)
operator|)
expr_stmt|;
comment|/* attach new cells to either the pure space free list  or the  	 * standard free list 	 */
if|if
condition|(
name|purep
condition|)
block|{
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|type_struct
operator|->
name|next_pure_free
argument_list|)
expr_stmt|;
name|type_struct
operator|->
name|next_pure_free
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|type_struct
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|type_struct
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
block|}
comment|/*  if type atom, set pnames to CNIL  */
if|if
condition|(
name|type_struct
operator|==
operator|&
name|atom_str
condition|)
for|for
control|(
name|cntr
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|lispval
operator|)
name|temp
init|;
name|cntr
operator|<
name|atom_str
operator|.
name|space
condition|;
operator|++
name|cntr
control|)
block|{
name|p
operator|->
name|a
operator|.
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
name|p
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|p
operator|+
name|atom_str
operator|.
name|type_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  space was available  */
block|}
end_block

begin_comment
comment|/*  * next_one(type_struct)   *  *  Allocates one new item of each kind of space, except STRNG.	  *  If there is no space, calls gc, the garbage collector.  *  If there is still no space, allocates a new page using  *  get_more_space  */
end_comment

begin_function
name|lispval
name|next_one
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
name|type_struct
operator|->
name|next_free
operator|==
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
block|{
name|int
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|initflag
operator|==
name|FALSE
operator|)
operator|&&
comment|/* dont gc during init */
ifndef|#
directive|ifndef
name|GCSTRINGS
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|STRNG
operator|)
operator|&&
comment|/* can't collect strings */
else|#
directive|else
name|gcstrings
operator|&&
comment|/* user (sstatus gcstrings) */
endif|#
directive|endif
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|BCD
operator|)
operator|&&
comment|/* nor function headers  */
name|gcdis
operator|->
name|a
operator|.
name|clb
operator|==
name|nil
condition|)
comment|/* gc not disabled */
comment|/* not to collect during load */
block|{
name|gc
argument_list|(
name|type_struct
argument_list|)
expr_stmt|;
comment|/*  collect  */
block|}
if|if
condition|(
name|type_struct
operator|->
name|next_free
operator|!=
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|g
operator|=
name|get_more_space
argument_list|(
name|type_struct
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
break|break;
name|space_warn
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|type_struct
operator|->
name|next_free
expr_stmt|;
name|type_struct
operator|->
name|next_free
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|type_struct
operator|->
name|next_free
operator|)
expr_stmt|;
operator|(
operator|*
operator|(
name|type_struct
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Warn about exhaustion of space,  * shared with next_pure_free().  */
end_comment

begin_macro
name|space_warn
argument_list|(
argument|g
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|g
operator|==
literal|1
condition|)
block|{
name|plimit
operator|->
name|i
operator|+=
name|NUMSPACES
expr_stmt|;
comment|/*  allow a few more pages  */
name|copval
argument_list|(
name|plima
argument_list|,
name|plimit
argument_list|)
expr_stmt|;
comment|/*  restore to reserved reg  */
name|error
argument_list|(
literal|"PAGE LIMIT EXCEEDED--EMERGENCY PAGES ALLOCATED"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"SORRY, ABSOLUTE PAGE LIMIT HAS BEEN REACHED"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* allocate an element of a pure structure.  Pure structures will  * be ignored by the garbage collector.  */
end_comment

begin_function
name|lispval
name|next_pure_one
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
name|type_struct
operator|->
name|next_pure_free
operator|==
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
block|{
name|int
name|g
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|g
operator|=
name|get_more_space
argument_list|(
name|type_struct
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
break|break;
name|space_warn
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|type_struct
operator|->
name|next_pure_free
expr_stmt|;
name|type_struct
operator|->
name|next_pure_free
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|type_struct
operator|->
name|next_pure_free
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newint
parameter_list|()
block|{
return|return
operator|(
name|next_one
argument_list|(
operator|&
name|int_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewint
parameter_list|()
block|{
return|return
operator|(
name|next_pure_one
argument_list|(
operator|&
name|int_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newdot
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|dtpr_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewdot
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_pure_one
argument_list|(
operator|&
name|dtpr_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newdoub
parameter_list|()
block|{
return|return
operator|(
name|next_one
argument_list|(
operator|&
name|doub_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewdb
parameter_list|()
block|{
return|return
operator|(
name|next_pure_one
argument_list|(
operator|&
name|doub_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newsdot
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|sdot_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewsdot
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_pure_one
argument_list|(
operator|&
name|sdot_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|atom
modifier|*
name|newatom
parameter_list|(
name|pure
parameter_list|)
block|{
name|struct
name|atom
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|mypname
decl_stmt|;
name|mypname
operator|=
name|newstr
argument_list|(
name|pure
argument_list|)
expr_stmt|;
name|pnameprot
operator|=
operator|(
operator|(
name|lispval
operator|)
name|mypname
operator|)
expr_stmt|;
name|save
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|next_one
argument_list|(
operator|&
name|atom_str
argument_list|)
expr_stmt|;
name|save
operator|->
name|plist
operator|=
name|save
operator|->
name|fnbnd
operator|=
name|nil
expr_stmt|;
name|save
operator|->
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
name|save
operator|->
name|clb
operator|=
name|CNIL
expr_stmt|;
name|save
operator|->
name|pname
operator|=
name|mypname
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|newstr
parameter_list|(
name|purep
parameter_list|)
block|{
name|char
modifier|*
name|save
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
name|int
name|atmlen
decl_stmt|;
specifier|register
name|struct
name|str_x
modifier|*
name|p
init|=
name|str_current
operator|+
name|purep
decl_stmt|;
name|atmlen
operator|=
name|strlen
argument_list|(
name|strbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|atmlen
operator|>
name|p
operator|->
name|space_left
condition|)
block|{
if|if
condition|(
name|atmlen
operator|>=
name|STRBLEN
condition|)
block|{
name|save
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|OTHER
argument_list|,
name|atmlen
argument_list|,
name|purep
argument_list|)
expr_stmt|;
name|SETTYPE
argument_list|(
name|save
argument_list|,
name|STRNG
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|purepage
index|[
name|ATOX
argument_list|(
name|save
argument_list|)
index|]
operator|=
operator|(
name|char
operator|)
name|purep
expr_stmt|;
name|strcpy
argument_list|(
name|save
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
name|p
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|purep
condition|?
name|next_pure_one
argument_list|(
operator|&
name|strng_str
argument_list|)
else|:
name|next_one
argument_list|(
operator|&
name|strng_str
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|space_left
operator|=
name|LBPG
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|(
name|save
operator|=
name|p
operator|->
name|next_free
operator|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/*while(atmlen& 3) ++atmlen;	/*  even up length of string  */
name|p
operator|->
name|next_free
operator|+=
name|atmlen
expr_stmt|;
name|p
operator|->
name|space_left
operator|-=
name|atmlen
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|Iinewstr
parameter_list|(
name|s
parameter_list|,
name|purep
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
operator|(
name|endstrb
operator|-
name|strbuf
operator|-
literal|1
operator|)
condition|)
name|atomtoolong
argument_list|(
name|strbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstr
argument_list|(
name|purep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|inewstr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|Iinewstr
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pinewstr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|Iinewstr
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|newarray
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|array_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|nil
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|accfun
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|aux
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|length
operator|=
name|SMALL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|delta
operator|=
name|SMALL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newfunct
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|lispval
name|Badcall
parameter_list|()
function_decl|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|funct_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|bcd
operator|.
name|start
operator|=
name|Badcall
expr_stmt|;
name|temp
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newval
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewval
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_pure_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newhunk
parameter_list|(
name|hunknum
parameter_list|)
name|int
name|hunknum
decl_stmt|;
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|hunk_str
index|[
name|hunknum
index|]
argument_list|)
expr_stmt|;
comment|/* Get a hunk */
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewhunk
parameter_list|(
name|hunknum
parameter_list|)
name|int
name|hunknum
decl_stmt|;
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_pure_one
argument_list|(
operator|&
name|hunk_str
index|[
name|hunknum
index|]
argument_list|)
expr_stmt|;
comment|/* Get a hunk */
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|inewval
parameter_list|(
name|arg
parameter_list|)
name|lispval
name|arg
decl_stmt|;
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vector allocators.  * a vector looks like:  *  longword: N = size in bytes  *  longword: pointer to lisp object, this is the vector property field  *  N consecutive bytes  *  */
end_comment

begin_function_decl
name|lispval
name|getvec
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|lispval
name|newvec
parameter_list|(
name|size
parameter_list|)
block|{
return|return
operator|(
name|getvec
argument_list|(
name|size
argument_list|,
operator|&
name|vect_str
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnewvec
parameter_list|(
name|size
parameter_list|)
block|{
return|return
operator|(
name|getvec
argument_list|(
name|size
argument_list|,
operator|&
name|vect_str
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|nveci
parameter_list|(
name|size
parameter_list|)
block|{
return|return
operator|(
name|getvec
argument_list|(
name|size
argument_list|,
operator|&
name|vecti_str
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|pnveci
parameter_list|(
name|size
parameter_list|)
block|{
return|return
operator|(
name|getvec
argument_list|(
name|size
argument_list|,
operator|&
name|vecti_str
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getvec  *  get a vector of size byte, from type structure typestr and  * get it from pure space if purep is TRUE.  *  vectors are stored linked through their property field.  Thus  * when the code here refers to v.vector[0], it is the prop field  * and vl.vectorl[-1] is the size field.   In other code,  * v.vector[-1] is the prop field, and vl.vectorl[-2] is the size.  */
end_comment

begin_function
name|lispval
name|getvec
parameter_list|(
name|size
parameter_list|,
name|typestr
parameter_list|,
name|purep
parameter_list|)
specifier|register
name|struct
name|types
modifier|*
name|typestr
decl_stmt|;
block|{
specifier|register
name|lispval
name|back
decl_stmt|,
name|current
decl_stmt|;
name|int
name|sizewant
decl_stmt|,
name|bytes
decl_stmt|,
name|thissize
decl_stmt|,
name|pages
decl_stmt|,
name|pindex
decl_stmt|,
name|triedgc
init|=
name|FALSE
decl_stmt|;
comment|/* we have to round up to a multiple of 4 bytes to determine the      * size of vector we want.  The rounding up assures that the      * property pointers are longword aligned      */
name|sizewant
operator|=
name|VecTotSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"want vect %db\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|purep
condition|)
name|back
operator|=
operator|(
name|lispval
operator|)
operator|&
operator|(
name|typestr
operator|->
name|next_pure_free
operator|)
expr_stmt|;
else|else
name|back
operator|=
operator|(
name|lispval
operator|)
operator|&
operator|(
name|typestr
operator|->
name|next_free
operator|)
expr_stmt|;
name|current
operator|=
name|back
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|CNIL
condition|)
block|{
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"next free size %db; "
argument_list|,
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thissize
operator|=
name|VecTotSize
argument_list|(
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|==
name|sizewant
condition|)
block|{
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exact match of size %d at 0x%x\n"
argument_list|,
literal|4
operator|*
name|thissize
argument_list|,
operator|&
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|back
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
operator|=
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
expr_stmt|;
comment|/* change free pointer*/
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
operator|=
name|nil
expr_stmt|;
comment|/* put nil in property */
comment|/* to the user, vector begins one after property*/
return|return
operator|(
operator|(
name|lispval
operator|)
operator|&
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|thissize
operator|>=
name|sizewant
operator|+
literal|3
condition|)
block|{
comment|/* the reason that there is a `+ 3' instead of `+ 2' 	     * is that we don't want to leave a zero sized vector which 	     * isn't guaranteed to be followed by another vector 	     */
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"breaking a %d vector into a "
argument_list|,
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
operator|+
name|sizewant
operator|+
literal|1
index|]
operator|=
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
expr_stmt|;
comment|/* free list pointer */
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
literal|1
operator|+
name|sizewant
index|]
operator|=
name|VecTotToByte
argument_list|(
name|thissize
operator|-
name|sizewant
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/*size info */
name|back
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
operator|=
operator|(
name|lispval
operator|)
operator|&
operator|(
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
operator|+
name|sizewant
operator|+
literal|1
index|]
operator|)
expr_stmt|;
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d one and a %d one\n"
argument_list|,
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
argument_list|,
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
literal|1
operator|+
name|sizewant
index|]
argument_list|)
expr_stmt|;
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
operator|=
name|nil
expr_stmt|;
comment|/* put nil in property */
comment|/* vector begins one after the property */
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" and returning vector at 0x%x\n"
argument_list|,
operator|&
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
operator|&
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
argument_list|)
operator|)
return|;
block|}
name|back
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|triedgc
operator|&&
operator|!
name|purep
operator|&&
operator|(
name|gcdis
operator|->
name|a
operator|.
name|clb
operator|==
name|nil
operator|)
operator|&&
operator|(
name|initflag
operator|==
name|FALSE
operator|)
condition|)
block|{
name|gc
argument_list|(
name|typestr
argument_list|)
expr_stmt|;
name|triedgc
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* set bytes to size needed for this vector */
name|bytes
operator|=
name|size
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* must make sure that if the vector we are allocating doesnt        completely fill a page, there is room for another vector to record        the size left over */
if|if
condition|(
operator|(
name|bytes
operator|&
operator|(
name|LBPG
operator|-
literal|1
operator|)
operator|)
operator|>
operator|(
name|LBPG
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
condition|)
name|bytes
operator|+=
name|LBPG
expr_stmt|;
name|bytes
operator|=
name|roundup
argument_list|(
name|bytes
argument_list|,
name|LBPG
argument_list|)
expr_stmt|;
name|current
operator|=
name|csegment
argument_list|(
name|typestr
operator|->
name|type
argument_list|,
name|bytes
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|purep
argument_list|)
expr_stmt|;
name|current
operator|->
name|vl
operator|.
name|vectorl
index|[
literal|0
index|]
operator|=
name|bytes
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|purep
condition|)
block|{
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|=
call|(
name|lispval
call|)
argument_list|(
name|typestr
operator|->
name|next_pure_free
argument_list|)
expr_stmt|;
name|typestr
operator|->
name|next_pure_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|)
expr_stmt|;
comment|/* make them pure */
name|pages
operator|=
name|bytes
operator|/
name|LBPG
expr_stmt|;
for|for
control|(
name|pindex
operator|=
name|ATOX
argument_list|(
name|current
argument_list|)
init|;
name|pages
condition|;
name|pages
operator|--
control|)
block|{
name|purepage
index|[
name|pindex
operator|++
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|=
call|(
name|lispval
call|)
argument_list|(
name|typestr
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|typestr
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"grabbed %d vec pages\n"
argument_list|,
name|bytes
operator|/
name|LBPG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"creating a new vec, size %d\n"
argument_list|,
name|current
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * Ipurep :: routine to check for pureness of a data item  *  */
end_comment

begin_function
name|lispval
name|Ipurep
parameter_list|(
name|element
parameter_list|)
name|lispval
name|element
decl_stmt|;
block|{
if|if
condition|(
name|purepage
index|[
name|ATOX
argument_list|(
name|element
argument_list|)
index|]
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* routines to return space to the free list.  These are used by the  * arithmetic routines which tend to create large intermediate results  * which are know to be garbage after the calculation is over.  *  * There are jsb callable versions of these routines in qfuncl.s  */
end_comment

begin_comment
comment|/* pruneb   - prune bignum. A bignum is an sdot followed by a list of  *  dtprs.    The dtpr list is linked by car instead of cdr so when we  *  put it in the free list, we have to change the links.  */
end_comment

begin_macro
name|pruneb
argument_list|(
argument|bignum
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|bignum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|temp
init|=
name|bignum
decl_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|SDOT
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"value to pruneb not a sdot"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
operator|(
name|sdot_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|->
name|s
operator|.
name|I
operator|=
operator|(
name|int
operator|)
name|sdot_str
operator|.
name|next_free
expr_stmt|;
name|sdot_str
operator|.
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
comment|/* bignums are not terminated by nil on the dual, 	   they are terminated by (lispval) 0 */
while|while
condition|(
name|temp
operator|=
name|temp
operator|->
name|s
operator|.
name|CDR
condition|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|DTPR
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"value to pruneb not a list"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
operator|(
name|dtpr_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|->
name|s
operator|.
name|I
operator|=
operator|(
name|int
operator|)
name|dtpr_str
operator|.
name|next_free
expr_stmt|;
name|dtpr_str
operator|.
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
block|}
block|}
end_block

begin_function
name|lispval
name|Badcall
parameter_list|()
block|{
name|error
argument_list|(
literal|"BAD FUNCTION DESCRIPTOR USED IN CALL"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ngc   *  this is the lisp function gc  *  */
end_comment

begin_function
name|lispval
name|Ngc
parameter_list|()
block|{
return|return
operator|(
name|gc
argument_list|(
operator|(
expr|struct
name|types
operator|*
operator|)
name|CNIL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gc(type_struct)   *  *  garbage collector:  Collects garbage by mark and sweep algorithm.  *  After this is done, calls the Nlambda, gcafter.  *  gc may also be called from LISP, as an  nlambda of no arguments.  * type_struct is the type of lisp data that ran out causing this  * garbage collection  */
end_comment

begin_decl_stmt
name|int
name|printall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|lispval
name|gc
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
name|lispval
name|save
decl_stmt|;
name|struct
name|tms
name|begin
decl_stmt|,
name|finish
decl_stmt|;
specifier|extern
name|int
name|gctime
decl_stmt|;
comment|/* if this was called automatically when space ran out 	 * print out a message 	 */
if|if
condition|(
operator|(
name|Vgcprint
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|type_struct
operator|!=
operator|(
expr|struct
name|types
operator|*
operator|)
name|CNIL
operator|)
condition|)
block|{
name|FILE
modifier|*
name|port
init|=
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|poport
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|port
argument_list|,
literal|"gc:"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gctime
condition|)
name|times
argument_list|(
operator|&
name|begin
argument_list|)
expr_stmt|;
name|gc1
argument_list|()
expr_stmt|;
comment|/* mark&sweep */
comment|/* Now we call gcafter--special c ase if gc called from LISP */
if|if
condition|(
name|type_struct
operator|==
operator|(
expr|struct
name|types
operator|*
operator|)
name|CNIL
condition|)
name|gccall1
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
comment|/* make the call "(gcafter)" */
else|else
block|{
name|gccall1
operator|->
name|d
operator|.
name|cdr
operator|=
name|gccall2
expr_stmt|;
name|gccall2
operator|->
name|d
operator|.
name|car
operator|=
operator|*
operator|(
name|type_struct
operator|->
name|type_name
operator|)
expr_stmt|;
block|}
name|PUSHDOWN
argument_list|(
name|gcdis
argument_list|,
name|gcdis
argument_list|)
expr_stmt|;
comment|/*  flag to indicate in garbage collector  */
name|save
operator|=
name|eval
argument_list|(
name|gccall1
argument_list|)
expr_stmt|;
comment|/*  call gcafter  */
name|POP
expr_stmt|;
comment|/*  turn off flag  */
if|if
condition|(
name|gctime
condition|)
block|{
name|times
argument_list|(
operator|&
name|finish
argument_list|)
expr_stmt|;
name|gctime
operator|+=
operator|(
name|finish
operator|.
name|tms_utime
operator|-
name|begin
operator|.
name|tms_utime
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|save
operator|)
return|;
comment|/*  return result of gcafter  */
block|}
end_function

begin_comment
comment|/*  gc1()  **************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Mark-and-sweep phase						*/
end_comment

begin_macro
name|gc1
argument_list|()
end_macro

begin_block
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
modifier|*
name|start
decl_stmt|,
name|bvalue
decl_stmt|,
name|type_len
decl_stmt|;
specifier|register
name|struct
name|types
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|point
decl_stmt|,
name|i
decl_stmt|,
name|freecnt
decl_stmt|,
name|itemstogo
decl_stmt|,
name|bits
decl_stmt|,
name|bindex
decl_stmt|,
name|type
decl_stmt|,
name|bytestoclear
decl_stmt|;
name|int
name|usedcnt
decl_stmt|;
name|char
modifier|*
name|pindex
decl_stmt|;
name|struct
name|argent
modifier|*
name|loop2
decl_stmt|;
name|struct
name|nament
modifier|*
name|loop3
decl_stmt|;
name|struct
name|atom
modifier|*
name|symb
decl_stmt|;
name|int
name|markdp
parameter_list|()
function_decl|;
specifier|extern
name|int
name|hashtop
decl_stmt|;
name|pagerand
argument_list|()
expr_stmt|;
comment|/*  decide whether to check LISP structure or not  */
ifdef|#
directive|ifdef
name|METER
name|vtimes
argument_list|(
operator|&
name|premark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mrkdpcnt
operator|=
literal|0
expr_stmt|;
name|conssame
operator|=
name|consdiff
operator|=
name|consnil
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*  first set all bit maps to zero  */
ifdef|#
directive|ifdef
name|SLOCLEAR
block|{
name|int
name|enddat
decl_stmt|;
name|enddat
operator|=
call|(
name|int
call|)
argument_list|(
name|datalim
operator|-
name|OFFSET
argument_list|)
operator|>>
literal|8
expr_stmt|;
for|for
control|(
name|bvalue
operator|=
literal|0
init|;
name|bvalue
operator|<
operator|(
name|int
operator|)
name|enddat
condition|;
operator|++
name|bvalue
control|)
block|{
name|qbitmap
index|[
name|bvalue
index|]
operator|=
name|zeroq
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* try the movc5 to clear the bit maps */
comment|/* the maximum number of bytes we can clear in one sweep is 	 * 2^16 (or 1<<16 in the C lingo) 	 */
name|bytestoclear
operator|=
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|datalim
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
name|beginsweep
operator|)
operator|)
operator|>>
literal|9
operator|)
operator|*
literal|16
expr_stmt|;
for|for
control|(
name|start
operator|=
name|bitmapi
operator|+
name|ATOLX
argument_list|(
name|beginsweep
argument_list|)
init|;
name|bytestoclear
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|bytestoclear
operator|>
name|MAXCLEAR
condition|)
name|blzero
argument_list|(
operator|(
name|int
operator|)
name|start
argument_list|,
name|MAXCLEAR
argument_list|)
expr_stmt|;
else|else
name|blzero
argument_list|(
operator|(
name|int
operator|)
name|start
argument_list|,
name|bytestoclear
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|MAXCLEAR
operator|+
operator|(
name|int
operator|)
name|start
operator|)
expr_stmt|;
name|bytestoclear
operator|-=
name|MAXCLEAR
expr_stmt|;
block|}
comment|/* mark all atoms in the oblist */
for|for
control|(
name|bvalue
operator|=
literal|0
init|;
name|bvalue
operator|<=
name|hashtop
operator|-
literal|1
condition|;
name|bvalue
operator|++
control|)
comment|/* though oblist */
block|{
for|for
control|(
name|symb
operator|=
name|hasht
index|[
name|bvalue
index|]
init|;
name|symb
operator|!=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
condition|;
name|symb
operator|=
name|symb
operator|->
name|hshlnk
control|)
block|{
name|markdp
argument_list|(
operator|(
name|lispval
operator|)
name|symb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark all the atoms and ints associated with the hunk 	   data types */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|markdp
argument_list|(
name|hunk_items
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|markdp
argument_list|(
name|hunk_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|markdp
argument_list|(
name|hunk_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* next run up the name stack */
for|for
control|(
name|loop2
operator|=
name|np
operator|-
literal|1
init|;
name|loop2
operator|>=
name|orgnp
condition|;
operator|--
name|loop2
control|)
name|MARKVAL
argument_list|(
name|loop2
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* now the bindstack (vals only, atoms are marked elsewhere ) */
for|for
control|(
name|loop3
operator|=
name|bnp
operator|-
literal|1
init|;
name|loop3
operator|>=
name|orgbnp
condition|;
operator|--
name|loop3
control|)
name|MARKVAL
argument_list|(
name|loop3
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* next mark all compiler linked data */
comment|/* if the Vpurcopylits switch is non nil (lisp variable $purcopylits) 	 * then when compiled code is read in, it tables will not be linked 	 * into this table and thus will not be marked here.  That is ok 	 * though, since that data is assumed to be pure. 	 */
name|point
operator|=
name|bind_lists
expr_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|point
operator|)
operator|!=
operator|(
name|int
operator|*
operator|)
name|CNIL
condition|)
block|{
while|while
condition|(
operator|*
name|start
operator|!=
operator|-
literal|1
condition|)
block|{
name|markdp
argument_list|(
operator|(
name|lispval
operator|)
operator|*
name|start
argument_list|)
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
name|point
operator|=
operator|(
name|int
operator|*
operator|)
operator|*
operator|(
name|point
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* next mark all system-significant lisp data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGNIF
condition|;
operator|++
name|i
control|)
name|markdp
argument_list|(
operator|(
name|lispsys
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
name|vtimes
argument_list|(
operator|&
name|presweep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* all accessible data has now been marked. */
comment|/* all collectable spaces must be swept,    */
comment|/* and freelists constructed.		    */
comment|/* first clear the structure elements for types 	 * we will sweep 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|VECTORI
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|=
name|gcableptr
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|STRNG
operator|&&
operator|!
name|gcstrings
condition|)
block|{
comment|/* don't do anything*/
block|}
else|else
block|{
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|space_left
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|m_68k
name|fixbits
argument_list|(
name|bitmapi
operator|+
name|ATOLX
argument_list|(
name|beginsweep
argument_list|)
argument_list|,
name|bitmapi
operator|+
name|ATOLX
argument_list|(
name|datalim
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sweep up in memory looking at gcable pages */
for|for
control|(
name|start
operator|=
name|beginsweep
operator|,
name|bindex
operator|=
name|ATOLX
argument_list|(
name|start
argument_list|)
operator|,
name|pindex
operator|=
operator|&
name|purepage
index|[
name|ATOX
argument_list|(
name|start
argument_list|)
index|]
init|;
name|start
operator|<
operator|(
name|int
operator|*
operator|)
name|datalim
condition|;
name|start
operator|+=
literal|128
operator|,
name|pindex
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gcableptr
index|[
name|type
operator|=
name|TYPE
argument_list|(
name|start
argument_list|)
index|]
operator|)
operator|||
operator|*
name|pindex
ifdef|#
directive|ifdef
name|GCSTRINGS
operator|||
operator|(
name|type
operator|==
name|STRNG
operator|&&
operator|!
name|gcstrings
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* ignore this page but advance pointer 	*/
name|bindex
operator|+=
literal|4
expr_stmt|;
comment|/* and 4 words of 32 bit bitmap words */
continue|continue;
block|}
name|freecnt
operator|=
literal|0
expr_stmt|;
comment|/* number of free items found */
name|usedcnt
operator|=
literal|0
expr_stmt|;
comment|/* number of used items found */
name|point
operator|=
name|start
expr_stmt|;
comment|/* sweep dtprs as a special case, since 	     * 1) there will (usually) be more dtpr pages than any other type 	     * 2) most dtpr pages will be empty so we can really win by special 	     *    caseing the sweeping of massive numbers of free cells 	     */
comment|/* since sdot's have the same structure as dtprs, this code will 	       work for them too 	     */
if|if
condition|(
operator|(
name|type
operator|==
name|DTPR
operator|)
operator|||
operator|(
name|type
operator|==
name|SDOT
operator|)
condition|)
block|{
name|int
modifier|*
name|head
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|head
operator|=
operator|(
name|int
operator|*
operator|)
name|s
operator|->
name|next_free
expr_stmt|;
comment|/* first value on free list*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
comment|/* 4 bit map words per page  */
block|{
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
comment|/* 32 bits = 16 dtprs */
if|if
condition|(
name|bvalue
operator|==
literal|0
condition|)
comment|/* if all are free	*/
block|{
operator|*
name|point
operator|=
operator|(
name|int
operator|)
name|head
expr_stmt|;
name|lim
operator|=
name|point
operator|+
literal|32
expr_stmt|;
comment|/* 16 dtprs = 32 ints */
for|for
control|(
name|point
operator|+=
literal|2
init|;
name|point
operator|<
name|lim
condition|;
name|point
operator|+=
literal|2
control|)
block|{
operator|*
name|point
operator|=
call|(
name|int
call|)
argument_list|(
name|point
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|point
operator|-
literal|2
expr_stmt|;
name|freecnt
operator|+=
literal|16
expr_stmt|;
block|}
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|bvalue
operator|&
literal|1
operator|)
condition|)
block|{
name|freecnt
operator|++
expr_stmt|;
operator|*
name|point
operator|=
operator|(
name|int
operator|)
name|head
expr_stmt|;
name|head
operator|=
name|point
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|METER
comment|/* check if the page address of this cell is the 			 * same as the address of its cdr 			 */
elseif|else
if|if
condition|(
name|FALSE
operator|&&
name|gcstat
operator|&&
operator|(
name|type
operator|==
name|DTPR
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|point
operator|&
operator|~
literal|511
operator|)
operator|==
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|point
argument_list|)
operator|&
operator|~
literal|511
operator|)
condition|)
name|conssame
operator|++
expr_stmt|;
else|else
name|consdiff
operator|++
expr_stmt|;
name|usedcnt
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|usedcnt
operator|++
expr_stmt|;
comment|/* keep track of used */
name|point
operator|+=
literal|2
expr_stmt|;
name|bvalue
operator|=
name|bvalue
operator|>>
literal|2
expr_stmt|;
block|}
block|}
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|head
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|VECTOR
operator|)
operator|||
operator|(
name|type
operator|==
name|VECTORI
operator|)
condition|)
block|{
name|int
name|canjoin
init|=
name|FALSE
decl_stmt|;
name|int
modifier|*
name|tempp
decl_stmt|;
comment|/* check if first item on freelist ends exactly at 		   this page 		 */
if|if
condition|(
operator|(
operator|(
name|tempp
operator|=
operator|(
name|int
operator|*
operator|)
name|s
operator|->
name|next_free
operator|)
operator|!=
operator|(
name|int
operator|*
operator|)
name|CNIL
operator|)
operator|&&
operator|(
operator|(
name|VecTotSize
argument_list|(
operator|(
operator|(
name|lispval
operator|)
name|tempp
operator|)
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
literal|1
operator|+
name|tempp
operator|)
operator|==
name|point
operator|)
condition|)
name|canjoin
operator|=
name|TRUE
expr_stmt|;
comment|/* arbitrary sized vector sweeper */
comment|/* 		 * jump past first word since that is a size fixnum 		 * and second word since that is property word 		 */
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vector sweeping, start at 0x%x\n"
argument_list|,
name|point
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|30
expr_stmt|;
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
operator|>>
literal|2
expr_stmt|;
name|point
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|type_len
operator|=
name|point
index|[
name|VSizeOff
index|]
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"point: 0x%x, type_len %d\n"
argument_list|,
name|point
argument_list|,
name|type_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bvalue: 0x%x, bits: %d, bindex: 0x%x\n"
argument_list|,
name|bvalue
argument_list|,
name|bits
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
block|}
comment|/* get size of vector */
if|if
condition|(
operator|!
operator|(
name|bvalue
operator|&
literal|1
operator|)
condition|)
comment|/* if free */
block|{
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"free\n"
argument_list|)
expr_stmt|;
name|freecnt
operator|+=
name|type_len
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|canjoin
condition|)
block|{
comment|/* join by adjusting size of first vector */
operator|(
call|(
name|lispval
call|)
argument_list|(
name|s
operator|->
name|next_free
argument_list|)
operator|)
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
operator|+=
name|type_len
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"joined size: %d\n"
argument_list|,
operator|(
call|(
name|lispval
call|)
argument_list|(
name|s
operator|->
name|next_free
argument_list|)
operator|)
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* vectors are linked at the property word */
operator|*
operator|(
name|point
operator|-
literal|1
operator|)
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|point
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|canjoin
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|canjoin
operator|=
name|FALSE
expr_stmt|;
name|usedcnt
operator|+=
name|type_len
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
name|point
operator|+=
name|VecTotSize
argument_list|(
name|type_len
argument_list|)
expr_stmt|;
comment|/* we stop sweeping only when we reach a page 		       boundary since vectors can span pages 		     */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|point
operator|&
literal|511
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* reset the counters, we cannot predict how 			 * many pages we have crossed over 			 */
name|bindex
operator|=
name|ATOLX
argument_list|(
name|point
argument_list|)
expr_stmt|;
comment|/* these will be inced, so we must dec */
name|pindex
operator|=
operator|&
name|purepage
index|[
name|ATOX
argument_list|(
name|point
argument_list|)
index|]
operator|-
literal|1
expr_stmt|;
name|start
operator|=
name|point
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of vector sweep when point = 0x%x\n"
argument_list|,
name|point
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* must advance to next point and next value in bitmap. 		     * we add VecTotSize(type_len) + 2 to get us to the 0th 		     * entry in the next vector (beyond the size fixnum) 		     */
name|point
operator|+=
literal|2
expr_stmt|;
comment|/* point to next 0th entry */
if|if
condition|(
operator|(
name|bits
operator|-=
operator|(
name|VecTotSize
argument_list|(
name|type_len
argument_list|)
operator|+
literal|2
operator|)
operator|)
operator|>
literal|0
condition|)
name|bvalue
operator|=
name|bvalue
operator|>>
operator|(
name|VecTotSize
argument_list|(
name|type_len
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
else|else
block|{
name|bits
operator|=
operator|-
name|bits
expr_stmt|;
comment|/* must advance to next word in map */
name|bindex
operator|+=
name|bits
operator|/
literal|32
expr_stmt|;
comment|/* this is tricky stuff... */
name|bits
operator|=
name|bits
operator|%
literal|32
expr_stmt|;
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
operator|>>
name|bits
expr_stmt|;
name|bits
operator|=
literal|32
operator|-
name|bits
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* general sweeper, will work for all types */
name|itemstogo
operator|=
name|s
operator|->
name|space
expr_stmt|;
comment|/* number of items per page  */
name|bits
operator|=
literal|32
expr_stmt|;
comment|/* number of bits per word */
name|type_len
operator|=
name|s
operator|->
name|type_len
expr_stmt|;
comment|/* printf(" s %d, itemstogo %d, len %d\n",s,itemstogo,type_len);*/
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bvalue
operator|&
literal|1
operator|)
condition|)
comment|/* if data element is not marked */
block|{
name|freecnt
operator|++
expr_stmt|;
operator|*
name|point
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|point
expr_stmt|;
block|}
else|else
name|usedcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|itemstogo
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|type_len
operator|>=
literal|64
condition|)
block|{
name|bindex
operator|++
expr_stmt|;
if|if
condition|(
name|type_len
operator|>=
literal|128
condition|)
name|bindex
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
block|}
name|point
operator|+=
name|type_len
expr_stmt|;
comment|/* shift over mask by number of words in data type */
if|if
condition|(
operator|(
name|bits
operator|-=
name|type_len
operator|)
operator|>
literal|0
condition|)
block|{
name|bvalue
operator|=
name|bvalue
operator|>>
name|type_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
name|bits
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|bits
operator|=
operator|-
name|bits
expr_stmt|;
while|while
condition|(
name|bits
operator|>=
literal|32
condition|)
block|{
name|bindex
operator|++
expr_stmt|;
name|bits
operator|-=
literal|32
expr_stmt|;
block|}
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
name|bvalue
operator|=
name|bvalue
operator|>>
name|bits
expr_stmt|;
name|bits
operator|=
literal|32
operator|-
name|bits
expr_stmt|;
empty_stmt|;
block|}
block|}
block|}
name|s
operator|->
name|space_left
operator|+=
name|freecnt
expr_stmt|;
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|+=
name|usedcnt
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|METER
name|vtimes
argument_list|(
operator|&
name|alldone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcstat
condition|)
name|gcdump
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pagenorm
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * alloc  *  *  This routine tries to allocate one or more pages of the space named  *  by the first argument.   Returns the number of pages actually allocated.  *    */
end_comment

begin_function
name|lispval
name|alloc
parameter_list|(
name|tname
parameter_list|,
name|npages
parameter_list|)
name|lispval
name|tname
decl_stmt|;
name|long
name|npages
decl_stmt|;
block|{
name|long
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|struct
name|types
modifier|*
name|typeptr
decl_stmt|;
name|ii
operator|=
name|typenum
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|typeptr
operator|=
name|spaces
index|[
name|ii
index|]
expr_stmt|;
if|if
condition|(
name|npages
operator|<=
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|npages
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|ATOX
argument_list|(
name|datalim
argument_list|)
operator|)
operator|+
name|npages
operator|>
name|TTSIZE
condition|)
name|error
argument_list|(
literal|"Space request would exceed maximum memory allocation"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ii
operator|==
name|VECTOR
operator|)
operator|||
operator|(
name|ii
operator|==
name|VECTORI
operator|)
condition|)
block|{
comment|/* allocate in one big chunk */
name|tname
operator|=
name|csegment
argument_list|(
operator|(
name|int
operator|)
name|ii
argument_list|,
operator|(
name|int
operator|)
name|npages
operator|*
literal|128
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tname
operator|->
name|vl
operator|.
name|vectorl
index|[
literal|0
index|]
operator|=
operator|(
name|npages
operator|*
literal|512
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
expr_stmt|;
name|tname
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|=
operator|(
name|lispval
operator|)
name|typeptr
operator|->
name|next_free
expr_stmt|;
name|typeptr
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|tname
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alloced %d vec pages\n"
argument_list|,
name|npages
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|npages
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|npages
condition|;
operator|++
name|jj
control|)
if|if
condition|(
name|get_more_space
argument_list|(
name|spaces
index|[
name|ii
index|]
argument_list|,
name|FALSE
argument_list|)
condition|)
break|break;
return|return
operator|(
name|inewint
argument_list|(
name|jj
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * csegment(typecode,nitems,useholeflag)  *  allocate nitems of type typecode.  If useholeflag is true, then  * allocate in the hole if there is room.  This routine doesn't look  * in the free lists, it always allocates space.  */
end_comment

begin_function
name|lispval
name|csegment
parameter_list|(
name|typecode
parameter_list|,
name|nitems
parameter_list|,
name|useholeflag
parameter_list|)
block|{
specifier|register
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
specifier|register
name|char
modifier|*
name|charadd
decl_stmt|;
name|ii
operator|=
name|typecode
expr_stmt|;
if|if
condition|(
name|ii
operator|!=
name|OTHER
condition|)
name|nitems
operator|*=
literal|4
operator|*
name|spaces
index|[
name|ii
index|]
operator|->
name|type_len
expr_stmt|;
name|nitems
operator|=
name|roundup
argument_list|(
name|nitems
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/*  round up to right length  */
ifdef|#
directive|ifdef
name|HOLE
if|if
condition|(
name|useholeflag
condition|)
name|charadd
operator|=
name|gethspace
argument_list|(
name|nitems
argument_list|,
name|ii
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|charadd
operator|=
name|sbrk
argument_list|(
name|nitems
argument_list|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|charadd
operator|+
name|nitems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|charadd
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"NOT ENOUGH SPACE FOR ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*if(ii!=OTHER)*/
operator|(
operator|*
name|spaces
index|[
name|ii
index|]
operator|->
name|pages
operator|)
operator|->
name|i
operator|+=
name|nitems
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|ATOX
argument_list|(
name|datalim
argument_list|)
operator|>
name|fakettsize
condition|)
block|{
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|OFFSET
operator|+
operator|(
name|fakettsize
operator|<<
literal|9
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakettsize
operator|>=
name|TTSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"There isn't room enough to continue, goodbye\n"
argument_list|)
expr_stmt|;
name|franzexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fakettsize
operator|++
expr_stmt|;
name|badmem
argument_list|(
literal|53
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nitems
condition|;
name|jj
operator|=
name|jj
operator|+
literal|512
control|)
block|{
name|SETTYPE
argument_list|(
name|charadd
operator|+
name|jj
argument_list|,
name|ii
argument_list|,
literal|30
argument_list|)
expr_stmt|;
block|}
name|ii
operator|=
operator|(
name|int
operator|)
name|charadd
expr_stmt|;
while|while
condition|(
name|nitems
operator|>
name|MAXCLEAR
condition|)
block|{
name|blzero
argument_list|(
name|ii
argument_list|,
name|MAXCLEAR
argument_list|)
expr_stmt|;
name|nitems
operator|-=
name|MAXCLEAR
expr_stmt|;
name|ii
operator|+=
name|MAXCLEAR
expr_stmt|;
block|}
name|blzero
argument_list|(
name|ii
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|charadd
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csizeof
parameter_list|(
name|tname
parameter_list|)
name|lispval
name|tname
decl_stmt|;
block|{
return|return
operator|(
name|spaces
index|[
name|typenum
argument_list|(
name|tname
argument_list|)
index|]
operator|->
name|type_len
operator|*
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|int
name|typenum
parameter_list|(
name|tname
parameter_list|)
name|lispval
name|tname
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|;
name|chek
label|:
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|NUMSPACES
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|spaces
index|[
name|ii
index|]
operator|&&
name|tname
operator|==
operator|*
operator|(
name|spaces
index|[
name|ii
index|]
operator|->
name|type_name
operator|)
condition|)
break|break;
if|if
condition|(
name|ii
operator|==
name|NUMSPACES
condition|)
block|{
name|tname
operator|=
name|error
argument_list|(
literal|"BAD TYPE NAME"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
name|ii
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gethspace
parameter_list|(
name|segsiz
parameter_list|,
name|type
parameter_list|)
block|{
extern|extern usehole;
specifier|extern
name|char
name|holend
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|curhbeg
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|usehole
condition|)
block|{
name|curhbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|roundup
argument_list|(
operator|(
operator|(
name|int
operator|)
name|curhbeg
operator|)
argument_list|,
name|LBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|holend
operator|-
name|curhbeg
operator|)
operator|<
name|segsiz
condition|)
block|{
name|usehole
operator|=
name|FALSE
expr_stmt|;
name|curhbeg
operator|=
name|holend
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|curhbeg
expr_stmt|;
name|curhbeg
operator|=
name|curhbeg
operator|+
name|segsiz
expr_stmt|;
comment|/*printf("start %d, finish %d, size %d\n",value, curhbeg,segsiz);*/
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
name|value
operator|=
operator|(
name|ysbrk
argument_list|(
name|segsiz
operator|/
name|LBPG
argument_list|,
name|type
argument_list|)
operator|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|value
operator|+
name|segsiz
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_macro
name|gcrebear
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HOLE
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|types
modifier|*
name|p
decl_stmt|;
comment|/* this gets done upon rebirth */
name|str_current
index|[
literal|1
index|]
operator|.
name|space_left
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|GCSTRINGS
name|str_current
index|[
literal|0
index|]
operator|.
name|space_left
operator|=
literal|0
expr_stmt|;
comment|/* both kinds of strings go in hole*/
endif|#
directive|endif
name|funct_str
operator|.
name|space_left
operator|=
literal|0
expr_stmt|;
name|funct_str
operator|.
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
comment|/* clear pure space pointers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMSPACES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|=
name|spaces
index|[
name|i
index|]
condition|)
name|p
operator|->
name|next_pure_free
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/** markit(p) ***********************************************************/
end_comment

begin_comment
comment|/*  just calls markdp							*/
end_comment

begin_macro
name|markit
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|lispval
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|markdp
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * markdp(p)  *  *  markdp is the routine which marks each data item.  If it is a  *  dotted pair, the car and cdr are marked also.  *  An iterative method is used to mark list structure, to avoid  *  excessive recursion.  */
end_comment

begin_expr_stmt
name|markdp
argument_list|(
name|p
argument_list|)
specifier|register
name|lispval
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|tahoe
specifier|register
name|int
name|r
decl_stmt|,
name|s
decl_stmt|;
comment|/* (goes with non-asm readbit, oksetbit) */
endif|#
directive|endif
comment|/*	register hsize, hcntr;						 */
name|int
name|hsize
decl_stmt|,
name|hcntr
decl_stmt|;
ifdef|#
directive|ifdef
name|METER
name|mrkdpcnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|ptr_loop
label|:
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|p
operator|)
operator|<=
operator|(
operator|(
name|int
operator|)
name|nil
operator|)
condition|)
return|return;
comment|/*  do not mark special data types or nil=0  */
switch|switch
condition|(
name|TYPE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|ftstbit
expr_stmt|;
name|MARKVAL
argument_list|(
name|p
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
name|MARKVAL
argument_list|(
name|p
operator|->
name|a
operator|.
name|plist
argument_list|)
expr_stmt|;
name|MARKVAL
argument_list|(
name|p
operator|->
name|a
operator|.
name|fnbnd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GCSTRINGS
if|if
condition|(
name|gcstrings
condition|)
name|MARKVAL
argument_list|(
operator|(
operator|(
name|lispval
operator|)
name|p
operator|->
name|a
operator|.
name|pname
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRNG
case|:
name|p
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|p
operator|)
operator|&
operator|~
operator|(
name|LBPG
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ftstbit
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
name|INT
case|:
case|case
name|DOUB
case|:
name|ftstbit
expr_stmt|;
return|return;
case|case
name|VALUE
case|:
name|ftstbit
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|l
expr_stmt|;
goto|goto
name|ptr_loop
goto|;
case|case
name|DTPR
case|:
name|ftstbit
expr_stmt|;
name|MARKVAL
argument_list|(
name|p
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
comment|/* if we are metering , then check if the cdr is 			 * nil, or if the cdr is on the same page, and if 			 * it isn't one of those, then it is on a different 			 * page 			 */
if|if
condition|(
name|gcstat
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
name|consnil
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|p
operator|&
operator|~
literal|511
operator|)
operator|==
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|d
operator|.
name|cdr
argument_list|)
operator|)
operator|&
operator|~
literal|511
operator|)
condition|)
name|conssame
operator|++
expr_stmt|;
else|else
name|consdiff
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|p
operator|=
name|p
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
goto|goto
name|ptr_loop
goto|;
case|case
name|ARRAY
case|:
name|ftstbit
expr_stmt|;
comment|/* mark array itself */
name|MARKVAL
argument_list|(
name|p
operator|->
name|ar
operator|.
name|accfun
argument_list|)
expr_stmt|;
comment|/* mark access function */
name|MARKVAL
argument_list|(
name|p
operator|->
name|ar
operator|.
name|aux
argument_list|)
expr_stmt|;
comment|/* mark aux data */
name|MARKVAL
argument_list|(
name|p
operator|->
name|ar
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* mark length */
name|MARKVAL
argument_list|(
name|p
operator|->
name|ar
operator|.
name|delta
argument_list|)
expr_stmt|;
comment|/* mark delta */
if|if
condition|(
name|TYPE
argument_list|(
name|p
operator|->
name|ar
operator|.
name|aux
argument_list|)
operator|==
name|DTPR
operator|&&
name|p
operator|->
name|ar
operator|.
name|aux
operator|->
name|d
operator|.
name|car
operator|==
name|Vnogbar
condition|)
block|{
comment|/* a non garbage collected array must have its 			     * array space marked but the value of the array 			     * space is not marked 			     */
name|int
name|l
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|debugin
condition|)
block|{
name|printf
argument_list|(
literal|"mark array holders len %d, del %d, start 0x%x\n"
argument_list|,
name|p
operator|->
name|ar
operator|.
name|length
operator|->
name|i
argument_list|,
name|p
operator|->
name|ar
operator|.
name|delta
operator|->
name|i
argument_list|,
name|p
operator|->
name|ar
operator|.
name|data
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|p
operator|->
name|ar
operator|.
name|length
operator|->
name|i
expr_stmt|;
comment|/* number of elements */
name|d
operator|=
name|p
operator|->
name|ar
operator|.
name|delta
operator|->
name|i
expr_stmt|;
comment|/* bytes per element  */
name|p
operator|=
operator|(
name|lispval
operator|)
name|p
operator|->
name|ar
operator|.
name|data
expr_stmt|;
comment|/* address of first one*/
if|if
condition|(
name|purepage
index|[
name|ATOX
argument_list|(
name|p
argument_list|)
index|]
condition|)
return|return;
for|for
control|(
operator|(
name|cnt
operator|=
literal|0
operator|)
init|;
name|cnt
operator|<
name|l
condition|;
name|p
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|+
name|d
argument_list|)
operator|,
name|cnt
operator|++
control|)
block|{
name|setbit
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*			register int i, l; int d;		*/
comment|/*			register char *dataptr = p->ar.data;	*/
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|d
decl_stmt|;
name|char
modifier|*
name|dataptr
init|=
name|p
operator|->
name|ar
operator|.
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
name|p
operator|->
name|ar
operator|.
name|length
operator|->
name|i
operator|,
name|d
operator|=
name|p
operator|->
name|ar
operator|.
name|delta
operator|->
name|i
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
name|markdp
argument_list|(
operator|(
name|lispval
operator|)
name|dataptr
argument_list|)
expr_stmt|;
name|dataptr
operator|+=
name|d
expr_stmt|;
block|}
block|}
return|return;
case|case
name|SDOT
case|:
do|do
block|{
name|ftstbit
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|0
condition|)
do|;
return|return;
case|case
name|BCD
case|:
name|ftstbit
expr_stmt|;
name|markdp
argument_list|(
name|p
operator|->
name|bcd
operator|.
name|discipline
argument_list|)
expr_stmt|;
return|return;
case|case
name|HUNK2
case|:
case|case
name|HUNK4
case|:
case|case
name|HUNK8
case|:
case|case
name|HUNK16
case|:
case|case
name|HUNK32
case|:
case|case
name|HUNK64
case|:
case|case
name|HUNK128
case|:
block|{
name|hsize
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ftstbit
expr_stmt|;
for|for
control|(
name|hcntr
operator|=
literal|0
init|;
name|hcntr
operator|<
name|hsize
condition|;
name|hcntr
operator|++
control|)
name|MARKVAL
argument_list|(
name|p
operator|->
name|h
operator|.
name|hunk
index|[
name|hcntr
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|VECTORI
case|:
name|ftstbit
expr_stmt|;
name|MARKVAL
argument_list|(
name|p
operator|->
name|v
operator|.
name|vector
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* mark property */
return|return;
case|case
name|VECTOR
case|:
block|{
specifier|register
name|int
name|vsize
decl_stmt|;
name|ftstbit
expr_stmt|;
name|vsize
operator|=
name|VecSize
argument_list|(
name|p
operator|->
name|vl
operator|.
name|vectorl
index|[
name|VSizeOff
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mark vect at %x  size %d\n"
argument_list|,
name|p
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|vsize
operator|>=
operator|-
literal|1
condition|)
block|{
name|MARKVAL
argument_list|(
name|p
operator|->
name|v
operator|.
name|vector
index|[
name|vsize
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return;
block|}
block|}
return|return;
block|}
end_block

begin_comment
comment|/* xsbrk allocates space in large chunks (currently 16 pages)  * xsbrk(1)  returns a pointer to a page  * xsbrk(0)  returns a pointer to the next page we will allocate (like sbrk(0))  */
end_comment

begin_function
name|char
modifier|*
name|xsbrk
parameter_list|(
name|n
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|xx
decl_stmt|;
comment|/*  pointer to next available blank page  */
specifier|extern
name|int
name|xcycle
decl_stmt|;
comment|/*  number of blank pages available  */
name|lispval
name|u
decl_stmt|;
comment|/*  used to compute limits of bit table  */
if|if
condition|(
operator|(
name|xcycle
operator|--
operator|)
operator|<=
literal|0
condition|)
block|{
name|xcycle
operator|=
literal|15
expr_stmt|;
name|xx
operator|=
name|sbrk
argument_list|(
literal|16
operator|*
name|LBPG
argument_list|)
expr_stmt|;
comment|/*  get pages 16 at a time  */
if|if
condition|(
operator|(
name|int
operator|)
name|xx
operator|==
operator|-
literal|1
condition|)
name|lispend
argument_list|(
literal|"For sbrk from lisp: no space... Goodbye!"
argument_list|)
expr_stmt|;
block|}
else|else
name|xx
operator|+=
name|LBPG
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|xcycle
operator|++
expr_stmt|;
comment|/* don't allocate the page */
name|xx
operator|-=
name|LBPG
expr_stmt|;
return|return
operator|(
name|xx
operator|)
return|;
comment|/* just return its address */
block|}
if|if
condition|(
operator|(
name|u
operator|=
call|(
name|lispval
call|)
argument_list|(
name|xx
operator|+
name|LBPG
argument_list|)
operator|)
operator|>
name|datalim
condition|)
name|datalim
operator|=
name|u
expr_stmt|;
return|return
operator|(
name|xx
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ysbrk
parameter_list|(
name|pages
parameter_list|,
name|type
parameter_list|)
name|int
name|pages
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|xx
decl_stmt|;
comment|/*  will point to block of storage  */
name|int
name|i
decl_stmt|;
name|xx
operator|=
name|sbrk
argument_list|(
name|pages
operator|*
name|LBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|xx
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"OUT OF SPACE FOR ARRAY REQUEST"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|xx
operator|+
name|pages
operator|*
name|LBPG
argument_list|)
expr_stmt|;
comment|/*  compute bit table limit  */
comment|/*  set type for pages  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
operator|++
name|i
control|)
block|{
name|SETTYPE
argument_list|(
operator|(
name|xx
operator|+
name|i
operator|*
name|LBPG
operator|)
argument_list|,
name|type
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|xx
operator|)
return|;
comment|/*  return pointer to block of storage  */
block|}
end_function

begin_comment
comment|/*  * getatom   * returns either an existing atom with the name specified in strbuf, or  * if the atom does not already exist, regurgitates a new one and   * returns it.  */
end_comment

begin_function
name|lispval
name|getatom
parameter_list|(
name|purep
parameter_list|)
block|{
specifier|register
name|lispval
name|aptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|endname
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
name|lispval
name|b
decl_stmt|;
name|char
name|c
decl_stmt|;
name|name
operator|=
name|strbuf
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
operator|(
name|char
operator|)
literal|0377
condition|)
return|return
operator|(
name|eofa
operator|)
return|;
name|hash
operator|=
name|hashfcn
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|atmlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|hasht
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
name|CNIL
condition|)
comment|/* if (strcmp(name,aptr->a.pname)==0) */
if|if
condition|(
operator|*
name|name
operator|==
operator|*
name|aptr
operator|->
name|a
operator|.
name|pname
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|aptr
operator|->
name|a
operator|.
name|pname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|aptr
operator|)
return|;
else|else
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|aptr
operator|->
name|a
operator|.
name|hshlnk
expr_stmt|;
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|newatom
argument_list|(
name|purep
argument_list|)
expr_stmt|;
comment|/*share pname of atoms on oblist*/
name|aptr
operator|->
name|a
operator|.
name|hshlnk
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
name|hasht
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|aptr
expr_stmt|;
name|endname
operator|=
name|name
operator|+
name|atmlen
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|atmlen
operator|!=
literal|4
operator|)
operator|&&
operator|(
operator|*
name|name
operator|==
literal|'c'
operator|)
operator|&&
operator|(
operator|*
name|endname
operator|==
literal|'r'
operator|)
condition|)
block|{
name|b
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|lambda
expr_stmt|;
name|b
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|newdot
argument_list|()
expr_stmt|;
operator|(
name|b
operator|->
name|d
operator|.
name|car
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|xatom
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|b
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
operator|++
name|name
operator|==
name|endname
condition|)
block|{
name|b
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|lispval
operator|)
name|xatom
expr_stmt|;
name|aptr
operator|->
name|a
operator|.
name|fnbnd
operator|=
operator|(
operator|--
name|np
operator|)
operator|->
name|val
expr_stmt|;
break|break;
block|}
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|)
operator|==
literal|'a'
condition|)
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|cara
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|cdra
expr_stmt|;
else|else
block|{
operator|--
name|np
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|aptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inewatom is like getatom, except that you provide it a string  * to be used as the print name.  It doesn't do the automagic  * creation of things of the form c[ad]*r.  */
end_comment

begin_function
name|lispval
name|inewatom
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|atom
modifier|*
name|aptr
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
specifier|extern
name|struct
name|types
name|atom_str
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
operator|(
name|char
operator|)
literal|0377
condition|)
return|return
operator|(
name|eofa
operator|)
return|;
name|hash
operator|=
name|hashfcn
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|aptr
operator|->
name|pname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|aptr
operator|)
return|;
else|else
name|aptr
operator|=
name|aptr
operator|->
name|hshlnk
expr_stmt|;
name|aptr
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|next_one
argument_list|(
operator|&
name|atom_str
argument_list|)
expr_stmt|;
name|aptr
operator|->
name|plist
operator|=
name|aptr
operator|->
name|fnbnd
operator|=
name|nil
expr_stmt|;
name|aptr
operator|->
name|clb
operator|=
name|CNIL
expr_stmt|;
name|aptr
operator|->
name|pname
operator|=
name|name
expr_stmt|;
name|aptr
operator|->
name|hshlnk
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
name|hasht
index|[
name|hash
index|]
operator|=
name|aptr
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|aptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* our hash function */
end_comment

begin_expr_stmt
name|hashfcn
argument_list|(
name|symb
argument_list|)
specifier|register
name|char
operator|*
name|symb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*	for (i=0 ; *symb ; i += i + *symb++); return(i& (HASHTOP-1)); */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|symb
condition|;
name|i
operator|+=
name|i
operator|*
literal|2
operator|+
operator|*
name|symb
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|&
literal|077777
operator|%
name|HASHTOP
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|LImemory
parameter_list|()
block|{
name|int
name|nextadr
decl_stmt|,
name|pagesinuse
decl_stmt|;
name|printf
argument_list|(
literal|"Memory report. max pages = %d (0x%x) = %d Bytes\n"
argument_list|,
name|TTSIZE
argument_list|,
name|TTSIZE
argument_list|,
name|TTSIZE
operator|*
name|LBPG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOLE
name|printf
argument_list|(
literal|"This lisp has a hole:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  current hole start: %d (0x%x), end %d (0x%x)\n"
argument_list|,
name|curhbeg
argument_list|,
name|curhbeg
argument_list|,
name|holend
argument_list|,
name|holend
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  hole free: %d bytes = %d pages\n\n"
argument_list|,
name|holend
operator|-
name|curhbeg
argument_list|,
operator|(
name|holend
operator|-
name|curhbeg
operator|)
operator|/
name|LBPG
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nextadr
operator|=
operator|(
name|int
operator|)
name|xsbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* next space to be allocated */
name|pagesinuse
operator|=
name|nextadr
operator|/
name|LBPG
expr_stmt|;
name|printf
argument_list|(
literal|"Next allocation at addr %d (0x%x) = page %d\n"
argument_list|,
name|nextadr
argument_list|,
name|nextadr
argument_list|,
name|pagesinuse
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Free data pages: %d\n"
argument_list|,
name|TTSIZE
operator|-
name|pagesinuse
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|atom
modifier|*
name|hasht
index|[
name|HASHTOP
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|myhook
argument_list|()
end_macro

begin_block
block|{}
end_block

end_unit

