begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that this notice is preserved and that due credit is given  * to the University of California at Berkeley. The name of the University  * may not be used to endorse or promote products derived from this  * software without specific prior written permission. This software  * is provided ``as is'' without express or implied warranty.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sys_dos.c	1.3 (Berkeley) 3/8/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SO_OOBINLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SO_OOBINLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(SO_OOBINLINE) */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * MSDOS doesn't have anyway of deciding whether a full-edited line  * is ready to be read in, so we need to do character-by-character  * reads, and then do the editing in the program (in the case where  * we are supporting line-by-line mode).  *  * The following routines, which are internal to the MSDOS-specific  * code, accomplish this miracle.  */
end_comment

begin_define
define|#
directive|define
name|Hex
parameter_list|(
name|c
parameter_list|)
value|HEX[(c)&0xff]
end_define

begin_expr_stmt
specifier|static
name|survivorSetup
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Do we have ^C hooks in? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lineend
init|=
literal|0
decl_stmt|,
comment|/* There is a line terminator */
name|ctrlCCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|linein
index|[
literal|200
index|]
decl_stmt|,
comment|/* Where input line is assembled */
modifier|*
name|nextin
init|=
name|linein
decl_stmt|,
comment|/* Next input character */
modifier|*
name|nextout
init|=
name|linein
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next character to be consumed */
end_comment

begin_decl_stmt
specifier|static
name|char
name|savedInState
decl_stmt|,
name|savedOutState
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|consumechar
parameter_list|()
define|\
value|if ((++nextout)>= nextin) { \ 	nextout = nextin = linein; \ 	lineend = 0; \     }
end_define

begin_define
define|#
directive|define
name|characteratatime
parameter_list|()
value|(!MODE_LINE(globalmode))
end_define

begin_comment
comment|/* one by one */
end_comment

begin_comment
comment|/*  * killone()  *  *  Erase the last character on the line.  */
end_comment

begin_function
specifier|static
name|void
name|killone
parameter_list|()
block|{
if|if
condition|(
name|lineend
condition|)
block|{
return|return;
comment|/* ??? XXX */
block|}
if|if
condition|(
name|nextin
operator|==
name|linein
condition|)
block|{
return|return;
comment|/* Nothing to do */
block|}
name|nextin
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|isspace
argument_list|(
operator|*
name|nextin
argument_list|)
operator|||
name|isprint
argument_list|(
operator|*
name|nextin
argument_list|)
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setlineend()  *  *  Decide if it's time to send the current line up to the user  * process.  */
end_comment

begin_function
specifier|static
name|void
name|setlineend
parameter_list|()
block|{
if|if
condition|(
name|nextin
operator|==
name|nextout
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|characteratatime
argument_list|()
condition|)
block|{
name|lineend
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextin
operator|>=
operator|(
name|linein
operator|+
sizeof|sizeof
name|linein
operator|)
condition|)
block|{
name|lineend
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
operator|*
operator|(
name|nextin
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|termIntChar
operator|)
operator|||
operator|(
name|c
operator|==
name|termQuitChar
operator|)
operator|||
operator|(
name|c
operator|==
name|termEofChar
operator|)
condition|)
block|{
name|lineend
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|termFlushChar
condition|)
block|{
name|lineend
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|lineend
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Otherwise, leave it alone (reset by 'consumechar') */
block|}
end_function

begin_comment
comment|/*  * OK, what we do here is:  *  *   o  If we are echoing, then  *	o  Look for character erase, line kill characters  *	o  Echo the character (using '^' if a control character)  *   o  Put the character in the input buffer  *   o  Set 'lineend' as necessary  */
end_comment

begin_function
specifier|static
name|void
name|DoNextChar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
comment|/* Character to process */
block|{
specifier|static
name|char
name|literalnextcharacter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nextin
operator|>=
operator|(
name|linein
operator|+
sizeof|sizeof
name|linein
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\7'
argument_list|)
expr_stmt|;
comment|/* Ring bell */
name|setlineend
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
comment|/* Look for some special character */
if|if
condition|(
operator|!
name|literalnextcharacter
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|termEraseChar
condition|)
block|{
name|killone
argument_list|()
expr_stmt|;
name|setlineend
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|termKillChar
condition|)
block|{
while|while
condition|(
name|nextin
operator|!=
name|linein
condition|)
block|{
name|killone
argument_list|()
expr_stmt|;
block|}
name|setlineend
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|termLiteralNextChar
condition|)
block|{
name|literalnextcharacter
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|MODE_LOCAL_ECHO
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|literalnextcharacter
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
operator|^
literal|0x40
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|literalnextcharacter
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nextin
operator|++
operator|=
name|c
expr_stmt|;
name|setlineend
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|inputExists
parameter_list|()
block|{
name|int
name|input
decl_stmt|;
specifier|static
name|state
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ctrlCCount
condition|)
block|{
name|DoNextChar
argument_list|(
literal|0x03
argument_list|)
expr_stmt|;
name|ctrlCCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|lineend
condition|)
block|{
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|1
comment|/* For BIOS variety of calls */
if|if
condition|(
name|kbhit
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|lineend
return|;
block|}
name|input
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* MSC - get console character */
if|if
condition|(
operator|(
name|input
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
name|DoNextChar
argument_list|(
literal|0x01
argument_list|)
expr_stmt|;
comment|/* ^A */
block|}
else|else
block|{
name|DoNextChar
argument_list|(
name|input
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 0 */
if|if
condition|(
operator|(
name|input
operator|=
name|dirconio
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|lineend
return|;
block|}
if|if
condition|(
operator|(
name|input
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|input
operator|&
literal|0xff00
operator|)
operator|==
literal|0x0300
condition|)
block|{
comment|/* Null */
name|DoNextChar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DoNextChar
argument_list|(
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|&
literal|0x8000
condition|)
block|{
name|DoNextChar
argument_list|(
literal|0x01
argument_list|)
expr_stmt|;
name|DoNextChar
argument_list|(
operator|(
name|input
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DoNextChar
argument_list|(
operator|(
name|input
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DoNextChar
argument_list|(
name|input
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 0 */
return|return
name|lineend
return|;
block|}
end_function

begin_function
name|void
name|CtrlCInterrupt
parameter_list|()
block|{
if|if
condition|(
operator|!
name|MODE_COMMAND_LINE
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
name|char
name|far
modifier|*
name|Bios_Break
init|=
operator|(
name|char
name|far
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
literal|0x40
operator|<<
literal|16
operator|)
operator||
literal|0x71
operator|)
decl_stmt|;
name|ctrlCCount
operator|++
expr_stmt|;
comment|/* XXX */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CtrlCInterrupt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeallsockets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dosbinary
parameter_list|(
name|fd
parameter_list|,
name|onoff
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
name|onoff
decl_stmt|;
block|{
name|union
name|REGS
name|regs
decl_stmt|;
name|int
name|oldstate
decl_stmt|;
comment|/* Get old stuff */
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x44
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|fd
expr_stmt|;
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
name|oldstate
operator|=
name|regs
operator|.
name|h
operator|.
name|dl
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* Save state */
comment|/* Set correct bits in new mode */
name|regs
operator|.
name|h
operator|.
name|dh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|regs
operator|.
name|h
operator|.
name|dl
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
block|}
else|else
block|{
name|regs
operator|.
name|h
operator|.
name|dl
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
comment|/* Set in new mode */
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x44
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|1
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|fd
expr_stmt|;
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|oldstate
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The MSDOS routines, called from elsewhere.  */
end_comment

begin_function
name|int
name|TerminalAutoFlush
parameter_list|()
comment|/* MSDOS */
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|TerminalCanRead
parameter_list|()
block|{
return|return
name|inputExists
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * Flush output to the terminal  */
end_comment

begin_function
name|void
name|TerminalFlushOutput
parameter_list|()
comment|/* MSDOS */
block|{ }
end_function

begin_function
name|void
name|TerminalNewMode
parameter_list|(
name|fd_in
parameter_list|,
name|fd_out
parameter_list|,
name|f
parameter_list|)
comment|/* MSDOS */
name|int
name|fd_in
decl_stmt|,
name|fd_out
decl_stmt|;
comment|/* File descriptors */
specifier|register
name|int
name|f
decl_stmt|;
block|{
name|union
name|REGS
name|inregs
decl_stmt|;
name|struct
name|SREGS
name|segregs
decl_stmt|;
specifier|static
name|old_1b_offset
operator|=
literal|0
operator|,
name|old_1b_segment
operator|=
literal|0
expr_stmt|;
name|globalmode
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|MODE_COMMAND_LINE
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_1b_segment
operator||
name|old_1b_offset
condition|)
block|{
name|inregs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x25
expr_stmt|;
name|inregs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x1b
expr_stmt|;
name|inregs
operator|.
name|x
operator|.
name|dx
operator|=
name|old_1b_offset
expr_stmt|;
name|segregs
operator|.
name|ds
operator|=
name|old_1b_segment
expr_stmt|;
name|intdosx
argument_list|(
operator|&
name|inregs
argument_list|,
operator|&
name|inregs
argument_list|,
operator|&
name|segregs
argument_list|)
expr_stmt|;
name|old_1b_segment
operator|=
name|old_1b_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|setmode
argument_list|(
name|fd_out
argument_list|,
name|O_TEXT
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ExitPerror
argument_list|(
literal|"setmode (text)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|setmode
argument_list|(
name|fd_out
argument_list|,
name|O_TEXT
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ExitPerror
argument_list|(
literal|"setmode (text)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CtrlCInterrupt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_1b_segment
operator||
name|old_1b_offset
operator|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|void
name|iret_subr
parameter_list|()
function_decl|;
name|void
function_decl|(
name|far
modifier|*
name|foo_subr
function_decl|)
parameter_list|()
init|=
name|iret_subr
function_decl|;
name|inregs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x35
expr_stmt|;
name|inregs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x1b
expr_stmt|;
name|intdosx
argument_list|(
operator|&
name|inregs
argument_list|,
operator|&
name|inregs
argument_list|,
operator|&
name|segregs
argument_list|)
expr_stmt|;
name|old_1b_segment
operator|=
name|segregs
operator|.
name|es
expr_stmt|;
name|old_1b_offset
operator|=
name|inregs
operator|.
name|x
operator|.
name|bx
expr_stmt|;
name|inregs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x25
expr_stmt|;
name|inregs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x1b
expr_stmt|;
name|inregs
operator|.
name|x
operator|.
name|dx
operator|=
name|FP_OFF
argument_list|(
name|foo_subr
argument_list|)
expr_stmt|;
name|segregs
operator|.
name|ds
operator|=
name|FP_SEG
argument_list|(
name|foo_subr
argument_list|)
expr_stmt|;
name|intdosx
argument_list|(
operator|&
name|inregs
argument_list|,
operator|&
name|inregs
argument_list|,
operator|&
name|segregs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|setmode
argument_list|(
name|fd_out
argument_list|,
name|O_TEXT
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ExitPerror
argument_list|(
literal|"setmode (text)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|setmode
argument_list|(
name|fd_in
argument_list|,
name|O_TEXT
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ExitPerror
argument_list|(
literal|"setmode (text)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|setmode
argument_list|(
name|fd_out
argument_list|,
name|O_BINARY
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ExitPerror
argument_list|(
literal|"setmode (binary)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|setmode
argument_list|(
name|fd_in
argument_list|,
name|O_BINARY
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ExitPerror
argument_list|(
literal|"setmode (binary)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|TerminalRead
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|count
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|inputExists
argument_list|()
operator|&&
operator|(
name|done
operator|<
name|count
operator|)
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
operator|*
name|nextout
expr_stmt|;
name|consumechar
argument_list|()
expr_stmt|;
name|done
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
block|{
return|return
operator|(
name|done
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|TerminalSaveState
parameter_list|()
comment|/* MSDOS */
block|{
name|termEofChar
operator|=
literal|'\4'
expr_stmt|;
name|termEraseChar
operator|=
literal|'\10'
expr_stmt|;
name|termFlushChar
operator|=
literal|'\17'
expr_stmt|;
name|termIntChar
operator|=
literal|'\3'
expr_stmt|;
name|termKillChar
operator|=
literal|'\25'
expr_stmt|;
name|termLiteralNextChar
operator|=
literal|'\26'
expr_stmt|;
name|termQuitChar
operator|=
literal|'\0'
expr_stmt|;
empty_stmt|;
name|savedInState
operator|=
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|savedOutState
operator|=
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|TerminalSpecialChars
parameter_list|(
name|c
parameter_list|)
comment|/* MSDOS */
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|TerminalRestoreState
parameter_list|()
comment|/* MSDOS */
block|{
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|savedInState
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dosbinary
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|savedOutState
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|TerminalWrite
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|count
parameter_list|)
comment|/* MSDOS */
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
return|return
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|count
argument_list|,
name|stdout
argument_list|)
return|;
comment|/* XXX */
block|}
end_function

begin_function
name|int
name|NetClose
parameter_list|(
name|fd
parameter_list|)
block|{
return|return
name|closesocket
argument_list|(
name|fd
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|NetNonblockingIO
parameter_list|(
name|fd
parameter_list|,
name|onoff
parameter_list|)
comment|/* MSDOS */
name|int
name|fd
decl_stmt|,
name|onoff
decl_stmt|;
block|{
if|if
condition|(
name|SetSockOpt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_NONBLOCKING
argument_list|,
name|onoff
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"setsockop (SO_NONBLOCKING) "
argument_list|)
expr_stmt|;
name|ExitString
argument_list|(
name|stderr
argument_list|,
literal|"exiting\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|NetSigIO
parameter_list|(
name|fd
parameter_list|)
comment|/* MSDOS */
name|int
name|fd
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|NetSetPgrp
parameter_list|(
name|fd
parameter_list|)
comment|/* MSDOS */
name|int
name|fd
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(MSDOS) */
end_comment

end_unit

