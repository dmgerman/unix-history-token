begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that this notice is preserved and that due credit is given  * to the University of California at Berkeley. The name of the University  * may not be used to endorse or promote products derived from this  * software without specific prior written permission. This software  * is provided ``as is'' without express or implied warranty.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)telnet.c	5.31 (Berkeley) 5/15/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* By the way, we need to include curses.h before telnet.h since,  * among other things, telnet.h #defines 'DO', which is a variable  * declared in curses.h.  */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|"ring.h"
end_include

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_escape
end_escape

begin_define
define|#
directive|define
name|strip
parameter_list|(
name|x
parameter_list|)
value|((x)&0x7f)
end_define

begin_decl_stmt
specifier|static
name|char
name|subbuffer
index|[
name|SUBBUFSIZE
index|]
decl_stmt|,
modifier|*
name|subpointer
decl_stmt|,
modifier|*
name|subend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for sub-options */
end_comment

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer;
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|subend = subpointer;
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \ 				*subpointer++ = (c); \ 			}
end_define

begin_decl_stmt
name|char
name|hisopts
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myopts
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|doopt
index|[]
init|=
block|{
name|IAC
block|,
name|DO
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dont
index|[]
init|=
block|{
name|IAC
block|,
name|DONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|will
index|[]
init|=
block|{
name|IAC
block|,
name|WILL
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wont
index|[]
init|=
block|{
name|IAC
block|,
name|WONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|connected
decl_stmt|,
name|showoptions
decl_stmt|,
name|In3270
decl_stmt|,
comment|/* Are we in 3270 mode? */
name|ISend
decl_stmt|,
comment|/* trying to send network data in */
name|debug
init|=
literal|0
decl_stmt|,
name|crmod
decl_stmt|,
name|netdata
decl_stmt|,
comment|/* Print out network data flow */
name|crlf
decl_stmt|,
comment|/* Should '\r' be mapped to<CR><LF> (or<CR><NUL>)? */
name|noasynch
init|=
literal|0
decl_stmt|,
comment|/* User specified "-noasynch" on command line */
name|askedSGA
init|=
literal|0
decl_stmt|,
comment|/* We have talked about suppress go ahead */
name|telnetport
decl_stmt|,
name|SYNCHing
decl_stmt|,
comment|/* we are in TELNET SYNCH mode */
name|flushout
decl_stmt|,
comment|/* flush output */
name|autoflush
init|=
literal|0
decl_stmt|,
comment|/* flush output when interrupting? */
name|autosynch
decl_stmt|,
comment|/* send interrupt characters with SYNCH? */
name|localchars
decl_stmt|,
comment|/* we recognize interrupt/quit */
name|donelclchars
decl_stmt|,
comment|/* the user has set "localchars" */
name|donebinarytoggle
decl_stmt|,
comment|/* the user has put us in binary */
name|dontlecho
decl_stmt|,
comment|/* do we suppress local echoing right now? */
name|globalmode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CONTROL
parameter_list|(
name|x
parameter_list|)
value|((x)&0x1f)
end_define

begin_comment
comment|/* CTRL(x) is not portable */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|0
decl_stmt|,
name|escape
decl_stmt|,
name|echoc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Telnet receiver states for fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_define
define|#
directive|define
name|TS_WILL
value|2
end_define

begin_define
define|#
directive|define
name|TS_WONT
value|3
end_define

begin_define
define|#
directive|define
name|TS_DO
value|4
end_define

begin_define
define|#
directive|define
name|TS_DONT
value|5
end_define

begin_define
define|#
directive|define
name|TS_CR
value|6
end_define

begin_define
define|#
directive|define
name|TS_SB
value|7
end_define

begin_comment
comment|/* sub-option collection */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|8
end_define

begin_comment
comment|/* looking for sub-option end */
end_comment

begin_decl_stmt
specifier|static
name|int
name|telrcv_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|peerdied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flushline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following are some clocks used to decide how to interpret  * the relationship between various variables.  */
end_comment

begin_decl_stmt
name|Clocks
name|clocks
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|Modelist
name|modelist
index|[]
init|=
block|{
block|{
literal|"telnet command mode"
block|,
name|COMMAND_LINE
block|}
block|,
block|{
literal|"character-at-a-time mode"
block|,
literal|0
block|}
block|,
block|{
literal|"character-at-a-time mode (local echo)"
block|,
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (remote echo)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode"
block|,
name|LINE
operator||
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (local echoing suppressed)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"3270 mode"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Initialize telnet environment.  */
end_comment

begin_macro
name|init_telnet
argument_list|()
end_macro

begin_block
block|{
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|ClearArray
argument_list|(
name|hisopts
argument_list|)
expr_stmt|;
name|ClearArray
argument_list|(
name|myopts
argument_list|)
expr_stmt|;
name|connected
operator|=
name|In3270
operator|=
name|ISend
operator|=
name|donebinarytoggle
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
operator|&&
name|defined
argument_list|(
name|TN3270
argument_list|)
name|HaveInput
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(unix)&& defined(TN3270) */
name|SYNCHing
operator|=
literal|0
expr_stmt|;
comment|/* Don't change NetTrace */
name|escape
operator|=
name|CONTROL
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|echoc
operator|=
name|CONTROL
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_function
specifier|static
name|void
name|printring
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
comment|/* where things go */
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|Ring
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ring
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|Ring
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|format
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'%'
condition|)
block|{
name|i
operator|=
operator|*
name|format
operator|++
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'c'
case|:
operator|*
name|ptr
operator|++
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|string
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ExitString
argument_list|(
literal|"printring: trailing %%.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
name|ExitString
argument_list|(
literal|"printring: unknown format character.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|willoption
parameter_list|(
name|option
parameter_list|,
name|reply
parameter_list|)
name|int
name|option
decl_stmt|,
name|reply
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
comment|/* 	     * The following is a pain in the rear-end. 	     * Various IBM servers (some versions of Wiscnet, 	     * possibly Fibronics/Spartacus, and who knows who 	     * else) will NOT allow us to send "DO SGA" too early 	     * in the setup proceedings.  On the other hand, 	     * 4.2 servers (telnetd) won't set SGA correctly. 	     * So, we are stuck.  Empirically (but, based on 	     * a VERY small sample), the IBM servers don't send 	     * out anything about ECHO, so we postpone our sending 	     * "DO SGA" until we see "WILL ECHO" (which 4.2 servers 	     * DO send). 	     */
block|{
if|if
condition|(
name|askedSGA
operator|==
literal|0
condition|)
block|{
name|askedSGA
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hisopts
index|[
name|TELOPT_SGA
index|]
condition|)
block|{
name|willoption
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Fall through */
case|case
name|TELOPT_EOR
case|:
case|case
name|TELOPT_BINARY
case|:
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_SGA
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
name|hisopts
index|[
name|option
index|]
operator|=
literal|1
expr_stmt|;
name|fmt
operator|=
name|doopt
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
comment|/* possibly set new tty mode */
break|break;
case|case
name|TELOPT_TM
case|:
return|return;
comment|/* Never reply to TM will's/wont's */
default|default:
name|fmt
operator|=
name|dont
expr_stmt|;
break|break;
block|}
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
else|else
name|printoption
argument_list|(
literal|"<SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wontoption
parameter_list|(
name|option
parameter_list|,
name|reply
parameter_list|)
name|int
name|option
decl_stmt|,
name|reply
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
case|case
name|TELOPT_SGA
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
name|hisopts
index|[
name|option
index|]
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|dont
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
comment|/* Set new tty mode */
break|break;
case|case
name|TELOPT_TM
case|:
return|return;
comment|/* Never reply to TM will's/wont's */
default|default:
name|fmt
operator|=
name|dont
expr_stmt|;
block|}
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
else|else
name|printoption
argument_list|(
literal|"<SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dooption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
name|fmt
operator|=
name|will
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|TELOPT_EOR
case|:
case|case
name|TELOPT_BINARY
case|:
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_TTYPE
case|:
comment|/* terminal type option */
case|case
name|TELOPT_SGA
case|:
comment|/* no big deal */
name|fmt
operator|=
name|will
expr_stmt|;
name|myopts
index|[
name|option
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* We're never going to echo... */
default|default:
name|fmt
operator|=
name|wont
expr_stmt|;
break|break;
block|}
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *		Terminal type, send request.  */
end_comment

begin_function
specifier|static
name|void
name|suboption
parameter_list|()
block|{
name|printsub
argument_list|(
literal|"<"
argument_list|,
name|subbuffer
argument_list|,
name|subend
operator|-
name|subbuffer
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subbuffer
index|[
literal|0
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
name|TELOPT_TTYPE
case|:
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|!=
name|TELQUAL_SEND
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|namebuf
index|[
literal|41
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|tn3270_ttype
argument_list|()
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
name|name
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|40
operator|)
condition|)
block|{
name|name
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|+
literal|4
operator|+
literal|2
operator|)
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|strcpy
argument_list|(
name|namebuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|upcase
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
literal|"%c%c%c%c%s%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_TTYPE
argument_list|,
name|TELQUAL_IS
argument_list|,
name|namebuf
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* printsub(">", nfrontp+2, 4+strlen(namebuf)+2-2-2); */
block|}
else|else
block|{
name|ExitString
argument_list|(
literal|"No room in buffer for terminal type.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|telrcv
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|scc
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|scc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TTYROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|sbp
operator|=
name|netiring
operator|.
name|consume
expr_stmt|;
name|scc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
comment|/* No more data coming in */
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0xff
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
switch|switch
condition|(
name|telrcv_state
condition|)
block|{
case|case
name|TS_CR
case|:
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
break|break;
comment|/* Ignore \0 after CR */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|hisopts
index|[
name|TELOPT_ECHO
index|]
operator|)
operator|&&
operator|!
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Else, fall through */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0377
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* defined(TN3270) */
comment|/* 		     * The 'crmod' hack (see following) is needed 		     * since we can't * set CRMOD on output only. 		     * Machines like MULTICS like to send \r without 		     * \n; since we must turn off CRMOD to get proper 		     * input, the mapping is done here (sigh). 		     */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
operator|!
name|hisopts
index|[
name|TELOPT_BINARY
index|]
condition|)
block|{
if|if
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* a "true" CR */
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hisopts
index|[
name|TELOPT_ECHO
index|]
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|telrcv_state
operator|=
name|TS_CR
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_IAC
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|WILL
case|:
name|telrcv_state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|telrcv_state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|telrcv_state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|telrcv_state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|DM
case|:
comment|/* 		     * We may have missed an urgent notification, 		     * so make sure we flush whatever is in the 		     * buffer currently. 		     */
name|SYNCHing
operator|=
literal|1
expr_stmt|;
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
name|stilloob
argument_list|()
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP
case|:
case|case
name|GA
case|:
break|break;
case|case
name|SB
case|:
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|EOR
case|:
if|if
condition|(
name|In3270
condition|)
block|{
name|Ibackp
operator|+=
name|DataFromNetwork
argument_list|(
name|Ibackp
argument_list|,
name|Ifrontp
operator|-
name|Ibackp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ibackp
operator|==
name|Ifrontp
condition|)
block|{
name|Ibackp
operator|=
name|Ifrontp
operator|=
name|Ibuf
expr_stmt|;
name|ISend
operator|=
literal|0
expr_stmt|;
comment|/* should have been! */
block|}
else|else
block|{
name|ISend
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|IAC
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
break|break;
default|default:
break|break;
block|}
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WILL
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|will
argument_list|,
name|c
argument_list|,
operator|!
name|hisopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_TM
condition|)
block|{
if|if
condition|(
name|flushout
condition|)
block|{
name|flushout
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|hisopts
index|[
name|c
index|]
condition|)
block|{
name|willoption
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|wont
argument_list|,
name|c
argument_list|,
name|hisopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_TM
condition|)
block|{
if|if
condition|(
name|flushout
condition|)
block|{
name|flushout
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hisopts
index|[
name|c
index|]
condition|)
block|{
name|wontoption
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|doopt
argument_list|,
name|c
argument_list|,
operator|!
name|myopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myopts
index|[
name|c
index|]
condition|)
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|dont
argument_list|,
name|c
argument_list|,
name|myopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|myopts
index|[
name|c
index|]
condition|)
block|{
name|myopts
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
name|wont
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
comment|/* set new tty mode (maybe) */
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|wont
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
condition|)
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|telsnd
parameter_list|()
block|{
name|int
name|tcc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tbp
decl_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NETROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
specifier|register
name|int
name|sc
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|tbp
operator|=
name|ttyiring
operator|.
name|consume
expr_stmt|;
name|tcc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|tbp
operator|++
operator|&
literal|0xff
operator|,
name|sc
operator|=
name|strip
argument_list|(
name|c
argument_list|)
operator|,
name|tcc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|escape
condition|)
block|{
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|MODE_LINE
argument_list|(
name|globalmode
argument_list|)
operator|&&
operator|(
name|sc
operator|==
name|echoc
operator|)
condition|)
block|{
if|if
condition|(
name|tcc
operator|>
literal|0
operator|&&
name|strip
argument_list|(
operator|*
name|tbp
argument_list|)
operator|==
name|echoc
condition|)
block|{
name|tcc
operator|--
expr_stmt|;
name|tbp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dontlecho
operator|=
operator|!
name|dontlecho
expr_stmt|;
name|settimer
argument_list|(
name|echotoggle
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|localchars
condition|)
block|{
if|if
condition|(
name|TerminalSpecialChars
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|myopts
index|[
name|TELOPT_BINARY
index|]
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* 		     * If we are in CRMOD mode (\r ==> \n) 		     * on our local machine, then probably 		     * a newline (unix) is CRLF (TELNET). 		     */
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
name|NETADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
name|NETADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
operator|!
name|crlf
condition|)
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IAC
case|:
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
comment|/* Non-zero if we did anything */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Scheduler()  *  * Try to do something.  *  * If we do something useful, return 1; else return 0.  *  */
end_comment

begin_function
name|int
name|Scheduler
parameter_list|(
name|block
parameter_list|)
name|int
name|block
decl_stmt|;
comment|/* should we block in the select ? */
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* One wants to be a bit careful about setting returnValue 		 * to one, since a one implies we did some useful work, 		 * and therefore probably won't be called to block next 		 * time (TN3270 mode only). 		 */
name|int
name|returnValue
decl_stmt|;
name|int
name|netin
decl_stmt|,
name|netout
decl_stmt|,
name|netex
decl_stmt|,
name|ttyin
decl_stmt|,
name|ttyout
decl_stmt|;
comment|/* Decide which rings should be processed */
name|netout
operator|=
name|ring_full_count
argument_list|(
operator|&
name|netoring
argument_list|)
operator|&&
operator|(
operator|!
name|MODE_LINE
argument_list|(
name|globalmode
argument_list|)
operator|||
name|flushline
operator|||
name|myopts
index|[
name|TELOPT_BINARY
index|]
operator|)
expr_stmt|;
name|ttyout
operator|=
name|ring_full_count
argument_list|(
operator|&
name|ttyoring
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|ttyin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
expr_stmt|;
else|#
directive|else
comment|/* defined(TN3270) */
name|ttyin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(TN3270) */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|netin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|netin
operator|=
operator|!
name|ISend
operator|&&
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
name|netex
operator|=
operator|!
name|SYNCHing
expr_stmt|;
comment|/* If we have seen a signal recently, reset things */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
operator|&&
name|defined
argument_list|(
name|unix
argument_list|)
if|if
condition|(
name|HaveInput
condition|)
block|{
name|HaveInput
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|inputAvailable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TN3270)&& defined(unix) */
comment|/* Call to system code to process rings */
name|returnValue
operator|=
name|process_rings
argument_list|(
name|netin
argument_list|,
name|netout
argument_list|,
name|netex
argument_list|,
name|ttyin
argument_list|,
name|ttyout
argument_list|,
operator|!
name|block
argument_list|)
expr_stmt|;
comment|/* Now, look at the input rings, looking for work to do. */
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
name|c
operator|=
name|DataFromTerminal
argument_list|(
name|ttyiring
operator|.
name|consume
argument_list|,
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|returnValue
operator|=
literal|1
expr_stmt|;
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* defined(TN3270) */
name|returnValue
operator||=
name|telsnd
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
block|}
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|netiring
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|returnValue
operator||=
name|telrcv
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|returnValue
operator|=
name|Push3270
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
return|return
name|returnValue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Select from tty and network...  */
end_comment

begin_function
name|void
name|telnet
parameter_list|()
block|{
name|sys_telnet_init
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|telnetport
condition|)
block|{
if|if
condition|(
operator|!
name|hisopts
index|[
name|TELOPT_SGA
index|]
condition|)
block|{
name|willoption
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|myopts
index|[
name|TELOPT_TTYPE
index|]
condition|)
block|{
name|dooption
argument_list|(
name|TELOPT_TTYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
comment|/* !defined(TN3270) */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|!
name|In3270
operator|&&
operator|!
name|shell_active
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there is data waiting to go out to terminal, don't 		 * schedule any more data for the terminal. 		 */
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyoring
argument_list|)
condition|)
block|{
name|schedValue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|shell_active
condition|)
block|{
if|if
condition|(
name|shell_continue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ConnectScreen
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|In3270
condition|)
block|{
name|schedValue
operator|=
name|DoTerminalOutput
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|schedValue
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * nextitem()  *  *	Return the address of the next "item" in the TELNET data  * stream.  This will be the address of the next character if  * the current address is a user data character, or it will  * be the address of the character following the TELNET command  * if the current address is a TELNET IAC ("I Am a Command")  * character.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nextitem
parameter_list|(
name|current
parameter_list|)
name|char
modifier|*
name|current
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|current
operator|&
literal|0xff
operator|)
operator|!=
name|IAC
condition|)
block|{
return|return
name|current
operator|+
literal|1
return|;
block|}
switch|switch
condition|(
operator|*
operator|(
name|current
operator|+
literal|1
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
name|DO
case|:
case|case
name|DONT
case|:
case|case
name|WILL
case|:
case|case
name|WONT
case|:
return|return
name|current
operator|+
literal|3
return|;
case|case
name|SB
case|:
comment|/* loop forever looking for the SE */
block|{
specifier|register
name|char
modifier|*
name|look
init|=
name|current
operator|+
literal|2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|look
operator|++
operator|&
literal|0xff
operator|)
operator|==
name|IAC
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|look
operator|++
operator|&
literal|0xff
operator|)
operator|==
name|SE
condition|)
block|{
return|return
name|look
return|;
block|}
block|}
block|}
block|}
default|default:
return|return
name|current
operator|+
literal|2
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * netclear()  *  *	We are about to do a TELNET SYNCH operation.  Clear  * the path to the network.  *  *	Things are a bit tricky since we may have sent the first  * byte or so of a previous TELNET command into the network.  * So, we have to scan the network buffer from the beginning  * until we are up to where we want to be.  *  *	A side effect of what we do, just to keep things  * simple, is to clear the urgent data pointer.  The principal  * caller should be setting the urgent data pointer AFTER calling  * us in any case.  */
end_comment

begin_function
specifier|static
name|void
name|netclear
parameter_list|()
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|register char *thisitem, *next;     char *good;
define|#
directive|define
name|wewant
parameter_list|(
name|p
parameter_list|)
value|((nfrontp> p)&& ((*p&0xff) == IAC)&& \ 				((*(p+1)&0xff) != EC)&& ((*(p+1)&0xff) != EL))
block|thisitem = netobuf;      while ((next = nextitem(thisitem))<= netobuf.send) { 	thisitem = next;     }
comment|/* Now, thisitem is first before/at boundary. */
block|good = netobuf;
comment|/* where the good bytes go */
block|while (netoring.add> thisitem) { 	if (wewant(thisitem)) { 	    int length;  	    next = thisitem; 	    do { 		next = nextitem(next); 	    } while (wewant(next)&& (nfrontp> next)); 	    length = next-thisitem; 	    memcpy(good, thisitem, length); 	    good += length; 	    thisitem = next; 	} else { 	    thisitem = nextitem(thisitem); 	}     }
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * These routines add various telnet commands to the data stream.  */
end_comment

begin_function
specifier|static
name|void
name|doflush
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DO
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|flushout
operator|=
literal|1
expr_stmt|;
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Flush/drop output */
comment|/* do printoption AFTER flush, otherwise the output gets tossed... */
name|printoption
argument_list|(
literal|"<SENT"
argument_list|,
name|doopt
argument_list|,
name|TELOPT_TM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitAO
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|AO
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xmitEL
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitEC
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EC
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOT43
argument_list|)
end_if

begin_function
name|int
else|#
directive|else
comment|/* defined(NOT43) */
name|void
endif|#
directive|endif
comment|/* defined(NOT43) */
name|dosynch
parameter_list|()
block|{
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear the path to the network */
name|NETADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|setneturg
argument_list|()
expr_stmt|;
name|NETADD
argument_list|(
name|DM
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NOT43
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* defined(NOT43) */
block|}
end_function

begin_function
name|void
name|intp
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IP
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendbrk
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

