begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * Copyright (c) 1976 Board of Trustees of the University of Illinois.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley and the University  * of Illinois, Urbana.  The name of either  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lexi.c	5.8 (Berkeley) 6/29/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * NAME:  *	lexi  *  * FUNCTION:  *	This is the token scanner for indent  *  * ALGORITHM:  *	1) Strip off intervening blanks and/or tabs.  *	2) If it is an alphanumeric token, move it to the token buffer "token".  *	   Check if it is a special reserved word that indent will want to  *	   know about.  *	3) Non-alphanumeric tokens are handled with a big switch statement.  A  *	   flag is kept to remember if the last token was a "unary delimiter",  *	   which forces a following operator to be unary as opposed to binary.  *  * PARAMETERS:  *	None  *  * RETURNS:  *	An integer code indicating the type of token scanned.  *  * GLOBALS:  *	buf_ptr =  *	had_eof  *	ps.last_u_d =	Set to true iff this token is a "unary delimiter"  *  * CALLS:  *	fill_buffer  *	printf (lib)  *  * CALLED BY:  *	main  *  * NOTES:  *	Start of comment is passed back so that the comment can be scanned by  *	pr_comment.  *  *	Strings and character literals are returned just like identifiers.  *  * HISTORY:  *	initial coding 	November 1976	D A Willcox of CAC  *	1/7/77		D A Willcox of CAC	Fix to provide proper handling  *						of "int a -1;"  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Here we have the token scanner for indent.  It scans off one token and  * puts it in the global variable "token".  It returns a code, indicating  * the type of token scanned.   */
end_comment

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_define
define|#
directive|define
name|alphanum
value|1
end_define

begin_define
define|#
directive|define
name|opchar
value|3
end_define

begin_struct
struct|struct
name|templ
block|{
name|char
modifier|*
name|rwd
decl_stmt|;
name|int
name|rwcode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|templ
name|specials
index|[
literal|100
index|]
init|=
block|{
literal|"switch"
block|,
literal|1
block|,
literal|"case"
block|,
literal|2
block|,
literal|"break"
block|,
literal|0
block|,
literal|"struct"
block|,
literal|3
block|,
literal|"union"
block|,
literal|3
block|,
literal|"enum"
block|,
literal|3
block|,
literal|"default"
block|,
literal|2
block|,
literal|"int"
block|,
literal|4
block|,
literal|"char"
block|,
literal|4
block|,
literal|"float"
block|,
literal|4
block|,
literal|"double"
block|,
literal|4
block|,
literal|"long"
block|,
literal|4
block|,
literal|"short"
block|,
literal|4
block|,
literal|"typdef"
block|,
literal|4
block|,
literal|"unsigned"
block|,
literal|4
block|,
literal|"register"
block|,
literal|4
block|,
literal|"static"
block|,
literal|4
block|,
literal|"global"
block|,
literal|4
block|,
literal|"extern"
block|,
literal|4
block|,
literal|"void"
block|,
literal|4
block|,
literal|"goto"
block|,
literal|0
block|,
literal|"return"
block|,
literal|0
block|,
literal|"if"
block|,
literal|5
block|,
literal|"while"
block|,
literal|5
block|,
literal|"for"
block|,
literal|5
block|,
literal|"else"
block|,
literal|6
block|,
literal|"do"
block|,
literal|6
block|,
literal|"sizeof"
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chartype
index|[
literal|128
index|]
init|=
block|{
comment|/* this is used to facilitate the decision 				 * of what type (alphanumeric, operator) 				 * each character is */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|lexi
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|tok
decl_stmt|;
comment|/* local pointer to next char in token */
name|int
name|unary_delim
decl_stmt|;
comment|/* this is set to 1 if the current token  				 * 				 * forces a following operator to be unary */
specifier|static
name|int
name|last_code
decl_stmt|;
comment|/* the last token type returned */
specifier|static
name|int
name|l_struct
decl_stmt|;
comment|/* set to 1 if the last token was 'struct' */
name|int
name|code
decl_stmt|;
comment|/* internal code to be returned */
name|char
name|qchar
decl_stmt|;
comment|/* the delimiter character for a string */
name|tok
operator|=
name|token
expr_stmt|;
comment|/* point to start of place to save token */
name|unary_delim
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|col_1
operator|=
name|ps
operator|.
name|last_nl
expr_stmt|;
comment|/* tell world that this token started in 				 * column 1 iff the last thing scanned was 				 * nl */
name|ps
operator|.
name|last_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
name|ps
operator|.
name|col_1
operator|=
name|false
expr_stmt|;
comment|/* leading blanks imply token is not in 				 * column 1 */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
comment|/* Scan an alphanumeric token.  Note that we must also handle      * stuff like "1.0e+03" and "7e-6". */
if|if
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
operator|&
literal|0177
index|]
operator|==
name|alphanum
condition|)
block|{
comment|/* we have a character 							 * or number */
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
comment|/* used for searching thru list of  				 * reserved words */
specifier|register
name|struct
name|templ
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
comment|/* copy it over */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|chartype
index|[
name|c
operator|=
operator|*
name|buf_ptr
operator|&
literal|0177
index|]
operator|==
name|alphanum
operator|||
name|isdigit
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|'e'
operator|||
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|'E'
operator|)
condition|)
do|;
operator|*
name|tok
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|ps
operator|.
name|its_a_keyword
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|sizeof_keyword
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|l_struct
condition|)
block|{
comment|/* if last token was 'struct', then this 				 * token should be treated as a 				 * declaration */
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|ident
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
block|}
name|ps
operator|.
name|last_u_d
operator|=
name|false
expr_stmt|;
comment|/* Operator after indentifier is binary */
name|last_code
operator|=
name|ident
expr_stmt|;
comment|/* Remember that this is the code we will 				 * return */
comment|/* 	 * This loop will check if the token is a keyword.  	 */
for|for
control|(
name|p
operator|=
name|specials
init|;
operator|(
name|j
operator|=
name|p
operator|->
name|rwd
operator|)
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|tok
operator|=
name|token
expr_stmt|;
comment|/* point at scanned token */
if|if
condition|(
operator|*
name|j
operator|++
operator|!=
operator|*
name|tok
operator|++
operator|||
operator|*
name|j
operator|++
operator|!=
operator|*
name|tok
operator|++
condition|)
continue|continue;
comment|/* This test depends on the fact that 				 * identifiers are always at least 1 				 * character long (ie. the first two bytes 				 * of the identifier are always 				 * meaningful) */
if|if
condition|(
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
comment|/* If its a one-character identifier */
while|while
condition|(
operator|*
name|tok
operator|++
operator|==
operator|*
name|j
condition|)
if|if
condition|(
operator|*
name|j
operator|++
operator|==
literal|0
condition|)
goto|goto
name|found_keyword
goto|;
comment|/* I wish that C had a multi-level 					 * break... */
block|}
if|if
condition|(
name|p
operator|->
name|rwd
condition|)
block|{
comment|/* we have a keyword */
name|found_keyword
label|:
name|ps
operator|.
name|its_a_keyword
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|rwcode
condition|)
block|{
case|case
literal|1
case|:
comment|/* it is a switch */
return|return
operator|(
name|swstmt
operator|)
return|;
case|case
literal|2
case|:
comment|/* a case or default */
return|return
operator|(
name|casestmt
operator|)
return|;
case|case
literal|3
case|:
comment|/* a "struct" */
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
break|break;
comment|/* inside parens: cast */
name|l_struct
operator|=
name|true
expr_stmt|;
comment|/* 		     * Next time around, we will want to know that we have 		     * had a 'struct'  		     */
case|case
literal|4
case|:
comment|/* one of the declaration keywords */
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
block|{
name|ps
operator|.
name|cast_mask
operator||=
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
expr_stmt|;
break|break;
comment|/* inside parens: cast */
block|}
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
case|case
literal|5
case|:
comment|/* if, while, for */
return|return
operator|(
name|sp_paren
operator|)
return|;
case|case
literal|6
case|:
comment|/* do, else */
return|return
operator|(
name|sp_nparen
operator|)
return|;
case|case
literal|7
case|:
name|ps
operator|.
name|sizeof_keyword
operator|=
name|true
expr_stmt|;
default|default:
comment|/* all others are treated like any other 				 * identifier */
return|return
operator|(
name|ident
operator|)
return|;
block|}
comment|/* end of switch */
block|}
comment|/* end of if (found_it) */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'('
operator|&&
name|ps
operator|.
name|tos
operator|<=
literal|1
operator|&&
name|ps
operator|.
name|ind_level
operator|==
literal|0
operator|&&
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|!=
literal|')'
operator|||
name|buf_ptr
index|[
literal|2
index|]
operator|!=
literal|';'
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|ps
operator|.
name|procname
argument_list|,
name|token
argument_list|,
sizeof|sizeof
name|ps
operator|.
name|procname
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * The following hack attempts to guess whether or not the current 	 * token is in fact a declaration keyword -- one that has been 	 * typedefd  	 */
if|if
condition|(
operator|(
operator|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
name|buf_ptr
index|[
literal|1
index|]
operator|!=
literal|'='
operator|)
operator|||
name|isalpha
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|)
operator|&&
operator|!
name|ps
operator|.
name|p_l_follow
operator|&&
operator|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
operator|||
name|ps
operator|.
name|last_token
operator|==
name|semicolon
operator|||
name|ps
operator|.
name|last_token
operator|==
name|decl
operator|||
name|ps
operator|.
name|last_token
operator|==
name|lbrace
operator|||
name|ps
operator|.
name|last_token
operator|==
name|rbrace
operator|)
condition|)
block|{
name|ps
operator|.
name|its_a_keyword
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|last_code
operator|==
name|decl
condition|)
comment|/* if this is a declared variable, then 				 * following sign is unary */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* will make "int a -1" work */
name|last_code
operator|=
name|ident
expr_stmt|;
return|return
operator|(
name|ident
operator|)
return|;
comment|/* the ident is not in the list */
block|}
comment|/* end of procesing for alpanum character */
comment|/* Scan a non-alphanumeric token */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
comment|/* if it is only a one-character token, it 				 * is moved here */
operator|*
name|tok
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|token
condition|)
block|{
case|case
literal|'\n'
case|:
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember that we just had a newline */
name|code
operator|=
operator|(
name|had_eof
condition|?
literal|0
else|:
name|newline
operator|)
expr_stmt|;
comment|/* 	     * if data has been exausted, the newline is a dummy, and we 	     * should return code to stop  	     */
break|break;
case|case
literal|'\''
case|:
comment|/* start of quoted character */
case|case
literal|'"'
case|:
comment|/* start of string */
name|qchar
operator|=
operator|*
name|token
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
name|tok
index|[
operator|-
literal|1
index|]
operator|=
literal|'`'
expr_stmt|;
if|if
condition|(
name|qchar
operator|==
literal|'"'
condition|)
operator|*
name|tok
operator|++
operator|=
literal|'`'
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
name|BACKSLASH
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
literal|'f'
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
literal|'L'
expr_stmt|;
block|}
do|do
block|{
comment|/* copy the string */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* move one character or [/<char>]<char> */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|"%d: Unterminated literal\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
goto|goto
name|stop_lit
goto|;
block|}
operator|*
name|tok
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|had_eof
operator|||
operator|(
operator|(
name|tok
operator|-
name|token
operator|)
operator|>
operator|(
name|bufsize
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Unterminated literal\n"
argument_list|)
expr_stmt|;
operator|++
name|tok
expr_stmt|;
goto|goto
name|stop_lit
goto|;
comment|/* get outof literal copying loop */
block|}
if|if
condition|(
operator|*
name|tok
operator|==
name|BACKSLASH
condition|)
block|{
comment|/* if escape, copy extra 						 * char */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
comment|/* check for escaped 						 * newline */
operator|++
name|line_no
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
operator|*
operator|++
name|tok
operator|=
name|BACKSLASH
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
operator|*
operator|++
name|tok
operator|=
name|BACKSLASH
expr_stmt|;
block|}
operator|*
operator|++
name|tok
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|++
name|tok
expr_stmt|;
comment|/* we must increment this again because we 				 * copied two chars */
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
comment|/* we copied one character */
block|}
comment|/* end of while (1) */
block|}
do|while
condition|(
operator|*
name|tok
operator|++
operator|!=
name|qchar
condition|)
do|;
if|if
condition|(
name|troff
condition|)
block|{
name|tok
index|[
operator|-
literal|1
index|]
operator|=
name|BACKSLASH
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
literal|'f'
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
literal|'R'
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
literal|'\''
expr_stmt|;
if|if
condition|(
name|qchar
operator|==
literal|'"'
condition|)
operator|*
name|tok
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
name|stop_lit
label|:
name|code
operator|=
name|ident
expr_stmt|;
break|break;
case|case
operator|(
literal|'('
operator|)
case|:
case|case
operator|(
literal|'['
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|lparen
expr_stmt|;
break|break;
case|case
operator|(
literal|')'
operator|)
case|:
case|case
operator|(
literal|']'
operator|)
case|:
name|code
operator|=
name|rparen
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|code
operator|=
name|preesc
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|question
expr_stmt|;
break|break;
case|case
operator|(
literal|':'
operator|)
case|:
name|code
operator|=
name|colon
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
case|case
operator|(
literal|';'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|semicolon
expr_stmt|;
break|break;
case|case
operator|(
literal|'{'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
comment|/* 	     * if (ps.in_or_st) ps.block_init = 1;  	     */
name|code
operator|=
name|ps
operator|.
name|block_init
condition|?
name|lparen
else|:
name|lbrace
expr_stmt|;
break|break;
case|case
operator|(
literal|'}'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|ps
operator|.
name|block_init
condition|?
name|rparen
else|:
name|rbrace
expr_stmt|;
break|break;
case|case
literal|014
case|:
comment|/* a form feed */
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember this so we can set 'ps.col_1' 				 * right */
name|code
operator|=
name|form_feed
expr_stmt|;
break|break;
case|case
operator|(
literal|','
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|comma
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|unary_delim
operator|=
name|false
expr_stmt|;
name|code
operator|=
name|period
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
comment|/* check for -, +, --, ++ */
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|token
index|[
literal|0
index|]
condition|)
block|{
comment|/* check for doubled character */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* buffer overflow will be checked at end of loop */
if|if
condition|(
name|last_code
operator|==
name|ident
operator|||
name|last_code
operator|==
name|rparen
condition|)
block|{
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|postop
operator|)
expr_stmt|;
comment|/* check for following ++ or -- */
name|unary_delim
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
comment|/* check for operator += */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'>'
condition|)
block|{
comment|/* check for operator -> */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pointer_as_binop
condition|)
block|{
name|code
operator|=
name|unary_op
expr_stmt|;
name|unary_delim
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* buffer overflow will be checked at end of switch */
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|ps
operator|.
name|in_or_st
condition|)
name|ps
operator|.
name|block_init
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
index|]
operator|==
name|opchar
condition|)
block|{
comment|/* we have two char 						 * assignment */
name|tok
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
operator|||
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|tok
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|buf_ptr
condition|)
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|tok
operator|++
operator|=
literal|'='
expr_stmt|;
comment|/* Flip =+ to += */
operator|*
name|tok
operator|=
literal|0
expr_stmt|;
block|}
name|code
operator|=
name|binary_op
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
comment|/* can drop thru!!! */
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'!'
case|:
comment|/* ops like<,<<,<=, !=, etc */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'<'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'*'
condition|)
block|{
comment|/* it is start of comment */
operator|*
name|tok
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
name|code
operator|=
name|comment
expr_stmt|;
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
operator|(
name|tok
operator|-
literal|1
operator|)
operator|==
operator|*
name|buf_ptr
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
comment|/* handle ||,&&, etc, and also things as in int *****i */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
block|}
comment|/* end of switch */
if|if
condition|(
name|code
operator|!=
name|newline
condition|)
block|{
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* check for input buffer empty */
name|fill_buffer
argument_list|()
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|unary_delim
expr_stmt|;
operator|*
name|tok
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate the token */
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Add the given keyword to the keyword table, using val as the keyword type    */
end_comment

begin_macro
name|addkey
argument_list|(
argument|key
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|templ
modifier|*
name|p
init|=
name|specials
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|rwd
condition|)
if|if
condition|(
name|p
operator|->
name|rwd
index|[
literal|0
index|]
operator|==
name|key
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|rwd
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|specials
operator|+
sizeof|sizeof
name|specials
operator|/
sizeof|sizeof
name|specials
index|[
literal|0
index|]
condition|)
return|return;
comment|/* For now, table overflows are silently 				   ignored */
name|p
operator|->
name|rwd
operator|=
name|key
expr_stmt|;
name|p
operator|->
name|rwcode
operator|=
name|val
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|.
name|rwd
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|.
name|rwcode
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_block

end_unit

