begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)check.c	5.2 (Berkeley) 1/10/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: check.c,v 1.5 84/12/26 10:38:35 linton Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check a tree for semantic correctness.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Check that the nodes in a tree have the correct arguments  * in order to be evaluated.  Basically the error checking here  * frees the evaluation routines from worrying about anything  * except dynamic errors, e.g. subscript out of range.  */
end_comment

begin_function
name|public
name|check
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Node
name|p
decl_stmt|;
block|{
name|Node
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
name|checkref
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|O_ASSIGN
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|p2
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$unsafeassign"
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
operator|!=
name|size
argument_list|(
name|p2
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incompatible sizes"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|not
name|compatible
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|,
name|p2
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incompatible types"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_CATCH
case|:
case|case
name|O_IGNORE
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|lcon
operator|<
literal|0
name|or
name|p
operator|->
name|value
operator|.
name|lcon
operator|>
name|NSIG
condition|)
block|{
name|error
argument_list|(
literal|"invalid signal number"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_CONT
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|lcon
operator|!=
name|DEFSIG
name|and
argument_list|(
argument|p->value.lcon<
literal|0
argument|or p->value.lcon> NSIG
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid signal number"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_DUMP
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|f
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|not
name|isblock
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a block"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected a symbol, found \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_LIST
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|f
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|not
name|isblock
argument_list|(
argument|f
argument_list|)
name|or
name|ismodule
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|firstline
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NOADDR
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is empty"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_TRACE
case|:
case|case
name|O_TRACEI
case|:
name|chktrace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_STOP
case|:
case|case
name|O_STOPI
case|:
name|chkstop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CALLPROC
case|:
case|case
name|O_CALL
case|:
if|if
condition|(
name|not
name|isroutine
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\" not call-able"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|O_WHEREIS
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
name|and
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"symbol not defined"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Check arguments to a trace command.  */
end_comment

begin_function
name|private
name|chktrace
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
name|Node
name|exp
decl_stmt|,
name|place
decl_stmt|,
name|cond
decl_stmt|;
name|exp
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|place
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
name|cond
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|nil
condition|)
block|{
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_LCON
name|or
name|exp
operator|->
name|op
operator|==
name|O_QLINE
condition|)
block|{
if|if
condition|(
name|place
operator|!=
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"unexpected \"at\" or \"in\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|O_TRACE
condition|)
block|{
name|chkline
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkaddr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|!=
name|nil
name|and
argument_list|(
argument|place->op == O_QLINE or place->op == O_LCON
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|O_TRACE
condition|)
block|{
name|chkline
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkaddr
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
name|and
name|exp
operator|->
name|op
operator|!=
name|O_SYM
name|and
name|exp
operator|->
name|op
operator|!=
name|O_CALL
condition|)
block|{
name|error
argument_list|(
literal|"can't trace expressions"
argument_list|)
expr_stmt|;
block|}
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check arguments to a stop command.  */
end_comment

begin_function
name|private
name|chkstop
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
name|Node
name|exp
decl_stmt|,
name|place
decl_stmt|,
name|cond
decl_stmt|;
name|exp
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|place
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
name|cond
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
name|and
name|exp
operator|->
name|op
operator|!=
name|O_SYM
name|and
name|exp
operator|->
name|op
operator|!=
name|O_LCON
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected variable, found "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|place
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|place
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|O_STOP
condition|)
block|{
name|chkline
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkaddr
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see that the given node specifies some subprogram.  * Nil is ok since that means the entire program.  */
end_comment

begin_function
name|private
name|chkblock
parameter_list|(
name|b
parameter_list|)
name|Node
name|b
decl_stmt|;
block|{
name|Symbol
name|p
decl_stmt|,
name|outer
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|op
operator|!=
name|O_SYM
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected subprogram, found "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ismodule
argument_list|(
name|b
operator|->
name|value
operator|.
name|sym
argument_list|)
condition|)
block|{
name|outer
operator|=
name|b
operator|->
name|value
operator|.
name|sym
expr_stmt|;
while|while
condition|(
name|outer
operator|!=
name|nil
condition|)
block|{
name|find
argument_list|(
argument|p
argument_list|,
argument|outer->name
argument_list|)
name|where
name|p
operator|->
name|block
operator|==
name|outer
name|endfind
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|outer
operator|=
name|nil
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" is not a subprogram"
argument_list|,
name|symname
argument_list|(
name|b
operator|->
name|value
operator|.
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ismodule
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|outer
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|outer
operator|=
name|nil
expr_stmt|;
name|b
operator|->
name|value
operator|.
name|sym
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|value
operator|.
name|sym
operator|->
name|class
operator|==
name|VAR
name|and
name|b
operator|->
name|value
operator|.
name|sym
operator|->
name|name
operator|==
name|b
operator|->
name|value
operator|.
name|sym
operator|->
name|block
operator|->
name|name
name|and
name|b
operator|->
name|value
operator|.
name|sym
operator|->
name|block
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|b
operator|->
name|value
operator|.
name|sym
operator|=
name|b
operator|->
name|value
operator|.
name|sym
operator|->
name|block
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|isblock
argument_list|(
name|b
operator|->
name|value
operator|.
name|sym
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a subprogram"
argument_list|,
name|symname
argument_list|(
name|b
operator|->
name|value
operator|.
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to make sure a node corresponds to a source line.  */
end_comment

begin_function
name|private
name|chkline
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"missing line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|O_QLINE
name|and
name|p
operator|->
name|op
operator|!=
name|O_LCON
condition|)
block|{
name|error
argument_list|(
literal|"expected source line number, found \"%t\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to make sure a node corresponds to an address.  */
end_comment

begin_function
name|private
name|chkaddr
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"missing address"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|O_LCON
name|and
name|p
operator|->
name|op
operator|!=
name|O_QLINE
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected address, found \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

