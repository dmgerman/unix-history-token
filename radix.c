begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * radix.c -- generic radix tree  *  * Taken from NSD4, modified for ldns  *  * Copyright (c) 2012, NLnet Labs. All rights reserved.  *  * This software is open source.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/**  * \file  * Implementation of a radix tree.  */
end_comment

begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_include
include|#
directive|include
file|<ldns/radix.h>
end_include

begin_include
include|#
directive|include
file|<ldns/util.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/** Helper functions */
end_comment

begin_function_decl
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_new_node
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_find_prefix
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|ldns_radix_node_t
modifier|*
modifier|*
name|result
parameter_list|,
name|radix_strlen_t
modifier|*
name|pos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_array_space
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_array_grow
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|unsigned
name|need
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_str_create
parameter_list|(
name|ldns_radix_array_t
modifier|*
name|array
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|pos
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_prefix_remainder
parameter_list|(
name|radix_strlen_t
name|prefix_len
parameter_list|,
name|uint8_t
modifier|*
name|longer_str
parameter_list|,
name|radix_strlen_t
name|longer_len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|split_str
parameter_list|,
name|radix_strlen_t
modifier|*
name|split_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_array_split
parameter_list|(
name|ldns_radix_array_t
modifier|*
name|array
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|pos
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|ldns_radix_node_t
modifier|*
name|add
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ldns_radix_str_is_prefix
parameter_list|(
name|uint8_t
modifier|*
name|str1
parameter_list|,
name|radix_strlen_t
name|len1
parameter_list|,
name|uint8_t
modifier|*
name|str2
parameter_list|,
name|radix_strlen_t
name|len2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|radix_strlen_t
name|ldns_radix_str_common
parameter_list|(
name|uint8_t
modifier|*
name|str1
parameter_list|,
name|radix_strlen_t
name|len1
parameter_list|,
name|uint8_t
modifier|*
name|str2
parameter_list|,
name|radix_strlen_t
name|len2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_next_in_subtree
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_prev_from_index
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|uint8_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_last_in_subtree_incl_self
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_last_in_subtree
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_del_fix
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_cleanup_onechild
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_cleanup_leaf
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_node_free
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_node_array_free
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_node_array_free_front
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_node_array_free_end
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_array_reduce
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ldns_radix_self_or_prev
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|ldns_radix_node_t
modifier|*
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Create a new radix node.  *  */
end_comment

begin_function
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_new_node
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|node
init|=
name|LDNS_MALLOC
argument_list|(
name|ldns_radix_node_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|node
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|node
operator|->
name|klen
operator|=
name|len
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|parent_index
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|capacity
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/**  * Create a new radix tree.  *  */
end_comment

begin_function
name|ldns_radix_t
modifier|*
name|ldns_radix_create
parameter_list|(
name|void
parameter_list|)
block|{
name|ldns_radix_t
modifier|*
name|tree
decl_stmt|;
comment|/** Allocate memory for it */
name|tree
operator|=
operator|(
name|ldns_radix_t
operator|*
operator|)
name|LDNS_MALLOC
argument_list|(
name|ldns_radix_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/** Initialize it */
name|ldns_radix_init
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize radix tree.  *  */
end_comment

begin_function
name|void
name|ldns_radix_init
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|)
block|{
comment|/** Initialize it */
if|if
condition|(
name|tree
condition|)
block|{
name|tree
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * Free radix tree.  *  */
end_comment

begin_function
name|void
name|ldns_radix_free
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|root
condition|)
block|{
name|ldns_radix_traverse_postorder
argument_list|(
name|tree
operator|->
name|root
argument_list|,
name|ldns_radix_node_free
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|LDNS_FREE
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * Insert data into the tree.  *  */
end_comment

begin_function
name|ldns_status
name|ldns_radix_insert
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|radix_strlen_t
name|pos
init|=
literal|0
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|add
init|=
name|NULL
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|tree
operator|||
operator|!
name|key
operator|||
operator|!
name|data
condition|)
block|{
return|return
name|LDNS_STATUS_NULL
return|;
block|}
name|add
operator|=
name|ldns_radix_new_node
argument_list|(
name|data
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|add
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
comment|/** Search the trie until we can make no further process. */
if|if
condition|(
operator|!
name|ldns_radix_find_prefix
argument_list|(
name|tree
argument_list|,
name|key
argument_list|,
name|len
argument_list|,
operator|&
name|prefix
argument_list|,
operator|&
name|pos
argument_list|)
condition|)
block|{
comment|/** No prefix found */
name|assert
argument_list|(
name|tree
operator|->
name|root
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/** 			 * Example 1: The root: 			 * | [0] 			 **/
name|tree
operator|->
name|root
operator|=
name|add
expr_stmt|;
block|}
else|else
block|{
comment|/** Example 2: 'dns': 			 * | [0] 			 * --| [d+ns] dns 			 **/
name|prefix
operator|=
name|ldns_radix_new_node
argument_list|(
name|NULL
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
comment|/** Find some space in the array for the first byte */
if|if
condition|(
operator|!
name|ldns_radix_array_space
argument_list|(
name|prefix
argument_list|,
name|key
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|prefix
operator|->
name|array
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
comment|/** Set relational pointers */
name|add
operator|->
name|parent
operator|=
name|prefix
expr_stmt|;
name|add
operator|->
name|parent_index
operator|=
literal|0
expr_stmt|;
name|prefix
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|edge
operator|=
name|add
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/** Store the remainder of the prefix */
if|if
condition|(
operator|!
name|ldns_radix_prefix_remainder
argument_list|(
literal|1
argument_list|,
name|key
argument_list|,
name|len
argument_list|,
operator|&
name|prefix
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
operator|&
name|prefix
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|prefix
operator|->
name|array
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
block|}
name|tree
operator|->
name|root
operator|=
name|prefix
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pos
operator|==
name|len
condition|)
block|{
comment|/** Exact match found */
if|if
condition|(
name|prefix
operator|->
name|data
condition|)
block|{
comment|/* Element already exists */
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_EXISTS_ERR
return|;
block|}
name|prefix
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|prefix
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|prefix
operator|->
name|klen
operator|=
name|len
expr_stmt|;
comment|/* redundant */
block|}
else|else
block|{
comment|/** Prefix found */
name|uint8_t
name|byte
init|=
name|key
index|[
name|pos
index|]
decl_stmt|;
name|assert
argument_list|(
name|pos
operator|<
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|<
name|prefix
operator|->
name|offset
operator|||
operator|(
name|byte
operator|-
name|prefix
operator|->
name|offset
operator|)
operator|>=
name|prefix
operator|->
name|len
condition|)
block|{
comment|/** Find some space in the array for the byte. */
comment|/** 			 * Example 3: 'ldns' 			 * | [0] 			 * --| [d+ns] dns 			 * --| [l+dns] ldns 			 **/
if|if
condition|(
operator|!
name|ldns_radix_array_space
argument_list|(
name|prefix
argument_list|,
name|byte
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
name|assert
argument_list|(
name|byte
operator|>=
name|prefix
operator|->
name|offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|byte
operator|-
name|prefix
operator|->
name|offset
operator|)
operator|<=
name|prefix
operator|->
name|len
argument_list|)
expr_stmt|;
name|byte
operator|-=
name|prefix
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|len
condition|)
block|{
comment|/** Create remainder of the string. */
if|if
condition|(
operator|!
name|ldns_radix_str_create
argument_list|(
operator|&
name|prefix
operator|->
name|array
index|[
name|byte
index|]
argument_list|,
name|key
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
block|}
comment|/** Add new node. */
name|add
operator|->
name|parent
operator|=
name|prefix
expr_stmt|;
name|add
operator|->
name|parent_index
operator|=
name|byte
expr_stmt|;
name|prefix
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
operator|=
name|add
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|->
name|array
index|[
name|byte
operator|-
name|prefix
operator|->
name|offset
index|]
operator|.
name|edge
operator|==
name|NULL
condition|)
block|{
comment|/** Use existing element. */
comment|/** 			 * Example 4: 'edns' 			 * | [0] 			 * --| [d+ns] dns 			 * --| [e+dns] edns 			 * --| [l+dns] ldns 			 **/
name|byte
operator|-=
name|prefix
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|len
condition|)
block|{
comment|/** Create remainder of the string. */
if|if
condition|(
operator|!
name|ldns_radix_str_create
argument_list|(
operator|&
name|prefix
operator|->
name|array
index|[
name|byte
index|]
argument_list|,
name|key
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
block|}
comment|/** Add new node. */
name|add
operator|->
name|parent
operator|=
name|prefix
expr_stmt|;
name|add
operator|->
name|parent_index
operator|=
name|byte
expr_stmt|;
name|prefix
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
operator|=
name|add
expr_stmt|;
block|}
else|else
block|{
comment|/** 			 * Use existing element, but it has a shared prefix, 			 * we need a split. 			 */
if|if
condition|(
operator|!
name|ldns_radix_array_split
argument_list|(
operator|&
name|prefix
operator|->
name|array
index|[
name|byte
operator|-
operator|(
name|prefix
operator|->
name|offset
operator|)
index|]
argument_list|,
name|key
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|len
argument_list|,
name|add
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|add
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
block|}
block|}
name|tree
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/**  * Delete data from the tree.  *  */
end_comment

begin_function
name|void
modifier|*
name|ldns_radix_delete
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|del
init|=
name|ldns_radix_search
argument_list|(
name|tree
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|del
condition|)
block|{
name|tree
operator|->
name|count
operator|--
expr_stmt|;
name|data
operator|=
name|del
operator|->
name|data
expr_stmt|;
name|del
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|ldns_radix_del_fix
argument_list|(
name|tree
argument_list|,
name|del
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Search data in the tree.  *  */
end_comment

begin_function
name|ldns_radix_node_t
modifier|*
name|ldns_radix_search
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|radix_strlen_t
name|pos
init|=
literal|0
decl_stmt|;
name|uint8_t
name|byte
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tree
operator|||
operator|!
name|key
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|node
operator|=
name|tree
operator|->
name|root
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|len
condition|)
block|{
return|return
name|node
operator|->
name|data
condition|?
name|node
else|:
name|NULL
return|;
block|}
name|byte
operator|=
name|key
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|byte
operator|<
name|node
operator|->
name|offset
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|byte
operator|-=
name|node
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|byte
operator|>=
name|node
operator|->
name|len
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
operator|>
literal|0
condition|)
block|{
comment|/** Must match additional string. */
if|if
condition|(
name|pos
operator|+
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
operator|>
name|len
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|key
index|[
name|pos
index|]
argument_list|,
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|str
argument_list|,
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|pos
operator|+=
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
expr_stmt|;
block|}
name|node
operator|=
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Search data in the tree, and if not found, find the closest smaller  * element in the tree.  *  */
end_comment

begin_function
name|int
name|ldns_radix_find_less_equal
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|ldns_radix_node_t
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|radix_strlen_t
name|pos
init|=
literal|0
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|int
name|memcmp_res
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tree
operator|||
operator|!
name|tree
operator|->
name|root
operator|||
operator|!
name|key
condition|)
block|{
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|node
operator|=
name|tree
operator|->
name|root
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|len
condition|)
block|{
name|byte
operator|=
name|key
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|byte
operator|<
name|node
operator|->
name|offset
condition|)
block|{
comment|/** 			 * No exact match. The lesser is in this or the 			 * previous node. 			 */
name|ldns_radix_self_or_prev
argument_list|(
name|node
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|byte
operator|-=
name|node
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|byte
operator|>=
name|node
operator|->
name|len
condition|)
block|{
comment|/** 			 * No exact match. The lesser is in this node or the 			 * last of this array, or something before this node. 			 */
operator|*
name|result
operator|=
name|ldns_radix_last_in_subtree_incl_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
block|{
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|pos
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
condition|)
block|{
comment|/** 			 * No exact match. Find the previous in the array 			 * from this index. 			 */
operator|*
name|result
operator|=
name|ldns_radix_prev_from_index
argument_list|(
name|node
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
block|{
name|ldns_radix_self_or_prev
argument_list|(
name|node
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
operator|!=
literal|0
condition|)
block|{
comment|/** Must match additional string. */
if|if
condition|(
name|pos
operator|+
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
operator|>
name|len
condition|)
block|{
comment|/** Additional string is longer than key. */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|key
index|[
name|pos
index|]
argument_list|,
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|str
argument_list|,
name|len
operator|-
name|pos
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/** Key is before this node. */
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/** Key is after additional string. */
operator|*
name|result
operator|=
name|ldns_radix_last_in_subtree_incl_self
argument_list|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
block|{
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
name|memcmp_res
operator|=
name|memcmp
argument_list|(
operator|&
name|key
index|[
name|pos
index|]
argument_list|,
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|str
argument_list|,
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp_res
operator|<
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|memcmp_res
operator|>
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|ldns_radix_last_in_subtree_incl_self
argument_list|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
block|{
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|pos
operator|+=
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
expr_stmt|;
block|}
name|node
operator|=
name|node
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|data
condition|)
block|{
comment|/** Exact match. */
operator|*
name|result
operator|=
name|node
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/** There is a node which is an exact match, but has no element. */
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get the first element in the tree.  *  */
end_comment

begin_function
name|ldns_radix_node_t
modifier|*
name|ldns_radix_first
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|tree
operator|||
operator|!
name|tree
operator|->
name|root
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|first
operator|=
name|tree
operator|->
name|root
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|data
condition|)
block|{
return|return
name|first
return|;
block|}
return|return
name|ldns_radix_next
argument_list|(
name|first
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Get the last element in the tree.  *  */
end_comment

begin_function
name|ldns_radix_node_t
modifier|*
name|ldns_radix_last
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tree
operator|||
operator|!
name|tree
operator|->
name|root
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|ldns_radix_last_in_subtree_incl_self
argument_list|(
name|tree
operator|->
name|root
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Next element.  *  */
end_comment

begin_function
name|ldns_radix_node_t
modifier|*
name|ldns_radix_next
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|node
operator|->
name|len
condition|)
block|{
comment|/** Go down: most-left child is the next. */
name|ldns_radix_node_t
modifier|*
name|next
init|=
name|ldns_radix_next_in_subtree
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
block|{
return|return
name|next
return|;
block|}
block|}
comment|/** No elements in subtree, get to parent and go down next branch. */
while|while
condition|(
name|node
operator|->
name|parent
condition|)
block|{
name|uint8_t
name|index
init|=
name|node
operator|->
name|parent_index
decl_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|index
operator|++
expr_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|node
operator|->
name|len
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|array
index|[
name|index
index|]
operator|.
name|edge
condition|)
block|{
name|ldns_radix_node_t
modifier|*
name|next
decl_stmt|;
comment|/** Node itself. */
if|if
condition|(
name|node
operator|->
name|array
index|[
name|index
index|]
operator|.
name|edge
operator|->
name|data
condition|)
block|{
return|return
name|node
operator|->
name|array
index|[
name|index
index|]
operator|.
name|edge
return|;
block|}
comment|/** Dive into subtree. */
name|next
operator|=
name|ldns_radix_next_in_subtree
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
return|return
name|next
return|;
block|}
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Previous element.  *  */
end_comment

begin_function
name|ldns_radix_node_t
modifier|*
name|ldns_radix_prev
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/** Get to parent and go down previous branch. */
while|while
condition|(
name|node
operator|->
name|parent
condition|)
block|{
name|uint8_t
name|index
init|=
name|node
operator|->
name|parent_index
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|prev
decl_stmt|;
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|ldns_radix_prev_from_index
argument_list|(
name|node
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
return|return
name|prev
return|;
block|}
if|if
condition|(
name|node
operator|->
name|data
condition|)
block|{
return|return
name|node
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Print node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_node_print
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|uint8_t
name|i
parameter_list|,
name|uint8_t
modifier|*
name|str
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|unsigned
name|d
parameter_list|)
block|{
name|uint8_t
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
condition|)
block|{
name|radix_strlen_t
name|l
decl_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"| [%u+"
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|len
condition|;
name|l
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%c"
argument_list|,
operator|(
name|char
operator|)
name|str
index|[
name|l
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"]%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"| [%u]"
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|data
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|node
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|array
index|[
name|j
index|]
operator|.
name|edge
condition|)
block|{
name|ldns_radix_node_print
argument_list|(
name|fd
argument_list|,
name|node
operator|->
name|array
index|[
name|j
index|]
operator|.
name|edge
argument_list|,
name|j
argument_list|,
name|node
operator|->
name|array
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|node
operator|->
name|array
index|[
name|j
index|]
operator|.
name|len
argument_list|,
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * Print radix tree.  *  */
end_comment

begin_function
name|void
name|ldns_radix_printf
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|ldns_radix_t
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fd
operator|||
operator|!
name|tree
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|tree
operator|->
name|root
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"; empty radix tree\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ldns_radix_node_print
argument_list|(
name|fd
argument_list|,
name|tree
operator|->
name|root
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Join two radix trees.  *  */
end_comment

begin_function
name|ldns_status
name|ldns_radix_join
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree1
parameter_list|,
name|ldns_radix_t
modifier|*
name|tree2
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|cur_node
decl_stmt|,
modifier|*
name|next_node
decl_stmt|;
name|ldns_status
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|tree2
operator|||
operator|!
name|tree2
operator|->
name|root
condition|)
block|{
return|return
name|LDNS_STATUS_OK
return|;
block|}
comment|/** Add all elements from tree2 into tree1. */
name|cur_node
operator|=
name|ldns_radix_first
argument_list|(
name|tree2
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_node
condition|)
block|{
name|status
operator|=
name|LDNS_STATUS_NO_DATA
expr_stmt|;
comment|/** Insert current node into tree1 */
if|if
condition|(
name|cur_node
operator|->
name|data
condition|)
block|{
name|status
operator|=
name|ldns_radix_insert
argument_list|(
name|tree1
argument_list|,
name|cur_node
operator|->
name|key
argument_list|,
name|cur_node
operator|->
name|klen
argument_list|,
name|cur_node
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/** Exist errors may occur */
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
operator|&&
name|status
operator|!=
name|LDNS_STATUS_EXISTS_ERR
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
name|next_node
operator|=
name|ldns_radix_next
argument_list|(
name|cur_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LDNS_STATUS_OK
condition|)
block|{
operator|(
name|void
operator|)
name|ldns_radix_delete
argument_list|(
name|tree2
argument_list|,
name|cur_node
operator|->
name|key
argument_list|,
name|cur_node
operator|->
name|klen
argument_list|)
expr_stmt|;
block|}
name|cur_node
operator|=
name|next_node
expr_stmt|;
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/**  * Split a radix tree intwo.  *  */
end_comment

begin_function
name|ldns_status
name|ldns_radix_split
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree1
parameter_list|,
name|size_t
name|num
parameter_list|,
name|ldns_radix_t
modifier|*
modifier|*
name|tree2
parameter_list|)
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|cur_node
decl_stmt|;
name|ldns_status
name|status
init|=
name|LDNS_STATUS_OK
decl_stmt|;
if|if
condition|(
operator|!
name|tree1
operator|||
operator|!
name|tree1
operator|->
name|root
operator|||
name|num
operator|==
literal|0
condition|)
block|{
return|return
name|LDNS_STATUS_OK
return|;
block|}
if|if
condition|(
operator|!
name|tree2
condition|)
block|{
return|return
name|LDNS_STATUS_NULL
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|tree2
condition|)
block|{
operator|*
name|tree2
operator|=
name|ldns_radix_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|tree2
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
block|}
block|}
name|cur_node
operator|=
name|ldns_radix_first
argument_list|(
name|tree1
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|num
operator|&&
name|cur_node
condition|)
block|{
if|if
condition|(
name|cur_node
operator|->
name|data
condition|)
block|{
comment|/** Delete current node from tree1. */
name|uint8_t
modifier|*
name|cur_key
init|=
name|cur_node
operator|->
name|key
decl_stmt|;
name|radix_strlen_t
name|cur_len
init|=
name|cur_node
operator|->
name|klen
decl_stmt|;
name|void
modifier|*
name|cur_data
init|=
name|ldns_radix_delete
argument_list|(
name|tree1
argument_list|,
name|cur_key
argument_list|,
name|cur_len
argument_list|)
decl_stmt|;
comment|/** Insert current node into tree2/ */
if|if
condition|(
operator|!
name|cur_data
condition|)
block|{
return|return
name|LDNS_STATUS_NO_DATA
return|;
block|}
name|status
operator|=
name|ldns_radix_insert
argument_list|(
operator|*
name|tree2
argument_list|,
name|cur_key
argument_list|,
name|cur_len
argument_list|,
name|cur_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LDNS_STATUS_OK
operator|&&
name|status
operator|!=
name|LDNS_STATUS_EXISTS_ERR
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* 			if (status == LDNS_STATUS_OK) { 				cur_node->key = NULL; 				cur_node->klen = 0; 			} */
comment|/** Update count; get first element from tree1 again. */
name|count
operator|++
expr_stmt|;
name|cur_node
operator|=
name|ldns_radix_first
argument_list|(
name|tree1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cur_node
operator|=
name|ldns_radix_next
argument_list|(
name|cur_node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/**  * Call function for all nodes in the tree, such that leaf nodes are  * called before parent nodes.  *  */
end_comment

begin_function
name|void
name|ldns_radix_traverse_postorder
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_radix_node_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ldns_radix_traverse_postorder
argument_list|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/** Call user function */
call|(
modifier|*
name|func
call|)
argument_list|(
name|node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/** Static helper functions */
end_comment

begin_comment
comment|/**  * Find a prefix of the key.  * @param tree:   tree.  * @param key:    key.  * @param len:    length of key.  * @param result: the longest prefix, the entry itself if *pos==len,  *                otherwise an array entry.  * @param pos:    position in string where next unmatched byte is.  *                If *pos==len, an exact match is found.  *                If *pos== 0, a "" match was found.  * @return 0 (false) if no prefix found.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_find_prefix
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|ldns_radix_node_t
modifier|*
modifier|*
name|result
parameter_list|,
name|radix_strlen_t
modifier|*
name|respos
parameter_list|)
block|{
comment|/** Start searching at the root node */
name|ldns_radix_node_t
modifier|*
name|n
init|=
name|tree
operator|->
name|root
decl_stmt|;
name|radix_strlen_t
name|pos
init|=
literal|0
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
operator|*
name|respos
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/** No root, no prefix found */
return|return
literal|0
return|;
block|}
comment|/** For each node, look if we can make further progress */
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|len
condition|)
block|{
comment|/** Exact match */
return|return
literal|1
return|;
block|}
name|byte
operator|=
name|key
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|byte
operator|<
name|n
operator|->
name|offset
condition|)
block|{
comment|/** key< node */
return|return
literal|1
return|;
block|}
name|byte
operator|-=
name|n
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|byte
operator|>=
name|n
operator|->
name|len
condition|)
block|{
comment|/** key> node */
return|return
literal|1
return|;
block|}
comment|/** So far, the trie matches */
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
operator|!=
literal|0
condition|)
block|{
comment|/** Must match additional string */
if|if
condition|(
name|pos
operator|+
name|n
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
operator|>
name|len
condition|)
block|{
return|return
literal|1
return|;
comment|/* no match at child node */
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|key
index|[
name|pos
index|]
argument_list|,
name|n
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|str
argument_list|,
name|n
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|/* no match at child node */
block|}
name|pos
operator|+=
name|n
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|len
expr_stmt|;
block|}
comment|/** Continue searching prefix at this child node */
name|n
operator|=
name|n
operator|->
name|array
index|[
name|byte
index|]
operator|.
name|edge
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/** Update the prefix node */
operator|*
name|respos
operator|=
name|pos
expr_stmt|;
operator|*
name|result
operator|=
name|n
expr_stmt|;
block|}
comment|/** Done */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Make space in the node's array for another byte.  * @param node: node.  * @param byte: byte.  * @return 1 if successful, 0 otherwise.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_array_space
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
comment|/** Is there an array? */
if|if
condition|(
operator|!
name|node
operator|->
name|array
condition|)
block|{
name|assert
argument_list|(
name|node
operator|->
name|capacity
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/** No array, create new array */
name|node
operator|->
name|array
operator|=
name|LDNS_MALLOC
argument_list|(
name|ldns_radix_array_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|array
condition|)
block|{
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
operator|&
name|node
operator|->
name|array
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|capacity
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|offset
operator|=
name|byte
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/** Array exist */
name|assert
argument_list|(
name|node
operator|->
name|array
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|capacity
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|len
operator|==
literal|0
condition|)
block|{
comment|/** Unused array */
name|node
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|offset
operator|=
name|byte
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|byte
operator|<
name|node
operator|->
name|offset
condition|)
block|{
comment|/** Byte is below the offset */
name|uint8_t
name|index
decl_stmt|;
name|uint16_t
name|need
init|=
name|node
operator|->
name|offset
operator|-
name|byte
decl_stmt|;
comment|/** Is there enough capacity? */
if|if
condition|(
name|node
operator|->
name|len
operator|+
name|need
operator|>
name|node
operator|->
name|capacity
condition|)
block|{
comment|/** Not enough capacity, grow array */
if|if
condition|(
operator|!
name|ldns_radix_array_grow
argument_list|(
name|node
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|node
operator|->
name|len
operator|+
name|need
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* failed to grow array */
block|}
block|}
comment|/** Move items to the end */
name|memmove
argument_list|(
operator|&
name|node
operator|->
name|array
index|[
name|need
index|]
argument_list|,
operator|&
name|node
operator|->
name|array
index|[
literal|0
index|]
argument_list|,
name|node
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/** Fix parent index */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|node
operator|->
name|len
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|array
index|[
name|index
operator|+
name|need
index|]
operator|.
name|edge
condition|)
block|{
name|node
operator|->
name|array
index|[
name|index
operator|+
name|need
index|]
operator|.
name|edge
operator|->
name|parent_index
operator|=
name|index
operator|+
name|need
expr_stmt|;
block|}
block|}
comment|/** Zero the first */
name|memset
argument_list|(
operator|&
name|node
operator|->
name|array
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|need
operator|*
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|len
operator|+=
name|need
expr_stmt|;
name|node
operator|->
name|offset
operator|=
name|byte
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|byte
operator|-
name|node
operator|->
name|offset
operator|>=
name|node
operator|->
name|len
condition|)
block|{
comment|/** Byte does not fit in array */
name|uint16_t
name|need
init|=
operator|(
name|byte
operator|-
name|node
operator|->
name|offset
operator|)
operator|-
name|node
operator|->
name|len
operator|+
literal|1
decl_stmt|;
comment|/** Is there enough capacity? */
if|if
condition|(
name|node
operator|->
name|len
operator|+
name|need
operator|>
name|node
operator|->
name|capacity
condition|)
block|{
comment|/** Not enough capacity, grow array */
if|if
condition|(
operator|!
name|ldns_radix_array_grow
argument_list|(
name|node
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|node
operator|->
name|len
operator|+
name|need
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* failed to grow array */
block|}
block|}
comment|/** Zero the added items */
name|memset
argument_list|(
operator|&
name|node
operator|->
name|array
index|[
name|node
operator|->
name|len
index|]
argument_list|,
literal|0
argument_list|,
name|need
operator|*
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|len
operator|+=
name|need
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Grow the array.  * @param node: node.  * @param need: number of elements the array at least need to grow.  *              Can't be bigger than 256.  * @return: 0 if failed, 1 if was successful.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_array_grow
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|unsigned
name|need
parameter_list|)
block|{
name|unsigned
name|size
init|=
operator|(
operator|(
name|unsigned
operator|)
name|node
operator|->
name|capacity
operator|)
operator|*
literal|2
decl_stmt|;
name|ldns_radix_array_t
modifier|*
name|a
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|need
operator|>
name|size
condition|)
block|{
name|size
operator|=
name|need
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|256
condition|)
block|{
name|size
operator|=
literal|256
expr_stmt|;
block|}
name|a
operator|=
name|LDNS_XMALLOC
argument_list|(
name|ldns_radix_array_t
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
return|return
literal|0
return|;
block|}
name|assert
argument_list|(
name|node
operator|->
name|len
operator|<=
name|node
operator|->
name|capacity
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|capacity
operator|<
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|a
index|[
literal|0
index|]
argument_list|,
operator|&
name|node
operator|->
name|array
index|[
literal|0
index|]
argument_list|,
name|node
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|node
operator|->
name|array
argument_list|)
expr_stmt|;
name|node
operator|->
name|array
operator|=
name|a
expr_stmt|;
name|node
operator|->
name|capacity
operator|=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Create a prefix in the array string.  * @param array: array.  * @param key:   key.  * @param pos:   start position in key.  * @param len:   length of key.  * @return 0 if failed, 1 if was successful.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_str_create
parameter_list|(
name|ldns_radix_array_t
modifier|*
name|array
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|pos
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|)
block|{
name|array
operator|->
name|str
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
operator|(
name|len
operator|-
name|pos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|array
operator|->
name|str
condition|)
block|{
return|return
literal|0
return|;
block|}
name|memmove
argument_list|(
name|array
operator|->
name|str
argument_list|,
name|key
operator|+
name|pos
argument_list|,
name|len
operator|-
name|pos
argument_list|)
expr_stmt|;
name|array
operator|->
name|len
operator|=
operator|(
name|len
operator|-
name|pos
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate remainder from prefixes for a split.  * @param prefixlen:  length of prefix.  * @param longer_str: the longer string.  * @param longer_len: the longer string length.  * @param split_str:  the split string.  * @param split_len:  the split string length.  * @return 0 if failed, 1 if successful.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_prefix_remainder
parameter_list|(
name|radix_strlen_t
name|prefix_len
parameter_list|,
name|uint8_t
modifier|*
name|longer_str
parameter_list|,
name|radix_strlen_t
name|longer_len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|split_str
parameter_list|,
name|radix_strlen_t
modifier|*
name|split_len
parameter_list|)
block|{
operator|*
name|split_len
operator|=
name|longer_len
operator|-
name|prefix_len
expr_stmt|;
operator|*
name|split_str
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
operator|(
operator|*
name|split_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|split_str
condition|)
block|{
return|return
literal|0
return|;
block|}
name|memmove
argument_list|(
operator|*
name|split_str
argument_list|,
name|longer_str
operator|+
name|prefix_len
argument_list|,
name|longer_len
operator|-
name|prefix_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Create a split when two nodes have a shared prefix.  * @param array: array.  * @param key:   key.  * @param pos:   start position in key.  * @param len:   length of the key.  * @param add:   node to be added.  * @return 0 if failed, 1 if was successful.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_array_split
parameter_list|(
name|ldns_radix_array_t
modifier|*
name|array
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|radix_strlen_t
name|pos
parameter_list|,
name|radix_strlen_t
name|len
parameter_list|,
name|ldns_radix_node_t
modifier|*
name|add
parameter_list|)
block|{
name|uint8_t
modifier|*
name|str_to_add
init|=
name|key
operator|+
name|pos
decl_stmt|;
name|radix_strlen_t
name|strlen_to_add
init|=
name|len
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|ldns_radix_str_is_prefix
argument_list|(
name|str_to_add
argument_list|,
name|strlen_to_add
argument_list|,
name|array
operator|->
name|str
argument_list|,
name|array
operator|->
name|len
argument_list|)
condition|)
block|{
comment|/** The string to add is a prefix of the existing string */
name|uint8_t
modifier|*
name|split_str
init|=
name|NULL
decl_stmt|,
modifier|*
name|dup_str
init|=
name|NULL
decl_stmt|;
name|radix_strlen_t
name|split_len
init|=
literal|0
decl_stmt|;
comment|/** 		 * Example 5: 'ld' 		 * | [0] 		 * --| [d+ns] dns 		 * --| [e+dns] edns 		 * --| [l+d] ld 		 * ----| [n+s] ldns 		 **/
name|assert
argument_list|(
name|strlen_to_add
operator|<
name|array
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/** Store the remainder in the split string */
if|if
condition|(
name|array
operator|->
name|len
operator|-
name|strlen_to_add
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_radix_prefix_remainder
argument_list|(
name|strlen_to_add
operator|+
literal|1
argument_list|,
name|array
operator|->
name|str
argument_list|,
name|array
operator|->
name|len
argument_list|,
operator|&
name|split_str
argument_list|,
operator|&
name|split_len
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/** Duplicate the string to add */
if|if
condition|(
name|strlen_to_add
operator|!=
literal|0
condition|)
block|{
name|dup_str
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
name|strlen_to_add
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dup_str
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|split_str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|dup_str
argument_list|,
name|str_to_add
argument_list|,
name|strlen_to_add
argument_list|)
expr_stmt|;
block|}
comment|/** Make space in array for the new node */
if|if
condition|(
operator|!
name|ldns_radix_array_space
argument_list|(
name|add
argument_list|,
name|array
operator|->
name|str
index|[
name|strlen_to_add
index|]
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|split_str
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|dup_str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** 		 * The added node should go direct under the existing parent. 		 * The existing node should go under the added node. 		 */
name|add
operator|->
name|parent
operator|=
name|array
operator|->
name|edge
operator|->
name|parent
expr_stmt|;
name|add
operator|->
name|parent_index
operator|=
name|array
operator|->
name|edge
operator|->
name|parent_index
expr_stmt|;
name|add
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|edge
operator|=
name|array
operator|->
name|edge
expr_stmt|;
name|add
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|str
operator|=
name|split_str
expr_stmt|;
name|add
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|split_len
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|parent
operator|=
name|add
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|parent_index
operator|=
literal|0
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|array
operator|->
name|str
argument_list|)
expr_stmt|;
name|array
operator|->
name|edge
operator|=
name|add
expr_stmt|;
name|array
operator|->
name|str
operator|=
name|dup_str
expr_stmt|;
name|array
operator|->
name|len
operator|=
name|strlen_to_add
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldns_radix_str_is_prefix
argument_list|(
name|array
operator|->
name|str
argument_list|,
name|array
operator|->
name|len
argument_list|,
name|str_to_add
argument_list|,
name|strlen_to_add
argument_list|)
condition|)
block|{
comment|/** The existing string is a prefix of the string to add */
comment|/** 		 * Example 6: 'dns-ng' 		 * | [0] 		 * --| [d+ns] dns 		 * ----| [-+ng] dns-ng 		 * --| [e+dns] edns 		 * --| [l+d] ld 		 * ----| [n+s] ldns 		 **/
name|uint8_t
modifier|*
name|split_str
init|=
name|NULL
decl_stmt|;
name|radix_strlen_t
name|split_len
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|array
operator|->
name|len
operator|<
name|strlen_to_add
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen_to_add
operator|-
name|array
operator|->
name|len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_radix_prefix_remainder
argument_list|(
name|array
operator|->
name|len
operator|+
literal|1
argument_list|,
name|str_to_add
argument_list|,
name|strlen_to_add
argument_list|,
operator|&
name|split_str
argument_list|,
operator|&
name|split_len
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/** Make space in array for the new node */
if|if
condition|(
operator|!
name|ldns_radix_array_space
argument_list|(
name|array
operator|->
name|edge
argument_list|,
name|str_to_add
index|[
name|array
operator|->
name|len
index|]
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|split_str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** 		 * The added node should go direct under the existing node. 		 */
name|add
operator|->
name|parent
operator|=
name|array
operator|->
name|edge
expr_stmt|;
name|add
operator|->
name|parent_index
operator|=
name|str_to_add
index|[
name|array
operator|->
name|len
index|]
operator|-
name|array
operator|->
name|edge
operator|->
name|offset
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|array
index|[
name|add
operator|->
name|parent_index
index|]
operator|.
name|edge
operator|=
name|add
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|array
index|[
name|add
operator|->
name|parent_index
index|]
operator|.
name|str
operator|=
name|split_str
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|array
index|[
name|add
operator|->
name|parent_index
index|]
operator|.
name|len
operator|=
name|split_len
expr_stmt|;
block|}
else|else
block|{
comment|/** Create a new split node. */
comment|/** 		 * Example 7: 'dndns' 		 * | [0] 		 * --| [d+n] 		 * ----| [d+ns] dndns 		 * ----| [s] dns 		 * ------| [-+ng] dns-ng 		 * --| [e+dns] edns 		 * --| [l+d] ld 		 * ----| [n+s] ldns 		 **/
name|ldns_radix_node_t
modifier|*
name|common
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|common_str
init|=
name|NULL
decl_stmt|,
modifier|*
name|s1
init|=
name|NULL
decl_stmt|,
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
name|radix_strlen_t
name|common_len
init|=
literal|0
decl_stmt|,
name|l1
init|=
literal|0
decl_stmt|,
name|l2
init|=
literal|0
decl_stmt|;
name|common_len
operator|=
name|ldns_radix_str_common
argument_list|(
name|array
operator|->
name|str
argument_list|,
name|array
operator|->
name|len
argument_list|,
name|str_to_add
argument_list|,
name|strlen_to_add
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|common_len
operator|<
name|array
operator|->
name|len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|common_len
operator|<
name|strlen_to_add
argument_list|)
expr_stmt|;
comment|/** Create the new common node. */
name|common
operator|=
name|ldns_radix_new_node
argument_list|(
name|NULL
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|array
operator|->
name|len
operator|-
name|common_len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_radix_prefix_remainder
argument_list|(
name|common_len
operator|+
literal|1
argument_list|,
name|array
operator|->
name|str
argument_list|,
name|array
operator|->
name|len
argument_list|,
operator|&
name|s1
argument_list|,
operator|&
name|l1
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|strlen_to_add
operator|-
name|common_len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_radix_prefix_remainder
argument_list|(
name|common_len
operator|+
literal|1
argument_list|,
name|str_to_add
argument_list|,
name|strlen_to_add
argument_list|,
operator|&
name|s2
argument_list|,
operator|&
name|l2
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/** Create the shared prefix. */
if|if
condition|(
name|common_len
operator|>
literal|0
condition|)
block|{
name|common_str
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
name|common_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common_str
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|s2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|common_str
argument_list|,
name|str_to_add
argument_list|,
name|common_len
argument_list|)
expr_stmt|;
block|}
comment|/** Make space in the common node array. */
if|if
condition|(
operator|!
name|ldns_radix_array_space
argument_list|(
name|common
argument_list|,
name|array
operator|->
name|str
index|[
name|common_len
index|]
argument_list|)
operator|||
operator|!
name|ldns_radix_array_space
argument_list|(
name|common
argument_list|,
name|str_to_add
index|[
name|common_len
index|]
argument_list|)
condition|)
block|{
name|LDNS_FREE
argument_list|(
name|common
operator|->
name|array
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|common_str
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|s2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** 		 * The common node should go direct under the parent node. 		 * The added and existing nodes go under the common node. 		 */
name|common
operator|->
name|parent
operator|=
name|array
operator|->
name|edge
operator|->
name|parent
expr_stmt|;
name|common
operator|->
name|parent_index
operator|=
name|array
operator|->
name|edge
operator|->
name|parent_index
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|parent
operator|=
name|common
expr_stmt|;
name|array
operator|->
name|edge
operator|->
name|parent_index
operator|=
name|array
operator|->
name|str
index|[
name|common_len
index|]
operator|-
name|common
operator|->
name|offset
expr_stmt|;
name|add
operator|->
name|parent
operator|=
name|common
expr_stmt|;
name|add
operator|->
name|parent_index
operator|=
name|str_to_add
index|[
name|common_len
index|]
operator|-
name|common
operator|->
name|offset
expr_stmt|;
name|common
operator|->
name|array
index|[
name|array
operator|->
name|edge
operator|->
name|parent_index
index|]
operator|.
name|edge
operator|=
name|array
operator|->
name|edge
expr_stmt|;
name|common
operator|->
name|array
index|[
name|array
operator|->
name|edge
operator|->
name|parent_index
index|]
operator|.
name|str
operator|=
name|s1
expr_stmt|;
name|common
operator|->
name|array
index|[
name|array
operator|->
name|edge
operator|->
name|parent_index
index|]
operator|.
name|len
operator|=
name|l1
expr_stmt|;
name|common
operator|->
name|array
index|[
name|add
operator|->
name|parent_index
index|]
operator|.
name|edge
operator|=
name|add
expr_stmt|;
name|common
operator|->
name|array
index|[
name|add
operator|->
name|parent_index
index|]
operator|.
name|str
operator|=
name|s2
expr_stmt|;
name|common
operator|->
name|array
index|[
name|add
operator|->
name|parent_index
index|]
operator|.
name|len
operator|=
name|l2
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|array
operator|->
name|str
argument_list|)
expr_stmt|;
name|array
operator|->
name|edge
operator|=
name|common
expr_stmt|;
name|array
operator|->
name|str
operator|=
name|common_str
expr_stmt|;
name|array
operator|->
name|len
operator|=
name|common_len
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check if one string prefix of other string.  * @param str1: one string.  * @param len1: one string length.  * @param str2: other string.  * @param len2: other string length.  * @return 1 if prefix, 0 otherwise.  *  */
end_comment

begin_function
specifier|static
name|int
name|ldns_radix_str_is_prefix
parameter_list|(
name|uint8_t
modifier|*
name|str1
parameter_list|,
name|radix_strlen_t
name|len1
parameter_list|,
name|uint8_t
modifier|*
name|str2
parameter_list|,
name|radix_strlen_t
name|len2
parameter_list|)
block|{
if|if
condition|(
name|len1
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|/* empty prefix is also a prefix */
block|}
if|if
condition|(
name|len1
operator|>
name|len2
condition|)
block|{
return|return
literal|0
return|;
comment|/* len1 is longer so str1 cannot be a prefix */
block|}
return|return
operator|(
name|memcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of bytes in common for the two strings.  * @param str1: one string.  * @param len1: one string length.  * @param str2: other string.  * @param len2: other string length.  * @return length of substring that the two strings have in common.  *  */
end_comment

begin_function
specifier|static
name|radix_strlen_t
name|ldns_radix_str_common
parameter_list|(
name|uint8_t
modifier|*
name|str1
parameter_list|,
name|radix_strlen_t
name|len1
parameter_list|,
name|uint8_t
modifier|*
name|str2
parameter_list|,
name|radix_strlen_t
name|len2
parameter_list|)
block|{
name|radix_strlen_t
name|i
decl_stmt|,
name|max
init|=
operator|(
name|len1
operator|<
name|len2
operator|)
condition|?
name|len1
else|:
name|len2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str1
index|[
name|i
index|]
operator|!=
name|str2
index|[
name|i
index|]
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
name|max
return|;
block|}
end_function

begin_comment
comment|/**  * Find the next element in the subtree of this node.  * @param node: node.  * @return: node with next element.  *  */
end_comment

begin_function
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_next_in_subtree
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|next
decl_stmt|;
comment|/** Try every subnode. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
condition|)
block|{
comment|/** Node itself. */
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
operator|->
name|data
condition|)
block|{
return|return
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
return|;
block|}
comment|/** Dive into subtree. */
name|next
operator|=
name|ldns_radix_next_in_subtree
argument_list|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
return|return
name|next
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Find the previous element in the array of this node, from index.  * @param node: node.  * @param index: index.  * @return previous node from index.  *  */
end_comment

begin_function
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_prev_from_index
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|uint8_t
name|i
init|=
name|index
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
condition|)
block|{
name|ldns_radix_node_t
modifier|*
name|prev
init|=
name|ldns_radix_last_in_subtree_incl_self
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
return|return
name|prev
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Find last node in subtree, or this node (if have data).  * @param node: node.  * @return last node in subtree, or this node, or NULL.  *  */
end_comment

begin_function
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_last_in_subtree_incl_self
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|ldns_radix_node_t
modifier|*
name|last
init|=
name|ldns_radix_last_in_subtree
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
return|return
name|last
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|data
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Find last node in subtree.  * @param node: node.  * @return last node in subtree.  *  */
end_comment

begin_function
specifier|static
name|ldns_radix_node_t
modifier|*
name|ldns_radix_last_in_subtree
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/** Look for the most right leaf node. */
for|for
control|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|node
operator|->
name|len
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
condition|)
block|{
comment|/** Keep looking for the most right leaf node. */
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|ldns_radix_node_t
modifier|*
name|last
init|=
name|ldns_radix_last_in_subtree
argument_list|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
return|return
name|last
return|;
block|}
block|}
comment|/** Could this be the most right leaf node? */
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
operator|->
name|data
condition|)
block|{
return|return
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Fix tree after deleting element.  * @param tree: tree.  * @param node: node with deleted element.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_del_fix
parameter_list|(
name|ldns_radix_t
modifier|*
name|tree
parameter_list|,
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
while|while
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|data
condition|)
block|{
comment|/** Thou should not delete nodes with data attached. */
return|return;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|len
operator|==
literal|1
operator|&&
name|node
operator|->
name|parent
condition|)
block|{
comment|/** Node with one child is fold back into. */
name|ldns_radix_cleanup_onechild
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|len
operator|==
literal|0
condition|)
block|{
comment|/** Leaf node. */
name|ldns_radix_node_t
modifier|*
name|parent
init|=
name|node
operator|->
name|parent
decl_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
block|{
comment|/** The root is a leaf node. */
name|ldns_radix_node_free
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tree
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/** Cleanup leaf node and continue with parent. */
name|ldns_radix_cleanup_leaf
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|/** 			 * Node cannot be deleted, because it has edge nodes 			 * and no parent to fix up to. 			 */
return|return;
block|}
block|}
comment|/** Not reached. */
return|return;
block|}
end_function

begin_comment
comment|/**  * Clean up a node with one child.  * @param node: node with one child.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_cleanup_onechild
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|uint8_t
modifier|*
name|join_str
decl_stmt|;
name|radix_strlen_t
name|join_len
decl_stmt|;
name|uint8_t
name|parent_index
init|=
name|node
operator|->
name|parent_index
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|child
init|=
name|node
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|edge
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|parent
init|=
name|node
operator|->
name|parent
decl_stmt|;
comment|/** Node has one child, merge the child node into the parent node. */
name|assert
argument_list|(
name|parent_index
operator|<
name|parent
operator|->
name|len
argument_list|)
expr_stmt|;
name|join_len
operator|=
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|len
operator|+
name|node
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|len
operator|+
literal|1
expr_stmt|;
name|join_str
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
name|join_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|join_str
condition|)
block|{
comment|/** 		 * Cleanup failed due to out of memory. 		 * This tree is now inefficient, with the empty node still 		 * existing, but it is still valid. 		 */
return|return;
block|}
name|memcpy
argument_list|(
name|join_str
argument_list|,
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|str
argument_list|,
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|join_str
index|[
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|len
index|]
operator|=
name|child
operator|->
name|parent_index
operator|+
name|node
operator|->
name|offset
expr_stmt|;
name|memmove
argument_list|(
name|join_str
operator|+
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|len
operator|+
literal|1
argument_list|,
name|node
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|node
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|str
operator|=
name|join_str
expr_stmt|;
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|len
operator|=
name|join_len
expr_stmt|;
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|edge
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|child
operator|->
name|parent_index
operator|=
name|parent_index
expr_stmt|;
name|ldns_radix_node_free
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Clean up a leaf node.  * @param node: leaf node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_cleanup_leaf
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|uint8_t
name|parent_index
init|=
name|node
operator|->
name|parent_index
decl_stmt|;
name|ldns_radix_node_t
modifier|*
name|parent
init|=
name|node
operator|->
name|parent
decl_stmt|;
comment|/** Delete lead node and fix parent array. */
name|assert
argument_list|(
name|parent_index
operator|<
name|parent
operator|->
name|len
argument_list|)
expr_stmt|;
name|ldns_radix_node_free
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|parent
operator|->
name|array
index|[
name|parent_index
index|]
operator|.
name|edge
operator|=
name|NULL
expr_stmt|;
comment|/** Fix array in parent. */
if|if
condition|(
name|parent
operator|->
name|len
operator|==
literal|1
condition|)
block|{
name|ldns_radix_node_array_free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent_index
operator|==
literal|0
condition|)
block|{
name|ldns_radix_node_array_free_front
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_radix_node_array_free_end
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * Free a radix node.  * @param node: node.  * @param arg: user argument.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_node_free
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|LDNS_FREE
argument_list|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|klen
operator|=
literal|0
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|node
operator|->
name|array
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Free select edge array.  * @param node: node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_node_array_free
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|node
operator|->
name|array
argument_list|)
expr_stmt|;
name|node
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|capacity
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Free front of select edge array.  * @param node: node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_node_array_free_front
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
comment|/** Remove until a non NULL entry. */
while|while
condition|(
name|n
operator|<
name|node
operator|->
name|len
operator|&&
name|node
operator|->
name|array
index|[
name|n
index|]
operator|.
name|edge
operator|==
name|NULL
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|n
operator|==
name|node
operator|->
name|len
condition|)
block|{
name|ldns_radix_node_array_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|n
operator|<
name|node
operator|->
name|len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|int
operator|)
name|n
operator|<=
operator|(
literal|255
operator|-
operator|(
name|int
operator|)
name|node
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|node
operator|->
name|array
index|[
literal|0
index|]
argument_list|,
operator|&
name|node
operator|->
name|array
index|[
name|n
index|]
argument_list|,
operator|(
name|node
operator|->
name|len
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|offset
operator|+=
name|n
expr_stmt|;
name|node
operator|->
name|len
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
condition|)
block|{
name|node
operator|->
name|array
index|[
name|i
index|]
operator|.
name|edge
operator|->
name|parent_index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|ldns_radix_array_reduce
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Free front of select edge array.  * @param node: node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_node_array_free_end
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
name|uint16_t
name|n
init|=
literal|0
decl_stmt|;
comment|/** Shorten array. */
while|while
condition|(
name|n
operator|<
name|node
operator|->
name|len
operator|&&
name|node
operator|->
name|array
index|[
name|node
operator|->
name|len
operator|-
literal|1
operator|-
name|n
index|]
operator|.
name|edge
operator|==
name|NULL
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|n
operator|==
name|node
operator|->
name|len
condition|)
block|{
name|ldns_radix_node_array_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|n
operator|<
name|node
operator|->
name|len
argument_list|)
expr_stmt|;
name|node
operator|->
name|len
operator|-=
name|n
expr_stmt|;
name|ldns_radix_array_reduce
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Reduce the capacity of the array if needed.  * @param node: node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_array_reduce
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|len
operator|<=
name|node
operator|->
name|capacity
operator|/
literal|2
operator|&&
name|node
operator|->
name|len
operator|!=
name|node
operator|->
name|capacity
condition|)
block|{
name|ldns_radix_array_t
modifier|*
name|a
init|=
name|LDNS_XMALLOC
argument_list|(
name|ldns_radix_array_t
argument_list|,
name|node
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
return|return;
block|}
name|memcpy
argument_list|(
name|a
argument_list|,
name|node
operator|->
name|array
argument_list|,
sizeof|sizeof
argument_list|(
name|ldns_radix_array_t
argument_list|)
operator|*
name|node
operator|->
name|len
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|node
operator|->
name|array
argument_list|)
expr_stmt|;
name|node
operator|->
name|array
operator|=
name|a
expr_stmt|;
name|node
operator|->
name|capacity
operator|=
name|node
operator|->
name|len
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * Return this element if it exists, the previous otherwise.  * @param node: from this node.  * @param result: result node.  *  */
end_comment

begin_function
specifier|static
name|void
name|ldns_radix_self_or_prev
parameter_list|(
name|ldns_radix_node_t
modifier|*
name|node
parameter_list|,
name|ldns_radix_node_t
modifier|*
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|data
condition|)
block|{
operator|*
name|result
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result
operator|=
name|ldns_radix_prev
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

