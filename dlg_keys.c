begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: dlg_keys.c,v 1.34 2011/10/14 00:41:08 tom Exp $  *  *  dlg_keys.c -- runtime binding support for dialog  *  *  Copyright 2006-2009,2011 Thomas E. Dickey  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU Lesser General Public License, version 2.1  *  as published by the Free Software Foundation.  *  *  This program is distributed in the hope that it will be useful, but  *  WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to  *	Free Software Foundation, Inc.  *	51 Franklin St., Fifth Floor  *	Boston, MA 02110, USA.  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dlg_keys.h>
end_include

begin_define
define|#
directive|define
name|LIST_BINDINGS
value|struct _list_bindings
end_define

begin_macro
name|LIST_BINDINGS
end_macro

begin_block
block|{
name|LIST_BINDINGS
modifier|*
name|link
decl_stmt|;
name|WINDOW
modifier|*
name|win
decl_stmt|;
comment|/* window on which widget gets input */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* widget name */
name|bool
name|buttons
decl_stmt|;
comment|/* true only for dlg_register_buttons() */
name|DLG_KEYS_BINDING
modifier|*
name|binding
decl_stmt|;
comment|/* list of bindings */
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|WILDNAME
value|"*"
end_define

begin_decl_stmt
specifier|static
name|LIST_BINDINGS
modifier|*
name|all_bindings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|DLG_KEYS_BINDING
name|end_keys_binding
init|=
name|END_KEYS_BINDING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For a given named widget's window, associate a binding table.  */
end_comment

begin_function
name|void
name|dlg_register_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DLG_KEYS_BINDING
modifier|*
name|binding
parameter_list|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
operator|,
name|q
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
name|win
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|p
operator|->
name|binding
operator|=
name|binding
expr_stmt|;
return|return;
block|}
block|}
comment|/* add built-in bindings at the end of the list (see compare_bindings). */
if|if
condition|(
operator|(
name|p
operator|=
name|dlg_calloc
argument_list|(
name|LIST_BINDINGS
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|->
name|win
operator|=
name|win
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|binding
operator|=
name|binding
expr_stmt|;
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
name|q
operator|->
name|link
operator|=
name|p
expr_stmt|;
else|else
name|all_bindings
operator|=
name|p
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DLG_TRACE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_RC_FILE
argument_list|)
comment|/*      * Trace the binding information assigned to this window.  For most widgets      * there is only one binding table.  forms have two, so the trace will be      * longer.  Since compiled-in bindings are only visible when the widget is      * registered, there is no other way to see what bindings are available,      * than by running dialog and tracing it.      */
name|dlg_trace_msg
argument_list|(
literal|"# dlg_register_window %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dlg_dump_window_keys
argument_list|(
name|dialog_state
operator|.
name|trace_output
argument_list|,
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Unlike dlg_lookup_key(), this looks for either widget-builtin or rc-file  * definitions, depending on whether 'win' is null.  */
end_comment

begin_function
specifier|static
name|int
name|key_is_bound
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|curses_key
parameter_list|,
name|int
name|function_key
parameter_list|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
name|win
operator|&&
operator|!
name|dlg_strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|->
name|binding
index|[
name|n
index|]
operator|.
name|is_function_key
operator|>=
literal|0
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|p
operator|->
name|binding
index|[
name|n
index|]
operator|.
name|curses_key
operator|==
name|curses_key
operator|&&
name|p
operator|->
name|binding
index|[
name|n
index|]
operator|.
name|is_function_key
operator|==
name|function_key
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Call this function after dlg_register_window(), for the list of button  * labels associated with the widget.  *  * Ensure that dlg_lookup_key() will not accidentally translate a key that  * we would like to use for a button abbreviation to some other key, e.g.,  * h/j/k/l for navigation into a cursor key.  Do this by binding the key  * to itself.  *  * See dlg_char_to_button().  */
end_comment

begin_function
name|void
name|dlg_register_buttons
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|buttons
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|;
name|DLG_KEYS_BINDING
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|buttons
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|buttons
index|[
name|n
index|]
operator|!=
literal|0
condition|;
operator|++
name|n
control|)
block|{
name|int
name|curses_key
init|=
name|dlg_button_to_char
argument_list|(
name|buttons
index|[
name|n
index|]
argument_list|)
decl_stmt|;
comment|/* ignore multibyte characters */
if|if
condition|(
name|curses_key
operator|>=
name|KEY_MIN
condition|)
continue|continue;
comment|/* if it is not bound in the widget, skip it (no conflicts) */
if|if
condition|(
operator|!
name|key_is_bound
argument_list|(
name|win
argument_list|,
name|name
argument_list|,
name|curses_key
argument_list|,
name|FALSE
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
comment|/* if it is bound in the rc-file, skip it */
if|if
condition|(
name|key_is_bound
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
name|curses_key
argument_list|,
name|FALSE
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|p
operator|=
name|dlg_calloc
argument_list|(
name|LIST_BINDINGS
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|dlg_calloc
argument_list|(
name|DLG_KEYS_BINDING
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
index|[
literal|0
index|]
operator|.
name|is_function_key
operator|=
literal|0
expr_stmt|;
name|q
index|[
literal|0
index|]
operator|.
name|curses_key
operator|=
name|curses_key
expr_stmt|;
name|q
index|[
literal|0
index|]
operator|.
name|dialog_key
operator|=
name|curses_key
expr_stmt|;
name|q
index|[
literal|1
index|]
operator|=
name|end_keys_binding
expr_stmt|;
name|p
operator|->
name|win
operator|=
name|win
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|buttons
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|binding
operator|=
name|q
expr_stmt|;
comment|/* put these at the beginning, to override the widget's table */
name|p
operator|->
name|link
operator|=
name|all_bindings
expr_stmt|;
name|all_bindings
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Remove the bindings for a given window.  */
end_comment

begin_function
name|void
name|dlg_unregister_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
operator|,
name|q
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
name|win
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
else|else
block|{
name|all_bindings
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
comment|/* the user-defined and buttons-bindings all are length=1 */
if|if
condition|(
name|p
operator|->
name|binding
index|[
literal|1
index|]
operator|.
name|is_function_key
operator|<
literal|0
condition|)
name|free
argument_list|(
name|p
operator|->
name|binding
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dlg_unregister_window
argument_list|(
name|win
argument_list|)
expr_stmt|;
break|break;
block|}
name|q
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Call this after wgetch(), using the same window pointer and passing  * the curses-key.  *  * If there is no binding associated with the widget, it simply returns  * the given curses-key.  *  * Parameters:  *	win is the window on which the wgetch() was done.  *	curses_key is the value returned by wgetch().  *	fkey in/out (on input, it is true if curses_key is a function key,  *		and on output, it is true if the result is a function key).  */
end_comment

begin_function
name|int
name|dlg_lookup_key
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|curses_key
parameter_list|,
name|int
modifier|*
name|fkey
parameter_list|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|;
name|DLG_KEYS_BINDING
modifier|*
name|q
decl_stmt|;
comment|/*      * Ignore mouse clicks, since they are already encoded properly.      */
ifdef|#
directive|ifdef
name|KEY_MOUSE
if|if
condition|(
operator|*
name|fkey
operator|!=
literal|0
operator|&&
name|curses_key
operator|==
name|KEY_MOUSE
condition|)
block|{
empty_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* 	 * Ignore resize events, since they are already encoded properly. 	 */
ifdef|#
directive|ifdef
name|KEY_RESIZE
if|if
condition|(
operator|*
name|fkey
operator|!=
literal|0
operator|&&
name|curses_key
operator|==
name|KEY_RESIZE
condition|)
block|{
empty_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|*
name|fkey
operator|==
literal|0
operator|||
name|curses_key
operator|<
name|KEY_MAX
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|WILDNAME
decl_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|all_bindings
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
name|win
condition|)
block|{
name|name
operator|=
name|p
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|all_bindings
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
name|win
operator|||
operator|(
name|p
operator|->
name|win
operator|==
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
name|int
name|function_key
init|=
operator|(
operator|*
name|fkey
operator|!=
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|binding
init|;
name|q
operator|->
name|is_function_key
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|p
operator|->
name|buttons
operator|&&
operator|!
name|function_key
operator|&&
name|q
operator|->
name|curses_key
operator|==
operator|(
name|int
operator|)
name|dlg_toupper
argument_list|(
name|curses_key
argument_list|)
condition|)
block|{
operator|*
name|fkey
operator|=
literal|0
expr_stmt|;
return|return
name|q
operator|->
name|dialog_key
return|;
block|}
if|if
condition|(
name|q
operator|->
name|curses_key
operator|==
name|curses_key
operator|&&
name|q
operator|->
name|is_function_key
operator|==
name|function_key
condition|)
block|{
operator|*
name|fkey
operator|=
name|q
operator|->
name|dialog_key
expr_stmt|;
return|return
operator|*
name|fkey
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|curses_key
return|;
block|}
end_function

begin_comment
comment|/*  * Test a dialog internal keycode to see if it corresponds to one of the push  * buttons on the widget such as "OK".  *  * This is only useful if there are user-defined key bindings, since there are  * no built-in bindings that map directly to DLGK_OK, etc.  *  * See also dlg_ok_buttoncode().  */
end_comment

begin_function
name|int
name|dlg_result_key
parameter_list|(
name|int
name|dialog_key
parameter_list|,
name|int
name|fkey
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|resultp
parameter_list|)
block|{
name|int
name|done
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
if|if
condition|(
name|fkey
condition|)
block|{
switch|switch
condition|(
operator|(
name|DLG_KEYS_ENUM
operator|)
name|dialog_key
condition|)
block|{
case|case
name|DLGK_OK
case|:
operator|*
name|resultp
operator|=
name|DLG_EXIT_OK
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DLGK_CANCEL
case|:
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|nocancel
condition|)
block|{
operator|*
name|resultp
operator|=
name|DLG_EXIT_CANCEL
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_EXTRA
case|:
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
condition|)
block|{
operator|*
name|resultp
operator|=
name|DLG_EXIT_EXTRA
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_HELP
case|:
if|if
condition|(
name|dialog_vars
operator|.
name|help_button
condition|)
block|{
operator|*
name|resultp
operator|=
name|DLG_EXIT_HELP
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_ESC
case|:
operator|*
name|resultp
operator|=
name|DLG_EXIT_ESC
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|dialog_key
operator|==
name|ESC
condition|)
block|{
operator|*
name|resultp
operator|=
name|DLG_EXIT_ESC
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dialog_key
operator|==
name|ERR
condition|)
block|{
operator|*
name|resultp
operator|=
name|DLG_EXIT_ERROR
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|done
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
end_ifdef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|CODENAME
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ASCII_NAME
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
value|{ #name, code }
end_define

begin_define
define|#
directive|define
name|CURSES_NAME
parameter_list|(
name|upper
parameter_list|)
value|{ #upper, KEY_ ## upper }
end_define

begin_define
define|#
directive|define
name|COUNT_CURSES
value|sizeof(curses_names)/sizeof(curses_names[0])
end_define

begin_decl_stmt
specifier|static
specifier|const
name|CODENAME
name|curses_names
index|[]
init|=
block|{
name|ASCII_NAME
argument_list|(
name|ESC
argument_list|,
literal|'\033'
argument_list|)
block|,
name|ASCII_NAME
argument_list|(
name|CR
argument_list|,
literal|'\r'
argument_list|)
block|,
name|ASCII_NAME
argument_list|(
name|LF
argument_list|,
literal|'\n'
argument_list|)
block|,
name|ASCII_NAME
argument_list|(
name|FF
argument_list|,
literal|'\f'
argument_list|)
block|,
name|ASCII_NAME
argument_list|(
name|TAB
argument_list|,
literal|'\t'
argument_list|)
block|,
name|ASCII_NAME
argument_list|(
name|DEL
argument_list|,
literal|'\177'
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|DOWN
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|UP
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|LEFT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|RIGHT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|HOME
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|BACKSPACE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|F0
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|DL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|IL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|DC
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|IC
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|EIC
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|CLEAR
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|EOS
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|EOL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SF
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SR
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|NPAGE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|PPAGE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|STAB
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|CTAB
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|CATAB
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|ENTER
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|PRINT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|LL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|A1
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|A3
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|B2
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|C1
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|C3
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|BTAB
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|BEG
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|CANCEL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|CLOSE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|COMMAND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|COPY
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|CREATE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|END
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|EXIT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|FIND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|HELP
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|MARK
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|MESSAGE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|MOVE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|NEXT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|OPEN
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|OPTIONS
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|PREVIOUS
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|REDO
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|REFERENCE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|REFRESH
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|REPLACE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|RESTART
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|RESUME
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SAVE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SBEG
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SCANCEL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SCOMMAND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SCOPY
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SCREATE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SDC
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SDL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SELECT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SEND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SEOL
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SEXIT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SFIND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SHELP
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SHOME
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SIC
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SLEFT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SMESSAGE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SMOVE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SNEXT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SOPTIONS
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SPREVIOUS
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SPRINT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SREDO
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SREPLACE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SRIGHT
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SRSUME
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SSAVE
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SSUSPEND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SUNDO
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|SUSPEND
argument_list|)
block|,
name|CURSES_NAME
argument_list|(
name|UNDO
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIALOG_NAME
parameter_list|(
name|upper
parameter_list|)
value|{ #upper, DLGK_ ## upper }
end_define

begin_define
define|#
directive|define
name|COUNT_DIALOG
value|sizeof(dialog_names)/sizeof(dialog_names[0])
end_define

begin_decl_stmt
specifier|static
specifier|const
name|CODENAME
name|dialog_names
index|[]
init|=
block|{
name|DIALOG_NAME
argument_list|(
name|OK
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|CANCEL
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|EXTRA
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|HELP
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|ESC
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|PAGE_FIRST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|PAGE_LAST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|PAGE_NEXT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|PAGE_PREV
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|ITEM_FIRST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|ITEM_LAST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|ITEM_NEXT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|ITEM_PREV
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FIELD_FIRST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FIELD_LAST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FIELD_NEXT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FIELD_PREV
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FORM_FIRST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FORM_LAST
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FORM_NEXT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FORM_PREV
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|GRID_UP
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|GRID_DOWN
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|GRID_LEFT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|GRID_RIGHT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|DELETE_LEFT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|DELETE_RIGHT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|DELETE_ALL
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|ENTER
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|BEGIN
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|FINAL
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|SELECT
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
name|HELPFILE
argument_list|)
block|,
name|DIALOG_NAME
argument_list|(
argument|TRACE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|skip_white
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|skip_black
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Find a user-defined binding, given the curses key code.  */
end_comment

begin_function
specifier|static
name|DLG_KEYS_BINDING
modifier|*
name|find_binding
parameter_list|(
name|char
modifier|*
name|widget
parameter_list|,
name|int
name|curses_key
parameter_list|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|;
name|DLG_KEYS_BINDING
modifier|*
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
literal|0
operator|&&
operator|!
name|dlg_strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|widget
argument_list|)
operator|&&
name|p
operator|->
name|binding
operator|->
name|curses_key
operator|==
name|curses_key
condition|)
block|{
name|result
operator|=
name|p
operator|->
name|binding
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Built-in bindings have a nonzero "win" member, and the associated binding  * table can have more than one entry.  We keep those last, since lookups will  * find the user-defined bindings first and use those.  *  * Sort "*" (all-widgets) entries past named widgets, since those are less  * specific.  */
end_comment

begin_function
specifier|static
name|int
name|compare_bindings
parameter_list|(
name|LIST_BINDINGS
modifier|*
name|a
parameter_list|,
name|LIST_BINDINGS
modifier|*
name|b
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|win
operator|==
name|b
operator|->
name|win
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
condition|)
block|{
name|result
operator|=
name|a
operator|->
name|binding
index|[
literal|0
index|]
operator|.
name|curses_key
operator|-
name|b
operator|->
name|binding
index|[
literal|0
index|]
operator|.
name|curses_key
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|WILDNAME
argument_list|)
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|WILDNAME
argument_list|)
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|dlg_strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|win
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Find a user-defined binding, given the curses key code.  If it does not  * exist, create a new one, inserting it into the linked list, keeping it  * sorted to simplify lookups for user-defined bindings that can override  * the built-in bindings.  */
end_comment

begin_function
specifier|static
name|DLG_KEYS_BINDING
modifier|*
name|make_binding
parameter_list|(
name|char
modifier|*
name|widget
parameter_list|,
name|int
name|curses_key
parameter_list|,
name|int
name|is_function
parameter_list|,
name|int
name|dialog_key
parameter_list|)
block|{
name|LIST_BINDINGS
modifier|*
name|entry
init|=
literal|0
decl_stmt|;
name|DLG_KEYS_BINDING
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|DLG_KEYS_BINDING
modifier|*
name|result
init|=
name|find_binding
argument_list|(
name|widget
argument_list|,
name|curses_key
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
operator|&&
operator|(
name|entry
operator|=
name|dlg_calloc
argument_list|(
name|LIST_BINDINGS
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|data
operator|=
name|dlg_calloc
argument_list|(
name|DLG_KEYS_BINDING
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|name
operator|=
name|dlg_strclone
argument_list|(
name|widget
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|entry
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|->
name|binding
operator|=
name|data
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|.
name|is_function_key
operator|=
name|is_function
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|.
name|curses_key
operator|=
name|curses_key
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|.
name|dialog_key
operator|=
name|dialog_key
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|end_keys_binding
expr_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
operator|,
name|q
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|compare_bindings
argument_list|(
name|entry
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
block|{
name|q
operator|->
name|link
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|all_bindings
operator|=
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|entry
operator|->
name|link
operator|=
name|p
expr_stmt|;
block|}
name|result
operator|=
name|data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the parameters of the "bindkeys" configuration-file entry.  This  * expects widget name which may be "*", followed by curses key definition and  * then dialog key definition.  *  * The curses key "should" be one of the names (ignoring case) from  * curses_names[], but may also be a single control character (prefix "^" or  * "~" depending on whether it is C0 or C1), or an escaped single character.  * Binding a printable character with dialog is possible but not useful.  *  * The dialog key must be one of the names from dialog_names[].  */
end_comment

begin_function
name|int
name|dlg_parse_bindkey
parameter_list|(
name|char
modifier|*
name|params
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|skip_white
argument_list|(
name|params
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|bool
name|escaped
init|=
name|FALSE
decl_stmt|;
name|int
name|modified
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|xx
decl_stmt|;
name|char
modifier|*
name|widget
decl_stmt|;
name|int
name|is_function
init|=
name|FALSE
decl_stmt|;
name|int
name|curses_key
decl_stmt|;
name|int
name|dialog_key
decl_stmt|;
name|curses_key
operator|=
operator|-
literal|1
expr_stmt|;
name|dialog_key
operator|=
operator|-
literal|1
expr_stmt|;
name|widget
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|skip_black
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|widget
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|curses_key
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|escaped
condition|)
block|{
name|escaped
operator|=
name|FALSE
expr_stmt|;
name|curses_key
operator|=
operator|*
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modified
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'?'
condition|)
block|{
name|curses_key
operator|=
operator|(
operator|(
name|modified
operator|==
literal|'^'
operator|)
condition|?
literal|127
else|:
literal|255
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curses_key
operator|=
operator|(
operator|(
name|modified
operator|==
literal|'^'
operator|)
condition|?
operator|(
operator|*
name|p
operator|&
literal|0x1f
operator|)
else|:
operator|(
operator|(
operator|*
name|p
operator|&
literal|0x1f
operator|)
operator||
literal|0x80
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
block|{
name|modified
operator|=
operator|*
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'~'
condition|)
block|{
name|modified
operator|=
operator|*
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|curses_key
operator|<
literal|0
condition|)
block|{
name|char
name|fprefix
index|[
literal|2
index|]
decl_stmt|;
name|char
name|check
index|[
literal|2
index|]
decl_stmt|;
name|int
name|keynumber
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%[Ff]%d%c"
argument_list|,
name|fprefix
argument_list|,
operator|&
name|keynumber
argument_list|,
name|check
argument_list|)
operator|==
literal|2
condition|)
block|{
name|curses_key
operator|=
name|KEY_F
argument_list|(
name|keynumber
argument_list|)
expr_stmt|;
name|is_function
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|xx
operator|=
literal|0
init|;
name|xx
operator|<
name|COUNT_CURSES
condition|;
operator|++
name|xx
control|)
block|{
if|if
condition|(
operator|!
name|dlg_strcmp
argument_list|(
name|curses_names
index|[
name|xx
index|]
operator|.
name|name
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|curses_key
operator|=
name|curses_names
index|[
name|xx
index|]
operator|.
name|code
expr_stmt|;
name|is_function
operator|=
operator|(
name|curses_key
operator|>=
name|KEY_MIN
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|q
operator|=
name|skip_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|skip_black
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|q
condition|)
block|{
for|for
control|(
name|xx
operator|=
literal|0
init|;
name|xx
operator|<
name|COUNT_DIALOG
condition|;
operator|++
name|xx
control|)
block|{
if|if
condition|(
operator|!
name|dlg_strcmp
argument_list|(
name|dialog_names
index|[
name|xx
index|]
operator|.
name|name
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|dialog_key
operator|=
name|dialog_names
index|[
name|xx
index|]
operator|.
name|code
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|widget
operator|!=
literal|'\0'
operator|&&
name|curses_key
operator|>=
literal|0
operator|&&
name|dialog_key
operator|>=
literal|0
operator|&&
name|make_binding
argument_list|(
name|widget
argument_list|,
name|curses_key
argument_list|,
name|is_function
argument_list|,
name|dialog_key
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_curses_key
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|curses_key
parameter_list|)
block|{
if|if
condition|(
name|curses_key
operator|>
name|KEY_MIN
condition|)
block|{
name|unsigned
name|n
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNT_CURSES
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|curses_names
index|[
name|n
index|]
operator|.
name|code
operator|==
name|curses_key
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|curses_names
index|[
name|n
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|curses_key
operator|>=
name|KEY_F
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"F%d"
argument_list|,
name|curses_key
operator|-
name|KEY_F
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"curses%d"
argument_list|,
name|curses_key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|curses_key
operator|>=
literal|0
operator|&&
name|curses_key
operator|<
literal|32
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"^%c"
argument_list|,
name|curses_key
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curses_key
operator|==
literal|127
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"^?"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curses_key
operator|>=
literal|128
operator|&&
name|curses_key
operator|<
literal|160
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"~%c"
argument_list|,
name|curses_key
operator|-
literal|64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curses_key
operator|==
literal|255
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"~?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\%c"
argument_list|,
name|curses_key
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dialog_key
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|dialog_key
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNT_DIALOG
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|dialog_names
index|[
name|n
index|]
operator|.
name|code
operator|==
name|dialog_key
condition|)
block|{
name|fputs
argument_list|(
name|dialog_names
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"dialog%d"
argument_list|,
name|dialog_key
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_one_binding
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|widget
parameter_list|,
name|DLG_KEYS_BINDING
modifier|*
name|binding
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"bindkey %s "
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|dump_curses_key
argument_list|(
name|fp
argument_list|,
name|binding
operator|->
name|curses_key
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|dump_dialog_key
argument_list|(
name|fp
argument_list|,
name|binding
operator|->
name|dialog_key
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump bindings for the given window.  If it is a null, then this dumps the  * initial bindings which were loaded from the rc-file that are used as  * overall defaults.  */
end_comment

begin_function
name|void
name|dlg_dump_window_keys
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|;
name|DLG_KEYS_BINDING
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|last
init|=
literal|""
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
name|win
condition|)
block|{
if|if
condition|(
name|dlg_strcmp
argument_list|(
name|last
argument_list|,
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n# key bindings for %s widgets\n"
argument_list|,
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|WILDNAME
argument_list|)
condition|?
literal|"all"
else|:
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|name
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
name|p
operator|->
name|binding
init|;
name|q
operator|->
name|is_function_key
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
name|dump_one_binding
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump all of the bindings which are not specific to a given widget, i.e.,  * the "win" member is null.  */
end_comment

begin_function
name|void
name|dlg_dump_keys
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|LIST_BINDINGS
modifier|*
name|p
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_bindings
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
if|if
condition|(
name|p
operator|->
name|win
operator|==
literal|0
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|dlg_dump_window_keys
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_RC_FILE */
end_comment

end_unit

