begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_STDIO
end_define

begin_comment
comment|/* for sprintf() */
end_comment

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_include
include|#
directive|include
file|"apr_xml.h"
end_include

begin_include
include|#
directive|include
file|"apu_config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_XMLPARSE_XMLPARSE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<xmlparse/xmlparse.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_XMLTOK_XMLPARSE_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<xmltok/xmlparse.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_XML_XMLPARSE_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<xml/xmlparse.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUG_CR
value|"\r\n"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|APR_KW_xmlns
index|[]
init|=
block|{
literal|0x78
block|,
literal|0x6D
block|,
literal|0x6C
block|,
literal|0x6E
block|,
literal|0x73
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|APR_KW_xmlns_lang
index|[]
init|=
block|{
literal|0x78
block|,
literal|0x6D
block|,
literal|0x6C
block|,
literal|0x3A
block|,
literal|0x6C
block|,
literal|0x61
block|,
literal|0x6E
block|,
literal|0x67
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|APR_KW_DAV
index|[]
init|=
block|{
literal|0x44
block|,
literal|0x41
block|,
literal|0x56
block|,
literal|0x3A
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* errors related to namespace processing */
end_comment

begin_define
define|#
directive|define
name|APR_XML_NS_ERROR_UNKNOWN_PREFIX
value|(-1000)
end_define

begin_define
define|#
directive|define
name|APR_XML_NS_ERROR_INVALID_DECL
value|(-1001)
end_define

begin_comment
comment|/* test for a namespace prefix that begins with [Xx][Mm][Ll] */
end_comment

begin_define
define|#
directive|define
name|APR_XML_NS_IS_RESERVED
parameter_list|(
name|name
parameter_list|)
define|\
value|( (name[0] == 0x58 || name[0] == 0x78)&& \ 	  (name[1] == 0x4D || name[1] == 0x6D)&& \ 	  (name[2] == 0x4C || name[2] == 0x6C) )
end_define

begin_comment
comment|/* the real (internal) definition of the parser context */
end_comment

begin_struct
struct|struct
name|apr_xml_parser
block|{
name|apr_xml_doc
modifier|*
name|doc
decl_stmt|;
comment|/* the doc we're parsing */
name|apr_pool_t
modifier|*
name|p
decl_stmt|;
comment|/* the pool we allocate from */
name|apr_xml_elem
modifier|*
name|cur_elem
decl_stmt|;
comment|/* current element */
name|int
name|error
decl_stmt|;
comment|/* an error has occurred */
define|#
directive|define
name|APR_XML_ERROR_EXPAT
value|1
define|#
directive|define
name|APR_XML_ERROR_PARSE_DONE
value|2
comment|/* also: public APR_XML_NS_ERROR_* values (if any) */
name|XML_Parser
name|xp
decl_stmt|;
comment|/* the actual (Expat) XML parser */
name|enum
name|XML_Error
name|xp_err
decl_stmt|;
comment|/* stored Expat error code */
block|}
struct|;
end_struct

begin_comment
comment|/* struct for scoping namespace declarations */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|apr_xml_ns_scope
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* prefix used for this ns */
name|int
name|ns
decl_stmt|;
comment|/* index into namespace table */
name|int
name|emptyURI
decl_stmt|;
comment|/* the namespace URI is the empty string */
name|struct
name|apr_xml_ns_scope
modifier|*
name|next
decl_stmt|;
comment|/* next scoped namespace */
block|}
name|apr_xml_ns_scope
typedef|;
end_typedef

begin_comment
comment|/* return namespace table index for a given prefix */
end_comment

begin_function
specifier|static
name|int
name|find_prefix
parameter_list|(
name|apr_xml_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|apr_xml_elem
modifier|*
name|elem
init|=
name|parser
operator|->
name|cur_elem
decl_stmt|;
comment|/*     ** Walk up the tree, looking for a namespace scope that defines this     ** prefix.     */
for|for
control|(
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|parent
control|)
block|{
name|apr_xml_ns_scope
modifier|*
name|ns_scope
init|=
name|elem
operator|->
name|ns_scope
decl_stmt|;
for|for
control|(
name|ns_scope
operator|=
name|elem
operator|->
name|ns_scope
init|;
name|ns_scope
condition|;
name|ns_scope
operator|=
name|ns_scope
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prefix
argument_list|,
name|ns_scope
operator|->
name|prefix
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ns_scope
operator|->
name|emptyURI
condition|)
block|{
comment|/* 		    ** It is possible to set the default namespace to an 		    ** empty URI string; this resets the default namespace 		    ** to mean "no namespace." We just found the prefix 		    ** refers to an empty URI, so return "no namespace." 		    */
return|return
name|APR_XML_NS_NONE
return|;
block|}
return|return
name|ns_scope
operator|->
name|ns
return|;
block|}
block|}
block|}
comment|/*      * If the prefix is empty (""), this means that a prefix was not      * specified in the element/attribute. The search that was performed      * just above did not locate a default namespace URI (which is stored      * into ns_scope with an empty prefix). This means the element/attribute      * has "no namespace". We have a reserved value for this.      */
if|if
condition|(
operator|*
name|prefix
operator|==
literal|'\0'
condition|)
block|{
return|return
name|APR_XML_NS_NONE
return|;
block|}
comment|/* not found */
return|return
name|APR_XML_NS_ERROR_UNKNOWN_PREFIX
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_handler
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|)
block|{
name|apr_xml_parser
modifier|*
name|parser
init|=
name|userdata
decl_stmt|;
name|apr_xml_elem
modifier|*
name|elem
decl_stmt|;
name|apr_xml_attr
modifier|*
name|attr
decl_stmt|;
name|apr_xml_attr
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|;
specifier|const
name|char
modifier|*
name|quoted
decl_stmt|;
name|char
modifier|*
name|elem_name
decl_stmt|;
comment|/* punt once we find an error */
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
name|elem
operator|=
name|apr_pcalloc
argument_list|(
name|parser
operator|->
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prep the element */
name|elem
operator|->
name|name
operator|=
name|elem_name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* fill in the attributes (note: ends up in reverse order) */
while|while
condition|(
operator|*
name|attrs
condition|)
block|{
name|attr
operator|=
name|apr_palloc
argument_list|(
name|parser
operator|->
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|p
argument_list|,
operator|*
name|attrs
operator|++
argument_list|)
expr_stmt|;
name|attr
operator|->
name|value
operator|=
name|apr_pstrdup
argument_list|(
name|parser
operator|->
name|p
argument_list|,
operator|*
name|attrs
operator|++
argument_list|)
expr_stmt|;
name|attr
operator|->
name|next
operator|=
name|elem
operator|->
name|attr
expr_stmt|;
name|elem
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
block|}
comment|/* hook the element into the tree */
if|if
condition|(
name|parser
operator|->
name|cur_elem
operator|==
name|NULL
condition|)
block|{
comment|/* no current element; this also becomes the root */
name|parser
operator|->
name|cur_elem
operator|=
name|parser
operator|->
name|doc
operator|->
name|root
operator|=
name|elem
expr_stmt|;
block|}
else|else
block|{
comment|/* this element appeared within the current elem */
name|elem
operator|->
name|parent
operator|=
name|parser
operator|->
name|cur_elem
expr_stmt|;
comment|/* set up the child/sibling links */
if|if
condition|(
name|elem
operator|->
name|parent
operator|->
name|last_child
operator|==
name|NULL
condition|)
block|{
comment|/* no first child either */
name|elem
operator|->
name|parent
operator|->
name|first_child
operator|=
name|elem
operator|->
name|parent
operator|->
name|last_child
operator|=
name|elem
expr_stmt|;
block|}
else|else
block|{
comment|/* hook onto the end of the parent's children */
name|elem
operator|->
name|parent
operator|->
name|last_child
operator|->
name|next
operator|=
name|elem
expr_stmt|;
name|elem
operator|->
name|parent
operator|->
name|last_child
operator|=
name|elem
expr_stmt|;
block|}
comment|/* this element is now the current element */
name|parser
operator|->
name|cur_elem
operator|=
name|elem
expr_stmt|;
block|}
comment|/* scan the attributes for namespace declarations */
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|attr
operator|=
name|elem
operator|->
name|attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
name|APR_KW_xmlns
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
operator|&
name|attr
operator|->
name|name
index|[
literal|5
index|]
decl_stmt|;
name|apr_xml_ns_scope
modifier|*
name|ns_scope
decl_stmt|;
comment|/* test for xmlns:foo= form and xmlns= form */
if|if
condition|(
operator|*
name|prefix
operator|==
literal|0x3A
condition|)
block|{
comment|/* a namespace prefix declaration must have a                    non-empty value. */
if|if
condition|(
name|attr
operator|->
name|value
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|APR_XML_NS_ERROR_INVALID_DECL
expr_stmt|;
return|return;
block|}
operator|++
name|prefix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|prefix
operator|!=
literal|'\0'
condition|)
block|{
comment|/* advance "prev" since "attr" is still present */
name|prev
operator|=
name|attr
expr_stmt|;
continue|continue;
block|}
comment|/* quote the URI before we ever start working with it */
name|quoted
operator|=
name|apr_xml_quote_string
argument_list|(
name|parser
operator|->
name|p
argument_list|,
name|attr
operator|->
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* build and insert the new scope */
name|ns_scope
operator|=
name|apr_pcalloc
argument_list|(
name|parser
operator|->
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ns_scope
argument_list|)
argument_list|)
expr_stmt|;
name|ns_scope
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|ns_scope
operator|->
name|ns
operator|=
name|apr_xml_insert_uri
argument_list|(
name|parser
operator|->
name|doc
operator|->
name|namespaces
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
name|ns_scope
operator|->
name|emptyURI
operator|=
operator|*
name|quoted
operator|==
literal|'\0'
expr_stmt|;
name|ns_scope
operator|->
name|next
operator|=
name|elem
operator|->
name|ns_scope
expr_stmt|;
name|elem
operator|->
name|ns_scope
operator|=
name|ns_scope
expr_stmt|;
comment|/* remove this attribute from the element */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|elem
operator|->
name|attr
operator|=
name|attr
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|attr
operator|->
name|next
expr_stmt|;
comment|/* Note: prev will not be advanced since we just removed "attr" */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
name|APR_KW_xmlns_lang
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* save away the language (in quoted form) */
name|elem
operator|->
name|lang
operator|=
name|apr_xml_quote_string
argument_list|(
name|parser
operator|->
name|p
argument_list|,
name|attr
operator|->
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove this attribute from the element */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|elem
operator|->
name|attr
operator|=
name|attr
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|attr
operator|->
name|next
expr_stmt|;
comment|/* Note: prev will not be advanced since we just removed "attr" */
block|}
else|else
block|{
comment|/* advance "prev" since "attr" is still present */
name|prev
operator|=
name|attr
expr_stmt|;
block|}
block|}
comment|/*     ** If an xml:lang attribute didn't exist (lang==NULL), then copy the     ** language from the parent element (if present).     **     ** NOTE: elem_size() *depends* upon this pointer equality.     */
if|if
condition|(
name|elem
operator|->
name|lang
operator|==
name|NULL
operator|&&
name|elem
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|elem
operator|->
name|lang
operator|=
name|elem
operator|->
name|parent
operator|->
name|lang
expr_stmt|;
comment|/* adjust the element's namespace */
name|colon
operator|=
name|strchr
argument_list|(
name|elem_name
argument_list|,
literal|0x3A
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * The element is using the default namespace, which will always 	 * be found. Either it will be "no namespace", or a default 	 * namespace URI has been specified at some point. 	 */
name|elem
operator|->
name|ns
operator|=
name|find_prefix
argument_list|(
name|parser
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|APR_XML_NS_IS_RESERVED
argument_list|(
name|elem
operator|->
name|name
argument_list|)
condition|)
block|{
name|elem
operator|->
name|ns
operator|=
name|APR_XML_NS_NONE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
name|elem
operator|->
name|ns
operator|=
name|find_prefix
argument_list|(
name|parser
argument_list|,
name|elem
operator|->
name|name
argument_list|)
expr_stmt|;
name|elem
operator|->
name|name
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|APR_XML_NS_IS_ERROR
argument_list|(
name|elem
operator|->
name|ns
argument_list|)
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|elem
operator|->
name|ns
expr_stmt|;
return|return;
block|}
block|}
comment|/* adjust all remaining attributes' namespaces */
for|for
control|(
name|attr
operator|=
name|elem
operator|->
name|attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
comment|/*          * apr_xml_attr defines this as "const" but we dup'd it, so we          * know that we can change it. a bit hacky, but the existing          * structure def is best.          */
name|char
modifier|*
name|attr_name
init|=
operator|(
name|char
operator|*
operator|)
name|attr
operator|->
name|name
decl_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|attr_name
argument_list|,
literal|0x3A
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Attributes do NOT use the default namespace. Therefore, 	     * we place them into the "no namespace" category. 	     */
name|attr
operator|->
name|ns
operator|=
name|APR_XML_NS_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|APR_XML_NS_IS_RESERVED
argument_list|(
name|attr
operator|->
name|name
argument_list|)
condition|)
block|{
name|attr
operator|->
name|ns
operator|=
name|APR_XML_NS_NONE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
name|attr
operator|->
name|ns
operator|=
name|find_prefix
argument_list|(
name|parser
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|attr
operator|->
name|name
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|APR_XML_NS_IS_ERROR
argument_list|(
name|attr
operator|->
name|ns
argument_list|)
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|attr
operator|->
name|ns
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|end_handler
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|apr_xml_parser
modifier|*
name|parser
init|=
name|userdata
decl_stmt|;
comment|/* punt once we find an error */
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
comment|/* pop up one level */
name|parser
operator|->
name|cur_elem
operator|=
name|parser
operator|->
name|cur_elem
operator|->
name|parent
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdata_handler
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|apr_xml_parser
modifier|*
name|parser
init|=
name|userdata
decl_stmt|;
name|apr_xml_elem
modifier|*
name|elem
decl_stmt|;
name|apr_text_header
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* punt once we find an error */
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
name|elem
operator|=
name|parser
operator|->
name|cur_elem
expr_stmt|;
name|s
operator|=
name|apr_pstrndup
argument_list|(
name|parser
operator|->
name|p
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|last_child
operator|==
name|NULL
condition|)
block|{
comment|/* no children yet. this cdata follows the start tag */
name|hdr
operator|=
operator|&
name|elem
operator|->
name|first_cdata
expr_stmt|;
block|}
else|else
block|{
comment|/* child elements exist. this cdata follows the last child. */
name|hdr
operator|=
operator|&
name|elem
operator|->
name|last_child
operator|->
name|following_cdata
expr_stmt|;
block|}
name|apr_text_append
argument_list|(
name|parser
operator|->
name|p
argument_list|,
name|hdr
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|cleanup_parser
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|apr_xml_parser
modifier|*
name|parser
init|=
name|ctx
decl_stmt|;
name|XML_ParserFree
argument_list|(
name|parser
operator|->
name|xp
argument_list|)
expr_stmt|;
name|parser
operator|->
name|xp
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|XML_MAJOR_VERSION
operator|>
literal|1
end_if

begin_comment
comment|/* Stop the parser if an entity declaration is hit. */
end_comment

begin_function
specifier|static
name|void
name|entity_declaration
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|entityName
parameter_list|,
name|int
name|is_parameter_entity
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|value
parameter_list|,
name|int
name|value_length
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|base
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|systemId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|publicId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|notationName
parameter_list|)
block|{
name|apr_xml_parser
modifier|*
name|parser
init|=
name|userData
decl_stmt|;
name|XML_StopParser
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* A noop default_handler. */
end_comment

begin_function
specifier|static
name|void
name|default_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_xml_parser *
argument_list|)
end_macro

begin_macro
name|apr_xml_parser_create
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|apr_xml_parser
modifier|*
name|parser
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
argument_list|)
argument_list|)
decl_stmt|;
name|parser
operator|->
name|p
operator|=
name|pool
expr_stmt|;
name|parser
operator|->
name|doc
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
operator|->
name|doc
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|doc
operator|->
name|namespaces
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### is there a way to avoid hard-coding this? */
name|apr_xml_insert_uri
argument_list|(
name|parser
operator|->
name|doc
operator|->
name|namespaces
argument_list|,
name|APR_KW_DAV
argument_list|)
expr_stmt|;
name|parser
operator|->
name|xp
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|xp
operator|==
name|NULL
condition|)
block|{
operator|(
operator|*
name|apr_pool_abort_get
argument_list|(
name|pool
argument_list|)
operator|)
operator|(
name|APR_ENOMEM
operator|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|parser
argument_list|,
name|cleanup_parser
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|start_handler
argument_list|,
name|end_handler
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|cdata_handler
argument_list|)
expr_stmt|;
comment|/* Prevent the "billion laughs" attack against expat by disabling      * internal entity expansion.  With 2.x, forcibly stop the parser      * if an entity is declared - this is safer and a more obvious      * failure mode.  With older versions, installing a noop      * DefaultHandler means that internal entities will be expanded as      * the empty string, which is also sufficient to prevent the      * attack. */
if|#
directive|if
name|XML_MAJOR_VERSION
operator|>
literal|1
name|XML_SetEntityDeclHandler
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|entity_declaration
argument_list|)
expr_stmt|;
else|#
directive|else
name|XML_SetDefaultHandler
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|default_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|parser
return|;
block|}
end_block

begin_function
specifier|static
name|apr_status_t
name|do_parse
parameter_list|(
name|apr_xml_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|int
name|is_final
parameter_list|)
block|{
if|if
condition|(
name|parser
operator|->
name|xp
operator|==
name|NULL
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|APR_XML_ERROR_PARSE_DONE
expr_stmt|;
block|}
else|else
block|{
name|int
name|rv
init|=
name|XML_Parse
argument_list|(
name|parser
operator|->
name|xp
argument_list|,
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|is_final
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|APR_XML_ERROR_EXPAT
expr_stmt|;
name|parser
operator|->
name|xp_err
operator|=
name|XML_GetErrorCode
argument_list|(
name|parser
operator|->
name|xp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ### better error code? */
return|return
name|parser
operator|->
name|error
condition|?
name|APR_EGENERAL
else|:
name|APR_SUCCESS
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_xml_parser_feed
argument_list|(
argument|apr_xml_parser *parser
argument_list|,
argument|const char *data
argument_list|,
argument|apr_size_t len
argument_list|)
end_macro

begin_block
block|{
return|return
name|do_parse
argument_list|(
name|parser
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
literal|0
comment|/* is_final */
argument_list|)
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_xml_parser_done
argument_list|(
argument|apr_xml_parser *parser
argument_list|,
argument|apr_xml_doc **pdoc
argument_list|)
end_macro

begin_block
block|{
name|char
name|end
decl_stmt|;
name|apr_status_t
name|status
init|=
name|do_parse
argument_list|(
name|parser
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|,
literal|1
comment|/* is_final */
argument_list|)
decl_stmt|;
comment|/* get rid of the parser */
operator|(
name|void
operator|)
name|apr_pool_cleanup_run
argument_list|(
name|parser
operator|->
name|p
argument_list|,
name|parser
argument_list|,
name|cleanup_parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
if|if
condition|(
name|pdoc
operator|!=
name|NULL
condition|)
operator|*
name|pdoc
operator|=
name|parser
operator|->
name|doc
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|apr_xml_parser_geterror
argument_list|(
argument|apr_xml_parser *parser
argument_list|,
argument|char *errbuf
argument_list|,
argument|apr_size_t errbufsize
argument_list|)
end_macro

begin_block
block|{
name|int
name|error
init|=
name|parser
operator|->
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* clear our record of an error */
name|parser
operator|->
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|msg
operator|=
literal|"No error."
expr_stmt|;
break|break;
case|case
name|APR_XML_NS_ERROR_UNKNOWN_PREFIX
case|:
name|msg
operator|=
literal|"An undefined namespace prefix was used."
expr_stmt|;
break|break;
case|case
name|APR_XML_NS_ERROR_INVALID_DECL
case|:
name|msg
operator|=
literal|"A namespace prefix was defined with an empty URI."
expr_stmt|;
break|break;
case|case
name|APR_XML_ERROR_EXPAT
case|:
operator|(
name|void
operator|)
name|apr_snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbufsize
argument_list|,
literal|"XML parser error code: %s (%d)"
argument_list|,
name|XML_ErrorString
argument_list|(
name|parser
operator|->
name|xp_err
argument_list|)
argument_list|,
name|parser
operator|->
name|xp_err
argument_list|)
expr_stmt|;
return|return
name|errbuf
return|;
case|case
name|APR_XML_ERROR_PARSE_DONE
case|:
name|msg
operator|=
literal|"The parser is not active."
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
literal|"There was an unknown error within the XML body."
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|apr_cpystrn
argument_list|(
name|errbuf
argument_list|,
name|msg
argument_list|,
name|errbufsize
argument_list|)
expr_stmt|;
return|return
name|errbuf
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_xml_parse_file
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|apr_xml_parser **parser
argument_list|,
argument|apr_xml_doc **ppdoc
argument_list|,
argument|apr_file_t *xmlfd
argument_list|,
argument|apr_size_t buffer_length
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|;
operator|*
name|parser
operator|=
name|apr_xml_parser_create
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|parser
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: returning an error code would be nice,          * but we dont get one ;( */
return|return
name|APR_EGENERAL
return|;
block|}
name|buffer
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|length
operator|=
name|buffer_length
expr_stmt|;
name|rv
operator|=
name|apr_file_read
argument_list|(
name|xmlfd
argument_list|,
name|buffer
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
block|{
name|rv
operator|=
name|apr_xml_parser_feed
argument_list|(
operator|*
name|parser
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|length
operator|=
name|buffer_length
expr_stmt|;
name|rv
operator|=
name|apr_file_read
argument_list|(
name|xmlfd
argument_list|,
name|buffer
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|!=
name|APR_EOF
condition|)
block|{
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|apr_xml_parser_done
argument_list|(
operator|*
name|parser
argument_list|,
name|ppdoc
argument_list|)
expr_stmt|;
operator|*
name|parser
operator|=
name|NULL
expr_stmt|;
return|return
name|rv
return|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_text_append
argument_list|(
argument|apr_pool_t * p
argument_list|,
argument|apr_text_header *hdr
argument_list|,
argument|const char *text
argument_list|)
end_macro

begin_block
block|{
name|apr_text
modifier|*
name|t
init|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|first
operator|==
name|NULL
condition|)
block|{
comment|/* no text elements yet */
name|hdr
operator|->
name|first
operator|=
name|hdr
operator|->
name|last
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* append to the last text element */
name|hdr
operator|->
name|last
operator|->
name|next
operator|=
name|t
expr_stmt|;
name|hdr
operator|->
name|last
operator|=
name|t
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* --------------------------------------------------------------- ** ** XML UTILITY FUNCTIONS */
end_comment

begin_comment
comment|/* ** apr_xml_quote_string: quote an XML string ** ** Replace '<', '>', and '&' with '&lt;', '&gt;', and '&amp;'. ** If quotes is true, then replace '"' with '&quot;'. ** ** quotes is typically set to true for XML strings that will occur within ** double quotes -- attribute values. */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_macro
name|apr_xml_quote_string
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const char *s
argument_list|,
argument|int quotes
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
name|apr_size_t
name|len
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|extra
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|qstr
decl_stmt|;
name|char
modifier|*
name|qscan
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|s
init|;
operator|(
name|c
operator|=
operator|*
name|scan
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|scan
operator|,
operator|++
name|len
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'>'
condition|)
name|extra
operator|+=
literal|3
expr_stmt|;
comment|/*&lt; or&gt; */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|extra
operator|+=
literal|4
expr_stmt|;
comment|/*&amp; */
elseif|else
if|if
condition|(
name|quotes
operator|&&
name|c
operator|==
literal|'"'
condition|)
name|extra
operator|+=
literal|5
expr_stmt|;
comment|/*&quot; */
block|}
comment|/* nothing to do? */
if|if
condition|(
name|extra
operator|==
literal|0
condition|)
return|return
name|s
return|;
name|qstr
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|len
operator|+
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|s
operator|,
name|qscan
operator|=
name|qstr
init|;
operator|(
name|c
operator|=
operator|*
name|scan
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|scan
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
operator|*
name|qscan
operator|++
operator|=
literal|'&'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'l'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'t'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|';'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
operator|*
name|qscan
operator|++
operator|=
literal|'&'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'g'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'t'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|';'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
operator|*
name|qscan
operator|++
operator|=
literal|'&'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'a'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'p'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|';'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quotes
operator|&&
name|c
operator|==
literal|'"'
condition|)
block|{
operator|*
name|qscan
operator|++
operator|=
literal|'&'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'q'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'u'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'o'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|'t'
expr_stmt|;
operator|*
name|qscan
operator|++
operator|=
literal|';'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|qscan
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|qscan
operator|=
literal|'\0'
expr_stmt|;
return|return
name|qstr
return|;
block|}
end_block

begin_comment
comment|/* how many characters for the given integer? */
end_comment

begin_define
define|#
directive|define
name|APR_XML_NS_LEN
parameter_list|(
name|ns
parameter_list|)
value|((ns)< 10 ? 1 : (ns)< 100 ? 2 : (ns)< 1000 ? 3 : \                             (ns)< 10000 ? 4 : (ns)< 100000 ? 5 : \                             (ns)< 1000000 ? 6 : (ns)< 10000000 ? 7 : \                             (ns)< 100000000 ? 8 : (ns)< 1000000000 ? 9 : 10)
end_define

begin_function
specifier|static
name|apr_size_t
name|text_size
parameter_list|(
specifier|const
name|apr_text
modifier|*
name|t
parameter_list|)
block|{
name|apr_size_t
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
name|size
operator|+=
name|strlen
argument_list|(
name|t
operator|->
name|text
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|apr_size_t
name|elem_size
parameter_list|(
specifier|const
name|apr_xml_elem
modifier|*
name|elem
parameter_list|,
name|int
name|style
parameter_list|,
name|apr_array_header_t
modifier|*
name|namespaces
parameter_list|,
name|int
modifier|*
name|ns_map
parameter_list|)
block|{
name|apr_size_t
name|size
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_FULL
operator|||
name|style
operator|==
name|APR_XML_X2T_FULL_NS_LANG
condition|)
block|{
specifier|const
name|apr_xml_attr
modifier|*
name|attr
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_FULL_NS_LANG
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	    ** The outer element will contain xmlns:ns%d="%s" attributes 	    ** and an xml:lang attribute, if applicable. 	    */
for|for
control|(
name|i
operator|=
name|namespaces
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
comment|/* compute size of: ' xmlns:ns%d="%s"' */
name|size
operator|+=
operator|(
literal|9
operator|+
name|APR_XML_NS_LEN
argument_list|(
name|i
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|APR_XML_GET_URI_ITEM
argument_list|(
name|namespaces
argument_list|,
name|i
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|elem
operator|->
name|lang
operator|!=
name|NULL
condition|)
block|{
comment|/* compute size of: ' xml:lang="%s"' */
name|size
operator|+=
literal|11
operator|+
name|strlen
argument_list|(
name|elem
operator|->
name|lang
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elem
operator|->
name|ns
operator|==
name|APR_XML_NS_NONE
condition|)
block|{
comment|/* compute size of:<%s> */
name|size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|elem
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|ns
init|=
name|ns_map
condition|?
name|ns_map
index|[
name|elem
operator|->
name|ns
index|]
else|:
name|elem
operator|->
name|ns
decl_stmt|;
comment|/* compute size of:<ns%d:%s> */
name|size
operator|+=
literal|3
operator|+
name|APR_XML_NS_LEN
argument_list|(
name|ns
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|elem
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|APR_XML_ELEM_IS_EMPTY
argument_list|(
name|elem
argument_list|)
condition|)
block|{
comment|/* insert a closing "/" */
name|size
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * two of above plus "/": 	     *<ns%d:%s> ...</ns%d:%s> 	     * OR<%s> ...</%s> 	     */
name|size
operator|=
literal|2
operator|*
name|size
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|attr
operator|=
name|elem
operator|->
name|attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|attr
operator|->
name|ns
operator|==
name|APR_XML_NS_NONE
condition|)
block|{
comment|/* compute size of: ' %s="%s"' */
name|size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|attr
operator|->
name|name
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|attr
operator|->
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* compute size of: ' ns%d:%s="%s"' */
name|int
name|ns
init|=
name|ns_map
condition|?
name|ns_map
index|[
name|attr
operator|->
name|ns
index|]
else|:
name|attr
operator|->
name|ns
decl_stmt|;
name|size
operator|+=
literal|3
operator|+
name|APR_XML_NS_LEN
argument_list|(
name|ns
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|attr
operator|->
name|name
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|attr
operator|->
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	** If the element has an xml:lang value that is *different* from 	** its parent, then add the thing in: ' xml:lang="%s"'. 	** 	** NOTE: we take advantage of the pointer equality established by 	** the parsing for "inheriting" the xml:lang values from parents. 	*/
if|if
condition|(
name|elem
operator|->
name|lang
operator|!=
name|NULL
operator|&&
operator|(
name|elem
operator|->
name|parent
operator|==
name|NULL
operator|||
name|elem
operator|->
name|lang
operator|!=
name|elem
operator|->
name|parent
operator|->
name|lang
operator|)
condition|)
block|{
name|size
operator|+=
literal|11
operator|+
name|strlen
argument_list|(
name|elem
operator|->
name|lang
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_LANG_INNER
condition|)
block|{
comment|/* 	 * This style prepends the xml:lang value plus a null terminator. 	 * If a lang value is not present, then we insert a null term. 	 */
name|size
operator|=
name|elem
operator|->
name|lang
condition|?
name|strlen
argument_list|(
name|elem
operator|->
name|lang
argument_list|)
operator|+
literal|1
else|:
literal|1
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|size
operator|+=
name|text_size
argument_list|(
name|elem
operator|->
name|first_cdata
operator|.
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|elem
operator|->
name|first_child
init|;
name|elem
condition|;
name|elem
operator|=
name|elem
operator|->
name|next
control|)
block|{
comment|/* the size of the child element plus the CDATA that follows it */
name|size
operator|+=
operator|(
name|elem_size
argument_list|(
name|elem
argument_list|,
name|APR_XML_X2T_FULL
argument_list|,
name|NULL
argument_list|,
name|ns_map
argument_list|)
operator|+
name|text_size
argument_list|(
name|elem
operator|->
name|following_cdata
operator|.
name|first
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|write_text
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|apr_text
modifier|*
name|t
parameter_list|)
block|{
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|t
operator|->
name|text
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|write_elem
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|apr_xml_elem
modifier|*
name|elem
parameter_list|,
name|int
name|style
parameter_list|,
name|apr_array_header_t
modifier|*
name|namespaces
parameter_list|,
name|int
modifier|*
name|ns_map
parameter_list|)
block|{
specifier|const
name|apr_xml_elem
modifier|*
name|child
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|int
name|ns
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_FULL
operator|||
name|style
operator|==
name|APR_XML_X2T_FULL_NS_LANG
condition|)
block|{
name|int
name|empty
init|=
name|APR_XML_ELEM_IS_EMPTY
argument_list|(
name|elem
argument_list|)
decl_stmt|;
specifier|const
name|apr_xml_attr
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|elem
operator|->
name|ns
operator|==
name|APR_XML_NS_NONE
condition|)
block|{
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"<%s"
argument_list|,
name|elem
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|ns_map
condition|?
name|ns_map
index|[
name|elem
operator|->
name|ns
index|]
else|:
name|elem
operator|->
name|ns
expr_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"<ns%d:%s"
argument_list|,
name|ns
argument_list|,
name|elem
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|len
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|elem
operator|->
name|attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|attr
operator|->
name|ns
operator|==
name|APR_XML_NS_NONE
condition|)
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" %s=\"%s\""
argument_list|,
name|attr
operator|->
name|name
argument_list|,
name|attr
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|ns
operator|=
name|ns_map
condition|?
name|ns_map
index|[
name|attr
operator|->
name|ns
index|]
else|:
name|attr
operator|->
name|ns
expr_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" ns%d:%s=\"%s\""
argument_list|,
name|ns
argument_list|,
name|attr
operator|->
name|name
argument_list|,
name|attr
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|len
expr_stmt|;
block|}
comment|/* add the xml:lang value if necessary */
if|if
condition|(
name|elem
operator|->
name|lang
operator|!=
name|NULL
operator|&&
operator|(
name|style
operator|==
name|APR_XML_X2T_FULL_NS_LANG
operator|||
name|elem
operator|->
name|parent
operator|==
name|NULL
operator|||
name|elem
operator|->
name|lang
operator|!=
name|elem
operator|->
name|parent
operator|->
name|lang
operator|)
condition|)
block|{
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" xml:lang=\"%s\""
argument_list|,
name|elem
operator|->
name|lang
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
comment|/* add namespace definitions, if required */
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_FULL_NS_LANG
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|namespaces
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" xmlns:ns%d=\"%s\""
argument_list|,
name|i
argument_list|,
name|APR_XML_GET_URI_ITEM
argument_list|(
name|namespaces
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* no more to do. close it up and go. */
if|if
condition|(
name|empty
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'>'
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/* just close it */
operator|*
name|s
operator|++
operator|=
literal|'>'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_LANG_INNER
condition|)
block|{
comment|/* prepend the xml:lang value */
if|if
condition|(
name|elem
operator|->
name|lang
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|elem
operator|->
name|lang
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|elem
operator|->
name|lang
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|s
operator|=
name|write_text
argument_list|(
name|s
argument_list|,
name|elem
operator|->
name|first_cdata
operator|.
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|elem
operator|->
name|first_child
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|next
control|)
block|{
name|s
operator|=
name|write_elem
argument_list|(
name|s
argument_list|,
name|child
argument_list|,
name|APR_XML_X2T_FULL
argument_list|,
name|NULL
argument_list|,
name|ns_map
argument_list|)
expr_stmt|;
name|s
operator|=
name|write_text
argument_list|(
name|s
argument_list|,
name|child
operator|->
name|following_cdata
operator|.
name|first
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|APR_XML_X2T_FULL
operator|||
name|style
operator|==
name|APR_XML_X2T_FULL_NS_LANG
condition|)
block|{
if|if
condition|(
name|elem
operator|->
name|ns
operator|==
name|APR_XML_NS_NONE
condition|)
block|{
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"</%s>"
argument_list|,
name|elem
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|ns_map
condition|?
name|ns_map
index|[
name|elem
operator|->
name|ns
index|]
else|:
name|elem
operator|->
name|ns
expr_stmt|;
name|len
operator|=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"</ns%d:%s>"
argument_list|,
name|ns
argument_list|,
name|elem
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_xml_quote_elem
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|apr_xml_elem *elem
argument_list|)
end_macro

begin_block
block|{
name|apr_text
modifier|*
name|scan_txt
decl_stmt|;
name|apr_xml_attr
modifier|*
name|scan_attr
decl_stmt|;
name|apr_xml_elem
modifier|*
name|scan_elem
decl_stmt|;
comment|/* convert the element's text */
for|for
control|(
name|scan_txt
operator|=
name|elem
operator|->
name|first_cdata
operator|.
name|first
init|;
name|scan_txt
operator|!=
name|NULL
condition|;
name|scan_txt
operator|=
name|scan_txt
operator|->
name|next
control|)
block|{
name|scan_txt
operator|->
name|text
operator|=
name|apr_xml_quote_string
argument_list|(
name|p
argument_list|,
name|scan_txt
operator|->
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|scan_txt
operator|=
name|elem
operator|->
name|following_cdata
operator|.
name|first
init|;
name|scan_txt
operator|!=
name|NULL
condition|;
name|scan_txt
operator|=
name|scan_txt
operator|->
name|next
control|)
block|{
name|scan_txt
operator|->
name|text
operator|=
name|apr_xml_quote_string
argument_list|(
name|p
argument_list|,
name|scan_txt
operator|->
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* convert the attribute values */
for|for
control|(
name|scan_attr
operator|=
name|elem
operator|->
name|attr
init|;
name|scan_attr
operator|!=
name|NULL
condition|;
name|scan_attr
operator|=
name|scan_attr
operator|->
name|next
control|)
block|{
name|scan_attr
operator|->
name|value
operator|=
name|apr_xml_quote_string
argument_list|(
name|p
argument_list|,
name|scan_attr
operator|->
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* convert the child elements */
for|for
control|(
name|scan_elem
operator|=
name|elem
operator|->
name|first_child
init|;
name|scan_elem
operator|!=
name|NULL
condition|;
name|scan_elem
operator|=
name|scan_elem
operator|->
name|next
control|)
block|{
name|apr_xml_quote_elem
argument_list|(
name|p
argument_list|,
name|scan_elem
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* convert an element to a text string */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_xml_to_text
argument_list|(
argument|apr_pool_t * p
argument_list|,
argument|const apr_xml_elem *elem
argument_list|,
argument|int style
argument_list|,
argument|apr_array_header_t *namespaces
argument_list|,
argument|int *ns_map
argument_list|,
argument|const char **pbuf
argument_list|,
argument|apr_size_t *psize
argument_list|)
end_macro

begin_block
block|{
comment|/* get the exact size, plus a null terminator */
name|apr_size_t
name|size
init|=
name|elem_size
argument_list|(
name|elem
argument_list|,
name|style
argument_list|,
name|namespaces
argument_list|,
name|ns_map
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|write_elem
argument_list|(
name|s
argument_list|,
name|elem
argument_list|,
name|style
argument_list|,
name|namespaces
argument_list|,
name|ns_map
argument_list|)
expr_stmt|;
name|s
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pbuf
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|psize
condition|)
operator|*
name|psize
operator|=
name|size
expr_stmt|;
block|}
end_block

begin_macro
name|APU_DECLARE
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_macro
name|apr_xml_empty_elem
argument_list|(
argument|apr_pool_t * p
argument_list|,
argument|const apr_xml_elem *elem
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|elem
operator|->
name|ns
operator|==
name|APR_XML_NS_NONE
condition|)
block|{
comment|/* 	 * The prefix (xml...) is already within the prop name, or 	 * the element simply has no prefix. 	 */
return|return
name|apr_psprintf
argument_list|(
name|p
argument_list|,
literal|"<%s/>"
name|DEBUG_CR
argument_list|,
name|elem
operator|->
name|name
argument_list|)
return|;
block|}
return|return
name|apr_psprintf
argument_list|(
name|p
argument_list|,
literal|"<ns%d:%s/>"
name|DEBUG_CR
argument_list|,
name|elem
operator|->
name|ns
argument_list|,
name|elem
operator|->
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* return the URI's (existing) index, or insert it and return a new index */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_xml_insert_uri
argument_list|(
argument|apr_array_header_t *uri_array
argument_list|,
argument|const char *uri
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pelt
decl_stmt|;
comment|/* never insert an empty URI; this index is always APR_XML_NS_NONE */
if|if
condition|(
operator|*
name|uri
operator|==
literal|'\0'
condition|)
return|return
name|APR_XML_NS_NONE
return|;
for|for
control|(
name|i
operator|=
name|uri_array
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|uri
argument_list|,
name|APR_XML_GET_URI_ITEM
argument_list|(
name|uri_array
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
name|pelt
operator|=
name|apr_array_push
argument_list|(
name|uri_array
argument_list|)
expr_stmt|;
operator|*
name|pelt
operator|=
name|uri
expr_stmt|;
comment|/* assume uri is const or in a pool */
return|return
name|uri_array
operator|->
name|nelts
operator|-
literal|1
return|;
block|}
end_block

begin_comment
comment|/* convert the element to EBCDIC */
end_comment

begin_if
if|#
directive|if
name|APR_CHARSET_EBCDIC
end_if

begin_function
specifier|static
name|apr_status_t
name|apr_xml_parser_convert_elem
parameter_list|(
name|apr_xml_elem
modifier|*
name|e
parameter_list|,
name|apr_xlate_t
modifier|*
name|convset
parameter_list|)
block|{
name|apr_xml_attr
modifier|*
name|a
decl_stmt|;
name|apr_xml_elem
modifier|*
name|ec
decl_stmt|;
name|apr_text
modifier|*
name|t
decl_stmt|;
name|apr_size_t
name|inbytes_left
decl_stmt|,
name|outbytes_left
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|strlen
argument_list|(
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|convset
argument_list|,
name|e
operator|->
name|name
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|e
operator|->
name|name
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
for|for
control|(
name|t
operator|=
name|e
operator|->
name|first_cdata
operator|.
name|first
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|strlen
argument_list|(
name|t
operator|->
name|text
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|convset
argument_list|,
name|t
operator|->
name|text
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|text
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|e
operator|->
name|following_cdata
operator|.
name|first
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|strlen
argument_list|(
name|t
operator|->
name|text
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|convset
argument_list|,
name|t
operator|->
name|text
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|text
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
for|for
control|(
name|a
operator|=
name|e
operator|->
name|attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|strlen
argument_list|(
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|convset
argument_list|,
name|a
operator|->
name|name
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|name
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|strlen
argument_list|(
name|a
operator|->
name|value
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|convset
argument_list|,
name|a
operator|->
name|value
argument_list|,
operator|&
name|inbytes_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|value
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
for|for
control|(
name|ec
operator|=
name|e
operator|->
name|first_child
init|;
name|ec
operator|!=
name|NULL
condition|;
name|ec
operator|=
name|ec
operator|->
name|next
control|)
block|{
name|status
operator|=
name|apr_xml_parser_convert_elem
argument_list|(
name|ec
argument_list|,
name|convset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* convert the whole document to EBCDIC */
end_comment

begin_macro
name|APU_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_xml_parser_convert_doc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_xml_doc *pdoc
argument_list|,
argument|apr_xlate_t *convset
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|status
decl_stmt|;
comment|/* Don't convert the namespaces: they are constant! */
if|if
condition|(
name|pdoc
operator|->
name|namespaces
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|namespaces
decl_stmt|;
name|namespaces
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|pdoc
operator|->
name|namespaces
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespaces
operator|==
name|NULL
condition|)
return|return
name|APR_ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdoc
operator|->
name|namespaces
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|inbytes_left
decl_stmt|,
name|outbytes_left
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|APR_XML_GET_URI_ITEM
argument_list|(
name|pdoc
operator|->
name|namespaces
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|APR_ENOMEM
return|;
name|inbytes_left
operator|=
name|outbytes_left
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_xlate_conv_buffer
argument_list|(
name|convset
argument_list|,
name|ptr
argument_list|,
operator|&
name|inbytes_left
argument_list|,
name|ptr
argument_list|,
operator|&
name|outbytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
name|apr_xml_insert_uri
argument_list|(
name|namespaces
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|pdoc
operator|->
name|namespaces
operator|=
name|namespaces
expr_stmt|;
block|}
return|return
name|apr_xml_parser_convert_elem
argument_list|(
name|pdoc
operator|->
name|root
argument_list|,
name|convset
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

