begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file implements functions used by both client and servers in the  * XNS courier library  */
end_comment

begin_comment
comment|/*  $Log:	readwrite.c,v $  * Revision 2.5  87/04/12  14:01:18  jqj  * typo in previous  *   * Revision 2.3  87/04/12  13:52:27  jqj  * don't print silly message if remote system is down -- let higher level  * software say so.  *   * Revision 2.2  86/11/07  15:58:05  jqj  * Fixes for very long messages from wiebe@wally.cs.washington.edu.  *   * Revision 2.1  86/09/07  07:31:59  jqj  * OpenSPPconnection should return -1 on failure.  *   * Revision 2.0  85/11/21  07:22:15  jqj  * 4.3BSD standard release  *   * Revision 1.8  85/10/21  13:01:17  jqj  * Gould version.  *   * Revision 1.7  85/10/17  07:22:53  jqj  * Fix to previous edit.  *   * Revision 1.6  85/10/17  07:07:02  jqj  * ReadMessage had a typo which Gould compiler caught:  bug in case of  * message with Courier header split across several SPP packets.  *   * Revision 1.5  85/09/27  16:01:23  jqj  * added error checking to read in ReadMessage to bomb on closed connections.  *   * Revision 1.4  85/03/11  16:37:24  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.3  85/02/22  09:27:40  bill  * Almost working version.  Am about to change   * ReadMessage to match what really shows up from the Xerox stuff.  *   * Revision 1.2  85/01/27  07:37:39  jqj  * finished but undebugged version  *   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: readwrite.c,v 2.5 87/04/12 14:01:18 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* for ns.h and socket.h */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* for scatter/gather io */
end_comment

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_comment
comment|/* for XNS addresses and courierconnection.h */
end_comment

begin_include
include|#
directive|include
file|<netns/idp.h>
end_include

begin_include
include|#
directive|include
file|<netns/sp.h>
end_include

begin_comment
comment|/* for spphdr */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* for EPROTOTYPE */
end_comment

begin_include
include|#
directive|include
file|"courier.h"
end_include

begin_include
include|#
directive|include
file|"realcourierconnection.h"
end_include

begin_define
define|#
directive|define
name|MAKEVEC
parameter_list|(
name|idx
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
value|our_iovec[idx].iov_base = (caddr_t)addr;\ 				our_iovec[idx].iov_len = len;
end_define

begin_escape
end_escape

begin_expr_stmt
name|CourierWrite
argument_list|(
name|f
argument_list|,
name|hdrlen
argument_list|,
name|hdrbuf
argument_list|,
name|nwords
argument_list|,
name|arguments
argument_list|)
comment|/* write a 2-block message possibly consisting of several packets */
specifier|register
name|CourierConnection
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|hdrlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of hdrbuf, in words */
end_comment

begin_decl_stmt
name|Unspecified
modifier|*
name|hdrbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Cardinal
name|nwords
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of arguments, in words */
end_comment

begin_decl_stmt
specifier|register
name|Unspecified
modifier|*
name|arguments
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|iovec
name|our_iovec
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|state
operator|==
name|closed
condition|)
block|{
name|f
operator|->
name|abortseen
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|fd
operator|=
name|openSPPConnection
argument_list|(
operator|&
operator|(
name|f
operator|->
name|host
operator|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|f
operator|->
name|state
operator|=
name|wantversion
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Courier) Can't reopen SPP connection\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|MAKEVEC
argument_list|(
literal|0
argument_list|,
operator|&
operator|(
name|f
operator|->
name|sphdrOpts
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|f
operator|->
name|sphdrOpts
argument_list|)
argument_list|)
expr_stmt|;
name|MAKEVEC
argument_list|(
literal|1
argument_list|,
name|hdrbuf
argument_list|,
operator|(
name|hdrlen
operator|*
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwords
operator|<=
name|MAXWORDS
operator|-
name|hdrlen
condition|)
block|{
comment|/* SetSPPoptions(f->fd, SPPSST_RPC, 1, 0); 			 datastream=0, EOM=TRUE, Attn=FALSE */
name|f
operator|->
name|sphdrOpts
operator|.
name|sp_dt
operator|=
name|SPPSST_RPC
expr_stmt|;
name|f
operator|->
name|sphdrOpts
operator|.
name|sp_cc
operator||=
name|SP_EM
expr_stmt|;
name|MAKEVEC
argument_list|(
literal|2
argument_list|,
name|arguments
argument_list|,
name|nwords
operator|*
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|writev
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"(Courier) writev"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MAKEVEC
argument_list|(
literal|2
argument_list|,
name|arguments
argument_list|,
operator|(
name|MAXWORDS
operator|-
name|hdrlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SetSPPoptions(f->fd, SPPSST_RPC, 0, 0); 			/* datastream=0, EOM=FALSE, Attn=FALSE */
name|f
operator|->
name|sphdrOpts
operator|.
name|sp_dt
operator|=
name|SPPSST_RPC
expr_stmt|;
name|f
operator|->
name|sphdrOpts
operator|.
name|sp_cc
operator|&=
operator|~
name|SP_EM
expr_stmt|;
name|nwords
operator|-=
name|MAXWORDS
operator|-
name|hdrlen
expr_stmt|;
name|arguments
operator|+=
name|MAXWORDS
operator|-
name|hdrlen
expr_stmt|;
if|if
condition|(
name|writev
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"(Courier) writev"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|MAKEVEC
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arguments
argument_list|,
name|MAXWORDS
operator|*
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nwords
operator|>
name|MAXWORDS
condition|)
block|{
name|writev
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|nwords
operator|-=
name|MAXWORDS
expr_stmt|;
name|arguments
operator|+=
name|MAXWORDS
expr_stmt|;
name|our_iovec
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|arguments
expr_stmt|;
block|}
name|f
operator|->
name|sphdrOpts
operator|.
name|sp_cc
operator||=
name|SP_EM
expr_stmt|;
comment|/* SetSPPoptions(f->fd, SPPSST_RPC, 1, 0); 			/* datastream=0, EOM=TRUE, Attn=FALSE */
name|our_iovec
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|nwords
operator|*
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
expr_stmt|;
name|writev
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|Unspecified
modifier|*
name|ReadMessage
parameter_list|(
name|f
parameter_list|,
name|firstbuf
parameter_list|,
name|firstlength
parameter_list|)
specifier|register
name|CourierConnection
modifier|*
name|f
decl_stmt|;
comment|/* socket descriptor */
name|Unspecified
modifier|*
name|firstbuf
decl_stmt|;
name|Cardinal
name|firstlength
decl_stmt|;
comment|/* Read a complete Courier message from SPP socket f->fd, skipping packets  * with the wrong datastream type.  * If firstbuf is specified with a non-zero length (in Unspecifieds), then it   * is filled before the malloced packet.  * Return a pointer to beginning of a malloced packet (caller is responsible  * for freeing it), and a length in *retlength  * Returns NULL if connection closes prematurely.  */
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* ptr to message buffer */
name|LongCardinal
name|length
decl_stmt|,
comment|/* current message length, bytes */
name|bufsize
decl_stmt|,
comment|/* current buffer size, bytes */
name|nextincrement
decl_stmt|;
comment|/* amt of space to try for next */
specifier|register
name|int
name|count
decl_stmt|;
comment|/* data bytes read by current readv() */
name|struct
name|iovec
name|our_iovec
index|[
literal|3
index|]
decl_stmt|;
struct|struct
block|{
name|struct
name|sphdr
name|hdr
decl_stmt|;
name|Cardinal
name|version
index|[
literal|2
index|]
decl_stmt|;
block|}
name|hdrbuf
struct|;
name|Cardinal
name|versionl
decl_stmt|,
comment|/* version numbers received */
name|versionh
decl_stmt|;
name|int
name|verbyteswanted
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
extern|extern free(
block|)
function|;
end_function

begin_decl_stmt
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spp& idp header */
end_comment

begin_expr_stmt
name|MAKEVEC
argument_list|(
literal|0
argument_list|,
operator|&
name|hdrbuf
operator|.
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* conn id, etc... */
end_comment

begin_if
if|if
condition|(
name|firstbuf
operator|==
name|NULL
condition|)
name|firstlength
operator|=
literal|0
expr_stmt|;
else|else
name|firstlength
operator|*=
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* length in bytes */
end_comment

begin_expr_stmt
name|MAKEVEC
argument_list|(
literal|1
argument_list|,
name|firstbuf
argument_list|,
name|firstlength
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* data */
end_comment

begin_expr_stmt
name|buf
operator|=
name|malloc
argument_list|(
name|SPPMAXDATA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MAKEVEC
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
name|SPPMAXDATA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bufsize
operator|=
name|SPPMAXDATA
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * flush Courier version number if necessary 	 */
end_comment

begin_if
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|wantversion
condition|)
block|{
comment|/* we don't have to look for a version number this time! */
name|count
operator|=
name|readv
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|sppclosereply
argument_list|(
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|f
operator|->
name|state
operator|=
name|closed
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* stick version range in with header */
name|verbyteswanted
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Cardinal
argument_list|)
expr_stmt|;
name|our_iovec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|+=
name|verbyteswanted
expr_stmt|;
while|while
condition|(
name|verbyteswanted
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|readv
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|sppclosereply
argument_list|(
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|f
operator|->
name|state
operator|=
name|closed
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* we don't bother to check for matching */
comment|/* Courier version */
if|if
condition|(
name|count
operator|>=
name|verbyteswanted
condition|)
block|{
name|count
operator|-=
name|verbyteswanted
expr_stmt|;
name|our_iovec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|-=
name|verbyteswanted
expr_stmt|;
name|verbyteswanted
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|verbyteswanted
operator|-=
name|count
expr_stmt|;
name|our_iovec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|-=
name|count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|f
operator|->
name|state
operator|=
name|inprogress
expr_stmt|;
while|while
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* read either RPC reply or BDT garbage */
name|count
operator|=
name|readv
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|sppclosereply
argument_list|(
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|f
operator|->
name|state
operator|=
name|closed
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* {version-packet, null-0-packet, bdt-packet, reply-packet},  		 * is handled, but I don't think it's legal */
block|}
end_if

begin_comment
comment|/* 	 * we've flushed any version number that might be present, 	 * and have read the first packet -- which may be garbage. 	 * Throw away any further garbage (e.g. BDT data) too.   	 */
end_comment

begin_while
while|while
condition|(
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|!=
name|SPPSST_RPC
condition|)
block|{
name|count
operator|=
name|readv
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|sppclosereply
argument_list|(
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|f
operator|->
name|state
operator|=
name|closed
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_while

begin_comment
comment|/* 	 * Now we have a real RPC data packet, which we hope is the reply 	 */
end_comment

begin_expr_stmt
name|length
operator|=
name|count
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nextincrement
operator|=
name|SPPMAXDATA
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|!
operator|(
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_cc
operator|&
name|SP_EM
operator|)
condition|)
block|{
comment|/* Not to end of message yet, so read another packet */
if|if
condition|(
name|length
operator|+
name|SPPMAXDATA
operator|-
name|firstlength
operator|>
name|bufsize
condition|)
block|{
comment|/* not enough space for next packet.  Make room. */
name|bufsize
operator|+=
name|nextincrement
expr_stmt|;
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|bufsize
argument_list|)
expr_stmt|;
comment|/* do order(log(messagelength)) reallocs */
name|nextincrement
operator|+=
name|nextincrement
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>=
name|firstlength
condition|)
block|{
name|MAKEVEC
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MAKEVEC
argument_list|(
literal|2
argument_list|,
name|buf
operator|+
name|length
operator|-
name|firstlength
argument_list|,
name|bufsize
operator|+
name|firstlength
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|firstbuf
operator|+=
name|length
operator|/
sizeof|sizeof
argument_list|(
name|Unspecified
argument_list|)
expr_stmt|;
name|firstlength
operator|-=
name|length
expr_stmt|;
name|MAKEVEC
argument_list|(
literal|1
argument_list|,
name|firstbuf
argument_list|,
name|firstlength
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|readv
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|our_iovec
argument_list|,
literal|3
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|sppclosereply
argument_list|(
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|f
operator|->
name|state
operator|=
name|closed
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|!=
name|SPPSST_RPC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Courier) Stream type changed from %d to %d during message\n"
argument_list|,
name|SPPSST_RPC
argument_list|,
name|hdrbuf
operator|.
name|hdr
operator|.
name|sp_dt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|length
operator|+=
name|count
expr_stmt|;
block|}
end_while

begin_return
return|return
operator|(
operator|(
name|Unspecified
operator|*
operator|)
name|buf
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|CheckEND
operator|(
name|f
operator|)
comment|/* look ahead on courier connection, checking for an END packet.  * If seen, set state to closed.  */
name|CourierConnection
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
struct|struct
block|{
name|struct
name|sphdr
name|hdr
decl_stmt|;
name|char
name|data
index|[
name|SPPMAXDATA
index|]
decl_stmt|;
block|}
name|packbuf
struct|;
name|int
name|count
decl_stmt|;
name|int
name|fdmask
decl_stmt|;
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|fdmask
operator|=
literal|1
operator|<<
operator|(
name|f
operator|->
name|fd
operator|)
expr_stmt|;
while|while
condition|(
name|select
argument_list|(
name|f
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|count
operator|=
name|recv
argument_list|(
name|f
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|packbuf
argument_list|)
argument_list|,
name|MSG_PEEK
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|packbuf
operator|.
name|hdr
operator|.
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
name|read
argument_list|(
name|f
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|packbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sppclosereply
argument_list|(
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|f
operator|->
name|state
operator|=
name|closed
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
condition|)
name|read
argument_list|(
name|f
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|packbuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|CourierClose
argument_list|(
argument|conn
argument_list|)
end_macro

begin_decl_stmt
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|sppclose
argument_list|(
name|conn
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|conn
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* returns either a socket or -1 on error */
end_comment

begin_function
name|int
name|openSPPConnection
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr_ns
modifier|*
name|dst
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|dst
operator|->
name|sns_family
argument_list|,
name|SOCK_SEQPACKET
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"(Courier) socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|errno
operator|!=
name|ETIMEDOUT
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ECONNREFUSED
operator|)
condition|)
name|perror
argument_list|(
literal|"(Courier) connect"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*NOTREACHED*/
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

end_unit

