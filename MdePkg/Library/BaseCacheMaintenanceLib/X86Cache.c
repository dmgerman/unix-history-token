begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Cache Maintenance Functions.    Copyright (c) 2006 - 2015, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.   **/
end_comment

begin_include
include|#
directive|include
file|<Base.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_comment
comment|/**   Invalidates the entire instruction cache in cache coherency domain of the   calling CPU.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|InvalidateInstructionCache
parameter_list|(
name|VOID
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**   Invalidates a range of instruction cache lines in the cache coherency domain   of the calling CPU.    Invalidates the instruction cache lines specified by Address and Length. If   Address is not aligned on a cache line boundary, then entire instruction   cache line containing Address is invalidated. If Address + Length is not   aligned on a cache line boundary, then the entire instruction cache line   containing Address + Length -1 is invalidated. This function may choose to   invalidate the entire instruction cache if that is more efficient than   invalidating the specified range. If Length is 0, then no instruction cache   lines are invalidated. Address is returned.    If Length is greater than (MAX_ADDRESS - Address + 1), then ASSERT().    @param  Address The base address of the instruction cache lines to                   invalidate. If the CPU is in a physical addressing mode, then                   Address is a physical address. If the CPU is in a virtual                   addressing mode, then Address is a virtual address.    @param  Length  The number of bytes to invalidate from the instruction cache.    @return Address.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|InvalidateInstructionCacheRange
parameter_list|(
name|IN
name|VOID
modifier|*
name|Address
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
if|if
condition|(
name|Length
operator|==
literal|0
condition|)
block|{
return|return
name|Address
return|;
block|}
name|ASSERT
argument_list|(
operator|(
name|Length
operator|-
literal|1
operator|)
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
name|UINTN
operator|)
name|Address
operator|)
argument_list|)
expr_stmt|;
return|return
name|Address
return|;
block|}
end_function

begin_comment
comment|/**   Writes back and invalidates the entire data cache in cache coherency domain   of the calling CPU.    Writes back and invalidates the entire data cache in cache coherency domain   of the calling CPU. This function guarantees that all dirty cache lines are   written back to system memory, and also invalidates all the data cache lines   in the cache coherency domain of the calling CPU.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|WriteBackInvalidateDataCache
parameter_list|(
name|VOID
parameter_list|)
block|{
name|AsmWbinvd
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Writes back and invalidates a range of data cache lines in the cache   coherency domain of the calling CPU.    Writes back and invalidates the data cache lines specified by Address and   Length. If Address is not aligned on a cache line boundary, then entire data   cache line containing Address is written back and invalidated. If Address +   Length is not aligned on a cache line boundary, then the entire data cache   line containing Address + Length -1 is written back and invalidated. This   function may choose to write back and invalidate the entire data cache if   that is more efficient than writing back and invalidating the specified   range. If Length is 0, then no data cache lines are written back and   invalidated. Address is returned.    If Length is greater than (MAX_ADDRESS - Address + 1), then ASSERT().    @param  Address The base address of the data cache lines to write back and                   invalidate. If the CPU is in a physical addressing mode, then                   Address is a physical address. If the CPU is in a virtual                   addressing mode, then Address is a virtual address.   @param  Length  The number of bytes to write back and invalidate from the                   data cache.    @return Address of cache invalidation.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|WriteBackInvalidateDataCacheRange
parameter_list|(
name|IN
name|VOID
modifier|*
name|Address
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT32
name|RegEbx
decl_stmt|;
name|UINT32
name|RegEdx
decl_stmt|;
name|UINTN
name|CacheLineSize
decl_stmt|;
name|UINTN
name|Start
decl_stmt|;
name|UINTN
name|End
decl_stmt|;
if|if
condition|(
name|Length
operator|==
literal|0
condition|)
block|{
return|return
name|Address
return|;
block|}
name|ASSERT
argument_list|(
operator|(
name|Length
operator|-
literal|1
operator|)
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
name|UINTN
operator|)
name|Address
operator|)
argument_list|)
expr_stmt|;
comment|//
comment|// If the CPU does not support CLFLUSH instruction,
comment|// then promote flush range to flush entire cache.
comment|//
name|AsmCpuid
argument_list|(
literal|0x01
argument_list|,
name|NULL
argument_list|,
operator|&
name|RegEbx
argument_list|,
name|NULL
argument_list|,
operator|&
name|RegEdx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|RegEdx
operator|&
name|BIT19
operator|)
operator|==
literal|0
condition|)
block|{
name|AsmWbinvd
argument_list|()
expr_stmt|;
return|return
name|Address
return|;
block|}
comment|//
comment|// Cache line size is 8 * Bits 15-08 of EBX returned from CPUID 01H
comment|//
name|CacheLineSize
operator|=
operator|(
name|RegEbx
operator|&
literal|0xff00
operator|)
operator|>>
literal|5
expr_stmt|;
name|Start
operator|=
operator|(
name|UINTN
operator|)
name|Address
expr_stmt|;
comment|//
comment|// Calculate the cache line alignment
comment|//
name|End
operator|=
operator|(
name|Start
operator|+
name|Length
operator|+
operator|(
name|CacheLineSize
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|CacheLineSize
operator|-
literal|1
operator|)
expr_stmt|;
name|Start
operator|&=
operator|~
operator|(
operator|(
name|UINTN
operator|)
name|CacheLineSize
operator|-
literal|1
operator|)
expr_stmt|;
do|do
block|{
name|Start
operator|=
operator|(
name|UINTN
operator|)
name|AsmFlushCacheLine
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|Start
argument_list|)
operator|+
name|CacheLineSize
expr_stmt|;
block|}
do|while
condition|(
name|Start
operator|!=
name|End
condition|)
do|;
return|return
name|Address
return|;
block|}
end_function

begin_comment
comment|/**   Writes back the entire data cache in cache coherency domain of the calling   CPU.    Writes back the entire data cache in cache coherency domain of the calling   CPU. This function guarantees that all dirty cache lines are written back to   system memory. This function may also invalidate all the data cache lines in   the cache coherency domain of the calling CPU.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|WriteBackDataCache
parameter_list|(
name|VOID
parameter_list|)
block|{
name|WriteBackInvalidateDataCache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Writes back a range of data cache lines in the cache coherency domain of the   calling CPU.    Writes back the data cache lines specified by Address and Length. If Address   is not aligned on a cache line boundary, then entire data cache line   containing Address is written back. If Address + Length is not aligned on a   cache line boundary, then the entire data cache line containing Address +   Length -1 is written back. This function may choose to write back the entire   data cache if that is more efficient than writing back the specified range.   If Length is 0, then no data cache lines are written back. This function may   also invalidate all the data cache lines in the specified range of the cache   coherency domain of the calling CPU. Address is returned.    If Length is greater than (MAX_ADDRESS - Address + 1), then ASSERT().    @param  Address The base address of the data cache lines to write back. If                   the CPU is in a physical addressing mode, then Address is a                   physical address. If the CPU is in a virtual addressing                   mode, then Address is a virtual address.   @param  Length  The number of bytes to write back from the data cache.    @return Address of cache written in main memory.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|WriteBackDataCacheRange
parameter_list|(
name|IN
name|VOID
modifier|*
name|Address
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
return|return
name|WriteBackInvalidateDataCacheRange
argument_list|(
name|Address
argument_list|,
name|Length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Invalidates the entire data cache in cache coherency domain of the calling   CPU.    Invalidates the entire data cache in cache coherency domain of the calling   CPU. This function must be used with care because dirty cache lines are not   written back to system memory. It is typically used for cache diagnostics. If   the CPU does not support invalidation of the entire data cache, then a write   back and invalidate operation should be performed on the entire data cache.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|InvalidateDataCache
parameter_list|(
name|VOID
parameter_list|)
block|{
name|AsmInvd
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Invalidates a range of data cache lines in the cache coherency domain of the   calling CPU.    Invalidates the data cache lines specified by Address and Length. If Address   is not aligned on a cache line boundary, then entire data cache line   containing Address is invalidated. If Address + Length is not aligned on a   cache line boundary, then the entire data cache line containing Address +   Length -1 is invalidated. This function must never invalidate any cache lines   outside the specified range. If Length is 0, then no data cache lines are   invalidated. Address is returned. This function must be used with care   because dirty cache lines are not written back to system memory. It is   typically used for cache diagnostics. If the CPU does not support   invalidation of a data cache range, then a write back and invalidate   operation should be performed on the data cache range.    If Length is greater than (MAX_ADDRESS - Address + 1), then ASSERT().    @param  Address The base address of the data cache lines to invalidate. If                   the CPU is in a physical addressing mode, then Address is a                   physical address. If the CPU is in a virtual addressing mode,                   then Address is a virtual address.   @param  Length  The number of bytes to invalidate from the data cache.    @return Address.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|InvalidateDataCacheRange
parameter_list|(
name|IN
name|VOID
modifier|*
name|Address
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
comment|//
comment|// Invalidation of a data cache range without writing back is not supported on
comment|// x86 architecture, so write back and invalidate operation is performed.
comment|//
return|return
name|WriteBackInvalidateDataCacheRange
argument_list|(
name|Address
argument_list|,
name|Length
argument_list|)
return|;
block|}
end_function

end_unit

