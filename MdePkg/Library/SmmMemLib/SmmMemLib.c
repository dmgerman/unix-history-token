begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Instance of SMM memory check library.    SMM memory check library library implementation. This library consumes SMM_ACCESS2_PROTOCOL   to get SMRAM information. In order to use this library instance, the platform should produce   all SMRAM range via SMM_ACCESS2_PROTOCOL, including the range for firmware (like SMM Core   and SMM driver) and/or specific dedicated hardware.    Copyright (c) 2015 - 2016, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<PiSmm.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseMemoryLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/MemoryAllocationLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/UefiBootServicesTableLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/SmmServicesTableLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/HobLib.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/SmmAccess2.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/SmmReadyToLock.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/SmmEndOfDxe.h>
end_include

begin_define
define|#
directive|define
name|NEXT_MEMORY_DESCRIPTOR
parameter_list|(
name|MemoryDescriptor
parameter_list|,
name|Size
parameter_list|)
define|\
value|((EFI_MEMORY_DESCRIPTOR *)((UINT8 *)(MemoryDescriptor) + (Size)))
end_define

begin_decl_stmt
name|EFI_SMRAM_DESCRIPTOR
modifier|*
name|mSmmMemLibInternalSmramRanges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UINTN
name|mSmmMemLibInternalSmramCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// Maximum support address used to check input buffer
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|EFI_PHYSICAL_ADDRESS
name|mSmmMemLibInternalMaximumSupportAddress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UINTN
name|mMemoryMapEntryCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EFI_MEMORY_DESCRIPTOR
modifier|*
name|mMemoryMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UINTN
name|mDescriptorSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOID
modifier|*
name|mRegistrationEndOfDxe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOID
modifier|*
name|mRegistrationReadyToLock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOLEAN
name|mSmmReadyToLock
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**   Calculate and save the maximum support address.  **/
end_comment

begin_function
name|VOID
name|SmmMemLibInternalCalculateMaximumSupportAddress
parameter_list|(
name|VOID
parameter_list|)
block|{
name|VOID
modifier|*
name|Hob
decl_stmt|;
name|UINT32
name|RegEax
decl_stmt|;
name|UINT8
name|PhysicalAddressBits
decl_stmt|;
comment|//
comment|// Get physical address bits supported.
comment|//
name|Hob
operator|=
name|GetFirstHob
argument_list|(
name|EFI_HOB_TYPE_CPU
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hob
operator|!=
name|NULL
condition|)
block|{
name|PhysicalAddressBits
operator|=
operator|(
operator|(
name|EFI_HOB_CPU
operator|*
operator|)
name|Hob
operator|)
operator|->
name|SizeOfMemorySpace
expr_stmt|;
block|}
else|else
block|{
name|AsmCpuid
argument_list|(
literal|0x80000000
argument_list|,
operator|&
name|RegEax
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|RegEax
operator|>=
literal|0x80000008
condition|)
block|{
name|AsmCpuid
argument_list|(
literal|0x80000008
argument_list|,
operator|&
name|RegEax
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PhysicalAddressBits
operator|=
operator|(
name|UINT8
operator|)
name|RegEax
expr_stmt|;
block|}
else|else
block|{
name|PhysicalAddressBits
operator|=
literal|36
expr_stmt|;
block|}
block|}
comment|//
comment|// IA-32e paging translates 48-bit linear addresses to 52-bit physical addresses.
comment|//
name|ASSERT
argument_list|(
name|PhysicalAddressBits
operator|<=
literal|52
argument_list|)
expr_stmt|;
if|if
condition|(
name|PhysicalAddressBits
operator|>
literal|48
condition|)
block|{
name|PhysicalAddressBits
operator|=
literal|48
expr_stmt|;
block|}
comment|//
comment|// Save the maximum support address in one global variable
comment|//
name|mSmmMemLibInternalMaximumSupportAddress
operator|=
call|(
name|EFI_PHYSICAL_ADDRESS
call|)
argument_list|(
name|UINTN
argument_list|)
argument_list|(
name|LShiftU64
argument_list|(
literal|1
argument_list|,
name|PhysicalAddressBits
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
name|EFI_D_INFO
operator|,
literal|"mSmmMemLibInternalMaximumSupportAddress = 0x%lx\n"
operator|,
name|mSmmMemLibInternalMaximumSupportAddress
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   This function check if the buffer is valid per processor architecture and not overlap with SMRAM.    @param Buffer  The buffer start address to be checked.   @param Length  The buffer length to be checked.    @retval TRUE  This buffer is valid per processor architecture and not overlap with SMRAM.   @retval FALSE This buffer is not valid per processor architecture or overlap with SMRAM. **/
end_comment

begin_function
name|BOOLEAN
name|EFIAPI
name|SmmIsBufferOutsideSmmValid
parameter_list|(
name|IN
name|EFI_PHYSICAL_ADDRESS
name|Buffer
parameter_list|,
name|IN
name|UINT64
name|Length
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
comment|//
comment|// Check override.
comment|// NOTE: (B:0->L:4G) is invalid for IA32, but (B:1->L:4G-1)/(B:4G-1->L:1) is valid.
comment|//
if|if
condition|(
operator|(
name|Length
operator|>
name|mSmmMemLibInternalMaximumSupportAddress
operator|)
operator|||
operator|(
name|Buffer
operator|>
name|mSmmMemLibInternalMaximumSupportAddress
operator|)
operator|||
operator|(
operator|(
name|Length
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|Buffer
operator|>
operator|(
name|mSmmMemLibInternalMaximumSupportAddress
operator|-
operator|(
name|Length
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|//
comment|// Overflow happen
comment|//
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmIsBufferOutsideSmmValid: Overflow: Buffer (0x%lx) - Length (0x%lx), MaximumSupportAddress (0x%lx)\n"
operator|,
name|Buffer
operator|,
name|Length
operator|,
name|mSmmMemLibInternalMaximumSupportAddress
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|mSmmMemLibInternalSmramCount
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|Buffer
operator|>=
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|)
operator|&&
operator|(
name|Buffer
operator|<
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|+
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|PhysicalSize
operator|)
operator|)
operator|||
operator|(
operator|(
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|>=
name|Buffer
operator|)
operator|&&
operator|(
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|<
name|Buffer
operator|+
name|Length
operator|)
operator|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmIsBufferOutsideSmmValid: Overlap: Buffer (0x%lx) - Length (0x%lx), "
operator|,
name|Buffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"CpuStart (0x%lx) - PhysicalSize (0x%lx)\n"
operator|,
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|,
name|mSmmMemLibInternalSmramRanges
index|[
name|Index
index|]
operator|.
name|PhysicalSize
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|//
comment|// Check override for Valid Communication Region
comment|//
if|if
condition|(
name|mSmmReadyToLock
condition|)
block|{
name|EFI_MEMORY_DESCRIPTOR
modifier|*
name|MemoryMap
decl_stmt|;
name|BOOLEAN
name|InValidCommunicationRegion
decl_stmt|;
name|InValidCommunicationRegion
operator|=
name|FALSE
expr_stmt|;
name|MemoryMap
operator|=
name|mMemoryMap
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|mMemoryMapEntryCount
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Buffer
operator|>=
name|MemoryMap
operator|->
name|PhysicalStart
operator|)
operator|&&
operator|(
name|Buffer
operator|+
name|Length
operator|<=
name|MemoryMap
operator|->
name|PhysicalStart
operator|+
name|LShiftU64
argument_list|(
name|MemoryMap
operator|->
name|NumberOfPages
argument_list|,
name|EFI_PAGE_SHIFT
argument_list|)
operator|)
condition|)
block|{
name|InValidCommunicationRegion
operator|=
name|TRUE
expr_stmt|;
block|}
name|MemoryMap
operator|=
name|NEXT_MEMORY_DESCRIPTOR
argument_list|(
name|MemoryMap
argument_list|,
name|mDescriptorSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|InValidCommunicationRegion
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmIsBufferOutsideSmmValid: Not in ValidCommunicationRegion: Buffer (0x%lx) - Length (0x%lx), "
operator|,
name|Buffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**   Copies a source buffer (non-SMRAM) to a destination buffer (SMRAM).    This function copies a source buffer (non-SMRAM) to a destination buffer (SMRAM).   It checks if source buffer is valid per processor architecture and not overlap with SMRAM.   If the check passes, it copies memory and returns EFI_SUCCESS.   If the check fails, it return EFI_SECURITY_VIOLATION.   The implementation must be reentrant.    @param  DestinationBuffer   The pointer to the destination buffer of the memory copy.   @param  SourceBuffer        The pointer to the source buffer of the memory copy.   @param  Length              The number of bytes to copy from SourceBuffer to DestinationBuffer.    @retval EFI_SECURITY_VIOLATION The SourceBuffer is invalid per processor architecture or overlap with SMRAM.   @retval EFI_SUCCESS            Memory is copied.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmCopyMemToSmram
parameter_list|(
name|OUT
name|VOID
modifier|*
name|DestinationBuffer
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|SourceBuffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SmmIsBufferOutsideSmmValid
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|SourceBuffer
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmCopyMemToSmram: Security Violation: Source (0x%x), Length (0x%x)\n"
operator|,
name|SourceBuffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
return|return
name|EFI_SECURITY_VIOLATION
return|;
block|}
name|CopyMem
argument_list|(
name|DestinationBuffer
argument_list|,
name|SourceBuffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Copies a source buffer (SMRAM) to a destination buffer (NON-SMRAM).    This function copies a source buffer (non-SMRAM) to a destination buffer (SMRAM).   It checks if destination buffer is valid per processor architecture and not overlap with SMRAM.   If the check passes, it copies memory and returns EFI_SUCCESS.   If the check fails, it returns EFI_SECURITY_VIOLATION.   The implementation must be reentrant.      @param  DestinationBuffer   The pointer to the destination buffer of the memory copy.   @param  SourceBuffer        The pointer to the source buffer of the memory copy.   @param  Length              The number of bytes to copy from SourceBuffer to DestinationBuffer.    @retval EFI_SECURITY_VIOLATION The DesinationBuffer is invalid per processor architecture or overlap with SMRAM.   @retval EFI_SUCCESS            Memory is copied.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmCopyMemFromSmram
parameter_list|(
name|OUT
name|VOID
modifier|*
name|DestinationBuffer
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|SourceBuffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SmmIsBufferOutsideSmmValid
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|DestinationBuffer
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmCopyMemFromSmram: Security Violation: Destination (0x%x), Length (0x%x)\n"
operator|,
name|DestinationBuffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
return|return
name|EFI_SECURITY_VIOLATION
return|;
block|}
name|CopyMem
argument_list|(
name|DestinationBuffer
argument_list|,
name|SourceBuffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Copies a source buffer (NON-SMRAM) to a destination buffer (NON-SMRAM).    This function copies a source buffer (non-SMRAM) to a destination buffer (SMRAM).   It checks if source buffer and destination buffer are valid per processor architecture and not overlap with SMRAM.   If the check passes, it copies memory and returns EFI_SUCCESS.   If the check fails, it returns EFI_SECURITY_VIOLATION.   The implementation must be reentrant, and it must handle the case where source buffer overlaps destination buffer.      @param  DestinationBuffer   The pointer to the destination buffer of the memory copy.   @param  SourceBuffer        The pointer to the source buffer of the memory copy.   @param  Length              The number of bytes to copy from SourceBuffer to DestinationBuffer.    @retval EFI_SECURITY_VIOLATION The DesinationBuffer is invalid per processor architecture or overlap with SMRAM.   @retval EFI_SECURITY_VIOLATION The SourceBuffer is invalid per processor architecture or overlap with SMRAM.   @retval EFI_SUCCESS            Memory is copied.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmCopyMem
parameter_list|(
name|OUT
name|VOID
modifier|*
name|DestinationBuffer
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|SourceBuffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SmmIsBufferOutsideSmmValid
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|DestinationBuffer
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmCopyMem: Security Violation: Destination (0x%x), Length (0x%x)\n"
operator|,
name|DestinationBuffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
return|return
name|EFI_SECURITY_VIOLATION
return|;
block|}
if|if
condition|(
operator|!
name|SmmIsBufferOutsideSmmValid
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|SourceBuffer
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmCopyMem: Security Violation: Source (0x%x), Length (0x%x)\n"
operator|,
name|SourceBuffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
return|return
name|EFI_SECURITY_VIOLATION
return|;
block|}
name|CopyMem
argument_list|(
name|DestinationBuffer
argument_list|,
name|SourceBuffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Fills a target buffer (NON-SMRAM) with a byte value.    This function fills a target buffer (non-SMRAM) with a byte value.   It checks if target buffer is valid per processor architecture and not overlap with SMRAM.   If the check passes, it fills memory and returns EFI_SUCCESS.   If the check fails, it returns EFI_SECURITY_VIOLATION.      @param  Buffer    The memory to set.   @param  Length    The number of bytes to set.   @param  Value     The value with which to fill Length bytes of Buffer.      @retval EFI_SECURITY_VIOLATION The Buffer is invalid per processor architecture or overlap with SMRAM.   @retval EFI_SUCCESS            Memory is set.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmSetMem
parameter_list|(
name|OUT
name|VOID
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|,
name|IN
name|UINT8
name|Value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SmmIsBufferOutsideSmmValid
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
argument_list|,
name|Length
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
operator|(
name|EFI_D_ERROR
operator|,
literal|"SmmSetMem: Security Violation: Source (0x%x), Length (0x%x)\n"
operator|,
name|Buffer
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
return|return
name|EFI_SECURITY_VIOLATION
return|;
block|}
name|SetMem
argument_list|(
name|Buffer
argument_list|,
name|Length
argument_list|,
name|Value
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Notification for SMM EndOfDxe protocol.    @param[in] Protocol   Points to the protocol's unique identifier.   @param[in] Interface  Points to the interface instance.   @param[in] Handle     The handle on which the interface was installed.    @retval EFI_SUCCESS   Notification runs successfully. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmLibInternalEndOfDxeNotify
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|Protocol
parameter_list|,
name|IN
name|VOID
modifier|*
name|Interface
parameter_list|,
name|IN
name|EFI_HANDLE
name|Handle
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|UINTN
name|MapKey
decl_stmt|;
name|UINTN
name|MemoryMapSize
decl_stmt|;
name|EFI_MEMORY_DESCRIPTOR
modifier|*
name|MemoryMap
decl_stmt|;
name|EFI_MEMORY_DESCRIPTOR
modifier|*
name|MemoryMapStart
decl_stmt|;
name|EFI_MEMORY_DESCRIPTOR
modifier|*
name|SmmMemoryMapStart
decl_stmt|;
name|UINTN
name|MemoryMapEntryCount
decl_stmt|;
name|UINTN
name|DescriptorSize
decl_stmt|;
name|UINT32
name|DescriptorVersion
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|MemoryMapSize
operator|=
literal|0
expr_stmt|;
name|MemoryMap
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|GetMemoryMap
argument_list|(
operator|&
name|MemoryMapSize
argument_list|,
name|MemoryMap
argument_list|,
operator|&
name|MapKey
argument_list|,
operator|&
name|DescriptorSize
argument_list|,
operator|&
name|DescriptorVersion
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
do|do
block|{
name|Status
operator|=
name|gBS
operator|->
name|AllocatePool
argument_list|(
name|EfiBootServicesData
argument_list|,
name|MemoryMapSize
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|MemoryMap
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MemoryMap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|GetMemoryMap
argument_list|(
operator|&
name|MemoryMapSize
argument_list|,
name|MemoryMap
argument_list|,
operator|&
name|MapKey
argument_list|,
operator|&
name|DescriptorSize
argument_list|,
operator|&
name|DescriptorVersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|gBS
operator|->
name|FreePool
argument_list|(
name|MemoryMap
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
condition|)
do|;
comment|//
comment|// Get Count
comment|//
name|mDescriptorSize
operator|=
name|DescriptorSize
expr_stmt|;
name|MemoryMapEntryCount
operator|=
name|MemoryMapSize
operator|/
name|DescriptorSize
expr_stmt|;
name|MemoryMapStart
operator|=
name|MemoryMap
expr_stmt|;
name|mMemoryMapEntryCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|MemoryMapEntryCount
condition|;
name|Index
operator|++
control|)
block|{
switch|switch
condition|(
name|MemoryMap
operator|->
name|Type
condition|)
block|{
case|case
name|EfiReservedMemoryType
case|:
case|case
name|EfiRuntimeServicesCode
case|:
case|case
name|EfiRuntimeServicesData
case|:
case|case
name|EfiACPIMemoryNVS
case|:
name|mMemoryMapEntryCount
operator|++
expr_stmt|;
break|break;
block|}
name|MemoryMap
operator|=
name|NEXT_MEMORY_DESCRIPTOR
argument_list|(
name|MemoryMap
argument_list|,
name|DescriptorSize
argument_list|)
expr_stmt|;
block|}
name|MemoryMap
operator|=
name|MemoryMapStart
expr_stmt|;
comment|//
comment|// Get Data
comment|//
name|mMemoryMap
operator|=
name|AllocatePool
argument_list|(
name|mMemoryMapEntryCount
operator|*
name|DescriptorSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mMemoryMap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SmmMemoryMapStart
operator|=
name|mMemoryMap
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|MemoryMapEntryCount
condition|;
name|Index
operator|++
control|)
block|{
switch|switch
condition|(
name|MemoryMap
operator|->
name|Type
condition|)
block|{
case|case
name|EfiReservedMemoryType
case|:
case|case
name|EfiRuntimeServicesCode
case|:
case|case
name|EfiRuntimeServicesData
case|:
case|case
name|EfiACPIMemoryNVS
case|:
name|CopyMem
argument_list|(
name|mMemoryMap
argument_list|,
name|MemoryMap
argument_list|,
name|DescriptorSize
argument_list|)
expr_stmt|;
name|mMemoryMap
operator|=
name|NEXT_MEMORY_DESCRIPTOR
argument_list|(
name|mMemoryMap
argument_list|,
name|DescriptorSize
argument_list|)
expr_stmt|;
break|break;
block|}
name|MemoryMap
operator|=
name|NEXT_MEMORY_DESCRIPTOR
argument_list|(
name|MemoryMap
argument_list|,
name|DescriptorSize
argument_list|)
expr_stmt|;
block|}
name|mMemoryMap
operator|=
name|SmmMemoryMapStart
expr_stmt|;
name|MemoryMap
operator|=
name|MemoryMapStart
expr_stmt|;
name|gBS
operator|->
name|FreePool
argument_list|(
name|MemoryMap
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Notification for SMM ReadyToLock protocol.    @param[in] Protocol   Points to the protocol's unique identifier.   @param[in] Interface  Points to the interface instance.   @param[in] Handle     The handle on which the interface was installed.    @retval EFI_SUCCESS   Notification runs successfully. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmLibInternalReadyToLockNotify
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|Protocol
parameter_list|,
name|IN
name|VOID
modifier|*
name|Interface
parameter_list|,
name|IN
name|EFI_HANDLE
name|Handle
parameter_list|)
block|{
name|mSmmReadyToLock
operator|=
name|TRUE
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   The constructor function initializes the Smm Mem library    @param  ImageHandle   The firmware allocated handle for the EFI image.   @param  SystemTable   A pointer to the EFI System Table.    @retval EFI_SUCCESS   The constructor always returns EFI_SUCCESS.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmMemLibConstructor
parameter_list|(
name|IN
name|EFI_HANDLE
name|ImageHandle
parameter_list|,
name|IN
name|EFI_SYSTEM_TABLE
modifier|*
name|SystemTable
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_SMM_ACCESS2_PROTOCOL
modifier|*
name|SmmAccess
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
comment|//
comment|// Get SMRAM information
comment|//
name|Status
operator|=
name|gBS
operator|->
name|LocateProtocol
argument_list|(
operator|&
name|gEfiSmmAccess2ProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|SmmAccess
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
name|Size
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|SmmAccess
operator|->
name|GetCapabilities
argument_list|(
name|SmmAccess
argument_list|,
operator|&
name|Size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
name|mSmmMemLibInternalSmramRanges
operator|=
name|AllocatePool
argument_list|(
name|Size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSmmMemLibInternalSmramRanges
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Status
operator|=
name|SmmAccess
operator|->
name|GetCapabilities
argument_list|(
name|SmmAccess
argument_list|,
operator|&
name|Size
argument_list|,
name|mSmmMemLibInternalSmramRanges
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
name|mSmmMemLibInternalSmramCount
operator|=
name|Size
operator|/
sizeof|sizeof
argument_list|(
name|EFI_SMRAM_DESCRIPTOR
argument_list|)
expr_stmt|;
comment|//
comment|// Calculate and save maximum support address
comment|//
name|SmmMemLibInternalCalculateMaximumSupportAddress
argument_list|()
expr_stmt|;
comment|//
comment|// Register EndOfDxe to get UEFI memory map
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmRegisterProtocolNotify
argument_list|(
operator|&
name|gEfiSmmEndOfDxeProtocolGuid
argument_list|,
name|SmmLibInternalEndOfDxeNotify
argument_list|,
operator|&
name|mRegistrationEndOfDxe
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|//
comment|// Register ready to lock so that we can know when to check valid SMRAM region
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmRegisterProtocolNotify
argument_list|(
operator|&
name|gEfiSmmReadyToLockProtocolGuid
argument_list|,
name|SmmLibInternalReadyToLockNotify
argument_list|,
operator|&
name|mRegistrationReadyToLock
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   The destructor function frees resource used in the Smm Mem library    @param[in]  ImageHandle   The firmware allocated handle for the EFI image.   @param[in]  SystemTable   A pointer to the EFI System Table.    @retval     EFI_SUCCESS   The deconstructor always returns EFI_SUCCESS. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmMemLibDestructor
parameter_list|(
name|IN
name|EFI_HANDLE
name|ImageHandle
parameter_list|,
name|IN
name|EFI_SYSTEM_TABLE
modifier|*
name|SystemTable
parameter_list|)
block|{
name|FreePool
argument_list|(
name|mSmmMemLibInternalSmramRanges
argument_list|)
expr_stmt|;
name|gSmst
operator|->
name|SmmRegisterProtocolNotify
argument_list|(
operator|&
name|gEfiSmmEndOfDxeProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|&
name|mRegistrationEndOfDxe
argument_list|)
expr_stmt|;
name|gSmst
operator|->
name|SmmRegisterProtocolNotify
argument_list|(
operator|&
name|gEfiSmmReadyToLockProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|&
name|mRegistrationReadyToLock
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

end_unit

