begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Timer Library functions built upon ITC on IPF.    Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<Base.h>
end_include

begin_include
include|#
directive|include
file|<Library/TimerLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/PalLib.h>
end_include

begin_comment
comment|/**   Performs a delay measured as number of ticks.    An internal function to perform a delay measured as number of ticks. It's   invoked by MicroSecondDelay() and NanoSecondDelay().    @param  Delay The number of ticks to delay.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|InternalIpfDelay
parameter_list|(
name|IN
name|INT64
name|Delay
parameter_list|)
block|{
name|INT64
name|Ticks
decl_stmt|;
comment|//
comment|// The target timer count is calculated here
comment|//
name|Ticks
operator|=
operator|(
name|INT64
operator|)
name|AsmReadItc
argument_list|()
operator|+
name|Delay
expr_stmt|;
comment|//
comment|// Wait until time out
comment|// Delay> 2^63 could not be handled by this function
comment|// Timer wrap-arounds are handled correctly by this function
comment|//
while|while
condition|(
name|Ticks
operator|-
operator|(
name|INT64
operator|)
name|AsmReadItc
argument_list|()
operator|>=
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/**   Stalls the CPU for at least the given number of microseconds.    Stalls the CPU for the number of microseconds specified by MicroSeconds.    @param  MicroSeconds  The minimum number of microseconds to delay.    @return The value of MicroSeconds inputted.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|MicroSecondDelay
parameter_list|(
name|IN
name|UINTN
name|MicroSeconds
parameter_list|)
block|{
name|InternalIpfDelay
argument_list|(
name|GetPerformanceCounterProperties
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|*
name|MicroSeconds
operator|/
literal|1000000
argument_list|)
expr_stmt|;
return|return
name|MicroSeconds
return|;
block|}
end_function

begin_comment
comment|/**   Stalls the CPU for at least the given number of nanoseconds.    Stalls the CPU for the number of nanoseconds specified by NanoSeconds.    @param  NanoSeconds The minimum number of nanoseconds to delay.    @return The value of NanoSeconds inputted.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|NanoSecondDelay
parameter_list|(
name|IN
name|UINTN
name|NanoSeconds
parameter_list|)
block|{
name|InternalIpfDelay
argument_list|(
name|GetPerformanceCounterProperties
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|*
name|NanoSeconds
operator|/
literal|1000000000
argument_list|)
expr_stmt|;
return|return
name|NanoSeconds
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the current value of a 64-bit free running performance counter.    The counter can either count up by 1 or count down by 1. If the physical   performance counter counts by a larger increment, then the counter values   must be translated. The properties of the counter can be retrieved from   GetPerformanceCounterProperties().    @return The current value of the free running performance counter.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetPerformanceCounter
parameter_list|(
name|VOID
parameter_list|)
block|{
return|return
name|AsmReadItc
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the 64-bit frequency in Hz and the range of performance counter   values.    If StartValue is not NULL, then the value that the performance counter starts   with immediately after is it rolls over is returned in StartValue. If   EndValue is not NULL, then the value that the performance counter end with   immediately before it rolls over is returned in EndValue. The 64-bit   frequency of the performance counter in Hz is always returned. If StartValue   is less than EndValue, then the performance counter counts up. If StartValue   is greater than EndValue, then the performance counter counts down. For   example, a 64-bit free running counter that counts up would have a StartValue   of 0 and an EndValue of 0xFFFFFFFFFFFFFFFF. A 24-bit free running counter   that counts down would have a StartValue of 0xFFFFFF and an EndValue of 0.    @param  StartValue  The value the performance counter starts with when it                       rolls over.   @param  EndValue    The value that the performance counter ends with before                       it rolls over.    @return The frequency in Hz.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetPerformanceCounterProperties
parameter_list|(
name|OUT
name|UINT64
modifier|*
name|StartValue
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|EndValue
name|OPTIONAL
parameter_list|)
block|{
name|PAL_CALL_RETURN
name|PalRet
decl_stmt|;
name|UINT64
name|BaseFrequence
decl_stmt|;
if|if
condition|(
name|StartValue
operator|!=
name|NULL
condition|)
block|{
operator|*
name|StartValue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|EndValue
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndValue
operator|=
call|(
name|UINT64
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PalRet
operator|=
name|PalCall
argument_list|(
name|PAL_FREQ_BASE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PalRet
operator|.
name|Status
operator|!=
literal|0
condition|)
block|{
return|return
literal|1000000
return|;
block|}
name|BaseFrequence
operator|=
name|PalRet
operator|.
name|r9
expr_stmt|;
name|PalRet
operator|=
name|PalCall
argument_list|(
name|PAL_FREQ_RATIOS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PalRet
operator|.
name|Status
operator|!=
literal|0
condition|)
block|{
return|return
literal|1000000
return|;
block|}
return|return
name|BaseFrequence
operator|*
operator|(
name|PalRet
operator|.
name|r11
operator|>>
literal|32
operator|)
operator|/
operator|(
name|UINT32
operator|)
name|PalRet
operator|.
name|r11
return|;
block|}
end_function

begin_comment
comment|/**   Converts elapsed ticks of performance counter to time in nanoseconds.    This function converts the elapsed ticks of running performance counter to   time value in unit of nanoseconds.    @param  Ticks     The number of elapsed ticks of running performance counter.    @return The elapsed time in nanoseconds.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetTimeInNanoSecond
parameter_list|(
name|IN
name|UINT64
name|Ticks
parameter_list|)
block|{
name|UINT64
name|Frequency
decl_stmt|;
name|UINT64
name|NanoSeconds
decl_stmt|;
name|UINT64
name|Remainder
decl_stmt|;
name|INTN
name|Shift
decl_stmt|;
name|Frequency
operator|=
name|GetPerformanceCounterProperties
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|//          Ticks
comment|// Time = --------- x 1,000,000,000
comment|//        Frequency
comment|//
name|NanoSeconds
operator|=
name|MultU64x32
argument_list|(
name|DivU64x64Remainder
argument_list|(
name|Ticks
argument_list|,
name|Frequency
argument_list|,
operator|&
name|Remainder
argument_list|)
argument_list|,
literal|1000000000u
argument_list|)
expr_stmt|;
comment|//
comment|// Ensure (Remainder * 1,000,000,000) will not overflow 64-bit.
comment|// Since 2^29< 1,000,000,000 = 0x3B9ACA00< 2^30, Remainder should< 2^(64-30) = 2^34,
comment|// i.e. highest bit set in Remainder should<= 33.
comment|//
name|Shift
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|HighBitSet64
argument_list|(
name|Remainder
argument_list|)
operator|-
literal|33
argument_list|)
expr_stmt|;
name|Remainder
operator|=
name|RShiftU64
argument_list|(
name|Remainder
argument_list|,
operator|(
name|UINTN
operator|)
name|Shift
argument_list|)
expr_stmt|;
name|Frequency
operator|=
name|RShiftU64
argument_list|(
name|Frequency
argument_list|,
operator|(
name|UINTN
operator|)
name|Shift
argument_list|)
expr_stmt|;
name|NanoSeconds
operator|+=
name|DivU64x64Remainder
argument_list|(
name|MultU64x32
argument_list|(
name|Remainder
argument_list|,
literal|1000000000u
argument_list|)
argument_list|,
name|Frequency
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NanoSeconds
return|;
block|}
end_function

end_unit

