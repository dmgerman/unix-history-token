begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Timer Library functions built upon local APIC on IA32/x64.    Copyright (c) 2006 - 2015, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<Base.h>
end_include

begin_include
include|#
directive|include
file|<Library/TimerLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/IoLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/PcdLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_define
define|#
directive|define
name|APIC_SVR
value|0x0f0
end_define

begin_define
define|#
directive|define
name|APIC_LVTERR
value|0x370
end_define

begin_define
define|#
directive|define
name|APIC_TMICT
value|0x380
end_define

begin_define
define|#
directive|define
name|APIC_TMCCT
value|0x390
end_define

begin_define
define|#
directive|define
name|APIC_TDCR
value|0x3e0
end_define

begin_comment
comment|//
end_comment

begin_comment
comment|// The following array is used in calculating the frequency of local APIC
end_comment

begin_comment
comment|// timer. Refer to IA-32 developers' manual for more details.
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|GLOBAL_REMOVE_IF_UNREFERENCED
name|CONST
name|UINT8
name|mTimerLibLocalApicDivisor
index|[]
init|=
block|{
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x01
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**   Internal function to retrieve the base address of local APIC.    This function will ASSERT if:   The local APIC is not globally enabled.   The local APIC is not working under XAPIC mode.   The local APIC is not software enabled.    @return The base address of local APIC  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|InternalX86GetApicBase
parameter_list|(
name|VOID
parameter_list|)
block|{
name|UINTN
name|MsrValue
decl_stmt|;
name|UINTN
name|ApicBase
decl_stmt|;
name|MsrValue
operator|=
operator|(
name|UINTN
operator|)
name|AsmReadMsr64
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|ApicBase
operator|=
name|MsrValue
operator|&
literal|0xffffff000ULL
expr_stmt|;
comment|//
comment|// Check the APIC Global Enable bit (bit 11) in IA32_APIC_BASE MSR.
comment|// This bit will be 1, if local APIC is globally enabled.
comment|//
name|ASSERT
argument_list|(
operator|(
name|MsrValue
operator|&
name|BIT11
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Check the APIC Extended Mode bit (bit 10) in IA32_APIC_BASE MSR.
comment|// This bit will be 0, if local APIC is under XAPIC mode.
comment|//
name|ASSERT
argument_list|(
operator|(
name|MsrValue
operator|&
name|BIT10
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Check the APIC Software Enable/Disable bit (bit 8) in Spurious-Interrupt
comment|// Vector Register.
comment|// This bit will be 1, if local APIC is software enabled.
comment|//
name|ASSERT
argument_list|(
operator|(
name|MmioRead32
argument_list|(
name|ApicBase
operator|+
name|APIC_SVR
argument_list|)
operator|&
name|BIT8
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|ApicBase
return|;
block|}
end_function

begin_comment
comment|/**   Internal function to return the frequency of the local APIC timer.    @param  ApicBase  The base address of memory mapped registers of local APIC.    @return The frequency of the timer in Hz.  **/
end_comment

begin_function
name|UINT32
name|EFIAPI
name|InternalX86GetTimerFrequency
parameter_list|(
name|IN
name|UINTN
name|ApicBase
parameter_list|)
block|{
return|return
name|PcdGet32
argument_list|(
name|PcdFSBClock
argument_list|)
operator|/
name|mTimerLibLocalApicDivisor
index|[
name|MmioBitFieldRead32
argument_list|(
name|ApicBase
operator|+
name|APIC_TDCR
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/**   Internal function to read the current tick counter of local APIC.    @param  ApicBase  The base address of memory mapped registers of local APIC.    @return The tick counter read.  **/
end_comment

begin_function
name|INT32
name|EFIAPI
name|InternalX86GetTimerTick
parameter_list|(
name|IN
name|UINTN
name|ApicBase
parameter_list|)
block|{
return|return
name|MmioRead32
argument_list|(
name|ApicBase
operator|+
name|APIC_TMCCT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Internal function to read the initial timer count of local APIC.    @param  ApicBase  The base address of memory mapped registers of local APIC.    @return The initial timer count read.  **/
end_comment

begin_function
name|UINT32
name|InternalX86GetInitTimerCount
parameter_list|(
name|IN
name|UINTN
name|ApicBase
parameter_list|)
block|{
return|return
name|MmioRead32
argument_list|(
name|ApicBase
operator|+
name|APIC_TMICT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Stalls the CPU for at least the given number of ticks.    Stalls the CPU for at least the given number of ticks. It's invoked by   MicroSecondDelay() and NanoSecondDelay().    This function will ASSERT if the APIC timer intial count returned from   InternalX86GetInitTimerCount() is zero.    @param  ApicBase  The base address of memory mapped registers of local APIC.   @param  Delay     A period of time to delay in ticks.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|InternalX86Delay
parameter_list|(
name|IN
name|UINTN
name|ApicBase
parameter_list|,
name|IN
name|UINT32
name|Delay
parameter_list|)
block|{
name|INT32
name|Ticks
decl_stmt|;
name|UINT32
name|Times
decl_stmt|;
name|UINT32
name|InitCount
decl_stmt|;
name|UINT32
name|StartTick
decl_stmt|;
comment|//
comment|// In case Delay is too larger, separate it into several small delay slot.
comment|// Devided Delay by half value of Init Count is to avoid Delay close to
comment|// the Init Count, timeout maybe missing if the time consuming between 2
comment|// GetApicTimerCurrentCount() invoking is larger than the time gap between
comment|// Delay and the Init Count.
comment|//
name|InitCount
operator|=
name|InternalX86GetInitTimerCount
argument_list|(
name|ApicBase
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|InitCount
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|Times
operator|=
name|Delay
operator|/
operator|(
name|InitCount
operator|/
literal|2
operator|)
expr_stmt|;
name|Delay
operator|=
name|Delay
operator|%
operator|(
name|InitCount
operator|/
literal|2
operator|)
expr_stmt|;
comment|//
comment|// Get Start Tick and do delay
comment|//
name|StartTick
operator|=
name|InternalX86GetTimerTick
argument_list|(
name|ApicBase
argument_list|)
expr_stmt|;
do|do
block|{
comment|//
comment|// Wait until time out by Delay value
comment|//
do|do
block|{
name|CpuPause
argument_list|()
expr_stmt|;
comment|//
comment|// Get Ticks from Start to Current.
comment|//
name|Ticks
operator|=
name|StartTick
operator|-
name|InternalX86GetTimerTick
argument_list|(
name|ApicBase
argument_list|)
expr_stmt|;
comment|//
comment|// Ticks< 0 means Timer wrap-arounds happens.
comment|//
if|if
condition|(
name|Ticks
operator|<
literal|0
condition|)
block|{
name|Ticks
operator|+=
name|InitCount
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|UINT32
operator|)
name|Ticks
operator|<
name|Delay
condition|)
do|;
comment|//
comment|// Update StartTick and Delay for next delay slot
comment|//
name|StartTick
operator|-=
operator|(
name|StartTick
operator|>
name|Delay
operator|)
condition|?
name|Delay
else|:
operator|(
name|Delay
operator|-
name|InitCount
operator|)
expr_stmt|;
name|Delay
operator|=
name|InitCount
operator|/
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|Times
operator|--
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/**   Stalls the CPU for at least the given number of microseconds.    Stalls the CPU for the number of microseconds specified by MicroSeconds.    @param  MicroSeconds  The minimum number of microseconds to delay.    @return The value of MicroSeconds inputted.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|MicroSecondDelay
parameter_list|(
name|IN
name|UINTN
name|MicroSeconds
parameter_list|)
block|{
name|UINTN
name|ApicBase
decl_stmt|;
name|ApicBase
operator|=
name|InternalX86GetApicBase
argument_list|()
expr_stmt|;
name|InternalX86Delay
argument_list|(
name|ApicBase
argument_list|,
operator|(
name|UINT32
operator|)
name|DivU64x32
argument_list|(
name|MultU64x64
argument_list|(
name|InternalX86GetTimerFrequency
argument_list|(
name|ApicBase
argument_list|)
argument_list|,
name|MicroSeconds
argument_list|)
argument_list|,
literal|1000000u
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MicroSeconds
return|;
block|}
end_function

begin_comment
comment|/**   Stalls the CPU for at least the given number of nanoseconds.    Stalls the CPU for the number of nanoseconds specified by NanoSeconds.    @param  NanoSeconds The minimum number of nanoseconds to delay.    @return The value of NanoSeconds inputted.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|NanoSecondDelay
parameter_list|(
name|IN
name|UINTN
name|NanoSeconds
parameter_list|)
block|{
name|UINTN
name|ApicBase
decl_stmt|;
name|ApicBase
operator|=
name|InternalX86GetApicBase
argument_list|()
expr_stmt|;
name|InternalX86Delay
argument_list|(
name|ApicBase
argument_list|,
operator|(
name|UINT32
operator|)
name|DivU64x32
argument_list|(
name|MultU64x64
argument_list|(
name|InternalX86GetTimerFrequency
argument_list|(
name|ApicBase
argument_list|)
argument_list|,
name|NanoSeconds
argument_list|)
argument_list|,
literal|1000000000u
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NanoSeconds
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the current value of a 64-bit free running performance counter.    The counter can either count up by 1 or count down by 1. If the physical   performance counter counts by a larger increment, then the counter values   must be translated. The properties of the counter can be retrieved from   GetPerformanceCounterProperties().    @return The current value of the free running performance counter.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetPerformanceCounter
parameter_list|(
name|VOID
parameter_list|)
block|{
return|return
operator|(
name|UINT64
operator|)
operator|(
name|UINT32
operator|)
name|InternalX86GetTimerTick
argument_list|(
name|InternalX86GetApicBase
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the 64-bit frequency in Hz and the range of performance counter   values.    If StartValue is not NULL, then the value that the performance counter starts   with immediately after is it rolls over is returned in StartValue. If   EndValue is not NULL, then the value that the performance counter end with   immediately before it rolls over is returned in EndValue. The 64-bit   frequency of the performance counter in Hz is always returned. If StartValue   is less than EndValue, then the performance counter counts up. If StartValue   is greater than EndValue, then the performance counter counts down. For   example, a 64-bit free running counter that counts up would have a StartValue   of 0 and an EndValue of 0xFFFFFFFFFFFFFFFF. A 24-bit free running counter   that counts down would have a StartValue of 0xFFFFFF and an EndValue of 0.    @param  StartValue  The value the performance counter starts with when it                       rolls over.   @param  EndValue    The value that the performance counter ends with before                       it rolls over.    @return The frequency in Hz.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetPerformanceCounterProperties
parameter_list|(
name|OUT
name|UINT64
modifier|*
name|StartValue
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|EndValue
name|OPTIONAL
parameter_list|)
block|{
name|UINTN
name|ApicBase
decl_stmt|;
name|ApicBase
operator|=
name|InternalX86GetApicBase
argument_list|()
expr_stmt|;
if|if
condition|(
name|StartValue
operator|!=
name|NULL
condition|)
block|{
operator|*
name|StartValue
operator|=
operator|(
name|UINT64
operator|)
name|InternalX86GetInitTimerCount
argument_list|(
name|ApicBase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndValue
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndValue
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|UINT64
operator|)
name|InternalX86GetTimerFrequency
argument_list|(
name|ApicBase
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Converts elapsed ticks of performance counter to time in nanoseconds.    This function converts the elapsed ticks of running performance counter to   time value in unit of nanoseconds.    @param  Ticks     The number of elapsed ticks of running performance counter.    @return The elapsed time in nanoseconds.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetTimeInNanoSecond
parameter_list|(
name|IN
name|UINT64
name|Ticks
parameter_list|)
block|{
name|UINT64
name|Frequency
decl_stmt|;
name|UINT64
name|NanoSeconds
decl_stmt|;
name|UINT64
name|Remainder
decl_stmt|;
name|INTN
name|Shift
decl_stmt|;
name|Frequency
operator|=
name|GetPerformanceCounterProperties
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|//          Ticks
comment|// Time = --------- x 1,000,000,000
comment|//        Frequency
comment|//
name|NanoSeconds
operator|=
name|MultU64x32
argument_list|(
name|DivU64x64Remainder
argument_list|(
name|Ticks
argument_list|,
name|Frequency
argument_list|,
operator|&
name|Remainder
argument_list|)
argument_list|,
literal|1000000000u
argument_list|)
expr_stmt|;
comment|//
comment|// Ensure (Remainder * 1,000,000,000) will not overflow 64-bit.
comment|// Since 2^29< 1,000,000,000 = 0x3B9ACA00< 2^30, Remainder should< 2^(64-30) = 2^34,
comment|// i.e. highest bit set in Remainder should<= 33.
comment|//
name|Shift
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|HighBitSet64
argument_list|(
name|Remainder
argument_list|)
operator|-
literal|33
argument_list|)
expr_stmt|;
name|Remainder
operator|=
name|RShiftU64
argument_list|(
name|Remainder
argument_list|,
operator|(
name|UINTN
operator|)
name|Shift
argument_list|)
expr_stmt|;
name|Frequency
operator|=
name|RShiftU64
argument_list|(
name|Frequency
argument_list|,
operator|(
name|UINTN
operator|)
name|Shift
argument_list|)
expr_stmt|;
name|NanoSeconds
operator|+=
name|DivU64x64Remainder
argument_list|(
name|MultU64x32
argument_list|(
name|Remainder
argument_list|,
literal|1000000000u
argument_list|)
argument_list|,
name|Frequency
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NanoSeconds
return|;
block|}
end_function

end_unit

