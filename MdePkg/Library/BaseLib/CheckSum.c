begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Utility functions to generate checksum based on 2's complement   algorithm.    Copyright (c) 2007 - 2010, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|"BaseLibInternals.h"
end_include

begin_comment
comment|/**   Returns the sum of all elements in a buffer in unit of UINT8.   During calculation, the carry bits are dropped.    This function calculates the sum of all elements in a buffer   in unit of UINT8. The carry bits in result of addition are dropped.   The result is returned as UINT8. If Length is Zero, then Zero is   returned.    If Buffer is NULL, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the sum operation.   @param  Length      The size, in bytes, of Buffer.    @return Sum         The sum of Buffer with carry bits dropped during additions.  **/
end_comment

begin_function
name|UINT8
name|EFIAPI
name|CalculateSum8
parameter_list|(
name|IN
name|CONST
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT8
name|Sum
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Length
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Sum
operator|=
literal|0
operator|,
name|Count
operator|=
literal|0
init|;
name|Count
operator|<
name|Length
condition|;
name|Count
operator|++
control|)
block|{
name|Sum
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|Sum
operator|+
operator|*
operator|(
name|Buffer
operator|+
name|Count
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Sum
return|;
block|}
end_function

begin_comment
comment|/**   Returns the two's complement checksum of all elements in a buffer   of 8-bit values.    This function first calculates the sum of the 8-bit values in the   buffer specified by Buffer and Length.  The carry bits in the result   of addition are dropped. Then, the two's complement of the sum is   returned.  If Length is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the checksum operation.   @param  Length      The size, in bytes, of Buffer.    @return Checksum    The 2's complement checksum of Buffer.  **/
end_comment

begin_function
name|UINT8
name|EFIAPI
name|CalculateCheckSum8
parameter_list|(
name|IN
name|CONST
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT8
name|CheckSum
decl_stmt|;
name|CheckSum
operator|=
name|CalculateSum8
argument_list|(
name|Buffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|//
comment|// Return the checksum based on 2's complement.
comment|//
return|return
call|(
name|UINT8
call|)
argument_list|(
literal|0x100
operator|-
name|CheckSum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Returns the sum of all elements in a buffer of 16-bit values.  During   calculation, the carry bits are dropped.    This function calculates the sum of the 16-bit values in the buffer   specified by Buffer and Length. The carry bits in result of addition are dropped.   The 16-bit result is returned.  If Length is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Buffer is not aligned on a 16-bit boundary, then ASSERT().   If Length is not aligned on a 16-bit boundary, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the sum operation.   @param  Length      The size, in bytes, of Buffer.    @return Sum         The sum of Buffer with carry bits dropped during additions.  **/
end_comment

begin_function
name|UINT16
name|EFIAPI
name|CalculateSum16
parameter_list|(
name|IN
name|CONST
name|UINT16
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT16
name|Sum
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|Total
decl_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|&
literal|0x1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|Length
operator|&
literal|0x1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Length
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|Total
operator|=
name|Length
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|Sum
operator|=
literal|0
operator|,
name|Count
operator|=
literal|0
init|;
name|Count
operator|<
name|Total
condition|;
name|Count
operator|++
control|)
block|{
name|Sum
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Sum
operator|+
operator|*
operator|(
name|Buffer
operator|+
name|Count
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Sum
return|;
block|}
end_function

begin_comment
comment|/**   Returns the two's complement checksum of all elements in a buffer of   16-bit values.    This function first calculates the sum of the 16-bit values in the buffer   specified by Buffer and Length.  The carry bits in the result of addition   are dropped. Then, the two's complement of the sum is returned.  If Length   is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Buffer is not aligned on a 16-bit boundary, then ASSERT().   If Length is not aligned on a 16-bit boundary, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the checksum operation.   @param  Length      The size, in bytes, of Buffer.    @return Checksum    The 2's complement checksum of Buffer.  **/
end_comment

begin_function
name|UINT16
name|EFIAPI
name|CalculateCheckSum16
parameter_list|(
name|IN
name|CONST
name|UINT16
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT16
name|CheckSum
decl_stmt|;
name|CheckSum
operator|=
name|CalculateSum16
argument_list|(
name|Buffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|//
comment|// Return the checksum based on 2's complement.
comment|//
return|return
call|(
name|UINT16
call|)
argument_list|(
literal|0x10000
operator|-
name|CheckSum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Returns the sum of all elements in a buffer of 32-bit values. During   calculation, the carry bits are dropped.    This function calculates the sum of the 32-bit values in the buffer   specified by Buffer and Length. The carry bits in result of addition are dropped.   The 32-bit result is returned. If Length is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Buffer is not aligned on a 32-bit boundary, then ASSERT().   If Length is not aligned on a 32-bit boundary, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the sum operation.   @param  Length      The size, in bytes, of Buffer.    @return Sum         The sum of Buffer with carry bits dropped during additions.  **/
end_comment

begin_function
name|UINT32
name|EFIAPI
name|CalculateSum32
parameter_list|(
name|IN
name|CONST
name|UINT32
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT32
name|Sum
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|Total
decl_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|Length
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Length
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|Total
operator|=
name|Length
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|Sum
operator|=
literal|0
operator|,
name|Count
operator|=
literal|0
init|;
name|Count
operator|<
name|Total
condition|;
name|Count
operator|++
control|)
block|{
name|Sum
operator|=
name|Sum
operator|+
operator|*
operator|(
name|Buffer
operator|+
name|Count
operator|)
expr_stmt|;
block|}
return|return
name|Sum
return|;
block|}
end_function

begin_comment
comment|/**   Returns the two's complement checksum of all elements in a buffer of   32-bit values.    This function first calculates the sum of the 32-bit values in the buffer   specified by Buffer and Length.  The carry bits in the result of addition   are dropped. Then, the two's complement of the sum is returned.  If Length   is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Buffer is not aligned on a 32-bit boundary, then ASSERT().   If Length is not aligned on a 32-bit boundary, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the checksum operation.   @param  Length      The size, in bytes, of Buffer.    @return Checksum    The 2's complement checksum of Buffer.  **/
end_comment

begin_function
name|UINT32
name|EFIAPI
name|CalculateCheckSum32
parameter_list|(
name|IN
name|CONST
name|UINT32
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT32
name|CheckSum
decl_stmt|;
name|CheckSum
operator|=
name|CalculateSum32
argument_list|(
name|Buffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|//
comment|// Return the checksum based on 2's complement.
comment|//
return|return
call|(
name|UINT32
call|)
argument_list|(
call|(
name|UINT32
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|-
name|CheckSum
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Returns the sum of all elements in a buffer of 64-bit values.  During   calculation, the carry bits are dropped.    This function calculates the sum of the 64-bit values in the buffer   specified by Buffer and Length. The carry bits in result of addition are dropped.   The 64-bit result is returned.  If Length is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Buffer is not aligned on a 64-bit boundary, then ASSERT().   If Length is not aligned on a 64-bit boundary, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the sum operation.   @param  Length      The size, in bytes, of Buffer.    @return Sum         The sum of Buffer with carry bits dropped during additions.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|CalculateSum64
parameter_list|(
name|IN
name|CONST
name|UINT64
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT64
name|Sum
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|Total
decl_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|&
literal|0x7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|Length
operator|&
literal|0x7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Length
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
operator|(
name|UINTN
operator|)
name|Buffer
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|Total
operator|=
name|Length
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|Sum
operator|=
literal|0
operator|,
name|Count
operator|=
literal|0
init|;
name|Count
operator|<
name|Total
condition|;
name|Count
operator|++
control|)
block|{
name|Sum
operator|=
name|Sum
operator|+
operator|*
operator|(
name|Buffer
operator|+
name|Count
operator|)
expr_stmt|;
block|}
return|return
name|Sum
return|;
block|}
end_function

begin_comment
comment|/**   Returns the two's complement checksum of all elements in a buffer of   64-bit values.    This function first calculates the sum of the 64-bit values in the buffer   specified by Buffer and Length.  The carry bits in the result of addition   are dropped. Then, the two's complement of the sum is returned.  If Length   is 0, then 0 is returned.    If Buffer is NULL, then ASSERT().   If Buffer is not aligned on a 64-bit boundary, then ASSERT().   If Length is not aligned on a 64-bit boundary, then ASSERT().   If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().    @param  Buffer      The pointer to the buffer to carry out the checksum operation.   @param  Length      The size, in bytes, of Buffer.    @return Checksum    The 2's complement checksum of Buffer.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|CalculateCheckSum64
parameter_list|(
name|IN
name|CONST
name|UINT64
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINT64
name|CheckSum
decl_stmt|;
name|CheckSum
operator|=
name|CalculateSum64
argument_list|(
name|Buffer
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|//
comment|// Return the checksum based on 2's complement.
comment|//
return|return
call|(
name|UINT64
call|)
argument_list|(
call|(
name|UINT64
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|-
name|CheckSum
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

