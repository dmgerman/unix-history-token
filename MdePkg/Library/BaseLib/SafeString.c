begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Safe String functions.    Copyright (c) 2014 - 2017, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|"BaseLibInternals.h"
end_include

begin_define
define|#
directive|define
name|RSIZE_MAX
value|(PcdGet32 (PcdMaximumUnicodeStringLength))
end_define

begin_define
define|#
directive|define
name|ASCII_RSIZE_MAX
value|(PcdGet32 (PcdMaximumAsciiStringLength))
end_define

begin_define
define|#
directive|define
name|SAFE_STRING_CONSTRAINT_CHECK
parameter_list|(
name|Expression
parameter_list|,
name|Status
parameter_list|)
define|\
value|do { \     ASSERT (Expression); \     if (!(Expression)) { \       return Status; \     } \   } while (FALSE)
end_define

begin_comment
comment|/**   Returns if 2 memory blocks are overlapped.    @param  Base1  Base address of 1st memory block.   @param  Size1  Size of 1st memory block.   @param  Base2  Base address of 2nd memory block.   @param  Size2  Size of 2nd memory block.    @retval TRUE  2 memory blocks are overlapped.   @retval FALSE 2 memory blocks are not overlapped. **/
end_comment

begin_function
name|BOOLEAN
name|InternalSafeStringIsOverlap
parameter_list|(
name|IN
name|VOID
modifier|*
name|Base1
parameter_list|,
name|IN
name|UINTN
name|Size1
parameter_list|,
name|IN
name|VOID
modifier|*
name|Base2
parameter_list|,
name|IN
name|UINTN
name|Size2
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|UINTN
operator|)
name|Base1
operator|>=
operator|(
name|UINTN
operator|)
name|Base2
operator|)
operator|&&
operator|(
operator|(
name|UINTN
operator|)
name|Base1
operator|<
operator|(
name|UINTN
operator|)
name|Base2
operator|+
name|Size2
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|UINTN
operator|)
name|Base2
operator|>=
operator|(
name|UINTN
operator|)
name|Base1
operator|)
operator|&&
operator|(
operator|(
name|UINTN
operator|)
name|Base2
operator|<
operator|(
name|UINTN
operator|)
name|Base1
operator|+
name|Size1
operator|)
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**   Returns if 2 Unicode strings are not overlapped.    @param  Str1   Start address of 1st Unicode string.   @param  Size1  The number of char in 1st Unicode string,                  including terminating null char.   @param  Str2   Start address of 2nd Unicode string.   @param  Size2  The number of char in 2nd Unicode string,                  including terminating null char.    @retval TRUE  2 Unicode strings are NOT overlapped.   @retval FALSE 2 Unicode strings are overlapped. **/
end_comment

begin_function
name|BOOLEAN
name|InternalSafeStringNoStrOverlap
parameter_list|(
name|IN
name|CHAR16
modifier|*
name|Str1
parameter_list|,
name|IN
name|UINTN
name|Size1
parameter_list|,
name|IN
name|CHAR16
modifier|*
name|Str2
parameter_list|,
name|IN
name|UINTN
name|Size2
parameter_list|)
block|{
return|return
operator|!
name|InternalSafeStringIsOverlap
argument_list|(
name|Str1
argument_list|,
name|Size1
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|,
name|Str2
argument_list|,
name|Size2
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Returns if 2 Ascii strings are not overlapped.    @param  Str1   Start address of 1st Ascii string.   @param  Size1  The number of char in 1st Ascii string,                  including terminating null char.   @param  Str2   Start address of 2nd Ascii string.   @param  Size2  The number of char in 2nd Ascii string,                  including terminating null char.    @retval TRUE  2 Ascii strings are NOT overlapped.   @retval FALSE 2 Ascii strings are overlapped. **/
end_comment

begin_function
name|BOOLEAN
name|InternalSafeStringNoAsciiStrOverlap
parameter_list|(
name|IN
name|CHAR8
modifier|*
name|Str1
parameter_list|,
name|IN
name|UINTN
name|Size1
parameter_list|,
name|IN
name|CHAR8
modifier|*
name|Str2
parameter_list|,
name|IN
name|UINTN
name|Size2
parameter_list|)
block|{
return|return
operator|!
name|InternalSafeStringIsOverlap
argument_list|(
name|Str1
argument_list|,
name|Size1
argument_list|,
name|Str2
argument_list|,
name|Size2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Returns the length of a Null-terminated Unicode string.    This function is similar as strlen_s defined in C11.    If String is not aligned on a 16-bit boundary, then ASSERT().    @param  String   A pointer to a Null-terminated Unicode string.   @param  MaxSize  The maximum number of Destination Unicode                    char, including terminating null char.    @retval 0        If String is NULL.   @retval MaxSize  If there is no null character in the first MaxSize characters of String.   @return The number of characters that percede the terminating null character.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|StrnLenS
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|IN
name|UINTN
name|MaxSize
parameter_list|)
block|{
name|UINTN
name|Length
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// If String is a null pointer or MaxSize is 0, then the StrnLenS function returns zero.
comment|//
if|if
condition|(
operator|(
name|String
operator|==
name|NULL
operator|)
operator|||
operator|(
name|MaxSize
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//
comment|// Otherwise, the StrnLenS function returns the number of characters that precede the
comment|// terminating null character. If there is no null character in the first MaxSize characters of
comment|// String then StrnLenS returns MaxSize. At most the first MaxSize characters of String shall
comment|// be accessed by StrnLenS.
comment|//
name|Length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|String
index|[
name|Length
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Length
operator|>=
name|MaxSize
operator|-
literal|1
condition|)
block|{
return|return
name|MaxSize
return|;
block|}
name|Length
operator|++
expr_stmt|;
block|}
return|return
name|Length
return|;
block|}
end_function

begin_comment
comment|/**   Returns the size of a Null-terminated Unicode string in bytes, including the   Null terminator.    This function returns the size of the Null-terminated Unicode string   specified by String in bytes, including the Null terminator.    If String is not aligned on a 16-bit boundary, then ASSERT().    @param  String   A pointer to a Null-terminated Unicode string.   @param  MaxSize  The maximum number of Destination Unicode                    char, including the Null terminator.    @retval 0  If String is NULL.   @retval (sizeof (CHAR16) * (MaxSize + 1))              If there is no Null terminator in the first MaxSize characters of              String.   @return The size of the Null-terminated Unicode string in bytes, including           the Null terminator.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|StrnSizeS
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|IN
name|UINTN
name|MaxSize
parameter_list|)
block|{
comment|//
comment|// If String is a null pointer, then the StrnSizeS function returns zero.
comment|//
if|if
condition|(
name|String
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//
comment|// Otherwise, the StrnSizeS function returns the size of the Null-terminated
comment|// Unicode string in bytes, including the Null terminator. If there is no
comment|// Null terminator in the first MaxSize characters of String, then StrnSizeS
comment|// returns (sizeof (CHAR16) * (MaxSize + 1)) to keep a consistent map with
comment|// the StrnLenS function.
comment|//
return|return
operator|(
name|StrnLenS
argument_list|(
name|String
argument_list|,
name|MaxSize
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|String
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Copies the string pointed to by Source (including the terminating null char)   to the array pointed to by Destination.    This function is similar as strcpy_s defined in C11.    If Destination is not aligned on a 16-bit boundary, then ASSERT().   If Source is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Unicode string.   @param  DestMax                  The maximum number of Destination Unicode                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Unicode string.    @retval RETURN_SUCCESS           String is copied.   @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumUnicodeStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrCpyS
parameter_list|(
name|OUT
name|CHAR16
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Destination
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Source
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. DestMax shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. DestMax shall be greater than StrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|StrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR16
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The StrCpyS function copies the string pointed to by Source (including the terminating
comment|// null character) into the array pointed to by Destination.
comment|//
while|while
condition|(
operator|*
name|Source
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Copies not more than Length successive char from the string pointed to by   Source to the array pointed to by Destination. If no null char is copied from   Source, then Destination[Length] is always set to null.    This function is similar as strncpy_s defined in C11.    If Length> 0 and Destination is not aligned on a 16-bit boundary, then ASSERT().   If Length> 0 and Source is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Unicode string.   @param  DestMax                  The maximum number of Destination Unicode                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Unicode string.   @param  Length                   The maximum number of Unicode characters to copy.    @retval RETURN_SUCCESS           String is copied.   @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than                                     MIN(StrLen(Source), Length).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumUnicodeStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrnCpyS
parameter_list|(
name|OUT
name|CHAR16
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Destination
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Source
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Neither DestMax nor Length shall be greater than RSIZE_MAX
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. If Length is not less than DestMax, then DestMax shall be greater than StrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|StrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>=
name|DestMax
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
if|if
condition|(
name|SourceLen
operator|>
name|Length
condition|)
block|{
name|SourceLen
operator|=
name|Length
expr_stmt|;
block|}
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR16
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The StrnCpyS function copies not more than Length successive characters (characters that
comment|// follow a null character are not copied) from the array pointed to by Source to the array
comment|// pointed to by Destination. If no null character was copied from Source, then Destination[Length] is set to a null
comment|// character.
comment|//
while|while
condition|(
operator|(
operator|*
name|Source
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SourceLen
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
name|SourceLen
operator|--
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Appends a copy of the string pointed to by Source (including the terminating   null char) to the end of the string pointed to by Destination.    This function is similar as strcat_s defined in C11.    If Destination is not aligned on a 16-bit boundary, then ASSERT().   If Source is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Unicode string.   @param  DestMax                  The maximum number of Destination Unicode                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Unicode string.    @retval RETURN_SUCCESS           String is appended.   @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than                                     StrLen(Destination).   @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT                                    greater than StrLen(Source).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumUnicodeStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrCatS
parameter_list|(
name|IN
name|OUT
name|CHAR16
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|)
block|{
name|UINTN
name|DestLen
decl_stmt|;
name|UINTN
name|CopyLen
decl_stmt|;
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Destination
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Source
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Let CopyLen denote the value DestMax - StrnLenS(Destination, DestMax) upon entry to StrCatS.
comment|//
name|DestLen
operator|=
name|StrnLenS
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|CopyLen
operator|=
name|DestMax
operator|-
name|DestLen
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. DestMax shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. CopyLen shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_BAD_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|//
comment|// 5. CopyLen shall be greater than StrnLenS(Source, CopyLen).
comment|//
name|SourceLen
operator|=
name|StrnLenS
argument_list|(
name|Source
argument_list|,
name|CopyLen
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 6. Copying shall not take place between objects that overlap.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR16
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The StrCatS function appends a copy of the string pointed to by Source (including the
comment|// terminating null character) to the end of the string pointed to by Destination. The initial character
comment|// from Source overwrites the null character at the end of Destination.
comment|//
name|Destination
operator|=
name|Destination
operator|+
name|DestLen
expr_stmt|;
while|while
condition|(
operator|*
name|Source
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Appends not more than Length successive char from the string pointed to by   Source to the end of the string pointed to by Destination. If no null char is   copied from Source, then Destination[StrLen(Destination) + Length] is always   set to null.    This function is similar as strncat_s defined in C11.    If Destination is not aligned on a 16-bit boundary, then ASSERT().   If Source is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Unicode string.   @param  DestMax                  The maximum number of Destination Unicode                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Unicode string.   @param  Length                   The maximum number of Unicode characters to copy.    @retval RETURN_SUCCESS           String is appended.   @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than                                    StrLen(Destination).   @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT                                    greater than MIN(StrLen(Source), Length).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumUnicodeStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrnCatS
parameter_list|(
name|IN
name|OUT
name|CHAR16
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINTN
name|DestLen
decl_stmt|;
name|UINTN
name|CopyLen
decl_stmt|;
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Destination
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Source
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Let CopyLen denote the value DestMax - StrnLenS(Destination, DestMax) upon entry to StrnCatS.
comment|//
name|DestLen
operator|=
name|StrnLenS
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|CopyLen
operator|=
name|DestMax
operator|-
name|DestLen
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Neither DestMax nor Length shall be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. CopyLen shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_BAD_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|//
comment|// 5. If Length is not less than CopyLen, then CopyLen shall be greater than StrnLenS(Source, CopyLen).
comment|//
name|SourceLen
operator|=
name|StrnLenS
argument_list|(
name|Source
argument_list|,
name|CopyLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>=
name|CopyLen
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 6. Copying shall not take place between objects that overlap.
comment|//
if|if
condition|(
name|SourceLen
operator|>
name|Length
condition|)
block|{
name|SourceLen
operator|=
name|Length
expr_stmt|;
block|}
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR16
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The StrnCatS function appends not more than Length successive characters (characters
comment|// that follow a null character are not copied) from the array pointed to by Source to the end of
comment|// the string pointed to by Destination. The initial character from Source overwrites the null character at
comment|// the end of Destination. If no null character was copied from Source, then Destination[DestMax-CopyLen+Length] is set to
comment|// a null character.
comment|//
name|Destination
operator|=
name|Destination
operator|+
name|DestLen
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|Source
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SourceLen
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
name|SourceLen
operator|--
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode decimal string to a value of type UINTN.    This function outputs a value of type UINTN by interpreting the contents of   the Unicode string specified by String as a decimal number. The format of the   input Unicode string String is:                    [spaces] [decimal digits].    The valid decimal digit character is in the range [0-9]. The function will   ignore the pad space, which includes spaces or tab characters, before   [decimal digits]. The running zero in the beginning of [decimal digits] will   be ignored. Then, the function stops at the first character that is a not a   valid decimal character or a Null-terminator, whichever one comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If String is not aligned in a 16-bit boundary, then ASSERT().   If PcdMaximumUnicodeStringLength is not zero, and String contains more than   PcdMaximumUnicodeStringLength Unicode characters, not including the   Null-terminator, then ASSERT().    If String has no valid decimal digits in the above format, then 0 is stored   at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINTN, then   MAX_UINTN is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   decimal digits right after the optional pad spaces, the value of String is   stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Unicode string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumUnicodeStringLength is not                                    zero, and String contains more than                                    PcdMaximumUnicodeStringLength Unicode                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINTN.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrDecimalToUintnS
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINTN
modifier|*
name|Data
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|StrnLenS
argument_list|(
name|String
argument_list|,
name|RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|L'
expr|'
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|L'
expr|\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|L'
expr|0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalIsDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINTN, then MAX_UINTN is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
operator|(
operator|(
name|MAX_UINTN
operator|-
operator|(
operator|*
name|String
operator|-
literal|L'
expr|0'
operator|)
operator|)
operator|/
literal|10
operator|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINTN
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
operator|*
name|Data
operator|*
literal|10
operator|+
operator|(
operator|*
name|String
operator|-
literal|L'
expr|0'
operator|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode decimal string to a value of type UINT64.    This function outputs a value of type UINT64 by interpreting the contents of   the Unicode string specified by String as a decimal number. The format of the   input Unicode string String is:                    [spaces] [decimal digits].    The valid decimal digit character is in the range [0-9]. The function will   ignore the pad space, which includes spaces or tab characters, before   [decimal digits]. The running zero in the beginning of [decimal digits] will   be ignored. Then, the function stops at the first character that is a not a   valid decimal character or a Null-terminator, whichever one comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If String is not aligned in a 16-bit boundary, then ASSERT().   If PcdMaximumUnicodeStringLength is not zero, and String contains more than   PcdMaximumUnicodeStringLength Unicode characters, not including the   Null-terminator, then ASSERT().    If String has no valid decimal digits in the above format, then 0 is stored   at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINT64, then   MAX_UINT64 is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   decimal digits right after the optional pad spaces, the value of String is   stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Unicode string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumUnicodeStringLength is not                                    zero, and String contains more than                                    PcdMaximumUnicodeStringLength Unicode                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINT64.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrDecimalToUint64S
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|Data
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|StrnLenS
argument_list|(
name|String
argument_list|,
name|RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|L'
expr|'
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|L'
expr|\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|L'
expr|0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalIsDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINT64, then MAX_UINT64 is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
name|DivU64x32
argument_list|(
name|MAX_UINT64
operator|-
operator|(
operator|*
name|String
operator|-
literal|L'
expr|0'
operator|)
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINT64
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
name|MultU64x32
argument_list|(
operator|*
name|Data
argument_list|,
literal|10
argument_list|)
operator|+
operator|(
operator|*
name|String
operator|-
literal|L'
expr|0'
operator|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode hexadecimal string to a value of type   UINTN.    This function outputs a value of type UINTN by interpreting the contents of   the Unicode string specified by String as a hexadecimal number. The format of   the input Unicode string String is:                    [spaces][zeros][x][hexadecimal digits].    The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].   The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix.   If "x" appears in the input string, it must be prefixed with at least one 0.   The function will ignore the pad space, which includes spaces or tab   characters, before [zeros], [x] or [hexadecimal digit]. The running zero   before [x] or [hexadecimal digit] will be ignored. Then, the decoding starts   after [x] or the first valid hexadecimal digit. Then, the function stops at   the first character that is a not a valid hexadecimal character or NULL,   whichever one comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If String is not aligned in a 16-bit boundary, then ASSERT().   If PcdMaximumUnicodeStringLength is not zero, and String contains more than   PcdMaximumUnicodeStringLength Unicode characters, not including the   Null-terminator, then ASSERT().    If String has no valid hexadecimal digits in the above format, then 0 is   stored at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINTN, then   MAX_UINTN is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   hexadecimal digits right after the optional pad spaces, the value of String   is stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Unicode string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumUnicodeStringLength is not                                    zero, and String contains more than                                    PcdMaximumUnicodeStringLength Unicode                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINTN.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrHexToUintnS
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINTN
modifier|*
name|Data
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|StrnLenS
argument_list|(
name|String
argument_list|,
name|RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|L'
expr|'
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|L'
expr|\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|L'
expr|0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|InternalCharToUpper
argument_list|(
operator|*
name|String
argument_list|)
operator|==
literal|L'
expr|X'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|String
operator|-
literal|1
operator|)
operator|!=
literal|L'
expr|0'
condition|)
block|{
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
comment|//
comment|// Skip the 'X'
comment|//
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINTN, then MAX_UINTN is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
operator|(
operator|(
name|MAX_UINTN
operator|-
name|InternalHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
operator|)
operator|>>
literal|4
operator|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINTN
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
operator|(
operator|*
name|Data
operator|<<
literal|4
operator|)
operator|+
name|InternalHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode hexadecimal string to a value of type   UINT64.    This function outputs a value of type UINT64 by interpreting the contents of   the Unicode string specified by String as a hexadecimal number. The format of   the input Unicode string String is:                    [spaces][zeros][x][hexadecimal digits].    The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].   The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix.   If "x" appears in the input string, it must be prefixed with at least one 0.   The function will ignore the pad space, which includes spaces or tab   characters, before [zeros], [x] or [hexadecimal digit]. The running zero   before [x] or [hexadecimal digit] will be ignored. Then, the decoding starts   after [x] or the first valid hexadecimal digit. Then, the function stops at   the first character that is a not a valid hexadecimal character or NULL,   whichever one comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If String is not aligned in a 16-bit boundary, then ASSERT().   If PcdMaximumUnicodeStringLength is not zero, and String contains more than   PcdMaximumUnicodeStringLength Unicode characters, not including the   Null-terminator, then ASSERT().    If String has no valid hexadecimal digits in the above format, then 0 is   stored at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINT64, then   MAX_UINT64 is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   hexadecimal digits right after the optional pad spaces, the value of String   is stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Unicode string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumUnicodeStringLength is not                                    zero, and String contains more than                                    PcdMaximumUnicodeStringLength Unicode                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINT64.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrHexToUint64S
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|Data
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|StrnLenS
argument_list|(
name|String
argument_list|,
name|RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|L'
expr|'
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|L'
expr|\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|L'
expr|0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|InternalCharToUpper
argument_list|(
operator|*
name|String
argument_list|)
operator|==
literal|L'
expr|X'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|String
operator|-
literal|1
operator|)
operator|!=
literal|L'
expr|0'
condition|)
block|{
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
comment|//
comment|// Skip the 'X'
comment|//
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINT64, then MAX_UINT64 is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
name|RShiftU64
argument_list|(
name|MAX_UINT64
operator|-
name|InternalHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
argument_list|,
literal|4
argument_list|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINT64
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
name|LShiftU64
argument_list|(
operator|*
name|Data
argument_list|,
literal|4
argument_list|)
operator|+
name|InternalHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode string to IPv6 address and prefix length.    This function outputs a value of type IPv6_ADDRESS and may output a value   of type UINT8 by interpreting the contents of the Unicode string specified   by String. The format of the input Unicode string String is as follows:                    X:X:X:X:X:X:X:X[/P]    X contains one to four hexadecimal digit characters in the range [0-9], [a-f] and   [A-F]. X is converted to a value of type UINT16, whose low byte is stored in low   memory address and high byte is stored in high memory address. P contains decimal   digit characters in the range [0-9]. The running zero in the beginning of P will   be ignored. /P is optional.    When /P is not in the String, the function stops at the first character that is   not a valid hexadecimal digit character after eight X's are converted.    When /P is in the String, the function stops at the first character that is not   a valid decimal digit character after P is converted.    "::" can be used to compress one or more groups of X when X contains only 0.   The "::" can only appear once in the String.    If String is NULL, then ASSERT().    If Address is NULL, then ASSERT().    If String is not aligned in a 16-bit boundary, then ASSERT().    If PcdMaximumUnicodeStringLength is not zero, and String contains more than   PcdMaximumUnicodeStringLength Unicode characters, not including the   Null-terminator, then ASSERT().    If EndPointer is not NULL and Address is translated from String, a pointer   to the character that stopped the scan is stored at the location pointed to   by EndPointer.    @param  String                   Pointer to a Null-terminated Unicode string.   @param  EndPointer               Pointer to character that stops scan.   @param  Address                  Pointer to the converted IPv6 address.   @param  PrefixLength             Pointer to the converted IPv6 address prefix                                    length. MAX_UINT8 is returned when /P is                                    not in the String.    @retval RETURN_SUCCESS           Address is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.   @retval RETURN_UNSUPPORTED       If X contains more than four hexadecimal                                     digit characters.                                    If String contains "::" and number of X                                     is not less than 8.                                    If P starts with character that is not a                                     valid decimal digit character.                                    If the decimal number converted from P                                     exceeds 128.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrToIpv6Address
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|IPv6_ADDRESS
modifier|*
name|Address
parameter_list|,
name|OUT
name|UINT8
modifier|*
name|PrefixLength
name|OPTIONAL
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|UINTN
name|AddressIndex
decl_stmt|;
name|UINTN
name|Uintn
decl_stmt|;
name|IPv6_ADDRESS
name|LocalAddress
decl_stmt|;
name|UINT8
name|LocalPrefixLength
decl_stmt|;
name|CONST
name|CHAR16
modifier|*
name|Pointer
decl_stmt|;
name|CHAR16
modifier|*
name|End
decl_stmt|;
name|UINTN
name|CompressStart
decl_stmt|;
name|BOOLEAN
name|ExpectPrefix
decl_stmt|;
name|LocalPrefixLength
operator|=
name|MAX_UINT8
expr_stmt|;
name|CompressStart
operator|=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
expr_stmt|;
name|ExpectPrefix
operator|=
name|FALSE
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. None of String or Guid shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Address
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
for|for
control|(
name|Pointer
operator|=
name|String
operator|,
name|AddressIndex
operator|=
literal|0
init|;
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|+
literal|1
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|InternalIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|Pointer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|!=
literal|L'
expr|:'
condition|)
block|{
comment|//
comment|// ":" or "/" should be followed by digit characters.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Meet second ":" after previous ":" or "/"
comment|// or meet first ":" in the beginning of String.
comment|//
if|if
condition|(
name|ExpectPrefix
condition|)
block|{
comment|//
comment|// ":" shall not be after "/"
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|CompressStart
operator|!=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|||
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
comment|//
comment|// "::" can only appear once.
comment|// "::" can only appear when address is not full length.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
else|else
block|{
comment|//
comment|// Remember the start of zero compressing.
comment|//
name|CompressStart
operator|=
name|AddressIndex
expr_stmt|;
name|Pointer
operator|++
expr_stmt|;
if|if
condition|(
name|CompressStart
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|!=
literal|L'
expr|:'
condition|)
block|{
comment|//
comment|// Single ":" shall not be in the beginning of String.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|Pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|InternalIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|Pointer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|L'
expr|/'
condition|)
block|{
comment|//
comment|// Might be optional "/P" after "::".
comment|//
if|if
condition|(
name|CompressStart
operator|!=
name|AddressIndex
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ExpectPrefix
condition|)
block|{
comment|//
comment|// Get X.
comment|//
name|Status
operator|=
name|StrHexToUintnS
argument_list|(
name|Pointer
argument_list|,
operator|&
name|End
argument_list|,
operator|&
name|Uintn
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|End
operator|-
name|Pointer
operator|>
literal|4
condition|)
block|{
comment|//
comment|// Number of hexadecimal digit characters is no more than 4.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|Pointer
operator|=
name|End
expr_stmt|;
comment|//
comment|// Uintn won't exceed MAX_UINT16 if number of hexadecimal digit characters is no more than 4.
comment|//
name|ASSERT
argument_list|(
name|AddressIndex
operator|+
literal|1
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
argument_list|)
expr_stmt|;
name|LocalAddress
operator|.
name|Addr
index|[
name|AddressIndex
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
name|UINT16
operator|)
name|Uintn
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|LocalAddress
operator|.
name|Addr
index|[
name|AddressIndex
operator|+
literal|1
index|]
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
name|AddressIndex
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Get P, then exit the loop.
comment|//
name|Status
operator|=
name|StrDecimalToUintnS
argument_list|(
name|Pointer
argument_list|,
operator|&
name|End
argument_list|,
operator|&
name|Uintn
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|End
operator|==
name|Pointer
operator|||
name|Uintn
operator|>
literal|128
condition|)
block|{
comment|//
comment|// Prefix length should not exceed 128.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|LocalPrefixLength
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
name|Pointer
operator|=
name|End
expr_stmt|;
break|break;
block|}
block|}
comment|//
comment|// Skip ':' or "/"
comment|//
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|L'
expr|/'
condition|)
block|{
name|ExpectPrefix
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|L'
expr|:'
condition|)
block|{
if|if
condition|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
comment|//
comment|// Meet additional ":" after all 8 16-bit address
comment|//
break|break;
block|}
block|}
else|else
block|{
comment|//
comment|// Meet other character that is not "/" or ":" after all 8 16-bit address
comment|//
break|break;
block|}
name|Pointer
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|&&
name|CompressStart
operator|!=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|)
operator|||
operator|(
name|AddressIndex
operator|!=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|&&
name|CompressStart
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|)
condition|)
block|{
comment|//
comment|// Full length of address shall not have compressing zeros.
comment|// Non-full length of address shall have compressing zeros.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|CopyMem
argument_list|(
operator|&
name|Address
operator|->
name|Addr
index|[
literal|0
index|]
argument_list|,
operator|&
name|LocalAddress
operator|.
name|Addr
index|[
literal|0
index|]
argument_list|,
name|CompressStart
argument_list|)
expr_stmt|;
name|ZeroMem
argument_list|(
operator|&
name|Address
operator|->
name|Addr
index|[
name|CompressStart
index|]
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|-
name|AddressIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|AddressIndex
operator|>
name|CompressStart
condition|)
block|{
name|CopyMem
argument_list|(
operator|&
name|Address
operator|->
name|Addr
index|[
name|CompressStart
operator|+
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|-
name|AddressIndex
index|]
argument_list|,
operator|&
name|LocalAddress
operator|.
name|Addr
index|[
name|CompressStart
index|]
argument_list|,
name|AddressIndex
operator|-
name|CompressStart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PrefixLength
operator|!=
name|NULL
condition|)
block|{
operator|*
name|PrefixLength
operator|=
name|LocalPrefixLength
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|Pointer
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode string to IPv4 address and prefix length.    This function outputs a value of type IPv4_ADDRESS and may output a value   of type UINT8 by interpreting the contents of the Unicode string specified   by String. The format of the input Unicode string String is as follows:                    D.D.D.D[/P]    D and P are decimal digit characters in the range [0-9]. The running zero in   the beginning of D and P will be ignored. /P is optional.    When /P is not in the String, the function stops at the first character that is   not a valid decimal digit character after four D's are converted.    When /P is in the String, the function stops at the first character that is not   a valid decimal digit character after P is converted.    If String is NULL, then ASSERT().    If Address is NULL, then ASSERT().    If String is not aligned in a 16-bit boundary, then ASSERT().    If PcdMaximumUnicodeStringLength is not zero, and String contains more than   PcdMaximumUnicodeStringLength Unicode characters, not including the   Null-terminator, then ASSERT().    If EndPointer is not NULL and Address is translated from String, a pointer   to the character that stopped the scan is stored at the location pointed to   by EndPointer.    @param  String                   Pointer to a Null-terminated Unicode string.   @param  EndPointer               Pointer to character that stops scan.   @param  Address                  Pointer to the converted IPv4 address.   @param  PrefixLength             Pointer to the converted IPv4 address prefix                                    length. MAX_UINT8 is returned when /P is                                    not in the String.    @retval RETURN_SUCCESS           Address is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.   @retval RETURN_UNSUPPORTED       If String is not in the correct format.                                    If any decimal number converted from D                                     exceeds 255.                                    If the decimal number converted from P                                     exceeds 32.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrToIpv4Address
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|IPv4_ADDRESS
modifier|*
name|Address
parameter_list|,
name|OUT
name|UINT8
modifier|*
name|PrefixLength
name|OPTIONAL
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|UINTN
name|AddressIndex
decl_stmt|;
name|UINTN
name|Uintn
decl_stmt|;
name|IPv4_ADDRESS
name|LocalAddress
decl_stmt|;
name|UINT8
name|LocalPrefixLength
decl_stmt|;
name|CHAR16
modifier|*
name|Pointer
decl_stmt|;
name|LocalPrefixLength
operator|=
name|MAX_UINT8
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. None of String or Guid shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Address
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
for|for
control|(
name|Pointer
operator|=
operator|(
name|CHAR16
operator|*
operator|)
name|String
operator|,
name|AddressIndex
operator|=
literal|0
init|;
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|+
literal|1
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|InternalIsDecimalDigitCharacter
argument_list|(
operator|*
name|Pointer
argument_list|)
condition|)
block|{
comment|//
comment|// D or P contains invalid characters.
comment|//
break|break;
block|}
comment|//
comment|// Get D or P.
comment|//
name|Status
operator|=
name|StrDecimalToUintnS
argument_list|(
operator|(
name|CONST
name|CHAR16
operator|*
operator|)
name|Pointer
argument_list|,
operator|&
name|Pointer
argument_list|,
operator|&
name|Uintn
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
comment|//
comment|// It's P.
comment|//
if|if
condition|(
name|Uintn
operator|>
literal|32
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|LocalPrefixLength
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// It's D.
comment|//
if|if
condition|(
name|Uintn
operator|>
name|MAX_UINT8
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|LocalAddress
operator|.
name|Addr
index|[
name|AddressIndex
index|]
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
name|AddressIndex
operator|++
expr_stmt|;
block|}
comment|//
comment|// Check the '.' or '/', depending on the AddressIndex.
comment|//
if|if
condition|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|L'
expr|/'
condition|)
block|{
comment|//
comment|// '/P' is in the String.
comment|// Skip "/" and get P in next loop.
comment|//
name|Pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// '/P' is not in the String.
comment|//
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|L'
expr|.'
condition|)
block|{
comment|//
comment|// D should be followed by '.'
comment|//
name|Pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
block|}
block|}
if|if
condition|(
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|CopyMem
argument_list|(
name|Address
argument_list|,
operator|&
name|LocalAddress
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|Address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PrefixLength
operator|!=
name|NULL
condition|)
block|{
operator|*
name|PrefixLength
operator|=
name|LocalPrefixLength
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
name|Pointer
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode GUID string to a value of type   EFI_GUID.    This function outputs a GUID value by interpreting the contents of   the Unicode string specified by String. The format of the input   Unicode string String consists of 36 characters, as follows:                    aabbccdd-eeff-gghh-iijj-kkllmmnnoopp    The pairs aa - pp are two characters in the range [0-9], [a-f] and   [A-F], with each pair representing a single byte hexadecimal value.    The mapping between String and the EFI_GUID structure is as follows:                   aa          Data1[24:31]                   bb          Data1[16:23]                   cc          Data1[8:15]                   dd          Data1[0:7]                   ee          Data2[8:15]                   ff          Data2[0:7]                   gg          Data3[8:15]                   hh          Data3[0:7]                   ii          Data4[0:7]                   jj          Data4[8:15]                   kk          Data4[16:23]                   ll          Data4[24:31]                   mm          Data4[32:39]                   nn          Data4[40:47]                   oo          Data4[48:55]                   pp          Data4[56:63]    If String is NULL, then ASSERT().   If Guid is NULL, then ASSERT().   If String is not aligned in a 16-bit boundary, then ASSERT().    @param  String                   Pointer to a Null-terminated Unicode string.   @param  Guid                     Pointer to the converted GUID.    @retval RETURN_SUCCESS           Guid is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.   @retval RETURN_UNSUPPORTED       If String is not as the above format.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrToGuid
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|OUT
name|GUID
modifier|*
name|Guid
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|GUID
name|LocalGuid
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. None of String or Guid shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Guid
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// Get aabbccdd in big-endian.
comment|//
name|Status
operator|=
name|StrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
operator|&
name|LocalGuid
operator|.
name|Data1
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
index|]
operator|!=
literal|L'
expr|-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert big-endian to little-endian.
comment|//
name|LocalGuid
operator|.
name|Data1
operator|=
name|SwapBytes32
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
expr_stmt|;
name|String
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get eeff in big-endian.
comment|//
name|Status
operator|=
name|StrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
operator|&
name|LocalGuid
operator|.
name|Data2
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
index|]
operator|!=
literal|L'
expr|-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert big-endian to little-endian.
comment|//
name|LocalGuid
operator|.
name|Data2
operator|=
name|SwapBytes16
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
expr_stmt|;
name|String
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get gghh in big-endian.
comment|//
name|Status
operator|=
name|StrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
operator|&
name|LocalGuid
operator|.
name|Data3
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
index|]
operator|!=
literal|L'
expr|-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert big-endian to little-endian.
comment|//
name|LocalGuid
operator|.
name|Data3
operator|=
name|SwapBytes16
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
expr_stmt|;
name|String
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get iijj.
comment|//
name|Status
operator|=
name|StrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
literal|2
argument_list|,
operator|&
name|LocalGuid
operator|.
name|Data4
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
literal|2
index|]
operator|!=
literal|L'
expr|-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|String
operator|+=
literal|2
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get kkllmmnnoopp.
comment|//
name|Status
operator|=
name|StrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
literal|6
argument_list|,
operator|&
name|LocalGuid
operator|.
name|Data4
index|[
literal|2
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|CopyGuid
argument_list|(
name|Guid
argument_list|,
operator|&
name|LocalGuid
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode hexadecimal string to a byte array.    This function outputs a byte array by interpreting the contents of   the Unicode string specified by String in hexadecimal format. The format of   the input Unicode string String is:                    [XX]*    X is a hexadecimal digit character in the range [0-9], [a-f] and [A-F].   The function decodes every two hexadecimal digit characters as one byte. The   decoding stops after Length of characters and outputs Buffer containing   (Length / 2) bytes.    If String is not aligned in a 16-bit boundary, then ASSERT().    If String is NULL, then ASSERT().    If Buffer is NULL, then ASSERT().    If Length is not multiple of 2, then ASSERT().    If PcdMaximumUnicodeStringLength is not zero and Length is greater than   PcdMaximumUnicodeStringLength, then ASSERT().    If MaxBufferSize is less than (Length / 2), then ASSERT().    @param  String                   Pointer to a Null-terminated Unicode string.   @param  Length                   The number of Unicode characters to decode.   @param  Buffer                   Pointer to the converted bytes array.   @param  MaxBufferSize            The maximum size of Buffer.    @retval RETURN_SUCCESS           Buffer is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If Length is not multiple of 2.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and Length is greater than                                     PcdMaximumUnicodeStringLength.   @retval RETURN_UNSUPPORTED       If Length of characters from String contain                                     a character that is not valid hexadecimal                                     digit characters, or a Null-terminator.   @retval RETURN_BUFFER_TOO_SMALL  If MaxBufferSize is less than (Length / 2). **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|StrHexToBytes
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|,
name|OUT
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|MaxBufferSize
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|String
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. None of String or Buffer shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Buffer
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Length shall not be greater than RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. Length shall not be odd.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
operator|(
name|Length
operator|&
name|BIT0
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. MaxBufferSize shall equal to or greater than Length / 2.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|MaxBufferSize
operator|>=
name|Length
operator|/
literal|2
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 5. String shall not contains invalid hexadecimal digits.
comment|//
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Length
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|InternalIsHexaDecimalDigitCharacter
argument_list|(
name|String
index|[
name|Index
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|Index
operator|!=
name|Length
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert the hex string to bytes.
comment|//
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Length
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// For even characters, write the upper nibble for each buffer byte,
comment|// and for even characters, the lower nibble.
comment|//
if|if
condition|(
operator|(
name|Index
operator|&
name|BIT0
operator|)
operator|==
literal|0
condition|)
block|{
name|Buffer
index|[
name|Index
operator|/
literal|2
index|]
operator|=
operator|(
name|UINT8
operator|)
name|InternalHexCharToUintn
argument_list|(
name|String
index|[
name|Index
index|]
argument_list|)
operator|<<
literal|4
expr_stmt|;
block|}
else|else
block|{
name|Buffer
index|[
name|Index
operator|/
literal|2
index|]
operator||=
operator|(
name|UINT8
operator|)
name|InternalHexCharToUintn
argument_list|(
name|String
index|[
name|Index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Returns the length of a Null-terminated Ascii string.    This function is similar as strlen_s defined in C11.    @param  String   A pointer to a Null-terminated Ascii string.   @param  MaxSize  The maximum number of Destination Ascii                    char, including terminating null char.    @retval 0        If String is NULL.   @retval MaxSize  If there is no null character in the first MaxSize characters of String.   @return The number of characters that percede the terminating null character.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|AsciiStrnLenS
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|IN
name|UINTN
name|MaxSize
parameter_list|)
block|{
name|UINTN
name|Length
decl_stmt|;
comment|//
comment|// If String is a null pointer or MaxSize is 0, then the AsciiStrnLenS function returns zero.
comment|//
if|if
condition|(
operator|(
name|String
operator|==
name|NULL
operator|)
operator|||
operator|(
name|MaxSize
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//
comment|// Otherwise, the AsciiStrnLenS function returns the number of characters that precede the
comment|// terminating null character. If there is no null character in the first MaxSize characters of
comment|// String then AsciiStrnLenS returns MaxSize. At most the first MaxSize characters of String shall
comment|// be accessed by AsciiStrnLenS.
comment|//
name|Length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|String
index|[
name|Length
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Length
operator|>=
name|MaxSize
operator|-
literal|1
condition|)
block|{
return|return
name|MaxSize
return|;
block|}
name|Length
operator|++
expr_stmt|;
block|}
return|return
name|Length
return|;
block|}
end_function

begin_comment
comment|/**   Returns the size of a Null-terminated Ascii string in bytes, including the   Null terminator.    This function returns the size of the Null-terminated Ascii string specified   by String in bytes, including the Null terminator.    @param  String   A pointer to a Null-terminated Ascii string.   @param  MaxSize  The maximum number of Destination Ascii                    char, including the Null terminator.    @retval 0  If String is NULL.   @retval (sizeof (CHAR8) * (MaxSize + 1))              If there is no Null terminator in the first MaxSize characters of              String.   @return The size of the Null-terminated Ascii string in bytes, including the           Null terminator.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|AsciiStrnSizeS
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|IN
name|UINTN
name|MaxSize
parameter_list|)
block|{
comment|//
comment|// If String is a null pointer, then the AsciiStrnSizeS function returns
comment|// zero.
comment|//
if|if
condition|(
name|String
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//
comment|// Otherwise, the AsciiStrnSizeS function returns the size of the
comment|// Null-terminated Ascii string in bytes, including the Null terminator. If
comment|// there is no Null terminator in the first MaxSize characters of String,
comment|// then AsciiStrnSizeS returns (sizeof (CHAR8) * (MaxSize + 1)) to keep a
comment|// consistent map with the AsciiStrnLenS function.
comment|//
return|return
operator|(
name|AsciiStrnLenS
argument_list|(
name|String
argument_list|,
name|MaxSize
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|String
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Copies the string pointed to by Source (including the terminating null char)   to the array pointed to by Destination.    This function is similar as strcpy_s defined in C11.    If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Ascii string.   @param  DestMax                  The maximum number of Destination Ascii                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Ascii string.    @retval RETURN_SUCCESS           String is copied.   @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumAsciiStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrCpyS
parameter_list|(
name|OUT
name|CHAR8
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|Source
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. DestMax shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. DestMax shall be greater than AsciiStrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoAsciiStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR8
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The AsciiStrCpyS function copies the string pointed to by Source (including the terminating
comment|// null character) into the array pointed to by Destination.
comment|//
while|while
condition|(
operator|*
name|Source
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Copies not more than Length successive char from the string pointed to by   Source to the array pointed to by Destination. If no null char is copied from   Source, then Destination[Length] is always set to null.    This function is similar as strncpy_s defined in C11.    If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Ascii string.   @param  DestMax                  The maximum number of Destination Ascii                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Ascii string.   @param  Length                   The maximum number of Ascii characters to copy.    @retval RETURN_SUCCESS           String is copied.   @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than                                     MIN(StrLen(Source), Length).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumAsciiStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrnCpyS
parameter_list|(
name|OUT
name|CHAR8
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Neither DestMax nor Length shall be greater than ASCII_RSIZE_MAX
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. If Length is not less than DestMax, then DestMax shall be greater than AsciiStrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>=
name|DestMax
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
if|if
condition|(
name|SourceLen
operator|>
name|Length
condition|)
block|{
name|SourceLen
operator|=
name|Length
expr_stmt|;
block|}
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoAsciiStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR8
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The AsciiStrnCpyS function copies not more than Length successive characters (characters that
comment|// follow a null character are not copied) from the array pointed to by Source to the array
comment|// pointed to by Destination. If no null character was copied from Source, then Destination[Length] is set to a null
comment|// character.
comment|//
while|while
condition|(
operator|(
operator|*
name|Source
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SourceLen
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
name|SourceLen
operator|--
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Appends a copy of the string pointed to by Source (including the terminating   null char) to the end of the string pointed to by Destination.    This function is similar as strcat_s defined in C11.    If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Ascii string.   @param  DestMax                  The maximum number of Destination Ascii                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Ascii string.    @retval RETURN_SUCCESS           String is appended.   @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than                                     StrLen(Destination).   @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT                                    greater than StrLen(Source).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumAsciiStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrCatS
parameter_list|(
name|IN
name|OUT
name|CHAR8
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|Source
parameter_list|)
block|{
name|UINTN
name|DestLen
decl_stmt|;
name|UINTN
name|CopyLen
decl_stmt|;
name|UINTN
name|SourceLen
decl_stmt|;
comment|//
comment|// Let CopyLen denote the value DestMax - AsciiStrnLenS(Destination, DestMax) upon entry to AsciiStrCatS.
comment|//
name|DestLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|CopyLen
operator|=
name|DestMax
operator|-
name|DestLen
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. DestMax shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. CopyLen shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_BAD_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|//
comment|// 5. CopyLen shall be greater than AsciiStrnLenS(Source, CopyLen).
comment|//
name|SourceLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Source
argument_list|,
name|CopyLen
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 6. Copying shall not take place between objects that overlap.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoAsciiStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR8
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The AsciiStrCatS function appends a copy of the string pointed to by Source (including the
comment|// terminating null character) to the end of the string pointed to by Destination. The initial character
comment|// from Source overwrites the null character at the end of Destination.
comment|//
name|Destination
operator|=
name|Destination
operator|+
name|DestLen
expr_stmt|;
while|while
condition|(
operator|*
name|Source
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Appends not more than Length successive char from the string pointed to by   Source to the end of the string pointed to by Destination. If no null char is   copied from Source, then Destination[StrLen(Destination) + Length] is always   set to null.    This function is similar as strncat_s defined in C11.    If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Destination              A pointer to a Null-terminated Ascii string.   @param  DestMax                  The maximum number of Destination Ascii                                    char, including terminating null char.   @param  Source                   A pointer to a Null-terminated Ascii string.   @param  Length                   The maximum number of Ascii characters to copy.    @retval RETURN_SUCCESS           String is appended.   @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than                                    StrLen(Destination).   @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT                                    greater than MIN(StrLen(Source), Length).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                     and DestMax is greater than                                      PcdMaximumAsciiStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrnCatS
parameter_list|(
name|IN
name|OUT
name|CHAR8
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|)
block|{
name|UINTN
name|DestLen
decl_stmt|;
name|UINTN
name|CopyLen
decl_stmt|;
name|UINTN
name|SourceLen
decl_stmt|;
comment|//
comment|// Let CopyLen denote the value DestMax - AsciiStrnLenS(Destination, DestMax) upon entry to AsciiStrnCatS.
comment|//
name|DestLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|CopyLen
operator|=
name|DestMax
operator|-
name|DestLen
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Neither DestMax nor Length shall be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. CopyLen shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_BAD_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|//
comment|// 5. If Length is not less than CopyLen, then CopyLen shall be greater than AsciiStrnLenS(Source, CopyLen).
comment|//
name|SourceLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Source
argument_list|,
name|CopyLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>=
name|CopyLen
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|CopyLen
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 6. Copying shall not take place between objects that overlap.
comment|//
if|if
condition|(
name|SourceLen
operator|>
name|Length
condition|)
block|{
name|SourceLen
operator|=
name|Length
expr_stmt|;
block|}
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
name|InternalSafeStringNoAsciiStrOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|CHAR8
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// The AsciiStrnCatS function appends not more than Length successive characters (characters
comment|// that follow a null character are not copied) from the array pointed to by Source to the end of
comment|// the string pointed to by Destination. The initial character from Source overwrites the null character at
comment|// the end of Destination. If no null character was copied from Source, then Destination[DestMax-CopyLen+Length] is set to
comment|// a null character.
comment|//
name|Destination
operator|=
name|Destination
operator|+
name|DestLen
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|Source
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SourceLen
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
name|SourceLen
operator|--
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Ascii decimal string to a value of type UINTN.    This function outputs a value of type UINTN by interpreting the contents of   the Ascii string specified by String as a decimal number. The format of the   input Ascii string String is:                    [spaces] [decimal digits].    The valid decimal digit character is in the range [0-9]. The function will   ignore the pad space, which includes spaces or tab characters, before   [decimal digits]. The running zero in the beginning of [decimal digits] will   be ignored. Then, the function stops at the first character that is a not a   valid decimal character or a Null-terminator, whichever one comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If PcdMaximumAsciiStringLength is not zero, and String contains more than   PcdMaximumAsciiStringLength Ascii characters, not including the   Null-terminator, then ASSERT().    If String has no valid decimal digits in the above format, then 0 is stored   at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINTN, then   MAX_UINTN is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   decimal digits right after the optional pad spaces, the value of String is   stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Ascii string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                    and String contains more than                                    PcdMaximumAsciiStringLength Ascii                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINTN.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrDecimalToUintnS
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR8
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINTN
modifier|*
name|Data
parameter_list|)
block|{
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|AsciiStrnLenS
argument_list|(
name|String
argument_list|,
name|ASCII_RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|'0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalAsciiIsDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINTN, then MAX_UINTN is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
operator|(
operator|(
name|MAX_UINTN
operator|-
operator|(
operator|*
name|String
operator|-
literal|'0'
operator|)
operator|)
operator|/
literal|10
operator|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINTN
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
operator|*
name|Data
operator|*
literal|10
operator|+
operator|(
operator|*
name|String
operator|-
literal|'0'
operator|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Ascii decimal string to a value of type UINT64.    This function outputs a value of type UINT64 by interpreting the contents of   the Ascii string specified by String as a decimal number. The format of the   input Ascii string String is:                    [spaces] [decimal digits].    The valid decimal digit character is in the range [0-9]. The function will   ignore the pad space, which includes spaces or tab characters, before   [decimal digits]. The running zero in the beginning of [decimal digits] will   be ignored. Then, the function stops at the first character that is a not a   valid decimal character or a Null-terminator, whichever one comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If PcdMaximumAsciiStringLength is not zero, and String contains more than   PcdMaximumAsciiStringLength Ascii characters, not including the   Null-terminator, then ASSERT().    If String has no valid decimal digits in the above format, then 0 is stored   at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINT64, then   MAX_UINT64 is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   decimal digits right after the optional pad spaces, the value of String is   stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Ascii string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                    and String contains more than                                    PcdMaximumAsciiStringLength Ascii                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINT64.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrDecimalToUint64S
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR8
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|Data
parameter_list|)
block|{
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|AsciiStrnLenS
argument_list|(
name|String
argument_list|,
name|ASCII_RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|'0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalAsciiIsDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINT64, then MAX_UINT64 is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
name|DivU64x32
argument_list|(
name|MAX_UINT64
operator|-
operator|(
operator|*
name|String
operator|-
literal|'0'
operator|)
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINT64
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
name|MultU64x32
argument_list|(
operator|*
name|Data
argument_list|,
literal|10
argument_list|)
operator|+
operator|(
operator|*
name|String
operator|-
literal|'0'
operator|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Ascii hexadecimal string to a value of type UINTN.    This function outputs a value of type UINTN by interpreting the contents of   the Ascii string specified by String as a hexadecimal number. The format of   the input Ascii string String is:                    [spaces][zeros][x][hexadecimal digits].    The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].   The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix. If   "x" appears in the input string, it must be prefixed with at least one 0. The   function will ignore the pad space, which includes spaces or tab characters,   before [zeros], [x] or [hexadecimal digits]. The running zero before [x] or   [hexadecimal digits] will be ignored. Then, the decoding starts after [x] or   the first valid hexadecimal digit. Then, the function stops at the first   character that is a not a valid hexadecimal character or Null-terminator,   whichever on comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If PcdMaximumAsciiStringLength is not zero, and String contains more than   PcdMaximumAsciiStringLength Ascii characters, not including the   Null-terminator, then ASSERT().    If String has no valid hexadecimal digits in the above format, then 0 is   stored at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINTN, then   MAX_UINTN is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   hexadecimal digits right after the optional pad spaces, the value of String   is stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Ascii string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                    and String contains more than                                    PcdMaximumAsciiStringLength Ascii                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINTN.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrHexToUintnS
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR8
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINTN
modifier|*
name|Data
parameter_list|)
block|{
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|AsciiStrnLenS
argument_list|(
name|String
argument_list|,
name|ASCII_RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|'0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|InternalBaseLibAsciiToUpper
argument_list|(
operator|*
name|String
argument_list|)
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|String
operator|-
literal|1
operator|)
operator|!=
literal|'0'
condition|)
block|{
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
comment|//
comment|// Skip the 'X'
comment|//
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalAsciiIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINTN, then MAX_UINTN is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
operator|(
operator|(
name|MAX_UINTN
operator|-
name|InternalAsciiHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
operator|)
operator|>>
literal|4
operator|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINTN
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
operator|(
operator|*
name|Data
operator|<<
literal|4
operator|)
operator|+
name|InternalAsciiHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Ascii hexadecimal string to a value of type UINT64.    This function outputs a value of type UINT64 by interpreting the contents of   the Ascii string specified by String as a hexadecimal number. The format of   the input Ascii string String is:                    [spaces][zeros][x][hexadecimal digits].    The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].   The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix. If   "x" appears in the input string, it must be prefixed with at least one 0. The   function will ignore the pad space, which includes spaces or tab characters,   before [zeros], [x] or [hexadecimal digits]. The running zero before [x] or   [hexadecimal digits] will be ignored. Then, the decoding starts after [x] or   the first valid hexadecimal digit. Then, the function stops at the first   character that is a not a valid hexadecimal character or Null-terminator,   whichever on comes first.    If String is NULL, then ASSERT().   If Data is NULL, then ASSERT().   If PcdMaximumAsciiStringLength is not zero, and String contains more than   PcdMaximumAsciiStringLength Ascii characters, not including the   Null-terminator, then ASSERT().    If String has no valid hexadecimal digits in the above format, then 0 is   stored at the location pointed to by Data.   If the number represented by String exceeds the range defined by UINT64, then   MAX_UINT64 is stored at the location pointed to by Data.    If EndPointer is not NULL, a pointer to the character that stopped the scan   is stored at the location pointed to by EndPointer. If String has no valid   hexadecimal digits right after the optional pad spaces, the value of String   is stored at the location pointed to by EndPointer.    @param  String                   Pointer to a Null-terminated Ascii string.   @param  EndPointer               Pointer to character that stops scan.   @param  Data                     Pointer to the converted value.    @retval RETURN_SUCCESS           Value is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                    and String contains more than                                    PcdMaximumAsciiStringLength Ascii                                    characters, not including the                                    Null-terminator.   @retval RETURN_UNSUPPORTED       If the number represented by String exceeds                                    the range defined by UINT64.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrHexToUint64S
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR8
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|Data
parameter_list|)
block|{
comment|//
comment|// 1. Neither String nor Data shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Data
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. The length of String shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|AsciiStrnLenS
argument_list|(
name|String
argument_list|,
name|ASCII_RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
comment|//
comment|// Ignore the pad spaces (space or tab)
comment|//
while|while
condition|(
operator|(
operator|*
name|String
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|String
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
comment|//
comment|// Ignore leading Zeros after the spaces
comment|//
while|while
condition|(
operator|*
name|String
operator|==
literal|'0'
condition|)
block|{
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|InternalBaseLibAsciiToUpper
argument_list|(
operator|*
name|String
argument_list|)
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|String
operator|-
literal|1
operator|)
operator|!=
literal|'0'
condition|)
block|{
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
comment|//
comment|// Skip the 'X'
comment|//
name|String
operator|++
expr_stmt|;
block|}
operator|*
name|Data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|InternalAsciiIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|String
argument_list|)
condition|)
block|{
comment|//
comment|// If the number represented by String overflows according to the range
comment|// defined by UINT64, then MAX_UINT64 is stored in *Data and
comment|// RETURN_UNSUPPORTED is returned.
comment|//
if|if
condition|(
operator|*
name|Data
operator|>
name|RShiftU64
argument_list|(
name|MAX_UINT64
operator|-
name|InternalAsciiHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
argument_list|,
literal|4
argument_list|)
condition|)
block|{
operator|*
name|Data
operator|=
name|MAX_UINT64
expr_stmt|;
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
operator|*
name|Data
operator|=
name|LShiftU64
argument_list|(
operator|*
name|Data
argument_list|,
literal|4
argument_list|)
operator|+
name|InternalAsciiHexCharToUintn
argument_list|(
operator|*
name|String
argument_list|)
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated Unicode string to a Null-terminated   ASCII string.    This function is similar to AsciiStrCpyS.    This function converts the content of the Unicode string Source   to the ASCII string Destination by copying the lower 8 bits of   each Unicode character. The function terminates the ASCII string   Destination by appending a Null-terminator character at the end.    The caller is responsible to make sure Destination points to a buffer with size   equal or greater than ((StrLen (Source) + 1) * sizeof (CHAR8)) in bytes.    If any Unicode characters in Source contain non-zero value in   the upper 8 bits, then ASSERT().    If Source is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Source        The pointer to a Null-terminated Unicode string.   @param  Destination   The pointer to a Null-terminated ASCII string.   @param  DestMax       The maximum number of Destination Ascii                         char, including terminating null char.    @retval RETURN_SUCCESS           String is converted.   @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumAsciiStringLength is not zero,                                     and DestMax is greater than                                     PcdMaximumAsciiStringLength.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and DestMax is greater than                                     PcdMaximumUnicodeStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|UnicodeStrToAsciiStrS
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|,
name|OUT
name|CHAR8
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Source
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. DestMax shall not be greater than ASCII_RSIZE_MAX or RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. DestMax shall be greater than StrnLenS (Source, DestMax).
comment|//
name|SourceLen
operator|=
name|StrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|!
name|InternalSafeStringIsOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|Source
argument_list|,
operator|(
name|SourceLen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// convert string
comment|//
while|while
condition|(
operator|*
name|Source
operator|!=
literal|'\0'
condition|)
block|{
comment|//
comment|// If any Unicode characters in Source contain
comment|// non-zero value in the upper 8 bits, then ASSERT().
comment|//
name|ASSERT
argument_list|(
operator|*
name|Source
operator|<
literal|0x100
argument_list|)
expr_stmt|;
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|(
name|CHAR8
operator|)
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|'\0'
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert not more than Length successive characters from a Null-terminated   Unicode string to a Null-terminated Ascii string. If no null char is copied   from Source, then Destination[Length] is always set to null.    This function converts not more than Length successive characters from the   Unicode string Source to the Ascii string Destination by copying the lower 8   bits of each Unicode character. The function terminates the Ascii string   Destination by appending a Null-terminator character at the end.    The caller is responsible to make sure Destination points to a buffer with   size not smaller than ((MIN(StrLen(Source), Length) + 1) * sizeof (CHAR8))   in bytes.    If any Unicode characters in Source contain non-zero value in the upper 8   bits, then ASSERT().   If Source is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then Destination and DestinationLength are   unmodified.    @param  Source             The pointer to a Null-terminated Unicode string.   @param  Length             The maximum number of Unicode characters to                              convert.   @param  Destination        The pointer to a Null-terminated Ascii string.   @param  DestMax            The maximum number of Destination Ascii char,                              including terminating null char.   @param  DestinationLength  The number of Unicode characters converted.    @retval RETURN_SUCCESS            String is converted.   @retval RETURN_INVALID_PARAMETER  If Destination is NULL.                                     If Source is NULL.                                     If DestinationLength is NULL.                                     If PcdMaximumAsciiStringLength is not zero,                                     and Length or DestMax is greater than                                     PcdMaximumAsciiStringLength.                                     If PcdMaximumUnicodeStringLength is not                                     zero, and Length or DestMax is greater than                                     PcdMaximumUnicodeStringLength.                                     If DestMax is 0.   @retval RETURN_BUFFER_TOO_SMALL   If DestMax is NOT greater than                                     MIN(StrLen(Source), Length).   @retval RETURN_ACCESS_DENIED      If Source and Destination overlap.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|UnicodeStrnToAsciiStrS
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|,
name|OUT
name|CHAR8
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|DestinationLength
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Source
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. None of Destination, Source or DestinationLength shall be a null
comment|// pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestinationLength
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Neither Length nor DestMax shall be greater than ASCII_RSIZE_MAX or
comment|// RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. If Length is not less than DestMax, then DestMax shall be greater than
comment|// StrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|StrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>=
name|DestMax
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
if|if
condition|(
name|SourceLen
operator|>
name|Length
condition|)
block|{
name|SourceLen
operator|=
name|Length
expr_stmt|;
block|}
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|!
name|InternalSafeStringIsOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|Source
argument_list|,
operator|(
name|SourceLen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
operator|*
name|DestinationLength
operator|=
literal|0
expr_stmt|;
comment|//
comment|// Convert string
comment|//
while|while
condition|(
operator|(
operator|*
name|Source
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SourceLen
operator|>
literal|0
operator|)
condition|)
block|{
comment|//
comment|// If any Unicode characters in Source contain non-zero value in the upper
comment|// 8 bits, then ASSERT().
comment|//
name|ASSERT
argument_list|(
operator|*
name|Source
operator|<
literal|0x100
argument_list|)
expr_stmt|;
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|(
name|CHAR8
operator|)
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
name|SourceLen
operator|--
expr_stmt|;
operator|(
operator|*
name|DestinationLength
operator|)
operator|++
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert one Null-terminated ASCII string to a Null-terminated   Unicode string.    This function is similar to StrCpyS.    This function converts the contents of the ASCII string Source to the Unicode   string Destination. The function terminates the Unicode string Destination by   appending a Null-terminator character at the end.    The caller is responsible to make sure Destination points to a buffer with size   equal or greater than ((AsciiStrLen (Source) + 1) * sizeof (CHAR16)) in bytes.    If Destination is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then the Destination is unmodified.    @param  Source        The pointer to a Null-terminated ASCII string.   @param  Destination   The pointer to a Null-terminated Unicode string.   @param  DestMax       The maximum number of Destination Unicode                         char, including terminating null char.    @retval RETURN_SUCCESS           String is converted.   @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).   @retval RETURN_INVALID_PARAMETER If Destination is NULL.                                    If Source is NULL.                                    If PcdMaximumUnicodeStringLength is not zero,                                     and DestMax is greater than                                     PcdMaximumUnicodeStringLength.                                    If PcdMaximumAsciiStringLength is not zero,                                     and DestMax is greater than                                     PcdMaximumAsciiStringLength.                                    If DestMax is 0.   @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrToUnicodeStrS
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Source
parameter_list|,
name|OUT
name|CHAR16
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Destination
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. Neither Destination nor Source shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. DestMax shall not be greater than RSIZE_MAX or ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. DestMax shall be greater than AsciiStrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|!
name|InternalSafeStringIsOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
comment|//
comment|// Convert string
comment|//
while|while
condition|(
operator|*
name|Source
operator|!=
literal|'\0'
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|(
name|CHAR16
operator|)
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|'\0'
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert not more than Length successive characters from a Null-terminated   Ascii string to a Null-terminated Unicode string. If no null char is copied   from Source, then Destination[Length] is always set to null.    This function converts not more than Length successive characters from the   Ascii string Source to the Unicode string Destination. The function   terminates the Unicode string Destination by appending a Null-terminator   character at the end.    The caller is responsible to make sure Destination points to a buffer with   size not smaller than   ((MIN(AsciiStrLen(Source), Length) + 1) * sizeof (CHAR8)) in bytes.    If Destination is not aligned on a 16-bit boundary, then ASSERT().   If an error would be returned, then the function will also ASSERT().    If an error is returned, then Destination and DestinationLength are   unmodified.    @param  Source             The pointer to a Null-terminated Ascii string.   @param  Length             The maximum number of Ascii characters to convert.   @param  Destination        The pointer to a Null-terminated Unicode string.   @param  DestMax            The maximum number of Destination Unicode char,                              including terminating null char.   @param  DestinationLength  The number of Ascii characters converted.    @retval RETURN_SUCCESS            String is converted.   @retval RETURN_INVALID_PARAMETER  If Destination is NULL.                                     If Source is NULL.                                     If DestinationLength is NULL.                                     If PcdMaximumUnicodeStringLength is not                                     zero, and Length or DestMax is greater than                                     PcdMaximumUnicodeStringLength.                                     If PcdMaximumAsciiStringLength is not zero,                                     and Length or DestMax is greater than                                     PcdMaximumAsciiStringLength.                                     If DestMax is 0.   @retval RETURN_BUFFER_TOO_SMALL   If DestMax is NOT greater than                                     MIN(AsciiStrLen(Source), Length).   @retval RETURN_ACCESS_DENIED      If Source and Destination overlap.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrnToUnicodeStrS
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|,
name|OUT
name|CHAR16
modifier|*
name|Destination
parameter_list|,
name|IN
name|UINTN
name|DestMax
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|DestinationLength
parameter_list|)
block|{
name|UINTN
name|SourceLen
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|UINTN
operator|)
name|Destination
operator|&
name|BIT0
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// 1. None of Destination, Source or DestinationLength shall be a null
comment|// pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Destination
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Source
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestinationLength
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Neither Length nor DestMax shall be greater than ASCII_RSIZE_MAX or
comment|// RSIZE_MAX.
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. DestMax shall not equal zero.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|!=
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. If Length is not less than DestMax, then DestMax shall be greater than
comment|// AsciiStrnLenS(Source, DestMax).
comment|//
name|SourceLen
operator|=
name|AsciiStrnLenS
argument_list|(
name|Source
argument_list|,
name|DestMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>=
name|DestMax
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|DestMax
operator|>
name|SourceLen
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 5. Copying shall not take place between objects that overlap.
comment|//
if|if
condition|(
name|SourceLen
operator|>
name|Length
condition|)
block|{
name|SourceLen
operator|=
name|Length
expr_stmt|;
block|}
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|!
name|InternalSafeStringIsOverlap
argument_list|(
name|Destination
argument_list|,
name|DestMax
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|Source
argument_list|,
name|SourceLen
operator|+
literal|1
argument_list|)
argument_list|,
name|RETURN_ACCESS_DENIED
argument_list|)
expr_stmt|;
operator|*
name|DestinationLength
operator|=
literal|0
expr_stmt|;
comment|//
comment|// Convert string
comment|//
while|while
condition|(
operator|(
operator|*
name|Source
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SourceLen
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
operator|(
name|Destination
operator|++
operator|)
operator|=
operator|(
name|CHAR16
operator|)
operator|*
operator|(
name|Source
operator|++
operator|)
expr_stmt|;
name|SourceLen
operator|--
expr_stmt|;
operator|(
operator|*
name|DestinationLength
operator|)
operator|++
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
literal|0
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated ASCII string to IPv6 address and prefix length.    This function outputs a value of type IPv6_ADDRESS and may output a value   of type UINT8 by interpreting the contents of the ASCII string specified   by String. The format of the input ASCII string String is as follows:                    X:X:X:X:X:X:X:X[/P]    X contains one to four hexadecimal digit characters in the range [0-9], [a-f] and   [A-F]. X is converted to a value of type UINT16, whose low byte is stored in low   memory address and high byte is stored in high memory address. P contains decimal   digit characters in the range [0-9]. The running zero in the beginning of P will   be ignored. /P is optional.    When /P is not in the String, the function stops at the first character that is   not a valid hexadecimal digit character after eight X's are converted.    When /P is in the String, the function stops at the first character that is not   a valid decimal digit character after P is converted.    "::" can be used to compress one or more groups of X when X contains only 0.   The "::" can only appear once in the String.    If String is NULL, then ASSERT().    If Address is NULL, then ASSERT().    If EndPointer is not NULL and Address is translated from String, a pointer   to the character that stopped the scan is stored at the location pointed to   by EndPointer.    @param  String                   Pointer to a Null-terminated ASCII string.   @param  EndPointer               Pointer to character that stops scan.   @param  Address                  Pointer to the converted IPv6 address.   @param  PrefixLength             Pointer to the converted IPv6 address prefix                                    length. MAX_UINT8 is returned when /P is                                    not in the String.    @retval RETURN_SUCCESS           Address is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.   @retval RETURN_UNSUPPORTED       If X contains more than four hexadecimal                                     digit characters.                                    If String contains "::" and number of X                                     is not less than 8.                                    If P starts with character that is not a                                     valid decimal digit character.                                    If the decimal number converted from P                                     exceeds 128.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrToIpv6Address
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR8
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|IPv6_ADDRESS
modifier|*
name|Address
parameter_list|,
name|OUT
name|UINT8
modifier|*
name|PrefixLength
name|OPTIONAL
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|UINTN
name|AddressIndex
decl_stmt|;
name|UINTN
name|Uintn
decl_stmt|;
name|IPv6_ADDRESS
name|LocalAddress
decl_stmt|;
name|UINT8
name|LocalPrefixLength
decl_stmt|;
name|CONST
name|CHAR8
modifier|*
name|Pointer
decl_stmt|;
name|CHAR8
modifier|*
name|End
decl_stmt|;
name|UINTN
name|CompressStart
decl_stmt|;
name|BOOLEAN
name|ExpectPrefix
decl_stmt|;
name|LocalPrefixLength
operator|=
name|MAX_UINT8
expr_stmt|;
name|CompressStart
operator|=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
expr_stmt|;
name|ExpectPrefix
operator|=
name|FALSE
expr_stmt|;
comment|//
comment|// None of String or Address shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Address
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
for|for
control|(
name|Pointer
operator|=
name|String
operator|,
name|AddressIndex
operator|=
literal|0
init|;
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|+
literal|1
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|InternalAsciiIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|Pointer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|!=
literal|':'
condition|)
block|{
comment|//
comment|// ":" or "/" should be followed by digit characters.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Meet second ":" after previous ":" or "/"
comment|// or meet first ":" in the beginning of String.
comment|//
if|if
condition|(
name|ExpectPrefix
condition|)
block|{
comment|//
comment|// ":" shall not be after "/"
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|CompressStart
operator|!=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|||
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
comment|//
comment|// "::" can only appear once.
comment|// "::" can only appear when address is not full length.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
else|else
block|{
comment|//
comment|// Remember the start of zero compressing.
comment|//
name|CompressStart
operator|=
name|AddressIndex
expr_stmt|;
name|Pointer
operator|++
expr_stmt|;
if|if
condition|(
name|CompressStart
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|!=
literal|':'
condition|)
block|{
comment|//
comment|// Single ":" shall not be in the beginning of String.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|Pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|InternalAsciiIsHexaDecimalDigitCharacter
argument_list|(
operator|*
name|Pointer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|'/'
condition|)
block|{
comment|//
comment|// Might be optional "/P" after "::".
comment|//
if|if
condition|(
name|CompressStart
operator|!=
name|AddressIndex
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ExpectPrefix
condition|)
block|{
comment|//
comment|// Get X.
comment|//
name|Status
operator|=
name|AsciiStrHexToUintnS
argument_list|(
name|Pointer
argument_list|,
operator|&
name|End
argument_list|,
operator|&
name|Uintn
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|End
operator|-
name|Pointer
operator|>
literal|4
condition|)
block|{
comment|//
comment|// Number of hexadecimal digit characters is no more than 4.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|Pointer
operator|=
name|End
expr_stmt|;
comment|//
comment|// Uintn won't exceed MAX_UINT16 if number of hexadecimal digit characters is no more than 4.
comment|//
name|ASSERT
argument_list|(
name|AddressIndex
operator|+
literal|1
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
argument_list|)
expr_stmt|;
name|LocalAddress
operator|.
name|Addr
index|[
name|AddressIndex
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
name|UINT16
operator|)
name|Uintn
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|LocalAddress
operator|.
name|Addr
index|[
name|AddressIndex
operator|+
literal|1
index|]
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
name|AddressIndex
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Get P, then exit the loop.
comment|//
name|Status
operator|=
name|AsciiStrDecimalToUintnS
argument_list|(
name|Pointer
argument_list|,
operator|&
name|End
argument_list|,
operator|&
name|Uintn
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|End
operator|==
name|Pointer
operator|||
name|Uintn
operator|>
literal|128
condition|)
block|{
comment|//
comment|// Prefix length should not exceed 128.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|LocalPrefixLength
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
name|Pointer
operator|=
name|End
expr_stmt|;
break|break;
block|}
block|}
comment|//
comment|// Skip ':' or "/"
comment|//
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|'/'
condition|)
block|{
name|ExpectPrefix
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
comment|//
comment|// Meet additional ":" after all 8 16-bit address
comment|//
break|break;
block|}
block|}
else|else
block|{
comment|//
comment|// Meet other character that is not "/" or ":" after all 8 16-bit address
comment|//
break|break;
block|}
name|Pointer
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|&&
name|CompressStart
operator|!=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|)
operator|||
operator|(
name|AddressIndex
operator|!=
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|&&
name|CompressStart
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|)
condition|)
block|{
comment|//
comment|// Full length of address shall not have compressing zeros.
comment|// Non-full length of address shall have compressing zeros.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|CopyMem
argument_list|(
operator|&
name|Address
operator|->
name|Addr
index|[
literal|0
index|]
argument_list|,
operator|&
name|LocalAddress
operator|.
name|Addr
index|[
literal|0
index|]
argument_list|,
name|CompressStart
argument_list|)
expr_stmt|;
name|ZeroMem
argument_list|(
operator|&
name|Address
operator|->
name|Addr
index|[
name|CompressStart
index|]
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|-
name|AddressIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|AddressIndex
operator|>
name|CompressStart
condition|)
block|{
name|CopyMem
argument_list|(
operator|&
name|Address
operator|->
name|Addr
index|[
name|CompressStart
operator|+
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|-
name|AddressIndex
index|]
argument_list|,
operator|&
name|LocalAddress
operator|.
name|Addr
index|[
name|CompressStart
index|]
argument_list|,
name|AddressIndex
operator|-
name|CompressStart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PrefixLength
operator|!=
name|NULL
condition|)
block|{
operator|*
name|PrefixLength
operator|=
name|LocalPrefixLength
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|Pointer
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated ASCII string to IPv4 address and prefix length.    This function outputs a value of type IPv4_ADDRESS and may output a value   of type UINT8 by interpreting the contents of the ASCII string specified   by String. The format of the input ASCII string String is as follows:                    D.D.D.D[/P]    D and P are decimal digit characters in the range [0-9]. The running zero in   the beginning of D and P will be ignored. /P is optional.    When /P is not in the String, the function stops at the first character that is   not a valid decimal digit character after four D's are converted.    When /P is in the String, the function stops at the first character that is not   a valid decimal digit character after P is converted.    If String is NULL, then ASSERT().    If Address is NULL, then ASSERT().    If EndPointer is not NULL and Address is translated from String, a pointer   to the character that stopped the scan is stored at the location pointed to   by EndPointer.    @param  String                   Pointer to a Null-terminated ASCII string.   @param  EndPointer               Pointer to character that stops scan.   @param  Address                  Pointer to the converted IPv4 address.   @param  PrefixLength             Pointer to the converted IPv4 address prefix                                    length. MAX_UINT8 is returned when /P is                                    not in the String.    @retval RETURN_SUCCESS           Address is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.   @retval RETURN_UNSUPPORTED       If String is not in the correct format.                                    If any decimal number converted from D                                     exceeds 255.                                    If the decimal number converted from P                                     exceeds 32.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrToIpv4Address
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|CHAR8
modifier|*
modifier|*
name|EndPointer
parameter_list|,
name|OPTIONAL
name|OUT
name|IPv4_ADDRESS
modifier|*
name|Address
parameter_list|,
name|OUT
name|UINT8
modifier|*
name|PrefixLength
name|OPTIONAL
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|UINTN
name|AddressIndex
decl_stmt|;
name|UINTN
name|Uintn
decl_stmt|;
name|IPv4_ADDRESS
name|LocalAddress
decl_stmt|;
name|UINT8
name|LocalPrefixLength
decl_stmt|;
name|CHAR8
modifier|*
name|Pointer
decl_stmt|;
name|LocalPrefixLength
operator|=
name|MAX_UINT8
expr_stmt|;
comment|//
comment|// None of String or Address shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Address
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
for|for
control|(
name|Pointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|String
operator|,
name|AddressIndex
operator|=
literal|0
init|;
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
operator|+
literal|1
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|InternalAsciiIsDecimalDigitCharacter
argument_list|(
operator|*
name|Pointer
argument_list|)
condition|)
block|{
comment|//
comment|// D or P contains invalid characters.
comment|//
break|break;
block|}
comment|//
comment|// Get D or P.
comment|//
name|Status
operator|=
name|AsciiStrDecimalToUintnS
argument_list|(
operator|(
name|CONST
name|CHAR8
operator|*
operator|)
name|Pointer
argument_list|,
operator|&
name|Pointer
argument_list|,
operator|&
name|Uintn
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
comment|//
comment|// It's P.
comment|//
if|if
condition|(
name|Uintn
operator|>
literal|32
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|LocalPrefixLength
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// It's D.
comment|//
if|if
condition|(
name|Uintn
operator|>
name|MAX_UINT8
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|LocalAddress
operator|.
name|Addr
index|[
name|AddressIndex
index|]
operator|=
operator|(
name|UINT8
operator|)
name|Uintn
expr_stmt|;
name|AddressIndex
operator|++
expr_stmt|;
block|}
comment|//
comment|// Check the '.' or '/', depending on the AddressIndex.
comment|//
if|if
condition|(
name|AddressIndex
operator|==
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|'/'
condition|)
block|{
comment|//
comment|// '/P' is in the String.
comment|// Skip "/" and get P in next loop.
comment|//
name|Pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// '/P' is not in the String.
comment|//
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|'.'
condition|)
block|{
comment|//
comment|// D should be followed by '.'
comment|//
name|Pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
block|}
block|}
if|if
condition|(
name|AddressIndex
operator|<
name|ARRAY_SIZE
argument_list|(
name|Address
operator|->
name|Addr
argument_list|)
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|CopyMem
argument_list|(
name|Address
argument_list|,
operator|&
name|LocalAddress
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|Address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PrefixLength
operator|!=
name|NULL
condition|)
block|{
operator|*
name|PrefixLength
operator|=
name|LocalPrefixLength
expr_stmt|;
block|}
if|if
condition|(
name|EndPointer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndPointer
operator|=
name|Pointer
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated ASCII GUID string to a value of type   EFI_GUID.    This function outputs a GUID value by interpreting the contents of   the ASCII string specified by String. The format of the input   ASCII string String consists of 36 characters, as follows:                    aabbccdd-eeff-gghh-iijj-kkllmmnnoopp    The pairs aa - pp are two characters in the range [0-9], [a-f] and   [A-F], with each pair representing a single byte hexadecimal value.    The mapping between String and the EFI_GUID structure is as follows:                   aa          Data1[24:31]                   bb          Data1[16:23]                   cc          Data1[8:15]                   dd          Data1[0:7]                   ee          Data2[8:15]                   ff          Data2[0:7]                   gg          Data3[8:15]                   hh          Data3[0:7]                   ii          Data4[0:7]                   jj          Data4[8:15]                   kk          Data4[16:23]                   ll          Data4[24:31]                   mm          Data4[32:39]                   nn          Data4[40:47]                   oo          Data4[48:55]                   pp          Data4[56:63]    If String is NULL, then ASSERT().   If Guid is NULL, then ASSERT().    @param  String                   Pointer to a Null-terminated ASCII string.   @param  Guid                     Pointer to the converted GUID.    @retval RETURN_SUCCESS           Guid is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.   @retval RETURN_UNSUPPORTED       If String is not as the above format.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrToGuid
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|OUT
name|GUID
modifier|*
name|Guid
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|GUID
name|LocalGuid
decl_stmt|;
comment|//
comment|// None of String or Guid shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Guid
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// Get aabbccdd in big-endian.
comment|//
name|Status
operator|=
name|AsciiStrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
operator|&
name|LocalGuid
operator|.
name|Data1
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
index|]
operator|!=
literal|'-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert big-endian to little-endian.
comment|//
name|LocalGuid
operator|.
name|Data1
operator|=
name|SwapBytes32
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
expr_stmt|;
name|String
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get eeff in big-endian.
comment|//
name|Status
operator|=
name|AsciiStrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
operator|&
name|LocalGuid
operator|.
name|Data2
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
index|]
operator|!=
literal|'-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert big-endian to little-endian.
comment|//
name|LocalGuid
operator|.
name|Data2
operator|=
name|SwapBytes16
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
expr_stmt|;
name|String
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data2
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get gghh in big-endian.
comment|//
name|Status
operator|=
name|AsciiStrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
operator|&
name|LocalGuid
operator|.
name|Data3
argument_list|,
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
index|]
operator|!=
literal|'-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert big-endian to little-endian.
comment|//
name|LocalGuid
operator|.
name|Data3
operator|=
name|SwapBytes16
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
expr_stmt|;
name|String
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LocalGuid
operator|.
name|Data3
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get iijj.
comment|//
name|Status
operator|=
name|AsciiStrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
literal|2
argument_list|,
operator|&
name|LocalGuid
operator|.
name|Data4
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|String
index|[
literal|2
operator|*
literal|2
index|]
operator|!=
literal|'-'
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|String
operator|+=
literal|2
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
comment|//
comment|// Get kkllmmnnoopp.
comment|//
name|Status
operator|=
name|AsciiStrHexToBytes
argument_list|(
name|String
argument_list|,
literal|2
operator|*
literal|6
argument_list|,
operator|&
name|LocalGuid
operator|.
name|Data4
index|[
literal|2
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|CopyGuid
argument_list|(
name|Guid
argument_list|,
operator|&
name|LocalGuid
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Convert a Null-terminated ASCII hexadecimal string to a byte array.    This function outputs a byte array by interpreting the contents of   the ASCII string specified by String in hexadecimal format. The format of   the input ASCII string String is:                    [XX]*    X is a hexadecimal digit character in the range [0-9], [a-f] and [A-F].   The function decodes every two hexadecimal digit characters as one byte. The   decoding stops after Length of characters and outputs Buffer containing   (Length / 2) bytes.    If String is NULL, then ASSERT().    If Buffer is NULL, then ASSERT().    If Length is not multiple of 2, then ASSERT().    If PcdMaximumAsciiStringLength is not zero and Length is greater than   PcdMaximumAsciiStringLength, then ASSERT().    If MaxBufferSize is less than (Length / 2), then ASSERT().    @param  String                   Pointer to a Null-terminated ASCII string.   @param  Length                   The number of ASCII characters to decode.   @param  Buffer                   Pointer to the converted bytes array.   @param  MaxBufferSize            The maximum size of Buffer.    @retval RETURN_SUCCESS           Buffer is translated from String.   @retval RETURN_INVALID_PARAMETER If String is NULL.                                    If Data is NULL.                                    If Length is not multiple of 2.                                    If PcdMaximumAsciiStringLength is not zero,                                     and Length is greater than                                     PcdMaximumAsciiStringLength.   @retval RETURN_UNSUPPORTED       If Length of characters from String contain                                     a character that is not valid hexadecimal                                     digit characters, or a Null-terminator.   @retval RETURN_BUFFER_TOO_SMALL  If MaxBufferSize is less than (Length / 2). **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|AsciiStrHexToBytes
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|String
parameter_list|,
name|IN
name|UINTN
name|Length
parameter_list|,
name|OUT
name|UINT8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|MaxBufferSize
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
comment|//
comment|// 1. None of String or Buffer shall be a null pointer.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|String
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Buffer
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. Length shall not be greater than ASCII_RSIZE_MAX.
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Length
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. Length shall not be odd.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
operator|(
name|Length
operator|&
name|BIT0
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. MaxBufferSize shall equal to or greater than Length / 2.
comment|//
name|SAFE_STRING_CONSTRAINT_CHECK
argument_list|(
operator|(
name|MaxBufferSize
operator|>=
name|Length
operator|/
literal|2
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// 5. String shall not contains invalid hexadecimal digits.
comment|//
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Length
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|InternalAsciiIsHexaDecimalDigitCharacter
argument_list|(
name|String
index|[
name|Index
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|Index
operator|!=
name|Length
condition|)
block|{
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Convert the hex string to bytes.
comment|//
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Length
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// For even characters, write the upper nibble for each buffer byte,
comment|// and for even characters, the lower nibble.
comment|//
if|if
condition|(
operator|(
name|Index
operator|&
name|BIT0
operator|)
operator|==
literal|0
condition|)
block|{
name|Buffer
index|[
name|Index
operator|/
literal|2
index|]
operator|=
operator|(
name|UINT8
operator|)
name|InternalAsciiHexCharToUintn
argument_list|(
name|String
index|[
name|Index
index|]
argument_list|)
operator|<<
literal|4
expr_stmt|;
block|}
else|else
block|{
name|Buffer
index|[
name|Index
operator|/
literal|2
index|]
operator||=
operator|(
name|UINT8
operator|)
name|InternalAsciiHexCharToUintn
argument_list|(
name|String
index|[
name|Index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

end_unit

