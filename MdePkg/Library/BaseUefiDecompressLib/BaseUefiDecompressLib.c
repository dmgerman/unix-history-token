begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   UEFI Decompress Library implementation refer to UEFI specification.    Copyright (c) 2006 - 2015, Intel Corporation. All rights reserved.<BR>   Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<Base.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseMemoryLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/UefiDecompressLib.h>
end_include

begin_include
include|#
directive|include
file|"BaseUefiDecompressLibInternals.h"
end_include

begin_comment
comment|/**   Read NumOfBit of bits from source into mBitBuf.    Shift mBitBuf NumOfBits left. Read in NumOfBits of bits from source.    @param  Sd        The global scratch data.   @param  NumOfBits The number of bits to shift and read.  **/
end_comment

begin_function
name|VOID
name|FillBuf
parameter_list|(
name|IN
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|,
name|IN
name|UINT16
name|NumOfBits
parameter_list|)
block|{
comment|//
comment|// Left shift NumOfBits of bits in advance
comment|//
name|Sd
operator|->
name|mBitBuf
operator|=
call|(
name|UINT32
call|)
argument_list|(
name|Sd
operator|->
name|mBitBuf
operator|<<
name|NumOfBits
argument_list|)
expr_stmt|;
comment|//
comment|// Copy data needed in bytes into mSbuBitBuf
comment|//
while|while
condition|(
name|NumOfBits
operator|>
name|Sd
operator|->
name|mBitCount
condition|)
block|{
name|Sd
operator|->
name|mBitBuf
operator||=
call|(
name|UINT32
call|)
argument_list|(
name|Sd
operator|->
name|mSubBitBuf
operator|<<
operator|(
name|NumOfBits
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|NumOfBits
operator|-
name|Sd
operator|->
name|mBitCount
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mCompSize
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Get 1 byte into SubBitBuf
comment|//
name|Sd
operator|->
name|mCompSize
operator|--
expr_stmt|;
name|Sd
operator|->
name|mSubBitBuf
operator|=
name|Sd
operator|->
name|mSrcBase
index|[
name|Sd
operator|->
name|mInBuf
operator|++
index|]
expr_stmt|;
name|Sd
operator|->
name|mBitCount
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// No more bits from the source, just pad zero bit.
comment|//
name|Sd
operator|->
name|mSubBitBuf
operator|=
literal|0
expr_stmt|;
name|Sd
operator|->
name|mBitCount
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|//
comment|// Calculate additional bit count read to update mBitCount
comment|//
name|Sd
operator|->
name|mBitCount
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Sd
operator|->
name|mBitCount
operator|-
name|NumOfBits
argument_list|)
expr_stmt|;
comment|//
comment|// Copy NumOfBits of bits from mSubBitBuf into mBitBuf
comment|//
name|Sd
operator|->
name|mBitBuf
operator||=
name|Sd
operator|->
name|mSubBitBuf
operator|>>
name|Sd
operator|->
name|mBitCount
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Get NumOfBits of bits out from mBitBuf.    Get NumOfBits of bits out from mBitBuf. Fill mBitBuf with subsequent   NumOfBits of bits from source. Returns NumOfBits of bits that are   popped out.    @param  Sd        The global scratch data.   @param  NumOfBits The number of bits to pop and read.    @return The bits that are popped out.  **/
end_comment

begin_function
name|UINT32
name|GetBits
parameter_list|(
name|IN
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|,
name|IN
name|UINT16
name|NumOfBits
parameter_list|)
block|{
name|UINT32
name|OutBits
decl_stmt|;
comment|//
comment|// Pop NumOfBits of Bits from Left
comment|//
name|OutBits
operator|=
call|(
name|UINT32
call|)
argument_list|(
name|Sd
operator|->
name|mBitBuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
name|NumOfBits
operator|)
argument_list|)
expr_stmt|;
comment|//
comment|// Fill up mBitBuf from source
comment|//
name|FillBuf
argument_list|(
name|Sd
argument_list|,
name|NumOfBits
argument_list|)
expr_stmt|;
return|return
name|OutBits
return|;
block|}
end_function

begin_comment
comment|/**   Creates Huffman Code mapping table according to code length array.    Creates Huffman Code mapping table for Extra Set, Char&Len Set   and Position Set according to code length array.   If TableBits> 16, then ASSERT ().    @param  Sd        The global scratch data.   @param  NumOfChar The number of symbols in the symbol set.   @param  BitLen    Code length array.   @param  TableBits The width of the mapping table.   @param  Table     The table to be created.    @retval  0 OK.   @retval  BAD_TABLE The table is corrupted.  **/
end_comment

begin_function
name|UINT16
name|MakeTable
parameter_list|(
name|IN
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|,
name|IN
name|UINT16
name|NumOfChar
parameter_list|,
name|IN
name|UINT8
modifier|*
name|BitLen
parameter_list|,
name|IN
name|UINT16
name|TableBits
parameter_list|,
name|OUT
name|UINT16
modifier|*
name|Table
parameter_list|)
block|{
name|UINT16
name|Count
index|[
literal|17
index|]
decl_stmt|;
name|UINT16
name|Weight
index|[
literal|17
index|]
decl_stmt|;
name|UINT16
name|Start
index|[
literal|18
index|]
decl_stmt|;
name|UINT16
modifier|*
name|Pointer
decl_stmt|;
name|UINT16
name|Index3
decl_stmt|;
name|UINT16
name|Index
decl_stmt|;
name|UINT16
name|Len
decl_stmt|;
name|UINT16
name|Char
decl_stmt|;
name|UINT16
name|JuBits
decl_stmt|;
name|UINT16
name|Avail
decl_stmt|;
name|UINT16
name|NextCode
decl_stmt|;
name|UINT16
name|Mask
decl_stmt|;
name|UINT16
name|WordOfStart
decl_stmt|;
name|UINT16
name|WordOfCount
decl_stmt|;
comment|//
comment|// The maximum mapping table width supported by this internal
comment|// working function is 16.
comment|//
name|ASSERT
argument_list|(
name|TableBits
operator|<=
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<=
literal|16
condition|;
name|Index
operator|++
control|)
block|{
name|Count
index|[
name|Index
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|NumOfChar
condition|;
name|Index
operator|++
control|)
block|{
name|Count
index|[
name|BitLen
index|[
name|Index
index|]
index|]
operator|++
expr_stmt|;
block|}
name|Start
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|Start
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|1
init|;
name|Index
operator|<=
literal|16
condition|;
name|Index
operator|++
control|)
block|{
name|WordOfStart
operator|=
name|Start
index|[
name|Index
index|]
expr_stmt|;
name|WordOfCount
operator|=
name|Count
index|[
name|Index
index|]
expr_stmt|;
name|Start
index|[
name|Index
operator|+
literal|1
index|]
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|WordOfStart
operator|+
operator|(
name|WordOfCount
operator|<<
operator|(
literal|16
operator|-
name|Index
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Start
index|[
literal|17
index|]
operator|!=
literal|0
condition|)
block|{
comment|/*(1U<< 16)*/
return|return
operator|(
name|UINT16
operator|)
name|BAD_TABLE
return|;
block|}
name|JuBits
operator|=
call|(
name|UINT16
call|)
argument_list|(
literal|16
operator|-
name|TableBits
argument_list|)
expr_stmt|;
name|Weight
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|1
init|;
name|Index
operator|<=
name|TableBits
condition|;
name|Index
operator|++
control|)
block|{
name|Start
index|[
name|Index
index|]
operator|>>=
name|JuBits
expr_stmt|;
name|Weight
index|[
name|Index
index|]
operator|=
call|(
name|UINT16
call|)
argument_list|(
literal|1U
operator|<<
operator|(
name|TableBits
operator|-
name|Index
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|Index
operator|<=
literal|16
condition|)
block|{
name|Weight
index|[
name|Index
index|]
operator|=
call|(
name|UINT16
call|)
argument_list|(
literal|1U
operator|<<
operator|(
literal|16
operator|-
name|Index
operator|)
argument_list|)
expr_stmt|;
name|Index
operator|++
expr_stmt|;
block|}
name|Index
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Start
index|[
name|TableBits
operator|+
literal|1
index|]
operator|>>
name|JuBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|Index
operator|!=
literal|0
condition|)
block|{
name|Index3
operator|=
call|(
name|UINT16
call|)
argument_list|(
literal|1U
operator|<<
name|TableBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|Index
operator|<
name|Index3
condition|)
block|{
name|SetMem16
argument_list|(
name|Table
operator|+
name|Index
argument_list|,
operator|(
name|Index3
operator|-
name|Index
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|Table
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|Avail
operator|=
name|NumOfChar
expr_stmt|;
name|Mask
operator|=
call|(
name|UINT16
call|)
argument_list|(
literal|1U
operator|<<
operator|(
literal|15
operator|-
name|TableBits
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Char
operator|=
literal|0
init|;
name|Char
operator|<
name|NumOfChar
condition|;
name|Char
operator|++
control|)
block|{
name|Len
operator|=
name|BitLen
index|[
name|Char
index|]
expr_stmt|;
if|if
condition|(
name|Len
operator|==
literal|0
operator|||
name|Len
operator|>=
literal|17
condition|)
block|{
continue|continue;
block|}
name|NextCode
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Start
index|[
name|Len
index|]
operator|+
name|Weight
index|[
name|Len
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Len
operator|<=
name|TableBits
condition|)
block|{
for|for
control|(
name|Index
operator|=
name|Start
index|[
name|Len
index|]
init|;
name|Index
operator|<
name|NextCode
condition|;
name|Index
operator|++
control|)
block|{
name|Table
index|[
name|Index
index|]
operator|=
name|Char
expr_stmt|;
block|}
block|}
else|else
block|{
name|Index3
operator|=
name|Start
index|[
name|Len
index|]
expr_stmt|;
name|Pointer
operator|=
operator|&
name|Table
index|[
name|Index3
operator|>>
name|JuBits
index|]
expr_stmt|;
name|Index
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Len
operator|-
name|TableBits
argument_list|)
expr_stmt|;
while|while
condition|(
name|Index
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|Pointer
operator|==
literal|0
operator|&&
name|Avail
operator|<
operator|(
literal|2
operator|*
name|NC
operator|-
literal|1
operator|)
condition|)
block|{
name|Sd
operator|->
name|mRight
index|[
name|Avail
index|]
operator|=
name|Sd
operator|->
name|mLeft
index|[
name|Avail
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|Pointer
operator|=
name|Avail
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|Pointer
operator|<
operator|(
literal|2
operator|*
name|NC
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|Index3
operator|&
name|Mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|Pointer
operator|=
operator|&
name|Sd
operator|->
name|mRight
index|[
operator|*
name|Pointer
index|]
expr_stmt|;
block|}
else|else
block|{
name|Pointer
operator|=
operator|&
name|Sd
operator|->
name|mLeft
index|[
operator|*
name|Pointer
index|]
expr_stmt|;
block|}
block|}
name|Index3
operator|<<=
literal|1
expr_stmt|;
name|Index
operator|--
expr_stmt|;
block|}
operator|*
name|Pointer
operator|=
name|Char
expr_stmt|;
block|}
name|Start
index|[
name|Len
index|]
operator|=
name|NextCode
expr_stmt|;
block|}
comment|//
comment|// Succeeds
comment|//
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   Decodes a position value.    Get a position value according to Position Huffman Table.    @param  Sd The global scratch data.    @return The position value decoded.  **/
end_comment

begin_function
name|UINT32
name|DecodeP
parameter_list|(
name|IN
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|)
block|{
name|UINT16
name|Val
decl_stmt|;
name|UINT32
name|Mask
decl_stmt|;
name|UINT32
name|Pos
decl_stmt|;
name|Val
operator|=
name|Sd
operator|->
name|mPTTable
index|[
name|Sd
operator|->
name|mBitBuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|8
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|Val
operator|>=
name|MAXNP
condition|)
block|{
name|Mask
operator|=
literal|1U
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|8
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|Sd
operator|->
name|mBitBuf
operator|&
name|Mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|Val
operator|=
name|Sd
operator|->
name|mRight
index|[
name|Val
index|]
expr_stmt|;
block|}
else|else
block|{
name|Val
operator|=
name|Sd
operator|->
name|mLeft
index|[
name|Val
index|]
expr_stmt|;
block|}
name|Mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Val
operator|>=
name|MAXNP
condition|)
do|;
block|}
comment|//
comment|// Advance what we have read
comment|//
name|FillBuf
argument_list|(
name|Sd
argument_list|,
name|Sd
operator|->
name|mPTLen
index|[
name|Val
index|]
argument_list|)
expr_stmt|;
name|Pos
operator|=
name|Val
expr_stmt|;
if|if
condition|(
name|Val
operator|>
literal|1
condition|)
block|{
name|Pos
operator|=
call|(
name|UINT32
call|)
argument_list|(
operator|(
literal|1U
operator|<<
operator|(
name|Val
operator|-
literal|1
operator|)
operator|)
operator|+
name|GetBits
argument_list|(
name|Sd
argument_list|,
call|(
name|UINT16
call|)
argument_list|(
name|Val
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Pos
return|;
block|}
end_function

begin_comment
comment|/**   Reads code lengths for the Extra Set or the Position Set.    Read in the Extra Set or Position Set Length Array, then   generate the Huffman code mapping for them.    @param  Sd      The global scratch data.   @param  nn      The number of symbols.   @param  nbit    The number of bits needed to represent nn.   @param  Special The special symbol that needs to be taken care of.    @retval  0 OK.   @retval  BAD_TABLE Table is corrupted.  **/
end_comment

begin_function
name|UINT16
name|ReadPTLen
parameter_list|(
name|IN
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|,
name|IN
name|UINT16
name|nn
parameter_list|,
name|IN
name|UINT16
name|nbit
parameter_list|,
name|IN
name|UINT16
name|Special
parameter_list|)
block|{
name|UINT16
name|Number
decl_stmt|;
name|UINT16
name|CharC
decl_stmt|;
name|UINT16
name|Index
decl_stmt|;
name|UINT32
name|Mask
decl_stmt|;
name|ASSERT
argument_list|(
name|nn
operator|<=
name|NPT
argument_list|)
expr_stmt|;
comment|//
comment|// Read Extra Set Code Length Array size
comment|//
name|Number
operator|=
operator|(
name|UINT16
operator|)
name|GetBits
argument_list|(
name|Sd
argument_list|,
name|nbit
argument_list|)
expr_stmt|;
if|if
condition|(
name|Number
operator|==
literal|0
condition|)
block|{
comment|//
comment|// This represents only Huffman code used
comment|//
name|CharC
operator|=
operator|(
name|UINT16
operator|)
name|GetBits
argument_list|(
name|Sd
argument_list|,
name|nbit
argument_list|)
expr_stmt|;
name|SetMem16
argument_list|(
operator|&
name|Sd
operator|->
name|mPTTable
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Sd
operator|->
name|mPTTable
argument_list|)
argument_list|,
name|CharC
argument_list|)
expr_stmt|;
name|SetMem
argument_list|(
name|Sd
operator|->
name|mPTLen
argument_list|,
name|nn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Index
operator|<
name|Number
operator|&&
name|Index
operator|<
name|NPT
condition|)
block|{
name|CharC
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Sd
operator|->
name|mBitBuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|3
operator|)
argument_list|)
expr_stmt|;
comment|//
comment|// If a code length is less than 7, then it is encoded as a 3-bit
comment|// value. Or it is encoded as a series of "1"s followed by a
comment|// terminating "0". The number of "1"s = Code length - 4.
comment|//
if|if
condition|(
name|CharC
operator|==
literal|7
condition|)
block|{
name|Mask
operator|=
literal|1U
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|3
operator|)
expr_stmt|;
while|while
condition|(
name|Mask
operator|&
name|Sd
operator|->
name|mBitBuf
condition|)
block|{
name|Mask
operator|>>=
literal|1
expr_stmt|;
name|CharC
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|FillBuf
argument_list|(
name|Sd
argument_list|,
call|(
name|UINT16
call|)
argument_list|(
operator|(
name|CharC
operator|<
literal|7
operator|)
condition|?
literal|3
else|:
name|CharC
operator|-
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|Sd
operator|->
name|mPTLen
index|[
name|Index
operator|++
index|]
operator|=
operator|(
name|UINT8
operator|)
name|CharC
expr_stmt|;
comment|//
comment|// For Code&Len Set,
comment|// After the third length of the code length concatenation,
comment|// a 2-bit value is used to indicated the number of consecutive
comment|// zero lengths after the third length.
comment|//
if|if
condition|(
name|Index
operator|==
name|Special
condition|)
block|{
name|CharC
operator|=
operator|(
name|UINT16
operator|)
name|GetBits
argument_list|(
name|Sd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
call|(
name|INT16
call|)
argument_list|(
operator|--
name|CharC
argument_list|)
operator|>=
literal|0
operator|&&
name|Index
operator|<
name|NPT
condition|)
block|{
name|Sd
operator|->
name|mPTLen
index|[
name|Index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|Index
operator|<
name|nn
operator|&&
name|Index
operator|<
name|NPT
condition|)
block|{
name|Sd
operator|->
name|mPTLen
index|[
name|Index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|MakeTable
argument_list|(
name|Sd
argument_list|,
name|nn
argument_list|,
name|Sd
operator|->
name|mPTLen
argument_list|,
literal|8
argument_list|,
name|Sd
operator|->
name|mPTTable
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Reads code lengths for Char&Len Set.    Read in and decode the Char&Len Set Code Length Array, then   generate the Huffman Code mapping table for the Char&Len Set.    @param  Sd The global scratch data.  **/
end_comment

begin_function
name|VOID
name|ReadCLen
parameter_list|(
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|)
block|{
name|UINT16
name|Number
decl_stmt|;
name|UINT16
name|CharC
decl_stmt|;
name|UINT16
name|Index
decl_stmt|;
name|UINT32
name|Mask
decl_stmt|;
name|Number
operator|=
operator|(
name|UINT16
operator|)
name|GetBits
argument_list|(
name|Sd
argument_list|,
name|CBIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Number
operator|==
literal|0
condition|)
block|{
comment|//
comment|// This represents only Huffman code used
comment|//
name|CharC
operator|=
operator|(
name|UINT16
operator|)
name|GetBits
argument_list|(
name|Sd
argument_list|,
name|CBIT
argument_list|)
expr_stmt|;
name|SetMem
argument_list|(
name|Sd
operator|->
name|mCLen
argument_list|,
name|NC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SetMem16
argument_list|(
operator|&
name|Sd
operator|->
name|mCTable
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Sd
operator|->
name|mCTable
argument_list|)
argument_list|,
name|CharC
argument_list|)
expr_stmt|;
return|return ;
block|}
name|Index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Index
operator|<
name|Number
operator|&&
name|Index
operator|<
name|NC
condition|)
block|{
name|CharC
operator|=
name|Sd
operator|->
name|mPTTable
index|[
name|Sd
operator|->
name|mBitBuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|8
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|CharC
operator|>=
name|NT
condition|)
block|{
name|Mask
operator|=
literal|1U
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|8
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|Mask
operator|&
name|Sd
operator|->
name|mBitBuf
condition|)
block|{
name|CharC
operator|=
name|Sd
operator|->
name|mRight
index|[
name|CharC
index|]
expr_stmt|;
block|}
else|else
block|{
name|CharC
operator|=
name|Sd
operator|->
name|mLeft
index|[
name|CharC
index|]
expr_stmt|;
block|}
name|Mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|CharC
operator|>=
name|NT
condition|)
do|;
block|}
comment|//
comment|// Advance what we have read
comment|//
name|FillBuf
argument_list|(
name|Sd
argument_list|,
name|Sd
operator|->
name|mPTLen
index|[
name|CharC
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|CharC
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|CharC
operator|==
literal|0
condition|)
block|{
name|CharC
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CharC
operator|==
literal|1
condition|)
block|{
name|CharC
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|GetBits
argument_list|(
name|Sd
argument_list|,
literal|4
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CharC
operator|==
literal|2
condition|)
block|{
name|CharC
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|GetBits
argument_list|(
name|Sd
argument_list|,
name|CBIT
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
call|(
name|INT16
call|)
argument_list|(
operator|--
name|CharC
argument_list|)
operator|>=
literal|0
operator|&&
name|Index
operator|<
name|NC
condition|)
block|{
name|Sd
operator|->
name|mCLen
index|[
name|Index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|Sd
operator|->
name|mCLen
index|[
name|Index
operator|++
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|CharC
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|SetMem
argument_list|(
name|Sd
operator|->
name|mCLen
operator|+
name|Index
argument_list|,
name|NC
operator|-
name|Index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MakeTable
argument_list|(
name|Sd
argument_list|,
name|NC
argument_list|,
name|Sd
operator|->
name|mCLen
argument_list|,
literal|12
argument_list|,
name|Sd
operator|->
name|mCTable
argument_list|)
expr_stmt|;
return|return ;
block|}
end_function

begin_comment
comment|/**   Decode a character/length value.    Read one value from mBitBuf, Get one code from mBitBuf. If it is at block boundary, generates   Huffman code mapping table for Extra Set, Code&Len Set and   Position Set.    @param  Sd The global scratch data.    @return The value decoded.  **/
end_comment

begin_function
name|UINT16
name|DecodeC
parameter_list|(
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|)
block|{
name|UINT16
name|Index2
decl_stmt|;
name|UINT32
name|Mask
decl_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mBlockSize
operator|==
literal|0
condition|)
block|{
comment|//
comment|// Starting a new block
comment|// Read BlockSize from block header
comment|//
name|Sd
operator|->
name|mBlockSize
operator|=
operator|(
name|UINT16
operator|)
name|GetBits
argument_list|(
name|Sd
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|//
comment|// Read in the Extra Set Code Length Array,
comment|// Generate the Huffman code mapping table for Extra Set.
comment|//
name|Sd
operator|->
name|mBadTableFlag
operator|=
name|ReadPTLen
argument_list|(
name|Sd
argument_list|,
name|NT
argument_list|,
name|TBIT
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mBadTableFlag
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//
comment|// Read in and decode the Char&Len Set Code Length Array,
comment|// Generate the Huffman code mapping table for Char&Len Set.
comment|//
name|ReadCLen
argument_list|(
name|Sd
argument_list|)
expr_stmt|;
comment|//
comment|// Read in the Position Set Code Length Array,
comment|// Generate the Huffman code mapping table for the Position Set.
comment|//
name|Sd
operator|->
name|mBadTableFlag
operator|=
name|ReadPTLen
argument_list|(
name|Sd
argument_list|,
name|MAXNP
argument_list|,
name|Sd
operator|->
name|mPBit
argument_list|,
call|(
name|UINT16
call|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mBadTableFlag
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|//
comment|// Get one code according to Code&Set Huffman Table
comment|//
name|Sd
operator|->
name|mBlockSize
operator|--
expr_stmt|;
name|Index2
operator|=
name|Sd
operator|->
name|mCTable
index|[
name|Sd
operator|->
name|mBitBuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|12
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|Index2
operator|>=
name|NC
condition|)
block|{
name|Mask
operator|=
literal|1U
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|12
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|Sd
operator|->
name|mBitBuf
operator|&
name|Mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|Index2
operator|=
name|Sd
operator|->
name|mRight
index|[
name|Index2
index|]
expr_stmt|;
block|}
else|else
block|{
name|Index2
operator|=
name|Sd
operator|->
name|mLeft
index|[
name|Index2
index|]
expr_stmt|;
block|}
name|Mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Index2
operator|>=
name|NC
condition|)
do|;
block|}
comment|//
comment|// Advance what we have read
comment|//
name|FillBuf
argument_list|(
name|Sd
argument_list|,
name|Sd
operator|->
name|mCLen
index|[
name|Index2
index|]
argument_list|)
expr_stmt|;
return|return
name|Index2
return|;
block|}
end_function

begin_comment
comment|/**   Decode the source data and put the resulting data into the destination buffer.    @param  Sd The global scratch data.  **/
end_comment

begin_function
name|VOID
name|Decode
parameter_list|(
name|SCRATCH_DATA
modifier|*
name|Sd
parameter_list|)
block|{
name|UINT16
name|BytesRemain
decl_stmt|;
name|UINT32
name|DataIdx
decl_stmt|;
name|UINT16
name|CharC
decl_stmt|;
name|BytesRemain
operator|=
call|(
name|UINT16
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DataIdx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|//
comment|// Get one code from mBitBuf
comment|//
name|CharC
operator|=
name|DecodeC
argument_list|(
name|Sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mBadTableFlag
operator|!=
literal|0
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
if|if
condition|(
name|CharC
operator|<
literal|256
condition|)
block|{
comment|//
comment|// Process an Original character
comment|//
if|if
condition|(
name|Sd
operator|->
name|mOutBuf
operator|>=
name|Sd
operator|->
name|mOrigSize
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
else|else
block|{
comment|//
comment|// Write orignal character into mDstBase
comment|//
name|Sd
operator|->
name|mDstBase
index|[
name|Sd
operator|->
name|mOutBuf
operator|++
index|]
operator|=
operator|(
name|UINT8
operator|)
name|CharC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// Process a Pointer
comment|//
name|CharC
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|CharC
operator|-
operator|(
name|BIT8
operator|-
name|THRESHOLD
operator|)
argument_list|)
expr_stmt|;
comment|//
comment|// Get string length
comment|//
name|BytesRemain
operator|=
name|CharC
expr_stmt|;
comment|//
comment|// Locate string position
comment|//
name|DataIdx
operator|=
name|Sd
operator|->
name|mOutBuf
operator|-
name|DecodeP
argument_list|(
name|Sd
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|//
comment|// Write BytesRemain of bytes into mDstBase
comment|//
name|BytesRemain
operator|--
expr_stmt|;
while|while
condition|(
call|(
name|INT16
call|)
argument_list|(
name|BytesRemain
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|Sd
operator|->
name|mDstBase
index|[
name|Sd
operator|->
name|mOutBuf
operator|++
index|]
operator|=
name|Sd
operator|->
name|mDstBase
index|[
name|DataIdx
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mOutBuf
operator|>=
name|Sd
operator|->
name|mOrigSize
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
name|BytesRemain
operator|--
expr_stmt|;
block|}
block|}
block|}
name|Done
label|:
return|return ;
block|}
end_function

begin_comment
comment|/**   Given a compressed source buffer, this function retrieves the size of    the uncompressed buffer and the size of the scratch buffer required    to decompress the compressed source buffer.    Retrieves the size of the uncompressed buffer and the temporary scratch buffer    required to decompress the buffer specified by Source and SourceSize.   If the size of the uncompressed buffer or the size of the scratch buffer cannot   be determined from the compressed data specified by Source and SourceData,    then RETURN_INVALID_PARAMETER is returned.  Otherwise, the size of the uncompressed   buffer is returned in DestinationSize, the size of the scratch buffer is returned   in ScratchSize, and RETURN_SUCCESS is returned.   This function does not have scratch buffer available to perform a thorough    checking of the validity of the source data.  It just retrieves the "Original Size"   field from the beginning bytes of the source data and output it as DestinationSize.   And ScratchSize is specific to the decompression implementation.    If Source is NULL, then ASSERT().   If DestinationSize is NULL, then ASSERT().   If ScratchSize is NULL, then ASSERT().    @param  Source          The source buffer containing the compressed data.   @param  SourceSize      The size, in bytes, of the source buffer.   @param  DestinationSize A pointer to the size, in bytes, of the uncompressed buffer                           that will be generated when the compressed buffer specified                           by Source and SourceSize is decompressed.   @param  ScratchSize     A pointer to the size, in bytes, of the scratch buffer that                           is required to decompress the compressed buffer specified                            by Source and SourceSize.    @retval  RETURN_SUCCESS The size of the uncompressed data was returned                            in DestinationSize, and the size of the scratch                            buffer was returned in ScratchSize.   @retval  RETURN_INVALID_PARAMETER                            The size of the uncompressed data or the size of                            the scratch buffer cannot be determined from                            the compressed data specified by Source                            and SourceSize. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|UefiDecompressGetInfo
parameter_list|(
name|IN
name|CONST
name|VOID
modifier|*
name|Source
parameter_list|,
name|IN
name|UINT32
name|SourceSize
parameter_list|,
name|OUT
name|UINT32
modifier|*
name|DestinationSize
parameter_list|,
name|OUT
name|UINT32
modifier|*
name|ScratchSize
parameter_list|)
block|{
name|UINT32
name|CompressedSize
decl_stmt|;
name|ASSERT
argument_list|(
name|Source
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DestinationSize
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ScratchSize
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SourceSize
operator|<
literal|8
condition|)
block|{
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
name|CompressedSize
operator|=
name|ReadUnaligned32
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|Source
argument_list|)
expr_stmt|;
if|if
condition|(
name|SourceSize
operator|<
operator|(
name|CompressedSize
operator|+
literal|8
operator|)
condition|)
block|{
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
operator|*
name|ScratchSize
operator|=
sizeof|sizeof
argument_list|(
name|SCRATCH_DATA
argument_list|)
expr_stmt|;
operator|*
name|DestinationSize
operator|=
name|ReadUnaligned32
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|Source
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Decompresses a compressed source buffer.    Extracts decompressed data to its original form.   This function is designed so that the decompression algorithm can be implemented   without using any memory services.  As a result, this function is not allowed to   call any memory allocation services in its implementation.  It is the caller's    responsibility to allocate and free the Destination and Scratch buffers.   If the compressed source data specified by Source is successfully decompressed    into Destination, then RETURN_SUCCESS is returned.  If the compressed source data    specified by Source is not in a valid compressed data format,   then RETURN_INVALID_PARAMETER is returned.    If Source is NULL, then ASSERT().   If Destination is NULL, then ASSERT().   If the required scratch buffer size> 0 and Scratch is NULL, then ASSERT().    @param  Source      The source buffer containing the compressed data.   @param  Destination The destination buffer to store the decompressed data.   @param  Scratch     A temporary scratch buffer that is used to perform the decompression.                       This is an optional parameter that may be NULL if the                        required scratch buffer size is 0.                         @retval  RETURN_SUCCESS Decompression completed successfully, and                            the uncompressed buffer is returned in Destination.   @retval  RETURN_INVALID_PARAMETER                            The source buffer specified by Source is corrupted                            (not in a valid compressed format). **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|UefiDecompress
parameter_list|(
name|IN
name|CONST
name|VOID
modifier|*
name|Source
parameter_list|,
name|IN
name|OUT
name|VOID
modifier|*
name|Destination
parameter_list|,
name|IN
name|OUT
name|VOID
modifier|*
name|Scratch
name|OPTIONAL
parameter_list|)
block|{
name|UINT32
name|CompSize
decl_stmt|;
name|UINT32
name|OrigSize
decl_stmt|;
name|SCRATCH_DATA
modifier|*
name|Sd
decl_stmt|;
name|CONST
name|UINT8
modifier|*
name|Src
decl_stmt|;
name|UINT8
modifier|*
name|Dst
decl_stmt|;
name|ASSERT
argument_list|(
name|Source
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Destination
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Scratch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Src
operator|=
name|Source
expr_stmt|;
name|Dst
operator|=
name|Destination
expr_stmt|;
name|Sd
operator|=
operator|(
name|SCRATCH_DATA
operator|*
operator|)
name|Scratch
expr_stmt|;
name|CompSize
operator|=
name|Src
index|[
literal|0
index|]
operator|+
operator|(
name|Src
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|Src
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|Src
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|OrigSize
operator|=
name|Src
index|[
literal|4
index|]
operator|+
operator|(
name|Src
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|Src
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|Src
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
comment|//
comment|// If compressed file size is 0, return
comment|//
if|if
condition|(
name|OrigSize
operator|==
literal|0
condition|)
block|{
return|return
name|RETURN_SUCCESS
return|;
block|}
name|Src
operator|=
name|Src
operator|+
literal|8
expr_stmt|;
name|SetMem
argument_list|(
name|Sd
argument_list|,
sizeof|sizeof
argument_list|(
name|SCRATCH_DATA
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// The length of the field 'Position Set Code Length Array Size' in Block Header.
comment|// For UEFI 2.0 de/compression algorithm(Version 1), mPBit = 4
comment|//
name|Sd
operator|->
name|mPBit
operator|=
literal|4
expr_stmt|;
name|Sd
operator|->
name|mSrcBase
operator|=
operator|(
name|UINT8
operator|*
operator|)
name|Src
expr_stmt|;
name|Sd
operator|->
name|mDstBase
operator|=
name|Dst
expr_stmt|;
comment|//
comment|// CompSize and OrigSize are calculated in bytes
comment|//
name|Sd
operator|->
name|mCompSize
operator|=
name|CompSize
expr_stmt|;
name|Sd
operator|->
name|mOrigSize
operator|=
name|OrigSize
expr_stmt|;
comment|//
comment|// Fill the first BITBUFSIZ bits
comment|//
name|FillBuf
argument_list|(
name|Sd
argument_list|,
name|BITBUFSIZ
argument_list|)
expr_stmt|;
comment|//
comment|// Decompress it
comment|//
name|Decode
argument_list|(
name|Sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sd
operator|->
name|mBadTableFlag
operator|!=
literal|0
condition|)
block|{
comment|//
comment|// Something wrong with the source
comment|//
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

end_unit

