begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Base PE/COFF loader supports loading any PE32/PE32+ or TE image, but   only supports relocating IA32, x64, IPF, and EBC images.    Caution: This file requires additional review when modified.   This library will have external input - PE/COFF image.   This external input must be validated carefully to avoid security issue like   buffer overflow, integer overflow.    The basic guideline is that caller need provide ImageContext->ImageRead () with the   necessary data range check, to make sure when this library reads PE/COFF image, the   PE image buffer is always in valid range.   This library will also do some additional check for PE header fields.    PeCoffLoaderGetPeHeader() routine will do basic check for PE/COFF header.   PeCoffLoaderGetImageInfo() routine will do basic check for whole PE/COFF image.    Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>   Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|"BasePeCoffLibInternals.h"
end_include

begin_comment
comment|/**   Adjust some fields in section header for TE image.    @param  SectionHeader             Pointer to the section header.   @param  TeStrippedOffset          Size adjust for the TE image.  **/
end_comment

begin_function
name|VOID
name|PeCoffLoaderAdjustOffsetForTeImage
parameter_list|(
name|EFI_IMAGE_SECTION_HEADER
modifier|*
name|SectionHeader
parameter_list|,
name|UINT32
name|TeStrippedOffset
parameter_list|)
block|{
name|SectionHeader
operator|->
name|VirtualAddress
operator|-=
name|TeStrippedOffset
expr_stmt|;
name|SectionHeader
operator|->
name|PointerToRawData
operator|-=
name|TeStrippedOffset
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Retrieves the magic value from the PE/COFF header.    @param  Hdr             The buffer in which to return the PE32, PE32+, or TE header.    @return EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC - Image is PE32   @return EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC - Image is PE32+  **/
end_comment

begin_function
name|UINT16
name|PeCoffLoaderGetPeHeaderMagicValue
parameter_list|(
name|IN
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
parameter_list|)
block|{
comment|//
comment|// NOTE: Some versions of Linux ELILO for Itanium have an incorrect magic value
comment|//       in the PE/COFF Header.  If the MachineType is Itanium(IA64) and the
comment|//       Magic value in the OptionalHeader is  EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
comment|//       then override the returned value to EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|Machine
operator|==
name|IMAGE_FILE_MACHINE_IA64
operator|&&
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
return|return
name|EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC
return|;
block|}
comment|//
comment|// Return the magic value from the PC/COFF Optional Header
comment|//
return|return
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|Magic
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the PE or TE Header from a PE/COFF or TE image.     Caution: This function may receive untrusted input.   PE/COFF image is external input, so this routine will    also done many checks in PE image to make sure PE image DosHeader, PeOptionHeader,    SizeOfHeader, Section Data Region and Security Data Region be in PE image range.     @param  ImageContext    The context of the image being loaded.   @param  Hdr             The buffer in which to return the PE32, PE32+, or TE header.    @retval RETURN_SUCCESS  The PE or TE Header is read.   @retval Other           The error status from reading the PE/COFF or TE image using the ImageRead function.  **/
end_comment

begin_function
name|RETURN_STATUS
name|PeCoffLoaderGetPeHeader
parameter_list|(
name|IN
name|OUT
name|PE_COFF_LOADER_IMAGE_CONTEXT
modifier|*
name|ImageContext
parameter_list|,
name|OUT
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|EFI_IMAGE_DOS_HEADER
name|DosHdr
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|UINTN
name|ReadSize
decl_stmt|;
name|UINT16
name|Magic
decl_stmt|;
name|UINT32
name|SectionHeaderOffset
decl_stmt|;
name|UINT32
name|Index
decl_stmt|;
name|UINT32
name|HeaderWithoutDataDir
decl_stmt|;
name|CHAR8
name|BufferData
decl_stmt|;
name|UINTN
name|NumberOfSections
decl_stmt|;
name|EFI_IMAGE_SECTION_HEADER
name|SectionHeader
decl_stmt|;
comment|//
comment|// Read the DOS image header to check for its existence
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DOS_HEADER
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
literal|0
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|DosHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DosHdr
operator|.
name|e_magic
operator|==
name|EFI_IMAGE_DOS_SIGNATURE
condition|)
block|{
comment|//
comment|// DOS image header is present, so read the PE header after the DOS image
comment|// header
comment|//
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|=
name|DosHdr
operator|.
name|e_lfanew
expr_stmt|;
block|}
comment|//
comment|// Read the PE/COFF Header. For PE32 (32-bit) this will read in too much
comment|// data, but that should not hurt anything. Hdr.Pe32->OptionalHeader.Magic
comment|// determines if this is a PE32 or PE32+ image. The magic is in the same
comment|// location in both images.
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_OPTIONAL_HEADER_UNION
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|ImageContext
operator|->
name|PeCoffHeaderOffset
argument_list|,
operator|&
name|Size
argument_list|,
name|Hdr
operator|.
name|Pe32
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
comment|//
comment|// Use Signature to figure out if we understand the image format
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|Signature
operator|==
name|EFI_TE_IMAGE_HEADER_SIGNATURE
condition|)
block|{
name|ImageContext
operator|->
name|IsTeImage
operator|=
name|TRUE
expr_stmt|;
name|ImageContext
operator|->
name|Machine
operator|=
name|Hdr
operator|.
name|Te
operator|->
name|Machine
expr_stmt|;
name|ImageContext
operator|->
name|ImageType
operator|=
call|(
name|UINT16
call|)
argument_list|(
name|Hdr
operator|.
name|Te
operator|->
name|Subsystem
argument_list|)
expr_stmt|;
comment|//
comment|// For TeImage, SectionAlignment is undefined to be set to Zero
comment|// ImageSize can be calculated.
comment|//
name|ImageContext
operator|->
name|ImageSize
operator|=
literal|0
expr_stmt|;
name|ImageContext
operator|->
name|SectionAlignment
operator|=
literal|0
expr_stmt|;
name|ImageContext
operator|->
name|SizeOfHeaders
operator|=
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
operator|+
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|BaseOfCode
operator|-
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
expr_stmt|;
comment|//
comment|// Check the StrippedSize.
comment|//
if|if
condition|(
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
operator|>=
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Check the SizeOfHeaders field.
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|BaseOfCode
operator|<=
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Read last byte of Hdr.Te->SizeOfHeaders from the file.
comment|//
name|Size
operator|=
literal|1
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|ImageContext
operator|->
name|SizeOfHeaders
operator|-
literal|1
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|BufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
comment|//
comment|// TE Image Data Directory Entry size is non-zero, but the Data Directory Virtual Address is zero.
comment|// This case is not a valid TE image.
comment|//
if|if
condition|(
operator|(
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|0
index|]
operator|.
name|Size
operator|!=
literal|0
operator|&&
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|0
index|]
operator|.
name|VirtualAddress
operator|==
literal|0
operator|)
operator|||
operator|(
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|Size
operator|!=
literal|0
operator|&&
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|VirtualAddress
operator|==
literal|0
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|Signature
operator|==
name|EFI_IMAGE_NT_SIGNATURE
condition|)
block|{
name|ImageContext
operator|->
name|IsTeImage
operator|=
name|FALSE
expr_stmt|;
name|ImageContext
operator|->
name|Machine
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|Machine
expr_stmt|;
name|Magic
operator|=
name|PeCoffLoaderGetPeHeaderMagicValue
argument_list|(
name|Hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// 1. Check OptionalHeader.NumberOfRvaAndSizes filed.
comment|//
if|if
condition|(
name|EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES
operator|<
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// 2. Check the FileHeader.SizeOfOptionalHeader field.
comment|// OptionalHeader.NumberOfRvaAndSizes is not bigger than 16, so
comment|// OptionalHeader.NumberOfRvaAndSizes * sizeof (EFI_IMAGE_DATA_DIRECTORY) will not overflow.
comment|//
name|HeaderWithoutDataDir
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_OPTIONAL_HEADER32
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DATA_DIRECTORY
argument_list|)
operator|*
name|EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
operator|-
name|HeaderWithoutDataDir
operator|)
operator|!=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
operator|*
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DATA_DIRECTORY
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|SectionHeaderOffset
operator|=
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_FILE_HEADER
argument_list|)
operator|+
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
expr_stmt|;
comment|//
comment|// 3. Check the FileHeader.NumberOfSections field.
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
operator|<=
name|SectionHeaderOffset
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
operator|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
operator|-
name|SectionHeaderOffset
operator|)
operator|/
name|EFI_IMAGE_SIZEOF_SECTION_HEADER
operator|<=
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|NumberOfSections
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// 4. Check the OptionalHeader.SizeOfHeaders field.
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|<=
name|SectionHeaderOffset
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|>=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
operator|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|-
name|SectionHeaderOffset
operator|)
operator|/
name|EFI_IMAGE_SIZEOF_SECTION_HEADER
operator|<
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|NumberOfSections
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// 4.2 Read last byte of Hdr.Pe32.OptionalHeader.SizeOfHeaders from the file.
comment|//
name|Size
operator|=
literal|1
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|-
literal|1
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|BufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
comment|//
comment|// Check the EFI_IMAGE_DIRECTORY_ENTRY_SECURITY data.
comment|// Read the last byte to make sure the data is in the image region.
comment|// The DataDirectory array begin with 1, not 0, so here use< to compare not<=.
comment|//
if|if
condition|(
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
operator|<
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
condition|)
block|{
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|Size
operator|!=
literal|0
condition|)
block|{
comment|//
comment|// Check the member data to avoid overflow.
comment|//
if|if
condition|(
call|(
name|UINT32
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|-
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|VirtualAddress
operator|<
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Read last byte of section header from file
comment|//
name|Size
operator|=
literal|1
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|VirtualAddress
operator|+
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|Size
operator|-
literal|1
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|BufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
block|}
block|}
comment|//
comment|// Use PE32 offset
comment|//
name|ImageContext
operator|->
name|ImageType
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|Subsystem
expr_stmt|;
name|ImageContext
operator|->
name|ImageSize
operator|=
operator|(
name|UINT64
operator|)
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
expr_stmt|;
name|ImageContext
operator|->
name|SectionAlignment
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SectionAlignment
expr_stmt|;
name|ImageContext
operator|->
name|SizeOfHeaders
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC
condition|)
block|{
comment|//
comment|// 1. Check FileHeader.NumberOfRvaAndSizes filed.
comment|//
if|if
condition|(
name|EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES
operator|<
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// 2. Check the FileHeader.SizeOfOptionalHeader field.
comment|// OptionalHeader.NumberOfRvaAndSizes is not bigger than 16, so
comment|// OptionalHeader.NumberOfRvaAndSizes * sizeof (EFI_IMAGE_DATA_DIRECTORY) will not overflow.
comment|//
name|HeaderWithoutDataDir
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_OPTIONAL_HEADER64
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DATA_DIRECTORY
argument_list|)
operator|*
name|EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
operator|-
name|HeaderWithoutDataDir
operator|)
operator|!=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
operator|*
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DATA_DIRECTORY
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|SectionHeaderOffset
operator|=
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_FILE_HEADER
argument_list|)
operator|+
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
expr_stmt|;
comment|//
comment|// 3. Check the FileHeader.NumberOfSections field.
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
operator|<=
name|SectionHeaderOffset
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
operator|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
operator|-
name|SectionHeaderOffset
operator|)
operator|/
name|EFI_IMAGE_SIZEOF_SECTION_HEADER
operator|<=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|FileHeader
operator|.
name|NumberOfSections
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// 4. Check the OptionalHeader.SizeOfHeaders field.
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|<=
name|SectionHeaderOffset
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|>=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
operator|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|-
name|SectionHeaderOffset
operator|)
operator|/
name|EFI_IMAGE_SIZEOF_SECTION_HEADER
operator|<
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|FileHeader
operator|.
name|NumberOfSections
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// 4.2 Read last byte of Hdr.Pe32Plus.OptionalHeader.SizeOfHeaders from the file.
comment|//
name|Size
operator|=
literal|1
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
operator|-
literal|1
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|BufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
comment|//
comment|// Check the EFI_IMAGE_DIRECTORY_ENTRY_SECURITY data.
comment|// Read the last byte to make sure the data is in the image region.
comment|// The DataDirectory array begin with 1, not 0, so here use< to compare not<=.
comment|//
if|if
condition|(
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
operator|<
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
condition|)
block|{
if|if
condition|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|Size
operator|!=
literal|0
condition|)
block|{
comment|//
comment|// Check the member data to avoid overflow.
comment|//
if|if
condition|(
call|(
name|UINT32
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|-
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|VirtualAddress
operator|<
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Read last byte of section header from file
comment|//
name|Size
operator|=
literal|1
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|VirtualAddress
operator|+
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_SECURITY
index|]
operator|.
name|Size
operator|-
literal|1
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|BufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
block|}
block|}
comment|//
comment|// Use PE32+ offset
comment|//
name|ImageContext
operator|->
name|ImageType
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|Subsystem
expr_stmt|;
name|ImageContext
operator|->
name|ImageSize
operator|=
operator|(
name|UINT64
operator|)
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfImage
expr_stmt|;
name|ImageContext
operator|->
name|SectionAlignment
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SectionAlignment
expr_stmt|;
name|ImageContext
operator|->
name|SizeOfHeaders
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
expr_stmt|;
block|}
else|else
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_MACHINE_TYPE
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
block|}
else|else
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_MACHINE_TYPE
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
if|if
condition|(
operator|!
name|PeCoffLoaderImageFormatSupported
argument_list|(
name|ImageContext
operator|->
name|Machine
argument_list|)
condition|)
block|{
comment|//
comment|// If the PE/COFF loader does not support the image type return
comment|// unsupported. This library can support lots of types of images
comment|// this does not mean the user of this library can call the entry
comment|// point of the image.
comment|//
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Check each section field.
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|IsTeImage
condition|)
block|{
name|SectionHeaderOffset
operator|=
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
expr_stmt|;
name|NumberOfSections
operator|=
call|(
name|UINTN
call|)
argument_list|(
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SectionHeaderOffset
operator|=
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_FILE_HEADER
argument_list|)
operator|+
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
expr_stmt|;
name|NumberOfSections
operator|=
call|(
name|UINTN
call|)
argument_list|(
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|NumberOfSections
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|NumberOfSections
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// Read section header from file
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|SectionHeaderOffset
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|SectionHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
comment|//
comment|// Adjust some field in Section Header for TE image.
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|IsTeImage
condition|)
block|{
name|PeCoffLoaderAdjustOffsetForTeImage
argument_list|(
operator|&
name|SectionHeader
argument_list|,
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
operator|-
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SectionHeader
operator|.
name|SizeOfRawData
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Section data should bigger than the Pe header.
comment|//
if|if
condition|(
name|SectionHeader
operator|.
name|VirtualAddress
operator|<
name|ImageContext
operator|->
name|SizeOfHeaders
operator|||
name|SectionHeader
operator|.
name|PointerToRawData
operator|<
name|ImageContext
operator|->
name|SizeOfHeaders
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Check the member data to avoid overflow.
comment|//
if|if
condition|(
call|(
name|UINT32
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|-
name|SectionHeader
operator|.
name|PointerToRawData
operator|<
name|SectionHeader
operator|.
name|SizeOfRawData
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
comment|//
comment|// Base on the ImageRead function to check the section data field.
comment|// Read the last byte to make sure the data is in the image region.
comment|//
name|Size
operator|=
literal|1
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|SectionHeader
operator|.
name|PointerToRawData
operator|+
name|SectionHeader
operator|.
name|SizeOfRawData
operator|-
literal|1
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|BufferData
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
block|}
comment|//
comment|// Check next section.
comment|//
name|SectionHeaderOffset
operator|+=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves information about a PE/COFF image.    Computes the PeCoffHeaderOffset, IsTeImage, ImageType, ImageAddress, ImageSize,    DestinationAddress, RelocationsStripped, SectionAlignment, SizeOfHeaders, and    DebugDirectoryEntryRva fields of the ImageContext structure.     If ImageContext is NULL, then return RETURN_INVALID_PARAMETER.     If the PE/COFF image accessed through the ImageRead service in the ImageContext    structure is not a supported PE/COFF image type, then return RETURN_UNSUPPORTED.     If any errors occur while computing the fields of ImageContext,    then the error status is returned in the ImageError field of ImageContext.     If the image is a TE image, then SectionAlignment is set to 0.   The ImageRead and Handle fields of ImageContext structure must be valid prior    to invoking this service.    Caution: This function may receive untrusted input.   PE/COFF image is external input, so this routine will    also done many checks in PE image to make sure PE image DosHeader, PeOptionHeader,    SizeOfHeader, Section Data Region and Security Data Region be in PE image range.     @param  ImageContext              The pointer to the image context structure that describes the PE/COFF                                     image that needs to be examined by this function.    @retval RETURN_SUCCESS            The information on the PE/COFF image was collected.   @retval RETURN_INVALID_PARAMETER  ImageContext is NULL.   @retval RETURN_UNSUPPORTED        The PE/COFF image is not supported.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|PeCoffLoaderGetImageInfo
parameter_list|(
name|IN
name|OUT
name|PE_COFF_LOADER_IMAGE_CONTEXT
modifier|*
name|ImageContext
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_UNION
name|HdrData
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|EFI_IMAGE_DATA_DIRECTORY
modifier|*
name|DebugDirectoryEntry
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|UINTN
name|ReadSize
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|UINTN
name|DebugDirectoryEntryRva
decl_stmt|;
name|UINTN
name|DebugDirectoryEntryFileOffset
decl_stmt|;
name|UINTN
name|SectionHeaderOffset
decl_stmt|;
name|EFI_IMAGE_SECTION_HEADER
name|SectionHeader
decl_stmt|;
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
name|DebugEntry
decl_stmt|;
name|UINT32
name|NumberOfRvaAndSizes
decl_stmt|;
name|UINT16
name|Magic
decl_stmt|;
name|UINT32
name|TeStrippedOffset
decl_stmt|;
if|if
condition|(
name|ImageContext
operator|==
name|NULL
condition|)
block|{
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// Assume success
comment|//
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_SUCCESS
expr_stmt|;
name|Hdr
operator|.
name|Union
operator|=
operator|&
name|HdrData
expr_stmt|;
name|Status
operator|=
name|PeCoffLoaderGetPeHeader
argument_list|(
name|ImageContext
argument_list|,
name|Hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
name|Magic
operator|=
name|PeCoffLoaderGetPeHeaderMagicValue
argument_list|(
name|Hdr
argument_list|)
expr_stmt|;
comment|//
comment|// Retrieve the base address of the image
comment|//
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
name|TeStrippedOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|ImageContext
operator|->
name|ImageAddress
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|ImageBase
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|ImageContext
operator|->
name|ImageAddress
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|ImageBase
expr_stmt|;
block|}
block|}
else|else
block|{
name|TeStrippedOffset
operator|=
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
operator|-
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
expr_stmt|;
name|ImageContext
operator|->
name|ImageAddress
operator|=
call|(
name|PHYSICAL_ADDRESS
call|)
argument_list|(
name|Hdr
operator|.
name|Te
operator|->
name|ImageBase
operator|+
name|TeStrippedOffset
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Initialize the alternate destination address to 0 indicating that it
comment|// should not be used.
comment|//
name|ImageContext
operator|->
name|DestinationAddress
operator|=
literal|0
expr_stmt|;
comment|//
comment|// Initialize the debug codeview pointer.
comment|//
name|ImageContext
operator|->
name|DebugDirectoryEntryRva
operator|=
literal|0
expr_stmt|;
name|ImageContext
operator|->
name|CodeView
operator|=
name|NULL
expr_stmt|;
name|ImageContext
operator|->
name|PdbPointer
operator|=
name|NULL
expr_stmt|;
comment|//
comment|// Three cases with regards to relocations:
comment|// - Image has base relocs, RELOCS_STRIPPED==0    => image is relocatable
comment|// - Image has no base relocs, RELOCS_STRIPPED==1 => Image is not relocatable
comment|// - Image has no base relocs, RELOCS_STRIPPED==0 => Image is relocatable but
comment|//   has no base relocs to apply
comment|// Obviously having base relocations with RELOCS_STRIPPED==1 is invalid.
comment|//
comment|// Look at the file header to determine if relocations have been stripped, and
comment|// save this information in the image context for later use.
comment|//
if|if
condition|(
operator|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
operator|)
operator|&&
operator|(
operator|(
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|Characteristics
operator|&
name|EFI_IMAGE_FILE_RELOCS_STRIPPED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|RelocationsStripped
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
operator|&&
operator|(
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|0
index|]
operator|.
name|Size
operator|==
literal|0
operator|)
operator|&&
operator|(
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|0
index|]
operator|.
name|VirtualAddress
operator|==
literal|0
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|RelocationsStripped
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ImageContext
operator|->
name|RelocationsStripped
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DebugDirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
operator|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DebugDirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
operator|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|NumberOfRvaAndSizes
operator|>
name|EFI_IMAGE_DIRECTORY_ENTRY_DEBUG
condition|)
block|{
name|DebugDirectoryEntryRva
operator|=
name|DebugDirectoryEntry
operator|->
name|VirtualAddress
expr_stmt|;
comment|//
comment|// Determine the file offset of the debug directory...  This means we walk
comment|// the sections to find which section contains the RVA of the debug
comment|// directory
comment|//
name|DebugDirectoryEntryFileOffset
operator|=
literal|0
expr_stmt|;
name|SectionHeaderOffset
operator|=
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_FILE_HEADER
argument_list|)
operator|+
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|NumberOfSections
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// Read section header from file
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|SectionHeaderOffset
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|SectionHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
if|if
condition|(
name|DebugDirectoryEntryRva
operator|>=
name|SectionHeader
operator|.
name|VirtualAddress
operator|&&
name|DebugDirectoryEntryRva
operator|<
name|SectionHeader
operator|.
name|VirtualAddress
operator|+
name|SectionHeader
operator|.
name|Misc
operator|.
name|VirtualSize
condition|)
block|{
name|DebugDirectoryEntryFileOffset
operator|=
name|DebugDirectoryEntryRva
operator|-
name|SectionHeader
operator|.
name|VirtualAddress
operator|+
name|SectionHeader
operator|.
name|PointerToRawData
expr_stmt|;
break|break;
block|}
name|SectionHeaderOffset
operator|+=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DebugDirectoryEntryFileOffset
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|DebugDirectoryEntry
operator|->
name|Size
condition|;
name|Index
operator|+=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
argument_list|)
control|)
block|{
comment|//
comment|// Read next debug directory entry
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|DebugDirectoryEntryFileOffset
operator|+
name|Index
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|DebugEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
comment|//
comment|// From PeCoff spec, when DebugEntry.RVA == 0 means this debug info will not load into memory.
comment|// Here we will always load EFI_IMAGE_DEBUG_TYPE_CODEVIEW type debug info. so need adjust the
comment|// ImageContext->ImageSize when DebugEntry.RVA == 0.
comment|//
if|if
condition|(
name|DebugEntry
operator|.
name|Type
operator|==
name|EFI_IMAGE_DEBUG_TYPE_CODEVIEW
condition|)
block|{
name|ImageContext
operator|->
name|DebugDirectoryEntryRva
operator|=
call|(
name|UINT32
call|)
argument_list|(
name|DebugDirectoryEntryRva
operator|+
name|Index
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugEntry
operator|.
name|RVA
operator|==
literal|0
operator|&&
name|DebugEntry
operator|.
name|FileOffset
operator|!=
literal|0
condition|)
block|{
name|ImageContext
operator|->
name|ImageSize
operator|+=
name|DebugEntry
operator|.
name|SizeOfData
expr_stmt|;
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|DebugDirectoryEntry
operator|=
operator|&
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|1
index|]
expr_stmt|;
name|DebugDirectoryEntryRva
operator|=
name|DebugDirectoryEntry
operator|->
name|VirtualAddress
expr_stmt|;
name|SectionHeaderOffset
operator|=
call|(
name|UINTN
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
name|DebugDirectoryEntryFileOffset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
condition|;
control|)
block|{
comment|//
comment|// Read section header from file
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|SectionHeaderOffset
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|SectionHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
if|if
condition|(
name|DebugDirectoryEntryRva
operator|>=
name|SectionHeader
operator|.
name|VirtualAddress
operator|&&
name|DebugDirectoryEntryRva
operator|<
name|SectionHeader
operator|.
name|VirtualAddress
operator|+
name|SectionHeader
operator|.
name|Misc
operator|.
name|VirtualSize
condition|)
block|{
name|DebugDirectoryEntryFileOffset
operator|=
name|DebugDirectoryEntryRva
operator|-
name|SectionHeader
operator|.
name|VirtualAddress
operator|+
name|SectionHeader
operator|.
name|PointerToRawData
operator|-
name|TeStrippedOffset
expr_stmt|;
comment|//
comment|// File offset of the debug directory was found, if this is not the last
comment|// section, then skip to the last section for calculating the image size.
comment|//
if|if
condition|(
name|Index
operator|<
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
operator|-
literal|1
condition|)
block|{
name|SectionHeaderOffset
operator|+=
operator|(
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
operator|-
literal|1
operator|-
name|Index
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
name|Index
operator|=
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|//
comment|// In Te image header there is not a field to describe the ImageSize.
comment|// Actually, the ImageSize equals the RVA plus the VirtualSize of
comment|// the last section mapped into memory (Must be rounded up to
comment|// a multiple of Section Alignment). Per the PE/COFF specification, the
comment|// section headers in the Section Table must appear in order of the RVA
comment|// values for the corresponding sections. So the ImageSize can be determined
comment|// by the RVA and the VirtualSize of the last section header in the
comment|// Section Table.
comment|//
if|if
condition|(
operator|(
operator|++
name|Index
operator|)
operator|==
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
condition|)
block|{
name|ImageContext
operator|->
name|ImageSize
operator|=
operator|(
name|SectionHeader
operator|.
name|VirtualAddress
operator|+
name|SectionHeader
operator|.
name|Misc
operator|.
name|VirtualSize
operator|)
operator|-
name|TeStrippedOffset
expr_stmt|;
block|}
name|SectionHeaderOffset
operator|+=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_SECTION_HEADER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DebugDirectoryEntryFileOffset
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|DebugDirectoryEntry
operator|->
name|Size
condition|;
name|Index
operator|+=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
argument_list|)
control|)
block|{
comment|//
comment|// Read next debug directory entry
comment|//
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
argument_list|)
expr_stmt|;
name|ReadSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|DebugDirectoryEntryFileOffset
operator|+
name|Index
argument_list|,
operator|&
name|Size
argument_list|,
operator|&
name|DebugEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
operator|(
name|Size
operator|!=
name|ReadSize
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|ReadSize
condition|)
block|{
name|Status
operator|=
name|RETURN_UNSUPPORTED
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
if|if
condition|(
name|DebugEntry
operator|.
name|Type
operator|==
name|EFI_IMAGE_DEBUG_TYPE_CODEVIEW
condition|)
block|{
name|ImageContext
operator|->
name|DebugDirectoryEntryRva
operator|=
call|(
name|UINT32
call|)
argument_list|(
name|DebugDirectoryEntryRva
operator|+
name|Index
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
block|}
block|}
block|}
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Converts an image address to the loaded address.    @param  ImageContext      The context of the image being loaded.   @param  Address           The address to be converted to the loaded address.   @param  TeStrippedOffset  Stripped offset for TE image.    @return The converted address or NULL if the address can not be converted.  **/
end_comment

begin_function
name|VOID
modifier|*
name|PeCoffLoaderImageAddress
parameter_list|(
name|IN
name|OUT
name|PE_COFF_LOADER_IMAGE_CONTEXT
modifier|*
name|ImageContext
parameter_list|,
name|IN
name|UINTN
name|Address
parameter_list|,
name|IN
name|UINTN
name|TeStrippedOffset
parameter_list|)
block|{
comment|//
comment|// Make sure that Address and ImageSize is correct for the loaded image.
comment|//
if|if
condition|(
name|Address
operator|>=
name|ImageContext
operator|->
name|ImageSize
operator|+
name|TeStrippedOffset
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_IMAGE_ADDRESS
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|CHAR8
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
operator|+
name|Address
operator|-
name|TeStrippedOffset
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Applies relocation fixups to a PE/COFF image that was loaded with PeCoffLoaderLoadImage().    If the DestinationAddress field of ImageContext is 0, then use the ImageAddress field of   ImageContext as the relocation base address.  Otherwise, use the DestinationAddress field   of ImageContext as the relocation base address.  The caller must allocate the relocation   fixup log buffer and fill in the FixupData field of ImageContext prior to calling this function.      The ImageRead, Handle, PeCoffHeaderOffset,  IsTeImage, Machine, ImageType, ImageAddress,    ImageSize, DestinationAddress, RelocationsStripped, SectionAlignment, SizeOfHeaders,    DebugDirectoryEntryRva, EntryPoint, FixupDataSize, CodeView, PdbPointer, and FixupData of    the ImageContext structure must be valid prior to invoking this service.        If ImageContext is NULL, then ASSERT().    Note that if the platform does not maintain coherency between the instruction cache(s) and the data   cache(s) in hardware, then the caller is responsible for performing cache maintenance operations   prior to transferring control to a PE/COFF image that is loaded using this library.    @param  ImageContext        The pointer to the image context structure that describes the PE/COFF                               image that is being relocated.    @retval RETURN_SUCCESS      The PE/COFF image was relocated.                               Extended status information is in the ImageError field of ImageContext.   @retval RETURN_LOAD_ERROR   The image in not a valid PE/COFF image.                               Extended status information is in the ImageError field of ImageContext.   @retval RETURN_UNSUPPORTED  A relocation record type is not supported.                               Extended status information is in the ImageError field of ImageContext.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|PeCoffLoaderRelocateImage
parameter_list|(
name|IN
name|OUT
name|PE_COFF_LOADER_IMAGE_CONTEXT
modifier|*
name|ImageContext
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|EFI_IMAGE_DATA_DIRECTORY
modifier|*
name|RelocDir
decl_stmt|;
name|UINT64
name|Adjust
decl_stmt|;
name|EFI_IMAGE_BASE_RELOCATION
modifier|*
name|RelocBaseOrg
decl_stmt|;
name|EFI_IMAGE_BASE_RELOCATION
modifier|*
name|RelocBase
decl_stmt|;
name|EFI_IMAGE_BASE_RELOCATION
modifier|*
name|RelocBaseEnd
decl_stmt|;
name|UINT16
modifier|*
name|Reloc
decl_stmt|;
name|UINT16
modifier|*
name|RelocEnd
decl_stmt|;
name|CHAR8
modifier|*
name|Fixup
decl_stmt|;
name|CHAR8
modifier|*
name|FixupBase
decl_stmt|;
name|UINT16
modifier|*
name|Fixup16
decl_stmt|;
name|UINT32
modifier|*
name|Fixup32
decl_stmt|;
name|UINT64
modifier|*
name|Fixup64
decl_stmt|;
name|CHAR8
modifier|*
name|FixupData
decl_stmt|;
name|PHYSICAL_ADDRESS
name|BaseAddress
decl_stmt|;
name|UINT32
name|NumberOfRvaAndSizes
decl_stmt|;
name|UINT16
name|Magic
decl_stmt|;
name|UINT32
name|TeStrippedOffset
decl_stmt|;
name|ASSERT
argument_list|(
name|ImageContext
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Assume success
comment|//
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_SUCCESS
expr_stmt|;
comment|//
comment|// If there are no relocation entries, then we are done
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|RelocationsStripped
condition|)
block|{
comment|// Applies additional environment specific actions to relocate fixups
comment|// to a PE/COFF image if needed
name|PeCoffLoaderRelocateImageExtraAction
argument_list|(
name|ImageContext
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
comment|//
comment|// If the destination address is not 0, use that rather than the
comment|// image address as the relocation target.
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|DestinationAddress
operator|!=
literal|0
condition|)
block|{
name|BaseAddress
operator|=
name|ImageContext
operator|->
name|DestinationAddress
expr_stmt|;
block|}
else|else
block|{
name|BaseAddress
operator|=
name|ImageContext
operator|->
name|ImageAddress
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
operator|+
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|)
expr_stmt|;
name|TeStrippedOffset
operator|=
literal|0
expr_stmt|;
name|Magic
operator|=
name|PeCoffLoaderGetPeHeaderMagicValue
argument_list|(
name|Hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|Adjust
operator|=
operator|(
name|UINT64
operator|)
name|BaseAddress
operator|-
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|ImageBase
expr_stmt|;
if|if
condition|(
name|Adjust
operator|!=
literal|0
condition|)
block|{
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|ImageBase
operator|=
operator|(
name|UINT32
operator|)
name|BaseAddress
expr_stmt|;
block|}
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|RelocDir
operator|=
operator|&
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|Adjust
operator|=
operator|(
name|UINT64
operator|)
name|BaseAddress
operator|-
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|ImageBase
expr_stmt|;
if|if
condition|(
name|Adjust
operator|!=
literal|0
condition|)
block|{
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|ImageBase
operator|=
operator|(
name|UINT64
operator|)
name|BaseAddress
expr_stmt|;
block|}
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|RelocDir
operator|=
operator|&
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
index|]
expr_stmt|;
block|}
comment|//
comment|// Find the relocation block
comment|// Per the PE/COFF spec, you can't assume that a given data directory
comment|// is present in the image. You have to check the NumberOfRvaAndSizes in
comment|// the optional header to verify a desired directory entry is there.
comment|//
if|if
condition|(
operator|(
name|NumberOfRvaAndSizes
operator|<
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
operator|)
condition|)
block|{
name|RelocDir
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|Hdr
operator|.
name|Te
operator|=
operator|(
name|EFI_TE_IMAGE_HEADER
operator|*
operator|)
call|(
name|UINTN
call|)
argument_list|(
name|ImageContext
operator|->
name|ImageAddress
argument_list|)
expr_stmt|;
name|TeStrippedOffset
operator|=
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
operator|-
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
expr_stmt|;
name|Adjust
operator|=
call|(
name|UINT64
call|)
argument_list|(
name|BaseAddress
operator|-
operator|(
name|Hdr
operator|.
name|Te
operator|->
name|ImageBase
operator|+
name|TeStrippedOffset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Adjust
operator|!=
literal|0
condition|)
block|{
name|Hdr
operator|.
name|Te
operator|->
name|ImageBase
operator|=
call|(
name|UINT64
call|)
argument_list|(
name|BaseAddress
operator|-
name|TeStrippedOffset
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Find the relocation block
comment|//
name|RelocDir
operator|=
operator|&
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|RelocDir
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|RelocDir
operator|->
name|Size
operator|>
literal|0
operator|)
condition|)
block|{
name|RelocBase
operator|=
operator|(
name|EFI_IMAGE_BASE_RELOCATION
operator|*
operator|)
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|RelocDir
operator|->
name|VirtualAddress
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
name|RelocBaseEnd
operator|=
operator|(
name|EFI_IMAGE_BASE_RELOCATION
operator|*
operator|)
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|RelocDir
operator|->
name|VirtualAddress
operator|+
name|RelocDir
operator|->
name|Size
operator|-
literal|1
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|RelocBase
operator|==
name|NULL
operator|||
name|RelocBaseEnd
operator|==
name|NULL
operator|||
name|RelocBaseEnd
operator|<
name|RelocBase
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
block|}
else|else
block|{
comment|//
comment|// Set base and end to bypass processing below.
comment|//
name|RelocBase
operator|=
name|RelocBaseEnd
operator|=
name|NULL
expr_stmt|;
block|}
name|RelocBaseOrg
operator|=
name|RelocBase
expr_stmt|;
comment|//
comment|// If Adjust is not zero, then apply fix ups to the image
comment|//
if|if
condition|(
name|Adjust
operator|!=
literal|0
condition|)
block|{
comment|//
comment|// Run the relocation information and apply the fixups
comment|//
name|FixupData
operator|=
name|ImageContext
operator|->
name|FixupData
expr_stmt|;
while|while
condition|(
name|RelocBase
operator|<
name|RelocBaseEnd
condition|)
block|{
name|Reloc
operator|=
operator|(
name|UINT16
operator|*
operator|)
operator|(
operator|(
name|CHAR8
operator|*
operator|)
name|RelocBase
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_BASE_RELOCATION
argument_list|)
operator|)
expr_stmt|;
comment|//
comment|// Add check for RelocBase->SizeOfBlock field.
comment|//
if|if
condition|(
name|RelocBase
operator|->
name|SizeOfBlock
operator|==
literal|0
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|UINTN
operator|)
name|RelocBase
operator|>
name|MAX_ADDRESS
operator|-
name|RelocBase
operator|->
name|SizeOfBlock
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
name|RelocEnd
operator|=
operator|(
name|UINT16
operator|*
operator|)
operator|(
operator|(
name|CHAR8
operator|*
operator|)
name|RelocBase
operator|+
name|RelocBase
operator|->
name|SizeOfBlock
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|UINTN
operator|)
name|RelocEnd
operator|>
operator|(
name|UINTN
operator|)
name|RelocBaseOrg
operator|+
name|RelocDir
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
name|FixupBase
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|RelocBase
operator|->
name|VirtualAddress
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|FixupBase
operator|==
name|NULL
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
comment|//
comment|// Run this relocation record
comment|//
while|while
condition|(
name|Reloc
operator|<
name|RelocEnd
condition|)
block|{
name|Fixup
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|RelocBase
operator|->
name|VirtualAddress
operator|+
operator|(
operator|*
name|Reloc
operator|&
literal|0xFFF
operator|)
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fixup
operator|==
name|NULL
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
switch|switch
condition|(
operator|(
operator|*
name|Reloc
operator|)
operator|>>
literal|12
condition|)
block|{
case|case
name|EFI_IMAGE_REL_BASED_ABSOLUTE
case|:
break|break;
case|case
name|EFI_IMAGE_REL_BASED_HIGH
case|:
name|Fixup16
operator|=
operator|(
name|UINT16
operator|*
operator|)
name|Fixup
expr_stmt|;
operator|*
name|Fixup16
operator|=
call|(
name|UINT16
call|)
argument_list|(
operator|*
name|Fixup16
operator|+
operator|(
call|(
name|UINT16
call|)
argument_list|(
operator|(
name|UINT32
operator|)
name|Adjust
operator|>>
literal|16
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FixupData
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|UINT16
operator|*
operator|)
name|FixupData
operator|=
operator|*
name|Fixup16
expr_stmt|;
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EFI_IMAGE_REL_BASED_LOW
case|:
name|Fixup16
operator|=
operator|(
name|UINT16
operator|*
operator|)
name|Fixup
expr_stmt|;
operator|*
name|Fixup16
operator|=
call|(
name|UINT16
call|)
argument_list|(
operator|*
name|Fixup16
operator|+
operator|(
name|UINT16
operator|)
name|Adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|FixupData
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|UINT16
operator|*
operator|)
name|FixupData
operator|=
operator|*
name|Fixup16
expr_stmt|;
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EFI_IMAGE_REL_BASED_HIGHLOW
case|:
name|Fixup32
operator|=
operator|(
name|UINT32
operator|*
operator|)
name|Fixup
expr_stmt|;
operator|*
name|Fixup32
operator|=
operator|*
name|Fixup32
operator|+
operator|(
name|UINT32
operator|)
name|Adjust
expr_stmt|;
if|if
condition|(
name|FixupData
operator|!=
name|NULL
condition|)
block|{
name|FixupData
operator|=
name|ALIGN_POINTER
argument_list|(
name|FixupData
argument_list|,
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|FixupData
operator|=
operator|*
name|Fixup32
expr_stmt|;
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EFI_IMAGE_REL_BASED_DIR64
case|:
name|Fixup64
operator|=
operator|(
name|UINT64
operator|*
operator|)
name|Fixup
expr_stmt|;
operator|*
name|Fixup64
operator|=
operator|*
name|Fixup64
operator|+
operator|(
name|UINT64
operator|)
name|Adjust
expr_stmt|;
if|if
condition|(
name|FixupData
operator|!=
name|NULL
condition|)
block|{
name|FixupData
operator|=
name|ALIGN_POINTER
argument_list|(
name|FixupData
argument_list|,
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|UINT64
operator|*
operator|)
operator|(
name|FixupData
operator|)
operator|=
operator|*
name|Fixup64
expr_stmt|;
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|//
comment|// The common code does not handle some of the stranger IPF relocations
comment|// PeCoffLoaderRelocateImageEx () adds support for these complex fixups
comment|// on IPF and is a No-Op on other architectures.
comment|//
name|Status
operator|=
name|PeCoffLoaderRelocateImageEx
argument_list|(
name|Reloc
argument_list|,
name|Fixup
argument_list|,
operator|&
name|FixupData
argument_list|,
name|Adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|Status
return|;
block|}
block|}
comment|//
comment|// Next relocation record
comment|//
name|Reloc
operator|+=
literal|1
expr_stmt|;
block|}
comment|//
comment|// Next reloc block
comment|//
name|RelocBase
operator|=
operator|(
name|EFI_IMAGE_BASE_RELOCATION
operator|*
operator|)
name|RelocEnd
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|UINTN
operator|)
name|FixupData
operator|<=
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|FixupData
operator|+
name|ImageContext
operator|->
name|FixupDataSize
argument_list|)
expr_stmt|;
comment|//
comment|// Adjust the EntryPoint to match the linked-to address
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|DestinationAddress
operator|!=
literal|0
condition|)
block|{
name|ImageContext
operator|->
name|EntryPoint
operator|-=
operator|(
name|UINT64
operator|)
name|ImageContext
operator|->
name|ImageAddress
expr_stmt|;
name|ImageContext
operator|->
name|EntryPoint
operator|+=
operator|(
name|UINT64
operator|)
name|ImageContext
operator|->
name|DestinationAddress
expr_stmt|;
block|}
block|}
comment|// Applies additional environment specific actions to relocate fixups
comment|// to a PE/COFF image if needed
name|PeCoffLoaderRelocateImageExtraAction
argument_list|(
name|ImageContext
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Loads a PE/COFF image into memory.    Loads the PE/COFF image accessed through the ImageRead service of ImageContext into the buffer   specified by the ImageAddress and ImageSize fields of ImageContext.  The caller must allocate   the load buffer and fill in the ImageAddress and ImageSize fields prior to calling this function.   The EntryPoint, FixupDataSize, CodeView, PdbPointer and HiiResourceData fields of ImageContext are computed.   The ImageRead, Handle, PeCoffHeaderOffset,  IsTeImage,  Machine, ImageType, ImageAddress, ImageSize,    DestinationAddress, RelocationsStripped, SectionAlignment, SizeOfHeaders, and DebugDirectoryEntryRva    fields of the ImageContext structure must be valid prior to invoking this service.      If ImageContext is NULL, then ASSERT().    Note that if the platform does not maintain coherency between the instruction cache(s) and the data   cache(s) in hardware, then the caller is responsible for performing cache maintenance operations   prior to transferring control to a PE/COFF image that is loaded using this library.    @param  ImageContext              The pointer to the image context structure that describes the PE/COFF                                     image that is being loaded.    @retval RETURN_SUCCESS            The PE/COFF image was loaded into the buffer specified by                                     the ImageAddress and ImageSize fields of ImageContext.                                     Extended status information is in the ImageError field of ImageContext.   @retval RETURN_BUFFER_TOO_SMALL   The caller did not provide a large enough buffer.                                     Extended status information is in the ImageError field of ImageContext.   @retval RETURN_LOAD_ERROR         The PE/COFF image is an EFI Runtime image with no relocations.                                     Extended status information is in the ImageError field of ImageContext.   @retval RETURN_INVALID_PARAMETER  The image address is invalid.                                     Extended status information is in the ImageError field of ImageContext.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|PeCoffLoaderLoadImage
parameter_list|(
name|IN
name|OUT
name|PE_COFF_LOADER_IMAGE_CONTEXT
modifier|*
name|ImageContext
parameter_list|)
block|{
name|RETURN_STATUS
name|Status
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|PE_COFF_LOADER_IMAGE_CONTEXT
name|CheckContext
decl_stmt|;
name|EFI_IMAGE_SECTION_HEADER
modifier|*
name|FirstSection
decl_stmt|;
name|EFI_IMAGE_SECTION_HEADER
modifier|*
name|Section
decl_stmt|;
name|UINTN
name|NumberOfSections
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|CHAR8
modifier|*
name|Base
decl_stmt|;
name|CHAR8
modifier|*
name|End
decl_stmt|;
name|EFI_IMAGE_DATA_DIRECTORY
modifier|*
name|DirectoryEntry
decl_stmt|;
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
modifier|*
name|DebugEntry
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|UINT32
name|TempDebugEntryRva
decl_stmt|;
name|UINT32
name|NumberOfRvaAndSizes
decl_stmt|;
name|UINT16
name|Magic
decl_stmt|;
name|EFI_IMAGE_RESOURCE_DIRECTORY
modifier|*
name|ResourceDirectory
decl_stmt|;
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
modifier|*
name|ResourceDirectoryEntry
decl_stmt|;
name|EFI_IMAGE_RESOURCE_DIRECTORY_STRING
modifier|*
name|ResourceDirectoryString
decl_stmt|;
name|EFI_IMAGE_RESOURCE_DATA_ENTRY
modifier|*
name|ResourceDataEntry
decl_stmt|;
name|CHAR16
modifier|*
name|String
decl_stmt|;
name|UINT32
name|Offset
decl_stmt|;
name|UINT32
name|TeStrippedOffset
decl_stmt|;
name|ASSERT
argument_list|(
name|ImageContext
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Assume success
comment|//
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_SUCCESS
expr_stmt|;
comment|//
comment|// Copy the provided context information into our local version, get what we
comment|// can from the original image, and then use that to make sure everything
comment|// is legit.
comment|//
name|CopyMem
argument_list|(
operator|&
name|CheckContext
argument_list|,
name|ImageContext
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_COFF_LOADER_IMAGE_CONTEXT
argument_list|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|PeCoffLoaderGetImageInfo
argument_list|(
operator|&
name|CheckContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
comment|//
comment|// Make sure there is enough allocated space for the image being loaded
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|ImageSize
operator|<
name|CheckContext
operator|.
name|ImageSize
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_IMAGE_SIZE
expr_stmt|;
return|return
name|RETURN_BUFFER_TOO_SMALL
return|;
block|}
if|if
condition|(
name|ImageContext
operator|->
name|ImageAddress
operator|==
literal|0
condition|)
block|{
comment|//
comment|// Image cannot be loaded into 0 address.
comment|//
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_IMAGE_ADDRESS
expr_stmt|;
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// If there's no relocations, then make sure it's not a runtime driver,
comment|// and that it's being loaded at the linked address.
comment|//
if|if
condition|(
name|CheckContext
operator|.
name|RelocationsStripped
condition|)
block|{
comment|//
comment|// If the image does not contain relocations and it is a runtime driver
comment|// then return an error.
comment|//
if|if
condition|(
name|CheckContext
operator|.
name|ImageType
operator|==
name|EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_SUBSYSTEM
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
comment|//
comment|// If the image does not contain relocations, and the requested load address
comment|// is not the linked address, then return an error.
comment|//
if|if
condition|(
name|CheckContext
operator|.
name|ImageAddress
operator|!=
name|ImageContext
operator|->
name|ImageAddress
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_IMAGE_ADDRESS
expr_stmt|;
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
block|}
comment|//
comment|// Make sure the allocated space has the proper section alignment
comment|//
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ImageContext
operator|->
name|ImageAddress
operator|&
operator|(
name|CheckContext
operator|.
name|SectionAlignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_INVALID_SECTION_ALIGNMENT
expr_stmt|;
return|return
name|RETURN_INVALID_PARAMETER
return|;
block|}
block|}
comment|//
comment|// Read the entire PE/COFF or TE header into memory
comment|//
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
literal|0
argument_list|,
operator|&
name|ImageContext
operator|->
name|SizeOfHeaders
argument_list|,
operator|(
name|VOID
operator|*
operator|)
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
operator|+
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|)
expr_stmt|;
name|FirstSection
operator|=
operator|(
name|EFI_IMAGE_SECTION_HEADER
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
operator|+
name|ImageContext
operator|->
name|PeCoffHeaderOffset
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_FILE_HEADER
argument_list|)
operator|+
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|SizeOfOptionalHeader
operator|)
expr_stmt|;
name|NumberOfSections
operator|=
call|(
name|UINTN
call|)
argument_list|(
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|NumberOfSections
argument_list|)
expr_stmt|;
name|TeStrippedOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
literal|0
argument_list|,
operator|&
name|ImageContext
operator|->
name|SizeOfHeaders
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|Te
operator|=
operator|(
name|EFI_TE_IMAGE_HEADER
operator|*
operator|)
call|(
name|UINTN
call|)
argument_list|(
name|ImageContext
operator|->
name|ImageAddress
argument_list|)
expr_stmt|;
name|FirstSection
operator|=
operator|(
name|EFI_IMAGE_SECTION_HEADER
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageContext
operator|->
name|ImageAddress
operator|+
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
operator|)
expr_stmt|;
name|NumberOfSections
operator|=
call|(
name|UINTN
call|)
argument_list|(
name|Hdr
operator|.
name|Te
operator|->
name|NumberOfSections
argument_list|)
expr_stmt|;
name|TeStrippedOffset
operator|=
operator|(
name|UINT32
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
operator|-
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
comment|//
comment|// Load each section of the image
comment|//
name|Section
operator|=
name|FirstSection
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|NumberOfSections
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// Read the section
comment|//
name|Size
operator|=
operator|(
name|UINTN
operator|)
name|Section
operator|->
name|Misc
operator|.
name|VirtualSize
expr_stmt|;
if|if
condition|(
operator|(
name|Size
operator|==
literal|0
operator|)
operator|||
operator|(
name|Size
operator|>
name|Section
operator|->
name|SizeOfRawData
operator|)
condition|)
block|{
name|Size
operator|=
operator|(
name|UINTN
operator|)
name|Section
operator|->
name|SizeOfRawData
expr_stmt|;
block|}
comment|//
comment|// Compute sections address
comment|//
name|Base
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|Section
operator|->
name|VirtualAddress
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
name|End
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|Section
operator|->
name|VirtualAddress
operator|+
name|Section
operator|->
name|Misc
operator|.
name|VirtualSize
operator|-
literal|1
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
comment|//
comment|// If the size of the section is non-zero and the base address or end address resolved to 0, then fail.
comment|//
if|if
condition|(
operator|(
name|Size
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|Base
operator|==
name|NULL
operator|)
operator|||
operator|(
name|End
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_SECTION_NOT_LOADED
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
if|if
condition|(
name|Section
operator|->
name|SizeOfRawData
operator|>
literal|0
condition|)
block|{
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|Section
operator|->
name|PointerToRawData
operator|-
name|TeStrippedOffset
argument_list|,
operator|&
name|Size
argument_list|,
name|Base
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
return|return
name|Status
return|;
block|}
block|}
comment|//
comment|// If raw size is less then virtual size, zero fill the remaining
comment|//
if|if
condition|(
name|Size
operator|<
name|Section
operator|->
name|Misc
operator|.
name|VirtualSize
condition|)
block|{
name|ZeroMem
argument_list|(
name|Base
operator|+
name|Size
argument_list|,
name|Section
operator|->
name|Misc
operator|.
name|VirtualSize
operator|-
name|Size
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Next Section
comment|//
name|Section
operator|+=
literal|1
expr_stmt|;
block|}
comment|//
comment|// Get image's entry point
comment|//
name|Magic
operator|=
name|PeCoffLoaderGetPeHeaderMagicValue
argument_list|(
name|Hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
comment|//
comment|// Sizes of AddressOfEntryPoint are different so we need to do this safely
comment|//
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|ImageContext
operator|->
name|EntryPoint
operator|=
operator|(
name|PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|AddressOfEntryPoint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|ImageContext
operator|->
name|EntryPoint
operator|=
operator|(
name|PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|AddressOfEntryPoint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ImageContext
operator|->
name|EntryPoint
operator|=
operator|(
name|PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|AddressOfEntryPoint
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Determine the size of the fixup data
comment|//
comment|// Per the PE/COFF spec, you can't assume that a given data directory
comment|// is present in the image. You have to check the NumberOfRvaAndSizes in
comment|// the optional header to verify a desired directory entry is there.
comment|//
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
index|]
expr_stmt|;
block|}
comment|//
comment|// Must use UINT64 here, because there might a case that 32bit loader to load 64bit image.
comment|//
if|if
condition|(
name|NumberOfRvaAndSizes
operator|>
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
condition|)
block|{
name|ImageContext
operator|->
name|FixupDataSize
operator|=
name|DirectoryEntry
operator|->
name|Size
operator|/
sizeof|sizeof
argument_list|(
name|UINT16
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ImageContext
operator|->
name|FixupDataSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|DirectoryEntry
operator|=
operator|&
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
literal|0
index|]
expr_stmt|;
name|ImageContext
operator|->
name|FixupDataSize
operator|=
name|DirectoryEntry
operator|->
name|Size
operator|/
sizeof|sizeof
argument_list|(
name|UINT16
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Consumer must allocate a buffer for the relocation fixup log.
comment|// Only used for runtime drivers.
comment|//
name|ImageContext
operator|->
name|FixupData
operator|=
name|NULL
expr_stmt|;
comment|//
comment|// Load the Codeview information if present
comment|//
if|if
condition|(
name|ImageContext
operator|->
name|DebugDirectoryEntryRva
operator|!=
literal|0
condition|)
block|{
name|DebugEntry
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|ImageContext
operator|->
name|DebugDirectoryEntryRva
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugEntry
operator|==
name|NULL
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
name|TempDebugEntryRva
operator|=
name|DebugEntry
operator|->
name|RVA
expr_stmt|;
if|if
condition|(
name|DebugEntry
operator|->
name|RVA
operator|==
literal|0
operator|&&
name|DebugEntry
operator|->
name|FileOffset
operator|!=
literal|0
condition|)
block|{
name|Section
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|UINTN
operator|)
name|Section
operator|->
name|SizeOfRawData
operator|<
name|Section
operator|->
name|Misc
operator|.
name|VirtualSize
condition|)
block|{
name|TempDebugEntryRva
operator|=
name|Section
operator|->
name|VirtualAddress
operator|+
name|Section
operator|->
name|Misc
operator|.
name|VirtualSize
expr_stmt|;
block|}
else|else
block|{
name|TempDebugEntryRva
operator|=
name|Section
operator|->
name|VirtualAddress
operator|+
name|Section
operator|->
name|SizeOfRawData
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TempDebugEntryRva
operator|!=
literal|0
condition|)
block|{
name|ImageContext
operator|->
name|CodeView
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|TempDebugEntryRva
argument_list|,
name|TeStrippedOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ImageContext
operator|->
name|CodeView
operator|==
name|NULL
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_FAILED_RELOCATION
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
if|if
condition|(
name|DebugEntry
operator|->
name|RVA
operator|==
literal|0
condition|)
block|{
name|Size
operator|=
name|DebugEntry
operator|->
name|SizeOfData
expr_stmt|;
name|Status
operator|=
name|ImageContext
operator|->
name|ImageRead
argument_list|(
name|ImageContext
operator|->
name|Handle
argument_list|,
name|DebugEntry
operator|->
name|FileOffset
operator|-
name|TeStrippedOffset
argument_list|,
operator|&
name|Size
argument_list|,
name|ImageContext
operator|->
name|CodeView
argument_list|)
expr_stmt|;
comment|//
comment|// Should we apply fix up to this field according to the size difference between PE and TE?
comment|// Because now we maintain TE header fields unfixed, this field will also remain as they are
comment|// in original PE image.
comment|//
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_IMAGE_READ
expr_stmt|;
return|return
name|RETURN_LOAD_ERROR
return|;
block|}
name|DebugEntry
operator|->
name|RVA
operator|=
name|TempDebugEntryRva
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|ImageContext
operator|->
name|CodeView
condition|)
block|{
case|case
name|CODEVIEW_SIGNATURE_NB10
case|:
if|if
condition|(
name|DebugEntry
operator|->
name|SizeOfData
operator|<
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ImageContext
operator|->
name|PdbPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|ImageContext
operator|->
name|CodeView
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODEVIEW_SIGNATURE_RSDS
case|:
if|if
condition|(
name|DebugEntry
operator|->
name|SizeOfData
operator|<
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ImageContext
operator|->
name|PdbPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|ImageContext
operator|->
name|CodeView
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODEVIEW_SIGNATURE_MTOC
case|:
if|if
condition|(
name|DebugEntry
operator|->
name|SizeOfData
operator|<
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY
argument_list|)
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ImageContext
operator|->
name|PdbPointer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|ImageContext
operator|->
name|CodeView
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|//
comment|// Get Image's HII resource section
comment|//
name|ImageContext
operator|->
name|HiiResourceData
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ImageContext
operator|->
name|IsTeImage
operator|)
condition|)
block|{
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE
index|]
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE
index|]
expr_stmt|;
block|}
if|if
condition|(
name|NumberOfRvaAndSizes
operator|>
name|EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE
operator|&&
name|DirectoryEntry
operator|->
name|Size
operator|!=
literal|0
condition|)
block|{
name|Base
operator|=
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|DirectoryEntry
operator|->
name|VirtualAddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|!=
name|NULL
condition|)
block|{
name|ResourceDirectory
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY
operator|*
operator|)
name|Base
expr_stmt|;
name|Offset
operator|=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_RESOURCE_DIRECTORY
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
argument_list|)
operator|*
operator|(
name|ResourceDirectory
operator|->
name|NumberOfNamedEntries
operator|+
name|ResourceDirectory
operator|->
name|NumberOfIdEntries
operator|)
expr_stmt|;
if|if
condition|(
name|Offset
operator|>
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
operator|*
operator|)
operator|(
name|ResourceDirectory
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|ResourceDirectory
operator|->
name|NumberOfNamedEntries
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u1
operator|.
name|s
operator|.
name|NameIsString
condition|)
block|{
comment|//
comment|// Check the ResourceDirectoryEntry->u1.s.NameOffset before use it.
comment|//
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u1
operator|.
name|s
operator|.
name|NameOffset
operator|>=
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDirectoryString
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_STRING
operator|*
operator|)
operator|(
name|Base
operator|+
name|ResourceDirectoryEntry
operator|->
name|u1
operator|.
name|s
operator|.
name|NameOffset
operator|)
expr_stmt|;
name|String
operator|=
operator|&
name|ResourceDirectoryString
operator|->
name|String
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ResourceDirectoryString
operator|->
name|Length
operator|==
literal|3
operator|&&
name|String
index|[
literal|0
index|]
operator|==
literal|L'
expr|H'
operator|&&
name|String
index|[
literal|1
index|]
operator|==
literal|L'
expr|I'
operator|&&
name|String
index|[
literal|2
index|]
operator|==
literal|L'
expr|I'
condition|)
block|{
comment|//
comment|// Resource Type "HII" found
comment|//
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|DataIsDirectory
condition|)
block|{
comment|//
comment|// Move to next level - resource Name
comment|//
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|OffsetToDirectory
operator|>=
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDirectory
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY
operator|*
operator|)
operator|(
name|Base
operator|+
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|OffsetToDirectory
operator|)
expr_stmt|;
name|Offset
operator|=
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|OffsetToDirectory
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_RESOURCE_DIRECTORY
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
argument_list|)
operator|*
operator|(
name|ResourceDirectory
operator|->
name|NumberOfNamedEntries
operator|+
name|ResourceDirectory
operator|->
name|NumberOfIdEntries
operator|)
expr_stmt|;
if|if
condition|(
name|Offset
operator|>
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
operator|*
operator|)
operator|(
name|ResourceDirectory
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|DataIsDirectory
condition|)
block|{
comment|//
comment|// Move to next level - resource Language
comment|//
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|OffsetToDirectory
operator|>=
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDirectory
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY
operator|*
operator|)
operator|(
name|Base
operator|+
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|OffsetToDirectory
operator|)
expr_stmt|;
name|Offset
operator|=
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|OffsetToDirectory
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_RESOURCE_DIRECTORY
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
argument_list|)
operator|*
operator|(
name|ResourceDirectory
operator|->
name|NumberOfNamedEntries
operator|+
name|ResourceDirectory
operator|->
name|NumberOfIdEntries
operator|)
expr_stmt|;
if|if
condition|(
name|Offset
operator|>
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY
operator|*
operator|)
operator|(
name|ResourceDirectory
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Now it ought to be resource Data
comment|//
if|if
condition|(
operator|!
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|s
operator|.
name|DataIsDirectory
condition|)
block|{
if|if
condition|(
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|OffsetToData
operator|>=
name|DirectoryEntry
operator|->
name|Size
condition|)
block|{
name|ImageContext
operator|->
name|ImageError
operator|=
name|IMAGE_ERROR_UNSUPPORTED
expr_stmt|;
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
name|ResourceDataEntry
operator|=
operator|(
name|EFI_IMAGE_RESOURCE_DATA_ENTRY
operator|*
operator|)
operator|(
name|Base
operator|+
name|ResourceDirectoryEntry
operator|->
name|u2
operator|.
name|OffsetToData
operator|)
expr_stmt|;
name|ImageContext
operator|->
name|HiiResourceData
operator|=
operator|(
name|PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|PeCoffLoaderImageAddress
argument_list|(
name|ImageContext
argument_list|,
name|ResourceDataEntry
operator|->
name|OffsetToData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ResourceDirectoryEntry
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Reapply fixups on a fixed up PE32/PE32+ image to allow virutal calling at EFI   runtime.       This function reapplies relocation fixups to the PE/COFF image specified by ImageBase    and ImageSize so the image will execute correctly when the PE/COFF image is mapped    to the address specified by VirtualImageBase.  RelocationData must be identical    to the FiuxupData buffer from the PE_COFF_LOADER_IMAGE_CONTEXT structure    after this PE/COFF image was relocated with PeCoffLoaderRelocateImage().    Note that if the platform does not maintain coherency between the instruction cache(s) and the data   cache(s) in hardware, then the caller is responsible for performing cache maintenance operations   prior to transferring control to a PE/COFF image that is loaded using this library.    @param  ImageBase          The base address of a PE/COFF image that has been loaded                               and relocated into system memory.   @param  VirtImageBase      The request virtual address that the PE/COFF image is to                              be fixed up for.   @param  ImageSize          The size, in bytes, of the PE/COFF image.   @param  RelocationData     A pointer to the relocation data that was collected when the PE/COFF                               image was relocated using PeCoffLoaderRelocateImage().    **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|PeCoffLoaderRelocateImageForRuntime
parameter_list|(
name|IN
name|PHYSICAL_ADDRESS
name|ImageBase
parameter_list|,
name|IN
name|PHYSICAL_ADDRESS
name|VirtImageBase
parameter_list|,
name|IN
name|UINTN
name|ImageSize
parameter_list|,
name|IN
name|VOID
modifier|*
name|RelocationData
parameter_list|)
block|{
name|CHAR8
modifier|*
name|OldBase
decl_stmt|;
name|CHAR8
modifier|*
name|NewBase
decl_stmt|;
name|EFI_IMAGE_DOS_HEADER
modifier|*
name|DosHdr
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|UINT32
name|NumberOfRvaAndSizes
decl_stmt|;
name|EFI_IMAGE_DATA_DIRECTORY
modifier|*
name|DataDirectory
decl_stmt|;
name|EFI_IMAGE_DATA_DIRECTORY
modifier|*
name|RelocDir
decl_stmt|;
name|EFI_IMAGE_BASE_RELOCATION
modifier|*
name|RelocBase
decl_stmt|;
name|EFI_IMAGE_BASE_RELOCATION
modifier|*
name|RelocBaseEnd
decl_stmt|;
name|UINT16
modifier|*
name|Reloc
decl_stmt|;
name|UINT16
modifier|*
name|RelocEnd
decl_stmt|;
name|CHAR8
modifier|*
name|Fixup
decl_stmt|;
name|CHAR8
modifier|*
name|FixupBase
decl_stmt|;
name|UINT16
modifier|*
name|Fixup16
decl_stmt|;
name|UINT32
modifier|*
name|Fixup32
decl_stmt|;
name|UINT64
modifier|*
name|Fixup64
decl_stmt|;
name|CHAR8
modifier|*
name|FixupData
decl_stmt|;
name|UINTN
name|Adjust
decl_stmt|;
name|RETURN_STATUS
name|Status
decl_stmt|;
name|UINT16
name|Magic
decl_stmt|;
name|OldBase
operator|=
operator|(
name|CHAR8
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageBase
operator|)
expr_stmt|;
name|NewBase
operator|=
operator|(
name|CHAR8
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|VirtImageBase
operator|)
expr_stmt|;
name|Adjust
operator|=
operator|(
name|UINTN
operator|)
name|NewBase
operator|-
operator|(
name|UINTN
operator|)
name|OldBase
expr_stmt|;
comment|//
comment|// Find the image's relocate dir info
comment|//
name|DosHdr
operator|=
operator|(
name|EFI_IMAGE_DOS_HEADER
operator|*
operator|)
name|OldBase
expr_stmt|;
if|if
condition|(
name|DosHdr
operator|->
name|e_magic
operator|==
name|EFI_IMAGE_DOS_SIGNATURE
condition|)
block|{
comment|//
comment|// Valid DOS header so get address of PE header
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
operator|(
name|CHAR8
operator|*
operator|)
name|DosHdr
operator|)
operator|+
name|DosHdr
operator|->
name|e_lfanew
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// No Dos header so assume image starts with PE header.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
name|OldBase
expr_stmt|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|Signature
operator|!=
name|EFI_IMAGE_NT_SIGNATURE
condition|)
block|{
comment|//
comment|// Not a valid PE image so Exit
comment|//
return|return ;
block|}
name|Magic
operator|=
name|PeCoffLoaderGetPeHeaderMagicValue
argument_list|(
name|Hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DataDirectory
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
operator|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Use PE32+ offset
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DataDirectory
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
operator|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|//
comment|// Find the relocation block
comment|//
comment|// Per the PE/COFF spec, you can't assume that a given data directory
comment|// is present in the image. You have to check the NumberOfRvaAndSizes in
comment|// the optional header to verify a desired directory entry is there.
comment|//
if|if
condition|(
name|NumberOfRvaAndSizes
operator|>
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
condition|)
block|{
name|RelocDir
operator|=
name|DataDirectory
operator|+
name|EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC
expr_stmt|;
name|RelocBase
operator|=
operator|(
name|EFI_IMAGE_BASE_RELOCATION
operator|*
operator|)
call|(
name|UINTN
call|)
argument_list|(
name|ImageBase
operator|+
name|RelocDir
operator|->
name|VirtualAddress
argument_list|)
expr_stmt|;
name|RelocBaseEnd
operator|=
operator|(
name|EFI_IMAGE_BASE_RELOCATION
operator|*
operator|)
call|(
name|UINTN
call|)
argument_list|(
name|ImageBase
operator|+
name|RelocDir
operator|->
name|VirtualAddress
operator|+
name|RelocDir
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Cannot find relocations, cannot continue to relocate the image, ASSERT for this invalid image.
comment|//
name|ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|//
comment|// ASSERT for the invalid image when RelocBase and RelocBaseEnd are both NULL.
comment|//
name|ASSERT
argument_list|(
name|RelocBase
operator|!=
name|NULL
operator|&&
name|RelocBaseEnd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Run the whole relocation block. And re-fixup data that has not been
comment|// modified. The FixupData is used to see if the image has been modified
comment|// since it was relocated. This is so data sections that have been updated
comment|// by code will not be fixed up, since that would set them back to
comment|// defaults.
comment|//
name|FixupData
operator|=
name|RelocationData
expr_stmt|;
while|while
condition|(
name|RelocBase
operator|<
name|RelocBaseEnd
condition|)
block|{
comment|//
comment|// Add check for RelocBase->SizeOfBlock field.
comment|//
if|if
condition|(
operator|(
name|RelocBase
operator|->
name|SizeOfBlock
operator|==
literal|0
operator|)
operator|||
operator|(
name|RelocBase
operator|->
name|SizeOfBlock
operator|>
name|RelocDir
operator|->
name|Size
operator|)
condition|)
block|{
comment|//
comment|// Data invalid, cannot continue to relocate the image, just return.
comment|//
return|return;
block|}
name|Reloc
operator|=
operator|(
name|UINT16
operator|*
operator|)
operator|(
operator|(
name|UINT8
operator|*
operator|)
name|RelocBase
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_BASE_RELOCATION
argument_list|)
operator|)
expr_stmt|;
name|RelocEnd
operator|=
operator|(
name|UINT16
operator|*
operator|)
operator|(
operator|(
name|UINT8
operator|*
operator|)
name|RelocBase
operator|+
name|RelocBase
operator|->
name|SizeOfBlock
operator|)
expr_stmt|;
name|FixupBase
operator|=
operator|(
name|CHAR8
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|ImageBase
operator|)
operator|+
name|RelocBase
operator|->
name|VirtualAddress
expr_stmt|;
comment|//
comment|// Run this relocation record
comment|//
while|while
condition|(
name|Reloc
operator|<
name|RelocEnd
condition|)
block|{
name|Fixup
operator|=
name|FixupBase
operator|+
operator|(
operator|*
name|Reloc
operator|&
literal|0xFFF
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|Reloc
operator|)
operator|>>
literal|12
condition|)
block|{
case|case
name|EFI_IMAGE_REL_BASED_ABSOLUTE
case|:
break|break;
case|case
name|EFI_IMAGE_REL_BASED_HIGH
case|:
name|Fixup16
operator|=
operator|(
name|UINT16
operator|*
operator|)
name|Fixup
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|UINT16
operator|*
operator|)
name|FixupData
operator|==
operator|*
name|Fixup16
condition|)
block|{
operator|*
name|Fixup16
operator|=
call|(
name|UINT16
call|)
argument_list|(
operator|*
name|Fixup16
operator|+
operator|(
call|(
name|UINT16
call|)
argument_list|(
operator|(
name|UINT32
operator|)
name|Adjust
operator|>>
literal|16
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT16
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFI_IMAGE_REL_BASED_LOW
case|:
name|Fixup16
operator|=
operator|(
name|UINT16
operator|*
operator|)
name|Fixup
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|UINT16
operator|*
operator|)
name|FixupData
operator|==
operator|*
name|Fixup16
condition|)
block|{
operator|*
name|Fixup16
operator|=
call|(
name|UINT16
call|)
argument_list|(
operator|*
name|Fixup16
operator|+
operator|(
operator|(
name|UINT16
operator|)
name|Adjust
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
block|}
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT16
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFI_IMAGE_REL_BASED_HIGHLOW
case|:
name|Fixup32
operator|=
operator|(
name|UINT32
operator|*
operator|)
name|Fixup
expr_stmt|;
name|FixupData
operator|=
name|ALIGN_POINTER
argument_list|(
name|FixupData
argument_list|,
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|FixupData
operator|==
operator|*
name|Fixup32
condition|)
block|{
operator|*
name|Fixup32
operator|=
operator|*
name|Fixup32
operator|+
operator|(
name|UINT32
operator|)
name|Adjust
expr_stmt|;
block|}
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFI_IMAGE_REL_BASED_DIR64
case|:
name|Fixup64
operator|=
operator|(
name|UINT64
operator|*
operator|)
name|Fixup
expr_stmt|;
name|FixupData
operator|=
name|ALIGN_POINTER
argument_list|(
name|FixupData
argument_list|,
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|UINT64
operator|*
operator|)
name|FixupData
operator|==
operator|*
name|Fixup64
condition|)
block|{
operator|*
name|Fixup64
operator|=
operator|*
name|Fixup64
operator|+
operator|(
name|UINT64
operator|)
name|Adjust
expr_stmt|;
block|}
name|FixupData
operator|=
name|FixupData
operator|+
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|//
comment|// Only Itanium requires ConvertPeImage_Ex
comment|//
name|Status
operator|=
name|PeHotRelocateImageEx
argument_list|(
name|Reloc
argument_list|,
name|Fixup
argument_list|,
operator|&
name|FixupData
argument_list|,
name|Adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return ;
block|}
block|}
comment|//
comment|// Next relocation record
comment|//
name|Reloc
operator|+=
literal|1
expr_stmt|;
block|}
comment|//
comment|// next reloc block
comment|//
name|RelocBase
operator|=
operator|(
name|EFI_IMAGE_BASE_RELOCATION
operator|*
operator|)
name|RelocEnd
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**   Reads contents of a PE/COFF image from a buffer in system memory.       This is the default implementation of a PE_COFF_LOADER_READ_FILE function    that assumes FileHandle pointer to the beginning of a PE/COFF image.      This function reads contents of the PE/COFF image that starts at the system memory    address specified by FileHandle.  The read operation copies ReadSize bytes from the    PE/COFF image starting at byte offset FileOffset into the buffer specified by Buffer.     The size of the buffer actually read is returned in ReadSize.      The caller must make sure the FileOffset and ReadSize within the file scope.    If FileHandle is NULL, then ASSERT().   If ReadSize is NULL, then ASSERT().   If Buffer is NULL, then ASSERT().    @param  FileHandle        The pointer to base of the input stream   @param  FileOffset        Offset into the PE/COFF image to begin the read operation.   @param  ReadSize          On input, the size in bytes of the requested read operation.                               On output, the number of bytes actually read.   @param  Buffer            Output buffer that contains the data read from the PE/COFF image.    @retval RETURN_SUCCESS    Data is read from FileOffset from the Handle into                              the buffer. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|PeCoffLoaderImageReadFromMemory
parameter_list|(
name|IN
name|VOID
modifier|*
name|FileHandle
parameter_list|,
name|IN
name|UINTN
name|FileOffset
parameter_list|,
name|IN
name|OUT
name|UINTN
modifier|*
name|ReadSize
parameter_list|,
name|OUT
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ReadSize
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|FileHandle
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CopyMem
argument_list|(
name|Buffer
argument_list|,
operator|(
operator|(
name|UINT8
operator|*
operator|)
name|FileHandle
operator|)
operator|+
name|FileOffset
argument_list|,
operator|*
name|ReadSize
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Unloads a loaded PE/COFF image from memory and releases its taken resource.   Releases any environment specific resources that were allocated when the image    specified by ImageContext was loaded using PeCoffLoaderLoadImage().      For NT32 emulator, the PE/COFF image loaded by system needs to release.   For real platform, the PE/COFF image loaded by Core doesn't needs to be unloaded,    this function can simply return RETURN_SUCCESS.      If ImageContext is NULL, then ASSERT().      @param  ImageContext              The pointer to the image context structure that describes the PE/COFF                                     image to be unloaded.    @retval RETURN_SUCCESS            The PE/COFF image was unloaded successfully. **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|PeCoffLoaderUnloadImage
parameter_list|(
name|IN
name|OUT
name|PE_COFF_LOADER_IMAGE_CONTEXT
modifier|*
name|ImageContext
parameter_list|)
block|{
comment|//
comment|// Applies additional environment specific actions to unload a
comment|// PE/COFF image if needed
comment|//
name|PeCoffLoaderUnloadImageExtraAction
argument_list|(
name|ImageContext
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

end_unit

