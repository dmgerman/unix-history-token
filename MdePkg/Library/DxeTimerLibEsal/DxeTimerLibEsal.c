begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   This library implements the Timer Library using the Extended SAL Stall Services Class.    Copyright (c) 2007 - 2011, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<PiDxe.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/ExtendedSalServiceClasses.h>
end_include

begin_include
include|#
directive|include
file|<Library/TimerLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/ExtendedSalLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/PalLib.h>
end_include

begin_comment
comment|/**   Stalls the CPU for at least the given number of microseconds.    This function wraps EsalStall function of Extended SAL Stall Services Class.   It stalls the CPU for the number of microseconds specified by MicroSeconds.    @param  MicroSeconds  The minimum number of microseconds to delay.    @return MicroSeconds  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|MicroSecondDelay
parameter_list|(
name|IN
name|UINTN
name|MicroSeconds
parameter_list|)
block|{
name|EsalCall
argument_list|(
name|EFI_EXTENDED_SAL_STALL_SERVICES_PROTOCOL_GUID_LO
argument_list|,
name|EFI_EXTENDED_SAL_STALL_SERVICES_PROTOCOL_GUID_HI
argument_list|,
name|StallFunctionId
argument_list|,
name|MicroSeconds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|MicroSeconds
return|;
block|}
end_function

begin_comment
comment|/**   Stalls the CPU for at least the given number of nanoseconds.    This function wraps EsalStall function of Extended SAL Stall Services Class.   It stalls the CPU for the number of nanoseconds specified by NanoSeconds.    @param  NanoSeconds The minimum number of nanoseconds to delay.    @return NanoSeconds  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|NanoSecondDelay
parameter_list|(
name|IN
name|UINTN
name|NanoSeconds
parameter_list|)
block|{
name|UINT64
name|MicroSeconds
decl_stmt|;
comment|//
comment|// The unit of ESAL Stall service is microsecond, so we turn the time interval
comment|// from nanosecond to microsecond, using the ceiling value to ensure stalling
comment|// at least the given number of nanoseconds.
comment|//
name|MicroSeconds
operator|=
name|DivU64x32
argument_list|(
name|NanoSeconds
operator|+
literal|999
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|EsalCall
argument_list|(
name|EFI_EXTENDED_SAL_STALL_SERVICES_PROTOCOL_GUID_LO
argument_list|,
name|EFI_EXTENDED_SAL_STALL_SERVICES_PROTOCOL_GUID_HI
argument_list|,
name|StallFunctionId
argument_list|,
name|MicroSeconds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NanoSeconds
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the current value of a 64-bit free running performance counter.    Retrieves the current value of a 64-bit free running performance counter. The   counter can either count up by 1 or count down by 1. If the physical   performance counter counts by a larger increment, then the counter values   must be translated. The properties of the counter can be retrieved from   GetPerformanceCounterProperties().    @return The current value of the free running performance counter.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetPerformanceCounter
parameter_list|(
name|VOID
parameter_list|)
block|{
return|return
name|AsmReadItc
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves the 64-bit frequency in Hz and the range of performance counter   values.    If StartValue is not NULL, then the value that the performance counter starts   with immediately after is it rolls over is returned in StartValue. If   EndValue is not NULL, then the value that the performance counter end with   immediately before it rolls over is returned in EndValue. The 64-bit   frequency of the performance counter in Hz is always returned. If StartValue   is less than EndValue, then the performance counter counts up. If StartValue   is greater than EndValue, then the performance counter counts down. For   example, a 64-bit free running counter that counts up would have a StartValue   of 0 and an EndValue of 0xFFFFFFFFFFFFFFFF. A 24-bit free running counter   that counts down would have a StartValue of 0xFFFFFF and an EndValue of 0.    @param  StartValue  The value the performance counter starts with when it                       rolls over.   @param  EndValue    The value that the performance counter ends with before                       it rolls over.    @return The frequency in Hz.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetPerformanceCounterProperties
parameter_list|(
name|OUT
name|UINT64
modifier|*
name|StartValue
parameter_list|,
name|OPTIONAL
name|OUT
name|UINT64
modifier|*
name|EndValue
name|OPTIONAL
parameter_list|)
block|{
name|PAL_CALL_RETURN
name|PalRet
decl_stmt|;
name|UINT64
name|BaseFrequence
decl_stmt|;
comment|//
comment|// Get processor base frequency
comment|//
name|PalRet
operator|=
name|PalCall
argument_list|(
name|PAL_FREQ_BASE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|PalRet
operator|.
name|Status
operator|==
literal|0
argument_list|)
expr_stmt|;
name|BaseFrequence
operator|=
name|PalRet
operator|.
name|r9
expr_stmt|;
comment|//
comment|// Get processor frequency ratio
comment|//
name|PalRet
operator|=
name|PalCall
argument_list|(
name|PAL_FREQ_RATIOS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|PalRet
operator|.
name|Status
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Start value of counter is 0
comment|//
if|if
condition|(
name|StartValue
operator|!=
name|NULL
condition|)
block|{
operator|*
name|StartValue
operator|=
literal|0
expr_stmt|;
block|}
comment|//
comment|// End value of counter is 0xFFFFFFFFFFFFFFFF
comment|//
if|if
condition|(
name|EndValue
operator|!=
name|NULL
condition|)
block|{
operator|*
name|EndValue
operator|=
call|(
name|UINT64
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|BaseFrequence
operator|*
operator|(
name|PalRet
operator|.
name|r11
operator|>>
literal|32
operator|)
operator|/
operator|(
name|UINT32
operator|)
name|PalRet
operator|.
name|r11
return|;
block|}
end_function

begin_comment
comment|/**   Converts elapsed ticks of performance counter to time in nanoseconds.    This function converts the elapsed ticks of running performance counter to   time value in unit of nanoseconds.    @param  Ticks     The number of elapsed ticks of running performance counter.    @return The elapsed time in nanoseconds.  **/
end_comment

begin_function
name|UINT64
name|EFIAPI
name|GetTimeInNanoSecond
parameter_list|(
name|IN
name|UINT64
name|Ticks
parameter_list|)
block|{
name|UINT64
name|Frequency
decl_stmt|;
name|UINT64
name|NanoSeconds
decl_stmt|;
name|UINT64
name|Remainder
decl_stmt|;
name|INTN
name|Shift
decl_stmt|;
name|Frequency
operator|=
name|GetPerformanceCounterProperties
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|//          Ticks
comment|// Time = --------- x 1,000,000,000
comment|//        Frequency
comment|//
name|NanoSeconds
operator|=
name|MultU64x32
argument_list|(
name|DivU64x64Remainder
argument_list|(
name|Ticks
argument_list|,
name|Frequency
argument_list|,
operator|&
name|Remainder
argument_list|)
argument_list|,
literal|1000000000u
argument_list|)
expr_stmt|;
comment|//
comment|// Ensure (Remainder * 1,000,000,000) will not overflow 64-bit.
comment|// Since 2^29< 1,000,000,000 = 0x3B9ACA00< 2^30, Remainder should< 2^(64-30) = 2^34,
comment|// i.e. highest bit set in Remainder should<= 33.
comment|//
name|Shift
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|HighBitSet64
argument_list|(
name|Remainder
argument_list|)
operator|-
literal|33
argument_list|)
expr_stmt|;
name|Remainder
operator|=
name|RShiftU64
argument_list|(
name|Remainder
argument_list|,
operator|(
name|UINTN
operator|)
name|Shift
argument_list|)
expr_stmt|;
name|Frequency
operator|=
name|RShiftU64
argument_list|(
name|Frequency
argument_list|,
operator|(
name|UINTN
operator|)
name|Shift
argument_list|)
expr_stmt|;
name|NanoSeconds
operator|+=
name|DivU64x64Remainder
argument_list|(
name|MultU64x32
argument_list|(
name|Remainder
argument_list|,
literal|1000000000u
argument_list|)
argument_list|,
name|Frequency
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NanoSeconds
return|;
block|}
end_function

end_unit

