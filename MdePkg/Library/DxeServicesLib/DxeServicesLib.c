begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   MDE DXE Services Library provides functions that simplify the development of DXE Drivers.     These functions help access data from sections of FFS files or from file path.    Copyright (c) 2007 - 2015, Intel Corporation. All rights reserved.<BR>   (C) Copyright 2015 Hewlett Packard Enterprise Development LP<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<PiDxe.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/MemoryAllocationLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/UefiBootServicesTableLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DevicePathLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/UefiLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DxeServicesLib.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/FirmwareVolume2.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/LoadedImage.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/LoadFile2.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/LoadFile.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/SimpleFileSystem.h>
end_include

begin_include
include|#
directive|include
file|<Guid/FileInfo.h>
end_include

begin_comment
comment|/**   Identify the device handle from which the Image is loaded from. As this device handle is passed to   GetSectionFromFv as the identifier for a Firmware Volume, an EFI_FIRMWARE_VOLUME2_PROTOCOL    protocol instance should be located succesfully by calling gBS->HandleProtocol ().    This function locates the EFI_LOADED_IMAGE_PROTOCOL instance installed   on ImageHandle. It then returns EFI_LOADED_IMAGE_PROTOCOL.DeviceHandle.      If ImageHandle is NULL, then ASSERT ();   If failed to locate a EFI_LOADED_IMAGE_PROTOCOL on ImageHandle, then ASSERT ();      @param  ImageHandle         The firmware allocated handle for UEFI image.    @retval  EFI_HANDLE         The device handle from which the Image is loaded from.  **/
end_comment

begin_function
name|EFI_HANDLE
name|InternalImageHandleToFvHandle
parameter_list|(
name|EFI_HANDLE
name|ImageHandle
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_LOADED_IMAGE_PROTOCOL
modifier|*
name|LoadedImage
decl_stmt|;
name|ASSERT
argument_list|(
name|ImageHandle
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
operator|(
name|EFI_HANDLE
operator|*
operator|)
name|ImageHandle
argument_list|,
operator|&
name|gEfiLoadedImageProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|LoadedImage
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
return|return
name|LoadedImage
operator|->
name|DeviceHandle
return|;
block|}
end_function

begin_comment
comment|/**   Allocate and fill a buffer from a Firmware Section identified by a Firmware File GUID name, a Firmware    Section type and instance number from the specified Firmware Volume.    This functions first locate the EFI_FIRMWARE_VOLUME2_PROTOCOL protocol instance on FvHandle in order to    carry out the Firmware Volume read operation. The function then reads the Firmware Section found sepcifed    by NameGuid, SectionType and SectionInstance.       The details of this search order is defined in description of EFI_FIRMWARE_VOLUME2_PROTOCOL.ReadSection ()    found in PI Specification.      If SectionType is EFI_SECTION_TE, EFI_SECTION_TE is used as section type to start the search. If EFI_SECTION_TE section    is not found, EFI_SECTION_PE32 will be used to try the search again. If no EFI_SECTION_PE32 section is found, EFI_NOT_FOUND    is returned.      The data and size is returned by Buffer and Size. The caller is responsible to free the Buffer allocated    by this function. This function can be only called at TPL_NOTIFY and below.      If FvHandle is NULL, then ASSERT ();   If NameGuid is NULL, then ASSERT();   If Buffer is NULL, then ASSERT();   If Size is NULL, then ASSERT().    @param  FvHandle                The device handle that contains a instance of                                    EFI_FIRMWARE_VOLUME2_PROTOCOL instance.   @param  NameGuid                The GUID name of a Firmware File.   @param  SectionType             The Firmware Section type.   @param  SectionInstance         The instance number of Firmware Section to                                     read from starting from 0.   @param  Buffer                  On output, Buffer contains the the data read                                    from the section in the Firmware File found.   @param  Size                    On output, the size of Buffer.    @retval  EFI_SUCCESS            The image is found and data and size is returned.   @retval  EFI_NOT_FOUND          The image specified by NameGuid and SectionType                                    can't be found.   @retval  EFI_OUT_OF_RESOURCES   There were not enough resources to allocate the                                    output data buffer or complete the operations.   @retval  EFI_DEVICE_ERROR       A hardware error occurs during reading from the                                    Firmware Volume.   @retval  EFI_ACCESS_DENIED      The firmware volume containing the searched                                    Firmware File is configured to disallow reads.    **/
end_comment

begin_function
name|EFI_STATUS
name|InternalGetSectionFromFv
parameter_list|(
name|IN
name|EFI_HANDLE
name|FvHandle
parameter_list|,
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|NameGuid
parameter_list|,
name|IN
name|EFI_SECTION_TYPE
name|SectionType
parameter_list|,
name|IN
name|UINTN
name|SectionInstance
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Buffer
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_FIRMWARE_VOLUME2_PROTOCOL
modifier|*
name|Fv
decl_stmt|;
name|UINT32
name|AuthenticationStatus
decl_stmt|;
name|ASSERT
argument_list|(
name|NameGuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Size
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|FvHandle
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|FvHandle
argument_list|,
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|Fv
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|EFI_NOT_FOUND
return|;
block|}
comment|//
comment|// Read desired section content in NameGuid file
comment|//
operator|*
name|Buffer
operator|=
name|NULL
expr_stmt|;
operator|*
name|Size
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|Fv
operator|->
name|ReadSection
argument_list|(
name|Fv
argument_list|,
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|,
operator|&
name|AuthenticationStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|&&
operator|(
name|SectionType
operator|==
name|EFI_SECTION_TE
operator|)
condition|)
block|{
comment|//
comment|// Try reading PE32 section, if the required section is TE type
comment|//
operator|*
name|Buffer
operator|=
name|NULL
expr_stmt|;
operator|*
name|Size
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|Fv
operator|->
name|ReadSection
argument_list|(
name|Fv
argument_list|,
name|NameGuid
argument_list|,
name|EFI_SECTION_PE32
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|,
operator|&
name|AuthenticationStatus
argument_list|)
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Searches all the available firmware volumes and returns the first matching FFS section.     This function searches all the firmware volumes for FFS files with FV file type specified by FileType   The order that the firmware volumes is searched is not deterministic. For each available FV a search    is made for FFS file of type FileType. If the FV contains more than one FFS file with the same FileType,    the FileInstance instance will be the matched FFS file. For each FFS file found a search    is made for FFS sections of type SectionType. If the FFS file contains at least SectionInstance instances    of the FFS section specified by SectionType, then the SectionInstance instance is returned in Buffer.    Buffer is allocated using AllocatePool(), and the size of the allocated buffer is returned in Size.    It is the caller's responsibility to use FreePool() to free the allocated buffer.     See EFI_FIRMWARE_VOLUME2_PROTOCOL.ReadSection() for details on how sections    are retrieved from an FFS file based on SectionType and SectionInstance.    If SectionType is EFI_SECTION_TE, and the search with an FFS file fails,    the search will be retried with a section type of EFI_SECTION_PE32.   This function must be called with a TPL<= TPL_NOTIFY.    If Buffer is NULL, then ASSERT().   If Size is NULL, then ASSERT().    @param  FileType             Indicates the FV file type to search for within all                                 available FVs.   @param  FileInstance         Indicates which file instance within all available                                 FVs specified by FileType.                                FileInstance starts from zero.   @param  SectionType          Indicates the FFS section type to search for                                 within the FFS file                                 specified by FileType with FileInstance.   @param  SectionInstance      Indicates which section instance within the FFS file                                 specified by FileType with FileInstance to retrieve.                                 SectionInstance starts from zero.   @param  Buffer               On output, a pointer to a callee allocated buffer                                 containing the FFS file section that was found.                                Is it the caller's responsibility to free this                                 buffer using FreePool().   @param  Size                 On output, a pointer to the size, in bytes, of Buffer.    @retval  EFI_SUCCESS          The specified FFS section was returned.   @retval  EFI_NOT_FOUND        The specified FFS section could not be found.   @retval  EFI_OUT_OF_RESOURCES There are not enough resources available to retrieve                                  the matching FFS section.   @retval  EFI_DEVICE_ERROR     The FFS section could not be retrieves due to a                                  device error.   @retval  EFI_ACCESS_DENIED    The FFS section could not be retrieves because                                  the firmware volume that                                  contains the matching FFS section does not allow reads. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetSectionFromAnyFvByFileType
parameter_list|(
name|IN
name|EFI_FV_FILETYPE
name|FileType
parameter_list|,
name|IN
name|UINTN
name|FileInstance
parameter_list|,
name|IN
name|EFI_SECTION_TYPE
name|SectionType
parameter_list|,
name|IN
name|UINTN
name|SectionInstance
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Buffer
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_HANDLE
modifier|*
name|HandleBuffer
decl_stmt|;
name|UINTN
name|HandleCount
decl_stmt|;
name|UINTN
name|IndexFv
decl_stmt|;
name|UINTN
name|IndexFile
decl_stmt|;
name|UINTN
name|Key
decl_stmt|;
name|EFI_GUID
name|NameGuid
decl_stmt|;
name|EFI_FV_FILE_ATTRIBUTES
name|Attributes
decl_stmt|;
name|EFI_FIRMWARE_VOLUME2_PROTOCOL
modifier|*
name|Fv
decl_stmt|;
comment|//
comment|// Locate all available FVs.
comment|//
name|HandleBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|LocateHandleBuffer
argument_list|(
name|ByProtocol
argument_list|,
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|&
name|HandleCount
argument_list|,
operator|&
name|HandleBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
comment|//
comment|// Go through FVs one by one to find the required section data.
comment|//
for|for
control|(
name|IndexFv
operator|=
literal|0
init|;
name|IndexFv
operator|<
name|HandleCount
condition|;
name|IndexFv
operator|++
control|)
block|{
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|HandleBuffer
index|[
name|IndexFv
index|]
argument_list|,
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|Fv
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|//
comment|// Use Firmware Volume 2 Protocol to search for a file of type FileType in all FVs.
comment|//
name|IndexFile
operator|=
name|FileInstance
operator|+
literal|1
expr_stmt|;
name|Key
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|Status
operator|=
name|Fv
operator|->
name|GetNextFile
argument_list|(
name|Fv
argument_list|,
operator|&
name|Key
argument_list|,
operator|&
name|FileType
argument_list|,
operator|&
name|NameGuid
argument_list|,
operator|&
name|Attributes
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
break|break;
block|}
name|IndexFile
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|IndexFile
operator|>
literal|0
condition|)
do|;
comment|//
comment|// Fv File with the required FV file type is found.
comment|// Search the section file in the found FV file.
comment|//
if|if
condition|(
name|IndexFile
operator|==
literal|0
condition|)
block|{
name|Status
operator|=
name|InternalGetSectionFromFv
argument_list|(
name|HandleBuffer
index|[
name|IndexFv
index|]
argument_list|,
operator|&
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
block|}
block|}
comment|//
comment|// The required FFS section file is not found.
comment|//
if|if
condition|(
name|IndexFv
operator|==
name|HandleCount
condition|)
block|{
name|Status
operator|=
name|EFI_NOT_FOUND
expr_stmt|;
block|}
name|Done
label|:
if|if
condition|(
name|HandleBuffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|HandleBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Searches all the availables firmware volumes and returns the first matching FFS section.     This function searches all the firmware volumes for FFS files with an FFS filename specified by NameGuid.     The order that the firmware volumes is searched is not deterministic. For each FFS file found a search    is made for FFS sections of type SectionType. If the FFS file contains at least SectionInstance instances    of the FFS section specified by SectionType, then the SectionInstance instance is returned in Buffer.    Buffer is allocated using AllocatePool(), and the size of the allocated buffer is returned in Size.    It is the caller's responsibility to use FreePool() to free the allocated buffer.     See EFI_FIRMWARE_VOLUME2_PROTOCOL.ReadSection() for details on how sections    are retrieved from an FFS file based on SectionType and SectionInstance.    If SectionType is EFI_SECTION_TE, and the search with an FFS file fails,    the search will be retried with a section type of EFI_SECTION_PE32.   This function must be called with a TPL<= TPL_NOTIFY.    If NameGuid is NULL, then ASSERT().   If Buffer is NULL, then ASSERT().   If Size is NULL, then ASSERT().     @param  NameGuid             A pointer to to the FFS filename GUID to search for                                  within any of the firmware volumes in the platform.    @param  SectionType          Indicates the FFS section type to search for within                                 the FFS file specified by NameGuid.   @param  SectionInstance      Indicates which section instance within the FFS file                                 specified by NameGuid to retrieve.   @param  Buffer               On output, a pointer to a callee allocated buffer                                 containing the FFS file section that was found.                                  Is it the caller's responsibility to free this buffer                                 using FreePool().   @param  Size                 On output, a pointer to the size, in bytes, of Buffer.    @retval  EFI_SUCCESS          The specified FFS section was returned.   @retval  EFI_NOT_FOUND        The specified FFS section could not be found.   @retval  EFI_OUT_OF_RESOURCES There are not enough resources available to                                  retrieve the matching FFS section.   @retval  EFI_DEVICE_ERROR     The FFS section could not be retrieves due to a                                  device error.   @retval  EFI_ACCESS_DENIED    The FFS section could not be retrieves because the                                  firmware volume that                                  contains the matching FFS section does not allow reads. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetSectionFromAnyFv
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|NameGuid
parameter_list|,
name|IN
name|EFI_SECTION_TYPE
name|SectionType
parameter_list|,
name|IN
name|UINTN
name|SectionInstance
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Buffer
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_HANDLE
modifier|*
name|HandleBuffer
decl_stmt|;
name|UINTN
name|HandleCount
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|EFI_HANDLE
name|FvHandle
decl_stmt|;
comment|//
comment|// Search the FV that contain the caller's FFS first.
comment|// FV builder can choose to build FFS into the this FV
comment|// so that this implementation of GetSectionFromAnyFv
comment|// will locate the FFS faster.
comment|//
name|FvHandle
operator|=
name|InternalImageHandleToFvHandle
argument_list|(
name|gImageHandle
argument_list|)
expr_stmt|;
name|Status
operator|=
name|InternalGetSectionFromFv
argument_list|(
name|FvHandle
argument_list|,
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|EFI_SUCCESS
return|;
block|}
name|HandleBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|LocateHandleBuffer
argument_list|(
name|ByProtocol
argument_list|,
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|&
name|HandleCount
argument_list|,
operator|&
name|HandleBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|HandleCount
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// Skip the FV that contain the caller's FFS
comment|//
if|if
condition|(
name|HandleBuffer
index|[
name|Index
index|]
operator|!=
name|FvHandle
condition|)
block|{
name|Status
operator|=
name|InternalGetSectionFromFv
argument_list|(
name|HandleBuffer
index|[
name|Index
index|]
argument_list|,
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
block|}
block|}
if|if
condition|(
name|Index
operator|==
name|HandleCount
condition|)
block|{
name|Status
operator|=
name|EFI_NOT_FOUND
expr_stmt|;
block|}
name|Done
label|:
if|if
condition|(
name|HandleBuffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|HandleBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Searches the firmware volume that the currently executing module was loaded from and returns the first matching FFS section.     This function searches the firmware volume that the currently executing module was loaded    from for an FFS file with an FFS filename specified by NameGuid. If the FFS file is found a search    is made for FFS sections of type SectionType. If the FFS file contains at least SectionInstance    instances of the FFS section specified by SectionType, then the SectionInstance instance is returned in Buffer.   Buffer is allocated using AllocatePool(), and the size of the allocated buffer is returned in Size.    It is the caller's responsibility to use FreePool() to free the allocated buffer.    See EFI_FIRMWARE_VOLUME2_PROTOCOL.ReadSection() for details on how sections are retrieved from    an FFS file based on SectionType and SectionInstance.    If the currently executing module was not loaded from a firmware volume, then EFI_NOT_FOUND is returned.   If SectionType is EFI_SECTION_TE, and the search with an FFS file fails,    the search will be retried with a section type of EFI_SECTION_PE32.      This function must be called with a TPL<= TPL_NOTIFY.   If NameGuid is NULL, then ASSERT().   If Buffer is NULL, then ASSERT().   If Size is NULL, then ASSERT().    @param  NameGuid             A pointer to to the FFS filename GUID to search for                                 within the firmware volumes that the currently                                 executing module was loaded from.   @param  SectionType          Indicates the FFS section type to search for within                                 the FFS file specified by NameGuid.   @param  SectionInstance      Indicates which section instance within the FFS file                                 specified by NameGuid to retrieve.   @param  Buffer               On output, a pointer to a callee allocated buffer                                 containing the FFS file section that was found.                                  Is it the caller's responsibility to free this buffer                                 using FreePool().   @param  Size                 On output, a pointer to the size, in bytes, of Buffer.     @retval  EFI_SUCCESS          The specified FFS section was returned.   @retval  EFI_NOT_FOUND        The specified FFS section could not be found.   @retval  EFI_OUT_OF_RESOURCES There are not enough resources available to retrieve                                  the matching FFS section.   @retval  EFI_DEVICE_ERROR     The FFS section could not be retrieves due to a                                  device error.   @retval  EFI_ACCESS_DENIED    The FFS section could not be retrieves because the                                  firmware volume that contains the matching FFS                                  section does not allow reads.   **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetSectionFromFv
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|NameGuid
parameter_list|,
name|IN
name|EFI_SECTION_TYPE
name|SectionType
parameter_list|,
name|IN
name|UINTN
name|SectionInstance
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Buffer
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
parameter_list|)
block|{
return|return
name|InternalGetSectionFromFv
argument_list|(
name|InternalImageHandleToFvHandle
argument_list|(
name|gImageHandle
argument_list|)
argument_list|,
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Searches the FFS file the the currently executing module was loaded from and returns the first matching FFS section.    This function searches the FFS file that the currently executing module was loaded from for a FFS sections of type SectionType.   If the FFS file contains at least SectionInstance instances of the FFS section specified by SectionType,    then the SectionInstance instance is returned in Buffer. Buffer is allocated using AllocatePool(),    and the size of the allocated buffer is returned in Size. It is the caller's responsibility    to use FreePool() to free the allocated buffer. See EFI_FIRMWARE_VOLUME2_PROTOCOL.ReadSection() for    details on how sections are retrieved from an FFS file based on SectionType and SectionInstance.    If the currently executing module was not loaded from an FFS file, then EFI_NOT_FOUND is returned.   If SectionType is EFI_SECTION_TE, and the search with an FFS file fails,    the search will be retried with a section type of EFI_SECTION_PE32.   This function must be called with a TPL<= TPL_NOTIFY.      If Buffer is NULL, then ASSERT().   If Size is NULL, then ASSERT().     @param  SectionType          Indicates the FFS section type to search for within                                 the FFS file that the currently executing module                                 was loaded from.   @param  SectionInstance      Indicates which section instance to retrieve within                                 the FFS file that the currently executing module                                 was loaded from.   @param  Buffer               On output, a pointer to a callee allocated buffer                                 containing the FFS file section that was found.                                  Is it the caller's responsibility to free this buffer                                 using FreePool().   @param  Size                 On output, a pointer to the size, in bytes, of Buffer.    @retval  EFI_SUCCESS          The specified FFS section was returned.   @retval  EFI_NOT_FOUND        The specified FFS section could not be found.   @retval  EFI_OUT_OF_RESOURCES There are not enough resources available to retrieve                                  the matching FFS section.   @retval  EFI_DEVICE_ERROR     The FFS section could not be retrieves due to a                                  device error.   @retval  EFI_ACCESS_DENIED    The FFS section could not be retrieves because the                                  firmware volume that contains the matching FFS                                  section does not allow reads.      **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetSectionFromFfs
parameter_list|(
name|IN
name|EFI_SECTION_TYPE
name|SectionType
parameter_list|,
name|IN
name|UINTN
name|SectionInstance
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Buffer
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
parameter_list|)
block|{
return|return
name|InternalGetSectionFromFv
argument_list|(
name|InternalImageHandleToFvHandle
argument_list|(
name|gImageHandle
argument_list|)
argument_list|,
operator|&
name|gEfiCallerIdGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
name|Buffer
argument_list|,
name|Size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Get the image file buffer data and buffer size by its device path.       Access the file either from a firmware volume, from a file system interface,    or from the load file interface.      Allocate memory to store the found image. The caller is responsible to free memory.    If FilePath is NULL, then NULL is returned.   If FileSize is NULL, then NULL is returned.   If AuthenticationStatus is NULL, then NULL is returned.    @param[in]       BootPolicy           Policy for Open Image File.If TRUE, indicates                                          that the request originates from the boot                                          manager, and that the boot manager is                                         attempting to load FilePath as a boot                                         selection. If FALSE, then FilePath must                                          match an exact file to be loaded.   @param[in]       FilePath             The pointer to the device path of the file                                         that is absracted to the file buffer.   @param[out]      FileSize             The pointer to the size of the abstracted                                          file buffer.   @param[out]      AuthenticationStatus Pointer to the authentication status.    @retval NULL   FilePath is NULL, or FileSize is NULL, or AuthenticationStatus is NULL, or the file can't be found.   @retval other  The abstracted file buffer. The caller is responsible to free memory. **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|GetFileBufferByFilePath
parameter_list|(
name|IN
name|BOOLEAN
name|BootPolicy
parameter_list|,
name|IN
name|CONST
name|EFI_DEVICE_PATH_PROTOCOL
modifier|*
name|FilePath
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|FileSize
parameter_list|,
name|OUT
name|UINT32
modifier|*
name|AuthenticationStatus
parameter_list|)
block|{
name|EFI_DEVICE_PATH_PROTOCOL
modifier|*
name|DevicePathNode
decl_stmt|;
name|EFI_DEVICE_PATH_PROTOCOL
modifier|*
name|OrigDevicePathNode
decl_stmt|;
name|EFI_DEVICE_PATH_PROTOCOL
modifier|*
name|TempDevicePathNode
decl_stmt|;
name|EFI_HANDLE
name|Handle
decl_stmt|;
name|EFI_GUID
modifier|*
name|FvNameGuid
decl_stmt|;
name|EFI_FIRMWARE_VOLUME2_PROTOCOL
modifier|*
name|FwVol
decl_stmt|;
name|EFI_SECTION_TYPE
name|SectionType
decl_stmt|;
name|UINT8
modifier|*
name|ImageBuffer
decl_stmt|;
name|UINTN
name|ImageBufferSize
decl_stmt|;
name|EFI_FV_FILETYPE
name|Type
decl_stmt|;
name|EFI_FV_FILE_ATTRIBUTES
name|Attrib
decl_stmt|;
name|EFI_SIMPLE_FILE_SYSTEM_PROTOCOL
modifier|*
name|Volume
decl_stmt|;
name|EFI_FILE_HANDLE
name|FileHandle
decl_stmt|;
name|EFI_FILE_HANDLE
name|LastHandle
decl_stmt|;
name|EFI_FILE_INFO
modifier|*
name|FileInfo
decl_stmt|;
name|UINTN
name|FileInfoSize
decl_stmt|;
name|EFI_LOAD_FILE_PROTOCOL
modifier|*
name|LoadFile
decl_stmt|;
name|EFI_LOAD_FILE2_PROTOCOL
modifier|*
name|LoadFile2
decl_stmt|;
name|EFI_STATUS
name|Status
decl_stmt|;
comment|//
comment|// Check input File device path.
comment|//
if|if
condition|(
name|FilePath
operator|==
name|NULL
operator|||
name|FileSize
operator|==
name|NULL
operator|||
name|AuthenticationStatus
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// Init local variable
comment|//
name|TempDevicePathNode
operator|=
name|NULL
expr_stmt|;
name|FvNameGuid
operator|=
name|NULL
expr_stmt|;
name|FileInfo
operator|=
name|NULL
expr_stmt|;
name|FileHandle
operator|=
name|NULL
expr_stmt|;
name|ImageBuffer
operator|=
name|NULL
expr_stmt|;
name|ImageBufferSize
operator|=
literal|0
expr_stmt|;
operator|*
name|AuthenticationStatus
operator|=
literal|0
expr_stmt|;
comment|//
comment|// Copy File Device Path
comment|//
name|OrigDevicePathNode
operator|=
name|DuplicateDevicePath
argument_list|(
name|FilePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|OrigDevicePathNode
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// Check whether this device path support FV2 protocol.
comment|// Is so, this device path may contain a Image.
comment|//
name|DevicePathNode
operator|=
name|OrigDevicePathNode
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|LocateDevicePath
argument_list|(
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
operator|&
name|DevicePathNode
argument_list|,
operator|&
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// For FwVol File system there is only a single file name that is a GUID.
comment|//
name|FvNameGuid
operator|=
name|EfiGetNameGuidFromFwVolDevicePathNode
argument_list|(
operator|(
name|CONST
name|MEDIA_FW_VOL_FILEPATH_DEVICE_PATH
operator|*
operator|)
name|DevicePathNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|FvNameGuid
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|EFI_INVALID_PARAMETER
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Read image from the firmware file
comment|//
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|Handle
argument_list|,
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|FwVol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|SectionType
operator|=
name|EFI_SECTION_PE32
expr_stmt|;
name|ImageBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|FwVol
operator|->
name|ReadSection
argument_list|(
name|FwVol
argument_list|,
name|FvNameGuid
argument_list|,
name|SectionType
argument_list|,
literal|0
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|ImageBuffer
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
name|AuthenticationStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Try a raw file, since a PE32 SECTION does not exist
comment|//
if|if
condition|(
name|ImageBuffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|ImageBuffer
argument_list|)
expr_stmt|;
operator|*
name|AuthenticationStatus
operator|=
literal|0
expr_stmt|;
block|}
name|ImageBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|FwVol
operator|->
name|ReadFile
argument_list|(
name|FwVol
argument_list|,
name|FvNameGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|ImageBuffer
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
operator|&
name|Type
argument_list|,
operator|&
name|Attrib
argument_list|,
name|AuthenticationStatus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Finish
goto|;
block|}
block|}
comment|//
comment|// Attempt to access the file via a file system interface
comment|//
name|DevicePathNode
operator|=
name|OrigDevicePathNode
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|LocateDevicePath
argument_list|(
operator|&
name|gEfiSimpleFileSystemProtocolGuid
argument_list|,
operator|&
name|DevicePathNode
argument_list|,
operator|&
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|Handle
argument_list|,
operator|&
name|gEfiSimpleFileSystemProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|Volume
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Open the Volume to get the File System handle
comment|//
name|Status
operator|=
name|Volume
operator|->
name|OpenVolume
argument_list|(
name|Volume
argument_list|,
operator|&
name|FileHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Duplicate the device path to avoid the access to unaligned device path node.
comment|// Because the device path consists of one or more FILE PATH MEDIA DEVICE PATH
comment|// nodes, It assures the fields in device path nodes are 2 byte aligned.
comment|//
name|TempDevicePathNode
operator|=
name|DuplicateDevicePath
argument_list|(
name|DevicePathNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TempDevicePathNode
operator|==
name|NULL
condition|)
block|{
name|FileHandle
operator|->
name|Close
argument_list|(
name|FileHandle
argument_list|)
expr_stmt|;
comment|//
comment|// Setting Status to an EFI_ERROR value will cause the rest of
comment|// the file system support below to be skipped.
comment|//
name|Status
operator|=
name|EFI_OUT_OF_RESOURCES
expr_stmt|;
block|}
comment|//
comment|// Parse each MEDIA_FILEPATH_DP node. There may be more than one, since the
comment|// directory information and filename can be seperate. The goal is to inch
comment|// our way down each device path node and close the previous node
comment|//
name|DevicePathNode
operator|=
name|TempDevicePathNode
expr_stmt|;
while|while
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|&&
operator|!
name|IsDevicePathEnd
argument_list|(
name|DevicePathNode
argument_list|)
condition|)
block|{
if|if
condition|(
name|DevicePathType
argument_list|(
name|DevicePathNode
argument_list|)
operator|!=
name|MEDIA_DEVICE_PATH
operator|||
name|DevicePathSubType
argument_list|(
name|DevicePathNode
argument_list|)
operator|!=
name|MEDIA_FILEPATH_DP
condition|)
block|{
name|Status
operator|=
name|EFI_UNSUPPORTED
expr_stmt|;
break|break;
block|}
name|LastHandle
operator|=
name|FileHandle
expr_stmt|;
name|FileHandle
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|LastHandle
operator|->
name|Open
argument_list|(
name|LastHandle
argument_list|,
operator|&
name|FileHandle
argument_list|,
operator|(
operator|(
name|FILEPATH_DEVICE_PATH
operator|*
operator|)
name|DevicePathNode
operator|)
operator|->
name|PathName
argument_list|,
name|EFI_FILE_MODE_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Close the previous node
comment|//
name|LastHandle
operator|->
name|Close
argument_list|(
name|LastHandle
argument_list|)
expr_stmt|;
name|DevicePathNode
operator|=
name|NextDevicePathNode
argument_list|(
name|DevicePathNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// We have found the file. Now we need to read it. Before we can read the file we need to
comment|// figure out how big the file is.
comment|//
name|FileInfo
operator|=
name|NULL
expr_stmt|;
name|FileInfoSize
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|FileHandle
operator|->
name|GetInfo
argument_list|(
name|FileHandle
argument_list|,
operator|&
name|gEfiFileInfoGuid
argument_list|,
operator|&
name|FileInfoSize
argument_list|,
name|FileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
name|FileInfo
operator|=
name|AllocatePool
argument_list|(
name|FileInfoSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileInfo
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|EFI_OUT_OF_RESOURCES
expr_stmt|;
block|}
else|else
block|{
name|Status
operator|=
name|FileHandle
operator|->
name|GetInfo
argument_list|(
name|FileHandle
argument_list|,
operator|&
name|gEfiFileInfoGuid
argument_list|,
operator|&
name|FileInfoSize
argument_list|,
name|FileInfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|&&
operator|(
name|FileInfo
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|FileInfo
operator|->
name|Attribute
operator|&
name|EFI_FILE_DIRECTORY
operator|)
operator|==
literal|0
condition|)
block|{
comment|//
comment|// Allocate space for the file
comment|//
name|ImageBuffer
operator|=
name|AllocatePool
argument_list|(
operator|(
name|UINTN
operator|)
name|FileInfo
operator|->
name|FileSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ImageBuffer
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|EFI_OUT_OF_RESOURCES
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Read the file into the buffer we allocated
comment|//
name|ImageBufferSize
operator|=
operator|(
name|UINTN
operator|)
name|FileInfo
operator|->
name|FileSize
expr_stmt|;
name|Status
operator|=
name|FileHandle
operator|->
name|Read
argument_list|(
name|FileHandle
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
name|ImageBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Close the file and Free FileInfo and TempDevicePathNode since we are done
comment|//
if|if
condition|(
name|FileInfo
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|FileInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FileHandle
operator|!=
name|NULL
condition|)
block|{
name|FileHandle
operator|->
name|Close
argument_list|(
name|FileHandle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TempDevicePathNode
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|TempDevicePathNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Finish
goto|;
block|}
block|}
comment|//
comment|// Attempt to access the file via LoadFile2 interface
comment|//
if|if
condition|(
operator|!
name|BootPolicy
condition|)
block|{
name|DevicePathNode
operator|=
name|OrigDevicePathNode
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|LocateDevicePath
argument_list|(
operator|&
name|gEfiLoadFile2ProtocolGuid
argument_list|,
operator|&
name|DevicePathNode
argument_list|,
operator|&
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|Handle
argument_list|,
operator|&
name|gEfiLoadFile2ProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|LoadFile2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Call LoadFile2 with the correct buffer size
comment|//
name|ImageBufferSize
operator|=
literal|0
expr_stmt|;
name|ImageBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|LoadFile2
operator|->
name|LoadFile
argument_list|(
name|LoadFile2
argument_list|,
name|DevicePathNode
argument_list|,
name|FALSE
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
name|ImageBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
name|ImageBuffer
operator|=
name|AllocatePool
argument_list|(
name|ImageBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ImageBuffer
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|EFI_OUT_OF_RESOURCES
expr_stmt|;
block|}
else|else
block|{
name|Status
operator|=
name|LoadFile2
operator|->
name|LoadFile
argument_list|(
name|LoadFile2
argument_list|,
name|DevicePathNode
argument_list|,
name|FALSE
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
name|ImageBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Finish
goto|;
block|}
block|}
block|}
comment|//
comment|// Attempt to access the file via LoadFile interface
comment|//
name|DevicePathNode
operator|=
name|OrigDevicePathNode
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|LocateDevicePath
argument_list|(
operator|&
name|gEfiLoadFileProtocolGuid
argument_list|,
operator|&
name|DevicePathNode
argument_list|,
operator|&
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|Handle
argument_list|,
operator|&
name|gEfiLoadFileProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|LoadFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Call LoadFile with the correct buffer size
comment|//
name|ImageBufferSize
operator|=
literal|0
expr_stmt|;
name|ImageBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|LoadFile
operator|->
name|LoadFile
argument_list|(
name|LoadFile
argument_list|,
name|DevicePathNode
argument_list|,
name|BootPolicy
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
name|ImageBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
name|ImageBuffer
operator|=
name|AllocatePool
argument_list|(
name|ImageBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ImageBuffer
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|EFI_OUT_OF_RESOURCES
expr_stmt|;
block|}
else|else
block|{
name|Status
operator|=
name|LoadFile
operator|->
name|LoadFile
argument_list|(
name|LoadFile
argument_list|,
name|DevicePathNode
argument_list|,
name|BootPolicy
argument_list|,
operator|&
name|ImageBufferSize
argument_list|,
name|ImageBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Finish
label|:
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
if|if
condition|(
name|ImageBuffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|ImageBuffer
argument_list|)
expr_stmt|;
name|ImageBuffer
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|FileSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|FileSize
operator|=
name|ImageBufferSize
expr_stmt|;
block|}
name|FreePool
argument_list|(
name|OrigDevicePathNode
argument_list|)
expr_stmt|;
return|return
name|ImageBuffer
return|;
block|}
end_function

begin_comment
comment|/**   Searches all the available firmware volumes and returns the file device path of first matching   FFS section.    This function searches all the firmware volumes for FFS files with an FFS filename specified by NameGuid.   The order that the firmware volumes is searched is not deterministic. For each FFS file found a search   is made for FFS sections of type SectionType.    If SectionType is EFI_SECTION_TE, and the search with an FFS file fails,   the search will be retried with a section type of EFI_SECTION_PE32.   This function must be called with a TPL<= TPL_NOTIFY.    If NameGuid is NULL, then ASSERT().     @param  NameGuid             A pointer to to the FFS filename GUID to search for                                 within any of the firmware volumes in the platform.    @param  SectionType          Indicates the FFS section type to search for within                                 the FFS file specified by NameGuid.    @param  SectionInstance      Indicates which section instance within the FFS file                                 specified by NameGuid to retrieve.    @param  FvFileDevicePath     Device path for the target FFS                                 file.     @retval  EFI_SUCCESS           The specified file device path of FFS section was returned.    @retval  EFI_NOT_FOUND         The specified file device path of FFS section could not be found.    @retval  EFI_DEVICE_ERROR      The FFS section could not be retrieves due to a                                   device error.    @retval  EFI_ACCESS_DENIED     The FFS section could not be retrieves because the                                   firmware volume that contains the matching FFS section does not                                   allow reads.    @retval  EFI_INVALID_PARAMETER FvFileDevicePath is NULL.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetFileDevicePathFromAnyFv
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|NameGuid
parameter_list|,
name|IN
name|EFI_SECTION_TYPE
name|SectionType
parameter_list|,
name|IN
name|UINTN
name|SectionInstance
parameter_list|,
name|OUT
name|EFI_DEVICE_PATH_PROTOCOL
modifier|*
modifier|*
name|FvFileDevicePath
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_HANDLE
modifier|*
name|HandleBuffer
decl_stmt|;
name|UINTN
name|HandleCount
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|EFI_HANDLE
name|FvHandle
decl_stmt|;
name|EFI_DEVICE_PATH_PROTOCOL
modifier|*
name|FvDevicePath
decl_stmt|;
name|MEDIA_FW_VOL_FILEPATH_DEVICE_PATH
modifier|*
name|TempFvFileDevicePath
decl_stmt|;
name|VOID
modifier|*
name|Buffer
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
if|if
condition|(
name|FvFileDevicePath
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
name|HandleBuffer
operator|=
name|NULL
expr_stmt|;
name|FvDevicePath
operator|=
name|NULL
expr_stmt|;
name|TempFvFileDevicePath
operator|=
name|NULL
expr_stmt|;
name|Buffer
operator|=
name|NULL
expr_stmt|;
name|Size
operator|=
literal|0
expr_stmt|;
comment|//
comment|// Search the FV that contain the caller's FFS first.
comment|// FV builder can choose to build FFS into the this FV
comment|// so that this implementation of GetSectionFromAnyFv
comment|// will locate the FFS faster.
comment|//
name|FvHandle
operator|=
name|InternalImageHandleToFvHandle
argument_list|(
name|gImageHandle
argument_list|)
expr_stmt|;
name|Status
operator|=
name|InternalGetSectionFromFv
argument_list|(
name|FvHandle
argument_list|,
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
operator|&
name|Buffer
argument_list|,
operator|&
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
name|Status
operator|=
name|gBS
operator|->
name|LocateHandleBuffer
argument_list|(
name|ByProtocol
argument_list|,
operator|&
name|gEfiFirmwareVolume2ProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|&
name|HandleCount
argument_list|,
operator|&
name|HandleBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Done
goto|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|HandleCount
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// Skip the FV that contain the caller's FFS
comment|//
if|if
condition|(
name|HandleBuffer
index|[
name|Index
index|]
operator|!=
name|FvHandle
condition|)
block|{
name|Status
operator|=
name|InternalGetSectionFromFv
argument_list|(
name|HandleBuffer
index|[
name|Index
index|]
argument_list|,
name|NameGuid
argument_list|,
name|SectionType
argument_list|,
name|SectionInstance
argument_list|,
operator|&
name|Buffer
argument_list|,
operator|&
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Update FvHandle to the current handle.
comment|//
name|FvHandle
operator|=
name|HandleBuffer
index|[
name|Index
index|]
expr_stmt|;
goto|goto
name|Done
goto|;
block|}
block|}
block|}
if|if
condition|(
name|Index
operator|==
name|HandleCount
condition|)
block|{
name|Status
operator|=
name|EFI_NOT_FOUND
expr_stmt|;
block|}
name|Done
label|:
if|if
condition|(
name|Status
operator|==
name|EFI_SUCCESS
condition|)
block|{
comment|//
comment|// Build a device path to the file in the FV to pass into gBS->LoadImage
comment|//
name|Status
operator|=
name|gBS
operator|->
name|HandleProtocol
argument_list|(
name|FvHandle
argument_list|,
operator|&
name|gEfiDevicePathProtocolGuid
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|FvDevicePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
operator|*
name|FvFileDevicePath
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|TempFvFileDevicePath
operator|=
name|AllocateZeroPool
argument_list|(
sizeof|sizeof
argument_list|(
name|MEDIA_FW_VOL_FILEPATH_DEVICE_PATH
argument_list|)
operator|+
name|END_DEVICE_PATH_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|TempFvFileDevicePath
operator|==
name|NULL
condition|)
block|{
operator|*
name|FvFileDevicePath
operator|=
name|NULL
expr_stmt|;
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
name|EfiInitializeFwVolDevicepathNode
argument_list|(
operator|(
name|MEDIA_FW_VOL_FILEPATH_DEVICE_PATH
operator|*
operator|)
name|TempFvFileDevicePath
argument_list|,
name|NameGuid
argument_list|)
expr_stmt|;
name|SetDevicePathEndNode
argument_list|(
name|NextDevicePathNode
argument_list|(
name|TempFvFileDevicePath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|FvFileDevicePath
operator|=
name|AppendDevicePath
argument_list|(
name|FvDevicePath
argument_list|,
operator|(
name|EFI_DEVICE_PATH_PROTOCOL
operator|*
operator|)
name|TempFvFileDevicePath
argument_list|)
expr_stmt|;
name|FreePool
argument_list|(
name|TempFvFileDevicePath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HandleBuffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|HandleBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
end_function

end_unit

