begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Support routines for memory allocation routines based    on SMM Services Table services for SMM phase drivers.      The PI System Management Mode Core Interface Specification only allows the use   of EfiRuntimeServicesCode and EfiRuntimeServicesData memory types for memory    allocations through the SMM Services Table as the SMRAM space should be    reserved after BDS phase.  The functions in the Memory Allocation Library use   EfiBootServicesData as the default memory allocation type.  For this SMM    specific instance of the Memory Allocation Library, EfiRuntimeServicesData    is used as the default memory type for all allocations. In addition,    allocation for the Reserved memory types are not supported and will always    return NULL.    Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials                             are licensed and made available under the terms and conditions of the BSD License            which accompanies this distribution.  The full text of the license may be found at           http://opensource.org/licenses/bsd-license.php.                                                THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                        WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.               **/
end_comment

begin_include
include|#
directive|include
file|<PiSmm.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/SmmAccess2.h>
end_include

begin_include
include|#
directive|include
file|<Library/MemoryAllocationLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/UefiBootServicesTableLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/SmmServicesTableLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseMemoryLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_decl_stmt
name|EFI_SMRAM_DESCRIPTOR
modifier|*
name|mSmramRanges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UINTN
name|mSmramRangeCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**   The constructor function caches SMRAM ranges that are present in the system.        It will ASSERT() if SMM Access2 Protocol doesn't exist.   It will ASSERT() if SMRAM ranges can't be got.   It will ASSERT() if Resource can't be allocated for cache SMRAM range.    It will always return EFI_SUCCESS.    @param  ImageHandle   The firmware allocated handle for the EFI image.   @param  SystemTable   A pointer to the EFI System Table.    @retval EFI_SUCCESS   The constructor always returns EFI_SUCCESS.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmMemoryAllocationLibConstructor
parameter_list|(
name|IN
name|EFI_HANDLE
name|ImageHandle
parameter_list|,
name|IN
name|EFI_SYSTEM_TABLE
modifier|*
name|SystemTable
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_SMM_ACCESS2_PROTOCOL
modifier|*
name|SmmAccess
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
comment|//
comment|// Locate SMM Access2 Protocol
comment|//
name|Status
operator|=
name|gBS
operator|->
name|LocateProtocol
argument_list|(
operator|&
name|gEfiSmmAccess2ProtocolGuid
argument_list|,
name|NULL
argument_list|,
operator|(
name|VOID
operator|*
operator|*
operator|)
operator|&
name|SmmAccess
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|//
comment|// Get SMRAM range information
comment|//
name|Size
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|SmmAccess
operator|->
name|GetCapabilities
argument_list|(
name|SmmAccess
argument_list|,
operator|&
name|Size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
name|mSmramRanges
operator|=
operator|(
name|EFI_SMRAM_DESCRIPTOR
operator|*
operator|)
name|AllocatePool
argument_list|(
name|Size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mSmramRanges
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Status
operator|=
name|SmmAccess
operator|->
name|GetCapabilities
argument_list|(
name|SmmAccess
argument_list|,
operator|&
name|Size
argument_list|,
name|mSmramRanges
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
name|mSmramRangeCount
operator|=
name|Size
operator|/
sizeof|sizeof
argument_list|(
name|EFI_SMRAM_DESCRIPTOR
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   If SMM driver exits with an error, it must call this routine    to free the allocated resource before the exiting.    @param[in]  ImageHandle   The firmware allocated handle for the EFI image.   @param[in]  SystemTable   A pointer to the EFI System Table.    @retval     EFI_SUCCESS   The deconstructor always returns EFI_SUCCESS. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|SmmMemoryAllocationLibDestructor
parameter_list|(
name|IN
name|EFI_HANDLE
name|ImageHandle
parameter_list|,
name|IN
name|EFI_SYSTEM_TABLE
modifier|*
name|SystemTable
parameter_list|)
block|{
name|FreePool
argument_list|(
name|mSmramRanges
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Check whether the start address of buffer is within any of the SMRAM ranges.    @param[in]  Buffer   The pointer to the buffer to be checked.    @retval     TRUE     The buffer is in SMRAM ranges.   @retval     FALSE    The buffer is out of SMRAM ranges. **/
end_comment

begin_function
name|BOOLEAN
name|EFIAPI
name|BufferInSmram
parameter_list|(
name|IN
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|mSmramRangeCount
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
operator|>=
name|mSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|)
operator|&&
operator|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
operator|<
operator|(
name|mSmramRanges
index|[
name|Index
index|]
operator|.
name|CpuStart
operator|+
name|mSmramRanges
index|[
name|Index
index|]
operator|.
name|PhysicalSize
operator|)
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of a certain memory type.    Allocates the number of 4KB pages of a certain memory type and returns a pointer    to the allocated buffer.  The buffer returned is aligned on a 4KB boundary.  If    Pages is 0, then NULL is returned.   If there is not enough memory remaining to    satisfy the request, then NULL is returned.    @param  MemoryType            The type of memory to allocate.   @param  Pages                 The number of 4 KB pages to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|InternalAllocatePages
parameter_list|(
name|IN
name|EFI_MEMORY_TYPE
name|MemoryType
parameter_list|,
name|IN
name|UINTN
name|Pages
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_PHYSICAL_ADDRESS
name|Memory
decl_stmt|;
if|if
condition|(
name|Pages
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|Status
operator|=
name|gSmst
operator|->
name|SmmAllocatePages
argument_list|(
name|AllocateAnyPages
argument_list|,
name|MemoryType
argument_list|,
name|Pages
argument_list|,
operator|&
name|Memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|VOID
operator|*
operator|)
operator|(
name|UINTN
operator|)
name|Memory
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of type EfiRuntimeServicesData.    Allocates the number of 4KB pages of type EfiRuntimeServicesData and returns a pointer    to the allocated buffer.  The buffer returned is aligned on a 4KB boundary.  If    Pages is 0, then NULL is returned.  If there is not enough memory remaining to    satisfy the request, then NULL is returned.    @param  Pages                 The number of 4 KB pages to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocatePages
parameter_list|(
name|IN
name|UINTN
name|Pages
parameter_list|)
block|{
return|return
name|InternalAllocatePages
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|Pages
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of type EfiRuntimeServicesData.    Allocates the number of 4KB pages of type EfiRuntimeServicesData and returns a    pointer to the allocated buffer.  The buffer returned is aligned on a 4KB boundary.     If Pages is 0, then NULL is returned.  If there is not enough memory remaining    to satisfy the request, then NULL is returned.    @param  Pages                 The number of 4 KB pages to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateRuntimePages
parameter_list|(
name|IN
name|UINTN
name|Pages
parameter_list|)
block|{
return|return
name|InternalAllocatePages
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|Pages
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of type EfiReservedMemoryType.    Allocates the number of 4KB pages of type EfiReservedMemoryType and returns a    pointer to the allocated buffer.  The buffer returned is aligned on a 4KB boundary.     If Pages is 0, then NULL is returned.  If there is not enough memory remaining    to satisfy the request, then NULL is returned.    @param  Pages                 The number of 4 KB pages to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateReservedPages
parameter_list|(
name|IN
name|UINTN
name|Pages
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Frees one or more 4KB pages that were previously allocated with one of the page allocation   functions in the Memory Allocation Library.    Frees the number of 4KB pages specified by Pages from the buffer specified by Buffer.     Buffer must have been allocated on a previous call to the page allocation services    of the Memory Allocation Library.  If it is not possible to free allocated pages,    then this function will perform no actions.      If Buffer was not allocated with a page allocation function in the Memory Allocation    Library, then ASSERT().   If Pages is zero, then ASSERT().     @param  Buffer                The pointer to the buffer of pages to free.   @param  Pages                 The number of 4 KB pages to free.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|FreePages
parameter_list|(
name|IN
name|VOID
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Pages
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|ASSERT
argument_list|(
name|Pages
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferInSmram
argument_list|(
name|Buffer
argument_list|)
condition|)
block|{
comment|//
comment|// When Buffer is in SMRAM range, it should be allocated by gSmst->SmmAllocatePages() service.
comment|// So, gSmst->SmmFreePages() service is used to free it.
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmFreePages
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
argument_list|,
name|Pages
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// When Buffer is out of SMRAM range, it should be allocated by gBS->AllocatePages() service.
comment|// So, gBS->FreePages() service is used to free it.
comment|//
name|Status
operator|=
name|gBS
operator|->
name|FreePages
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
argument_list|,
name|Pages
argument_list|)
expr_stmt|;
block|}
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of a certain memory type at a specified alignment.    Allocates the number of 4KB pages specified by Pages of a certain memory type    with an alignment specified by Alignment.  The allocated buffer is returned.     If Pages is 0, then NULL is returned. If there is not enough memory at the    specified alignment remaining to satisfy the request, then NULL is returned.   If Alignment is not a power of two and Alignment is not zero, then ASSERT().   If Pages plus EFI_SIZE_TO_PAGES (Alignment) overflows, then ASSERT().    @param  MemoryType            The type of memory to allocate.   @param  Pages                 The number of 4 KB pages to allocate.   @param  Alignment             The requested alignment of the allocation.                                   Must be a power of two.                                 If Alignment is zero, then byte alignment is used.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|InternalAllocateAlignedPages
parameter_list|(
name|IN
name|EFI_MEMORY_TYPE
name|MemoryType
parameter_list|,
name|IN
name|UINTN
name|Pages
parameter_list|,
name|IN
name|UINTN
name|Alignment
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_PHYSICAL_ADDRESS
name|Memory
decl_stmt|;
name|UINTN
name|AlignedMemory
decl_stmt|;
name|UINTN
name|AlignmentMask
decl_stmt|;
name|UINTN
name|UnalignedPages
decl_stmt|;
name|UINTN
name|RealPages
decl_stmt|;
comment|//
comment|// Alignment must be a power of two or zero.
comment|//
name|ASSERT
argument_list|(
operator|(
name|Alignment
operator|&
operator|(
name|Alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pages
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|Alignment
operator|>
name|EFI_PAGE_SIZE
condition|)
block|{
comment|//
comment|// Calculate the total number of pages since alignment is larger than page size.
comment|//
name|AlignmentMask
operator|=
name|Alignment
operator|-
literal|1
expr_stmt|;
name|RealPages
operator|=
name|Pages
operator|+
name|EFI_SIZE_TO_PAGES
argument_list|(
name|Alignment
argument_list|)
expr_stmt|;
comment|//
comment|// Make sure that Pages plus EFI_SIZE_TO_PAGES (Alignment) does not overflow.
comment|//
name|ASSERT
argument_list|(
name|RealPages
operator|>
name|Pages
argument_list|)
expr_stmt|;
name|Status
operator|=
name|gSmst
operator|->
name|SmmAllocatePages
argument_list|(
name|AllocateAnyPages
argument_list|,
name|MemoryType
argument_list|,
name|RealPages
argument_list|,
operator|&
name|Memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|AlignedMemory
operator|=
operator|(
operator|(
name|UINTN
operator|)
name|Memory
operator|+
name|AlignmentMask
operator|)
operator|&
operator|~
name|AlignmentMask
expr_stmt|;
name|UnalignedPages
operator|=
name|EFI_SIZE_TO_PAGES
argument_list|(
name|AlignedMemory
operator|-
operator|(
name|UINTN
operator|)
name|Memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|UnalignedPages
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Free first unaligned page(s).
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmFreePages
argument_list|(
name|Memory
argument_list|,
name|UnalignedPages
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
name|Memory
operator|=
name|AlignedMemory
operator|+
name|EFI_PAGES_TO_SIZE
argument_list|(
name|Pages
argument_list|)
expr_stmt|;
name|UnalignedPages
operator|=
name|RealPages
operator|-
name|Pages
operator|-
name|UnalignedPages
expr_stmt|;
if|if
condition|(
name|UnalignedPages
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Free last unaligned page(s).
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmFreePages
argument_list|(
name|Memory
argument_list|,
name|UnalignedPages
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// Do not over-allocate pages in this case.
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmAllocatePages
argument_list|(
name|AllocateAnyPages
argument_list|,
name|MemoryType
argument_list|,
name|Pages
argument_list|,
operator|&
name|Memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|AlignedMemory
operator|=
operator|(
name|UINTN
operator|)
name|Memory
expr_stmt|;
block|}
return|return
operator|(
name|VOID
operator|*
operator|)
name|AlignedMemory
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of type EfiRuntimeServicesData at a specified alignment.    Allocates the number of 4KB pages specified by Pages of type EfiRuntimeServicesData    with an alignment specified by Alignment.  The allocated buffer is returned.     If Pages is 0, then NULL is returned.  If there is not enough memory at the    specified alignment remaining to satisfy the request, then NULL is returned.      If Alignment is not a power of two and Alignment is not zero, then ASSERT().   If Pages plus EFI_SIZE_TO_PAGES (Alignment) overflows, then ASSERT().    @param  Pages                 The number of 4 KB pages to allocate.   @param  Alignment             The requested alignment of the allocation.                                   Must be a power of two.                                 If Alignment is zero, then byte alignment is used.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateAlignedPages
parameter_list|(
name|IN
name|UINTN
name|Pages
parameter_list|,
name|IN
name|UINTN
name|Alignment
parameter_list|)
block|{
return|return
name|InternalAllocateAlignedPages
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|Pages
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of type EfiRuntimeServicesData at a specified alignment.    Allocates the number of 4KB pages specified by Pages of type EfiRuntimeServicesData    with an alignment specified by Alignment.  The allocated buffer is returned.     If Pages is 0, then NULL is returned.  If there is not enough memory at the    specified alignment remaining to satisfy the request, then NULL is returned.      If Alignment is not a power of two and Alignment is not zero, then ASSERT().   If Pages plus EFI_SIZE_TO_PAGES (Alignment) overflows, then ASSERT().    @param  Pages                 The number of 4 KB pages to allocate.   @param  Alignment             The requested alignment of the allocation.                                   Must be a power of two.                                 If Alignment is zero, then byte alignment is used.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateAlignedRuntimePages
parameter_list|(
name|IN
name|UINTN
name|Pages
parameter_list|,
name|IN
name|UINTN
name|Alignment
parameter_list|)
block|{
return|return
name|InternalAllocateAlignedPages
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|Pages
argument_list|,
name|Alignment
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates one or more 4KB pages of type EfiReservedMemoryType at a specified alignment.    Allocates the number of 4KB pages specified by Pages of type EfiReservedMemoryType    with an alignment specified by Alignment.  The allocated buffer is returned.     If Pages is 0, then NULL is returned.  If there is not enough memory at the    specified alignment remaining to satisfy the request, then NULL is returned.      If Alignment is not a power of two and Alignment is not zero, then ASSERT().   If Pages plus EFI_SIZE_TO_PAGES (Alignment) overflows, then ASSERT().    @param  Pages                 The number of 4 KB pages to allocate.   @param  Alignment             The requested alignment of the allocation.                                   Must be a power of two.                                 If Alignment is zero, then byte alignment is used.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateAlignedReservedPages
parameter_list|(
name|IN
name|UINTN
name|Pages
parameter_list|,
name|IN
name|UINTN
name|Alignment
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Frees one or more 4KB pages that were previously allocated with one of the aligned page   allocation functions in the Memory Allocation Library.    Frees the number of 4KB pages specified by Pages from the buffer specified by    Buffer.  Buffer must have been allocated on a previous call to the aligned page    allocation services of the Memory Allocation Library.  If it is not possible to    free allocated pages, then this function will perform no actions.      If Buffer was not allocated with an aligned page allocation function in the    Memory Allocation Library, then ASSERT().   If Pages is zero, then ASSERT().      @param  Buffer                The pointer to the buffer of pages to free.   @param  Pages                 The number of 4 KB pages to free.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|FreeAlignedPages
parameter_list|(
name|IN
name|VOID
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Pages
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|ASSERT
argument_list|(
name|Pages
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferInSmram
argument_list|(
name|Buffer
argument_list|)
condition|)
block|{
comment|//
comment|// When Buffer is in SMRAM range, it should be allocated by gSmst->SmmAllocatePages() service.
comment|// So, gSmst->SmmFreePages() service is used to free it.
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmFreePages
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
argument_list|,
name|Pages
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// When Buffer is out of SMRAM range, it should be allocated by gBS->AllocatePages() service.
comment|// So, gBS->FreePages() service is used to free it.
comment|//
name|Status
operator|=
name|gBS
operator|->
name|FreePages
argument_list|(
operator|(
name|EFI_PHYSICAL_ADDRESS
operator|)
operator|(
name|UINTN
operator|)
name|Buffer
argument_list|,
name|Pages
argument_list|)
expr_stmt|;
block|}
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Allocates a buffer of a certain pool type.    Allocates the number bytes specified by AllocationSize of a certain pool type    and returns a pointer to the allocated buffer.  If AllocationSize is 0, then a    valid buffer of 0 size is returned.  If there is not enough memory remaining to    satisfy the request, then NULL is returned.    @param  MemoryType            The type of memory to allocate.   @param  AllocationSize        The number of bytes to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|InternalAllocatePool
parameter_list|(
name|IN
name|EFI_MEMORY_TYPE
name|MemoryType
parameter_list|,
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|VOID
modifier|*
name|Memory
decl_stmt|;
name|Status
operator|=
name|gSmst
operator|->
name|SmmAllocatePool
argument_list|(
name|MemoryType
argument_list|,
name|AllocationSize
argument_list|,
operator|&
name|Memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|Memory
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|Memory
return|;
block|}
end_function

begin_comment
comment|/**   Allocates a buffer of type EfiRuntimeServicesData.    Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData    and returns a pointer to the allocated buffer.  If AllocationSize is 0, then a    valid buffer of 0 size is returned.  If there is not enough memory remaining to    satisfy the request, then NULL is returned.    @param  AllocationSize        The number of bytes to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocatePool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
return|return
name|InternalAllocatePool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|AllocationSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates a buffer of type EfiRuntimeServicesData.    Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData    and returns a pointer to the allocated buffer.  If AllocationSize is 0, then a    valid buffer of 0 size is returned.  If there is not enough memory remaining to    satisfy the request, then NULL is returned.    @param  AllocationSize        The number of bytes to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateRuntimePool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
return|return
name|InternalAllocatePool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|AllocationSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates a buffer of type EfiReservedMemoryType.    Allocates the number bytes specified by AllocationSize of type EfiReservedMemoryType    and returns a pointer to the allocated buffer.  If AllocationSize is 0, then a    valid buffer of 0 size is returned.  If there is not enough memory remaining to    satisfy the request, then NULL is returned.    @param  AllocationSize        The number of bytes to allocate.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateReservedPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Allocates and zeros a buffer of a certain pool type.    Allocates the number bytes specified by AllocationSize of a certain pool type,    clears the buffer with zeros, and returns a pointer to the allocated buffer.     If AllocationSize is 0, then a valid buffer of 0 size is returned.  If there is    not enough memory remaining to satisfy the request, then NULL is returned.    @param  PoolType              The type of memory to allocate.   @param  AllocationSize        The number of bytes to allocate and zero.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|InternalAllocateZeroPool
parameter_list|(
name|IN
name|EFI_MEMORY_TYPE
name|PoolType
parameter_list|,
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
name|VOID
modifier|*
name|Memory
decl_stmt|;
name|Memory
operator|=
name|InternalAllocatePool
argument_list|(
name|PoolType
argument_list|,
name|AllocationSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|Memory
operator|!=
name|NULL
condition|)
block|{
name|Memory
operator|=
name|ZeroMem
argument_list|(
name|Memory
argument_list|,
name|AllocationSize
argument_list|)
expr_stmt|;
block|}
return|return
name|Memory
return|;
block|}
end_function

begin_comment
comment|/**   Allocates and zeros a buffer of type EfiRuntimeServicesData.    Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData,    clears the buffer with zeros, and returns a pointer to the allocated buffer.     If AllocationSize is 0, then a valid buffer of 0 size is returned.  If there is    not enough memory remaining to satisfy the request, then NULL is returned.    @param  AllocationSize        The number of bytes to allocate and zero.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateZeroPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
return|return
name|InternalAllocateZeroPool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|AllocationSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates and zeros a buffer of type EfiRuntimeServicesData.    Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData,    clears the buffer with zeros, and returns a pointer to the allocated buffer.     If AllocationSize is 0, then a valid buffer of 0 size is returned.  If there is    not enough memory remaining to satisfy the request, then NULL is returned.    @param  AllocationSize        The number of bytes to allocate and zero.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateRuntimeZeroPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
return|return
name|InternalAllocateZeroPool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|AllocationSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Allocates and zeros a buffer of type EfiReservedMemoryType.    Allocates the number bytes specified by AllocationSize of type EfiReservedMemoryType,    clears the   buffer with zeros, and returns a pointer to the allocated buffer.     If AllocationSize is 0, then a valid buffer of 0 size is returned.  If there is    not enough memory remaining to satisfy the request, then NULL is returned.    @param  AllocationSize        The number of bytes to allocate and zero.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateReservedZeroPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Copies a buffer to an allocated buffer of a certain pool type.    Allocates the number bytes specified by AllocationSize of a certain pool type,    copies AllocationSize bytes from Buffer to the newly allocated buffer, and returns    a pointer to the allocated buffer.  If AllocationSize is 0, then a valid buffer    of 0 size is returned.  If there is not enough memory remaining to satisfy the    request, then NULL is returned. If Buffer is NULL, then ASSERT().   If AllocationSize is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().     @param  PoolType              The type of pool to allocate.   @param  AllocationSize        The number of bytes to allocate and zero.   @param  Buffer                The buffer to copy to the allocated buffer.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|InternalAllocateCopyPool
parameter_list|(
name|IN
name|EFI_MEMORY_TYPE
name|PoolType
parameter_list|,
name|IN
name|UINTN
name|AllocationSize
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
name|VOID
modifier|*
name|Memory
decl_stmt|;
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|AllocationSize
operator|<=
operator|(
name|MAX_ADDRESS
operator|-
operator|(
name|UINTN
operator|)
name|Buffer
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|Memory
operator|=
name|InternalAllocatePool
argument_list|(
name|PoolType
argument_list|,
name|AllocationSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|Memory
operator|!=
name|NULL
condition|)
block|{
name|Memory
operator|=
name|CopyMem
argument_list|(
name|Memory
argument_list|,
name|Buffer
argument_list|,
name|AllocationSize
argument_list|)
expr_stmt|;
block|}
return|return
name|Memory
return|;
block|}
end_function

begin_comment
comment|/**   Copies a buffer to an allocated buffer of type EfiRuntimeServicesData.    Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData,    copies AllocationSize bytes from Buffer to the newly allocated buffer, and returns    a pointer to the allocated buffer.  If AllocationSize is 0, then a valid buffer    of 0 size is returned.  If there is not enough memory remaining to satisfy the    request, then NULL is returned.      If Buffer is NULL, then ASSERT().   If AllocationSize is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().     @param  AllocationSize        The number of bytes to allocate and zero.   @param  Buffer                The buffer to copy to the allocated buffer.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateCopyPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
return|return
name|InternalAllocateCopyPool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|AllocationSize
argument_list|,
name|Buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Copies a buffer to an allocated buffer of type EfiRuntimeServicesData.    Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData,    copies AllocationSize bytes from Buffer to the newly allocated buffer, and returns    a pointer to the allocated buffer.  If AllocationSize is 0, then a valid buffer    of 0 size is returned.  If there is not enough memory remaining to satisfy the    request, then NULL is returned.      If Buffer is NULL, then ASSERT().   If AllocationSize is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().     @param  AllocationSize        The number of bytes to allocate and zero.   @param  Buffer                The buffer to copy to the allocated buffer.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateRuntimeCopyPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
return|return
name|InternalAllocateCopyPool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|AllocationSize
argument_list|,
name|Buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Copies a buffer to an allocated buffer of type EfiReservedMemoryType.    Allocates the number bytes specified by AllocationSize of type EfiReservedMemoryType,    copies AllocationSize bytes from Buffer to the newly allocated buffer, and returns    a pointer to the allocated buffer.  If AllocationSize is 0, then a valid buffer    of 0 size is returned.  If there is not enough memory remaining to satisfy the    request, then NULL is returned.      If Buffer is NULL, then ASSERT().   If AllocationSize is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().     @param  AllocationSize        The number of bytes to allocate and zero.   @param  Buffer                The buffer to copy to the allocated buffer.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|AllocateReservedCopyPool
parameter_list|(
name|IN
name|UINTN
name|AllocationSize
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Reallocates a buffer of a specified memory type.    Allocates and zeros the number bytes specified by NewSize from memory of the type   specified by PoolType.  If OldBuffer is not NULL, then the smaller of OldSize and    NewSize bytes are copied from OldBuffer to the newly allocated buffer, and    OldBuffer is freed.  A pointer to the newly allocated buffer is returned.     If NewSize is 0, then a valid buffer of 0 size is  returned.  If there is not    enough memory remaining to satisfy the request, then NULL is returned.      If the allocation of the new buffer is successful and the smaller of NewSize    and OldSize is greater than (MAX_ADDRESS - OldBuffer + 1), then ASSERT().    @param  PoolType       The type of pool to allocate.   @param  OldSize        The size, in bytes, of OldBuffer.   @param  NewSize        The size, in bytes, of the buffer to reallocate.   @param  OldBuffer      The buffer to copy to the allocated buffer.  This is an                           optional parameter that may be NULL.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|InternalReallocatePool
parameter_list|(
name|IN
name|EFI_MEMORY_TYPE
name|PoolType
parameter_list|,
name|IN
name|UINTN
name|OldSize
parameter_list|,
name|IN
name|UINTN
name|NewSize
parameter_list|,
name|IN
name|VOID
modifier|*
name|OldBuffer
name|OPTIONAL
parameter_list|)
block|{
name|VOID
modifier|*
name|NewBuffer
decl_stmt|;
name|NewBuffer
operator|=
name|InternalAllocateZeroPool
argument_list|(
name|PoolType
argument_list|,
name|NewSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewBuffer
operator|!=
name|NULL
operator|&&
name|OldBuffer
operator|!=
name|NULL
condition|)
block|{
name|CopyMem
argument_list|(
name|NewBuffer
argument_list|,
name|OldBuffer
argument_list|,
name|MIN
argument_list|(
name|OldSize
argument_list|,
name|NewSize
argument_list|)
argument_list|)
expr_stmt|;
name|FreePool
argument_list|(
name|OldBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|NewBuffer
return|;
block|}
end_function

begin_comment
comment|/**   Reallocates a buffer of type EfiRuntimeServicesData.    Allocates and zeros the number bytes specified by NewSize from memory of type   EfiRuntimeServicesData.  If OldBuffer is not NULL, then the smaller of OldSize and    NewSize bytes are copied from OldBuffer to the newly allocated buffer, and    OldBuffer is freed.  A pointer to the newly allocated buffer is returned.     If NewSize is 0, then a valid buffer of 0 size is  returned.  If there is not    enough memory remaining to satisfy the request, then NULL is returned.      If the allocation of the new buffer is successful and the smaller of NewSize    and OldSize is greater than (MAX_ADDRESS - OldBuffer + 1), then ASSERT().    @param  OldSize        The size, in bytes, of OldBuffer.   @param  NewSize        The size, in bytes, of the buffer to reallocate.   @param  OldBuffer      The buffer to copy to the allocated buffer.  This is an                           optional parameter that may be NULL.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|ReallocatePool
parameter_list|(
name|IN
name|UINTN
name|OldSize
parameter_list|,
name|IN
name|UINTN
name|NewSize
parameter_list|,
name|IN
name|VOID
modifier|*
name|OldBuffer
name|OPTIONAL
parameter_list|)
block|{
return|return
name|InternalReallocatePool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|OldSize
argument_list|,
name|NewSize
argument_list|,
name|OldBuffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Reallocates a buffer of type EfiRuntimeServicesData.    Allocates and zeros the number bytes specified by NewSize from memory of type   EfiRuntimeServicesData.  If OldBuffer is not NULL, then the smaller of OldSize    and NewSize bytes are copied from OldBuffer to the newly allocated buffer, and    OldBuffer is freed.  A pointer to the newly allocated buffer is returned.     If NewSize is 0, then a valid buffer of 0 size is  returned.  If there is not    enough memory remaining to satisfy the request, then NULL is returned.    If the allocation of the new buffer is successful and the smaller of NewSize    and OldSize is greater than (MAX_ADDRESS - OldBuffer + 1), then ASSERT().    @param  OldSize        The size, in bytes, of OldBuffer.   @param  NewSize        The size, in bytes, of the buffer to reallocate.   @param  OldBuffer      The buffer to copy to the allocated buffer.  This is an                           optional parameter that may be NULL.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|ReallocateRuntimePool
parameter_list|(
name|IN
name|UINTN
name|OldSize
parameter_list|,
name|IN
name|UINTN
name|NewSize
parameter_list|,
name|IN
name|VOID
modifier|*
name|OldBuffer
name|OPTIONAL
parameter_list|)
block|{
return|return
name|InternalReallocatePool
argument_list|(
name|EfiRuntimeServicesData
argument_list|,
name|OldSize
argument_list|,
name|NewSize
argument_list|,
name|OldBuffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Reallocates a buffer of type EfiReservedMemoryType.    Allocates and zeros the number bytes specified by NewSize from memory of type   EfiReservedMemoryType.  If OldBuffer is not NULL, then the smaller of OldSize    and NewSize bytes are copied from OldBuffer to the newly allocated buffer, and    OldBuffer is freed.  A pointer to the newly allocated buffer is returned.     If NewSize is 0, then a valid buffer of 0 size is  returned.  If there is not    enough memory remaining to satisfy the request, then NULL is returned.    If the allocation of the new buffer is successful and the smaller of NewSize    and OldSize is greater than (MAX_ADDRESS - OldBuffer + 1), then ASSERT().    @param  OldSize        The size, in bytes, of OldBuffer.   @param  NewSize        The size, in bytes, of the buffer to reallocate.   @param  OldBuffer      The buffer to copy to the allocated buffer.  This is an                           optional parameter that may be NULL.    @return A pointer to the allocated buffer or NULL if allocation fails.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|ReallocateReservedPool
parameter_list|(
name|IN
name|UINTN
name|OldSize
parameter_list|,
name|IN
name|UINTN
name|NewSize
parameter_list|,
name|IN
name|VOID
modifier|*
name|OldBuffer
name|OPTIONAL
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Frees a buffer that was previously allocated with one of the pool allocation    functions in the Memory Allocation Library.    Frees the buffer specified by Buffer.  Buffer must have been allocated on a    previous call to the pool allocation services of the Memory Allocation Library.     If it is not possible to free pool resources, then this function will perform    no actions.      If Buffer was not allocated with a pool allocation function in the Memory    Allocation Library, then ASSERT().    @param  Buffer                The pointer to the buffer to free.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|FreePool
parameter_list|(
name|IN
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
name|BufferInSmram
argument_list|(
name|Buffer
argument_list|)
condition|)
block|{
comment|//
comment|// When Buffer is in SMRAM range, it should be allocated by gSmst->SmmAllocatePool() service.
comment|// So, gSmst->SmmFreePool() service is used to free it.
comment|//
name|Status
operator|=
name|gSmst
operator|->
name|SmmFreePool
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// When Buffer is out of SMRAM range, it should be allocated by gBS->AllocatePool() service.
comment|// So, gBS->FreePool() service is used to free it.
comment|//
name|Status
operator|=
name|gBS
operator|->
name|FreePool
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
block|}
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

