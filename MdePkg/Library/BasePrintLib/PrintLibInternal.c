begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Print Library internal worker functions.    Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|"PrintLibInternal.h"
end_include

begin_define
define|#
directive|define
name|WARNING_STATUS_NUMBER
value|5
end_define

begin_define
define|#
directive|define
name|ERROR_STATUS_NUMBER
value|33
end_define

begin_comment
comment|//
end_comment

begin_comment
comment|// Safe print checks
end_comment

begin_comment
comment|//
end_comment

begin_define
define|#
directive|define
name|RSIZE_MAX
value|(PcdGet32 (PcdMaximumUnicodeStringLength))
end_define

begin_define
define|#
directive|define
name|ASCII_RSIZE_MAX
value|(PcdGet32 (PcdMaximumAsciiStringLength))
end_define

begin_define
define|#
directive|define
name|SAFE_PRINT_CONSTRAINT_CHECK
parameter_list|(
name|Expression
parameter_list|,
name|RetVal
parameter_list|)
define|\
value|do { \     ASSERT (Expression); \     if (!(Expression)) { \       return RetVal; \     } \   } while (FALSE)
end_define

begin_decl_stmt
name|GLOBAL_REMOVE_IF_UNREFERENCED
name|CONST
name|CHAR8
name|mHexStr
index|[]
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GLOBAL_REMOVE_IF_UNREFERENCED
name|CONST
name|CHAR8
modifier|*
name|CONST
name|mStatusString
index|[]
init|=
block|{
literal|"Success"
block|,
comment|//  RETURN_SUCCESS                = 0
literal|"Warning Unknown Glyph"
block|,
comment|//  RETURN_WARN_UNKNOWN_GLYPH     = 1
literal|"Warning Delete Failure"
block|,
comment|//  RETURN_WARN_DELETE_FAILURE    = 2
literal|"Warning Write Failure"
block|,
comment|//  RETURN_WARN_WRITE_FAILURE     = 3
literal|"Warning Buffer Too Small"
block|,
comment|//  RETURN_WARN_BUFFER_TOO_SMALL  = 4
literal|"Warning Stale Data"
block|,
comment|//  RETURN_WARN_STALE_DATA        = 5
literal|"Load Error"
block|,
comment|//  RETURN_LOAD_ERROR             = 1  | MAX_BIT
literal|"Invalid Parameter"
block|,
comment|//  RETURN_INVALID_PARAMETER      = 2  | MAX_BIT
literal|"Unsupported"
block|,
comment|//  RETURN_UNSUPPORTED            = 3  | MAX_BIT
literal|"Bad Buffer Size"
block|,
comment|//  RETURN_BAD_BUFFER_SIZE        = 4  | MAX_BIT
literal|"Buffer Too Small"
block|,
comment|//  RETURN_BUFFER_TOO_SMALL,      = 5  | MAX_BIT
literal|"Not Ready"
block|,
comment|//  RETURN_NOT_READY              = 6  | MAX_BIT
literal|"Device Error"
block|,
comment|//  RETURN_DEVICE_ERROR           = 7  | MAX_BIT
literal|"Write Protected"
block|,
comment|//  RETURN_WRITE_PROTECTED        = 8  | MAX_BIT
literal|"Out of Resources"
block|,
comment|//  RETURN_OUT_OF_RESOURCES       = 9  | MAX_BIT
literal|"Volume Corrupt"
block|,
comment|//  RETURN_VOLUME_CORRUPTED       = 10 | MAX_BIT
literal|"Volume Full"
block|,
comment|//  RETURN_VOLUME_FULL            = 11 | MAX_BIT
literal|"No Media"
block|,
comment|//  RETURN_NO_MEDIA               = 12 | MAX_BIT
literal|"Media changed"
block|,
comment|//  RETURN_MEDIA_CHANGED          = 13 | MAX_BIT
literal|"Not Found"
block|,
comment|//  RETURN_NOT_FOUND              = 14 | MAX_BIT
literal|"Access Denied"
block|,
comment|//  RETURN_ACCESS_DENIED          = 15 | MAX_BIT
literal|"No Response"
block|,
comment|//  RETURN_NO_RESPONSE            = 16 | MAX_BIT
literal|"No mapping"
block|,
comment|//  RETURN_NO_MAPPING             = 17 | MAX_BIT
literal|"Time out"
block|,
comment|//  RETURN_TIMEOUT                = 18 | MAX_BIT
literal|"Not started"
block|,
comment|//  RETURN_NOT_STARTED            = 19 | MAX_BIT
literal|"Already started"
block|,
comment|//  RETURN_ALREADY_STARTED        = 20 | MAX_BIT
literal|"Aborted"
block|,
comment|//  RETURN_ABORTED                = 21 | MAX_BIT
literal|"ICMP Error"
block|,
comment|//  RETURN_ICMP_ERROR             = 22 | MAX_BIT
literal|"TFTP Error"
block|,
comment|//  RETURN_TFTP_ERROR             = 23 | MAX_BIT
literal|"Protocol Error"
block|,
comment|//  RETURN_PROTOCOL_ERROR         = 24 | MAX_BIT
literal|"Incompatible Version"
block|,
comment|//  RETURN_INCOMPATIBLE_VERSION   = 25 | MAX_BIT
literal|"Security Violation"
block|,
comment|//  RETURN_SECURITY_VIOLATION     = 26 | MAX_BIT
literal|"CRC Error"
block|,
comment|//  RETURN_CRC_ERROR              = 27 | MAX_BIT
literal|"End of Media"
block|,
comment|//  RETURN_END_OF_MEDIA           = 28 | MAX_BIT
literal|"Reserved (29)"
block|,
comment|//  RESERVED                      = 29 | MAX_BIT
literal|"Reserved (30)"
block|,
comment|//  RESERVED                      = 30 | MAX_BIT
literal|"End of File"
block|,
comment|//  RETURN_END_OF_FILE            = 31 | MAX_BIT
literal|"Invalid Language"
block|,
comment|//  RETURN_INVALID_LANGUAGE       = 32 | MAX_BIT
literal|"Compromised Data"
comment|//  RETURN_COMPROMISED_DATA       = 33 | MAX_BIT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**   Internal function that places the character into the Buffer.    Internal function that places ASCII or Unicode character into the Buffer.    @param  Buffer      The buffer to place the Unicode or ASCII string.   @param  EndBuffer   The end of the input Buffer. No characters will be                       placed after that.    @param  Length      The count of character to be placed into Buffer.                       (Negative value indicates no buffer fill.)   @param  Character   The character to be placed into Buffer.   @param  Increment   The character increment in Buffer.    @return Buffer.  **/
end_comment

begin_function
name|CHAR8
modifier|*
name|BasePrintLibFillBuffer
parameter_list|(
name|OUT
name|CHAR8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|CHAR8
modifier|*
name|EndBuffer
parameter_list|,
name|IN
name|INTN
name|Length
parameter_list|,
name|IN
name|UINTN
name|Character
parameter_list|,
name|IN
name|INTN
name|Increment
parameter_list|)
block|{
name|INTN
name|Index
decl_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Length
operator|&&
name|Buffer
operator|<
name|EndBuffer
condition|;
name|Index
operator|++
control|)
block|{
operator|*
name|Buffer
operator|=
operator|(
name|CHAR8
operator|)
name|Character
expr_stmt|;
if|if
condition|(
name|Increment
operator|!=
literal|1
condition|)
block|{
operator|*
operator|(
name|Buffer
operator|+
literal|1
operator|)
operator|=
call|(
name|CHAR8
call|)
argument_list|(
name|Character
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|Buffer
operator|+=
name|Increment
expr_stmt|;
block|}
return|return
name|Buffer
return|;
block|}
end_function

begin_comment
comment|/**   Internal function that convert a number to a string in Buffer.    Print worker function that converts a decimal or hexadecimal number to an ASCII string in Buffer.    @param  Buffer    Location to place the ASCII string of Value.   @param  Value     The value to convert to a Decimal or Hexadecimal string in Buffer.   @param  Radix     Radix of the value    @return A pointer to the end of buffer filled with ASCII string.  **/
end_comment

begin_function
name|CHAR8
modifier|*
name|BasePrintLibValueToString
parameter_list|(
name|IN
name|OUT
name|CHAR8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|INT64
name|Value
parameter_list|,
name|IN
name|UINTN
name|Radix
parameter_list|)
block|{
name|UINT32
name|Remainder
decl_stmt|;
comment|//
comment|// Loop to convert one digit at a time in reverse order
comment|//
operator|*
name|Buffer
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|Value
operator|=
operator|(
name|INT64
operator|)
name|DivU64x32Remainder
argument_list|(
operator|(
name|UINT64
operator|)
name|Value
argument_list|,
operator|(
name|UINT32
operator|)
name|Radix
argument_list|,
operator|&
name|Remainder
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|++
name|Buffer
operator|)
operator|=
name|mHexStr
index|[
name|Remainder
index|]
expr_stmt|;
block|}
do|while
condition|(
name|Value
operator|!=
literal|0
condition|)
do|;
comment|//
comment|// Return pointer of the end of filled buffer.
comment|//
return|return
name|Buffer
return|;
block|}
end_function

begin_comment
comment|/**   Internal function that converts a decimal value to a Null-terminated string.      Converts the decimal number specified by Value to a Null-terminated     string specified by Buffer containing at most Width characters.   If Width is 0 then a width of  MAXIMUM_VALUE_CHARACTERS is assumed.   The total number of characters placed in Buffer is returned.   If the conversion contains more than Width characters, then only the first   Width characters are returned, and the total number of characters    required to perform the conversion is returned.   Additional conversion parameters are specified in Flags.     The Flags bit LEFT_JUSTIFY is always ignored.   All conversions are left justified in Buffer.   If Width is 0, PREFIX_ZERO is ignored in Flags.   If COMMA_TYPE is set in Flags, then PREFIX_ZERO is ignored in Flags, and commas   are inserted every 3rd digit starting from the right.   If Value is< 0, then the fist character in Buffer is a '-'.   If PREFIX_ZERO is set in Flags and PREFIX_ZERO is not being ignored,    then Buffer is padded with '0' characters so the combination of the optional '-'    sign character, '0' characters, digit characters for Value, and the Null-terminator   add up to Width characters.    If Buffer is NULL, then ASSERT().   If unsupported bits are set in Flags, then ASSERT().   If Width>= MAXIMUM_VALUE_CHARACTERS, then ASSERT()    @param  Buffer    The pointer to the output buffer for the produced Null-terminated                     string.   @param  Flags     The bitmask of flags that specify left justification, zero pad,                     and commas.   @param  Value     The 64-bit signed value to convert to a string.   @param  Width     The maximum number of characters to place in Buffer, not including                     the Null-terminator.   @param  Increment The character increment in Buffer.      @return Total number of characters required to perform the conversion.  **/
end_comment

begin_function
name|UINTN
name|BasePrintLibConvertValueToString
parameter_list|(
name|IN
name|OUT
name|CHAR8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|Flags
parameter_list|,
name|IN
name|INT64
name|Value
parameter_list|,
name|IN
name|UINTN
name|Width
parameter_list|,
name|IN
name|UINTN
name|Increment
parameter_list|)
block|{
name|CHAR8
modifier|*
name|OriginalBuffer
decl_stmt|;
name|CHAR8
modifier|*
name|EndBuffer
decl_stmt|;
name|CHAR8
name|ValueBuffer
index|[
name|MAXIMUM_VALUE_CHARACTERS
index|]
decl_stmt|;
name|CHAR8
modifier|*
name|ValueBufferPtr
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|Digits
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|UINTN
name|Radix
decl_stmt|;
comment|//
comment|// Make sure Buffer is not NULL and Width< MAXIMUM
comment|//
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Width
operator|<
name|MAXIMUM_VALUE_CHARACTERS
argument_list|)
expr_stmt|;
comment|//
comment|// Make sure Flags can only contain supported bits.
comment|//
name|ASSERT
argument_list|(
operator|(
name|Flags
operator|&
operator|~
operator|(
name|LEFT_JUSTIFY
operator||
name|COMMA_TYPE
operator||
name|PREFIX_ZERO
operator||
name|RADIX_HEX
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// If both COMMA_TYPE and RADIX_HEX are set, then ASSERT ()
comment|//
name|ASSERT
argument_list|(
operator|(
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|OriginalBuffer
operator|=
name|Buffer
expr_stmt|;
comment|//
comment|// Width is 0 or COMMA_TYPE is set, PREFIX_ZERO is ignored.
comment|//
if|if
condition|(
name|Width
operator|==
literal|0
operator|||
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Flags
operator|&=
operator|~
operator|(
operator|(
name|UINTN
operator|)
name|PREFIX_ZERO
operator|)
expr_stmt|;
block|}
comment|//
comment|// If Width is 0 then a width of  MAXIMUM_VALUE_CHARACTERS is assumed.
comment|//
if|if
condition|(
name|Width
operator|==
literal|0
condition|)
block|{
name|Width
operator|=
name|MAXIMUM_VALUE_CHARACTERS
operator|-
literal|1
expr_stmt|;
block|}
comment|//
comment|// Set the tag for the end of the input Buffer.
comment|//
name|EndBuffer
operator|=
name|Buffer
operator|+
name|Width
operator|*
name|Increment
expr_stmt|;
comment|//
comment|// Convert decimal negative
comment|//
if|if
condition|(
operator|(
name|Value
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Value
operator|=
operator|-
name|Value
expr_stmt|;
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
literal|'-'
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
name|Width
operator|--
expr_stmt|;
block|}
comment|//
comment|// Count the length of the value string.
comment|//
name|Radix
operator|=
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
condition|?
literal|10
else|:
literal|16
expr_stmt|;
name|ValueBufferPtr
operator|=
name|BasePrintLibValueToString
argument_list|(
name|ValueBuffer
argument_list|,
name|Value
argument_list|,
name|Radix
argument_list|)
expr_stmt|;
name|Count
operator|=
name|ValueBufferPtr
operator|-
name|ValueBuffer
expr_stmt|;
comment|//
comment|// Append Zero
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
name|PREFIX_ZERO
operator|)
operator|!=
literal|0
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
name|Width
operator|-
name|Count
argument_list|,
literal|'0'
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Print Comma type for every 3 characters
comment|//
name|Digits
operator|=
name|Count
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|Digits
operator|!=
literal|0
condition|)
block|{
name|Digits
operator|=
literal|3
operator|-
name|Digits
expr_stmt|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Count
condition|;
name|Index
operator|++
control|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
operator|*
name|ValueBufferPtr
operator|--
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Digits
operator|++
expr_stmt|;
if|if
condition|(
name|Digits
operator|==
literal|3
condition|)
block|{
name|Digits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Index
operator|+
literal|1
operator|)
operator|<
name|Count
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
literal|','
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Print Null-terminator
comment|//
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
operator|+
name|Increment
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Buffer
operator|-
name|OriginalBuffer
operator|)
operator|/
name|Increment
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Internal function that converts a decimal value to a Null-terminated string.    Converts the decimal number specified by Value to a Null-terminated string   specified by Buffer containing at most Width characters. If Width is 0 then a   width of MAXIMUM_VALUE_CHARACTERS is assumed. If the conversion contains more   than Width characters, then only the first Width characters are placed in   Buffer. Additional conversion parameters are specified in Flags.   The Flags bit LEFT_JUSTIFY is always ignored.   All conversions are left justified in Buffer.   If Width is 0, PREFIX_ZERO is ignored in Flags.   If COMMA_TYPE is set in Flags, then PREFIX_ZERO is ignored in Flags, and   commas are inserted every 3rd digit starting from the right.   If Value is< 0, then the fist character in Buffer is a '-'.   If PREFIX_ZERO is set in Flags and PREFIX_ZERO is not being ignored,   then Buffer is padded with '0' characters so the combination of the optional   '-' sign character, '0' characters, digit characters for Value, and the   Null-terminator add up to Width characters.    If an error would be returned, the function will ASSERT().    @param  Buffer      The pointer to the output buffer for the produced                       Null-terminated string.   @param  BufferSize  The size of Buffer in bytes, including the                       Null-terminator.   @param  Flags       The bitmask of flags that specify left justification,                       zero pad, and commas.   @param  Value       The 64-bit signed value to convert to a string.   @param  Width       The maximum number of characters to place in Buffer,                       not including the Null-terminator.   @param  Increment   The character increment in Buffer.    @retval RETURN_SUCCESS           The decimal value is converted.   @retval RETURN_BUFFER_TOO_SMALL  If BufferSize cannot hold the converted                                    value.   @retval RETURN_INVALID_PARAMETER If Buffer is NULL.                                    If Increment is 1 and                                    PcdMaximumAsciiStringLength is not zero,                                    BufferSize is greater than                                    PcdMaximumAsciiStringLength.                                    If Increment is not 1 and                                    PcdMaximumUnicodeStringLength is not zero,                                    BufferSize is greater than                                    (PcdMaximumUnicodeStringLength *                                    sizeof (CHAR16) + 1).                                    If unsupported bits are set in Flags.                                    If both COMMA_TYPE and RADIX_HEX are set in                                    Flags.                                    If Width>= MAXIMUM_VALUE_CHARACTERS.  **/
end_comment

begin_function
name|RETURN_STATUS
name|BasePrintLibConvertValueToStringS
parameter_list|(
name|IN
name|OUT
name|CHAR8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|BufferSize
parameter_list|,
name|IN
name|UINTN
name|Flags
parameter_list|,
name|IN
name|INT64
name|Value
parameter_list|,
name|IN
name|UINTN
name|Width
parameter_list|,
name|IN
name|UINTN
name|Increment
parameter_list|)
block|{
name|CHAR8
modifier|*
name|EndBuffer
decl_stmt|;
name|CHAR8
name|ValueBuffer
index|[
name|MAXIMUM_VALUE_CHARACTERS
index|]
decl_stmt|;
name|CHAR8
modifier|*
name|ValueBufferPtr
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|Digits
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|UINTN
name|Radix
decl_stmt|;
comment|//
comment|// 1. Buffer shall not be a null pointer.
comment|//
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Buffer
operator|!=
name|NULL
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 2. BufferSize shall not be greater than (RSIZE_MAX * sizeof (CHAR16)) for
comment|//    Unicode output string or shall not be greater than ASCII_RSIZE_MAX for
comment|//    Ascii output string.
comment|//
if|if
condition|(
name|Increment
operator|==
literal|1
condition|)
block|{
comment|//
comment|// Ascii output string
comment|//
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|BufferSize
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// Unicode output string
comment|//
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|BufferSize
operator|<=
name|RSIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
operator|+
literal|1
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// 3. Flags shall be set properly.
comment|//
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
operator|(
name|Flags
operator|&
operator|~
operator|(
name|LEFT_JUSTIFY
operator||
name|COMMA_TYPE
operator||
name|PREFIX_ZERO
operator||
name|RADIX_HEX
operator|)
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
operator|(
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// 4. Width shall be smaller than MAXIMUM_VALUE_CHARACTERS.
comment|//
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Width
operator|<
name|MAXIMUM_VALUE_CHARACTERS
operator|)
argument_list|,
name|RETURN_INVALID_PARAMETER
argument_list|)
expr_stmt|;
comment|//
comment|// Width is 0 or COMMA_TYPE is set, PREFIX_ZERO is ignored.
comment|//
if|if
condition|(
name|Width
operator|==
literal|0
operator|||
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Flags
operator|&=
operator|~
operator|(
operator|(
name|UINTN
operator|)
name|PREFIX_ZERO
operator|)
expr_stmt|;
block|}
comment|//
comment|// If Width is 0 then a width of MAXIMUM_VALUE_CHARACTERS is assumed.
comment|//
if|if
condition|(
name|Width
operator|==
literal|0
condition|)
block|{
name|Width
operator|=
name|MAXIMUM_VALUE_CHARACTERS
operator|-
literal|1
expr_stmt|;
block|}
comment|//
comment|// Count the characters of the output string.
comment|//
name|Count
operator|=
literal|0
expr_stmt|;
name|Radix
operator|=
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
condition|?
literal|10
else|:
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|PREFIX_ZERO
operator|)
operator|!=
literal|0
condition|)
block|{
name|Count
operator|=
name|Width
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|Value
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Count
operator|++
expr_stmt|;
comment|// minus sign
name|ValueBufferPtr
operator|=
name|BasePrintLibValueToString
argument_list|(
name|ValueBuffer
argument_list|,
operator|-
name|Value
argument_list|,
name|Radix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ValueBufferPtr
operator|=
name|BasePrintLibValueToString
argument_list|(
name|ValueBuffer
argument_list|,
name|Value
argument_list|,
name|Radix
argument_list|)
expr_stmt|;
block|}
name|Digits
operator|=
name|ValueBufferPtr
operator|-
name|ValueBuffer
expr_stmt|;
name|Count
operator|+=
name|Digits
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Count
operator|+=
operator|(
name|Digits
operator|-
literal|1
operator|)
operator|/
literal|3
expr_stmt|;
comment|// commas
block|}
block|}
name|Width
operator|=
name|MIN
argument_list|(
name|Count
argument_list|,
name|Width
argument_list|)
expr_stmt|;
comment|//
comment|// 5. BufferSize shall be large enough to hold the converted string.
comment|//
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|BufferSize
operator|>=
operator|(
name|Width
operator|+
literal|1
operator|)
operator|*
name|Increment
operator|)
argument_list|,
name|RETURN_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
comment|//
comment|// Set the tag for the end of the input Buffer.
comment|//
name|EndBuffer
operator|=
name|Buffer
operator|+
name|Width
operator|*
name|Increment
expr_stmt|;
comment|//
comment|// Convert decimal negative
comment|//
if|if
condition|(
operator|(
name|Value
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Value
operator|=
operator|-
name|Value
expr_stmt|;
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
literal|'-'
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
name|Width
operator|--
expr_stmt|;
block|}
comment|//
comment|// Count the length of the value string.
comment|//
name|ValueBufferPtr
operator|=
name|BasePrintLibValueToString
argument_list|(
name|ValueBuffer
argument_list|,
name|Value
argument_list|,
name|Radix
argument_list|)
expr_stmt|;
name|Count
operator|=
name|ValueBufferPtr
operator|-
name|ValueBuffer
expr_stmt|;
comment|//
comment|// Append Zero
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
name|PREFIX_ZERO
operator|)
operator|!=
literal|0
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
name|Width
operator|-
name|Count
argument_list|,
literal|'0'
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Print Comma type for every 3 characters
comment|//
name|Digits
operator|=
name|Count
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|Digits
operator|!=
literal|0
condition|)
block|{
name|Digits
operator|=
literal|3
operator|-
name|Digits
expr_stmt|;
block|}
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Count
condition|;
name|Index
operator|++
control|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
operator|*
name|ValueBufferPtr
operator|--
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Digits
operator|++
expr_stmt|;
if|if
condition|(
name|Digits
operator|==
literal|3
condition|)
block|{
name|Digits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Index
operator|+
literal|1
operator|)
operator|<
name|Count
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
literal|','
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Print Null-terminator
comment|//
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
operator|+
name|Increment
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Increment
argument_list|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Worker function that produces a Null-terminated string in an output buffer    based on a Null-terminated format string and a VA_LIST argument list.    VSPrint function to process format and place the results in Buffer. Since a    VA_LIST is used this routine allows the nesting of Vararg routines. Thus    this is the main print working routine.    If COUNT_ONLY_NO_PRINT is set in Flags, Buffer will not be modified at all.    @param[out] Buffer          The character buffer to print the results of the                                parsing of Format into.   @param[in]  BufferSize      The maximum number of characters to put into                                buffer.   @param[in]  Flags           Initial flags value.                               Can only have FORMAT_UNICODE, OUTPUT_UNICODE,                                and COUNT_ONLY_NO_PRINT set.   @param[in]  Format          A Null-terminated format string.   @param[in]  VaListMarker    VA_LIST style variable argument list consumed by                               processing Format.   @param[in]  BaseListMarker  BASE_LIST style variable argument list consumed                               by processing Format.    @return The number of characters printed not including the Null-terminator.           If COUNT_ONLY_NO_PRINT was set returns the same, but without any           modification to Buffer.  **/
end_comment

begin_function
name|UINTN
name|BasePrintLibSPrintMarker
parameter_list|(
name|OUT
name|CHAR8
modifier|*
name|Buffer
parameter_list|,
name|IN
name|UINTN
name|BufferSize
parameter_list|,
name|IN
name|UINTN
name|Flags
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|Format
parameter_list|,
name|IN
name|VA_LIST
name|VaListMarker
parameter_list|,
name|OPTIONAL
name|IN
name|BASE_LIST
name|BaseListMarker
name|OPTIONAL
parameter_list|)
block|{
name|CHAR8
modifier|*
name|OriginalBuffer
decl_stmt|;
name|CHAR8
modifier|*
name|EndBuffer
decl_stmt|;
name|CHAR8
name|ValueBuffer
index|[
name|MAXIMUM_VALUE_CHARACTERS
index|]
decl_stmt|;
name|UINT32
name|BytesPerOutputCharacter
decl_stmt|;
name|UINTN
name|BytesPerFormatCharacter
decl_stmt|;
name|UINTN
name|FormatMask
decl_stmt|;
name|UINTN
name|FormatCharacter
decl_stmt|;
name|UINTN
name|Width
decl_stmt|;
name|UINTN
name|Precision
decl_stmt|;
name|INT64
name|Value
decl_stmt|;
name|CONST
name|CHAR8
modifier|*
name|ArgumentString
decl_stmt|;
name|UINTN
name|Character
decl_stmt|;
name|GUID
modifier|*
name|TmpGuid
decl_stmt|;
name|TIME
modifier|*
name|TmpTime
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|ArgumentMask
decl_stmt|;
name|INTN
name|BytesPerArgumentCharacter
decl_stmt|;
name|UINTN
name|ArgumentCharacter
decl_stmt|;
name|BOOLEAN
name|Done
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|CHAR8
name|Prefix
decl_stmt|;
name|BOOLEAN
name|ZeroPad
decl_stmt|;
name|BOOLEAN
name|Comma
decl_stmt|;
name|UINTN
name|Digits
decl_stmt|;
name|UINTN
name|Radix
decl_stmt|;
name|RETURN_STATUS
name|Status
decl_stmt|;
name|UINT32
name|GuidData1
decl_stmt|;
name|UINT16
name|GuidData2
decl_stmt|;
name|UINT16
name|GuidData3
decl_stmt|;
name|UINTN
name|LengthToReturn
decl_stmt|;
comment|//
comment|// If you change this code be sure to match the 2 versions of this function.
comment|// Nearly identical logic is found in the BasePrintLib and
comment|// DxePrintLibPrint2Protocol (both PrintLib instances).
comment|//
comment|//
comment|// 1. Buffer shall not be a null pointer when both BufferSize> 0 and
comment|//    COUNT_ONLY_NO_PRINT is not set in Flags.
comment|//
if|if
condition|(
operator|(
name|BufferSize
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Buffer
operator|!=
name|NULL
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 2. Format shall not be a null pointer when BufferSize> 0 or when
comment|//    COUNT_ONLY_NO_PRINT is set in Flags.
comment|//
if|if
condition|(
operator|(
name|BufferSize
operator|>
literal|0
operator|)
operator|||
operator|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|Format
operator|!=
name|NULL
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// 3. BufferSize shall not be greater than RSIZE_MAX for Unicode output or
comment|//    ASCII_RSIZE_MAX for Ascii output.
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
name|OUTPUT_UNICODE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|BufferSize
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|BytesPerOutputCharacter
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|BufferSize
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|BytesPerOutputCharacter
operator|=
literal|1
expr_stmt|;
block|}
comment|//
comment|// 4. Format shall not contain more than RSIZE_MAX Unicode characters or
comment|//    ASCII_RSIZE_MAX Ascii characters.
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
name|FORMAT_UNICODE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|StrnLenS
argument_list|(
operator|(
name|CHAR16
operator|*
operator|)
name|Format
argument_list|,
name|RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|RSIZE_MAX
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|BytesPerFormatCharacter
operator|=
literal|2
expr_stmt|;
name|FormatMask
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ASCII_RSIZE_MAX
operator|!=
literal|0
condition|)
block|{
name|SAFE_PRINT_CONSTRAINT_CHECK
argument_list|(
operator|(
name|AsciiStrnLenS
argument_list|(
name|Format
argument_list|,
name|ASCII_RSIZE_MAX
operator|+
literal|1
argument_list|)
operator|<=
name|ASCII_RSIZE_MAX
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|BytesPerFormatCharacter
operator|=
literal|1
expr_stmt|;
name|FormatMask
operator|=
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|BufferSize
operator|==
literal|0
condition|)
block|{
name|Buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// We can run without a Buffer for counting only.
comment|//
if|if
condition|(
name|BufferSize
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
name|LengthToReturn
operator|=
literal|0
expr_stmt|;
name|EndBuffer
operator|=
name|NULL
expr_stmt|;
name|OriginalBuffer
operator|=
name|NULL
expr_stmt|;
comment|//
comment|// Reserve space for the Null terminator.
comment|//
if|if
condition|(
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|BufferSize
operator|--
expr_stmt|;
name|OriginalBuffer
operator|=
name|Buffer
expr_stmt|;
comment|//
comment|// Set the tag for the end of the input Buffer.
comment|//
name|EndBuffer
operator|=
name|Buffer
operator|+
name|BufferSize
operator|*
name|BytesPerOutputCharacter
expr_stmt|;
block|}
comment|//
comment|// Get the first character from the format string
comment|//
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
comment|//
comment|// Loop until the end of the format string is reached or the output buffer is full
comment|//
while|while
condition|(
name|FormatCharacter
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|Buffer
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|Buffer
operator|>=
name|EndBuffer
operator|)
condition|)
block|{
break|break;
block|}
comment|//
comment|// Clear all the flag bits except those that may have been passed in
comment|//
name|Flags
operator|&=
call|(
name|UINTN
call|)
argument_list|(
name|OUTPUT_UNICODE
operator||
name|FORMAT_UNICODE
operator||
name|COUNT_ONLY_NO_PRINT
argument_list|)
expr_stmt|;
comment|//
comment|// Set the default width to zero, and the default precision to 1
comment|//
name|Width
operator|=
literal|0
expr_stmt|;
name|Precision
operator|=
literal|1
expr_stmt|;
name|Prefix
operator|=
literal|0
expr_stmt|;
name|Comma
operator|=
name|FALSE
expr_stmt|;
name|ZeroPad
operator|=
name|FALSE
expr_stmt|;
name|Count
operator|=
literal|0
expr_stmt|;
name|Digits
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|FormatCharacter
condition|)
block|{
case|case
literal|'%'
case|:
comment|//
comment|// Parse Flags and Width
comment|//
for|for
control|(
name|Done
operator|=
name|FALSE
init|;
operator|!
name|Done
condition|;
control|)
block|{
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
switch|switch
condition|(
name|FormatCharacter
condition|)
block|{
case|case
literal|'.'
case|:
name|Flags
operator||=
name|PRECISION
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|Flags
operator||=
name|LEFT_JUSTIFY
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|Flags
operator||=
name|PREFIX_SIGN
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|Flags
operator||=
name|PREFIX_BLANK
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|Flags
operator||=
name|COMMA_TYPE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|Flags
operator||=
name|LONG_TYPE
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|(
name|Flags
operator|&
name|PRECISION
operator|)
operator|==
literal|0
condition|)
block|{
name|Flags
operator||=
name|PAD_TO_WIDTH
expr_stmt|;
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|Width
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|UINTN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Width
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|UINTN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|Precision
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|UINTN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Precision
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|UINTN
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
operator|(
name|Flags
operator|&
name|PRECISION
operator|)
operator|==
literal|0
condition|)
block|{
name|Flags
operator||=
name|PREFIX_ZERO
expr_stmt|;
block|}
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
for|for
control|(
name|Count
operator|=
literal|0
init|;
operator|(
operator|(
name|FormatCharacter
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|FormatCharacter
operator|<=
literal|'9'
operator|)
operator|)
condition|;
control|)
block|{
name|Count
operator|=
operator|(
name|Count
operator|*
literal|10
operator|)
operator|+
name|FormatCharacter
operator|-
literal|'0'
expr_stmt|;
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
block|}
name|Format
operator|-=
name|BytesPerFormatCharacter
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|PRECISION
operator|)
operator|==
literal|0
condition|)
block|{
name|Flags
operator||=
name|PAD_TO_WIDTH
expr_stmt|;
name|Width
operator|=
name|Count
expr_stmt|;
block|}
else|else
block|{
name|Precision
operator|=
name|Count
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
comment|//
comment|// Make no output if Format string terminates unexpectedly when
comment|// looking up for flag, width, precision and type.
comment|//
name|Format
operator|-=
name|BytesPerFormatCharacter
expr_stmt|;
name|Precision
operator|=
literal|0
expr_stmt|;
comment|//
comment|// break skipped on purpose.
comment|//
default|default:
name|Done
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|//
comment|// Handle each argument type
comment|//
switch|switch
condition|(
name|FormatCharacter
condition|)
block|{
case|case
literal|'p'
case|:
comment|//
comment|// Flag space, +, 0, L& l are invalid for type p.
comment|//
name|Flags
operator|&=
operator|~
operator|(
call|(
name|UINTN
call|)
argument_list|(
name|PREFIX_BLANK
operator||
name|PREFIX_SIGN
operator||
name|PREFIX_ZERO
operator||
name|LONG_TYPE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|VOID
operator|*
argument_list|)
operator|>
literal|4
condition|)
block|{
name|Flags
operator||=
name|LONG_TYPE
expr_stmt|;
block|}
comment|//
comment|// break skipped on purpose
comment|//
case|case
literal|'X'
case|:
name|Flags
operator||=
name|PREFIX_ZERO
expr_stmt|;
comment|//
comment|// break skipped on purpose
comment|//
case|case
literal|'x'
case|:
name|Flags
operator||=
name|RADIX_HEX
expr_stmt|;
comment|//
comment|// break skipped on purpose
comment|//
case|case
literal|'u'
case|:
if|if
condition|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
condition|)
block|{
name|Flags
operator|&=
operator|~
operator|(
call|(
name|UINTN
call|)
argument_list|(
name|PREFIX_SIGN
argument_list|)
operator|)
expr_stmt|;
name|Flags
operator||=
name|UNSIGNED_TYPE
expr_stmt|;
block|}
comment|//
comment|// break skipped on purpose
comment|//
case|case
literal|'d'
case|:
if|if
condition|(
operator|(
name|Flags
operator|&
name|LONG_TYPE
operator|)
operator|==
literal|0
condition|)
block|{
comment|//
comment|// 'd', 'u', 'x', and 'X' that are not preceded by 'l' or 'L' are assumed to be type "int".
comment|// This assumption is made so the format string definition is compatible with the ANSI C
comment|// Specification for formatted strings.  It is recommended that the Base Types be used
comment|// everywhere, but in this one case, compliance with ANSI C is more important, and
comment|// provides an implementation that is compatible with that largest possible set of CPU
comment|// architectures.  This is why the type "int" is used in this one case.
comment|//
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|Value
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Value
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|Value
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|INT64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Value
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|INT64
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|PREFIX_BLANK
operator|)
operator|!=
literal|0
condition|)
block|{
name|Prefix
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|PREFIX_SIGN
operator|)
operator|!=
literal|0
condition|)
block|{
name|Prefix
operator|=
literal|'+'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|COMMA_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Comma
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|RADIX_HEX
operator|)
operator|==
literal|0
condition|)
block|{
name|Radix
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|Comma
condition|)
block|{
name|Flags
operator|&=
operator|~
operator|(
operator|(
name|UINTN
operator|)
name|PREFIX_ZERO
operator|)
expr_stmt|;
name|Precision
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Value
operator|<
literal|0
operator|&&
operator|(
name|Flags
operator|&
name|UNSIGNED_TYPE
operator|)
operator|==
literal|0
condition|)
block|{
name|Flags
operator||=
name|PREFIX_SIGN
expr_stmt|;
name|Prefix
operator|=
literal|'-'
expr_stmt|;
name|Value
operator|=
operator|-
name|Value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Flags
operator|&
name|UNSIGNED_TYPE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|Flags
operator|&
name|LONG_TYPE
operator|)
operator|==
literal|0
condition|)
block|{
comment|//
comment|// 'd', 'u', 'x', and 'X' that are not preceded by 'l' or 'L' are assumed to be type "int".
comment|// This assumption is made so the format string definition is compatible with the ANSI C
comment|// Specification for formatted strings.  It is recommended that the Base Types be used
comment|// everywhere, but in this one case, compliance with ANSI C is more important, and
comment|// provides an implementation that is compatible with that largest possible set of CPU
comment|// architectures.  This is why the type "unsigned int" is used in this one case.
comment|//
name|Value
operator|=
operator|(
name|unsigned
name|int
operator|)
name|Value
expr_stmt|;
block|}
block|}
else|else
block|{
name|Radix
operator|=
literal|16
expr_stmt|;
name|Comma
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|LONG_TYPE
operator|)
operator|==
literal|0
operator|&&
name|Value
operator|<
literal|0
condition|)
block|{
comment|//
comment|// 'd', 'u', 'x', and 'X' that are not preceded by 'l' or 'L' are assumed to be type "int".
comment|// This assumption is made so the format string definition is compatible with the ANSI C
comment|// Specification for formatted strings.  It is recommended that the Base Types be used
comment|// everywhere, but in this one case, compliance with ANSI C is more important, and
comment|// provides an implementation that is compatible with that largest possible set of CPU
comment|// architectures.  This is why the type "unsigned int" is used in this one case.
comment|//
name|Value
operator|=
operator|(
name|unsigned
name|int
operator|)
name|Value
expr_stmt|;
block|}
block|}
comment|//
comment|// Convert Value to a reversed string
comment|//
name|Count
operator|=
name|BasePrintLibValueToString
argument_list|(
name|ValueBuffer
argument_list|,
name|Value
argument_list|,
name|Radix
argument_list|)
operator|-
name|ValueBuffer
expr_stmt|;
if|if
condition|(
name|Value
operator|==
literal|0
operator|&&
name|Precision
operator|==
literal|0
condition|)
block|{
name|Count
operator|=
literal|0
expr_stmt|;
block|}
name|ArgumentString
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|ValueBuffer
operator|+
name|Count
expr_stmt|;
name|Digits
operator|=
name|Count
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|Digits
operator|!=
literal|0
condition|)
block|{
name|Digits
operator|=
literal|3
operator|-
name|Digits
expr_stmt|;
block|}
if|if
condition|(
name|Comma
operator|&&
name|Count
operator|!=
literal|0
condition|)
block|{
name|Count
operator|+=
operator|(
operator|(
name|Count
operator|-
literal|1
operator|)
operator|/
literal|3
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|Prefix
operator|!=
literal|0
condition|)
block|{
name|Count
operator|++
expr_stmt|;
name|Precision
operator|++
expr_stmt|;
block|}
name|Flags
operator||=
name|ARGUMENT_REVERSED
expr_stmt|;
name|ZeroPad
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|PREFIX_ZERO
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|Flags
operator|&
name|LEFT_JUSTIFY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|Flags
operator|&
name|PAD_TO_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|Flags
operator|&
name|PRECISION
operator|)
operator|==
literal|0
condition|)
block|{
name|Precision
operator|=
name|Width
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|Flags
operator||=
name|ARGUMENT_UNICODE
expr_stmt|;
comment|//
comment|// break skipped on purpose
comment|//
case|case
literal|'a'
case|:
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|ArgumentString
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|CHAR8
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArgumentString
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|CHAR8
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ArgumentString
operator|==
name|NULL
condition|)
block|{
name|Flags
operator|&=
operator|~
operator|(
operator|(
name|UINTN
operator|)
name|ARGUMENT_UNICODE
operator|)
expr_stmt|;
name|ArgumentString
operator|=
literal|"<null string>"
expr_stmt|;
block|}
comment|//
comment|// Set the default precision for string to be zero if not specified.
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
name|PRECISION
operator|)
operator|==
literal|0
condition|)
block|{
name|Precision
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|Character
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|UINTN
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|Character
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|UINTN
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
block|}
name|ArgumentString
operator|=
operator|(
name|CHAR8
operator|*
operator|)
operator|&
name|Character
expr_stmt|;
name|Flags
operator||=
name|ARGUMENT_UNICODE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|TmpGuid
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|GUID
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TmpGuid
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|GUID
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TmpGuid
operator|==
name|NULL
condition|)
block|{
name|ArgumentString
operator|=
literal|"<null guid>"
expr_stmt|;
block|}
else|else
block|{
name|GuidData1
operator|=
name|ReadUnaligned32
argument_list|(
operator|&
operator|(
name|TmpGuid
operator|->
name|Data1
operator|)
argument_list|)
expr_stmt|;
name|GuidData2
operator|=
name|ReadUnaligned16
argument_list|(
operator|&
operator|(
name|TmpGuid
operator|->
name|Data2
operator|)
argument_list|)
expr_stmt|;
name|GuidData3
operator|=
name|ReadUnaligned16
argument_list|(
operator|&
operator|(
name|TmpGuid
operator|->
name|Data3
operator|)
argument_list|)
expr_stmt|;
name|BasePrintLibSPrint
argument_list|(
name|ValueBuffer
argument_list|,
name|MAXIMUM_VALUE_CHARACTERS
argument_list|,
literal|0
argument_list|,
literal|"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
argument_list|,
name|GuidData1
argument_list|,
name|GuidData2
argument_list|,
name|GuidData3
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|0
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|1
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|2
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|3
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|4
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|5
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|6
index|]
argument_list|,
name|TmpGuid
operator|->
name|Data4
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|ArgumentString
operator|=
name|ValueBuffer
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|TmpTime
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|TIME
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TmpTime
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|TIME
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TmpTime
operator|==
name|NULL
condition|)
block|{
name|ArgumentString
operator|=
literal|"<null time>"
expr_stmt|;
block|}
else|else
block|{
name|BasePrintLibSPrint
argument_list|(
name|ValueBuffer
argument_list|,
name|MAXIMUM_VALUE_CHARACTERS
argument_list|,
literal|0
argument_list|,
literal|"%02d/%02d/%04d  %02d:%02d"
argument_list|,
name|TmpTime
operator|->
name|Month
argument_list|,
name|TmpTime
operator|->
name|Day
argument_list|,
name|TmpTime
operator|->
name|Year
argument_list|,
name|TmpTime
operator|->
name|Hour
argument_list|,
name|TmpTime
operator|->
name|Minute
argument_list|)
expr_stmt|;
name|ArgumentString
operator|=
name|ValueBuffer
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|BaseListMarker
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|VA_ARG
argument_list|(
name|VaListMarker
argument_list|,
name|RETURN_STATUS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Status
operator|=
name|BASE_ARG
argument_list|(
name|BaseListMarker
argument_list|,
name|RETURN_STATUS
argument_list|)
expr_stmt|;
block|}
name|ArgumentString
operator|=
name|ValueBuffer
expr_stmt|;
if|if
condition|(
name|RETURN_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Clear error bit
comment|//
name|Index
operator|=
name|Status
operator|&
operator|~
name|MAX_BIT
expr_stmt|;
if|if
condition|(
name|Index
operator|>
literal|0
operator|&&
name|Index
operator|<=
name|ERROR_STATUS_NUMBER
condition|)
block|{
name|ArgumentString
operator|=
name|mStatusString
index|[
name|Index
operator|+
name|WARNING_STATUS_NUMBER
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|Index
operator|=
name|Status
expr_stmt|;
if|if
condition|(
name|Index
operator|<=
name|WARNING_STATUS_NUMBER
condition|)
block|{
name|ArgumentString
operator|=
name|mStatusString
index|[
name|Index
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ArgumentString
operator|==
name|ValueBuffer
condition|)
block|{
name|BasePrintLibSPrint
argument_list|(
operator|(
name|CHAR8
operator|*
operator|)
name|ValueBuffer
argument_list|,
name|MAXIMUM_VALUE_CHARACTERS
argument_list|,
literal|0
argument_list|,
literal|"%08X"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\r'
case|:
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
if|if
condition|(
name|FormatCharacter
operator|==
literal|'\n'
condition|)
block|{
comment|//
comment|// Translate '\r\n' to '\r\n'
comment|//
name|ArgumentString
operator|=
literal|"\r\n"
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Translate '\r' to '\r'
comment|//
name|ArgumentString
operator|=
literal|"\r"
expr_stmt|;
name|Format
operator|-=
name|BytesPerFormatCharacter
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
comment|//
comment|// Translate '\n' to '\r\n' and '\n\r' to '\r\n'
comment|//
name|ArgumentString
operator|=
literal|"\r\n"
expr_stmt|;
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
if|if
condition|(
name|FormatCharacter
operator|!=
literal|'\r'
condition|)
block|{
name|Format
operator|-=
name|BytesPerFormatCharacter
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
default|default:
comment|//
comment|// if the type is '%' or unknown, then print it to the screen
comment|//
name|ArgumentString
operator|=
operator|(
name|CHAR8
operator|*
operator|)
operator|&
name|FormatCharacter
expr_stmt|;
name|Flags
operator||=
name|ARGUMENT_UNICODE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\r'
case|:
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
if|if
condition|(
name|FormatCharacter
operator|==
literal|'\n'
condition|)
block|{
comment|//
comment|// Translate '\r\n' to '\r\n'
comment|//
name|ArgumentString
operator|=
literal|"\r\n"
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Translate '\r' to '\r'
comment|//
name|ArgumentString
operator|=
literal|"\r"
expr_stmt|;
name|Format
operator|-=
name|BytesPerFormatCharacter
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
comment|//
comment|// Translate '\n' to '\r\n' and '\n\r' to '\r\n'
comment|//
name|ArgumentString
operator|=
literal|"\r\n"
expr_stmt|;
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
if|if
condition|(
name|FormatCharacter
operator|!=
literal|'\r'
condition|)
block|{
name|Format
operator|-=
name|BytesPerFormatCharacter
expr_stmt|;
block|}
break|break;
default|default:
name|ArgumentString
operator|=
operator|(
name|CHAR8
operator|*
operator|)
operator|&
name|FormatCharacter
expr_stmt|;
name|Flags
operator||=
name|ARGUMENT_UNICODE
expr_stmt|;
break|break;
block|}
comment|//
comment|// Retrieve the ArgumentString attriubutes
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
name|ARGUMENT_UNICODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ArgumentMask
operator|=
literal|0xffff
expr_stmt|;
name|BytesPerArgumentCharacter
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ArgumentMask
operator|=
literal|0xff
expr_stmt|;
name|BytesPerArgumentCharacter
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|ARGUMENT_REVERSED
operator|)
operator|!=
literal|0
condition|)
block|{
name|BytesPerArgumentCharacter
operator|=
operator|-
name|BytesPerArgumentCharacter
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Compute the number of characters in ArgumentString and store it in Count
comment|// ArgumentString is either null-terminated, or it contains Precision characters
comment|//
for|for
control|(
name|Count
operator|=
literal|0
init|;
name|Count
operator|<
name|Precision
operator|||
operator|(
operator|(
name|Flags
operator|&
name|PRECISION
operator|)
operator|==
literal|0
operator|)
condition|;
name|Count
operator|++
control|)
block|{
name|ArgumentCharacter
operator|=
operator|(
operator|(
name|ArgumentString
index|[
name|Count
operator|*
name|BytesPerArgumentCharacter
index|]
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|ArgumentString
index|[
name|Count
operator|*
name|BytesPerArgumentCharacter
operator|+
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|ArgumentMask
expr_stmt|;
if|if
condition|(
name|ArgumentCharacter
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|Precision
operator|<
name|Count
condition|)
block|{
name|Precision
operator|=
name|Count
expr_stmt|;
block|}
comment|//
comment|// Pad before the string
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
operator|(
name|PAD_TO_WIDTH
operator||
name|LEFT_JUSTIFY
operator|)
operator|)
operator|==
operator|(
name|PAD_TO_WIDTH
operator|)
condition|)
block|{
name|LengthToReturn
operator|+=
operator|(
operator|(
name|Width
operator|-
name|Precision
operator|)
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
name|Width
operator|-
name|Precision
argument_list|,
literal|' '
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ZeroPad
condition|)
block|{
if|if
condition|(
name|Prefix
operator|!=
literal|0
condition|)
block|{
name|LengthToReturn
operator|+=
operator|(
literal|1
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
name|Prefix
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
block|}
name|LengthToReturn
operator|+=
operator|(
operator|(
name|Precision
operator|-
name|Count
operator|)
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
name|Precision
operator|-
name|Count
argument_list|,
literal|'0'
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LengthToReturn
operator|+=
operator|(
operator|(
name|Precision
operator|-
name|Count
operator|)
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
name|Precision
operator|-
name|Count
argument_list|,
literal|' '
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Prefix
operator|!=
literal|0
condition|)
block|{
name|LengthToReturn
operator|+=
operator|(
literal|1
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
name|Prefix
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// Output the Prefix character if it is present
comment|//
name|Index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Prefix
operator|!=
literal|0
condition|)
block|{
name|Index
operator|++
expr_stmt|;
block|}
comment|//
comment|// Copy the string into the output buffer performing the required type conversions
comment|//
while|while
condition|(
name|Index
operator|<
name|Count
condition|)
block|{
name|ArgumentCharacter
operator|=
operator|(
operator|(
operator|*
name|ArgumentString
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|ArgumentString
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|ArgumentMask
expr_stmt|;
name|LengthToReturn
operator|+=
operator|(
literal|1
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
name|ArgumentCharacter
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
name|ArgumentString
operator|+=
name|BytesPerArgumentCharacter
expr_stmt|;
name|Index
operator|++
expr_stmt|;
if|if
condition|(
name|Comma
condition|)
block|{
name|Digits
operator|++
expr_stmt|;
if|if
condition|(
name|Digits
operator|==
literal|3
condition|)
block|{
name|Digits
operator|=
literal|0
expr_stmt|;
name|Index
operator|++
expr_stmt|;
if|if
condition|(
name|Index
operator|<
name|Count
condition|)
block|{
name|LengthToReturn
operator|+=
operator|(
literal|1
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
literal|1
argument_list|,
literal|','
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|//
comment|// Pad after the string
comment|//
if|if
condition|(
operator|(
name|Flags
operator|&
operator|(
name|PAD_TO_WIDTH
operator||
name|LEFT_JUSTIFY
operator|)
operator|)
operator|==
operator|(
name|PAD_TO_WIDTH
operator||
name|LEFT_JUSTIFY
operator|)
condition|)
block|{
name|LengthToReturn
operator|+=
operator|(
operator|(
name|Width
operator|-
name|Precision
operator|)
operator|*
name|BytesPerOutputCharacter
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|==
literal|0
operator|&&
name|Buffer
operator|!=
name|NULL
condition|)
block|{
name|Buffer
operator|=
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
argument_list|,
name|Width
operator|-
name|Precision
argument_list|,
literal|' '
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Get the next character from the format string
comment|//
name|Format
operator|+=
name|BytesPerFormatCharacter
expr_stmt|;
comment|//
comment|// Get the next character from the format string
comment|//
name|FormatCharacter
operator|=
operator|(
operator|(
operator|*
name|Format
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
operator|(
name|Format
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|&
name|FormatMask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Flags
operator|&
name|COUNT_ONLY_NO_PRINT
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|LengthToReturn
operator|/
name|BytesPerOutputCharacter
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Null terminate the Unicode or ASCII string
comment|//
name|BasePrintLibFillBuffer
argument_list|(
name|Buffer
argument_list|,
name|EndBuffer
operator|+
name|BytesPerOutputCharacter
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BytesPerOutputCharacter
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Buffer
operator|-
name|OriginalBuffer
operator|)
operator|/
name|BytesPerOutputCharacter
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Worker function that produces a Null-terminated string in an output buffer    based on a Null-terminated format string and variable argument list.    VSPrint function to process format and place the results in Buffer. Since a    VA_LIST is used this routine allows the nesting of Vararg routines. Thus    this is the main print working routine    @param  StartOfBuffer The character buffer to print the results of the parsing                         of Format into.   @param  BufferSize    The maximum number of characters to put into buffer.                         Zero means no limit.   @param  Flags         Initial flags value.                         Can only have FORMAT_UNICODE and OUTPUT_UNICODE set   @param  FormatString  A Null-terminated format string.   @param  ...           The variable argument list.    @return The number of characters printed.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|BasePrintLibSPrint
parameter_list|(
name|OUT
name|CHAR8
modifier|*
name|StartOfBuffer
parameter_list|,
name|IN
name|UINTN
name|BufferSize
parameter_list|,
name|IN
name|UINTN
name|Flags
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|FormatString
parameter_list|,
modifier|...
parameter_list|)
block|{
name|VA_LIST
name|Marker
decl_stmt|;
name|UINTN
name|NumberOfPrinted
decl_stmt|;
name|VA_START
argument_list|(
name|Marker
argument_list|,
name|FormatString
argument_list|)
expr_stmt|;
name|NumberOfPrinted
operator|=
name|BasePrintLibSPrintMarker
argument_list|(
name|StartOfBuffer
argument_list|,
name|BufferSize
argument_list|,
name|Flags
argument_list|,
name|FormatString
argument_list|,
name|Marker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VA_END
argument_list|(
name|Marker
argument_list|)
expr_stmt|;
return|return
name|NumberOfPrinted
return|;
block|}
end_function

end_unit

