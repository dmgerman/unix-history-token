begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   This module provide help function for displaying unicode string.    Copyright (c) 2006 - 2015, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials                             are licensed and made available under the terms and conditions of the BSD License            which accompanies this distribution.  The full text of the license may be found at           http://opensource.org/licenses/bsd-license.php.                                                THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                        WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.               **/
end_comment

begin_include
include|#
directive|include
file|"UefiLibInternal.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|CHAR16
name|WChar
decl_stmt|;
name|UINT32
name|Width
decl_stmt|;
block|}
name|UNICODE_WIDTH_ENTRY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NARROW_CHAR
value|0xFFF0
end_define

begin_define
define|#
directive|define
name|WIDE_CHAR
value|0xFFF1
end_define

begin_decl_stmt
name|GLOBAL_REMOVE_IF_UNREFERENCED
name|CONST
name|UNICODE_WIDTH_ENTRY
name|mUnicodeWidthTable
index|[]
init|=
block|{
comment|//
comment|// General script area
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0x1FFF
block|,
literal|1
block|}
block|,
comment|/*    * Merge the blocks and replace them with the above entry as they fall to     * the same category and they are all narrow glyph. This will reduce search    * time and table size. The merge will omit the reserved code.    *    * Remove the above item if below is un-commented.    *   {(CHAR16)0x007F,  1},       // C0 controls and basic Latin. 0x0000-0x007F   {(CHAR16)0x00FF,  1},       // C1 controls and Latin-1 support. 0x0080-0x00FF   {(CHAR16)0x017F,  1},       // Latin extended-A. 0x0100-0x017F   {(CHAR16)0x024F,  1},       // Latin extended-B. 0x0180-0x024F   {(CHAR16)0x02AF,  1},       // IPA extensions. 0x0250-0x02AF   {(CHAR16)0x02FF,  1},       // Spacing modifier letters. 0x02B0-0x02FF   {(CHAR16)0x036F,  1},       // Combining diacritical marks. 0x0300-0x036F   {(CHAR16)0x03FF,  1},       // Greek. 0x0370-0x03FF   {(CHAR16)0x04FF,  1},       // Cyrillic. 0x0400-0x04FF   {(CHAR16)0x052F,  0},       // Unassigned. As Armenian in ver3.0. 0x0500-0x052F   {(CHAR16)0x058F,  1},       // Armenian. 0x0530-0x058F   {(CHAR16)0x05FF,  1},       // Hebrew. 0x0590-0x05FF   {(CHAR16)0x06FF,  1},       // Arabic. 0x0600-0x06FF   {(CHAR16)0x08FF,  0},       // Unassigned. 0x0700-0x08FF   {(CHAR16)0x097F,  1},       // Devanagari. 0x0900-0x097F   {(CHAR16)0x09FF,  1},       // Bengali. 0x0980-0x09FF   {(CHAR16)0x0A7F,  1},       // Gurmukhi. 0x0A00-0x0A7F   {(CHAR16)0x0AFF,  1},       // Gujarati. 0x0A80-0x0AFF   {(CHAR16)0x0B7F,  1},       // Oriya. 0x0B00-0x0B7F   {(CHAR16)0x0BFF,  1},       // Tamil. (See page 7-92). 0x0B80-0x0BFF   {(CHAR16)0x0C7F,  1},       // Telugu. 0x0C00-0x0C7F   {(CHAR16)0x0CFF,  1},       // Kannada. (See page 7-100). 0x0C80-0x0CFF   {(CHAR16)0x0D7F,  1},       // Malayalam (See page 7-104). 0x0D00-0x0D7F   {(CHAR16)0x0DFF,  0},       // Unassigned. 0x0D80-0x0DFF   {(CHAR16)0x0E7F,  1},       // Thai. 0x0E00-0x0E7F   {(CHAR16)0x0EFF,  1},       // Lao. 0x0E80-0x0EFF   {(CHAR16)0x0FBF,  1},       // Tibetan. 0x0F00-0x0FBF   {(CHAR16)0x109F,  0},       // Unassigned. 0x0FC0-0x109F   {(CHAR16)0x10FF,  1},       // Georgian. 0x10A0-0x10FF   {(CHAR16)0x11FF,  1},       // Hangul Jamo. 0x1100-0x11FF   {(CHAR16)0x1DFF,  0},       // Unassigned. 0x1200-0x1DFF   {(CHAR16)0x1EFF,  1},       // Latin extended additional. 0x1E00-0x1EFF   {(CHAR16)0x1FFF,  1},       // Greek extended. 0x1F00-0x1FFF   *   */
comment|//
comment|// Symbol area
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0x2FFF
block|,
literal|1
block|}
block|,
comment|/*    * Merge the blocks and replace them with the above entry as they fall to     * the same category and they are all narrow glyph. This will reduce search    * time and table size. The merge will omit the reserved code.    *    * Remove the above item if below is un-commented.    *   {(CHAR16)0x206F,  1},       // General punctuation. (See page7-154). 0x200-0x206F   {(CHAR16)0x209F,  1},       // Superscripts and subscripts. 0x2070-0x209F   {(CHAR16)0x20CF,  1},       // Currency symbols. 0x20A0-0x20CF   {(CHAR16)0x20FF,  1},       // Combining diacritical marks for symbols. 0x20D0-0x20FF   {(CHAR16)0x214F,  1},       // Letterlike sympbols. 0x2100-0x214F   {(CHAR16)0x218F,  1},       // Number forms. 0x2150-0x218F   {(CHAR16)0x21FF,  1},       // Arrows. 0x2190-0x21FF   {(CHAR16)0x22FF,  1},       // Mathematical operators. 0x2200-0x22FF   {(CHAR16)0x23FF,  1},       // Miscellaneous technical. 0x2300-0x23FF   {(CHAR16)0x243F,  1},       // Control pictures. 0x2400-0x243F   {(CHAR16)0x245F,  1},       // Optical character recognition. 0x2440-0x245F   {(CHAR16)0x24FF,  1},       // Enclosed alphanumerics. 0x2460-0x24FF   {(CHAR16)0x257F,  1},       // Box drawing. 0x2500-0x257F   {(CHAR16)0x259F,  1},       // Block elements. 0x2580-0x259F   {(CHAR16)0x25FF,  1},       // Geometric shapes. 0x25A0-0x25FF   {(CHAR16)0x26FF,  1},       // Miscellaneous symbols. 0x2600-0x26FF   {(CHAR16)0x27BF,  1},       // Dingbats. 0x2700-0x27BF   {(CHAR16)0x2FFF,  0},       // Reserved. 0x27C0-0x2FFF   *   */
comment|//
comment|// CJK phonetics and symbol area
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0x33FF
block|,
literal|2
block|}
block|,
comment|/*    * Merge the blocks and replace them with the above entry as they fall to     * the same category and they are all wide glyph. This will reduce search    * time and table size. The merge will omit the reserved code.    *    * Remove the above item if below is un-commented.    *   {(CHAR16)0x303F,  2},       // CJK symbols and punctuation. 0x3000-0x303F   {(CHAR16)0x309F,  2},       // Hiragana. 0x3040-0x309F   {(CHAR16)0x30FF,  2},       // Katakana. 0x30A0-0x30FF   {(CHAR16)0x312F,  2},       // Bopomofo. 0x3100-0x312F   {(CHAR16)0x318F,  2},       // Hangul compatibility jamo. 0x3130-0x318F   {(CHAR16)0x319F,  2},       // Kanbun. 0x3190-0x319F   {(CHAR16)0x31FF,  0},       // Reserved. As Bopomofo extended in ver3.0. 0x31A0-0x31FF   {(CHAR16)0x32FF,  2},       // Enclosed CJK letters and months. 0x3200-0x32FF   {(CHAR16)0x33FF,  2},       // CJK compatibility. 0x3300-0x33FF   *   */
comment|//
comment|// CJK ideograph area
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0x9FFF
block|,
literal|2
block|}
block|,
comment|/*    * Merge the blocks and replace them with the above entry as they fall to     * the same category and they are all wide glyph. This will reduce search    * time and table size. The merge will omit the reserved code.    *    * Remove the above item if below is un-commented.    *   {(CHAR16)0x4DFF,  0},       // Reserved. 0x3400-0x4DBF as CJK unified ideographs                        // extension A in ver3.0. 0x3400-0x4DFF   {(CHAR16)0x9FFF,  2},       // CJK unified ideographs. 0x4E00-0x9FFF   *   */
comment|//
comment|// Reserved
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0xABFF
block|,
literal|0
block|}
block|,
comment|// Reserved. 0xA000-0xA490 as Yi syllables. 0xA490-0xA4D0
comment|// as Yi radicals in ver3.0. 0xA000-0xABFF
comment|//
comment|// Hangul syllables
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0xD7FF
block|,
literal|2
block|}
block|,
comment|/*    * Merge the blocks and replace them with the above entry as they fall to     * the same category and they are all wide glyph. This will reduce search    * time and table size. The merge will omit the reserved code.    *    * Remove the above item if below is un-commented.    *   {(CHAR16)0xD7A3,  2},       // Hangul syllables. 0xAC00-0xD7A3   {(CHAR16)0xD7FF,  0},       // Reserved. 0xD7A3-0xD7FF   *   */
comment|//
comment|// Surrogates area
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0xDFFF
block|,
literal|0
block|}
block|,
comment|// Surrogates, not used now. 0xD800-0xDFFF
comment|//
comment|// Private use area
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0xF8FF
block|,
literal|0
block|}
block|,
comment|// Private use area. 0xE000-0xF8FF
comment|//
comment|// Compatibility area and specials
comment|//
block|{
operator|(
name|CHAR16
operator|)
literal|0xFAFF
block|,
literal|2
block|}
block|,
comment|// CJK compatibility ideographs. 0xF900-0xFAFF
block|{
operator|(
name|CHAR16
operator|)
literal|0xFB4F
block|,
literal|1
block|}
block|,
comment|// Alphabetic presentation forms. 0xFB00-0xFB4F
block|{
operator|(
name|CHAR16
operator|)
literal|0xFDFF
block|,
literal|1
block|}
block|,
comment|// Arabic presentation forms-A. 0xFB50-0xFDFF
block|{
operator|(
name|CHAR16
operator|)
literal|0xFE1F
block|,
literal|0
block|}
block|,
comment|// Reserved. As variation selectors in ver3.0. 0xFE00-0xFE1F
block|{
operator|(
name|CHAR16
operator|)
literal|0xFE2F
block|,
literal|1
block|}
block|,
comment|// Combining half marks. 0xFE20-0xFE2F
block|{
operator|(
name|CHAR16
operator|)
literal|0xFE4F
block|,
literal|2
block|}
block|,
comment|// CJK compatibility forms. 0xFE30-0xFE4F
block|{
operator|(
name|CHAR16
operator|)
literal|0xFE6F
block|,
literal|1
block|}
block|,
comment|// Small Form Variants. 0xFE50-0xFE6F
block|{
operator|(
name|CHAR16
operator|)
literal|0xFEFF
block|,
literal|1
block|}
block|,
comment|// Arabic presentation forms-B. 0xFE70-0xFEFF
block|{
operator|(
name|CHAR16
operator|)
literal|0xFFEF
block|,
literal|1
block|}
block|,
comment|// Half width and full width forms. 0xFF00-0xFFEF
block|{
operator|(
name|CHAR16
operator|)
literal|0xFFFF
block|,
literal|0
block|}
block|,
comment|// Speicials. 0xFFF0-0xFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**   Retrieves the width of a Unicode character.    This function computes and returns the width of the Unicode character specified   by UnicodeChar.    @param  UnicodeChar   A Unicode character.    @retval 0             The width if UnicodeChar could not be determined.   @retval 1             UnicodeChar is a narrow glyph.   @retval 2             UnicodeChar is a wide glyph.  **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|GetGlyphWidth
parameter_list|(
name|IN
name|CHAR16
name|UnicodeChar
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
name|UINTN
name|Low
decl_stmt|;
name|UINTN
name|High
decl_stmt|;
name|CONST
name|UNICODE_WIDTH_ENTRY
modifier|*
name|Item
decl_stmt|;
name|Item
operator|=
name|NULL
expr_stmt|;
name|Low
operator|=
literal|0
expr_stmt|;
name|High
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|mUnicodeWidthTable
argument_list|)
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|UNICODE_WIDTH_ENTRY
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|Low
operator|<=
name|High
condition|)
block|{
name|Index
operator|=
operator|(
name|Low
operator|+
name|High
operator|)
operator|>>
literal|1
expr_stmt|;
name|Item
operator|=
operator|&
operator|(
name|mUnicodeWidthTable
index|[
name|Index
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|Index
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|UnicodeChar
operator|<=
name|Item
operator|->
name|WChar
condition|)
block|{
break|break;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|UnicodeChar
operator|>
name|Item
operator|->
name|WChar
condition|)
block|{
name|Low
operator|=
name|Index
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UnicodeChar
operator|<=
name|mUnicodeWidthTable
index|[
name|Index
operator|-
literal|1
index|]
operator|.
name|WChar
condition|)
block|{
name|High
operator|=
name|Index
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Index - 1< UnicodeChar<= Index. Found
comment|//
break|break;
block|}
block|}
if|if
condition|(
name|Low
operator|<=
name|High
condition|)
block|{
return|return
name|Item
operator|->
name|Width
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**   Computes the display length of a Null-terminated Unicode String.    This function computes and returns the display length of the Null-terminated    Unicode string specified by String.  If String is NULL then 0 is returned. If    any of the widths of the Unicode characters in String can not be determined,    then 0 is returned. The display width of String can be computed by summing the    display widths of each Unicode character in String.  Unicode characters that    are narrow glyphs have a width of 1, and Unicode characters that are width glyphs    have a width of 2.  If String is not aligned on a 16-bit boundary, then ASSERT().    @param  String      A pointer to a Null-terminated Unicode string.    @return The display length of the Null-terminated Unicode string specified by String.    **/
end_comment

begin_function
name|UINTN
name|EFIAPI
name|UnicodeStringDisplayLength
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|String
parameter_list|)
block|{
name|UINTN
name|Length
decl_stmt|;
name|UINTN
name|Width
decl_stmt|;
if|if
condition|(
name|String
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|String
operator|!=
literal|0
condition|)
block|{
name|Width
operator|=
name|GetGlyphWidth
argument_list|(
operator|*
name|String
argument_list|)
expr_stmt|;
if|if
condition|(
name|Width
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Length
operator|+=
name|Width
expr_stmt|;
name|String
operator|++
expr_stmt|;
block|}
return|return
name|Length
return|;
block|}
end_function

begin_comment
comment|/**   Count the storage space of a Unicode string.     This function handles the Unicode string with NARROW_CHAR   and WIDE_CHAR control characters. NARROW_HCAR and WIDE_CHAR   does not count in the resultant output. If a WIDE_CHAR is   hit, then 2 Unicode character will consume an output storage   space with size of CHAR16 till a NARROW_CHAR is hit.    @param String          The input string to be counted.   @param LimitLen        Whether need to limit the string length.   @param MaxWidth        The max length this function supported.   @param Offset          The max index of the string can be show out.     @return Storage space for the input string.  **/
end_comment

begin_function
name|UINTN
name|UefiLibGetStringWidth
parameter_list|(
name|IN
name|CHAR16
modifier|*
name|String
parameter_list|,
name|IN
name|BOOLEAN
name|LimitLen
parameter_list|,
name|IN
name|UINTN
name|MaxWidth
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Offset
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
name|UINTN
name|Count
decl_stmt|;
name|UINTN
name|IncrementValue
decl_stmt|;
if|if
condition|(
name|String
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Index
operator|=
literal|0
expr_stmt|;
name|Count
operator|=
literal|0
expr_stmt|;
name|IncrementValue
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|//
comment|// Advance to the null-terminator or to the first width directive
comment|//
for|for
control|(
init|;
operator|(
name|String
index|[
name|Index
index|]
operator|!=
name|NARROW_CHAR
operator|)
operator|&&
operator|(
name|String
index|[
name|Index
index|]
operator|!=
name|WIDE_CHAR
operator|)
operator|&&
operator|(
name|String
index|[
name|Index
index|]
operator|!=
literal|0
operator|)
condition|;
name|Index
operator|++
control|)
block|{
name|Count
operator|=
name|Count
operator|+
name|IncrementValue
expr_stmt|;
if|if
condition|(
name|LimitLen
operator|&&
name|Count
operator|>
name|MaxWidth
condition|)
block|{
break|break;
block|}
block|}
comment|//
comment|// We hit the null-terminator, we now have a count
comment|//
if|if
condition|(
name|String
index|[
name|Index
index|]
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|LimitLen
operator|&&
name|Count
operator|>
name|MaxWidth
condition|)
block|{
operator|*
name|Offset
operator|=
name|Index
expr_stmt|;
break|break;
block|}
comment|//
comment|// We encountered a narrow directive - strip it from the size calculation since it doesn't get printed
comment|// and also set the flag that determines what we increment by.(if narrow, increment by 1, if wide increment by 2)
comment|//
if|if
condition|(
name|String
index|[
name|Index
index|]
operator|==
name|NARROW_CHAR
condition|)
block|{
comment|//
comment|// Skip to the next character
comment|//
name|Index
operator|++
expr_stmt|;
name|IncrementValue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Skip to the next character
comment|//
name|Index
operator|++
expr_stmt|;
name|IncrementValue
operator|=
literal|2
expr_stmt|;
block|}
block|}
do|while
condition|(
name|String
index|[
name|Index
index|]
operator|!=
literal|0
condition|)
do|;
return|return
name|Count
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Draws a dialog box to the console output device specified by    ConOut defined in the EFI_SYSTEM_TABLE and waits for a keystroke   from the console input device specified by ConIn defined in the    EFI_SYSTEM_TABLE.    If there are no strings in the variable argument list, then ASSERT().   If all the strings in the variable argument list are empty, then ASSERT().    @param[in]   Attribute  Specifies the foreground and background color of the popup.   @param[out]  Key        A pointer to the EFI_KEY value of the key that was                            pressed.  This is an optional parameter that may be NULL.                           If it is NULL then no wait for a keypress will be performed.   @param[in]  ...         The variable argument list that contains pointers to Null-                           terminated Unicode strings to display in the dialog box.                             The variable argument list is terminated by a NULL.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|CreatePopUp
parameter_list|(
name|IN
name|UINTN
name|Attribute
parameter_list|,
name|OUT
name|EFI_INPUT_KEY
modifier|*
name|Key
parameter_list|,
name|OPTIONAL
modifier|...
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|VA_LIST
name|Args
decl_stmt|;
name|EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL
modifier|*
name|ConOut
decl_stmt|;
name|EFI_SIMPLE_TEXT_OUTPUT_MODE
name|SavedConsoleMode
decl_stmt|;
name|UINTN
name|Columns
decl_stmt|;
name|UINTN
name|Rows
decl_stmt|;
name|UINTN
name|Column
decl_stmt|;
name|UINTN
name|Row
decl_stmt|;
name|UINTN
name|NumberOfLines
decl_stmt|;
name|UINTN
name|MaxLength
decl_stmt|;
name|CHAR16
modifier|*
name|String
decl_stmt|;
name|UINTN
name|Length
decl_stmt|;
name|CHAR16
modifier|*
name|Line
decl_stmt|;
name|UINTN
name|EventIndex
decl_stmt|;
name|CHAR16
modifier|*
name|TmpString
decl_stmt|;
comment|//
comment|// Determine the length of the longest line in the popup and the the total
comment|// number of lines in the popup
comment|//
name|VA_START
argument_list|(
name|Args
argument_list|,
name|Key
argument_list|)
expr_stmt|;
name|MaxLength
operator|=
literal|0
expr_stmt|;
name|NumberOfLines
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|String
operator|=
name|VA_ARG
argument_list|(
name|Args
argument_list|,
name|CHAR16
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|MaxLength
operator|=
name|MAX
argument_list|(
name|MaxLength
argument_list|,
name|UefiLibGetStringWidth
argument_list|(
name|String
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|NumberOfLines
operator|++
expr_stmt|;
block|}
name|VA_END
argument_list|(
name|Args
argument_list|)
expr_stmt|;
comment|//
comment|// If the total number of lines in the popup is zero, then ASSERT()
comment|//
name|ASSERT
argument_list|(
name|NumberOfLines
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// If the maximum length of all the strings is zero, then ASSERT()
comment|//
name|ASSERT
argument_list|(
name|MaxLength
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|//
comment|// Cache a pointer to the Simple Text Output Protocol in the EFI System Table
comment|//
name|ConOut
operator|=
name|gST
operator|->
name|ConOut
expr_stmt|;
comment|//
comment|// Save the current console cursor position and attributes
comment|//
name|CopyMem
argument_list|(
operator|&
name|SavedConsoleMode
argument_list|,
name|ConOut
operator|->
name|Mode
argument_list|,
sizeof|sizeof
argument_list|(
name|SavedConsoleMode
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Retrieve the number of columns and rows in the current console mode
comment|//
name|ConOut
operator|->
name|QueryMode
argument_list|(
name|ConOut
argument_list|,
name|SavedConsoleMode
operator|.
name|Mode
argument_list|,
operator|&
name|Columns
argument_list|,
operator|&
name|Rows
argument_list|)
expr_stmt|;
comment|//
comment|// Disable cursor and set the foreground and background colors specified by Attribute
comment|//
name|ConOut
operator|->
name|EnableCursor
argument_list|(
name|ConOut
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|SetAttribute
argument_list|(
name|ConOut
argument_list|,
name|Attribute
argument_list|)
expr_stmt|;
comment|//
comment|// Limit NumberOfLines to height of the screen minus 3 rows for the box itself
comment|//
name|NumberOfLines
operator|=
name|MIN
argument_list|(
name|NumberOfLines
argument_list|,
name|Rows
operator|-
literal|3
argument_list|)
expr_stmt|;
comment|//
comment|// Limit MaxLength to width of the screen minus 2 columns for the box itself
comment|//
name|MaxLength
operator|=
name|MIN
argument_list|(
name|MaxLength
argument_list|,
name|Columns
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|//
comment|// Compute the starting row and starting column for the popup
comment|//
name|Row
operator|=
operator|(
name|Rows
operator|-
operator|(
name|NumberOfLines
operator|+
literal|3
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|Column
operator|=
operator|(
name|Columns
operator|-
operator|(
name|MaxLength
operator|+
literal|2
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
comment|//
comment|// Allocate a buffer for a single line of the popup with borders and a Null-terminator
comment|//
name|Line
operator|=
name|AllocateZeroPool
argument_list|(
operator|(
name|MaxLength
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Line
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Draw top of popup box
comment|//
name|SetMem16
argument_list|(
name|Line
argument_list|,
operator|(
name|MaxLength
operator|+
literal|2
operator|)
operator|*
literal|2
argument_list|,
name|BOXDRAW_HORIZONTAL
argument_list|)
expr_stmt|;
name|Line
index|[
literal|0
index|]
operator|=
name|BOXDRAW_DOWN_RIGHT
expr_stmt|;
name|Line
index|[
name|MaxLength
operator|+
literal|1
index|]
operator|=
name|BOXDRAW_DOWN_LEFT
expr_stmt|;
name|Line
index|[
name|MaxLength
operator|+
literal|2
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|ConOut
operator|->
name|SetCursorPosition
argument_list|(
name|ConOut
argument_list|,
name|Column
argument_list|,
name|Row
operator|++
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|OutputString
argument_list|(
name|ConOut
argument_list|,
name|Line
argument_list|)
expr_stmt|;
comment|//
comment|// Draw middle of the popup with strings
comment|//
name|VA_START
argument_list|(
name|Args
argument_list|,
name|Key
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|String
operator|=
name|VA_ARG
argument_list|(
name|Args
argument_list|,
name|CHAR16
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|NumberOfLines
operator|>
literal|0
condition|)
block|{
name|SetMem16
argument_list|(
name|Line
argument_list|,
operator|(
name|MaxLength
operator|+
literal|2
operator|)
operator|*
literal|2
argument_list|,
literal|L'
expr|'
argument_list|)
expr_stmt|;
name|Line
index|[
literal|0
index|]
operator|=
name|BOXDRAW_VERTICAL
expr_stmt|;
name|Line
index|[
name|MaxLength
operator|+
literal|1
index|]
operator|=
name|BOXDRAW_VERTICAL
expr_stmt|;
name|Line
index|[
name|MaxLength
operator|+
literal|2
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|ConOut
operator|->
name|SetCursorPosition
argument_list|(
name|ConOut
argument_list|,
name|Column
argument_list|,
name|Row
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|OutputString
argument_list|(
name|ConOut
argument_list|,
name|Line
argument_list|)
expr_stmt|;
name|Length
operator|=
name|UefiLibGetStringWidth
argument_list|(
name|String
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|Length
operator|<=
name|MaxLength
condition|)
block|{
comment|//
comment|// Length<= MaxLength
comment|//
name|ConOut
operator|->
name|SetCursorPosition
argument_list|(
name|ConOut
argument_list|,
name|Column
operator|+
literal|1
operator|+
operator|(
name|MaxLength
operator|-
name|Length
operator|)
operator|/
literal|2
argument_list|,
name|Row
operator|++
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|OutputString
argument_list|(
name|ConOut
argument_list|,
name|String
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// Length> MaxLength
comment|//
name|UefiLibGetStringWidth
argument_list|(
name|String
argument_list|,
name|TRUE
argument_list|,
name|MaxLength
argument_list|,
operator|&
name|Length
argument_list|)
expr_stmt|;
name|TmpString
operator|=
name|AllocateZeroPool
argument_list|(
operator|(
name|Length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|TmpString
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|StrnCpyS
argument_list|(
name|TmpString
argument_list|,
name|Length
operator|+
literal|1
argument_list|,
name|String
argument_list|,
name|Length
operator|-
literal|3
argument_list|)
expr_stmt|;
name|StrCatS
argument_list|(
name|TmpString
argument_list|,
name|Length
operator|+
literal|1
argument_list|,
literal|L"..."
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|SetCursorPosition
argument_list|(
name|ConOut
argument_list|,
name|Column
operator|+
literal|1
argument_list|,
name|Row
operator|++
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|OutputString
argument_list|(
name|ConOut
argument_list|,
name|TmpString
argument_list|)
expr_stmt|;
name|FreePool
argument_list|(
name|TmpString
argument_list|)
expr_stmt|;
block|}
name|NumberOfLines
operator|--
expr_stmt|;
block|}
name|VA_END
argument_list|(
name|Args
argument_list|)
expr_stmt|;
comment|//
comment|// Draw bottom of popup box
comment|//
name|SetMem16
argument_list|(
name|Line
argument_list|,
operator|(
name|MaxLength
operator|+
literal|2
operator|)
operator|*
literal|2
argument_list|,
name|BOXDRAW_HORIZONTAL
argument_list|)
expr_stmt|;
name|Line
index|[
literal|0
index|]
operator|=
name|BOXDRAW_UP_RIGHT
expr_stmt|;
name|Line
index|[
name|MaxLength
operator|+
literal|1
index|]
operator|=
name|BOXDRAW_UP_LEFT
expr_stmt|;
name|Line
index|[
name|MaxLength
operator|+
literal|2
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|ConOut
operator|->
name|SetCursorPosition
argument_list|(
name|ConOut
argument_list|,
name|Column
argument_list|,
name|Row
operator|++
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|OutputString
argument_list|(
name|ConOut
argument_list|,
name|Line
argument_list|)
expr_stmt|;
comment|//
comment|// Free the allocated line buffer
comment|//
name|FreePool
argument_list|(
name|Line
argument_list|)
expr_stmt|;
comment|//
comment|// Restore the cursor visibility, position, and attributes
comment|//
name|ConOut
operator|->
name|EnableCursor
argument_list|(
name|ConOut
argument_list|,
name|SavedConsoleMode
operator|.
name|CursorVisible
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|SetCursorPosition
argument_list|(
name|ConOut
argument_list|,
name|SavedConsoleMode
operator|.
name|CursorColumn
argument_list|,
name|SavedConsoleMode
operator|.
name|CursorRow
argument_list|)
expr_stmt|;
name|ConOut
operator|->
name|SetAttribute
argument_list|(
name|ConOut
argument_list|,
name|SavedConsoleMode
operator|.
name|Attribute
argument_list|)
expr_stmt|;
comment|//
comment|// Wait for a keystroke
comment|//
if|if
condition|(
name|Key
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
name|Status
operator|=
name|gST
operator|->
name|ConIn
operator|->
name|ReadKeyStroke
argument_list|(
name|gST
operator|->
name|ConIn
argument_list|,
name|Key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
break|break;
block|}
comment|//
comment|// If we encounter error, continue to read another key in.
comment|//
if|if
condition|(
name|Status
operator|!=
name|EFI_NOT_READY
condition|)
block|{
continue|continue;
block|}
name|gBS
operator|->
name|WaitForEvent
argument_list|(
literal|1
argument_list|,
operator|&
name|gST
operator|->
name|ConIn
operator|->
name|WaitForKey
argument_list|,
operator|&
name|EventIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

