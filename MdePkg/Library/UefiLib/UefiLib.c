begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   The UEFI Library provides functions and macros that simplify the development of    UEFI Drivers and UEFI Applications.  These functions and macros help manage EFI    events, build simple locks utilizing EFI Task Priority Levels (TPLs), install    EFI Driver Model related protocols, manage Unicode string tables for UEFI Drivers,    and print messages on the console output and standard error devices.    Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|"UefiLibInternal.h"
end_include

begin_comment
comment|/**   Empty constructor function that is required to resolve dependencies between    libraries.        ** DO NOT REMOVE **      @param  ImageHandle   The firmware allocated handle for the EFI image.   @param  SystemTable   A pointer to the EFI System Table.      @retval EFI_SUCCESS   The constructor executed correctly.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|UefiLibConstructor
parameter_list|(
name|IN
name|EFI_HANDLE
name|ImageHandle
parameter_list|,
name|IN
name|EFI_SYSTEM_TABLE
modifier|*
name|SystemTable
parameter_list|)
block|{
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Compare whether two names of languages are identical.    @param  Language1 Name of language 1.   @param  Language2 Name of language 2.    @retval TRUE      Language 1 and language 2 are the same.   @retval FALSE     Language 1 and language 2 are not the same.  **/
end_comment

begin_function
name|BOOLEAN
name|CompareIso639LanguageCode
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Language1
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|Language2
parameter_list|)
block|{
name|UINT32
name|Name1
decl_stmt|;
name|UINT32
name|Name2
decl_stmt|;
name|Name1
operator|=
name|ReadUnaligned24
argument_list|(
operator|(
name|CONST
name|UINT32
operator|*
operator|)
name|Language1
argument_list|)
expr_stmt|;
name|Name2
operator|=
name|ReadUnaligned24
argument_list|(
operator|(
name|CONST
name|UINT32
operator|*
operator|)
name|Language2
argument_list|)
expr_stmt|;
return|return
call|(
name|BOOLEAN
call|)
argument_list|(
name|Name1
operator|==
name|Name2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Retrieves a pointer to the system configuration table from the EFI System Table   based on a specified GUID.      This function searches the list of configuration tables stored in the EFI System Table   for a table with a GUID that matches TableGuid.  If a match is found, then a pointer to   the configuration table is returned in Table., and EFI_SUCCESS is returned. If a matching GUID   is not found, then EFI_NOT_FOUND is returned.   If TableGuid is NULL, then ASSERT().   If Table is NULL, then ASSERT().    @param  TableGuid       The pointer to table's GUID type.   @param  Table           The pointer to the table associated with TableGuid in the EFI System Table.    @retval EFI_SUCCESS     A configuration table matching TableGuid was found.   @retval EFI_NOT_FOUND   A configuration table matching TableGuid could not be found.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiGetSystemConfigurationTable
parameter_list|(
name|IN
name|EFI_GUID
modifier|*
name|TableGuid
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Table
parameter_list|)
block|{
name|EFI_SYSTEM_TABLE
modifier|*
name|SystemTable
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|ASSERT
argument_list|(
name|TableGuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SystemTable
operator|=
name|gST
expr_stmt|;
operator|*
name|Table
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|SystemTable
operator|->
name|NumberOfTableEntries
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
name|CompareGuid
argument_list|(
name|TableGuid
argument_list|,
operator|&
operator|(
name|SystemTable
operator|->
name|ConfigurationTable
index|[
name|Index
index|]
operator|.
name|VendorGuid
operator|)
argument_list|)
condition|)
block|{
operator|*
name|Table
operator|=
name|SystemTable
operator|->
name|ConfigurationTable
index|[
name|Index
index|]
operator|.
name|VendorTable
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
block|}
return|return
name|EFI_NOT_FOUND
return|;
block|}
end_function

begin_comment
comment|/**   Creates and returns a notification event and registers that event with all the protocol   instances specified by ProtocolGuid.    This function causes the notification function to be executed for every protocol of type   ProtocolGuid instance that exists in the system when this function is invoked. If there are   no instances of ProtocolGuid in the handle database at the time this function is invoked,   then the notification function is still executed one time. In addition, every time a protocol   of type ProtocolGuid instance is installed or reinstalled, the notification function is also   executed. This function returns the notification event that was created.    If ProtocolGuid is NULL, then ASSERT().   If NotifyTpl is not a legal TPL value, then ASSERT().   If NotifyFunction is NULL, then ASSERT().   If Registration is NULL, then ASSERT().     @param  ProtocolGuid    Supplies GUID of the protocol upon whose installation the event is fired.   @param  NotifyTpl       Supplies the task priority level of the event notifications.   @param  NotifyFunction  Supplies the function to notify when the event is signaled.   @param  NotifyContext   The context parameter to pass to NotifyFunction.   @param  Registration    A pointer to a memory location to receive the registration value.                           This value is passed to LocateHandle() to obtain new handles that                           have been added that support the ProtocolGuid-specified protocol.     @return The notification event that was created.  **/
end_comment

begin_function
name|EFI_EVENT
name|EFIAPI
name|EfiCreateProtocolNotifyEvent
parameter_list|(
name|IN
name|EFI_GUID
modifier|*
name|ProtocolGuid
parameter_list|,
name|IN
name|EFI_TPL
name|NotifyTpl
parameter_list|,
name|IN
name|EFI_EVENT_NOTIFY
name|NotifyFunction
parameter_list|,
name|IN
name|VOID
modifier|*
name|NotifyContext
parameter_list|,
name|OPTIONAL
name|OUT
name|VOID
modifier|*
modifier|*
name|Registration
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_EVENT
name|Event
decl_stmt|;
name|ASSERT
argument_list|(
name|ProtocolGuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|NotifyFunction
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Registration
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Create the event
comment|//
name|Status
operator|=
name|gBS
operator|->
name|CreateEvent
argument_list|(
name|EVT_NOTIFY_SIGNAL
argument_list|,
name|NotifyTpl
argument_list|,
name|NotifyFunction
argument_list|,
name|NotifyContext
argument_list|,
operator|&
name|Event
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|//
comment|// Register for protocol notifications on this event
comment|//
name|Status
operator|=
name|gBS
operator|->
name|RegisterProtocolNotify
argument_list|(
name|ProtocolGuid
argument_list|,
name|Event
argument_list|,
name|Registration
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|//
comment|// Kick the event so we will perform an initial pass of
comment|// current installed drivers
comment|//
name|gBS
operator|->
name|SignalEvent
argument_list|(
name|Event
argument_list|)
expr_stmt|;
return|return
name|Event
return|;
block|}
end_function

begin_comment
comment|/**   Creates a named event that can be signaled with EfiNamedEventSignal().    This function creates an event using NotifyTpl, NoifyFunction, and NotifyContext.   This event is signaled with EfiNamedEventSignal(). This provides the ability for one or more   listeners on the same event named by the GUID specified by Name.    If Name is NULL, then ASSERT().   If NotifyTpl is not a legal TPL value, then ASSERT().   If NotifyFunction is NULL, then ASSERT().    @param  Name                  Supplies the GUID name of the event.   @param  NotifyTpl             Supplies the task priority level of the event notifications.   @param  NotifyFunction        Supplies the function to notify when the event is signaled.   @param  NotifyContext         The context parameter to pass to NotifyFunction.    @param  Registration          A pointer to a memory location to receive the registration value.    @retval EFI_SUCCESS           A named event was created.   @retval EFI_OUT_OF_RESOURCES  There are not enough resource to create the named event.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiNamedEventListen
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|Name
parameter_list|,
name|IN
name|EFI_TPL
name|NotifyTpl
parameter_list|,
name|IN
name|EFI_EVENT_NOTIFY
name|NotifyFunction
parameter_list|,
name|IN
name|CONST
name|VOID
modifier|*
name|NotifyContext
parameter_list|,
name|OPTIONAL
name|OUT
name|VOID
modifier|*
name|Registration
name|OPTIONAL
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_EVENT
name|Event
decl_stmt|;
name|VOID
modifier|*
name|RegistrationLocal
decl_stmt|;
name|ASSERT
argument_list|(
name|Name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|NotifyFunction
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|NotifyTpl
operator|<=
name|TPL_HIGH_LEVEL
argument_list|)
expr_stmt|;
comment|//
comment|// Create event
comment|//
name|Status
operator|=
name|gBS
operator|->
name|CreateEvent
argument_list|(
name|EVT_NOTIFY_SIGNAL
argument_list|,
name|NotifyTpl
argument_list|,
name|NotifyFunction
argument_list|,
operator|(
name|VOID
operator|*
operator|)
name|NotifyContext
argument_list|,
operator|&
name|Event
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
comment|//
comment|// The Registration is not optional to RegisterProtocolNotify().
comment|// To make it optional to EfiNamedEventListen(), may need to substitute with a local.
comment|//
if|if
condition|(
name|Registration
operator|!=
name|NULL
condition|)
block|{
name|RegistrationLocal
operator|=
name|Registration
expr_stmt|;
block|}
else|else
block|{
name|RegistrationLocal
operator|=
operator|&
name|RegistrationLocal
expr_stmt|;
block|}
comment|//
comment|// Register for an installation of protocol interface
comment|//
name|Status
operator|=
name|gBS
operator|->
name|RegisterProtocolNotify
argument_list|(
operator|(
name|EFI_GUID
operator|*
operator|)
name|Name
argument_list|,
name|Event
argument_list|,
name|RegistrationLocal
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Signals a named event created with EfiNamedEventListen().    This function signals the named event specified by Name. The named event must have been   created with EfiNamedEventListen().   If Name is NULL, then ASSERT().    @param  Name                  Supplies the GUID name of the event.    @retval EFI_SUCCESS           A named event was signaled.   @retval EFI_OUT_OF_RESOURCES  There are not enough resource to signal the named event.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiNamedEventSignal
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|Name
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_HANDLE
name|Handle
decl_stmt|;
name|ASSERT
argument_list|(
name|Name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Handle
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|InstallProtocolInterface
argument_list|(
operator|&
name|Handle
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|Name
argument_list|,
name|EFI_NATIVE_INTERFACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|UninstallProtocolInterface
argument_list|(
name|Handle
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|Name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Signals an event group by placing a new event in the group temporarily and   signaling it.    @param[in] EventGroup          Supplies the unique identifier of the event                                  group to signal.    @retval EFI_SUCCESS            The event group was signaled successfully.   @retval EFI_INVALID_PARAMETER  EventGroup is NULL.   @return                        Error codes that report problems about event                                  creation or signaling. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiEventGroupSignal
parameter_list|(
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|EventGroup
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_EVENT
name|Event
decl_stmt|;
if|if
condition|(
name|EventGroup
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
name|Status
operator|=
name|gBS
operator|->
name|CreateEventEx
argument_list|(
name|EVT_NOTIFY_SIGNAL
argument_list|,
name|TPL_CALLBACK
argument_list|,
name|EfiEventEmptyFunction
argument_list|,
name|NULL
argument_list|,
name|EventGroup
argument_list|,
operator|&
name|Event
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
name|Status
operator|=
name|gBS
operator|->
name|SignalEvent
argument_list|(
name|Event
argument_list|)
expr_stmt|;
name|gBS
operator|->
name|CloseEvent
argument_list|(
name|Event
argument_list|)
expr_stmt|;
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   An empty function that can be used as NotifyFunction parameter of   CreateEvent() or CreateEventEx().    @param Event              Event whose notification function is being invoked.   @param Context            The pointer to the notification function's context,                             which is implementation-dependent.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|EfiEventEmptyFunction
parameter_list|(
name|IN
name|EFI_EVENT
name|Event
parameter_list|,
name|IN
name|VOID
modifier|*
name|Context
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**    Returns the current TPL.    This function returns the current TPL.  There is no EFI service to directly    retrieve the current TPL. Instead, the RaiseTPL() function is used to raise    the TPL to TPL_HIGH_LEVEL.  This will return the current TPL.  The TPL level    can then immediately be restored back to the current TPL level with a call    to RestoreTPL().    @return The current TPL.  **/
end_comment

begin_function
name|EFI_TPL
name|EFIAPI
name|EfiGetCurrentTpl
parameter_list|(
name|VOID
parameter_list|)
block|{
name|EFI_TPL
name|Tpl
decl_stmt|;
name|Tpl
operator|=
name|gBS
operator|->
name|RaiseTPL
argument_list|(
name|TPL_HIGH_LEVEL
argument_list|)
expr_stmt|;
name|gBS
operator|->
name|RestoreTPL
argument_list|(
name|Tpl
argument_list|)
expr_stmt|;
return|return
name|Tpl
return|;
block|}
end_function

begin_comment
comment|/**   Initializes a basic mutual exclusion lock.    This function initializes a basic mutual exclusion lock to the released state    and returns the lock.  Each lock provides mutual exclusion access at its task    priority level.  Since there is no preemption or multiprocessor support in EFI,   acquiring the lock only consists of raising to the locks TPL.   If Lock is NULL, then ASSERT().   If Priority is not a valid TPL value, then ASSERT().    @param  Lock       A pointer to the lock data structure to initialize.   @param  Priority   EFI TPL is associated with the lock.    @return The lock.  **/
end_comment

begin_function
name|EFI_LOCK
modifier|*
name|EFIAPI
name|EfiInitializeLock
parameter_list|(
name|IN
name|OUT
name|EFI_LOCK
modifier|*
name|Lock
parameter_list|,
name|IN
name|EFI_TPL
name|Priority
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|Lock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Priority
operator|<=
name|TPL_HIGH_LEVEL
argument_list|)
expr_stmt|;
name|Lock
operator|->
name|Tpl
operator|=
name|Priority
expr_stmt|;
name|Lock
operator|->
name|OwnerTpl
operator|=
name|TPL_APPLICATION
expr_stmt|;
name|Lock
operator|->
name|Lock
operator|=
name|EfiLockReleased
expr_stmt|;
return|return
name|Lock
return|;
block|}
end_function

begin_comment
comment|/**   Acquires ownership of a lock.    This function raises the system's current task priority level to the task    priority level of the mutual exclusion lock.  Then, it places the lock in the    acquired state.   If Lock is NULL, then ASSERT().   If Lock is not initialized, then ASSERT().   If Lock is already in the acquired state, then ASSERT().    @param  Lock              A pointer to the lock to acquire.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|EfiAcquireLock
parameter_list|(
name|IN
name|EFI_LOCK
modifier|*
name|Lock
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|Lock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Lock
operator|->
name|Lock
operator|==
name|EfiLockReleased
argument_list|)
expr_stmt|;
name|Lock
operator|->
name|OwnerTpl
operator|=
name|gBS
operator|->
name|RaiseTPL
argument_list|(
name|Lock
operator|->
name|Tpl
argument_list|)
expr_stmt|;
name|Lock
operator|->
name|Lock
operator|=
name|EfiLockAcquired
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Acquires ownership of a lock.    This function raises the system's current task priority level to the task priority   level of the mutual exclusion lock.  Then, it attempts to place the lock in the acquired state.   If the lock is already in the acquired state, then EFI_ACCESS_DENIED is returned.   Otherwise, EFI_SUCCESS is returned.   If Lock is NULL, then ASSERT().   If Lock is not initialized, then ASSERT().    @param  Lock              A pointer to the lock to acquire.    @retval EFI_SUCCESS       The lock was acquired.   @retval EFI_ACCESS_DENIED The lock could not be acquired because it is already owned.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiAcquireLockOrFail
parameter_list|(
name|IN
name|EFI_LOCK
modifier|*
name|Lock
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|Lock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Lock
operator|->
name|Lock
operator|!=
name|EfiLockUninitialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lock
operator|->
name|Lock
operator|==
name|EfiLockAcquired
condition|)
block|{
comment|//
comment|// Lock is already owned, so bail out
comment|//
return|return
name|EFI_ACCESS_DENIED
return|;
block|}
name|Lock
operator|->
name|OwnerTpl
operator|=
name|gBS
operator|->
name|RaiseTPL
argument_list|(
name|Lock
operator|->
name|Tpl
argument_list|)
expr_stmt|;
name|Lock
operator|->
name|Lock
operator|=
name|EfiLockAcquired
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Releases ownership of a lock.    This function transitions a mutual exclusion lock from the acquired state to    the released state, and restores the system's task priority level to its    previous level.   If Lock is NULL, then ASSERT().   If Lock is not initialized, then ASSERT().   If Lock is already in the released state, then ASSERT().    @param  Lock  A pointer to the lock to release.  **/
end_comment

begin_function
name|VOID
name|EFIAPI
name|EfiReleaseLock
parameter_list|(
name|IN
name|EFI_LOCK
modifier|*
name|Lock
parameter_list|)
block|{
name|EFI_TPL
name|Tpl
decl_stmt|;
name|ASSERT
argument_list|(
name|Lock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Lock
operator|->
name|Lock
operator|==
name|EfiLockAcquired
argument_list|)
expr_stmt|;
name|Tpl
operator|=
name|Lock
operator|->
name|OwnerTpl
expr_stmt|;
name|Lock
operator|->
name|Lock
operator|=
name|EfiLockReleased
expr_stmt|;
name|gBS
operator|->
name|RestoreTPL
argument_list|(
name|Tpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   Tests whether a controller handle is being managed by a specific driver.    This function tests whether the driver specified by DriverBindingHandle is   currently managing the controller specified by ControllerHandle.  This test   is performed by evaluating if the the protocol specified by ProtocolGuid is   present on ControllerHandle and is was opened by DriverBindingHandle with an   attribute of EFI_OPEN_PROTOCOL_BY_DRIVER.    If ProtocolGuid is NULL, then ASSERT().    @param  ControllerHandle     A handle for a controller to test.   @param  DriverBindingHandle  Specifies the driver binding handle for the                                driver.   @param  ProtocolGuid         Specifies the protocol that the driver specified                                by DriverBindingHandle opens in its Start()                                function.    @retval EFI_SUCCESS          ControllerHandle is managed by the driver                                specified by DriverBindingHandle.   @retval EFI_UNSUPPORTED      ControllerHandle is not managed by the driver                                specified by DriverBindingHandle.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiTestManagedDevice
parameter_list|(
name|IN
name|CONST
name|EFI_HANDLE
name|ControllerHandle
parameter_list|,
name|IN
name|CONST
name|EFI_HANDLE
name|DriverBindingHandle
parameter_list|,
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|ProtocolGuid
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|VOID
modifier|*
name|ManagedInterface
decl_stmt|;
name|ASSERT
argument_list|(
name|ProtocolGuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|Status
operator|=
name|gBS
operator|->
name|OpenProtocol
argument_list|(
name|ControllerHandle
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|ProtocolGuid
argument_list|,
operator|&
name|ManagedInterface
argument_list|,
name|DriverBindingHandle
argument_list|,
name|ControllerHandle
argument_list|,
name|EFI_OPEN_PROTOCOL_BY_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|gBS
operator|->
name|CloseProtocol
argument_list|(
name|ControllerHandle
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|ProtocolGuid
argument_list|,
name|DriverBindingHandle
argument_list|,
name|ControllerHandle
argument_list|)
expr_stmt|;
return|return
name|EFI_UNSUPPORTED
return|;
block|}
if|if
condition|(
name|Status
operator|!=
name|EFI_ALREADY_STARTED
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   Tests whether a child handle is a child device of the controller.    This function tests whether ChildHandle is one of the children of   ControllerHandle.  This test is performed by checking to see if the protocol   specified by ProtocolGuid is present on ControllerHandle and opened by   ChildHandle with an attribute of EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER.   If ProtocolGuid is NULL, then ASSERT().    @param  ControllerHandle     A handle for a (parent) controller to test.    @param  ChildHandle          A child handle to test.   @param  ProtocolGuid         Supplies the protocol that the child controller                                opens on its parent controller.     @retval EFI_SUCCESS          ChildHandle is a child of the ControllerHandle.   @retval EFI_UNSUPPORTED      ChildHandle is not a child of the                                ControllerHandle.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|EfiTestChildHandle
parameter_list|(
name|IN
name|CONST
name|EFI_HANDLE
name|ControllerHandle
parameter_list|,
name|IN
name|CONST
name|EFI_HANDLE
name|ChildHandle
parameter_list|,
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|ProtocolGuid
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|EFI_OPEN_PROTOCOL_INFORMATION_ENTRY
modifier|*
name|OpenInfoBuffer
decl_stmt|;
name|UINTN
name|EntryCount
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|ASSERT
argument_list|(
name|ProtocolGuid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Retrieve the list of agents that are consuming the specific protocol
comment|// on ControllerHandle.
comment|//
name|Status
operator|=
name|gBS
operator|->
name|OpenProtocolInformation
argument_list|(
name|ControllerHandle
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|ProtocolGuid
argument_list|,
operator|&
name|OpenInfoBuffer
argument_list|,
operator|&
name|EntryCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// Inspect if ChildHandle is one of the agents.
comment|//
name|Status
operator|=
name|EFI_UNSUPPORTED
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|EntryCount
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OpenInfoBuffer
index|[
name|Index
index|]
operator|.
name|ControllerHandle
operator|==
name|ChildHandle
operator|)
operator|&&
operator|(
name|OpenInfoBuffer
index|[
name|Index
index|]
operator|.
name|Attributes
operator|&
name|EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER
operator|)
operator|!=
literal|0
condition|)
block|{
name|Status
operator|=
name|EFI_SUCCESS
expr_stmt|;
break|break;
block|}
block|}
name|FreePool
argument_list|(
name|OpenInfoBuffer
argument_list|)
expr_stmt|;
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   This function looks up a Unicode string in UnicodeStringTable.    If Language is a member of SupportedLanguages and a Unicode string is found in   UnicodeStringTable that matches the language code specified by Language, then it   is returned in UnicodeString.    @param  Language                A pointer to the ISO 639-2 language code for the                                    Unicode string to look up and return.   @param  SupportedLanguages      A pointer to the set of ISO 639-2 language codes                                    that the Unicode string table supports.  Language                                    must be a member of this set.   @param  UnicodeStringTable      A pointer to the table of Unicode strings.   @param  UnicodeString           A pointer to the Unicode string from UnicodeStringTable                                   that matches the language specified by Language.    @retval EFI_SUCCESS             The Unicode string that matches the language                                    specified by Language was found                                   in the table of Unicode strings UnicodeStringTable,                                    and it was returned in UnicodeString.   @retval EFI_INVALID_PARAMETER   Language is NULL.   @retval EFI_INVALID_PARAMETER   UnicodeString is NULL.   @retval EFI_UNSUPPORTED         SupportedLanguages is NULL.   @retval EFI_UNSUPPORTED         UnicodeStringTable is NULL.   @retval EFI_UNSUPPORTED         The language specified by Language is not a                                    member of SupportedLanguages.   @retval EFI_UNSUPPORTED         The language specified by Language is not                                    supported by UnicodeStringTable.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|LookupUnicodeString
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Language
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|SupportedLanguages
parameter_list|,
name|IN
name|CONST
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|UnicodeStringTable
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|UnicodeString
parameter_list|)
block|{
comment|//
comment|// Make sure the parameters are valid
comment|//
if|if
condition|(
name|Language
operator|==
name|NULL
operator|||
name|UnicodeString
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// If there are no supported languages, or the Unicode String Table is empty, then the
comment|// Unicode String specified by Language is not supported by this Unicode String Table
comment|//
if|if
condition|(
name|SupportedLanguages
operator|==
name|NULL
operator|||
name|UnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// Make sure Language is in the set of Supported Languages
comment|//
while|while
condition|(
operator|*
name|SupportedLanguages
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CompareIso639LanguageCode
argument_list|(
name|Language
argument_list|,
name|SupportedLanguages
argument_list|)
condition|)
block|{
comment|//
comment|// Search the Unicode String Table for the matching Language specifier
comment|//
while|while
condition|(
name|UnicodeStringTable
operator|->
name|Language
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CompareIso639LanguageCode
argument_list|(
name|Language
argument_list|,
name|UnicodeStringTable
operator|->
name|Language
argument_list|)
condition|)
block|{
comment|//
comment|// A matching string was found, so return it
comment|//
operator|*
name|UnicodeString
operator|=
name|UnicodeStringTable
operator|->
name|UnicodeString
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
name|UnicodeStringTable
operator|++
expr_stmt|;
block|}
return|return
name|EFI_UNSUPPORTED
return|;
block|}
name|SupportedLanguages
operator|+=
literal|3
expr_stmt|;
block|}
return|return
name|EFI_UNSUPPORTED
return|;
block|}
end_function

begin_comment
comment|/**   This function looks up a Unicode string in UnicodeStringTable.    If Language is a member of SupportedLanguages and a Unicode string is found in   UnicodeStringTable that matches the language code specified by Language, then   it is returned in UnicodeString.    @param  Language             A pointer to an ASCII string containing the ISO 639-2 or the                                RFC 4646 language code for the Unicode string to look up and                                return. If Iso639Language is TRUE, then this ASCII string is                                not assumed to be Null-terminated, and only the first three                                characters are used. If Iso639Language is FALSE, then this ASCII                                string must be Null-terminated.    @param  SupportedLanguages   A pointer to a Null-terminated ASCII string that contains a                                set of ISO 639-2 or RFC 4646 language codes that the Unicode                                string table supports.  Language must be a member of this set.                                If Iso639Language is TRUE, then this string contains one or more                                ISO 639-2 language codes with no separator characters. If Iso639Language                                is FALSE, then is string contains one or more RFC 4646 language                                codes separated by ';'.   @param  UnicodeStringTable   A pointer to the table of Unicode strings. Type EFI_UNICODE_STRING_TABLE                                is defined in "Related Definitions".   @param  UnicodeString        A pointer to the Null-terminated Unicode string from UnicodeStringTable                                that matches the language specified by Language.   @param  Iso639Language       Specifies the supported language code format. If it is TRUE, then                                Language and SupportedLanguages follow ISO 639-2 language code format.                                Otherwise, they follow RFC 4646 language code format.     @retval  EFI_SUCCESS            The Unicode string that matches the language specified by Language                                   was found in the table of Unicode strings UnicodeStringTable, and                                   it was returned in UnicodeString.   @retval  EFI_INVALID_PARAMETER  Language is NULL.     @retval  EFI_INVALID_PARAMETER  UnicodeString is NULL.     @retval  EFI_UNSUPPORTED        SupportedLanguages is NULL.     @retval  EFI_UNSUPPORTED        UnicodeStringTable is NULL.     @retval  EFI_UNSUPPORTED        The language specified by Language is not a member of SupportedLanguages.     @retval  EFI_UNSUPPORTED        The language specified by Language is not supported by UnicodeStringTable.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|LookupUnicodeString2
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Language
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|SupportedLanguages
parameter_list|,
name|IN
name|CONST
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|UnicodeStringTable
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|UnicodeString
parameter_list|,
name|IN
name|BOOLEAN
name|Iso639Language
parameter_list|)
block|{
name|BOOLEAN
name|Found
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|CHAR8
modifier|*
name|LanguageString
decl_stmt|;
comment|//
comment|// Make sure the parameters are valid
comment|//
if|if
condition|(
name|Language
operator|==
name|NULL
operator|||
name|UnicodeString
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// If there are no supported languages, or the Unicode String Table is empty, then the
comment|// Unicode String specified by Language is not supported by this Unicode String Table
comment|//
if|if
condition|(
name|SupportedLanguages
operator|==
name|NULL
operator|||
name|UnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// Make sure Language is in the set of Supported Languages
comment|//
name|Found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|SupportedLanguages
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Iso639Language
condition|)
block|{
if|if
condition|(
name|CompareIso639LanguageCode
argument_list|(
name|Language
argument_list|,
name|SupportedLanguages
argument_list|)
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|SupportedLanguages
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|SupportedLanguages
index|[
name|Index
index|]
operator|!=
literal|0
operator|&&
name|SupportedLanguages
index|[
name|Index
index|]
operator|!=
literal|';'
condition|;
name|Index
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|AsciiStrnCmp
argument_list|(
name|SupportedLanguages
argument_list|,
name|Language
argument_list|,
name|Index
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|Language
index|[
name|Index
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|SupportedLanguages
operator|+=
name|Index
expr_stmt|;
for|for
control|(
init|;
operator|*
name|SupportedLanguages
operator|!=
literal|0
operator|&&
operator|*
name|SupportedLanguages
operator|==
literal|';'
condition|;
name|SupportedLanguages
operator|++
control|)
empty_stmt|;
block|}
block|}
comment|//
comment|// If Language is not a member of SupportedLanguages, then return EFI_UNSUPPORTED
comment|//
if|if
condition|(
operator|!
name|Found
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// Search the Unicode String Table for the matching Language specifier
comment|//
while|while
condition|(
name|UnicodeStringTable
operator|->
name|Language
operator|!=
name|NULL
condition|)
block|{
name|LanguageString
operator|=
name|UnicodeStringTable
operator|->
name|Language
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|*
name|LanguageString
condition|)
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|LanguageString
index|[
name|Index
index|]
operator|!=
literal|0
operator|&&
name|LanguageString
index|[
name|Index
index|]
operator|!=
literal|';'
condition|;
name|Index
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|AsciiStrnCmp
argument_list|(
name|LanguageString
argument_list|,
name|Language
argument_list|,
name|Index
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|UnicodeString
operator|=
name|UnicodeStringTable
operator|->
name|UnicodeString
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
name|LanguageString
operator|+=
name|Index
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|LanguageString
index|[
name|Index
index|]
operator|!=
literal|0
operator|&&
name|LanguageString
index|[
name|Index
index|]
operator|==
literal|';'
condition|;
name|Index
operator|++
control|)
empty_stmt|;
block|}
name|UnicodeStringTable
operator|++
expr_stmt|;
block|}
return|return
name|EFI_UNSUPPORTED
return|;
block|}
end_function

begin_comment
comment|/**   This function adds a Unicode string to UnicodeStringTable.    If Language is a member of SupportedLanguages then UnicodeString is added to    UnicodeStringTable.  New buffers are allocated for both Language and    UnicodeString.  The contents of Language and UnicodeString are copied into    these new buffers.  These buffers are automatically freed when    FreeUnicodeStringTable() is called.    @param  Language                A pointer to the ISO 639-2 language code for the Unicode                                    string to add.   @param  SupportedLanguages      A pointer to the set of ISO 639-2 language codes                                   that the Unicode string table supports.                                   Language must be a member of this set.   @param  UnicodeStringTable      A pointer to the table of Unicode strings.   @param  UnicodeString           A pointer to the Unicode string to add.    @retval EFI_SUCCESS             The Unicode string that matches the language                                    specified by Language was found in the table of                                    Unicode strings UnicodeStringTable, and it was                                    returned in UnicodeString.   @retval EFI_INVALID_PARAMETER   Language is NULL.   @retval EFI_INVALID_PARAMETER   UnicodeString is NULL.   @retval EFI_INVALID_PARAMETER   UnicodeString is an empty string.   @retval EFI_UNSUPPORTED         SupportedLanguages is NULL.   @retval EFI_ALREADY_STARTED     A Unicode string with language Language is                                    already present in UnicodeStringTable.   @retval EFI_OUT_OF_RESOURCES    There is not enough memory to add another                                    Unicode string to UnicodeStringTable.   @retval EFI_UNSUPPORTED         The language specified by Language is not a                                    member of SupportedLanguages.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|AddUnicodeString
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Language
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|SupportedLanguages
parameter_list|,
name|IN
name|EFI_UNICODE_STRING_TABLE
modifier|*
modifier|*
name|UnicodeStringTable
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|UnicodeString
parameter_list|)
block|{
name|UINTN
name|NumberOfEntries
decl_stmt|;
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|OldUnicodeStringTable
decl_stmt|;
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|NewUnicodeStringTable
decl_stmt|;
name|UINTN
name|UnicodeStringLength
decl_stmt|;
comment|//
comment|// Make sure the parameter are valid
comment|//
if|if
condition|(
name|Language
operator|==
name|NULL
operator|||
name|UnicodeString
operator|==
name|NULL
operator|||
name|UnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// If there are no supported languages, then a Unicode String can not be added
comment|//
if|if
condition|(
name|SupportedLanguages
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// If the Unicode String is empty, then a Unicode String can not be added
comment|//
if|if
condition|(
name|UnicodeString
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// Make sure Language is a member of SupportedLanguages
comment|//
while|while
condition|(
operator|*
name|SupportedLanguages
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CompareIso639LanguageCode
argument_list|(
name|Language
argument_list|,
name|SupportedLanguages
argument_list|)
condition|)
block|{
comment|//
comment|// Determine the size of the Unicode String Table by looking for a NULL Language entry
comment|//
name|NumberOfEntries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|UnicodeStringTable
operator|!=
name|NULL
condition|)
block|{
name|OldUnicodeStringTable
operator|=
operator|*
name|UnicodeStringTable
expr_stmt|;
while|while
condition|(
name|OldUnicodeStringTable
operator|->
name|Language
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CompareIso639LanguageCode
argument_list|(
name|Language
argument_list|,
name|OldUnicodeStringTable
operator|->
name|Language
argument_list|)
condition|)
block|{
return|return
name|EFI_ALREADY_STARTED
return|;
block|}
name|OldUnicodeStringTable
operator|++
expr_stmt|;
name|NumberOfEntries
operator|++
expr_stmt|;
block|}
block|}
comment|//
comment|// Allocate space for a new Unicode String Table.  It must hold the current number of
comment|// entries, plus 1 entry for the new Unicode String, plus 1 entry for the end of table
comment|// marker
comment|//
name|NewUnicodeStringTable
operator|=
name|AllocatePool
argument_list|(
operator|(
name|NumberOfEntries
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EFI_UNICODE_STRING_TABLE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewUnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// If the current Unicode String Table contains any entries, then copy them to the
comment|// newly allocated Unicode String Table.
comment|//
if|if
condition|(
operator|*
name|UnicodeStringTable
operator|!=
name|NULL
condition|)
block|{
name|CopyMem
argument_list|(
name|NewUnicodeStringTable
argument_list|,
operator|*
name|UnicodeStringTable
argument_list|,
name|NumberOfEntries
operator|*
sizeof|sizeof
argument_list|(
name|EFI_UNICODE_STRING_TABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Allocate space for a copy of the Language specifier
comment|//
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|Language
operator|=
name|AllocateCopyPool
argument_list|(
literal|3
argument_list|,
name|Language
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|Language
operator|==
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|NewUnicodeStringTable
argument_list|)
expr_stmt|;
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// Compute the length of the Unicode String
comment|//
for|for
control|(
name|UnicodeStringLength
operator|=
literal|0
init|;
name|UnicodeString
index|[
name|UnicodeStringLength
index|]
operator|!=
literal|0
condition|;
name|UnicodeStringLength
operator|++
control|)
empty_stmt|;
comment|//
comment|// Allocate space for a copy of the Unicode String
comment|//
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|UnicodeString
operator|=
name|AllocateCopyPool
argument_list|(
operator|(
name|UnicodeStringLength
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|,
name|UnicodeString
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|UnicodeString
operator|==
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|Language
argument_list|)
expr_stmt|;
name|FreePool
argument_list|(
name|NewUnicodeStringTable
argument_list|)
expr_stmt|;
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// Mark the end of the Unicode String Table
comment|//
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
operator|+
literal|1
index|]
operator|.
name|Language
operator|=
name|NULL
expr_stmt|;
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
operator|+
literal|1
index|]
operator|.
name|UnicodeString
operator|=
name|NULL
expr_stmt|;
comment|//
comment|// Free the old Unicode String Table
comment|//
if|if
condition|(
operator|*
name|UnicodeStringTable
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
operator|*
name|UnicodeStringTable
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Point UnicodeStringTable at the newly allocated Unicode String Table
comment|//
operator|*
name|UnicodeStringTable
operator|=
name|NewUnicodeStringTable
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
name|SupportedLanguages
operator|+=
literal|3
expr_stmt|;
block|}
return|return
name|EFI_UNSUPPORTED
return|;
block|}
end_function

begin_comment
comment|/**   This function adds the Null-terminated Unicode string specified by UnicodeString   to UnicodeStringTable.    If Language is a member of SupportedLanguages then UnicodeString is added to   UnicodeStringTable.  New buffers are allocated for both Language and UnicodeString.   The contents of Language and UnicodeString are copied into these new buffers.   These buffers are automatically freed when EfiLibFreeUnicodeStringTable() is called.    @param  Language            A pointer to an ASCII string containing the ISO 639-2 or                               the RFC 4646 language code for the Unicode string to add.                               If Iso639Language is TRUE, then this ASCII string is not                               assumed to be Null-terminated, and only the first three                               chacters are used. If Iso639Language is FALSE, then this                               ASCII string must be Null-terminated.   @param  SupportedLanguages  A pointer to a Null-terminated ASCII string that contains                               a set of ISO 639-2 or RFC 4646 language codes that the Unicode                               string table supports.  Language must be a member of this set.                               If Iso639Language is TRUE, then this string contains one or more                               ISO 639-2 language codes with no separator characters.                               If Iso639Language is FALSE, then is string contains one or more                               RFC 4646 language codes separated by ';'.   @param  UnicodeStringTable  A pointer to the table of Unicode strings. Type EFI_UNICODE_STRING_TABLE                               is defined in "Related Definitions".   @param  UnicodeString       A pointer to the Unicode string to add.     @param  Iso639Language      Specifies the supported language code format. If it is TRUE,                               then Language and SupportedLanguages follow ISO 639-2 language code format.                               Otherwise, they follow RFC 4646 language code format.    @retval EFI_SUCCESS            The Unicode string that matches the language specified by                                  Language was found in the table of Unicode strings UnicodeStringTable,                                  and it was returned in UnicodeString.     @retval EFI_INVALID_PARAMETER  Language is NULL.     @retval EFI_INVALID_PARAMETER  UnicodeString is NULL.     @retval EFI_INVALID_PARAMETER  UnicodeString is an empty string.     @retval EFI_UNSUPPORTED        SupportedLanguages is NULL.     @retval EFI_ALREADY_STARTED    A Unicode string with language Language is already present in                                  UnicodeStringTable.     @retval EFI_OUT_OF_RESOURCES   There is not enough memory to add another Unicode string UnicodeStringTable.     @retval EFI_UNSUPPORTED        The language specified by Language is not a member of SupportedLanguages.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|AddUnicodeString2
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|Language
parameter_list|,
name|IN
name|CONST
name|CHAR8
modifier|*
name|SupportedLanguages
parameter_list|,
name|IN
name|EFI_UNICODE_STRING_TABLE
modifier|*
modifier|*
name|UnicodeStringTable
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|UnicodeString
parameter_list|,
name|IN
name|BOOLEAN
name|Iso639Language
parameter_list|)
block|{
name|UINTN
name|NumberOfEntries
decl_stmt|;
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|OldUnicodeStringTable
decl_stmt|;
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|NewUnicodeStringTable
decl_stmt|;
name|UINTN
name|UnicodeStringLength
decl_stmt|;
name|BOOLEAN
name|Found
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|CHAR8
modifier|*
name|LanguageString
decl_stmt|;
comment|//
comment|// Make sure the parameter are valid
comment|//
if|if
condition|(
name|Language
operator|==
name|NULL
operator|||
name|UnicodeString
operator|==
name|NULL
operator|||
name|UnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// If there are no supported languages, then a Unicode String can not be added
comment|//
if|if
condition|(
name|SupportedLanguages
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// If the Unicode String is empty, then a Unicode String can not be added
comment|//
if|if
condition|(
name|UnicodeString
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
comment|//
comment|// Make sure Language is a member of SupportedLanguages
comment|//
name|Found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|SupportedLanguages
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Iso639Language
condition|)
block|{
if|if
condition|(
name|CompareIso639LanguageCode
argument_list|(
name|Language
argument_list|,
name|SupportedLanguages
argument_list|)
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|SupportedLanguages
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|SupportedLanguages
index|[
name|Index
index|]
operator|!=
literal|0
operator|&&
name|SupportedLanguages
index|[
name|Index
index|]
operator|!=
literal|';'
condition|;
name|Index
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|AsciiStrnCmp
argument_list|(
name|SupportedLanguages
argument_list|,
name|Language
argument_list|,
name|Index
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|SupportedLanguages
operator|+=
name|Index
expr_stmt|;
for|for
control|(
init|;
operator|*
name|SupportedLanguages
operator|!=
literal|0
operator|&&
operator|*
name|SupportedLanguages
operator|==
literal|';'
condition|;
name|SupportedLanguages
operator|++
control|)
empty_stmt|;
block|}
block|}
comment|//
comment|// If Language is not a member of SupportedLanguages, then return EFI_UNSUPPORTED
comment|//
if|if
condition|(
operator|!
name|Found
condition|)
block|{
return|return
name|EFI_UNSUPPORTED
return|;
block|}
comment|//
comment|// Determine the size of the Unicode String Table by looking for a NULL Language entry
comment|//
name|NumberOfEntries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|UnicodeStringTable
operator|!=
name|NULL
condition|)
block|{
name|OldUnicodeStringTable
operator|=
operator|*
name|UnicodeStringTable
expr_stmt|;
while|while
condition|(
name|OldUnicodeStringTable
operator|->
name|Language
operator|!=
name|NULL
condition|)
block|{
name|LanguageString
operator|=
name|OldUnicodeStringTable
operator|->
name|Language
expr_stmt|;
while|while
condition|(
operator|*
name|LanguageString
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|LanguageString
index|[
name|Index
index|]
operator|!=
literal|0
operator|&&
name|LanguageString
index|[
name|Index
index|]
operator|!=
literal|';'
condition|;
name|Index
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|AsciiStrnCmp
argument_list|(
name|Language
argument_list|,
name|LanguageString
argument_list|,
name|Index
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|EFI_ALREADY_STARTED
return|;
block|}
name|LanguageString
operator|+=
name|Index
expr_stmt|;
for|for
control|(
init|;
operator|*
name|LanguageString
operator|!=
literal|0
operator|&&
operator|*
name|LanguageString
operator|==
literal|';'
condition|;
name|LanguageString
operator|++
control|)
empty_stmt|;
block|}
name|OldUnicodeStringTable
operator|++
expr_stmt|;
name|NumberOfEntries
operator|++
expr_stmt|;
block|}
block|}
comment|//
comment|// Allocate space for a new Unicode String Table.  It must hold the current number of
comment|// entries, plus 1 entry for the new Unicode String, plus 1 entry for the end of table
comment|// marker
comment|//
name|NewUnicodeStringTable
operator|=
name|AllocatePool
argument_list|(
operator|(
name|NumberOfEntries
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EFI_UNICODE_STRING_TABLE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewUnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// If the current Unicode String Table contains any entries, then copy them to the
comment|// newly allocated Unicode String Table.
comment|//
if|if
condition|(
operator|*
name|UnicodeStringTable
operator|!=
name|NULL
condition|)
block|{
name|CopyMem
argument_list|(
name|NewUnicodeStringTable
argument_list|,
operator|*
name|UnicodeStringTable
argument_list|,
name|NumberOfEntries
operator|*
sizeof|sizeof
argument_list|(
name|EFI_UNICODE_STRING_TABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Allocate space for a copy of the Language specifier
comment|//
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|Language
operator|=
name|AllocateCopyPool
argument_list|(
name|AsciiStrSize
argument_list|(
name|Language
argument_list|)
argument_list|,
name|Language
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|Language
operator|==
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|NewUnicodeStringTable
argument_list|)
expr_stmt|;
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// Compute the length of the Unicode String
comment|//
for|for
control|(
name|UnicodeStringLength
operator|=
literal|0
init|;
name|UnicodeString
index|[
name|UnicodeStringLength
index|]
operator|!=
literal|0
condition|;
name|UnicodeStringLength
operator|++
control|)
empty_stmt|;
comment|//
comment|// Allocate space for a copy of the Unicode String
comment|//
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|UnicodeString
operator|=
name|AllocateCopyPool
argument_list|(
name|StrSize
argument_list|(
name|UnicodeString
argument_list|)
argument_list|,
name|UnicodeString
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|UnicodeString
operator|==
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
index|]
operator|.
name|Language
argument_list|)
expr_stmt|;
name|FreePool
argument_list|(
name|NewUnicodeStringTable
argument_list|)
expr_stmt|;
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// Mark the end of the Unicode String Table
comment|//
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
operator|+
literal|1
index|]
operator|.
name|Language
operator|=
name|NULL
expr_stmt|;
name|NewUnicodeStringTable
index|[
name|NumberOfEntries
operator|+
literal|1
index|]
operator|.
name|UnicodeString
operator|=
name|NULL
expr_stmt|;
comment|//
comment|// Free the old Unicode String Table
comment|//
if|if
condition|(
operator|*
name|UnicodeStringTable
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
operator|*
name|UnicodeStringTable
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Point UnicodeStringTable at the newly allocated Unicode String Table
comment|//
operator|*
name|UnicodeStringTable
operator|=
name|NewUnicodeStringTable
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**   This function frees the table of Unicode strings in UnicodeStringTable.    If UnicodeStringTable is NULL, then EFI_SUCCESS is returned.   Otherwise, each language code, and each Unicode string in the Unicode string    table are freed, and EFI_SUCCESS is returned.    @param  UnicodeStringTable  A pointer to the table of Unicode strings.    @retval EFI_SUCCESS         The Unicode string table was freed.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FreeUnicodeStringTable
parameter_list|(
name|IN
name|EFI_UNICODE_STRING_TABLE
modifier|*
name|UnicodeStringTable
parameter_list|)
block|{
name|UINTN
name|Index
decl_stmt|;
comment|//
comment|// If the Unicode String Table is NULL, then it is already freed
comment|//
if|if
condition|(
name|UnicodeStringTable
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_SUCCESS
return|;
block|}
comment|//
comment|// Loop through the Unicode String Table until we reach the end of table marker
comment|//
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|UnicodeStringTable
index|[
name|Index
index|]
operator|.
name|Language
operator|!=
name|NULL
condition|;
name|Index
operator|++
control|)
block|{
comment|//
comment|// Free the Language string from the Unicode String Table
comment|//
name|FreePool
argument_list|(
name|UnicodeStringTable
index|[
name|Index
index|]
operator|.
name|Language
argument_list|)
expr_stmt|;
comment|//
comment|// Free the Unicode String from the Unicode String Table
comment|//
if|if
condition|(
name|UnicodeStringTable
index|[
name|Index
index|]
operator|.
name|UnicodeString
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|UnicodeStringTable
index|[
name|Index
index|]
operator|.
name|UnicodeString
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Free the Unicode String Table itself
comment|//
name|FreePool
argument_list|(
name|UnicodeStringTable
argument_list|)
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DISABLE_NEW_DEPRECATED_INTERFACES
end_ifndef

begin_comment
comment|/**   [ATTENTION] This function will be deprecated for security reason.    Returns a pointer to an allocated buffer that contains the contents of a    variable retrieved through the UEFI Runtime Service GetVariable().  The    returned buffer is allocated using AllocatePool().  The caller is responsible   for freeing this buffer with FreePool().    If Name is NULL, then ASSERT().   If Guid is NULL, then ASSERT().    @param[in]  Name  The pointer to a Null-terminated Unicode string.   @param[in]  Guid  The pointer to an EFI_GUID structure    @retval NULL   The variable could not be retrieved.   @retval NULL   There are not enough resources available for the variable contents.   @retval Other  A pointer to allocated buffer containing the variable contents.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|GetVariable
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|Name
parameter_list|,
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|Guid
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|VOID
modifier|*
name|Value
decl_stmt|;
name|ASSERT
argument_list|(
name|Name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Guid
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Try to get the variable size.
comment|//
name|Value
operator|=
name|NULL
expr_stmt|;
name|Size
operator|=
literal|0
expr_stmt|;
name|Status
operator|=
name|gRT
operator|->
name|GetVariable
argument_list|(
operator|(
name|CHAR16
operator|*
operator|)
name|Name
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|Guid
argument_list|,
name|NULL
argument_list|,
operator|&
name|Size
argument_list|,
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// Allocate buffer to get the variable.
comment|//
name|Value
operator|=
name|AllocatePool
argument_list|(
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Value
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// Get the variable data.
comment|//
name|Status
operator|=
name|gRT
operator|->
name|GetVariable
argument_list|(
operator|(
name|CHAR16
operator|*
operator|)
name|Name
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|Guid
argument_list|,
name|NULL
argument_list|,
operator|&
name|Size
argument_list|,
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|FreePool
argument_list|(
name|Value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|Value
return|;
block|}
end_function

begin_comment
comment|/**   [ATTENTION] This function will be deprecated for security reason.    Returns a pointer to an allocated buffer that contains the contents of a    variable retrieved through the UEFI Runtime Service GetVariable().  This    function always uses the EFI_GLOBAL_VARIABLE GUID to retrieve variables.   The returned buffer is allocated using AllocatePool().  The caller is    responsible for freeing this buffer with FreePool().    If Name is NULL, then ASSERT().    @param[in]  Name  The pointer to a Null-terminated Unicode string.    @retval NULL   The variable could not be retrieved.   @retval NULL   There are not enough resources available for the variable contents.   @retval Other  A pointer to allocated buffer containing the variable contents.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|GetEfiGlobalVariable
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|Name
parameter_list|)
block|{
return|return
name|GetVariable
argument_list|(
name|Name
argument_list|,
operator|&
name|gEfiGlobalVariableGuid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**   Returns the status whether get the variable success. The function retrieves    variable  through the UEFI Runtime Service GetVariable().  The    returned buffer is allocated using AllocatePool().  The caller is responsible   for freeing this buffer with FreePool().    If Name  is NULL, then ASSERT().   If Guid  is NULL, then ASSERT().   If Value is NULL, then ASSERT().    @param[in]  Name  The pointer to a Null-terminated Unicode string.   @param[in]  Guid  The pointer to an EFI_GUID structure   @param[out] Value The buffer point saved the variable info.   @param[out] Size  The buffer size of the variable.    @return EFI_OUT_OF_RESOURCES      Allocate buffer failed.   @return EFI_SUCCESS               Find the specified variable.   @return Others Errors             Return errors from call to gRT->GetVariable.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetVariable2
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|Name
parameter_list|,
name|IN
name|CONST
name|EFI_GUID
modifier|*
name|Guid
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Value
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
name|OPTIONAL
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|UINTN
name|BufferSize
decl_stmt|;
name|ASSERT
argument_list|(
name|Name
operator|!=
name|NULL
operator|&&
name|Guid
operator|!=
name|NULL
operator|&&
name|Value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//
comment|// Try to get the variable size.
comment|//
name|BufferSize
operator|=
literal|0
expr_stmt|;
operator|*
name|Value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Size
operator|!=
name|NULL
condition|)
block|{
operator|*
name|Size
operator|=
literal|0
expr_stmt|;
block|}
name|Status
operator|=
name|gRT
operator|->
name|GetVariable
argument_list|(
operator|(
name|CHAR16
operator|*
operator|)
name|Name
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|Guid
argument_list|,
name|NULL
argument_list|,
operator|&
name|BufferSize
argument_list|,
operator|*
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
return|return
name|Status
return|;
block|}
comment|//
comment|// Allocate buffer to get the variable.
comment|//
operator|*
name|Value
operator|=
name|AllocatePool
argument_list|(
name|BufferSize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|Value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Value
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
comment|//
comment|// Get the variable data.
comment|//
name|Status
operator|=
name|gRT
operator|->
name|GetVariable
argument_list|(
operator|(
name|CHAR16
operator|*
operator|)
name|Name
argument_list|,
operator|(
name|EFI_GUID
operator|*
operator|)
name|Guid
argument_list|,
name|NULL
argument_list|,
operator|&
name|BufferSize
argument_list|,
operator|*
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|FreePool
argument_list|(
operator|*
name|Value
argument_list|)
expr_stmt|;
operator|*
name|Value
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|Size
operator|!=
name|NULL
condition|)
block|{
operator|*
name|Size
operator|=
name|BufferSize
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Returns a pointer to an allocated buffer that contains the contents of a    variable retrieved through the UEFI Runtime Service GetVariable().  This    function always uses the EFI_GLOBAL_VARIABLE GUID to retrieve variables.   The returned buffer is allocated using AllocatePool().  The caller is    responsible for freeing this buffer with FreePool().    If Name is NULL, then ASSERT().   If Value is NULL, then ASSERT().    @param[in]  Name  The pointer to a Null-terminated Unicode string.   @param[out] Value The buffer point saved the variable info.   @param[out] Size  The buffer size of the variable.    @return EFI_OUT_OF_RESOURCES      Allocate buffer failed.   @return EFI_SUCCESS               Find the specified variable.   @return Others Errors             Return errors from call to gRT->GetVariable.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|GetEfiGlobalVariable2
parameter_list|(
name|IN
name|CONST
name|CHAR16
modifier|*
name|Name
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|Value
parameter_list|,
name|OUT
name|UINTN
modifier|*
name|Size
name|OPTIONAL
parameter_list|)
block|{
return|return
name|GetVariable2
argument_list|(
name|Name
argument_list|,
operator|&
name|gEfiGlobalVariableGuid
argument_list|,
name|Value
argument_list|,
name|Size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   Returns a pointer to an allocated buffer that contains the best matching language    from a set of supported languages.        This function supports both ISO 639-2 and RFC 4646 language codes, but language    code types may not be mixed in a single call to this function.  The language    code returned is allocated using AllocatePool().  The caller is responsible for    freeing the allocated buffer using FreePool().  This function supports a variable   argument list that allows the caller to pass in a prioritized list of language    codes to test against all the language codes in SupportedLanguages.     If SupportedLanguages is NULL, then ASSERT().    @param[in]  SupportedLanguages  A pointer to a Null-terminated ASCII string that                                   contains a set of language codes in the format                                    specified by Iso639Language.   @param[in]  Iso639Language      If TRUE, then all language codes are assumed to be                                   in ISO 639-2 format.  If FALSE, then all language                                   codes are assumed to be in RFC 4646 language format   @param[in]  ...                 A variable argument list that contains pointers to                                    Null-terminated ASCII strings that contain one or more                                   language codes in the format specified by Iso639Language.                                   The first language code from each of these language                                   code lists is used to determine if it is an exact or                                   close match to any of the language codes in                                    SupportedLanguages.  Close matches only apply to RFC 4646                                   language codes, and the matching algorithm from RFC 4647                                   is used to determine if a close match is present.  If                                    an exact or close match is found, then the matching                                   language code from SupportedLanguages is returned.  If                                   no matches are found, then the next variable argument                                   parameter is evaluated.  The variable argument list                                    is terminated by a NULL.    @retval NULL   The best matching language could not be found in SupportedLanguages.   @retval NULL   There are not enough resources available to return the best matching                   language.   @retval Other  A pointer to a Null-terminated ASCII string that is the best matching                   language in SupportedLanguages.  **/
end_comment

begin_function
name|CHAR8
modifier|*
name|EFIAPI
name|GetBestLanguage
parameter_list|(
name|IN
name|CONST
name|CHAR8
modifier|*
name|SupportedLanguages
parameter_list|,
name|IN
name|BOOLEAN
name|Iso639Language
parameter_list|,
modifier|...
parameter_list|)
block|{
name|VA_LIST
name|Args
decl_stmt|;
name|CHAR8
modifier|*
name|Language
decl_stmt|;
name|UINTN
name|CompareLength
decl_stmt|;
name|UINTN
name|LanguageLength
decl_stmt|;
name|CONST
name|CHAR8
modifier|*
name|Supported
decl_stmt|;
name|CHAR8
modifier|*
name|BestLanguage
decl_stmt|;
name|ASSERT
argument_list|(
name|SupportedLanguages
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VA_START
argument_list|(
name|Args
argument_list|,
name|Iso639Language
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|Language
operator|=
name|VA_ARG
argument_list|(
name|Args
argument_list|,
name|CHAR8
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|//
comment|// Default to ISO 639-2 mode
comment|//
name|CompareLength
operator|=
literal|3
expr_stmt|;
name|LanguageLength
operator|=
name|MIN
argument_list|(
literal|3
argument_list|,
name|AsciiStrLen
argument_list|(
name|Language
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// If in RFC 4646 mode, then determine the length of the first RFC 4646 language code in Language
comment|//
if|if
condition|(
operator|!
name|Iso639Language
condition|)
block|{
for|for
control|(
name|LanguageLength
operator|=
literal|0
init|;
name|Language
index|[
name|LanguageLength
index|]
operator|!=
literal|0
operator|&&
name|Language
index|[
name|LanguageLength
index|]
operator|!=
literal|';'
condition|;
name|LanguageLength
operator|++
control|)
empty_stmt|;
block|}
comment|//
comment|// Trim back the length of Language used until it is empty
comment|//
while|while
condition|(
name|LanguageLength
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Loop through all language codes in SupportedLanguages
comment|//
for|for
control|(
name|Supported
operator|=
name|SupportedLanguages
init|;
operator|*
name|Supported
operator|!=
literal|'\0'
condition|;
name|Supported
operator|+=
name|CompareLength
control|)
block|{
comment|//
comment|// In RFC 4646 mode, then Loop through all language codes in SupportedLanguages
comment|//
if|if
condition|(
operator|!
name|Iso639Language
condition|)
block|{
comment|//
comment|// Skip ';' characters in Supported
comment|//
for|for
control|(
init|;
operator|*
name|Supported
operator|!=
literal|'\0'
operator|&&
operator|*
name|Supported
operator|==
literal|';'
condition|;
name|Supported
operator|++
control|)
empty_stmt|;
comment|//
comment|// Determine the length of the next language code in Supported
comment|//
for|for
control|(
name|CompareLength
operator|=
literal|0
init|;
name|Supported
index|[
name|CompareLength
index|]
operator|!=
literal|0
operator|&&
name|Supported
index|[
name|CompareLength
index|]
operator|!=
literal|';'
condition|;
name|CompareLength
operator|++
control|)
empty_stmt|;
comment|//
comment|// If Language is longer than the Supported, then skip to the next language
comment|//
if|if
condition|(
name|LanguageLength
operator|>
name|CompareLength
condition|)
block|{
continue|continue;
block|}
block|}
comment|//
comment|// See if the first LanguageLength characters in Supported match Language
comment|//
if|if
condition|(
name|AsciiStrnCmp
argument_list|(
name|Supported
argument_list|,
name|Language
argument_list|,
name|LanguageLength
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VA_END
argument_list|(
name|Args
argument_list|)
expr_stmt|;
comment|//
comment|// Allocate, copy, and return the best matching language code from SupportedLanguages
comment|//
name|BestLanguage
operator|=
name|AllocateZeroPool
argument_list|(
name|CompareLength
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BestLanguage
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|CopyMem
argument_list|(
name|BestLanguage
argument_list|,
name|Supported
argument_list|,
name|CompareLength
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|Iso639Language
condition|)
block|{
comment|//
comment|// If ISO 639 mode, then each language can only be tested once
comment|//
name|LanguageLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// If RFC 4646 mode, then trim Language from the right to the next '-' character
comment|//
for|for
control|(
name|LanguageLength
operator|--
init|;
name|LanguageLength
operator|>
literal|0
operator|&&
name|Language
index|[
name|LanguageLength
index|]
operator|!=
literal|'-'
condition|;
name|LanguageLength
operator|--
control|)
empty_stmt|;
block|}
block|}
block|}
name|VA_END
argument_list|(
name|Args
argument_list|)
expr_stmt|;
comment|//
comment|// No matches were found
comment|//
return|return
name|NULL
return|;
block|}
end_function

end_unit

