begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Provides interface to EFI_FILE_HANDLE functionality.    Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<Uefi.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/SimpleFileSystem.h>
end_include

begin_include
include|#
directive|include
file|<Protocol/UnicodeCollation.h>
end_include

begin_include
include|#
directive|include
file|<Guid/FileInfo.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/MemoryAllocationLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/BaseMemoryLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/FileHandleLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/PcdLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/PrintLib.h>
end_include

begin_decl_stmt
name|CONST
name|UINT16
name|gUnicodeFileTag
init|=
name|EFI_UNICODE_BYTE_ORDER_MARK
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_FILE_NAME_LEN
value|522
end_define

begin_comment
comment|// (20 * (6+5+2))+1) unicode characters from EFI FAT spec (doubled for bytes)
end_comment

begin_define
define|#
directive|define
name|FIND_XXXXX_FILE_BUFFER_SIZE
value|(SIZE_OF_EFI_FILE_INFO + MAX_FILE_NAME_LEN)
end_define

begin_comment
comment|/**   This function will retrieve the information about the file for the handle   specified and store it in allocated pool memory.    This function allocates a buffer to store the file's information. It is the   caller's responsibility to free the buffer    @param  FileHandle  The file handle of the file for which information is   being requested.    @retval NULL information could not be retrieved.    @return the information about the file **/
end_comment

begin_function
name|EFI_FILE_INFO
modifier|*
name|EFIAPI
name|FileHandleGetInfo
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|)
block|{
name|EFI_FILE_INFO
modifier|*
name|FileInfo
decl_stmt|;
name|UINTN
name|FileInfoSize
decl_stmt|;
name|EFI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|//
comment|// Get the required size to allocate
comment|//
name|FileInfoSize
operator|=
literal|0
expr_stmt|;
name|FileInfo
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|FileHandle
operator|->
name|GetInfo
argument_list|(
name|FileHandle
argument_list|,
operator|&
name|gEfiFileInfoGuid
argument_list|,
operator|&
name|FileInfoSize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
comment|//
comment|// error is expected.  getting size to allocate
comment|//
name|FileInfo
operator|=
name|AllocateZeroPool
argument_list|(
name|FileInfoSize
argument_list|)
expr_stmt|;
comment|//
comment|// now get the information
comment|//
name|Status
operator|=
name|FileHandle
operator|->
name|GetInfo
argument_list|(
name|FileHandle
argument_list|,
operator|&
name|gEfiFileInfoGuid
argument_list|,
operator|&
name|FileInfoSize
argument_list|,
name|FileInfo
argument_list|)
expr_stmt|;
comment|//
comment|// if we got an error free the memory and return NULL
comment|//
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|&&
operator|(
name|FileInfo
operator|!=
name|NULL
operator|)
condition|)
block|{
name|FreePool
argument_list|(
name|FileInfo
argument_list|)
expr_stmt|;
name|FileInfo
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|FileInfo
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   This function sets the information about the file for the opened handle   specified.    @param[in]  FileHandle        The file handle of the file for which information                                 is being set.    @param[in]  FileInfo          The information to set.    @retval EFI_SUCCESS           The information was set.   @retval EFI_INVALID_PARAMETER A parameter was out of range or invalid.   @retval EFI_UNSUPPORTED       The FileHandle does not support FileInfo.   @retval EFI_NO_MEDIA          The device has no medium.   @retval EFI_DEVICE_ERROR      The device reported an error.   @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.   @retval EFI_WRITE_PROTECTED   The file or medium is write protected.   @retval EFI_ACCESS_DENIED     The file was opened read only.   @retval EFI_VOLUME_FULL       The volume is full. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleSetInfo
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|IN
name|CONST
name|EFI_FILE_INFO
modifier|*
name|FileInfo
parameter_list|)
block|{
if|if
condition|(
name|FileHandle
operator|==
name|NULL
operator|||
name|FileInfo
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Set the info
comment|//
return|return
operator|(
name|FileHandle
operator|->
name|SetInfo
argument_list|(
name|FileHandle
argument_list|,
operator|&
name|gEfiFileInfoGuid
argument_list|,
operator|(
name|UINTN
operator|)
name|FileInfo
operator|->
name|Size
argument_list|,
operator|(
name|EFI_FILE_INFO
operator|*
operator|)
name|FileInfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   This function reads information from an opened file.    If FileHandle is not a directory, the function reads the requested number of   bytes from the file at the file's current position and returns them in Buffer.   If the read goes beyond the end of the file, the read length is truncated to the   end of the file. The file's current position is increased by the number of bytes   returned.  If FileHandle is a directory, the function reads the directory entry   at the file's current position and returns the entry in Buffer. If the Buffer   is not large enough to hold the current directory entry, then   EFI_BUFFER_TOO_SMALL is returned and the current file position is not updated.   BufferSize is set to be the size of the buffer needed to read the entry. On   success, the current position is updated to the next directory entry. If there   are no more directory entries, the read returns a zero-length buffer.   EFI_FILE_INFO is the structure returned as the directory entry.    @param FileHandle             the opened file handle   @param BufferSize             on input the size of buffer in bytes.  on return                                 the number of bytes written.   @param Buffer                 the buffer to put read data into.    @retval EFI_SUCCESS           Data was read.   @retval EFI_NO_MEDIA          The device has no media.   @retval EFI_DEVICE_ERROR      The device reported an error.   @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.   @retval EFI_BUFFER_TO_SMALL   Buffer is too small. ReadSize contains required                                 size.  **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleRead
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|IN
name|OUT
name|UINTN
modifier|*
name|BufferSize
parameter_list|,
name|OUT
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the read based on EFI_FILE_PROTOCOL
comment|//
return|return
operator|(
name|FileHandle
operator|->
name|Read
argument_list|(
name|FileHandle
argument_list|,
name|BufferSize
argument_list|,
name|Buffer
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Write data to a file.    This function writes the specified number of bytes to the file at the current   file position. The current file position is advanced the actual number of bytes   written, which is returned in BufferSize. Partial writes only occur when there   has been a data error during the write attempt (such as "volume space full").   The file is automatically grown to hold the data if required. Direct writes to   opened directories are not supported.    @param FileHandle           The opened file for writing   @param BufferSize           on input the number of bytes in Buffer.  On output                               the number of bytes written.   @param Buffer               the buffer containing data to write is stored.   @retval EFI_SUCCESS          Data was written.  @retval EFI_UNSUPPORTED      Writes to an open directory are not supported.  @retval EFI_NO_MEDIA         The device has no media.  @retval EFI_DEVICE_ERROR     The device reported an error.  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.  @retval EFI_WRITE_PROTECTED  The device is write-protected.  @retval EFI_ACCESS_DENIED    The file was open for read only.  @retval EFI_VOLUME_FULL      The volume is full. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleWrite
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|IN
name|OUT
name|UINTN
modifier|*
name|BufferSize
parameter_list|,
name|IN
name|VOID
modifier|*
name|Buffer
parameter_list|)
block|{
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the write based on EFI_FILE_PROTOCOL
comment|//
return|return
operator|(
name|FileHandle
operator|->
name|Write
argument_list|(
name|FileHandle
argument_list|,
name|BufferSize
argument_list|,
name|Buffer
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Close an open file handle.    This function closes a specified file handle. All "dirty" cached file data is   flushed to the device, and the file is closed. In all cases the handle is   closed.  @param FileHandle               the file handle to close.  @retval EFI_SUCCESS             the file handle was closed successfully. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleClose
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the Close based on EFI_FILE_PROTOCOL
comment|//
name|Status
operator|=
name|FileHandle
operator|->
name|Close
argument_list|(
name|FileHandle
argument_list|)
expr_stmt|;
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Delete a file and close the handle    This function closes and deletes a file. In all cases the file handle is closed.   If the file cannot be deleted, the warning code EFI_WARN_DELETE_FAILURE is   returned, but the handle is still closed.    @param FileHandle             the file handle to delete    @retval EFI_SUCCESS           the file was closed successfully   @retval EFI_WARN_DELETE_FAILURE the handle was closed, but the file was not                                 deleted   @retval INVALID_PARAMETER     One of the parameters has an invalid value. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleDelete
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the Delete based on EFI_FILE_PROTOCOL
comment|//
name|Status
operator|=
name|FileHandle
operator|->
name|Delete
argument_list|(
name|FileHandle
argument_list|)
expr_stmt|;
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   Set the current position in a file.    This function sets the current file position for the handle to the position   supplied. With the exception of seeking to position 0xFFFFFFFFFFFFFFFF, only   absolute positioning is supported, and seeking past the end of the file is   allowed (a subsequent write would grow the file). Seeking to position   0xFFFFFFFFFFFFFFFF causes the current position to be set to the end of the file.   If FileHandle is a directory, the only position that may be set is zero. This   has the effect of starting the read process of the directory entries over.    @param FileHandle             The file handle on which the position is being set   @param Position               Byte position from beginning of file    @retval EFI_SUCCESS           Operation completed successfully.   @retval EFI_UNSUPPORTED       the seek request for non-zero is not valid on                                 directories.   @retval INVALID_PARAMETER     One of the parameters has an invalid value. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleSetPosition
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|IN
name|UINT64
name|Position
parameter_list|)
block|{
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the SetPosition based on EFI_FILE_PROTOCOL
comment|//
return|return
operator|(
name|FileHandle
operator|->
name|SetPosition
argument_list|(
name|FileHandle
argument_list|,
name|Position
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Gets a file's current position    This function retrieves the current file position for the file handle. For   directories, the current file position has no meaning outside of the file   system driver and as such the operation is not supported. An error is returned   if FileHandle is a directory.    @param FileHandle             The open file handle on which to get the position.   @param Position               Byte position from beginning of file.    @retval EFI_SUCCESS           the operation completed successfully.   @retval INVALID_PARAMETER     One of the parameters has an invalid value.   @retval EFI_UNSUPPORTED       the request is not valid on directories. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleGetPosition
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|OUT
name|UINT64
modifier|*
name|Position
parameter_list|)
block|{
if|if
condition|(
name|Position
operator|==
name|NULL
operator|||
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the GetPosition based on EFI_FILE_PROTOCOL
comment|//
return|return
operator|(
name|FileHandle
operator|->
name|GetPosition
argument_list|(
name|FileHandle
argument_list|,
name|Position
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Flushes data on a file    This function flushes all modified data associated with a file to a device.    @param FileHandle             The file handle on which to flush data    @retval EFI_SUCCESS           The data was flushed.   @retval EFI_NO_MEDIA          The device has no media.   @retval EFI_DEVICE_ERROR      The device reported an error.   @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.   @retval EFI_WRITE_PROTECTED   The file or medium is write protected.   @retval EFI_ACCESS_DENIED     The file was opened for read only. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleFlush
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|)
block|{
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// Perform the Flush based on EFI_FILE_PROTOCOL
comment|//
return|return
operator|(
name|FileHandle
operator|->
name|Flush
argument_list|(
name|FileHandle
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Function to determine if a given handle is a directory handle.    Open the file information on the DirHandle and verify that the Attribute   includes EFI_FILE_DIRECTORY bit set.    @param[in] DirHandle          Handle to open file.    @retval EFI_SUCCESS           DirHandle is a directory.   @retval EFI_INVALID_PARAMETER DirHandle is NULL.                                  The file information returns from FileHandleGetInfo is NULL.    @retval EFI_NOT_FOUND         DirHandle is not a directory. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleIsDirectory
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|DirHandle
parameter_list|)
block|{
name|EFI_FILE_INFO
modifier|*
name|DirInfo
decl_stmt|;
if|if
condition|(
name|DirHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// get the file information for DirHandle
comment|//
name|DirInfo
operator|=
name|FileHandleGetInfo
argument_list|(
name|DirHandle
argument_list|)
expr_stmt|;
comment|//
comment|// Parse DirInfo
comment|//
if|if
condition|(
name|DirInfo
operator|==
name|NULL
condition|)
block|{
comment|//
comment|// We got nothing...
comment|//
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|DirInfo
operator|->
name|Attribute
operator|&
name|EFI_FILE_DIRECTORY
operator|)
operator|==
literal|0
condition|)
block|{
comment|//
comment|// Attributes say this is not a directory
comment|//
name|FreePool
argument_list|(
name|DirInfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFI_NOT_FOUND
operator|)
return|;
block|}
comment|//
comment|// all good...
comment|//
name|FreePool
argument_list|(
name|DirInfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFI_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Retrieve first entry from a directory.    This function takes an open directory handle and gets information from the   first entry in the directory.  A buffer is allocated to contain   the information and a pointer to the buffer is returned in *Buffer.  The   caller can use FileHandleFindNextFile() to get subsequent directory entries.    The buffer will be freed by FileHandleFindNextFile() when the last directory   entry is read.  Otherwise, the caller must free the buffer, using FreePool,   when finished with it.    @param[in]  DirHandle         The file handle of the directory to search.   @param[out] Buffer            The pointer to pointer to buffer for file's information.    @retval EFI_SUCCESS           Found the first file.   @retval EFI_NOT_FOUND         Cannot find the directory.   @retval EFI_NO_MEDIA          The device has no media.   @retval EFI_DEVICE_ERROR      The device reported an error.   @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.   @return Others                status of FileHandleGetInfo, FileHandleSetPosition,                                 or FileHandleRead **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleFindFirstFile
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|DirHandle
parameter_list|,
name|OUT
name|EFI_FILE_INFO
modifier|*
modifier|*
name|Buffer
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|UINTN
name|BufferSize
decl_stmt|;
if|if
condition|(
name|Buffer
operator|==
name|NULL
operator|||
name|DirHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// verify that DirHandle is a directory
comment|//
name|Status
operator|=
name|FileHandleIsDirectory
argument_list|(
name|DirHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|Status
operator|)
return|;
block|}
comment|//
comment|// Allocate a buffer sized to struct size + enough for the string at the end
comment|//
name|BufferSize
operator|=
name|FIND_XXXXX_FILE_BUFFER_SIZE
expr_stmt|;
operator|*
name|Buffer
operator|=
name|AllocateZeroPool
argument_list|(
name|BufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Buffer
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_OUT_OF_RESOURCES
operator|)
return|;
block|}
comment|//
comment|// reset to the beginning of the directory
comment|//
name|Status
operator|=
name|FileHandleSetPosition
argument_list|(
name|DirHandle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|FreePool
argument_list|(
operator|*
name|Buffer
argument_list|)
expr_stmt|;
operator|*
name|Buffer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
comment|//
comment|// read in the info about the first file
comment|//
name|Status
operator|=
name|FileHandleRead
argument_list|(
name|DirHandle
argument_list|,
operator|&
name|BufferSize
argument_list|,
operator|*
name|Buffer
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Status
operator|!=
name|EFI_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|BufferSize
operator|==
literal|0
condition|)
block|{
name|FreePool
argument_list|(
operator|*
name|Buffer
argument_list|)
expr_stmt|;
operator|*
name|Buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|BufferSize
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EFI_NOT_FOUND
operator|)
return|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
return|return
operator|(
name|EFI_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Retrieve next entries from a directory.    To use this function, the caller must first call the FileHandleFindFirstFile()   function to get the first directory entry.  Subsequent directory entries are   retrieved by using the FileHandleFindNextFile() function.  This function can   be called several times to get each entry from the directory.  If the call of   FileHandleFindNextFile() retrieved the last directory entry, the next call of   this function will set *NoFile to TRUE and free the buffer.    @param[in]  DirHandle         The file handle of the directory.   @param[out] Buffer            The pointer to buffer for file's information.   @param[out] NoFile            The pointer to boolean when last file is found.    @retval EFI_SUCCESS           Found the next file, or reached last file   @retval EFI_NO_MEDIA          The device has no media.   @retval EFI_DEVICE_ERROR      The device reported an error.   @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleFindNextFile
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|DirHandle
parameter_list|,
name|OUT
name|EFI_FILE_INFO
modifier|*
name|Buffer
parameter_list|,
name|OUT
name|BOOLEAN
modifier|*
name|NoFile
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|UINTN
name|BufferSize
decl_stmt|;
if|if
condition|(
name|DirHandle
operator|==
name|NULL
operator|||
name|Buffer
operator|==
name|NULL
operator|||
name|NoFile
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// This BufferSize MUST stay equal to the originally allocated one in GetFirstFile
comment|//
name|BufferSize
operator|=
name|FIND_XXXXX_FILE_BUFFER_SIZE
expr_stmt|;
comment|//
comment|// read in the info about the next file
comment|//
name|Status
operator|=
name|FileHandleRead
argument_list|(
name|DirHandle
argument_list|,
operator|&
name|BufferSize
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|Status
operator|!=
name|EFI_BUFFER_TOO_SMALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|Status
operator|)
return|;
block|}
comment|//
comment|// If we read 0 bytes (but did not have erros) we already read in the last file.
comment|//
if|if
condition|(
name|BufferSize
operator|==
literal|0
condition|)
block|{
name|FreePool
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
operator|*
name|NoFile
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|EFI_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Retrieve the size of a file.    This function extracts the file size info from the FileHandle's EFI_FILE_INFO   data.    @param[in] FileHandle         The file handle from which size is retrieved.   @param[out] Size              The pointer to size.    @retval EFI_SUCCESS           Operation was completed successfully.   @retval EFI_DEVICE_ERROR      Cannot access the file.   @retval EFI_INVALID_PARAMETER FileHandle is NULL.                                 Size is NULL. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleGetSize
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|OUT
name|UINT64
modifier|*
name|Size
parameter_list|)
block|{
name|EFI_FILE_INFO
modifier|*
name|FileInfo
decl_stmt|;
if|if
condition|(
name|FileHandle
operator|==
name|NULL
operator|||
name|Size
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// get the FileInfo structure
comment|//
name|FileInfo
operator|=
name|FileHandleGetInfo
argument_list|(
name|FileHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileInfo
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_DEVICE_ERROR
operator|)
return|;
block|}
comment|//
comment|// Assign the Size pointer to the correct value
comment|//
operator|*
name|Size
operator|=
name|FileInfo
operator|->
name|FileSize
expr_stmt|;
comment|//
comment|// free the FileInfo memory
comment|//
name|FreePool
argument_list|(
name|FileInfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFI_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Set the size of a file.    This function changes the file size info from the FileHandle's EFI_FILE_INFO   data.    @param[in] FileHandle         The file handle whose size is to be changed.   @param[in] Size               The new size.    @retval EFI_SUCCESS           The operation completed successfully.   @retval EFI_DEVICE_ERROR      Cannot access the file.   @retval EFI_INVALID_PARAMETER FileHandle is NULL. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleSetSize
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|FileHandle
parameter_list|,
name|IN
name|UINT64
name|Size
parameter_list|)
block|{
name|EFI_FILE_INFO
modifier|*
name|FileInfo
decl_stmt|;
name|EFI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
name|FileHandle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
comment|//
comment|// get the FileInfo structure
comment|//
name|FileInfo
operator|=
name|FileHandleGetInfo
argument_list|(
name|FileHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileInfo
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_DEVICE_ERROR
operator|)
return|;
block|}
comment|//
comment|// Assign the FileSize pointer to the new value
comment|//
name|FileInfo
operator|->
name|FileSize
operator|=
name|Size
expr_stmt|;
name|Status
operator|=
name|FileHandleSetInfo
argument_list|(
name|FileHandle
argument_list|,
name|FileInfo
argument_list|)
expr_stmt|;
comment|//
comment|// free the FileInfo memory
comment|//
name|FreePool
argument_list|(
name|FileInfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Safely append (on the left) with automatic string resizing given length of Destination and   desired length of copy from Source.    append the first D characters of Source to the end of Destination, where D is   the lesser of Count and the StrLen() of Source. If appending those D characters   will fit within Destination (whose Size is given as CurrentSize) and   still leave room for a NULL terminator, then those characters are appended,   starting at the original terminating NULL of Destination, and a new terminating   NULL is appended.    If appending D characters onto Destination will result in a overflow of the size   given in CurrentSize the string will be grown such that the copy can be performed   and CurrentSize will be updated to the new size.    If Source is NULL, there is nothing to append, just return the current buffer in   Destination.    if Destination is NULL, then return error   if Destination's current length (including NULL terminator) is already more then   CurrentSize, then ASSERT()    @param[in, out] Destination   The String to append onto   @param[in, out] CurrentSize   on call the number of bytes in Destination.  On                                 return possibly the new size (still in bytes).  if NULL                                 then allocate whatever is needed.   @param[in]      Source        The String to append from   @param[in]      Count         Maximum number of characters to append.  if 0 then                                 all are appended.    @return Destination           return the resultant string. **/
end_comment

begin_function
name|CHAR16
modifier|*
name|EFIAPI
name|StrnCatGrowLeft
parameter_list|(
name|IN
name|OUT
name|CHAR16
modifier|*
modifier|*
name|Destination
parameter_list|,
name|IN
name|OUT
name|UINTN
modifier|*
name|CurrentSize
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|Source
parameter_list|,
name|IN
name|UINTN
name|Count
parameter_list|)
block|{
name|UINTN
name|DestinationStartSize
decl_stmt|;
name|UINTN
name|NewSize
decl_stmt|;
name|UINTN
name|CopySize
decl_stmt|;
if|if
condition|(
name|Destination
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|//
comment|// If there's nothing to do then just return Destination
comment|//
if|if
condition|(
name|Source
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|*
name|Destination
operator|)
return|;
block|}
comment|//
comment|// allow for NULL pointers address as Destination
comment|//
if|if
condition|(
operator|*
name|Destination
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|CurrentSize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|DestinationStartSize
operator|=
name|StrSize
argument_list|(
operator|*
name|Destination
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DestinationStartSize
operator|<=
operator|*
name|CurrentSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DestinationStartSize
operator|=
literal|0
expr_stmt|;
comment|//    ASSERT(*CurrentSize == 0);
block|}
comment|//
comment|// Append all of Source?
comment|//
if|if
condition|(
name|Count
operator|==
literal|0
condition|)
block|{
name|Count
operator|=
name|StrSize
argument_list|(
name|Source
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Test and grow if required
comment|//
if|if
condition|(
name|CurrentSize
operator|!=
name|NULL
condition|)
block|{
name|NewSize
operator|=
operator|*
name|CurrentSize
expr_stmt|;
while|while
condition|(
name|NewSize
operator|<
operator|(
name|DestinationStartSize
operator|+
name|Count
operator|)
condition|)
block|{
name|NewSize
operator|+=
literal|2
operator|*
name|Count
expr_stmt|;
block|}
operator|*
name|Destination
operator|=
name|ReallocatePool
argument_list|(
operator|*
name|CurrentSize
argument_list|,
name|NewSize
argument_list|,
operator|*
name|Destination
argument_list|)
expr_stmt|;
operator|*
name|CurrentSize
operator|=
name|NewSize
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Destination
operator|=
name|AllocateZeroPool
argument_list|(
name|Count
operator|+
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|Destination
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|CopySize
operator|=
name|StrSize
argument_list|(
operator|*
name|Destination
argument_list|)
expr_stmt|;
name|CopyMem
argument_list|(
operator|(
operator|*
name|Destination
operator|)
operator|+
operator|(
operator|(
name|Count
operator|-
literal|2
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
operator|)
argument_list|,
operator|*
name|Destination
argument_list|,
name|CopySize
argument_list|)
expr_stmt|;
name|CopyMem
argument_list|(
operator|*
name|Destination
argument_list|,
name|Source
argument_list|,
name|Count
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|Destination
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Function to get a full filename given a EFI_FILE_HANDLE somewhere lower on the   directory 'stack'. If the file is a directory, then append the '\' char at the    end of name string. If it's not a directory, then the last '\' should not be    added.    if Handle is NULL, return EFI_INVALID_PARAMETER    @param[in] Handle             Handle to the Directory or File to create path to.   @param[out] FullFileName      pointer to pointer to generated full file name.  It                                 is the responsibility of the caller to free this memory                                 with a call to FreePool().   @retval EFI_SUCCESS           the operation was sucessful and the FullFileName is valid.   @retval EFI_INVALID_PARAMETER Handle was NULL.   @retval EFI_INVALID_PARAMETER FullFileName was NULL.   @retval EFI_OUT_OF_RESOURCES  a memory allocation failed. **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleGetFileName
parameter_list|(
name|IN
name|CONST
name|EFI_FILE_HANDLE
name|Handle
parameter_list|,
name|OUT
name|CHAR16
modifier|*
modifier|*
name|FullFileName
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|EFI_FILE_HANDLE
name|CurrentHandle
decl_stmt|;
name|EFI_FILE_HANDLE
name|NextHigherHandle
decl_stmt|;
name|EFI_FILE_INFO
modifier|*
name|FileInfo
decl_stmt|;
name|Size
operator|=
literal|0
expr_stmt|;
comment|//
comment|// Check our parameters
comment|//
if|if
condition|(
name|FullFileName
operator|==
name|NULL
operator|||
name|Handle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
operator|*
name|FullFileName
operator|=
name|NULL
expr_stmt|;
name|CurrentHandle
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|Handle
operator|->
name|Open
argument_list|(
name|Handle
argument_list|,
operator|&
name|CurrentHandle
argument_list|,
literal|L"."
argument_list|,
name|EFI_FILE_MODE_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|//
comment|// Reverse out the current directory on the device
comment|//
for|for
control|(
init|;
condition|;
control|)
block|{
name|FileInfo
operator|=
name|FileHandleGetInfo
argument_list|(
name|CurrentHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileInfo
operator|==
name|NULL
condition|)
block|{
name|Status
operator|=
name|EFI_OUT_OF_RESOURCES
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|//
comment|// We got info... do we have a name? if yes precede the current path with it...
comment|//
if|if
condition|(
name|StrLen
argument_list|(
name|FileInfo
operator|->
name|FileName
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|FullFileName
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|*
name|FullFileName
operator|==
name|NULL
operator|&&
name|Size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|FullFileName
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|*
name|FullFileName
operator|=
name|StrnCatGrowLeft
argument_list|(
name|FullFileName
argument_list|,
operator|&
name|Size
argument_list|,
literal|L"\\"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|FreePool
argument_list|(
name|FileInfo
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|FullFileName
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
operator|*
name|FullFileName
operator|==
name|NULL
operator|&&
name|Size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|FullFileName
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|*
name|FullFileName
operator|=
name|StrnCatGrowLeft
argument_list|(
name|FullFileName
argument_list|,
operator|&
name|Size
argument_list|,
literal|L"\\"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
operator|*
name|FullFileName
operator|==
name|NULL
operator|&&
name|Size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|FullFileName
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|*
name|FullFileName
operator|=
name|StrnCatGrowLeft
argument_list|(
name|FullFileName
argument_list|,
operator|&
name|Size
argument_list|,
name|FileInfo
operator|->
name|FileName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|FullFileName
operator|=
name|StrnCatGrowLeft
argument_list|(
name|FullFileName
argument_list|,
operator|&
name|Size
argument_list|,
literal|L"\\"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FreePool
argument_list|(
name|FileInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Move to the parent directory
comment|//
name|Status
operator|=
name|CurrentHandle
operator|->
name|Open
argument_list|(
name|CurrentHandle
argument_list|,
operator|&
name|NextHigherHandle
argument_list|,
literal|L".."
argument_list|,
name|EFI_FILE_MODE_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
break|break;
block|}
name|FileHandleClose
argument_list|(
name|CurrentHandle
argument_list|)
expr_stmt|;
name|CurrentHandle
operator|=
name|NextHigherHandle
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Status
operator|==
name|EFI_NOT_FOUND
condition|)
block|{
name|Status
operator|=
name|EFI_SUCCESS
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|*
name|FullFileName
operator|==
name|NULL
operator|&&
name|Size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|FullFileName
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|*
name|FullFileName
operator|=
name|StrnCatGrowLeft
argument_list|(
name|FullFileName
argument_list|,
operator|&
name|Size
argument_list|,
literal|L"\\"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|FullFileName
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|FullFileName
operator|)
index|[
name|StrLen
argument_list|(
operator|*
name|FullFileName
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|StrLen
argument_list|(
operator|*
name|FullFileName
argument_list|)
operator|>
literal|1
operator|&&
name|FileHandleIsDirectory
argument_list|(
name|Handle
argument_list|)
operator|==
name|EFI_NOT_FOUND
condition|)
block|{
operator|(
operator|*
name|FullFileName
operator|)
index|[
name|StrLen
argument_list|(
operator|*
name|FullFileName
argument_list|)
operator|-
literal|1
index|]
operator|=
name|CHAR_NULL
expr_stmt|;
block|}
if|if
condition|(
name|CurrentHandle
operator|!=
name|NULL
condition|)
block|{
name|CurrentHandle
operator|->
name|Close
argument_list|(
name|CurrentHandle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|&&
operator|*
name|FullFileName
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
operator|*
name|FullFileName
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Function to read a single line from a file. The \n is not included in the returned   buffer.  The returned buffer must be callee freed.    If the position upon start is 0, then the Ascii Boolean will be set.  This should be   maintained and not changed for all operations with the same file.    @param[in]       Handle        FileHandle to read from.   @param[in, out]  Ascii         Boolean value for indicating whether the file is Ascii (TRUE) or UCS2 (FALSE);    @return                       The line of text from the file.    @sa FileHandleReadLine **/
end_comment

begin_function
name|CHAR16
modifier|*
name|EFIAPI
name|FileHandleReturnLine
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|Handle
parameter_list|,
name|IN
name|OUT
name|BOOLEAN
modifier|*
name|Ascii
parameter_list|)
block|{
name|CHAR16
modifier|*
name|RetVal
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|EFI_STATUS
name|Status
decl_stmt|;
name|Size
operator|=
literal|0
expr_stmt|;
name|RetVal
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|FileHandleReadLine
argument_list|(
name|Handle
argument_list|,
name|RetVal
argument_list|,
operator|&
name|Size
argument_list|,
name|FALSE
argument_list|,
name|Ascii
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|==
name|EFI_BUFFER_TOO_SMALL
condition|)
block|{
name|RetVal
operator|=
name|AllocateZeroPool
argument_list|(
name|Size
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleReadLine
argument_list|(
name|Handle
argument_list|,
name|RetVal
argument_list|,
operator|&
name|Size
argument_list|,
name|FALSE
argument_list|,
name|Ascii
argument_list|)
expr_stmt|;
block|}
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|&&
operator|(
name|RetVal
operator|!=
name|NULL
operator|)
condition|)
block|{
name|FreePool
argument_list|(
name|RetVal
argument_list|)
expr_stmt|;
name|RetVal
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|RetVal
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Function to read a single line (up to but not including the \n) from a file.    If the position upon start is 0, then the Ascii Boolean will be set.  This should be   maintained and not changed for all operations with the same file.   The function will not return the \r and \n character in buffer. When an empty line is   read a CHAR_NULL character will be returned in buffer.    @param[in]       Handle        FileHandle to read from.   @param[in, out]  Buffer        The pointer to buffer to read into.   @param[in, out]  Size          The pointer to number of bytes in Buffer.   @param[in]       Truncate      If the buffer is large enough, this has no effect.                                  If the buffer is is too small and Truncate is TRUE,                                  the line will be truncated.                                  If the buffer is is too small and Truncate is FALSE,                                  then no read will occur.    @param[in, out]  Ascii         Boolean value for indicating whether the file is                                  Ascii (TRUE) or UCS2 (FALSE).    @retval EFI_SUCCESS           The operation was successful.  The line is stored in                                 Buffer.   @retval EFI_INVALID_PARAMETER Handle was NULL.   @retval EFI_INVALID_PARAMETER Size was NULL.   @retval EFI_BUFFER_TOO_SMALL  Size was not large enough to store the line.                                 Size was updated to the minimum space required.   @sa FileHandleRead **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleReadLine
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|Handle
parameter_list|,
name|IN
name|OUT
name|CHAR16
modifier|*
name|Buffer
parameter_list|,
name|IN
name|OUT
name|UINTN
modifier|*
name|Size
parameter_list|,
name|IN
name|BOOLEAN
name|Truncate
parameter_list|,
name|IN
name|OUT
name|BOOLEAN
modifier|*
name|Ascii
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|CHAR16
name|CharBuffer
decl_stmt|;
name|UINT64
name|FileSize
decl_stmt|;
name|UINTN
name|CharSize
decl_stmt|;
name|UINTN
name|CountSoFar
decl_stmt|;
name|UINTN
name|CrCount
decl_stmt|;
name|UINT64
name|OriginalFilePosition
decl_stmt|;
if|if
condition|(
name|Handle
operator|==
name|NULL
operator|||
name|Size
operator|==
name|NULL
operator|||
operator|(
name|Buffer
operator|==
name|NULL
operator|&&
operator|*
name|Size
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
if|if
condition|(
name|Buffer
operator|!=
name|NULL
operator|&&
operator|*
name|Size
operator|!=
literal|0
condition|)
block|{
operator|*
name|Buffer
operator|=
name|CHAR_NULL
expr_stmt|;
block|}
name|Status
operator|=
name|FileHandleGetSize
argument_list|(
name|Handle
argument_list|,
operator|&
name|FileSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
elseif|else
if|if
condition|(
name|FileSize
operator|==
literal|0
condition|)
block|{
operator|*
name|Ascii
operator|=
name|TRUE
expr_stmt|;
return|return
name|EFI_SUCCESS
return|;
block|}
name|FileHandleGetPosition
argument_list|(
name|Handle
argument_list|,
operator|&
name|OriginalFilePosition
argument_list|)
expr_stmt|;
if|if
condition|(
name|OriginalFilePosition
operator|==
literal|0
condition|)
block|{
name|CharSize
operator|=
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleRead
argument_list|(
name|Handle
argument_list|,
operator|&
name|CharSize
argument_list|,
operator|&
name|CharBuffer
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
if|if
condition|(
name|CharBuffer
operator|==
name|gUnicodeFileTag
condition|)
block|{
operator|*
name|Ascii
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Ascii
operator|=
name|TRUE
expr_stmt|;
name|FileHandleSetPosition
argument_list|(
name|Handle
argument_list|,
name|OriginalFilePosition
argument_list|)
expr_stmt|;
block|}
block|}
name|CrCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|CountSoFar
operator|=
literal|0
init|;
condition|;
name|CountSoFar
operator|++
control|)
block|{
name|CharBuffer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|Ascii
condition|)
block|{
name|CharSize
operator|=
sizeof|sizeof
argument_list|(
name|CHAR8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CharSize
operator|=
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
expr_stmt|;
block|}
name|Status
operator|=
name|FileHandleRead
argument_list|(
name|Handle
argument_list|,
operator|&
name|CharSize
argument_list|,
operator|&
name|CharBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
operator|||
name|CharSize
operator|==
literal|0
operator|||
operator|(
name|CharBuffer
operator|==
literal|L'
expr|\n'
operator|&&
operator|!
operator|(
operator|*
name|Ascii
operator|)
operator|)
operator|||
operator|(
name|CharBuffer
operator|==
literal|'\n'
operator|&&
operator|*
name|Ascii
operator|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|CharBuffer
operator|==
literal|L'
expr|\r'
operator|&&
operator|!
operator|(
operator|*
name|Ascii
operator|)
operator|)
operator|||
operator|(
name|CharBuffer
operator|==
literal|'\r'
operator|&&
operator|*
name|Ascii
operator|)
condition|)
block|{
name|CrCount
operator|++
expr_stmt|;
continue|continue;
block|}
comment|//
comment|// if we have space save it...
comment|//
if|if
condition|(
operator|(
name|CountSoFar
operator|+
literal|1
operator|-
name|CrCount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
operator|<
operator|*
name|Size
condition|)
block|{
name|ASSERT
argument_list|(
name|Buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CHAR16
operator|*
operator|)
name|Buffer
operator|)
index|[
name|CountSoFar
operator|-
name|CrCount
index|]
operator|=
name|CharBuffer
expr_stmt|;
operator|(
operator|(
name|CHAR16
operator|*
operator|)
name|Buffer
operator|)
index|[
name|CountSoFar
operator|+
literal|1
operator|-
name|CrCount
index|]
operator|=
name|CHAR_NULL
expr_stmt|;
block|}
block|}
comment|//
comment|// if we ran out of space tell when...
comment|//
if|if
condition|(
operator|(
name|CountSoFar
operator|+
literal|1
operator|-
name|CrCount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
operator|>
operator|*
name|Size
condition|)
block|{
operator|*
name|Size
operator|=
operator|(
name|CountSoFar
operator|+
literal|1
operator|-
name|CrCount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Truncate
condition|)
block|{
if|if
condition|(
name|Buffer
operator|!=
name|NULL
operator|&&
operator|*
name|Size
operator|!=
literal|0
condition|)
block|{
name|ZeroMem
argument_list|(
name|Buffer
argument_list|,
operator|*
name|Size
argument_list|)
expr_stmt|;
block|}
name|FileHandleSetPosition
argument_list|(
name|Handle
argument_list|,
name|OriginalFilePosition
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFI_BUFFER_TOO_SMALL
operator|)
return|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
operator|(
name|DEBUG_WARN
operator|,
literal|"The line was truncated in FileHandleReadLine"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFI_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Function to write a line of text to a file.      If the file is a Unicode file (with UNICODE file tag) then write the unicode    text.   If the file is an ASCII file then write the ASCII text.   If the size of file is zero (without file tag at the beginning) then write    ASCII text as default.    @param[in]     Handle         FileHandle to write to.   @param[in]     Buffer         Buffer to write, if NULL the function will                                 take no action and return EFI_SUCCESS.    @retval  EFI_SUCCESS            The data was written.                                   Buffer is NULL.   @retval  EFI_INVALID_PARAMETER  Handle is NULL.   @retval  EFI_OUT_OF_RESOURCES   Unable to allocate temporary space for ASCII                                    string due to out of resources.    @sa FileHandleWrite **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandleWriteLine
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|Handle
parameter_list|,
name|IN
name|CHAR16
modifier|*
name|Buffer
parameter_list|)
block|{
name|EFI_STATUS
name|Status
decl_stmt|;
name|CHAR16
name|CharBuffer
decl_stmt|;
name|UINTN
name|Size
decl_stmt|;
name|UINTN
name|Index
decl_stmt|;
name|UINTN
name|CharSize
decl_stmt|;
name|UINT64
name|FileSize
decl_stmt|;
name|UINT64
name|OriginalFilePosition
decl_stmt|;
name|BOOLEAN
name|Ascii
decl_stmt|;
name|CHAR8
modifier|*
name|AsciiBuffer
decl_stmt|;
if|if
condition|(
name|Buffer
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|Handle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_INVALID_PARAMETER
operator|)
return|;
block|}
name|Ascii
operator|=
name|FALSE
expr_stmt|;
name|AsciiBuffer
operator|=
name|NULL
expr_stmt|;
name|Status
operator|=
name|FileHandleGetPosition
argument_list|(
name|Handle
argument_list|,
operator|&
name|OriginalFilePosition
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
name|Status
operator|=
name|FileHandleSetPosition
argument_list|(
name|Handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
name|Status
operator|=
name|FileHandleGetSize
argument_list|(
name|Handle
argument_list|,
operator|&
name|FileSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
if|if
condition|(
name|FileSize
operator|==
literal|0
condition|)
block|{
name|Ascii
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|CharSize
operator|=
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleRead
argument_list|(
name|Handle
argument_list|,
operator|&
name|CharSize
argument_list|,
operator|&
name|CharBuffer
argument_list|)
expr_stmt|;
name|ASSERT_EFI_ERROR
argument_list|(
name|Status
argument_list|)
expr_stmt|;
if|if
condition|(
name|CharBuffer
operator|==
name|gUnicodeFileTag
condition|)
block|{
name|Ascii
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|Ascii
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|Status
operator|=
name|FileHandleSetPosition
argument_list|(
name|Handle
argument_list|,
name|OriginalFilePosition
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
if|if
condition|(
name|Ascii
condition|)
block|{
name|Size
operator|=
operator|(
name|StrSize
argument_list|(
name|Buffer
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR8
argument_list|)
expr_stmt|;
name|AsciiBuffer
operator|=
operator|(
name|CHAR8
operator|*
operator|)
name|AllocateZeroPool
argument_list|(
name|Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|AsciiBuffer
operator|==
name|NULL
condition|)
block|{
return|return
name|EFI_OUT_OF_RESOURCES
return|;
block|}
name|UnicodeStrToAsciiStrS
argument_list|(
name|Buffer
argument_list|,
name|AsciiBuffer
argument_list|,
name|Size
argument_list|)
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|Size
condition|;
name|Index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|AsciiBuffer
index|[
name|Index
index|]
operator|&
name|BIT7
operator|)
operator|!=
literal|0
condition|)
block|{
name|FreePool
argument_list|(
name|AsciiBuffer
argument_list|)
expr_stmt|;
return|return
name|EFI_INVALID_PARAMETER
return|;
block|}
block|}
name|Size
operator|=
name|AsciiStrSize
argument_list|(
name|AsciiBuffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|CHAR8
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleWrite
argument_list|(
name|Handle
argument_list|,
operator|&
name|Size
argument_list|,
name|AsciiBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|FreePool
argument_list|(
name|AsciiBuffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|Size
operator|=
name|AsciiStrSize
argument_list|(
literal|"\r\n"
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|CHAR8
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleWrite
argument_list|(
name|Handle
argument_list|,
operator|&
name|Size
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|OriginalFilePosition
operator|==
literal|0
condition|)
block|{
name|Status
operator|=
name|FileHandleSetPosition
argument_list|(
name|Handle
argument_list|,
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
name|Status
return|;
block|}
block|}
name|Size
operator|=
name|StrSize
argument_list|(
name|Buffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleWrite
argument_list|(
name|Handle
argument_list|,
operator|&
name|Size
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFI_ERROR
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|Size
operator|=
name|StrSize
argument_list|(
literal|L"\r\n"
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|CHAR16
argument_list|)
expr_stmt|;
name|Status
operator|=
name|FileHandleWrite
argument_list|(
name|Handle
argument_list|,
operator|&
name|Size
argument_list|,
literal|L"\r\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AsciiBuffer
operator|!=
name|NULL
condition|)
block|{
name|FreePool
argument_list|(
name|AsciiBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|Status
return|;
block|}
end_function

begin_comment
comment|/**   function to take a formatted argument and print it to a file.    @param[in] Handle   the file handle for the file to write to   @param[in] Format   the format argument (see printlib for format specifier)   @param[in] ...      the variable arguments for the format    @retval EFI_SUCCESS the operation was successful   @return other       a return value from FileHandleWriteLine    @sa FileHandleWriteLine **/
end_comment

begin_function
name|EFI_STATUS
name|EFIAPI
name|FileHandlePrintLine
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|Handle
parameter_list|,
name|IN
name|CONST
name|CHAR16
modifier|*
name|Format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|VA_LIST
name|Marker
decl_stmt|;
name|CHAR16
modifier|*
name|Buffer
decl_stmt|;
name|EFI_STATUS
name|Status
decl_stmt|;
comment|//
comment|// Get a buffer to print into
comment|//
name|Buffer
operator|=
name|AllocateZeroPool
argument_list|(
name|PcdGet16
argument_list|(
name|PcdUefiFileHandleLibPrintBufferSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Buffer
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EFI_OUT_OF_RESOURCES
operator|)
return|;
block|}
comment|//
comment|// Print into our buffer
comment|//
name|VA_START
argument_list|(
name|Marker
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|UnicodeVSPrint
argument_list|(
name|Buffer
argument_list|,
name|PcdGet16
argument_list|(
name|PcdUefiFileHandleLibPrintBufferSize
argument_list|)
argument_list|,
name|Format
argument_list|,
name|Marker
argument_list|)
expr_stmt|;
name|VA_END
argument_list|(
name|Marker
argument_list|)
expr_stmt|;
comment|//
comment|// Print buffer into file
comment|//
name|Status
operator|=
name|FileHandleWriteLine
argument_list|(
name|Handle
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
comment|//
comment|// Cleanup and return
comment|//
name|FreePool
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   Function to determine if a FILE_HANDLE is at the end of the file.    This will NOT work on directories.    If Handle is NULL, then return False.    @param[in] Handle     the file handle    @retval TRUE          the position is at the end of the file   @retval FALSE         the position is not at the end of the file **/
end_comment

begin_function
name|BOOLEAN
name|EFIAPI
name|FileHandleEof
parameter_list|(
name|IN
name|EFI_FILE_HANDLE
name|Handle
parameter_list|)
block|{
name|EFI_FILE_INFO
modifier|*
name|Info
decl_stmt|;
name|UINT64
name|Pos
decl_stmt|;
name|BOOLEAN
name|RetVal
decl_stmt|;
if|if
condition|(
name|Handle
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|FileHandleGetPosition
argument_list|(
name|Handle
argument_list|,
operator|&
name|Pos
argument_list|)
expr_stmt|;
name|Info
operator|=
name|FileHandleGetInfo
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|Info
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|FileHandleSetPosition
argument_list|(
name|Handle
argument_list|,
name|Pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pos
operator|==
name|Info
operator|->
name|FileSize
condition|)
block|{
name|RetVal
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|RetVal
operator|=
name|FALSE
expr_stmt|;
block|}
name|FreePool
argument_list|(
name|Info
argument_list|)
expr_stmt|;
return|return
operator|(
name|RetVal
operator|)
return|;
block|}
end_function

end_unit

