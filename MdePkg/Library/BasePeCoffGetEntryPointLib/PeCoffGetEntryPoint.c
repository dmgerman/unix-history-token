begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/** @file   Provides the services to get the entry point to a PE/COFF image that has either been    loaded into memory or is executing at it's linked address.    Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>   Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>   This program and the accompanying materials   are licensed and made available under the terms and conditions of the BSD License   which accompanies this distribution.  The full text of the license may be found at   http://opensource.org/licenses/bsd-license.php.    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.  **/
end_comment

begin_include
include|#
directive|include
file|<Base.h>
end_include

begin_include
include|#
directive|include
file|<Library/PeCoffGetEntryPointLib.h>
end_include

begin_include
include|#
directive|include
file|<Library/DebugLib.h>
end_include

begin_include
include|#
directive|include
file|<IndustryStandard/PeImage.h>
end_include

begin_comment
comment|/**   Retrieves and returns a pointer to the entry point to a PE/COFF image that has been loaded   into system memory with the PE/COFF Loader Library functions.    Retrieves the entry point to the PE/COFF image specified by Pe32Data and returns this entry   point in EntryPoint.  If the entry point could not be retrieved from the PE/COFF image, then   return RETURN_INVALID_PARAMETER.  Otherwise return RETURN_SUCCESS.   If Pe32Data is NULL, then ASSERT().   If EntryPoint is NULL, then ASSERT().    @param  Pe32Data                  The pointer to the PE/COFF image that is loaded in system memory.   @param  EntryPoint                The pointer to entry point to the PE/COFF image to return.    @retval RETURN_SUCCESS            EntryPoint was returned.   @retval RETURN_INVALID_PARAMETER  The entry point could not be found in the PE/COFF image.  **/
end_comment

begin_function
name|RETURN_STATUS
name|EFIAPI
name|PeCoffLoaderGetEntryPoint
parameter_list|(
name|IN
name|VOID
modifier|*
name|Pe32Data
parameter_list|,
name|OUT
name|VOID
modifier|*
modifier|*
name|EntryPoint
parameter_list|)
block|{
name|EFI_IMAGE_DOS_HEADER
modifier|*
name|DosHdr
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|ASSERT
argument_list|(
name|Pe32Data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|EntryPoint
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DosHdr
operator|=
operator|(
name|EFI_IMAGE_DOS_HEADER
operator|*
operator|)
name|Pe32Data
expr_stmt|;
if|if
condition|(
name|DosHdr
operator|->
name|e_magic
operator|==
name|EFI_IMAGE_DOS_SIGNATURE
condition|)
block|{
comment|//
comment|// DOS image header is present, so read the PE header after the DOS image header.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
call|(
name|UINTN
call|)
argument_list|(
operator|(
name|DosHdr
operator|->
name|e_lfanew
operator|)
operator|&
literal|0x0ffff
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// DOS image header is not present, so PE header is at the image base.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
name|Pe32Data
expr_stmt|;
block|}
comment|//
comment|// Calculate the entry point relative to the start of the image.
comment|// AddressOfEntryPoint is common for PE32& PE32+
comment|//
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|Signature
operator|==
name|EFI_TE_IMAGE_HEADER_SIGNATURE
condition|)
block|{
operator|*
name|EntryPoint
operator|=
operator|(
name|VOID
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
call|(
name|UINTN
call|)
argument_list|(
name|Hdr
operator|.
name|Te
operator|->
name|AddressOfEntryPoint
operator|&
literal|0x0ffffffff
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
operator|-
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
operator|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|Signature
operator|==
name|EFI_IMAGE_NT_SIGNATURE
condition|)
block|{
operator|*
name|EntryPoint
operator|=
operator|(
name|VOID
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
call|(
name|UINTN
call|)
argument_list|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|AddressOfEntryPoint
operator|&
literal|0x0ffffffff
argument_list|)
operator|)
expr_stmt|;
return|return
name|RETURN_SUCCESS
return|;
block|}
return|return
name|RETURN_UNSUPPORTED
return|;
block|}
end_function

begin_comment
comment|/**   Returns the machine type of a PE/COFF image.    Returns the machine type from the PE/COFF image specified by Pe32Data.   If Pe32Data is NULL, then ASSERT().    @param  Pe32Data   The pointer to the PE/COFF image that is loaded in system                      memory.    @return Machine type or zero if not a valid image.  **/
end_comment

begin_function
name|UINT16
name|EFIAPI
name|PeCoffLoaderGetMachineType
parameter_list|(
name|IN
name|VOID
modifier|*
name|Pe32Data
parameter_list|)
block|{
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|EFI_IMAGE_DOS_HEADER
modifier|*
name|DosHdr
decl_stmt|;
name|ASSERT
argument_list|(
name|Pe32Data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DosHdr
operator|=
operator|(
name|EFI_IMAGE_DOS_HEADER
operator|*
operator|)
name|Pe32Data
expr_stmt|;
if|if
condition|(
name|DosHdr
operator|->
name|e_magic
operator|==
name|EFI_IMAGE_DOS_SIGNATURE
condition|)
block|{
comment|//
comment|// DOS image header is present, so read the PE header after the DOS image header.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
call|(
name|UINTN
call|)
argument_list|(
operator|(
name|DosHdr
operator|->
name|e_lfanew
operator|)
operator|&
literal|0x0ffff
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// DOS image header is not present, so PE header is at the image base.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
name|Pe32Data
expr_stmt|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|Signature
operator|==
name|EFI_TE_IMAGE_HEADER_SIGNATURE
condition|)
block|{
return|return
name|Hdr
operator|.
name|Te
operator|->
name|Machine
return|;
block|}
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|Signature
operator|==
name|EFI_IMAGE_NT_SIGNATURE
condition|)
block|{
return|return
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|Machine
return|;
block|}
return|return
literal|0x0000
return|;
block|}
end_function

begin_comment
comment|/**   Returns a pointer to the PDB file name for a PE/COFF image that has been   loaded into system memory with the PE/COFF Loader Library functions.     Returns the PDB file name for the PE/COFF image specified by Pe32Data.  If   the PE/COFF image specified by Pe32Data is not a valid, then NULL is   returned.  If the PE/COFF image specified by Pe32Data does not contain a   debug directory entry, then NULL is returned.  If the debug directory entry   in the PE/COFF image specified by Pe32Data does not contain a PDB file name,   then NULL is returned.   If Pe32Data is NULL, then ASSERT().    @param  Pe32Data   The pointer to the PE/COFF image that is loaded in system                      memory.    @return The PDB file name for the PE/COFF image specified by Pe32Data or NULL           if it cannot be retrieved.  **/
end_comment

begin_function
name|VOID
modifier|*
name|EFIAPI
name|PeCoffLoaderGetPdbPointer
parameter_list|(
name|IN
name|VOID
modifier|*
name|Pe32Data
parameter_list|)
block|{
name|EFI_IMAGE_DOS_HEADER
modifier|*
name|DosHdr
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|EFI_IMAGE_DATA_DIRECTORY
modifier|*
name|DirectoryEntry
decl_stmt|;
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
modifier|*
name|DebugEntry
decl_stmt|;
name|UINTN
name|DirCount
decl_stmt|;
name|VOID
modifier|*
name|CodeViewEntryPointer
decl_stmt|;
name|INTN
name|TEImageAdjust
decl_stmt|;
name|UINT32
name|NumberOfRvaAndSizes
decl_stmt|;
name|UINT16
name|Magic
decl_stmt|;
name|ASSERT
argument_list|(
name|Pe32Data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TEImageAdjust
operator|=
literal|0
expr_stmt|;
name|DirectoryEntry
operator|=
name|NULL
expr_stmt|;
name|DebugEntry
operator|=
name|NULL
expr_stmt|;
name|NumberOfRvaAndSizes
operator|=
literal|0
expr_stmt|;
name|DosHdr
operator|=
operator|(
name|EFI_IMAGE_DOS_HEADER
operator|*
operator|)
name|Pe32Data
expr_stmt|;
if|if
condition|(
name|DosHdr
operator|->
name|e_magic
operator|==
name|EFI_IMAGE_DOS_SIGNATURE
condition|)
block|{
comment|//
comment|// DOS image header is present, so read the PE header after the DOS image header.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
call|(
name|UINTN
call|)
argument_list|(
operator|(
name|DosHdr
operator|->
name|e_lfanew
operator|)
operator|&
literal|0x0ffff
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// DOS image header is not present, so PE header is at the image base.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
name|Pe32Data
expr_stmt|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|Signature
operator|==
name|EFI_TE_IMAGE_HEADER_SIGNATURE
condition|)
block|{
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
name|EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
operator|.
name|VirtualAddress
operator|!=
literal|0
condition|)
block|{
name|DirectoryEntry
operator|=
operator|&
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
name|EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
expr_stmt|;
name|TEImageAdjust
operator|=
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
operator|-
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
expr_stmt|;
name|DebugEntry
operator|=
operator|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|+
name|Hdr
operator|.
name|Te
operator|->
name|DataDirectory
index|[
name|EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
operator|.
name|VirtualAddress
operator|+
name|TEImageAdjust
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|Signature
operator|==
name|EFI_IMAGE_NT_SIGNATURE
condition|)
block|{
comment|//
comment|// NOTE: We use Machine field to identify PE32/PE32+, instead of Magic.
comment|//       It is due to backward-compatibility, for some system might
comment|//       generate PE32+ image with PE32 Magic.
comment|//
switch|switch
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|FileHeader
operator|.
name|Machine
condition|)
block|{
case|case
name|IMAGE_FILE_MACHINE_I386
case|:
comment|//
comment|// Assume PE32 image with IA32 Machine field.
comment|//
name|Magic
operator|=
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
expr_stmt|;
break|break;
case|case
name|IMAGE_FILE_MACHINE_X64
case|:
case|case
name|IMAGE_FILE_MACHINE_IA64
case|:
comment|//
comment|// Assume PE32+ image with x64 or IA64 Machine field
comment|//
name|Magic
operator|=
name|EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC
expr_stmt|;
break|break;
default|default:
comment|//
comment|// For unknow Machine field, use Magic in optional Header
comment|//
name|Magic
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|Magic
expr_stmt|;
block|}
if|if
condition|(
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32 offset get Debug Directory Entry
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
operator|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
operator|)
expr_stmt|;
name|DebugEntry
operator|=
operator|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
name|DirectoryEntry
operator|->
name|VirtualAddress
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|Magic
operator|==
name|EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC
condition|)
block|{
comment|//
comment|// Use PE32+ offset get Debug Directory Entry
comment|//
name|NumberOfRvaAndSizes
operator|=
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|NumberOfRvaAndSizes
expr_stmt|;
name|DirectoryEntry
operator|=
operator|(
name|EFI_IMAGE_DATA_DIRECTORY
operator|*
operator|)
operator|&
operator|(
name|Hdr
operator|.
name|Pe32Plus
operator|->
name|OptionalHeader
operator|.
name|DataDirectory
index|[
name|EFI_IMAGE_DIRECTORY_ENTRY_DEBUG
index|]
operator|)
expr_stmt|;
name|DebugEntry
operator|=
operator|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
name|DirectoryEntry
operator|->
name|VirtualAddress
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|NumberOfRvaAndSizes
operator|<=
name|EFI_IMAGE_DIRECTORY_ENTRY_DEBUG
condition|)
block|{
name|DirectoryEntry
operator|=
name|NULL
expr_stmt|;
name|DebugEntry
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|DebugEntry
operator|==
name|NULL
operator|||
name|DirectoryEntry
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|//
comment|// Scan the directory to find the debug entry.
comment|//
for|for
control|(
name|DirCount
operator|=
literal|0
init|;
name|DirCount
operator|<
name|DirectoryEntry
operator|->
name|Size
condition|;
name|DirCount
operator|+=
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_DIRECTORY_ENTRY
argument_list|)
operator|,
name|DebugEntry
operator|++
control|)
block|{
if|if
condition|(
name|DebugEntry
operator|->
name|Type
operator|==
name|EFI_IMAGE_DEBUG_TYPE_CODEVIEW
condition|)
block|{
if|if
condition|(
name|DebugEntry
operator|->
name|SizeOfData
operator|>
literal|0
condition|)
block|{
name|CodeViewEntryPointer
operator|=
operator|(
name|VOID
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|DebugEntry
operator|->
name|RVA
operator|+
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|)
operator|+
operator|(
name|UINTN
operator|)
name|TEImageAdjust
operator|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|CodeViewEntryPointer
condition|)
block|{
case|case
name|CODEVIEW_SIGNATURE_NB10
case|:
return|return
operator|(
name|VOID
operator|*
operator|)
operator|(
operator|(
name|CHAR8
operator|*
operator|)
name|CodeViewEntryPointer
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY
argument_list|)
operator|)
return|;
case|case
name|CODEVIEW_SIGNATURE_RSDS
case|:
return|return
operator|(
name|VOID
operator|*
operator|)
operator|(
operator|(
name|CHAR8
operator|*
operator|)
name|CodeViewEntryPointer
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY
argument_list|)
operator|)
return|;
case|case
name|CODEVIEW_SIGNATURE_MTOC
case|:
return|return
operator|(
name|VOID
operator|*
operator|)
operator|(
operator|(
name|CHAR8
operator|*
operator|)
name|CodeViewEntryPointer
operator|+
sizeof|sizeof
argument_list|(
name|EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**   Returns the size of the PE/COFF headers    Returns the size of the PE/COFF header specified by Pe32Data.   If Pe32Data is NULL, then ASSERT().    @param  Pe32Data   The pointer to the PE/COFF image that is loaded in system                      memory.    @return Size of PE/COFF header in bytes or zero if not a valid image.  **/
end_comment

begin_function
name|UINT32
name|EFIAPI
name|PeCoffGetSizeOfHeaders
parameter_list|(
name|IN
name|VOID
modifier|*
name|Pe32Data
parameter_list|)
block|{
name|EFI_IMAGE_DOS_HEADER
modifier|*
name|DosHdr
decl_stmt|;
name|EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION
name|Hdr
decl_stmt|;
name|UINTN
name|SizeOfHeaders
decl_stmt|;
name|ASSERT
argument_list|(
name|Pe32Data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DosHdr
operator|=
operator|(
name|EFI_IMAGE_DOS_HEADER
operator|*
operator|)
name|Pe32Data
expr_stmt|;
if|if
condition|(
name|DosHdr
operator|->
name|e_magic
operator|==
name|EFI_IMAGE_DOS_SIGNATURE
condition|)
block|{
comment|//
comment|// DOS image header is present, so read the PE header after the DOS image header.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
operator|(
operator|(
name|UINTN
operator|)
name|Pe32Data
operator|+
call|(
name|UINTN
call|)
argument_list|(
operator|(
name|DosHdr
operator|->
name|e_lfanew
operator|)
operator|&
literal|0x0ffff
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|//
comment|// DOS image header is not present, so PE header is at the image base.
comment|//
name|Hdr
operator|.
name|Pe32
operator|=
operator|(
name|EFI_IMAGE_NT_HEADERS32
operator|*
operator|)
name|Pe32Data
expr_stmt|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|Te
operator|->
name|Signature
operator|==
name|EFI_TE_IMAGE_HEADER_SIGNATURE
condition|)
block|{
name|SizeOfHeaders
operator|=
sizeof|sizeof
argument_list|(
name|EFI_TE_IMAGE_HEADER
argument_list|)
operator|+
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|BaseOfCode
operator|-
operator|(
name|UINTN
operator|)
name|Hdr
operator|.
name|Te
operator|->
name|StrippedSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Hdr
operator|.
name|Pe32
operator|->
name|Signature
operator|==
name|EFI_IMAGE_NT_SIGNATURE
condition|)
block|{
name|SizeOfHeaders
operator|=
name|Hdr
operator|.
name|Pe32
operator|->
name|OptionalHeader
operator|.
name|SizeOfHeaders
expr_stmt|;
block|}
else|else
block|{
name|SizeOfHeaders
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|UINT32
operator|)
name|SizeOfHeaders
return|;
block|}
end_function

end_unit

