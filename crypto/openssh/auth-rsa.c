begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: auth-rsa.c,v 1.86 2014/01/27 19:18:54 markus Exp $ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * RSA-based authentication.  This code determines whether to admit a login  * based on RSA authentication.  This file also contains functions to check  * validity of the host key.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"uidswap.h"
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ssh-gss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"monitor_wrap.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"digest.h"
end_include

begin_comment
comment|/* import */
end_comment

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Session identifier that is used to bind key exchange and authentication  * responses to a particular session.  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|session_id
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The .ssh/authorized_keys file contains public keys, one per line, in the  * following format:  *   options bits e n comment  * where bits, e and n are decimal numbers,  * and comment is any string of characters up to newline.  The maximum  * length of a line is SSH_MAX_PUBKEY_BYTES characters.  See sshd(8) for a  * description of the options.  */
end_comment

begin_function
name|BIGNUM
modifier|*
name|auth_rsa_generate_challenge
parameter_list|(
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|challenge
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|(
name|challenge
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"auth_rsa_generate_challenge: BN_new() failed"
argument_list|)
expr_stmt|;
comment|/* Generate a random challenge. */
if|if
condition|(
name|BN_rand
argument_list|(
name|challenge
argument_list|,
literal|256
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"auth_rsa_generate_challenge: BN_rand failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"auth_rsa_generate_challenge: BN_CTX_new failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod
argument_list|(
name|challenge
argument_list|,
name|challenge
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"auth_rsa_generate_challenge: BN_mod failed"
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|challenge
return|;
block|}
end_function

begin_function
name|int
name|auth_rsa_verify_response
parameter_list|(
name|Key
modifier|*
name|key
parameter_list|,
name|BIGNUM
modifier|*
name|challenge
parameter_list|,
name|u_char
name|response
index|[
literal|16
index|]
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|32
index|]
decl_stmt|,
name|mdbuf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|ssh_digest_ctx
modifier|*
name|md
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* don't allow short keys */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|<
name|SSH_RSA_MINIMUM_MODULUS_SIZE
condition|)
block|{
name|error
argument_list|(
literal|"%s: RSA modulus too small: %d< minimum %d bits"
argument_list|,
name|__func__
argument_list|,
name|BN_num_bits
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|SSH_RSA_MINIMUM_MODULUS_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* The response is MD5 of decrypted challenge plus session id. */
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|32
condition|)
name|fatal
argument_list|(
literal|"%s: bad challenge length %d"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|challenge
argument_list|,
name|buf
operator|+
literal|32
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|ssh_digest_start
argument_list|(
name|SSH_DIGEST_MD5
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ssh_digest_update
argument_list|(
name|md
argument_list|,
name|buf
argument_list|,
literal|32
argument_list|)
operator|<
literal|0
operator|||
name|ssh_digest_update
argument_list|(
name|md
argument_list|,
name|session_id
argument_list|,
literal|16
argument_list|)
operator|<
literal|0
operator|||
name|ssh_digest_final
argument_list|(
name|md
argument_list|,
name|mdbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|mdbuf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: md5 failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ssh_digest_free
argument_list|(
name|md
argument_list|)
expr_stmt|;
comment|/* Verify that the response is the original challenge. */
if|if
condition|(
name|timingsafe_bcmp
argument_list|(
name|response
argument_list|,
name|mdbuf
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Wrong answer. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Correct answer. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Performs the RSA authentication challenge-response dialog with the client,  * and returns true (non-zero) if the client gave the correct answer to  * our challenge; returns zero if the client gives a wrong answer.  */
end_comment

begin_function
name|int
name|auth_rsa_challenge_dialog
parameter_list|(
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|challenge
decl_stmt|,
modifier|*
name|encrypted_challenge
decl_stmt|;
name|u_char
name|response
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|success
decl_stmt|;
if|if
condition|(
operator|(
name|encrypted_challenge
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"auth_rsa_challenge_dialog: BN_new() failed"
argument_list|)
expr_stmt|;
name|challenge
operator|=
name|PRIVSEP
argument_list|(
name|auth_rsa_generate_challenge
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encrypt the challenge with the public key. */
name|rsa_public_encrypt
argument_list|(
name|encrypted_challenge
argument_list|,
name|challenge
argument_list|,
name|key
operator|->
name|rsa
argument_list|)
expr_stmt|;
comment|/* Send the encrypted challenge to the client. */
name|packet_start
argument_list|(
name|SSH_SMSG_AUTH_RSA_CHALLENGE
argument_list|)
expr_stmt|;
name|packet_put_bignum
argument_list|(
name|encrypted_challenge
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|BN_clear_free
argument_list|(
name|encrypted_challenge
argument_list|)
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for a response. */
name|packet_read_expect
argument_list|(
name|SSH_CMSG_AUTH_RSA_RESPONSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|response
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|packet_get_char
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|success
operator|=
name|PRIVSEP
argument_list|(
name|auth_rsa_verify_response
argument_list|(
name|key
argument_list|,
name|challenge
argument_list|,
name|response
argument_list|)
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rsa_key_allowed_in_file
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|client_n
parameter_list|,
name|Key
modifier|*
modifier|*
name|rkey
parameter_list|)
block|{
name|char
modifier|*
name|fp
decl_stmt|,
name|line
index|[
name|SSH_MAX_PUBKEY_BYTES
index|]
decl_stmt|;
name|int
name|allowed
init|=
literal|0
decl_stmt|,
name|bits
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|u_long
name|linenum
init|=
literal|0
decl_stmt|;
name|Key
modifier|*
name|key
decl_stmt|;
name|debug
argument_list|(
literal|"trying public RSA key file %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|auth_openkeyfile
argument_list|(
name|file
argument_list|,
name|pw
argument_list|,
name|options
operator|.
name|strict_modes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	 * Go though the accepted keys, looking for the current key.  If 	 * found, perform a challenge-response dialog to verify that the 	 * user really has the corresponding private key. 	 */
name|key
operator|=
name|key_new
argument_list|(
name|KEY_RSA1
argument_list|)
expr_stmt|;
while|while
condition|(
name|read_keyfile_line
argument_list|(
name|f
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
operator|&
name|linenum
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|key_options
decl_stmt|;
name|int
name|keybits
decl_stmt|;
comment|/* Skip leading whitespace, empty and comment lines. */
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|||
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* 		 * Check if there are options for this key, and if so, 		 * save their starting address and skip the option part 		 * for now.  If there are no options, set the starting 		 * address to NULL. 		 */
if|if
condition|(
operator|*
name|cp
operator|<
literal|'0'
operator|||
operator|*
name|cp
operator|>
literal|'9'
condition|)
block|{
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|key_options
operator|=
name|cp
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
operator|&&
operator|(
name|quoted
operator|||
operator|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|)
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Skip both */
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
block|}
block|}
else|else
name|key_options
operator|=
name|NULL
expr_stmt|;
comment|/* Parse the key from the line. */
if|if
condition|(
name|hostfile_read_key
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|bits
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"%.100s, line %lu: non ssh1 key syntax"
argument_list|,
name|file
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* cp now points to the comment part. */
comment|/* 		 * Check if the we have found the desired key (identified 		 * by its modulus). 		 */
if|if
condition|(
name|BN_cmp
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|client_n
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* check the real bits  */
name|keybits
operator|=
name|BN_num_bits
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|keybits
operator|<
literal|0
operator|||
name|bits
operator|!=
name|keybits
condition|)
name|logit
argument_list|(
literal|"Warning: %s, line %lu: keysize mismatch: "
literal|"actual %d vs. announced %d."
argument_list|,
name|file
argument_list|,
name|linenum
argument_list|,
name|BN_num_bits
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|fp
operator|=
name|key_fingerprint
argument_list|(
name|key
argument_list|,
name|SSH_FP_MD5
argument_list|,
name|SSH_FP_HEX
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"matching key found: file %s, line %lu %s %s"
argument_list|,
name|file
argument_list|,
name|linenum
argument_list|,
name|key_type
argument_list|(
name|key
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Never accept a revoked key */
if|if
condition|(
name|auth_key_is_revoked
argument_list|(
name|key
argument_list|)
condition|)
break|break;
comment|/* We have found the desired key. */
comment|/* 		 * If our options do not allow this key to be used, 		 * do not send challenge. 		 */
if|if
condition|(
operator|!
name|auth_parse_options
argument_list|(
name|pw
argument_list|,
name|key_options
argument_list|,
name|file
argument_list|,
name|linenum
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|key_is_cert_authority
condition|)
continue|continue;
comment|/* break out, this key is allowed */
name|allowed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Close the file. */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* return key if allowed */
if|if
condition|(
name|allowed
operator|&&
name|rkey
operator|!=
name|NULL
condition|)
operator|*
name|rkey
operator|=
name|key
expr_stmt|;
else|else
name|key_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|allowed
return|;
block|}
end_function

begin_comment
comment|/*  * check if there's user key matching client_n,  * return key if login is allowed, NULL otherwise  */
end_comment

begin_function
name|int
name|auth_rsa_key_allowed
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|,
name|BIGNUM
modifier|*
name|client_n
parameter_list|,
name|Key
modifier|*
modifier|*
name|rkey
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|allowed
init|=
literal|0
decl_stmt|;
name|temporarily_use_uid
argument_list|(
name|pw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|allowed
operator|&&
name|i
operator|<
name|options
operator|.
name|num_authkeys_files
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|options
operator|.
name|authorized_keys_files
index|[
name|i
index|]
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|file
operator|=
name|expand_authorized_keys
argument_list|(
name|options
operator|.
name|authorized_keys_files
index|[
name|i
index|]
argument_list|,
name|pw
argument_list|)
expr_stmt|;
name|allowed
operator|=
name|rsa_key_allowed_in_file
argument_list|(
name|pw
argument_list|,
name|file
argument_list|,
name|client_n
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|restore_uid
argument_list|()
expr_stmt|;
return|return
name|allowed
return|;
block|}
end_function

begin_comment
comment|/*  * Performs the RSA authentication dialog with the client.  This returns  * 0 if the client could not be authenticated, and 1 if authentication was  * successful.  This may exit if there is a serious protocol violation.  */
end_comment

begin_function
name|int
name|auth_rsa
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
name|BIGNUM
modifier|*
name|client_n
parameter_list|)
block|{
name|Key
modifier|*
name|key
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
init|=
name|authctxt
operator|->
name|pw
decl_stmt|;
comment|/* no user given */
if|if
condition|(
operator|!
name|authctxt
operator|->
name|valid
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|PRIVSEP
argument_list|(
name|auth_rsa_key_allowed
argument_list|(
name|pw
argument_list|,
name|client_n
argument_list|,
operator|&
name|key
argument_list|)
argument_list|)
condition|)
block|{
name|auth_clear_options
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Perform the challenge-response dialog for this key. */
if|if
condition|(
operator|!
name|auth_rsa_challenge_dialog
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|/* Wrong response. */
name|verbose
argument_list|(
literal|"Wrong response to RSA authentication challenge."
argument_list|)
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"Wrong response to RSA authentication challenge."
argument_list|)
expr_stmt|;
comment|/* 		 * Break out of the loop. Otherwise we might send 		 * another challenge and break the protocol. 		 */
name|key_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Correct response.  The client has been successfully 	 * authenticated. Note that we have not yet processed the 	 * options; this will be reset if the options cause the 	 * authentication to be rejected. 	 */
name|pubkey_auth_info
argument_list|(
name|authctxt
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"RSA authentication accepted."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

