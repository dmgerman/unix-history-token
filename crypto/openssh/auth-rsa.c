begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * RSA-based authentication.  This code determines whether to admit a login  * based on RSA authentication.  This file also contains functions to check  * validity of the host key.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: auth-rsa.c,v 1.32 2000/10/14 12:19:45 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"mpaux.h"
end_include

begin_include
include|#
directive|include
file|"uidswap.h"
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_comment
comment|/* import */
end_comment

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Session identifier that is used to bind key exchange and authentication  * responses to a particular session.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|session_id
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The .ssh/authorized_keys file contains public keys, one per line, in the  * following format:  *   options bits e n comment  * where bits, e and n are decimal numbers,  * and comment is any string of characters up to newline.  The maximum  * length of a line is 8000 characters.  See the documentation for a  * description of the options.  */
end_comment

begin_comment
comment|/*  * Performs the RSA authentication challenge-response dialog with the client,  * and returns true (non-zero) if the client gave the correct answer to  * our challenge; returns zero if the client gives a wrong answer.  */
end_comment

begin_function
name|int
name|auth_rsa_challenge_dialog
parameter_list|(
name|RSA
modifier|*
name|pk
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|challenge
decl_stmt|,
modifier|*
name|encrypted_challenge
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|,
name|mdbuf
index|[
literal|16
index|]
decl_stmt|,
name|response
index|[
literal|16
index|]
decl_stmt|;
name|MD5_CTX
name|md
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|len
decl_stmt|;
name|encrypted_challenge
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|challenge
operator|=
name|BN_new
argument_list|()
expr_stmt|;
comment|/* Generate a random challenge. */
name|BN_rand
argument_list|(
name|challenge
argument_list|,
literal|256
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_mod
argument_list|(
name|challenge
argument_list|,
name|challenge
argument_list|,
name|pk
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Encrypt the challenge with the public key. */
name|rsa_public_encrypt
argument_list|(
name|encrypted_challenge
argument_list|,
name|challenge
argument_list|,
name|pk
argument_list|)
expr_stmt|;
comment|/* Send the encrypted challenge to the client. */
name|packet_start
argument_list|(
name|SSH_SMSG_AUTH_RSA_CHALLENGE
argument_list|)
expr_stmt|;
name|packet_put_bignum
argument_list|(
name|encrypted_challenge
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|BN_clear_free
argument_list|(
name|encrypted_challenge
argument_list|)
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for a response. */
name|packet_read_expect
argument_list|(
operator|&
name|plen
argument_list|,
name|SSH_CMSG_AUTH_RSA_RESPONSE
argument_list|)
expr_stmt|;
name|packet_integrity_check
argument_list|(
name|plen
argument_list|,
literal|16
argument_list|,
name|SSH_CMSG_AUTH_RSA_RESPONSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|response
index|[
name|i
index|]
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
comment|/* The response is MD5 of decrypted challenge plus session id. */
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|32
condition|)
name|fatal
argument_list|(
literal|"auth_rsa_challenge_dialog: bad challenge length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|challenge
argument_list|,
name|buf
operator|+
literal|32
operator|-
name|len
argument_list|)
expr_stmt|;
name|MD5_Init
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|buf
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md
argument_list|,
name|session_id
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5_Final
argument_list|(
name|mdbuf
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
comment|/* Verify that the response is the original challenge. */
if|if
condition|(
name|memcmp
argument_list|(
name|response
argument_list|,
name|mdbuf
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Wrong answer. */
return|return
literal|0
return|;
block|}
comment|/* Correct answer. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Performs the RSA authentication dialog with the client.  This returns  * 0 if the client could not be authenticated, and 1 if authentication was  * successful.  This may exit if there is a serious protocol violation.  */
end_comment

begin_function
name|int
name|auth_rsa
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|,
name|BIGNUM
modifier|*
name|client_n
parameter_list|)
block|{
name|char
name|line
index|[
literal|8192
index|]
decl_stmt|,
name|file
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|authenticated
decl_stmt|;
name|unsigned
name|int
name|bits
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|unsigned
name|long
name|linenum
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|RSA
modifier|*
name|pk
decl_stmt|;
comment|/* no user given */
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Temporarily use the user's uid. */
name|temporarily_use_uid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* The authorized keys. */
name|snprintf
argument_list|(
name|file
argument_list|,
sizeof|sizeof
name|file
argument_list|,
literal|"%.500s/%.100s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|SSH_USER_PERMITTED_KEYS
argument_list|)
expr_stmt|;
comment|/* Fail quietly if file does not exist */
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Restore the privileged uid. */
name|restore_uid
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Open the file containing the authorized keys. */
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/* Restore the privileged uid. */
name|restore_uid
argument_list|()
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"Could not open %.900s for reading."
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"If your home is on an NFS volume, it may need to be world-readable."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|options
operator|.
name|strict_modes
condition|)
block|{
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* Check open file in order to avoid open/stat races */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|st
operator|.
name|st_uid
operator|!=
literal|0
operator|&&
name|st
operator|.
name|st_uid
operator|!=
name|pw
operator|->
name|pw_uid
operator|)
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|022
operator|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"RSA authentication refused for %.100s: "
literal|"bad ownership or modes for '%s'."
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Check path to SSH_USER_PERMITTED_KEYS */
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|check
index|[]
init|=
block|{
literal|""
block|,
name|SSH_USER_DIR
block|,
name|NULL
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|check
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
literal|"%.500s/%.100s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|check
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|line
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|st
operator|.
name|st_uid
operator|!=
literal|0
operator|&&
name|st
operator|.
name|st_uid
operator|!=
name|pw
operator|->
name|pw_uid
operator|)
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|022
operator|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"RSA authentication refused for %.100s: "
literal|"bad ownership or modes for '%s'."
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|restore_uid
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Flag indicating whether authentication has succeeded. */
name|authenticated
operator|=
literal|0
expr_stmt|;
name|pk
operator|=
name|RSA_new
argument_list|()
expr_stmt|;
name|pk
operator|->
name|e
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|pk
operator|->
name|n
operator|=
name|BN_new
argument_list|()
expr_stmt|;
comment|/* 	 * Go though the accepted keys, looking for the current key.  If 	 * found, perform a challenge-response dialog to verify that the 	 * user really has the corresponding private key. 	 */
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|linenum
operator|++
expr_stmt|;
comment|/* Skip leading whitespace, empty and comment lines. */
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|||
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* 		 * Check if there are options for this key, and if so, 		 * save their starting address and skip the option part 		 * for now.  If there are no options, set the starting 		 * address to NULL. 		 */
if|if
condition|(
operator|*
name|cp
operator|<
literal|'0'
operator|||
operator|*
name|cp
operator|>
literal|'9'
condition|)
block|{
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|options
operator|=
name|cp
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
operator|&&
operator|(
name|quoted
operator|||
operator|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|)
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Skip both */
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
block|}
block|}
else|else
name|options
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If our options do not allow this key to be used, 		 * do not send challenge. 		 */
if|if
condition|(
operator|!
name|auth_parse_options
argument_list|(
name|pw
argument_list|,
name|options
argument_list|,
name|linenum
argument_list|)
condition|)
continue|continue;
comment|/* Parse the key from the line. */
if|if
condition|(
operator|!
name|auth_rsa_read_key
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|bits
argument_list|,
name|pk
operator|->
name|e
argument_list|,
name|pk
operator|->
name|n
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"%.100s, line %lu: bad key syntax"
argument_list|,
name|SSH_USER_PERMITTED_KEYS
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"%.100s, line %lu: bad key syntax"
argument_list|,
name|SSH_USER_PERMITTED_KEYS
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* cp now points to the comment part. */
comment|/* Check if the we have found the desired key (identified by its modulus). */
if|if
condition|(
name|BN_cmp
argument_list|(
name|pk
operator|->
name|n
argument_list|,
name|client_n
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* check the real bits  */
if|if
condition|(
name|bits
operator|!=
name|BN_num_bits
argument_list|(
name|pk
operator|->
name|n
argument_list|)
condition|)
name|log
argument_list|(
literal|"Warning: %s, line %ld: keysize mismatch: "
literal|"actual %d vs. announced %d."
argument_list|,
name|file
argument_list|,
name|linenum
argument_list|,
name|BN_num_bits
argument_list|(
name|pk
operator|->
name|n
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* We have found the desired key. */
comment|/* Perform the challenge-response dialog for this key. */
if|if
condition|(
operator|!
name|auth_rsa_challenge_dialog
argument_list|(
name|pk
argument_list|)
condition|)
block|{
comment|/* Wrong response. */
name|verbose
argument_list|(
literal|"Wrong response to RSA authentication challenge."
argument_list|)
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"Wrong response to RSA authentication challenge."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Correct response.  The client has been successfully 		 * authenticated. Note that we have not yet processed the 		 * options; this will be reset if the options cause the 		 * authentication to be rejected. 		 * Break out of the loop if authentication was successful; 		 * otherwise continue searching. 		 */
name|authenticated
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Restore the privileged uid. */
name|restore_uid
argument_list|()
expr_stmt|;
comment|/* Close the file. */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
name|authenticated
condition|)
name|packet_send_debug
argument_list|(
literal|"RSA authentication accepted."
argument_list|)
expr_stmt|;
else|else
name|auth_clear_options
argument_list|()
expr_stmt|;
comment|/* Return authentication result. */
return|return
name|authenticated
return|;
block|}
end_function

end_unit

