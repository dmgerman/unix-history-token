begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: sshconnect1.c,v 1.80 2017/03/10 03:53:11 dtucker Exp $ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Code to connect to a remote host, and to perform the client side of the  * login (authentication) dialog.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_SSH1
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"cipher.h"
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_include
include|#
directive|include
file|"uidswap.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"readconf.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"sshconnect.h"
end_include

begin_include
include|#
directive|include
file|"authfile.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"digest.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_comment
comment|/* Session id for the current session. */
end_comment

begin_decl_stmt
name|u_char
name|session_id
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|supported_authentications
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Options
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Checks if the user has an authentication agent, and if so, tries to  * authenticate using the agent.  */
end_comment

begin_function
specifier|static
name|int
name|try_agent_authentication
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|type
decl_stmt|,
name|agent_fd
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|u_char
name|response
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|BIGNUM
modifier|*
name|challenge
decl_stmt|;
name|struct
name|ssh_identitylist
modifier|*
name|idlist
init|=
name|NULL
decl_stmt|;
comment|/* Get connection to the agent. */
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_get_authentication_socket
argument_list|(
operator|&
name|agent_fd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|!=
name|SSH_ERR_AGENT_NOT_PRESENT
condition|)
name|debug
argument_list|(
literal|"%s: ssh_get_authentication_socket: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|challenge
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"try_agent_authentication: BN_new failed"
argument_list|)
expr_stmt|;
comment|/* Loop through identities served by the agent. */
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_fetch_identitylist
argument_list|(
name|agent_fd
argument_list|,
literal|1
argument_list|,
operator|&
name|idlist
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|!=
name|SSH_ERR_AGENT_NO_IDENTITIES
condition|)
name|debug
argument_list|(
literal|"%s: ssh_fetch_identitylist: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idlist
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
comment|/* Try this identity. */
name|debug
argument_list|(
literal|"Trying RSA authentication via agent with '%.100s'"
argument_list|,
name|idlist
operator|->
name|comments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Tell the server that we are willing to authenticate using this key. */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_RSA
argument_list|)
expr_stmt|;
name|packet_put_bignum
argument_list|(
name|idlist
operator|->
name|keys
index|[
name|i
index|]
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for server's response. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
comment|/* The server sends failure if it doesn't like our key or 		   does not support RSA authentication. */
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_FAILURE
condition|)
block|{
name|debug
argument_list|(
literal|"Server refused our key."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Otherwise it should have sent a challenge. */
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_AUTH_RSA_CHALLENGE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error during RSA authentication: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"Received RSA challenge from server."
argument_list|)
expr_stmt|;
comment|/* Ask the agent to decrypt the challenge. */
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_decrypt_challenge
argument_list|(
name|agent_fd
argument_list|,
name|idlist
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|challenge
argument_list|,
name|session_id
argument_list|,
name|response
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The agent failed to authenticate this identifier 			 * although it advertised it supports this.  Just 			 * return a wrong value. 			 */
name|logit
argument_list|(
literal|"Authentication agent failed to decrypt "
literal|"challenge: %s"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"Sending response to RSA challenge."
argument_list|)
expr_stmt|;
comment|/* Send the decrypted challenge back to the server. */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_RSA_RESPONSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|packet_put_char
argument_list|(
name|response
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for response from the server. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
comment|/* 		 * The server returns success if it accepted the 		 * authentication. 		 */
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_SUCCESS
condition|)
block|{
name|debug
argument_list|(
literal|"RSA authentication accepted by server."
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error waiting RSA auth "
literal|"response: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
name|debug
argument_list|(
literal|"RSA authentication using agent refused."
argument_list|)
expr_stmt|;
name|out
label|:
name|ssh_free_identitylist
argument_list|(
name|idlist
argument_list|)
expr_stmt|;
name|ssh_close_authentication_socket
argument_list|(
name|agent_fd
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Computes the proper response to a RSA challenge, and sends the response to  * the server.  */
end_comment

begin_function
specifier|static
name|void
name|respond_to_rsa_challenge
parameter_list|(
name|BIGNUM
modifier|*
name|challenge
parameter_list|,
name|RSA
modifier|*
name|prv
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|32
index|]
decl_stmt|,
name|response
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|ssh_digest_ctx
modifier|*
name|md
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* Decrypt the challenge using the private key. */
comment|/* XXX think about Bleichenbacher, too */
if|if
condition|(
name|rsa_private_decrypt
argument_list|(
name|challenge
argument_list|,
name|challenge
argument_list|,
name|prv
argument_list|)
operator|!=
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"respond_to_rsa_challenge: rsa_private_decrypt failed"
argument_list|)
expr_stmt|;
comment|/* Compute the response. */
comment|/* The response is MD5 of decrypted challenge plus session id. */
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
operator|(
name|u_int
operator|)
name|len
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|packet_disconnect
argument_list|(
literal|"respond_to_rsa_challenge: bad challenge length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|challenge
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|ssh_digest_start
argument_list|(
name|SSH_DIGEST_MD5
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ssh_digest_update
argument_list|(
name|md
argument_list|,
name|buf
argument_list|,
literal|32
argument_list|)
operator|<
literal|0
operator|||
name|ssh_digest_update
argument_list|(
name|md
argument_list|,
name|session_id
argument_list|,
literal|16
argument_list|)
operator|<
literal|0
operator|||
name|ssh_digest_final
argument_list|(
name|md
argument_list|,
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: md5 failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ssh_digest_free
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Sending response to host key RSA challenge."
argument_list|)
expr_stmt|;
comment|/* Send the response back to the server. */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_RSA_RESPONSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|packet_put_char
argument_list|(
name|response
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|explicit_bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
operator|&
name|md
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Checks if the user has authentication file, and if so, tries to authenticate  * the user using it.  */
end_comment

begin_function
specifier|static
name|int
name|try_rsa_authentication
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|challenge
decl_stmt|;
name|Key
modifier|*
name|public
decl_stmt|,
modifier|*
name|private
decl_stmt|;
name|char
name|buf
index|[
literal|300
index|]
decl_stmt|,
modifier|*
name|passphrase
init|=
name|NULL
decl_stmt|,
modifier|*
name|comment
decl_stmt|,
modifier|*
name|authfile
decl_stmt|;
name|int
name|i
decl_stmt|,
name|perm_ok
init|=
literal|1
decl_stmt|,
name|type
decl_stmt|,
name|quit
decl_stmt|;
name|public
operator|=
name|options
operator|.
name|identity_keys
index|[
name|idx
index|]
expr_stmt|;
name|authfile
operator|=
name|options
operator|.
name|identity_files
index|[
name|idx
index|]
expr_stmt|;
name|comment
operator|=
name|xstrdup
argument_list|(
name|authfile
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Trying RSA authentication with key '%.100s'"
argument_list|,
name|comment
argument_list|)
expr_stmt|;
comment|/* Tell the server that we are willing to authenticate using this key. */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_RSA
argument_list|)
expr_stmt|;
name|packet_put_bignum
argument_list|(
name|public
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for server's response. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
comment|/* 	 * The server responds with failure if it doesn't like our key or 	 * doesn't support RSA authentication. 	 */
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_FAILURE
condition|)
block|{
name|debug
argument_list|(
literal|"Server refused our key."
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise, the server should respond with a challenge. */
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_AUTH_RSA_CHALLENGE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error during RSA authentication: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Get the challenge from the packet. */
if|if
condition|(
operator|(
name|challenge
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"try_rsa_authentication: BN_new failed"
argument_list|)
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"Received RSA challenge from server."
argument_list|)
expr_stmt|;
comment|/* 	 * If the key is not stored in external hardware, we have to 	 * load the private key.  Try first with empty passphrase; if it 	 * fails, ask for a passphrase. 	 */
if|if
condition|(
name|public
operator|->
name|flags
operator|&
name|SSHKEY_FLAG_EXT
condition|)
name|private
operator|=
name|public
expr_stmt|;
else|else
name|private
operator|=
name|key_load_private_type
argument_list|(
name|KEY_RSA1
argument_list|,
name|authfile
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
operator|&
name|perm_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|==
name|NULL
operator|&&
operator|!
name|options
operator|.
name|batch_mode
operator|&&
name|perm_ok
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Enter passphrase for RSA key '%.100s': "
argument_list|,
name|comment
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|number_of_password_prompts
condition|;
name|i
operator|++
control|)
block|{
name|passphrase
operator|=
name|read_passphrase
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|passphrase
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|private
operator|=
name|key_load_private_type
argument_list|(
name|KEY_RSA1
argument_list|,
name|authfile
argument_list|,
name|passphrase
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|quit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|debug2
argument_list|(
literal|"no passphrase given, try next key"
argument_list|)
expr_stmt|;
name|quit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|private
operator|!=
name|NULL
operator|||
name|quit
condition|)
break|break;
name|debug2
argument_list|(
literal|"bad passphrase given, try again..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|private
operator|!=
name|NULL
condition|)
name|maybe_add_key_to_agent
argument_list|(
name|authfile
argument_list|,
name|private
argument_list|,
name|comment
argument_list|,
name|passphrase
argument_list|)
expr_stmt|;
if|if
condition|(
name|passphrase
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passphrase
argument_list|)
expr_stmt|;
block|}
comment|/* We no longer need the comment. */
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|options
operator|.
name|batch_mode
operator|&&
name|perm_ok
condition|)
name|error
argument_list|(
literal|"Bad passphrase."
argument_list|)
expr_stmt|;
comment|/* Send a dummy response packet to avoid protocol error. */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_RSA_RESPONSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Expect the server to reject it... */
name|packet_read_expect
argument_list|(
name|SSH_SMSG_FAILURE
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Compute and send a response to the challenge. */
name|respond_to_rsa_challenge
argument_list|(
name|challenge
argument_list|,
name|private
operator|->
name|rsa
argument_list|)
expr_stmt|;
comment|/* Destroy the private key unless it in external hardware. */
if|if
condition|(
operator|!
operator|(
name|private
operator|->
name|flags
operator|&
name|SSHKEY_FLAG_EXT
operator|)
condition|)
name|key_free
argument_list|(
name|private
argument_list|)
expr_stmt|;
comment|/* We no longer need the challenge. */
name|BN_clear_free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
comment|/* Wait for response from the server. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_SUCCESS
condition|)
block|{
name|debug
argument_list|(
literal|"RSA authentication accepted by server."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error waiting RSA auth response: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"RSA authentication refused."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Tries to authenticate the user using combined rhosts or /etc/hosts.equiv  * authentication and RSA host authentication.  */
end_comment

begin_function
specifier|static
name|int
name|try_rhosts_rsa_authentication
parameter_list|(
specifier|const
name|char
modifier|*
name|local_user
parameter_list|,
name|Key
modifier|*
name|host_key
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|BIGNUM
modifier|*
name|challenge
decl_stmt|;
name|debug
argument_list|(
literal|"Trying rhosts or /etc/hosts.equiv with RSA host authentication."
argument_list|)
expr_stmt|;
comment|/* Tell the server that we are willing to authenticate using this key. */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_RHOSTS_RSA
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|local_user
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|packet_put_bignum
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|e
argument_list|)
expr_stmt|;
name|packet_put_bignum
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Wait for server's response. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
comment|/* The server responds with failure if it doesn't admit our 	   .rhosts authentication or doesn't know our host key. */
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_FAILURE
condition|)
block|{
name|debug
argument_list|(
literal|"Server refused our rhosts authentication or host key."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise, the server should respond with a challenge. */
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_AUTH_RSA_CHALLENGE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error during RSA authentication: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Get the challenge from the packet. */
if|if
condition|(
operator|(
name|challenge
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"try_rhosts_rsa_authentication: BN_new failed"
argument_list|)
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"Received RSA challenge for host key from server."
argument_list|)
expr_stmt|;
comment|/* Compute a response to the challenge. */
name|respond_to_rsa_challenge
argument_list|(
name|challenge
argument_list|,
name|host_key
operator|->
name|rsa
argument_list|)
expr_stmt|;
comment|/* We no longer need the challenge. */
name|BN_clear_free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
comment|/* Wait for response from the server. */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_SUCCESS
condition|)
block|{
name|debug
argument_list|(
literal|"Rhosts or /etc/hosts.equiv with RSA host authentication accepted by server."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error waiting RSA auth response: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Rhosts or /etc/hosts.equiv with RSA host authentication refused."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Tries to authenticate with any string-based challenge/response system.  * Note that the client code is not tied to s/key or TIS.  */
end_comment

begin_function
specifier|static
name|int
name|try_challenge_response_authentication
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|clen
decl_stmt|;
name|char
name|prompt
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|challenge
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|debug
argument_list|(
literal|"Doing challenge response authentication."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|number_of_password_prompts
condition|;
name|i
operator|++
control|)
block|{
comment|/* request a challenge */
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_TIS
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
operator|&&
name|type
operator|!=
name|SSH_SMSG_AUTH_TIS_CHALLENGE
condition|)
block|{
name|packet_disconnect
argument_list|(
literal|"Protocol error: got %d in response "
literal|"to SSH_CMSG_AUTH_TIS"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_AUTH_TIS_CHALLENGE
condition|)
block|{
name|debug
argument_list|(
literal|"No challenge."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|challenge
operator|=
name|packet_get_string
argument_list|(
operator|&
name|clen
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
literal|"%s%s"
argument_list|,
name|challenge
argument_list|,
name|strchr
argument_list|(
name|challenge
argument_list|,
literal|'\n'
argument_list|)
condition|?
literal|""
else|:
literal|"\nResponse: "
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|challenge
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Permission denied, please try again."
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|cipher
operator|==
name|SSH_CIPHER_NONE
condition|)
name|logit
argument_list|(
literal|"WARNING: Encryption is disabled! "
literal|"Response will be transmitted in clear text."
argument_list|)
expr_stmt|;
name|response
operator|=
name|read_passphrase
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|response
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
block|}
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_TIS_RESPONSE
argument_list|)
expr_stmt|;
name|ssh_put_password
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|response
argument_list|,
name|strlen
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_SUCCESS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error: got %d in response "
literal|"to SSH_CMSG_AUTH_TIS_RESPONSE"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* failure */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Tries to authenticate with plain passwd authentication.  */
end_comment

begin_function
specifier|static
name|int
name|try_password_authentication
parameter_list|(
name|char
modifier|*
name|prompt
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|password
decl_stmt|;
name|debug
argument_list|(
literal|"Doing password authentication."
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|cipher
operator|==
name|SSH_CIPHER_NONE
condition|)
name|logit
argument_list|(
literal|"WARNING: Encryption is disabled! Password will be transmitted in clear text."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|number_of_password_prompts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Permission denied, please try again."
argument_list|)
expr_stmt|;
name|password
operator|=
name|read_passphrase
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_CMSG_AUTH_PASSWORD
argument_list|)
expr_stmt|;
name|ssh_put_password
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|password
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_SUCCESS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error: got %d in response to passwd auth"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* failure */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * SSH1 key exchange  */
end_comment

begin_function
name|void
name|ssh_kex
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|hostaddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|BIGNUM
modifier|*
name|key
decl_stmt|;
name|Key
modifier|*
name|host_key
decl_stmt|,
modifier|*
name|server_key
decl_stmt|;
name|int
name|bits
decl_stmt|,
name|rbits
decl_stmt|;
name|int
name|ssh_cipher_default
init|=
name|SSH_CIPHER_3DES
decl_stmt|;
name|u_char
name|session_key
index|[
name|SSH_SESSION_KEY_LENGTH
index|]
decl_stmt|;
name|u_char
name|cookie
index|[
literal|8
index|]
decl_stmt|;
name|u_int
name|supported_ciphers
decl_stmt|;
name|u_int
name|server_flags
decl_stmt|,
name|client_flags
decl_stmt|;
name|debug
argument_list|(
literal|"Waiting for server public key."
argument_list|)
expr_stmt|;
comment|/* Wait for a public key packet from the server. */
name|packet_read_expect
argument_list|(
name|SSH_SMSG_PUBLIC_KEY
argument_list|)
expr_stmt|;
comment|/* Get cookie from the packet. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|cookie
index|[
name|i
index|]
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
comment|/* Get the public key. */
if|if
condition|(
operator|(
name|server_key
operator|=
name|key_new
argument_list|(
name|KEY_RSA1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: key_new(KEY_RSA1) failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bits
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|e
argument_list|)
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|rbits
operator|=
name|BN_num_bits
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
name|rbits
condition|)
block|{
name|logit
argument_list|(
literal|"Warning: Server lies about size of server public key: "
literal|"actual size is %d bits vs. announced %d."
argument_list|,
name|rbits
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"Warning: This may be due to an old implementation of ssh."
argument_list|)
expr_stmt|;
block|}
comment|/* Get the host key. */
if|if
condition|(
operator|(
name|host_key
operator|=
name|key_new
argument_list|(
name|KEY_RSA1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: key_new(KEY_RSA1) failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bits
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|e
argument_list|)
expr_stmt|;
name|packet_get_bignum
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|rbits
operator|=
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
name|rbits
condition|)
block|{
name|logit
argument_list|(
literal|"Warning: Server lies about size of server host key: "
literal|"actual size is %d bits vs. announced %d."
argument_list|,
name|rbits
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"Warning: This may be due to an old implementation of ssh."
argument_list|)
expr_stmt|;
block|}
comment|/* Get protocol flags. */
name|server_flags
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_set_protocol_flags
argument_list|(
name|server_flags
argument_list|)
expr_stmt|;
name|supported_ciphers
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|supported_authentications
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"Received server public key (%d bits) and host key (%d bits)."
argument_list|,
name|BN_num_bits
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_host_key
argument_list|(
name|host
argument_list|,
name|hostaddr
argument_list|,
name|host_key
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Host key verification failed."
argument_list|)
expr_stmt|;
name|client_flags
operator|=
name|SSH_PROTOFLAG_SCREEN_NUMBER
operator||
name|SSH_PROTOFLAG_HOST_IN_FWD_OPEN
expr_stmt|;
name|derive_ssh1_session_id
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|cookie
argument_list|,
name|session_id
argument_list|)
expr_stmt|;
comment|/* 	 * Generate an encryption key for the session.   The key is a 256 bit 	 * random number, interpreted as a 32-byte key, with the least 	 * significant 8 bits being the first byte of the key. 	 */
name|arc4random_buf
argument_list|(
name|session_key
argument_list|,
sizeof|sizeof
argument_list|(
name|session_key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * According to the protocol spec, the first byte of the session key 	 * is the highest byte of the integer.  The session key is xored with 	 * the first 16 bytes of the session id. 	 */
if|if
condition|(
operator|(
name|key
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"ssh_kex: BN_new failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_set_word
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"ssh_kex: BN_set_word failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSH_SESSION_KEY_LENGTH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_lshift
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"ssh_kex: BN_lshift failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|BN_add_word
argument_list|(
name|key
argument_list|,
name|session_key
index|[
name|i
index|]
operator|^
name|session_id
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"ssh_kex: BN_add_word failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|BN_add_word
argument_list|(
name|key
argument_list|,
name|session_key
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"ssh_kex: BN_add_word failed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Encrypt the integer using the public key and host key of the 	 * server (key with smaller modulus first). 	 */
if|if
condition|(
name|BN_cmp
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Public key has smaller modulus. */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|<
name|BN_num_bits
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|+
name|SSH_KEY_BITS_RESERVED
condition|)
block|{
name|fatal
argument_list|(
literal|"respond_to_rsa_challenge: host_key %d< server_key %d + "
literal|"SSH_KEY_BITS_RESERVED %d"
argument_list|,
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|BN_num_bits
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|SSH_KEY_BITS_RESERVED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsa_public_encrypt
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|server_key
operator|->
name|rsa
argument_list|)
operator|!=
literal|0
operator|||
name|rsa_public_encrypt
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|host_key
operator|->
name|rsa
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: rsa_public_encrypt failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Host key has smaller modulus (or they are equal). */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|<
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|+
name|SSH_KEY_BITS_RESERVED
condition|)
block|{
name|fatal
argument_list|(
literal|"respond_to_rsa_challenge: server_key %d< host_key %d + "
literal|"SSH_KEY_BITS_RESERVED %d"
argument_list|,
name|BN_num_bits
argument_list|(
name|server_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|BN_num_bits
argument_list|(
name|host_key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
name|SSH_KEY_BITS_RESERVED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsa_public_encrypt
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|host_key
operator|->
name|rsa
argument_list|)
operator|!=
literal|0
operator|||
name|rsa_public_encrypt
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|server_key
operator|->
name|rsa
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: rsa_public_encrypt failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy the public keys since we no longer need them. */
name|key_free
argument_list|(
name|server_key
argument_list|)
expr_stmt|;
name|key_free
argument_list|(
name|host_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|cipher
operator|==
name|SSH_CIPHER_NOT_SET
condition|)
block|{
if|if
condition|(
name|cipher_mask_ssh1
argument_list|(
literal|1
argument_list|)
operator|&
name|supported_ciphers
operator|&
operator|(
literal|1
operator|<<
name|ssh_cipher_default
operator|)
condition|)
name|options
operator|.
name|cipher
operator|=
name|ssh_cipher_default
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|.
name|cipher
operator|==
name|SSH_CIPHER_INVALID
operator|||
operator|!
operator|(
name|cipher_mask_ssh1
argument_list|(
literal|1
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|options
operator|.
name|cipher
operator|)
operator|)
condition|)
block|{
name|logit
argument_list|(
literal|"No valid SSH1 cipher, using %.100s instead."
argument_list|,
name|cipher_name
argument_list|(
name|ssh_cipher_default
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|.
name|cipher
operator|=
name|ssh_cipher_default
expr_stmt|;
block|}
comment|/* Check that the selected cipher is supported. */
if|if
condition|(
operator|!
operator|(
name|supported_ciphers
operator|&
operator|(
literal|1
operator|<<
name|options
operator|.
name|cipher
operator|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"Selected cipher type %.100s not supported by server."
argument_list|,
name|cipher_name
argument_list|(
name|options
operator|.
name|cipher
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Encryption type: %.100s"
argument_list|,
name|cipher_name
argument_list|(
name|options
operator|.
name|cipher
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send the encrypted session key to the server. */
name|packet_start
argument_list|(
name|SSH_CMSG_SESSION_KEY
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
name|options
operator|.
name|cipher
argument_list|)
expr_stmt|;
comment|/* Send the cookie back to the server. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|packet_put_char
argument_list|(
name|cookie
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Send and destroy the encrypted encryption key integer. */
name|packet_put_bignum
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Send protocol flags. */
name|packet_put_int
argument_list|(
name|client_flags
argument_list|)
expr_stmt|;
comment|/* Send the packet now. */
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"Sent encrypted session key."
argument_list|)
expr_stmt|;
comment|/* Set the encryption key. */
name|packet_set_encryption_key
argument_list|(
name|session_key
argument_list|,
name|SSH_SESSION_KEY_LENGTH
argument_list|,
name|options
operator|.
name|cipher
argument_list|)
expr_stmt|;
comment|/* 	 * We will no longer need the session key here. 	 * Destroy any extra copies. 	 */
name|explicit_bzero
argument_list|(
name|session_key
argument_list|,
sizeof|sizeof
argument_list|(
name|session_key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Expect a success message from the server.  Note that this message 	 * will be received in encrypted form. 	 */
name|packet_read_expect
argument_list|(
name|SSH_SMSG_SUCCESS
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Received encrypted confirmation."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Authenticate user  */
end_comment

begin_function
name|void
name|ssh_userauth1
parameter_list|(
specifier|const
name|char
modifier|*
name|local_user
parameter_list|,
specifier|const
name|char
modifier|*
name|server_user
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|Sensitive
modifier|*
name|sensitive
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|supported_authentications
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"ssh_userauth1: server supports no auth methods"
argument_list|)
expr_stmt|;
comment|/* Send the name of the user to log in as on the server. */
name|packet_start
argument_list|(
name|SSH_CMSG_USER
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|server_user
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* 	 * The server should respond with success if no authentication is 	 * needed (the user has no password).  Otherwise the server responds 	 * with failure. 	 */
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
comment|/* check whether the connection was accepted without authentication. */
if|if
condition|(
name|type
operator|==
name|SSH_SMSG_SUCCESS
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|type
operator|!=
name|SSH_SMSG_FAILURE
condition|)
name|packet_disconnect
argument_list|(
literal|"Protocol error: got %d in response to SSH_CMSG_USER"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * Try .rhosts or /etc/hosts.equiv authentication with RSA host 	 * authentication. 	 */
if|if
condition|(
operator|(
name|supported_authentications
operator|&
operator|(
literal|1
operator|<<
name|SSH_AUTH_RHOSTS_RSA
operator|)
operator|)
operator|&&
name|options
operator|.
name|rhosts_rsa_authentication
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sensitive
operator|->
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sensitive
operator|->
name|keys
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|sensitive
operator|->
name|keys
index|[
name|i
index|]
operator|->
name|type
operator|==
name|KEY_RSA1
operator|&&
name|try_rhosts_rsa_authentication
argument_list|(
name|local_user
argument_list|,
name|sensitive
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
block|}
comment|/* Try RSA authentication if the server supports it. */
if|if
condition|(
operator|(
name|supported_authentications
operator|&
operator|(
literal|1
operator|<<
name|SSH_AUTH_RSA
operator|)
operator|)
operator|&&
name|options
operator|.
name|rsa_authentication
condition|)
block|{
comment|/* 		 * Try RSA authentication using the authentication agent. The 		 * agent is tried first because no passphrase is needed for 		 * it, whereas identity files may require passphrases. 		 */
if|if
condition|(
name|try_agent_authentication
argument_list|()
condition|)
goto|goto
name|success
goto|;
comment|/* Try RSA authentication for each identity. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|num_identity_files
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|options
operator|.
name|identity_keys
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|options
operator|.
name|identity_keys
index|[
name|i
index|]
operator|->
name|type
operator|==
name|KEY_RSA1
operator|&&
name|try_rsa_authentication
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
comment|/* Try challenge response authentication if the server supports it. */
if|if
condition|(
operator|(
name|supported_authentications
operator|&
operator|(
literal|1
operator|<<
name|SSH_AUTH_TIS
operator|)
operator|)
operator|&&
name|options
operator|.
name|challenge_response_authentication
operator|&&
operator|!
name|options
operator|.
name|batch_mode
condition|)
block|{
if|if
condition|(
name|try_challenge_response_authentication
argument_list|()
condition|)
goto|goto
name|success
goto|;
block|}
comment|/* Try password authentication if the server supports it. */
if|if
condition|(
operator|(
name|supported_authentications
operator|&
operator|(
literal|1
operator|<<
name|SSH_AUTH_PASSWORD
operator|)
operator|)
operator|&&
name|options
operator|.
name|password_authentication
operator|&&
operator|!
name|options
operator|.
name|batch_mode
condition|)
block|{
name|char
name|prompt
index|[
literal|80
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|"%.30s@%.128s's password: "
argument_list|,
name|server_user
argument_list|,
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_password_authentication
argument_list|(
name|prompt
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
comment|/* All authentication methods have failed.  Exit with an error message. */
name|fatal
argument_list|(
literal|"Permission denied."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|success
label|:
return|return;
comment|/* need statement after label */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_SSH1 */
end_comment

end_unit

