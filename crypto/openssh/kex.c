begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: kex.c,v 1.12 2000/10/11 20:27:23 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"bufaux.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_define
define|#
directive|define
name|KEX_COOKIE_LEN
value|16
end_define

begin_function
name|Buffer
modifier|*
name|kex_init
parameter_list|(
name|char
modifier|*
name|myproposal
index|[
name|PROPOSAL_MAX
index|]
parameter_list|)
block|{
name|int
name|first_kex_packet_follows
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|cookie
index|[
name|KEX_COOKIE_LEN
index|]
decl_stmt|;
name|u_int32_t
name|rand
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Buffer
modifier|*
name|ki
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ki
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEX_COOKIE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|rand
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|cookie
index|[
name|i
index|]
operator|=
name|rand
operator|&
literal|0xff
expr_stmt|;
name|rand
operator|>>=
literal|8
expr_stmt|;
block|}
name|buffer_init
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|ki
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cookie
argument_list|,
sizeof|sizeof
name|cookie
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROPOSAL_MAX
condition|;
name|i
operator|++
control|)
name|buffer_put_cstring
argument_list|(
name|ki
argument_list|,
name|myproposal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buffer_put_char
argument_list|(
name|ki
argument_list|,
name|first_kex_packet_follows
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|ki
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* uint32 reserved */
return|return
name|ki
return|;
block|}
end_function

begin_comment
comment|/* send kexinit, parse and save reply */
end_comment

begin_function
name|void
name|kex_exchange_kexinit
parameter_list|(
name|Buffer
modifier|*
name|my_kexinit
parameter_list|,
name|Buffer
modifier|*
name|peer_kexint
parameter_list|,
name|char
modifier|*
name|peer_proposal
index|[
name|PROPOSAL_MAX
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|debug
argument_list|(
literal|"send KEXINIT"
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_KEXINIT
argument_list|)
expr_stmt|;
name|packet_put_raw
argument_list|(
name|buffer_ptr
argument_list|(
name|my_kexinit
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
name|my_kexinit
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
comment|/* 	 * read and save raw KEXINIT payload in buffer. this is used during 	 * computation of the session_id and the session keys. 	 */
name|debug
argument_list|(
literal|"wait KEXINIT"
argument_list|)
expr_stmt|;
name|packet_read_expect
argument_list|(
operator|&
name|plen
argument_list|,
name|SSH2_MSG_KEXINIT
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|packet_get_raw
argument_list|(
operator|&
name|plen
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
name|peer_kexint
argument_list|,
name|ptr
argument_list|,
name|plen
argument_list|)
expr_stmt|;
comment|/* parse packet and save algorithm proposal */
comment|/* skip cookie */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEX_COOKIE_LEN
condition|;
name|i
operator|++
control|)
name|packet_get_char
argument_list|()
expr_stmt|;
comment|/* extract kex init proposal strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROPOSAL_MAX
condition|;
name|i
operator|++
control|)
block|{
name|peer_proposal
index|[
name|i
index|]
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"got kexinit: %s"
argument_list|,
name|peer_proposal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* first kex follow / reserved */
name|i
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"first kex follow: %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"reserved: %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|packet_done
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* diffie-hellman-group1-sha1 */
end_comment

begin_function
name|int
name|dh_pub_is_valid
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
name|BIGNUM
modifier|*
name|dh_pub
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|BN_num_bits
argument_list|(
name|dh_pub
argument_list|)
decl_stmt|;
name|int
name|bits_set
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dh_pub
operator|->
name|neg
condition|)
block|{
name|log
argument_list|(
literal|"invalid public DH value: negativ"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BN_is_bit_set
argument_list|(
name|dh_pub
argument_list|,
name|i
argument_list|)
condition|)
name|bits_set
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"bits set: %d/%d"
argument_list|,
name|bits_set
argument_list|,
name|BN_num_bits
argument_list|(
name|dh
operator|->
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */
if|if
condition|(
name|bits_set
operator|>
literal|1
operator|&&
operator|(
name|BN_cmp
argument_list|(
name|dh_pub
argument_list|,
name|dh
operator|->
name|p
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|1
return|;
name|log
argument_list|(
literal|"invalid public DH value (%d/%d)"
argument_list|,
name|bits_set
argument_list|,
name|BN_num_bits
argument_list|(
name|dh
operator|->
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|DH
modifier|*
name|dh_gen_key
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
name|int
name|tries
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|DH_generate_key
argument_list|(
name|dh
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"DH_generate_key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|++
operator|>
literal|10
condition|)
name|fatal
argument_list|(
literal|"dh_new_group1: too many bad keys: giving up"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|dh_pub_is_valid
argument_list|(
name|dh
argument_list|,
name|dh
operator|->
name|pub_key
argument_list|)
condition|)
do|;
return|return
name|dh
return|;
block|}
end_function

begin_function
name|DH
modifier|*
name|dh_new_group_asc
parameter_list|(
specifier|const
name|char
modifier|*
name|gen
parameter_list|,
specifier|const
name|char
modifier|*
name|modulus
parameter_list|)
block|{
name|DH
modifier|*
name|dh
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dh
operator|=
name|DH_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"DH_new"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|BN_hex2bn
argument_list|(
operator|&
name|dh
operator|->
name|p
argument_list|,
name|modulus
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"BN_hex2bn p"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|BN_hex2bn
argument_list|(
operator|&
name|dh
operator|->
name|g
argument_list|,
name|gen
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"BN_hex2bn g"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dh_gen_key
argument_list|(
name|dh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|DH
modifier|*
name|dh_new_group
parameter_list|(
name|BIGNUM
modifier|*
name|gen
parameter_list|,
name|BIGNUM
modifier|*
name|modulus
parameter_list|)
block|{
name|DH
modifier|*
name|dh
decl_stmt|;
name|dh
operator|=
name|DH_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"DH_new"
argument_list|)
expr_stmt|;
name|dh
operator|->
name|p
operator|=
name|modulus
expr_stmt|;
name|dh
operator|->
name|g
operator|=
name|gen
expr_stmt|;
return|return
operator|(
name|dh_gen_key
argument_list|(
name|dh
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|DH
modifier|*
name|dh_new_group1
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|gen
init|=
literal|"2"
decl_stmt|,
modifier|*
name|group1
init|=
literal|"FFFFFFFF"
literal|"FFFFFFFF"
literal|"C90FDAA2"
literal|"2168C234"
literal|"C4C6628B"
literal|"80DC1CD1"
literal|"29024E08"
literal|"8A67CC74"
literal|"020BBEA6"
literal|"3B139B22"
literal|"514A0879"
literal|"8E3404DD"
literal|"EF9519B3"
literal|"CD3A431B"
literal|"302B0A6D"
literal|"F25F1437"
literal|"4FE1356D"
literal|"6D51C245"
literal|"E485B576"
literal|"625E7EC6"
literal|"F44C42E9"
literal|"A637ED6B"
literal|"0BFF5CB6"
literal|"F406B7ED"
literal|"EE386BFB"
literal|"5A899FA5"
literal|"AE9F2411"
literal|"7C4B1FE6"
literal|"49286651"
literal|"ECE65381"
literal|"FFFFFFFF"
literal|"FFFFFFFF"
decl_stmt|;
return|return
operator|(
name|dh_new_group_asc
argument_list|(
name|gen
argument_list|,
name|group1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dump_digest
parameter_list|(
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x"
argument_list|,
name|digest
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|kex_hash
parameter_list|(
name|char
modifier|*
name|client_version_string
parameter_list|,
name|char
modifier|*
name|server_version_string
parameter_list|,
name|char
modifier|*
name|ckexinit
parameter_list|,
name|int
name|ckexinitlen
parameter_list|,
name|char
modifier|*
name|skexinit
parameter_list|,
name|int
name|skexinitlen
parameter_list|,
name|char
modifier|*
name|serverhostkeyblob
parameter_list|,
name|int
name|sbloblen
parameter_list|,
name|BIGNUM
modifier|*
name|client_dh_pub
parameter_list|,
name|BIGNUM
modifier|*
name|server_dh_pub
parameter_list|,
name|BIGNUM
modifier|*
name|shared_secret
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
specifier|static
name|unsigned
name|char
name|digest
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|EVP_MD
modifier|*
name|evp_md
init|=
name|EVP_sha1
argument_list|()
decl_stmt|;
name|EVP_MD_CTX
name|md
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|client_version_string
argument_list|,
name|strlen
argument_list|(
name|client_version_string
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|server_version_string
argument_list|,
name|strlen
argument_list|(
name|server_version_string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
name|buffer_put_int
argument_list|(
operator|&
name|b
argument_list|,
name|ckexinitlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_char
argument_list|(
operator|&
name|b
argument_list|,
name|SSH2_MSG_KEXINIT
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|ckexinit
argument_list|,
name|ckexinitlen
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
operator|&
name|b
argument_list|,
name|skexinitlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_char
argument_list|(
operator|&
name|b
argument_list|,
name|SSH2_MSG_KEXINIT
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|skexinit
argument_list|,
name|skexinitlen
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|serverhostkeyblob
argument_list|,
name|sbloblen
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|client_dh_pub
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|server_dh_pub
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|shared_secret
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_KEX
name|buffer_dump
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EVP_DigestInit
argument_list|(
operator|&
name|md
argument_list|,
name|evp_md
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|md
argument_list|,
name|digest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_KEX
name|dump_digest
argument_list|(
name|digest
argument_list|,
name|evp_md
operator|->
name|md_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|digest
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|kex_hash_gex
parameter_list|(
name|char
modifier|*
name|client_version_string
parameter_list|,
name|char
modifier|*
name|server_version_string
parameter_list|,
name|char
modifier|*
name|ckexinit
parameter_list|,
name|int
name|ckexinitlen
parameter_list|,
name|char
modifier|*
name|skexinit
parameter_list|,
name|int
name|skexinitlen
parameter_list|,
name|char
modifier|*
name|serverhostkeyblob
parameter_list|,
name|int
name|sbloblen
parameter_list|,
name|int
name|minbits
parameter_list|,
name|BIGNUM
modifier|*
name|prime
parameter_list|,
name|BIGNUM
modifier|*
name|gen
parameter_list|,
name|BIGNUM
modifier|*
name|client_dh_pub
parameter_list|,
name|BIGNUM
modifier|*
name|server_dh_pub
parameter_list|,
name|BIGNUM
modifier|*
name|shared_secret
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
specifier|static
name|unsigned
name|char
name|digest
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|EVP_MD
modifier|*
name|evp_md
init|=
name|EVP_sha1
argument_list|()
decl_stmt|;
name|EVP_MD_CTX
name|md
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|client_version_string
argument_list|,
name|strlen
argument_list|(
name|client_version_string
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|server_version_string
argument_list|,
name|strlen
argument_list|(
name|server_version_string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
name|buffer_put_int
argument_list|(
operator|&
name|b
argument_list|,
name|ckexinitlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_char
argument_list|(
operator|&
name|b
argument_list|,
name|SSH2_MSG_KEXINIT
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|ckexinit
argument_list|,
name|ckexinitlen
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
operator|&
name|b
argument_list|,
name|skexinitlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_char
argument_list|(
operator|&
name|b
argument_list|,
name|SSH2_MSG_KEXINIT
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|skexinit
argument_list|,
name|skexinitlen
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|serverhostkeyblob
argument_list|,
name|sbloblen
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
operator|&
name|b
argument_list|,
name|minbits
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|prime
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|client_dh_pub
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|server_dh_pub
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|shared_secret
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_KEX
name|buffer_dump
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EVP_DigestInit
argument_list|(
operator|&
name|md
argument_list|,
name|evp_md
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|md
argument_list|,
name|digest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_KEX
name|dump_digest
argument_list|(
name|digest
argument_list|,
name|evp_md
operator|->
name|md_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|digest
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|derive_key
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|need
parameter_list|,
name|char
name|unsigned
modifier|*
name|hash
parameter_list|,
name|BIGNUM
modifier|*
name|shared_secret
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|EVP_MD
modifier|*
name|evp_md
init|=
name|EVP_sha1
argument_list|()
decl_stmt|;
name|EVP_MD_CTX
name|md
decl_stmt|;
name|char
name|c
init|=
name|id
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
name|mdsz
init|=
name|evp_md
operator|->
name|md_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|digest
init|=
name|xmalloc
argument_list|(
operator|(
operator|(
name|need
operator|+
name|mdsz
operator|-
literal|1
operator|)
operator|/
name|mdsz
operator|)
operator|*
name|mdsz
argument_list|)
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|shared_secret
argument_list|)
expr_stmt|;
name|EVP_DigestInit
argument_list|(
operator|&
name|md
argument_list|,
name|evp_md
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shared_secret K */
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|hash
argument_list|,
name|mdsz
argument_list|)
expr_stmt|;
comment|/* transport-06 */
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* key id */
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|hash
argument_list|,
name|mdsz
argument_list|)
expr_stmt|;
comment|/* session id */
name|EVP_DigestFinal
argument_list|(
operator|&
name|md
argument_list|,
name|digest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* expand */
for|for
control|(
name|have
operator|=
name|mdsz
init|;
name|need
operator|>
name|have
condition|;
name|have
operator|+=
name|mdsz
control|)
block|{
name|EVP_DigestInit
argument_list|(
operator|&
name|md
argument_list|,
name|evp_md
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|hash
argument_list|,
name|mdsz
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|md
argument_list|,
name|digest
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|md
argument_list|,
name|digest
operator|+
name|have
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_KEX
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Digest '%c'== "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dump_digest
argument_list|(
name|digest
argument_list|,
name|need
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|digest
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NKEYS
value|6
end_define

begin_define
define|#
directive|define
name|MAX_PROP
value|20
end_define

begin_define
define|#
directive|define
name|SEP
value|","
end_define

begin_function
name|char
modifier|*
name|get_match
parameter_list|(
name|char
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|server
parameter_list|)
block|{
name|char
modifier|*
name|sproposals
index|[
name|MAX_PROP
index|]
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nproposals
decl_stmt|;
name|c
operator|=
name|cp
operator|=
name|xstrdup
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|s
operator|=
name|sp
operator|=
name|xstrdup
argument_list|(
name|server
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|sp
argument_list|,
name|SEP
argument_list|)
operator|)
operator|,
name|i
operator|=
literal|0
init|;
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|sp
argument_list|,
name|SEP
argument_list|)
operator|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|MAX_PROP
condition|)
name|sproposals
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
else|else
break|break;
block|}
name|nproposals
operator|=
name|i
expr_stmt|;
for|for
control|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
name|SEP
argument_list|)
operator|)
operator|,
name|i
operator|=
literal|0
init|;
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
name|SEP
argument_list|)
operator|)
operator|,
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nproposals
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|sproposals
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
block|}
name|xfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|choose_enc
parameter_list|(
name|Enc
modifier|*
name|enc
parameter_list|,
name|char
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|server
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|get_match
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"no matching cipher found: client %s server %s"
argument_list|,
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|enc
operator|->
name|cipher
operator|=
name|cipher_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|cipher
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"matching cipher is not supported: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|enc
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|enc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|enc
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
name|enc
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|choose_mac
parameter_list|(
name|Mac
modifier|*
name|mac
parameter_list|,
name|char
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|server
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|get_match
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"no matching mac found: client %s server %s"
argument_list|,
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"hmac-md5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mac
operator|->
name|md
operator|=
name|EVP_md5
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"hmac-sha1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mac
operator|->
name|md
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"hmac-ripemd160@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mac
operator|->
name|md
operator|=
name|EVP_ripemd160
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unsupported mac %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|mac
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|mac
operator|->
name|mac_len
operator|=
name|mac
operator|->
name|md
operator|->
name|md_size
expr_stmt|;
name|mac
operator|->
name|key_len
operator|=
operator|(
name|datafellows
operator|&
name|SSH_BUG_HMAC
operator|)
condition|?
literal|16
else|:
name|mac
operator|->
name|mac_len
expr_stmt|;
name|mac
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|choose_comp
parameter_list|(
name|Comp
modifier|*
name|comp
parameter_list|,
name|char
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|server
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|get_match
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"no matching comp found: client %s server %s"
argument_list|,
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"zlib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|comp
operator|->
name|type
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|comp
operator|->
name|type
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unsupported comp %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|comp
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|choose_kex
parameter_list|(
name|Kex
modifier|*
name|k
parameter_list|,
name|char
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|server
parameter_list|)
block|{
name|k
operator|->
name|name
operator|=
name|get_match
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|name
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"no kex alg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|k
operator|->
name|name
argument_list|,
name|KEX_DH1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|k
operator|->
name|kex_type
operator|=
name|DH_GRP1_SHA1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|k
operator|->
name|name
argument_list|,
name|KEX_DHGEX
argument_list|)
operator|==
literal|0
condition|)
block|{
name|k
operator|->
name|kex_type
operator|=
name|DH_GEX_SHA1
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"bad kex alg %s"
argument_list|,
name|k
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|choose_hostkeyalg
parameter_list|(
name|Kex
modifier|*
name|k
parameter_list|,
name|char
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|server
parameter_list|)
block|{
name|k
operator|->
name|hostkeyalg
operator|=
name|get_match
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|hostkeyalg
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"no hostkey alg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|k
operator|->
name|hostkeyalg
argument_list|,
name|KEX_DSS
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"bad hostkey alg %s"
argument_list|,
name|k
operator|->
name|hostkeyalg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Kex
modifier|*
name|kex_choose_conf
parameter_list|(
name|char
modifier|*
name|cprop
index|[
name|PROPOSAL_MAX
index|]
parameter_list|,
name|char
modifier|*
name|sprop
index|[
name|PROPOSAL_MAX
index|]
parameter_list|,
name|int
name|server
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|ctos
decl_stmt|;
comment|/* direction: if true client-to-server */
name|int
name|need
decl_stmt|;
name|Kex
modifier|*
name|k
decl_stmt|;
name|k
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|server
operator|=
name|server
expr_stmt|;
for|for
control|(
name|mode
operator|=
literal|0
init|;
name|mode
operator|<
name|MODE_MAX
condition|;
name|mode
operator|++
control|)
block|{
name|int
name|nenc
decl_stmt|,
name|nmac
decl_stmt|,
name|ncomp
decl_stmt|;
name|ctos
operator|=
operator|(
operator|!
name|k
operator|->
name|server
operator|&&
name|mode
operator|==
name|MODE_OUT
operator|)
operator|||
operator|(
name|k
operator|->
name|server
operator|&&
name|mode
operator|==
name|MODE_IN
operator|)
expr_stmt|;
name|nenc
operator|=
name|ctos
condition|?
name|PROPOSAL_ENC_ALGS_CTOS
else|:
name|PROPOSAL_ENC_ALGS_STOC
expr_stmt|;
name|nmac
operator|=
name|ctos
condition|?
name|PROPOSAL_MAC_ALGS_CTOS
else|:
name|PROPOSAL_MAC_ALGS_STOC
expr_stmt|;
name|ncomp
operator|=
name|ctos
condition|?
name|PROPOSAL_COMP_ALGS_CTOS
else|:
name|PROPOSAL_COMP_ALGS_STOC
expr_stmt|;
name|choose_enc
argument_list|(
operator|&
name|k
operator|->
name|enc
index|[
name|mode
index|]
argument_list|,
name|cprop
index|[
name|nenc
index|]
argument_list|,
name|sprop
index|[
name|nenc
index|]
argument_list|)
expr_stmt|;
name|choose_mac
argument_list|(
operator|&
name|k
operator|->
name|mac
index|[
name|mode
index|]
argument_list|,
name|cprop
index|[
name|nmac
index|]
argument_list|,
name|sprop
index|[
name|nmac
index|]
argument_list|)
expr_stmt|;
name|choose_comp
argument_list|(
operator|&
name|k
operator|->
name|comp
index|[
name|mode
index|]
argument_list|,
name|cprop
index|[
name|ncomp
index|]
argument_list|,
name|sprop
index|[
name|ncomp
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"kex: %s %s %s %s"
argument_list|,
name|ctos
condition|?
literal|"client->server"
else|:
literal|"server->client"
argument_list|,
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|name
argument_list|,
name|k
operator|->
name|mac
index|[
name|mode
index|]
operator|.
name|name
argument_list|,
name|k
operator|->
name|comp
index|[
name|mode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|choose_kex
argument_list|(
name|k
argument_list|,
name|cprop
index|[
name|PROPOSAL_KEX_ALGS
index|]
argument_list|,
name|sprop
index|[
name|PROPOSAL_KEX_ALGS
index|]
argument_list|)
expr_stmt|;
name|choose_hostkeyalg
argument_list|(
name|k
argument_list|,
name|cprop
index|[
name|PROPOSAL_SERVER_HOST_KEY_ALGS
index|]
argument_list|,
name|sprop
index|[
name|PROPOSAL_SERVER_HOST_KEY_ALGS
index|]
argument_list|)
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mode
operator|=
literal|0
init|;
name|mode
operator|<
name|MODE_MAX
condition|;
name|mode
operator|++
control|)
block|{
if|if
condition|(
name|need
operator|<
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|cipher
operator|->
name|key_len
condition|)
name|need
operator|=
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|cipher
operator|->
name|key_len
expr_stmt|;
if|if
condition|(
name|need
operator|<
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|cipher
operator|->
name|block_size
condition|)
name|need
operator|=
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|cipher
operator|->
name|block_size
expr_stmt|;
if|if
condition|(
name|need
operator|<
name|k
operator|->
name|mac
index|[
name|mode
index|]
operator|.
name|key_len
condition|)
name|need
operator|=
name|k
operator|->
name|mac
index|[
name|mode
index|]
operator|.
name|key_len
expr_stmt|;
block|}
comment|/* XXX need runden? */
name|k
operator|->
name|we_need
operator|=
name|need
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
name|int
name|kex_derive_keys
parameter_list|(
name|Kex
modifier|*
name|k
parameter_list|,
name|unsigned
name|char
modifier|*
name|hash
parameter_list|,
name|BIGNUM
modifier|*
name|shared_secret
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|ctos
decl_stmt|;
name|unsigned
name|char
modifier|*
name|keys
index|[
name|NKEYS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYS
condition|;
name|i
operator|++
control|)
name|keys
index|[
name|i
index|]
operator|=
name|derive_key
argument_list|(
literal|'A'
operator|+
name|i
argument_list|,
name|k
operator|->
name|we_need
argument_list|,
name|hash
argument_list|,
name|shared_secret
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
literal|0
init|;
name|mode
operator|<
name|MODE_MAX
condition|;
name|mode
operator|++
control|)
block|{
name|ctos
operator|=
operator|(
operator|!
name|k
operator|->
name|server
operator|&&
name|mode
operator|==
name|MODE_OUT
operator|)
operator|||
operator|(
name|k
operator|->
name|server
operator|&&
name|mode
operator|==
name|MODE_IN
operator|)
expr_stmt|;
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|iv
operator|=
name|keys
index|[
name|ctos
condition|?
literal|0
else|:
literal|1
index|]
expr_stmt|;
name|k
operator|->
name|enc
index|[
name|mode
index|]
operator|.
name|key
operator|=
name|keys
index|[
name|ctos
condition|?
literal|2
else|:
literal|3
index|]
expr_stmt|;
name|k
operator|->
name|mac
index|[
name|mode
index|]
operator|.
name|key
operator|=
name|keys
index|[
name|ctos
condition|?
literal|4
else|:
literal|5
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

