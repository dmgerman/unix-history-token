begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Shared versions of debug(), log(), etc.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: log.c,v 1.7 2000/01/04 00:07:59 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* Fatal messages.  This function never returns. */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|do_log
argument_list|(
name|SYSLOG_LEVEL_FATAL
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatal_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Error messages that should be logged. */
end_comment

begin_function
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|do_log
argument_list|(
name|SYSLOG_LEVEL_ERROR
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Log this message (information that usually should go to the log). */
end_comment

begin_function
name|void
name|log
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|do_log
argument_list|(
name|SYSLOG_LEVEL_INFO
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More detailed messages (information that does not need to go to the log). */
end_comment

begin_function
name|void
name|verbose
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|do_log
argument_list|(
name|SYSLOG_LEVEL_VERBOSE
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging messages that should not be logged during normal operation. */
end_comment

begin_function
name|void
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|do_log
argument_list|(
name|SYSLOG_LEVEL_DEBUG
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fatal cleanup */
end_comment

begin_struct
struct|struct
name|fatal_cleanup
block|{
name|struct
name|fatal_cleanup
modifier|*
name|next
decl_stmt|;
name|void
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|context
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|fatal_cleanup
modifier|*
name|fatal_cleanups
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Registers a cleanup function to be called by fatal() before exiting. */
end_comment

begin_function
name|void
name|fatal_add_cleanup
parameter_list|(
name|void
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|fatal_cleanup
modifier|*
name|cu
decl_stmt|;
name|cu
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cu
argument_list|)
argument_list|)
expr_stmt|;
name|cu
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|cu
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|cu
operator|->
name|next
operator|=
name|fatal_cleanups
expr_stmt|;
name|fatal_cleanups
operator|=
name|cu
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes a cleanup frunction to be called at fatal(). */
end_comment

begin_function
name|void
name|fatal_remove_cleanup
parameter_list|(
name|void
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|fatal_cleanup
modifier|*
modifier|*
name|cup
decl_stmt|,
modifier|*
name|cu
decl_stmt|;
for|for
control|(
name|cup
operator|=
operator|&
name|fatal_cleanups
init|;
operator|*
name|cup
condition|;
name|cup
operator|=
operator|&
name|cu
operator|->
name|next
control|)
block|{
name|cu
operator|=
operator|*
name|cup
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|proc
operator|==
name|proc
operator|&&
name|cu
operator|->
name|context
operator|==
name|context
condition|)
block|{
operator|*
name|cup
operator|=
name|cu
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|cu
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fatal
argument_list|(
literal|"fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|proc
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup and exit */
end_comment

begin_function
name|void
name|fatal_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|fatal_cleanup
modifier|*
name|cu
decl_stmt|,
modifier|*
name|next_cu
decl_stmt|;
specifier|static
name|int
name|called
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|called
condition|)
name|exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|called
operator|=
literal|1
expr_stmt|;
comment|/* Call cleanup functions. */
for|for
control|(
name|cu
operator|=
name|fatal_cleanups
init|;
name|cu
condition|;
name|cu
operator|=
name|next_cu
control|)
block|{
name|next_cu
operator|=
name|cu
operator|->
name|next
expr_stmt|;
name|debug
argument_list|(
literal|"Calling cleanup 0x%lx(0x%lx)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cu
operator|->
name|proc
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cu
operator|->
name|context
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cu
operator|->
name|proc
call|)
argument_list|(
name|cu
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* textual representation of log-facilities/levels */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|SyslogFacility
name|val
decl_stmt|;
block|}
name|log_facilities
index|[]
init|=
block|{
block|{
literal|"DAEMON"
block|,
name|SYSLOG_FACILITY_DAEMON
block|}
block|,
block|{
literal|"USER"
block|,
name|SYSLOG_FACILITY_USER
block|}
block|,
block|{
literal|"AUTH"
block|,
name|SYSLOG_FACILITY_AUTH
block|}
block|,
block|{
literal|"LOCAL0"
block|,
name|SYSLOG_FACILITY_LOCAL0
block|}
block|,
block|{
literal|"LOCAL1"
block|,
name|SYSLOG_FACILITY_LOCAL1
block|}
block|,
block|{
literal|"LOCAL2"
block|,
name|SYSLOG_FACILITY_LOCAL2
block|}
block|,
block|{
literal|"LOCAL3"
block|,
name|SYSLOG_FACILITY_LOCAL3
block|}
block|,
block|{
literal|"LOCAL4"
block|,
name|SYSLOG_FACILITY_LOCAL4
block|}
block|,
block|{
literal|"LOCAL5"
block|,
name|SYSLOG_FACILITY_LOCAL5
block|}
block|,
block|{
literal|"LOCAL6"
block|,
name|SYSLOG_FACILITY_LOCAL6
block|}
block|,
block|{
literal|"LOCAL7"
block|,
name|SYSLOG_FACILITY_LOCAL7
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|LogLevel
name|val
decl_stmt|;
block|}
name|log_levels
index|[]
init|=
block|{
block|{
literal|"QUIET"
block|,
name|SYSLOG_LEVEL_QUIET
block|}
block|,
block|{
literal|"FATAL"
block|,
name|SYSLOG_LEVEL_FATAL
block|}
block|,
block|{
literal|"ERROR"
block|,
name|SYSLOG_LEVEL_ERROR
block|}
block|,
block|{
literal|"INFO"
block|,
name|SYSLOG_LEVEL_INFO
block|}
block|,
block|{
literal|"VERBOSE"
block|,
name|SYSLOG_LEVEL_VERBOSE
block|}
block|,
block|{
literal|"DEBUG"
block|,
name|SYSLOG_LEVEL_DEBUG
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|SyslogFacility
name|log_facility_number
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|log_facilities
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|log_facilities
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|log_facilities
index|[
name|i
index|]
operator|.
name|val
return|;
return|return
operator|(
name|SyslogFacility
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|LogLevel
name|log_level_number
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|log_levels
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|log_levels
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|log_levels
index|[
name|i
index|]
operator|.
name|val
return|;
return|return
operator|(
name|LogLevel
operator|)
operator|-
literal|1
return|;
block|}
end_function

end_unit

