begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: ssh-pkcs11.c,v 1.11 2013/11/13 13:48:20 markus Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2010 Markus Friedl.  All rights reserved.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_PKCS11
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"openbsd-compat/sys-queue.h"
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_define
define|#
directive|define
name|CRYPTOKI_COMPAT
end_define

begin_include
include|#
directive|include
file|"pkcs11.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"ssh-pkcs11.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_struct
struct|struct
name|pkcs11_slotinfo
block|{
name|CK_TOKEN_INFO
name|token
decl_stmt|;
name|CK_SESSION_HANDLE
name|session
decl_stmt|;
name|int
name|logged_in
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pkcs11_provider
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|handle
decl_stmt|;
name|CK_FUNCTION_LIST
modifier|*
name|function_list
decl_stmt|;
name|CK_INFO
name|info
decl_stmt|;
name|CK_ULONG
name|nslots
decl_stmt|;
name|CK_SLOT_ID
modifier|*
name|slotlist
decl_stmt|;
name|struct
name|pkcs11_slotinfo
modifier|*
name|slotinfo
decl_stmt|;
name|int
name|valid
decl_stmt|;
name|int
name|refcount
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|pkcs11_provider
argument_list|)
name|next
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pkcs11_provider
argument_list|)
end_macro

begin_expr_stmt
name|pkcs11_providers
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|pkcs11_key
block|{
name|struct
name|pkcs11_provider
modifier|*
name|provider
decl_stmt|;
name|CK_ULONG
name|slotidx
decl_stmt|;
name|int
function_decl|(
modifier|*
name|orig_finish
function_decl|)
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
name|RSA_METHOD
name|rsa_method
decl_stmt|;
name|char
modifier|*
name|keyid
decl_stmt|;
name|int
name|keyid_len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|pkcs11_interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pkcs11_init
parameter_list|(
name|int
name|interactive
parameter_list|)
block|{
name|pkcs11_interactive
operator|=
name|interactive
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pkcs11_providers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * finalize a provider shared libarary, it's no longer usable.  * however, there might still be keys referencing this provider,  * so the actuall freeing of memory is handled by pkcs11_provider_unref().  * this is called when a provider gets unregistered.  */
end_comment

begin_function
specifier|static
name|void
name|pkcs11_provider_finalize
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|p
parameter_list|)
block|{
name|CK_RV
name|rv
decl_stmt|;
name|CK_ULONG
name|i
decl_stmt|;
name|debug
argument_list|(
literal|"pkcs11_provider_finalize: %p refcount %d valid %d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|refcount
argument_list|,
name|p
operator|->
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|valid
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|slotinfo
index|[
name|i
index|]
operator|.
name|session
operator|&&
operator|(
name|rv
operator|=
name|p
operator|->
name|function_list
operator|->
name|C_CloseSession
argument_list|(
name|p
operator|->
name|slotinfo
index|[
name|i
index|]
operator|.
name|session
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
name|error
argument_list|(
literal|"C_CloseSession failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|p
operator|->
name|function_list
operator|->
name|C_Finalize
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
name|error
argument_list|(
literal|"C_Finalize failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|p
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|function_list
operator|=
name|NULL
expr_stmt|;
name|dlclose
argument_list|(
name|p
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a reference to the provider.  * called when a key gets destroyed or when the provider is unregistered.  */
end_comment

begin_function
specifier|static
name|void
name|pkcs11_provider_unref
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|p
parameter_list|)
block|{
name|debug
argument_list|(
literal|"pkcs11_provider_unref: %p refcount %d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|p
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|valid
condition|)
name|error
argument_list|(
literal|"pkcs11_provider_unref: %p still valid"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|slotlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|slotinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* unregister all providers, keys might still point to the providers */
end_comment

begin_function
name|void
name|pkcs11_terminate
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pkcs11_provider
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pkcs11_providers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pkcs11_providers
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|pkcs11_provider_finalize
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pkcs11_provider_unref
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* lookup provider by name */
end_comment

begin_function
specifier|static
name|struct
name|pkcs11_provider
modifier|*
name|pkcs11_provider_lookup
parameter_list|(
name|char
modifier|*
name|provider_id
parameter_list|)
block|{
name|struct
name|pkcs11_provider
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&pkcs11_providers
argument_list|,
argument|next
argument_list|)
block|{
name|debug
argument_list|(
literal|"check %p %s"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|provider_id
argument_list|,
name|p
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* unregister provider by name */
end_comment

begin_function
name|int
name|pkcs11_del_provider
parameter_list|(
name|char
modifier|*
name|provider_id
parameter_list|)
block|{
name|struct
name|pkcs11_provider
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|pkcs11_provider_lookup
argument_list|(
name|provider_id
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pkcs11_providers
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|pkcs11_provider_finalize
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pkcs11_provider_unref
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* openssl callback for freeing an RSA key */
end_comment

begin_function
specifier|static
name|int
name|pkcs11_rsa_finish
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|struct
name|pkcs11_key
modifier|*
name|k11
decl_stmt|;
name|int
name|rv
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|k11
operator|=
name|RSA_get_app_data
argument_list|(
name|rsa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|k11
operator|->
name|orig_finish
condition|)
name|rv
operator|=
name|k11
operator|->
name|orig_finish
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|k11
operator|->
name|provider
condition|)
name|pkcs11_provider_unref
argument_list|(
name|k11
operator|->
name|provider
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k11
operator|->
name|keyid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k11
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* find a single 'obj' for given attributes */
end_comment

begin_function
specifier|static
name|int
name|pkcs11_find
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|p
parameter_list|,
name|CK_ULONG
name|slotidx
parameter_list|,
name|CK_ATTRIBUTE
modifier|*
name|attr
parameter_list|,
name|CK_ULONG
name|nattr
parameter_list|,
name|CK_OBJECT_HANDLE
modifier|*
name|obj
parameter_list|)
block|{
name|CK_FUNCTION_LIST
modifier|*
name|f
decl_stmt|;
name|CK_SESSION_HANDLE
name|session
decl_stmt|;
name|CK_ULONG
name|nfound
init|=
literal|0
decl_stmt|;
name|CK_RV
name|rv
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|f
operator|=
name|p
operator|->
name|function_list
expr_stmt|;
name|session
operator|=
name|p
operator|->
name|slotinfo
index|[
name|slotidx
index|]
operator|.
name|session
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_FindObjectsInit
argument_list|(
name|session
argument_list|,
name|attr
argument_list|,
name|nattr
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_FindObjectsInit failed (nattr %lu): %lu"
argument_list|,
name|nattr
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_FindObjects
argument_list|(
name|session
argument_list|,
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|nfound
argument_list|)
operator|)
operator|!=
name|CKR_OK
operator|||
name|nfound
operator|!=
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"C_FindObjects failed (nfound %lu nattr %lu): %lu"
argument_list|,
name|nfound
argument_list|,
name|nattr
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_FindObjectsFinal
argument_list|(
name|session
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
name|error
argument_list|(
literal|"C_FindObjectsFinal failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* openssl callback doing the actual signing operation */
end_comment

begin_function
specifier|static
name|int
name|pkcs11_rsa_private_encrypt
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|from
parameter_list|,
name|u_char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|struct
name|pkcs11_key
modifier|*
name|k11
decl_stmt|;
name|struct
name|pkcs11_slotinfo
modifier|*
name|si
decl_stmt|;
name|CK_FUNCTION_LIST
modifier|*
name|f
decl_stmt|;
name|CK_OBJECT_HANDLE
name|obj
decl_stmt|;
name|CK_ULONG
name|tlen
init|=
literal|0
decl_stmt|;
name|CK_RV
name|rv
decl_stmt|;
name|CK_OBJECT_CLASS
name|private_key_class
init|=
name|CKO_PRIVATE_KEY
decl_stmt|;
name|CK_BBOOL
name|true_val
init|=
name|CK_TRUE
decl_stmt|;
name|CK_MECHANISM
name|mech
init|=
block|{
name|CKM_RSA_PKCS
block|,
name|NULL_PTR
block|,
literal|0
block|}
decl_stmt|;
name|CK_ATTRIBUTE
name|key_filter
index|[]
init|=
block|{
block|{
name|CKA_CLASS
block|,
name|NULL
block|,
expr|sizeof
operator|(
name|private_key_class
operator|)
block|}
block|,
block|{
name|CKA_ID
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|CKA_SIGN
block|,
name|NULL
block|,
expr|sizeof
operator|(
name|true_val
operator|)
block|}
block|}
decl_stmt|;
name|char
modifier|*
name|pin
decl_stmt|,
name|prompt
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|rval
init|=
operator|-
literal|1
decl_stmt|;
name|key_filter
index|[
literal|0
index|]
operator|.
name|pValue
operator|=
operator|&
name|private_key_class
expr_stmt|;
name|key_filter
index|[
literal|2
index|]
operator|.
name|pValue
operator|=
operator|&
name|true_val
expr_stmt|;
if|if
condition|(
operator|(
name|k11
operator|=
name|RSA_get_app_data
argument_list|(
name|rsa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"RSA_get_app_data failed for rsa %p"
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|k11
operator|->
name|provider
operator|||
operator|!
name|k11
operator|->
name|provider
operator|->
name|valid
condition|)
block|{
name|error
argument_list|(
literal|"no pkcs11 (valid) provider for rsa %p"
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|f
operator|=
name|k11
operator|->
name|provider
operator|->
name|function_list
expr_stmt|;
name|si
operator|=
operator|&
name|k11
operator|->
name|provider
operator|->
name|slotinfo
index|[
name|k11
operator|->
name|slotidx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|si
operator|->
name|token
operator|.
name|flags
operator|&
name|CKF_LOGIN_REQUIRED
operator|)
operator|&&
operator|!
name|si
operator|->
name|logged_in
condition|)
block|{
if|if
condition|(
operator|!
name|pkcs11_interactive
condition|)
block|{
name|error
argument_list|(
literal|"need pin"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|,
literal|"Enter PIN for '%s': "
argument_list|,
name|si
operator|->
name|token
operator|.
name|label
argument_list|)
expr_stmt|;
name|pin
operator|=
name|read_passphrase
argument_list|(
name|prompt
argument_list|,
name|RP_ALLOW_EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bail out */
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_Login
argument_list|(
name|si
operator|->
name|session
argument_list|,
name|CKU_USER
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pin
argument_list|,
name|strlen
argument_list|(
name|pin
argument_list|)
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|free
argument_list|(
name|pin
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"C_Login failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|pin
argument_list|)
expr_stmt|;
name|si
operator|->
name|logged_in
operator|=
literal|1
expr_stmt|;
block|}
name|key_filter
index|[
literal|1
index|]
operator|.
name|pValue
operator|=
name|k11
operator|->
name|keyid
expr_stmt|;
name|key_filter
index|[
literal|1
index|]
operator|.
name|ulValueLen
operator|=
name|k11
operator|->
name|keyid_len
expr_stmt|;
comment|/* try to find object w/CKA_SIGN first, retry w/o */
if|if
condition|(
name|pkcs11_find
argument_list|(
name|k11
operator|->
name|provider
argument_list|,
name|k11
operator|->
name|slotidx
argument_list|,
name|key_filter
argument_list|,
literal|3
argument_list|,
operator|&
name|obj
argument_list|)
operator|<
literal|0
operator|&&
name|pkcs11_find
argument_list|(
name|k11
operator|->
name|provider
argument_list|,
name|k11
operator|->
name|slotidx
argument_list|,
name|key_filter
argument_list|,
literal|2
argument_list|,
operator|&
name|obj
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot find private key"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_SignInit
argument_list|(
name|si
operator|->
name|session
argument_list|,
operator|&
name|mech
argument_list|,
name|obj
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_SignInit failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX handle CKR_BUFFER_TOO_SMALL */
name|tlen
operator|=
name|RSA_size
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
name|rv
operator|=
name|f
operator|->
name|C_Sign
argument_list|(
name|si
operator|->
name|session
argument_list|,
operator|(
name|CK_BYTE
operator|*
operator|)
name|from
argument_list|,
name|flen
argument_list|,
name|to
argument_list|,
operator|&
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|CKR_OK
condition|)
name|rval
operator|=
name|tlen
expr_stmt|;
else|else
name|error
argument_list|(
literal|"C_Sign failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkcs11_rsa_private_decrypt
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|from
parameter_list|,
name|u_char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* redirect private key operations for rsa key to pkcs11 token */
end_comment

begin_function
specifier|static
name|int
name|pkcs11_rsa_wrap
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|provider
parameter_list|,
name|CK_ULONG
name|slotidx
parameter_list|,
name|CK_ATTRIBUTE
modifier|*
name|keyid_attrib
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|struct
name|pkcs11_key
modifier|*
name|k11
decl_stmt|;
specifier|const
name|RSA_METHOD
modifier|*
name|def
init|=
name|RSA_get_default_method
argument_list|()
decl_stmt|;
name|k11
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k11
argument_list|)
argument_list|)
expr_stmt|;
name|k11
operator|->
name|provider
operator|=
name|provider
expr_stmt|;
name|provider
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* provider referenced by RSA key */
name|k11
operator|->
name|slotidx
operator|=
name|slotidx
expr_stmt|;
comment|/* identify key object on smartcard */
name|k11
operator|->
name|keyid_len
operator|=
name|keyid_attrib
operator|->
name|ulValueLen
expr_stmt|;
name|k11
operator|->
name|keyid
operator|=
name|xmalloc
argument_list|(
name|k11
operator|->
name|keyid_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|k11
operator|->
name|keyid
argument_list|,
name|keyid_attrib
operator|->
name|pValue
argument_list|,
name|k11
operator|->
name|keyid_len
argument_list|)
expr_stmt|;
name|k11
operator|->
name|orig_finish
operator|=
name|def
operator|->
name|finish
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|k11
operator|->
name|rsa_method
argument_list|,
name|def
argument_list|,
sizeof|sizeof
argument_list|(
name|k11
operator|->
name|rsa_method
argument_list|)
argument_list|)
expr_stmt|;
name|k11
operator|->
name|rsa_method
operator|.
name|name
operator|=
literal|"pkcs11"
expr_stmt|;
name|k11
operator|->
name|rsa_method
operator|.
name|rsa_priv_enc
operator|=
name|pkcs11_rsa_private_encrypt
expr_stmt|;
name|k11
operator|->
name|rsa_method
operator|.
name|rsa_priv_dec
operator|=
name|pkcs11_rsa_private_decrypt
expr_stmt|;
name|k11
operator|->
name|rsa_method
operator|.
name|finish
operator|=
name|pkcs11_rsa_finish
expr_stmt|;
name|RSA_set_method
argument_list|(
name|rsa
argument_list|,
operator|&
name|k11
operator|->
name|rsa_method
argument_list|)
expr_stmt|;
name|RSA_set_app_data
argument_list|(
name|rsa
argument_list|,
name|k11
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* remove trailing spaces */
end_comment

begin_function
specifier|static
name|void
name|rmspace
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|i
operator|==
name|len
operator|-
literal|1
operator|||
name|buf
index|[
name|i
index|]
operator|==
literal|' '
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
break|break;
block|}
end_function

begin_comment
comment|/*  * open a pkcs11 session and login if required.  * if pin == NULL we delay login until key use  */
end_comment

begin_function
specifier|static
name|int
name|pkcs11_open_session
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|p
parameter_list|,
name|CK_ULONG
name|slotidx
parameter_list|,
name|char
modifier|*
name|pin
parameter_list|)
block|{
name|CK_RV
name|rv
decl_stmt|;
name|CK_FUNCTION_LIST
modifier|*
name|f
decl_stmt|;
name|CK_SESSION_HANDLE
name|session
decl_stmt|;
name|int
name|login_required
decl_stmt|;
name|f
operator|=
name|p
operator|->
name|function_list
expr_stmt|;
name|login_required
operator|=
name|p
operator|->
name|slotinfo
index|[
name|slotidx
index|]
operator|.
name|token
operator|.
name|flags
operator|&
name|CKF_LOGIN_REQUIRED
expr_stmt|;
if|if
condition|(
name|pin
operator|&&
name|login_required
operator|&&
operator|!
name|strlen
argument_list|(
name|pin
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"pin required"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_OpenSession
argument_list|(
name|p
operator|->
name|slotlist
index|[
name|slotidx
index|]
argument_list|,
name|CKF_RW_SESSION
operator||
name|CKF_SERIAL_SESSION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|session
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_OpenSession failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|login_required
operator|&&
name|pin
condition|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_Login
argument_list|(
name|session
argument_list|,
name|CKU_USER
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pin
argument_list|,
name|strlen
argument_list|(
name|pin
argument_list|)
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_Login failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_CloseSession
argument_list|(
name|session
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
name|error
argument_list|(
literal|"C_CloseSession failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|slotinfo
index|[
name|slotidx
index|]
operator|.
name|logged_in
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|slotinfo
index|[
name|slotidx
index|]
operator|.
name|session
operator|=
name|session
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lookup public keys for token in slot identified by slotidx,  * add 'wrapped' public keys to the 'keysp' array and increment nkeys.  * keysp points to an (possibly empty) array with *nkeys keys.  */
end_comment

begin_function_decl
specifier|static
name|int
name|pkcs11_fetch_keys_filter
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
parameter_list|,
name|CK_ULONG
parameter_list|,
name|CK_ATTRIBUTE
index|[]
parameter_list|,
name|CK_ATTRIBUTE
index|[
literal|3
index|]
parameter_list|,
name|Key
modifier|*
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__bounded__
parameter_list|(
name|__minbytes__
parameter_list|,
function_decl|4
operator|,
function_decl|3 * sizeof
parameter_list|(
name|CK_ATTRIBUTE
parameter_list|)
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|int
name|pkcs11_fetch_keys
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|p
parameter_list|,
name|CK_ULONG
name|slotidx
parameter_list|,
name|Key
modifier|*
modifier|*
modifier|*
name|keysp
parameter_list|,
name|int
modifier|*
name|nkeys
parameter_list|)
block|{
name|CK_OBJECT_CLASS
name|pubkey_class
init|=
name|CKO_PUBLIC_KEY
decl_stmt|;
name|CK_OBJECT_CLASS
name|cert_class
init|=
name|CKO_CERTIFICATE
decl_stmt|;
name|CK_ATTRIBUTE
name|pubkey_filter
index|[]
init|=
block|{
block|{
name|CKA_CLASS
block|,
name|NULL
block|,
expr|sizeof
operator|(
name|pubkey_class
operator|)
block|}
block|}
decl_stmt|;
name|CK_ATTRIBUTE
name|cert_filter
index|[]
init|=
block|{
block|{
name|CKA_CLASS
block|,
name|NULL
block|,
expr|sizeof
operator|(
name|cert_class
operator|)
block|}
block|}
decl_stmt|;
name|CK_ATTRIBUTE
name|pubkey_attribs
index|[]
init|=
block|{
block|{
name|CKA_ID
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|CKA_MODULUS
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|CKA_PUBLIC_EXPONENT
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|CK_ATTRIBUTE
name|cert_attribs
index|[]
init|=
block|{
block|{
name|CKA_ID
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|CKA_SUBJECT
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|CKA_VALUE
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|pubkey_filter
index|[
literal|0
index|]
operator|.
name|pValue
operator|=
operator|&
name|pubkey_class
expr_stmt|;
name|cert_filter
index|[
literal|0
index|]
operator|.
name|pValue
operator|=
operator|&
name|cert_class
expr_stmt|;
if|if
condition|(
name|pkcs11_fetch_keys_filter
argument_list|(
name|p
argument_list|,
name|slotidx
argument_list|,
name|pubkey_filter
argument_list|,
name|pubkey_attribs
argument_list|,
name|keysp
argument_list|,
name|nkeys
argument_list|)
operator|<
literal|0
operator|||
name|pkcs11_fetch_keys_filter
argument_list|(
name|p
argument_list|,
name|slotidx
argument_list|,
name|cert_filter
argument_list|,
name|cert_attribs
argument_list|,
name|keysp
argument_list|,
name|nkeys
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkcs11_key_included
parameter_list|(
name|Key
modifier|*
modifier|*
modifier|*
name|keysp
parameter_list|,
name|int
modifier|*
name|nkeys
parameter_list|,
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|nkeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|key_equal
argument_list|(
name|key
argument_list|,
operator|(
operator|*
name|keysp
operator|)
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkcs11_fetch_keys_filter
parameter_list|(
name|struct
name|pkcs11_provider
modifier|*
name|p
parameter_list|,
name|CK_ULONG
name|slotidx
parameter_list|,
name|CK_ATTRIBUTE
name|filter
index|[]
parameter_list|,
name|CK_ATTRIBUTE
name|attribs
index|[
literal|3
index|]
parameter_list|,
name|Key
modifier|*
modifier|*
modifier|*
name|keysp
parameter_list|,
name|int
modifier|*
name|nkeys
parameter_list|)
block|{
name|Key
modifier|*
name|key
decl_stmt|;
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|X509
modifier|*
name|x509
decl_stmt|;
name|EVP_PKEY
modifier|*
name|evp
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|CK_RV
name|rv
decl_stmt|;
name|CK_OBJECT_HANDLE
name|obj
decl_stmt|;
name|CK_ULONG
name|nfound
decl_stmt|;
name|CK_SESSION_HANDLE
name|session
decl_stmt|;
name|CK_FUNCTION_LIST
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|p
operator|->
name|function_list
expr_stmt|;
name|session
operator|=
name|p
operator|->
name|slotinfo
index|[
name|slotidx
index|]
operator|.
name|session
expr_stmt|;
comment|/* setup a filter the looks for public keys */
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_FindObjectsInit
argument_list|(
name|session
argument_list|,
name|filter
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_FindObjectsInit failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* XXX 3 attributes in attribs[] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|attribs
index|[
name|i
index|]
operator|.
name|pValue
operator|=
name|NULL
expr_stmt|;
name|attribs
index|[
name|i
index|]
operator|.
name|ulValueLen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_FindObjects
argument_list|(
name|session
argument_list|,
operator|&
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|nfound
argument_list|)
operator|)
operator|!=
name|CKR_OK
operator|||
name|nfound
operator|==
literal|0
condition|)
break|break;
comment|/* found a key, so figure out size of the attributes */
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_GetAttributeValue
argument_list|(
name|session
argument_list|,
name|obj
argument_list|,
name|attribs
argument_list|,
literal|3
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetAttributeValue failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check that none of the attributes are zero length */
if|if
condition|(
name|attribs
index|[
literal|0
index|]
operator|.
name|ulValueLen
operator|==
literal|0
operator|||
name|attribs
index|[
literal|1
index|]
operator|.
name|ulValueLen
operator|==
literal|0
operator|||
name|attribs
index|[
literal|2
index|]
operator|.
name|ulValueLen
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* allocate buffers for attributes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|attribs
index|[
name|i
index|]
operator|.
name|pValue
operator|=
name|xmalloc
argument_list|(
name|attribs
index|[
name|i
index|]
operator|.
name|ulValueLen
argument_list|)
expr_stmt|;
comment|/* 		 * retrieve ID, modulus and public exponent of RSA key, 		 * or ID, subject and value for certificates. 		 */
name|rsa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_GetAttributeValue
argument_list|(
name|session
argument_list|,
name|obj
argument_list|,
name|attribs
argument_list|,
literal|3
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetAttributeValue failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attribs
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|CKA_MODULUS
condition|)
block|{
if|if
condition|(
operator|(
name|rsa
operator|=
name|RSA_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"RSA_new failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rsa
operator|->
name|n
operator|=
name|BN_bin2bn
argument_list|(
name|attribs
index|[
literal|1
index|]
operator|.
name|pValue
argument_list|,
name|attribs
index|[
literal|1
index|]
operator|.
name|ulValueLen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rsa
operator|->
name|e
operator|=
name|BN_bin2bn
argument_list|(
name|attribs
index|[
literal|2
index|]
operator|.
name|pValue
argument_list|,
name|attribs
index|[
literal|2
index|]
operator|.
name|ulValueLen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
name|attribs
index|[
literal|2
index|]
operator|.
name|pValue
expr_stmt|;
if|if
condition|(
operator|(
name|x509
operator|=
name|X509_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"X509_new failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2i_X509
argument_list|(
operator|&
name|x509
argument_list|,
operator|&
name|cp
argument_list|,
name|attribs
index|[
literal|2
index|]
operator|.
name|ulValueLen
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"d2i_X509 failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|evp
operator|=
name|X509_get_pubkey
argument_list|(
name|x509
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|evp
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
operator|||
name|evp
operator|->
name|pkey
operator|.
name|rsa
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"X509_get_pubkey failed or no rsa"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rsa
operator|=
name|RSAPublicKey_dup
argument_list|(
name|evp
operator|->
name|pkey
operator|.
name|rsa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"RSAPublicKey_dup"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x509
condition|)
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsa
operator|&&
name|rsa
operator|->
name|n
operator|&&
name|rsa
operator|->
name|e
operator|&&
name|pkcs11_rsa_wrap
argument_list|(
name|p
argument_list|,
name|slotidx
argument_list|,
operator|&
name|attribs
index|[
literal|0
index|]
argument_list|,
name|rsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|key
operator|=
name|key_new
argument_list|(
name|KEY_UNSPEC
argument_list|)
expr_stmt|;
name|key
operator|->
name|rsa
operator|=
name|rsa
expr_stmt|;
name|key
operator|->
name|type
operator|=
name|KEY_RSA
expr_stmt|;
name|key
operator|->
name|flags
operator||=
name|KEY_FLAG_EXT
expr_stmt|;
if|if
condition|(
name|pkcs11_key_included
argument_list|(
name|keysp
argument_list|,
name|nkeys
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|key_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* expand key array and add key */
operator|*
name|keysp
operator|=
name|xrealloc
argument_list|(
operator|*
name|keysp
argument_list|,
operator|*
name|nkeys
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Key
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|keysp
operator|)
index|[
operator|*
name|nkeys
index|]
operator|=
name|key
expr_stmt|;
operator|*
name|nkeys
operator|=
operator|*
name|nkeys
operator|+
literal|1
expr_stmt|;
name|debug
argument_list|(
literal|"have %d keys"
argument_list|,
operator|*
name|nkeys
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rsa
condition|)
block|{
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|attribs
index|[
name|i
index|]
operator|.
name|pValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_FindObjectsFinal
argument_list|(
name|session
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
name|error
argument_list|(
literal|"C_FindObjectsFinal failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* register a new provider, fails if provider already exists */
end_comment

begin_function
name|int
name|pkcs11_add_provider
parameter_list|(
name|char
modifier|*
name|provider_id
parameter_list|,
name|char
modifier|*
name|pin
parameter_list|,
name|Key
modifier|*
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
name|int
name|nkeys
decl_stmt|,
name|need_finalize
init|=
literal|0
decl_stmt|;
name|struct
name|pkcs11_provider
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|handle
init|=
name|NULL
decl_stmt|;
name|CK_RV
function_decl|(
modifier|*
name|getfunctionlist
function_decl|)
parameter_list|(
name|CK_FUNCTION_LIST
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|CK_RV
name|rv
decl_stmt|;
name|CK_FUNCTION_LIST
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|CK_TOKEN_INFO
modifier|*
name|token
decl_stmt|;
name|CK_ULONG
name|i
decl_stmt|;
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pkcs11_provider_lookup
argument_list|(
name|provider_id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"provider already registered: %s"
argument_list|,
name|provider_id
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* open shared pkcs11-libarary */
if|if
condition|(
operator|(
name|handle
operator|=
name|dlopen
argument_list|(
name|provider_id
argument_list|,
name|RTLD_NOW
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"dlopen %s failed: %s"
argument_list|,
name|provider_id
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|getfunctionlist
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"C_GetFunctionList"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"dlsym(C_GetFunctionList) failed: %s"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|provider_id
argument_list|)
expr_stmt|;
name|p
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
comment|/* setup the pkcs11 callbacks */
if|if
condition|(
operator|(
name|rv
operator|=
call|(
modifier|*
name|getfunctionlist
call|)
argument_list|(
operator|&
name|f
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetFunctionList failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|->
name|function_list
operator|=
name|f
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_Initialize
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_Initialize failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|need_finalize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_GetInfo
argument_list|(
operator|&
name|p
operator|->
name|info
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetInfo failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rmspace
argument_list|(
name|p
operator|->
name|info
operator|.
name|manufacturerID
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|info
operator|.
name|manufacturerID
argument_list|)
argument_list|)
expr_stmt|;
name|rmspace
argument_list|(
name|p
operator|->
name|info
operator|.
name|libraryDescription
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|info
operator|.
name|libraryDescription
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"manufacturerID<%s> cryptokiVersion %d.%d"
literal|" libraryDescription<%s> libraryVersion %d.%d"
argument_list|,
name|p
operator|->
name|info
operator|.
name|manufacturerID
argument_list|,
name|p
operator|->
name|info
operator|.
name|cryptokiVersion
operator|.
name|major
argument_list|,
name|p
operator|->
name|info
operator|.
name|cryptokiVersion
operator|.
name|minor
argument_list|,
name|p
operator|->
name|info
operator|.
name|libraryDescription
argument_list|,
name|p
operator|->
name|info
operator|.
name|libraryVersion
operator|.
name|major
argument_list|,
name|p
operator|->
name|info
operator|.
name|libraryVersion
operator|.
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_GetSlotList
argument_list|(
name|CK_TRUE
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
operator|->
name|nslots
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetSlotList failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|nslots
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"no slots"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|->
name|slotlist
operator|=
name|xcalloc
argument_list|(
name|p
operator|->
name|nslots
argument_list|,
sizeof|sizeof
argument_list|(
name|CK_SLOT_ID
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_GetSlotList
argument_list|(
name|CK_TRUE
argument_list|,
name|p
operator|->
name|slotlist
argument_list|,
operator|&
name|p
operator|->
name|nslots
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetSlotList failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|->
name|slotinfo
operator|=
name|xcalloc
argument_list|(
name|p
operator|->
name|nslots
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pkcs11_slotinfo
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|nkeys
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nslots
condition|;
name|i
operator|++
control|)
block|{
name|token
operator|=
operator|&
name|p
operator|->
name|slotinfo
index|[
name|i
index|]
operator|.
name|token
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|f
operator|->
name|C_GetTokenInfo
argument_list|(
name|p
operator|->
name|slotlist
index|[
name|i
index|]
argument_list|,
name|token
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
block|{
name|error
argument_list|(
literal|"C_GetTokenInfo failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rmspace
argument_list|(
name|token
operator|->
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|token
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|rmspace
argument_list|(
name|token
operator|->
name|manufacturerID
argument_list|,
sizeof|sizeof
argument_list|(
name|token
operator|->
name|manufacturerID
argument_list|)
argument_list|)
expr_stmt|;
name|rmspace
argument_list|(
name|token
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|token
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|rmspace
argument_list|(
name|token
operator|->
name|serialNumber
argument_list|,
sizeof|sizeof
argument_list|(
name|token
operator|->
name|serialNumber
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"label<%s> manufacturerID<%s> model<%s> serial<%s>"
literal|" flags 0x%lx"
argument_list|,
name|token
operator|->
name|label
argument_list|,
name|token
operator|->
name|manufacturerID
argument_list|,
name|token
operator|->
name|model
argument_list|,
name|token
operator|->
name|serialNumber
argument_list|,
name|token
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* open session, login with pin and retrieve public keys */
if|if
condition|(
name|pkcs11_open_session
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|pin
argument_list|)
operator|==
literal|0
condition|)
name|pkcs11_fetch_keys
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|keyp
argument_list|,
operator|&
name|nkeys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nkeys
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pkcs11_providers
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|p
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* add to provider list */
return|return
operator|(
name|nkeys
operator|)
return|;
block|}
name|error
argument_list|(
literal|"no keys"
argument_list|)
expr_stmt|;
comment|/* don't add the provider, since it does not have any keys */
name|fail
label|:
if|if
condition|(
name|need_finalize
operator|&&
operator|(
name|rv
operator|=
name|f
operator|->
name|C_Finalize
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
name|CKR_OK
condition|)
name|error
argument_list|(
literal|"C_Finalize failed: %lu"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|slotlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|slotinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle
condition|)
name|dlclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|pkcs11_init
parameter_list|(
name|int
name|interactive
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pkcs11_terminate
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_PKCS11 */
end_comment

end_unit

