begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: sshkey.c,v 1.45 2017/03/10 04:07:20 djm Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.  * Copyright (c) 2008 Alexander von Gernler.  All rights reserved.  * Copyright (c) 2010,2011 Damien Miller.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"crypto_api.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTIL_H */
end_comment

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"sshbuf.h"
end_include

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_include
include|#
directive|include
file|"cipher.h"
end_include

begin_include
include|#
directive|include
file|"digest.h"
end_include

begin_define
define|#
directive|define
name|SSHKEY_INTERNAL
end_define

begin_include
include|#
directive|include
file|"sshkey.h"
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_comment
comment|/* openssh private key file format */
end_comment

begin_define
define|#
directive|define
name|MARK_BEGIN
value|"-----BEGIN OPENSSH PRIVATE KEY-----\n"
end_define

begin_define
define|#
directive|define
name|MARK_END
value|"-----END OPENSSH PRIVATE KEY-----\n"
end_define

begin_define
define|#
directive|define
name|MARK_BEGIN_LEN
value|(sizeof(MARK_BEGIN) - 1)
end_define

begin_define
define|#
directive|define
name|MARK_END_LEN
value|(sizeof(MARK_END) - 1)
end_define

begin_define
define|#
directive|define
name|KDFNAME
value|"bcrypt"
end_define

begin_define
define|#
directive|define
name|AUTH_MAGIC
value|"openssh-key-v1"
end_define

begin_define
define|#
directive|define
name|SALT_LEN
value|16
end_define

begin_define
define|#
directive|define
name|DEFAULT_CIPHERNAME
value|"aes256-cbc"
end_define

begin_define
define|#
directive|define
name|DEFAULT_ROUNDS
value|16
end_define

begin_comment
comment|/* Version identification string for SSH v1 identity files. */
end_comment

begin_define
define|#
directive|define
name|LEGACY_BEGIN
value|"SSH PRIVATE KEY FILE FORMAT 1.1\n"
end_define

begin_function_decl
specifier|static
name|int
name|sshkey_from_blob_internal
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|int
name|allow_cert
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Supported key types */
end_comment

begin_struct
struct|struct
name|keytype
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|shortname
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|nid
decl_stmt|;
name|int
name|cert
decl_stmt|;
name|int
name|sigonly
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|keytype
name|keytypes
index|[]
init|=
block|{
block|{
literal|"ssh-ed25519"
block|,
literal|"ED25519"
block|,
name|KEY_ED25519
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ssh-ed25519-cert-v01@openssh.com"
block|,
literal|"ED25519-CERT"
block|,
name|KEY_ED25519_CERT
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|WITH_OPENSSL
ifdef|#
directive|ifdef
name|WITH_SSH1
block|{
name|NULL
block|,
literal|"RSA1"
block|,
name|KEY_RSA1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"ssh-rsa"
block|,
literal|"RSA"
block|,
name|KEY_RSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rsa-sha2-256"
block|,
literal|"RSA"
block|,
name|KEY_RSA
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"rsa-sha2-512"
block|,
literal|"RSA"
block|,
name|KEY_RSA
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"ssh-dss"
block|,
literal|"DSA"
block|,
name|KEY_DSA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
block|{
literal|"ecdsa-sha2-nistp256"
block|,
literal|"ECDSA"
block|,
name|KEY_ECDSA
block|,
name|NID_X9_62_prime256v1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ecdsa-sha2-nistp384"
block|,
literal|"ECDSA"
block|,
name|KEY_ECDSA
block|,
name|NID_secp384r1
block|,
literal|0
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
block|{
literal|"ecdsa-sha2-nistp521"
block|,
literal|"ECDSA"
block|,
name|KEY_ECDSA
block|,
name|NID_secp521r1
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
block|{
literal|"ssh-rsa-cert-v01@openssh.com"
block|,
literal|"RSA-CERT"
block|,
name|KEY_RSA_CERT
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ssh-dss-cert-v01@openssh.com"
block|,
literal|"DSA-CERT"
block|,
name|KEY_DSA_CERT
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
block|{
literal|"ecdsa-sha2-nistp256-cert-v01@openssh.com"
block|,
literal|"ECDSA-CERT"
block|,
name|KEY_ECDSA_CERT
block|,
name|NID_X9_62_prime256v1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ecdsa-sha2-nistp384-cert-v01@openssh.com"
block|,
literal|"ECDSA-CERT"
block|,
name|KEY_ECDSA_CERT
block|,
name|NID_secp384r1
block|,
literal|1
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
block|{
literal|"ecdsa-sha2-nistp521-cert-v01@openssh.com"
block|,
literal|"ECDSA-CERT"
block|,
name|KEY_ECDSA_CERT
block|,
name|NID_secp521r1
block|,
literal|1
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
block|{
name|NULL
block|,
name|NULL
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|sshkey_type
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|k
operator|->
name|type
condition|)
return|return
name|kt
operator|->
name|shortname
return|;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sshkey_ssh_name_from_type_nid
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|nid
parameter_list|)
block|{
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|type
operator|&&
operator|(
name|kt
operator|->
name|nid
operator|==
literal|0
operator|||
name|kt
operator|->
name|nid
operator|==
name|nid
operator|)
condition|)
return|return
name|kt
operator|->
name|name
return|;
block|}
return|return
literal|"ssh-unknown"
return|;
block|}
end_function

begin_function
name|int
name|sshkey_type_is_cert
parameter_list|(
name|int
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|kt
operator|->
name|cert
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sshkey_ssh_name
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
return|return
name|sshkey_ssh_name_from_type_nid
argument_list|(
name|k
operator|->
name|type
argument_list|,
name|k
operator|->
name|ecdsa_nid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sshkey_ssh_name_plain
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
return|return
name|sshkey_ssh_name_from_type_nid
argument_list|(
name|sshkey_type_plain
argument_list|(
name|k
operator|->
name|type
argument_list|)
argument_list|,
name|k
operator|->
name|ecdsa_nid
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sshkey_type_from_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
comment|/* Only allow shortname matches for plain key types */
if|if
condition|(
operator|(
name|kt
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|kt
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|kt
operator|->
name|cert
operator|&&
name|strcasecmp
argument_list|(
name|kt
operator|->
name|shortname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|kt
operator|->
name|type
return|;
block|}
return|return
name|KEY_UNSPEC
return|;
block|}
end_function

begin_function
name|int
name|sshkey_ecdsa_nid_from_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|KEY_ECDSA
operator|&&
name|kt
operator|->
name|type
operator|!=
name|KEY_ECDSA_CERT
condition|)
continue|continue;
if|if
condition|(
name|kt
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|kt
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|kt
operator|->
name|nid
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sshkey_alg_list
parameter_list|(
name|int
name|certs_only
parameter_list|,
name|int
name|plain_only
parameter_list|,
name|int
name|include_sigonly
parameter_list|,
name|char
name|sep
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|size_t
name|nlen
decl_stmt|,
name|rlen
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|include_sigonly
operator|&&
name|kt
operator|->
name|sigonly
condition|)
continue|continue;
if|if
condition|(
operator|(
name|certs_only
operator|&&
operator|!
name|kt
operator|->
name|cert
operator|)
operator|||
operator|(
name|plain_only
operator|&&
name|kt
operator|->
name|cert
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|ret
index|[
name|rlen
operator|++
index|]
operator|=
name|sep
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|realloc
argument_list|(
name|ret
argument_list|,
name|rlen
operator|+
name|nlen
operator|+
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|tmp
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|+
name|rlen
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rlen
operator|+=
name|nlen
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|sshkey_names_valid2
parameter_list|(
specifier|const
name|char
modifier|*
name|names
parameter_list|,
name|int
name|allow_wildcard
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|keytype
modifier|*
name|kt
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|names
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|names
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|s
operator|=
name|cp
operator|=
name|strdup
argument_list|(
name|names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|","
argument_list|)
operator|)
init|;
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|","
argument_list|)
operator|)
control|)
block|{
name|type
operator|=
name|sshkey_type_from_name
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|KEY_RSA1
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type
operator|==
name|KEY_UNSPEC
condition|)
block|{
if|if
condition|(
name|allow_wildcard
condition|)
block|{
comment|/* 				 * Try matching key types against the string. 				 * If any has a positive or negative match then 				 * the component is accepted. 				 */
for|for
control|(
name|kt
operator|=
name|keytypes
init|;
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|KEY_RSA1
condition|)
continue|continue;
if|if
condition|(
name|match_pattern_list
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
operator|-
literal|1
condition|)
continue|continue;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|u_int
name|sshkey_size
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA_CERT
case|:
return|return
name|BN_num_bits
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|)
return|;
case|case
name|KEY_DSA
case|:
case|case
name|KEY_DSA_CERT
case|:
return|return
name|BN_num_bits
argument_list|(
name|k
operator|->
name|dsa
operator|->
name|p
argument_list|)
return|;
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ECDSA_CERT
case|:
return|return
name|sshkey_curve_nid_to_bits
argument_list|(
name|k
operator|->
name|ecdsa_nid
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
return|return
literal|256
return|;
comment|/* XXX */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sshkey_type_is_valid_ca
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KEY_RSA
case|:
case|case
name|KEY_DSA
case|:
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ED25519
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|sshkey_is_cert
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|sshkey_type_is_cert
argument_list|(
name|k
operator|->
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the cert-less equivalent to a certified key type */
end_comment

begin_function
name|int
name|sshkey_type_plain
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KEY_RSA_CERT
case|:
return|return
name|KEY_RSA
return|;
case|case
name|KEY_DSA_CERT
case|:
return|return
name|KEY_DSA
return|;
case|case
name|KEY_ECDSA_CERT
case|:
return|return
name|KEY_ECDSA
return|;
case|case
name|KEY_ED25519_CERT
case|:
return|return
name|KEY_ED25519
return|;
default|default:
return|return
name|type
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_comment
comment|/* XXX: these are really begging for a table-driven approach */
end_comment

begin_function
name|int
name|sshkey_curve_name_to_nid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nistp256"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NID_X9_62_prime256v1
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nistp384"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NID_secp384r1
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nistp521"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NID_secp521r1
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|u_int
name|sshkey_curve_nid_to_bits
parameter_list|(
name|int
name|nid
parameter_list|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
name|NID_X9_62_prime256v1
case|:
return|return
literal|256
return|;
case|case
name|NID_secp384r1
case|:
return|return
literal|384
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
case|case
name|NID_secp521r1
case|:
return|return
literal|521
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|sshkey_ecdsa_bits_to_nid
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|256
case|:
return|return
name|NID_X9_62_prime256v1
return|;
case|case
literal|384
case|:
return|return
name|NID_secp384r1
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
case|case
literal|521
case|:
return|return
name|NID_secp521r1
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sshkey_curve_nid_to_name
parameter_list|(
name|int
name|nid
parameter_list|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
name|NID_X9_62_prime256v1
case|:
return|return
literal|"nistp256"
return|;
case|case
name|NID_secp384r1
case|:
return|return
literal|"nistp384"
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
case|case
name|NID_secp521r1
case|:
return|return
literal|"nistp521"
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|int
name|sshkey_ec_nid_to_hash_alg
parameter_list|(
name|int
name|nid
parameter_list|)
block|{
name|int
name|kbits
init|=
name|sshkey_curve_nid_to_bits
argument_list|(
name|nid
argument_list|)
decl_stmt|;
if|if
condition|(
name|kbits
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* RFC5656 section 6.2.1 */
if|if
condition|(
name|kbits
operator|<=
literal|256
condition|)
return|return
name|SSH_DIGEST_SHA256
return|;
elseif|else
if|if
condition|(
name|kbits
operator|<=
literal|384
condition|)
return|return
name|SSH_DIGEST_SHA384
return|;
else|else
return|return
name|SSH_DIGEST_SHA512
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_OPENSSL */
end_comment

begin_function
specifier|static
name|void
name|cert_free
parameter_list|(
name|struct
name|sshkey_cert
modifier|*
name|cert
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|cert
operator|==
name|NULL
condition|)
return|return;
name|sshbuf_free
argument_list|(
name|cert
operator|->
name|certblob
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|cert
operator|->
name|critical
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|cert
operator|->
name|extensions
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cert
operator|->
name|key_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cert
operator|->
name|nprincipals
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|cert
operator|->
name|principals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cert
operator|->
name|principals
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|cert
operator|->
name|signature_key
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|cert
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cert
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sshkey_cert
modifier|*
name|cert_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sshkey_cert
modifier|*
name|cert
decl_stmt|;
if|if
condition|(
operator|(
name|cert
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cert
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|cert
operator|->
name|certblob
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cert
operator|->
name|critical
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cert
operator|->
name|extensions
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|cert_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cert
operator|->
name|key_id
operator|=
name|NULL
expr_stmt|;
name|cert
operator|->
name|principals
operator|=
name|NULL
expr_stmt|;
name|cert
operator|->
name|signature_key
operator|=
name|NULL
expr_stmt|;
return|return
name|cert
return|;
block|}
end_function

begin_function
name|struct
name|sshkey
modifier|*
name|sshkey_new
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|k
decl_stmt|;
ifdef|#
directive|ifdef
name|WITH_OPENSSL
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|DSA
modifier|*
name|dsa
decl_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
if|if
condition|(
operator|(
name|k
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|k
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|k
operator|->
name|ecdsa
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|ecdsa_nid
operator|=
operator|-
literal|1
expr_stmt|;
name|k
operator|->
name|dsa
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|rsa
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|cert
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|ed25519_sk
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|ed25519_pk
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
operator|(
name|rsa
operator|=
name|RSA_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rsa
operator|->
name|n
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rsa
operator|->
name|e
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rsa
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|k
operator|->
name|rsa
operator|=
name|rsa
expr_stmt|;
break|break;
case|case
name|KEY_DSA
case|:
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
operator|(
name|dsa
operator|=
name|DSA_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dsa
operator|->
name|p
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dsa
operator|->
name|q
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dsa
operator|->
name|g
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dsa
operator|->
name|pub_key
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dsa
operator|!=
name|NULL
condition|)
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|k
operator|->
name|dsa
operator|=
name|dsa
expr_stmt|;
break|break;
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ECDSA_CERT
case|:
comment|/* Cannot do anything until we know the group */
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
comment|/* no need to prealloc */
break|break;
case|case
name|KEY_UNSPEC
case|:
break|break;
default|default:
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|k
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|->
name|cert
operator|=
name|cert_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|k
return|;
block|}
end_function

begin_function
name|int
name|sshkey_add_private
parameter_list|(
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA_CERT
case|:
define|#
directive|define
name|bn_maybe_alloc_failed
parameter_list|(
name|p
parameter_list|)
value|(p == NULL&& (p = BN_new()) == NULL)
if|if
condition|(
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|||
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|||
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|||
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|||
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|dmq1
argument_list|)
operator|||
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|dmp1
argument_list|)
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
break|break;
case|case
name|KEY_DSA
case|:
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
name|bn_maybe_alloc_failed
argument_list|(
name|k
operator|->
name|dsa
operator|->
name|priv_key
argument_list|)
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
break|break;
undef|#
directive|undef
name|bn_maybe_alloc_failed
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ECDSA_CERT
case|:
comment|/* Cannot do anything until we know the group */
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
comment|/* no need to prealloc */
break|break;
case|case
name|KEY_UNSPEC
case|:
break|break;
default|default:
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|sshkey
modifier|*
name|sshkey_new_private
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|k
init|=
name|sshkey_new
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sshkey_add_private
argument_list|(
name|k
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|k
return|;
block|}
end_function

begin_function
name|void
name|sshkey_free
parameter_list|(
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
name|k
operator|->
name|rsa
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|k
operator|->
name|rsa
argument_list|)
expr_stmt|;
name|k
operator|->
name|rsa
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|KEY_DSA
case|:
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
name|k
operator|->
name|dsa
operator|!=
name|NULL
condition|)
name|DSA_free
argument_list|(
name|k
operator|->
name|dsa
argument_list|)
expr_stmt|;
name|k
operator|->
name|dsa
operator|=
name|NULL
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ECDSA_CERT
case|:
if|if
condition|(
name|k
operator|->
name|ecdsa
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
name|k
operator|->
name|ecdsa
operator|=
name|NULL
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
if|if
condition|(
name|k
operator|->
name|ed25519_pk
condition|)
block|{
name|explicit_bzero
argument_list|(
name|k
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
operator|->
name|ed25519_pk
argument_list|)
expr_stmt|;
name|k
operator|->
name|ed25519_pk
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|->
name|ed25519_sk
condition|)
block|{
name|explicit_bzero
argument_list|(
name|k
operator|->
name|ed25519_sk
argument_list|,
name|ED25519_SK_SZ
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
operator|->
name|ed25519_sk
argument_list|)
expr_stmt|;
name|k
operator|->
name|ed25519_sk
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|KEY_UNSPEC
case|:
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|k
argument_list|)
condition|)
name|cert_free
argument_list|(
name|k
operator|->
name|cert
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|k
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cert_compare
parameter_list|(
name|struct
name|sshkey_cert
modifier|*
name|a
parameter_list|,
name|struct
name|sshkey_cert
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|NULL
operator|&&
name|b
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sshbuf_len
argument_list|(
name|a
operator|->
name|certblob
argument_list|)
operator|!=
name|sshbuf_len
argument_list|(
name|b
operator|->
name|certblob
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|timingsafe_bcmp
argument_list|(
name|sshbuf_ptr
argument_list|(
name|a
operator|->
name|certblob
argument_list|)
argument_list|,
name|sshbuf_ptr
argument_list|(
name|b
operator|->
name|certblob
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|a
operator|->
name|certblob
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Compare public portions of key only, allowing comparisons between  * certificates and plain keys too.  */
end_comment

begin_function
name|int
name|sshkey_equal_public
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WITH_OPENSSL
argument_list|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_HAS_ECC
argument_list|)
name|BN_CTX
modifier|*
name|bnctx
decl_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL&& OPENSSL_HAS_ECC */
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
operator|||
name|sshkey_type_plain
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|!=
name|sshkey_type_plain
argument_list|(
name|b
operator|->
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|a
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA_CERT
case|:
case|case
name|KEY_RSA
case|:
return|return
name|a
operator|->
name|rsa
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|rsa
operator|!=
name|NULL
operator|&&
name|BN_cmp
argument_list|(
name|a
operator|->
name|rsa
operator|->
name|e
argument_list|,
name|b
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|BN_cmp
argument_list|(
name|a
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|b
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|==
literal|0
return|;
case|case
name|KEY_DSA_CERT
case|:
case|case
name|KEY_DSA
case|:
return|return
name|a
operator|->
name|dsa
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|dsa
operator|!=
name|NULL
operator|&&
name|BN_cmp
argument_list|(
name|a
operator|->
name|dsa
operator|->
name|p
argument_list|,
name|b
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|==
literal|0
operator|&&
name|BN_cmp
argument_list|(
name|a
operator|->
name|dsa
operator|->
name|q
argument_list|,
name|b
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|==
literal|0
operator|&&
name|BN_cmp
argument_list|(
name|a
operator|->
name|dsa
operator|->
name|g
argument_list|,
name|b
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|==
literal|0
operator|&&
name|BN_cmp
argument_list|(
name|a
operator|->
name|dsa
operator|->
name|pub_key
argument_list|,
name|b
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|==
literal|0
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA_CERT
case|:
case|case
name|KEY_ECDSA
case|:
if|if
condition|(
name|a
operator|->
name|ecdsa
operator|==
name|NULL
operator|||
name|b
operator|->
name|ecdsa
operator|==
name|NULL
operator|||
name|EC_KEY_get0_public_key
argument_list|(
name|a
operator|->
name|ecdsa
argument_list|)
operator|==
name|NULL
operator|||
name|EC_KEY_get0_public_key
argument_list|(
name|b
operator|->
name|ecdsa
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|bnctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EC_GROUP_cmp
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|a
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_group
argument_list|(
name|b
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|0
operator|||
name|EC_POINT_cmp
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|a
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|a
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|b
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
return|return
name|a
operator|->
name|ed25519_pk
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|ed25519_pk
operator|!=
name|NULL
operator|&&
name|memcmp
argument_list|(
name|a
operator|->
name|ed25519_pk
argument_list|,
name|b
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
operator|==
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|sshkey_equal
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
operator|||
name|a
operator|->
name|type
operator|!=
name|b
operator|->
name|type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cert_compare
argument_list|(
name|a
operator|->
name|cert
argument_list|,
name|b
operator|->
name|cert
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|sshkey_equal_public
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|to_blob_buf
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|,
name|int
name|force_plain
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|cert
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_EXPECTED_CERT
return|;
if|if
condition|(
name|sshbuf_len
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_ERR_KEY_LACKS_CERTBLOB
return|;
block|}
name|type
operator|=
name|force_plain
condition|?
name|sshkey_type_plain
argument_list|(
name|key
operator|->
name|type
argument_list|)
else|:
name|key
operator|->
name|type
expr_stmt|;
name|typename
operator|=
name|sshkey_ssh_name_from_type_nid
argument_list|(
name|type
argument_list|,
name|key
operator|->
name|ecdsa_nid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA_CERT
case|:
case|case
name|KEY_ECDSA_CERT
case|:
case|case
name|KEY_RSA_CERT
case|:
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519_CERT
case|:
comment|/* Use the existing blob */
comment|/* XXX modified flag? */
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
break|break;
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA
case|:
if|if
condition|(
name|key
operator|->
name|dsa
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|typename
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
if|if
condition|(
name|key
operator|->
name|ecdsa
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|typename
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|sshkey_curve_nid_to_name
argument_list|(
name|key
operator|->
name|ecdsa_nid
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_eckey
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ecdsa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
break|break;
endif|#
directive|endif
case|case
name|KEY_RSA
case|:
if|if
condition|(
name|key
operator|->
name|rsa
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|typename
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
if|if
condition|(
name|key
operator|->
name|ed25519_pk
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|typename
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_string
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
break|break;
default|default:
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sshkey_putb
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|)
block|{
return|return
name|to_blob_buf
argument_list|(
name|key
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sshkey_puts
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|tmp
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|r
operator|=
name|to_blob_buf
argument_list|(
name|key
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|sshkey_putb_plain
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|)
block|{
return|return
name|to_blob_buf
argument_list|(
name|key
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|to_blob
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
modifier|*
name|blobp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|int
name|force_plain
parameter_list|)
block|{
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blobp
operator|!=
name|NULL
condition|)
operator|*
name|blobp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|to_blob_buf
argument_list|(
name|key
argument_list|,
name|b
argument_list|,
name|force_plain
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|len
operator|=
name|sshbuf_len
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|blobp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|blobp
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
operator|*
name|blobp
argument_list|,
name|sshbuf_ptr
argument_list|(
name|b
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|sshkey_to_blob
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
modifier|*
name|blobp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
return|return
name|to_blob
argument_list|(
name|key
argument_list|,
name|blobp
argument_list|,
name|lenp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sshkey_plain_to_blob
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
modifier|*
name|blobp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
return|return
name|to_blob
argument_list|(
name|key
argument_list|,
name|blobp
argument_list|,
name|lenp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sshkey_fingerprint_raw
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|,
name|int
name|dgst_alg
parameter_list|,
name|u_char
modifier|*
modifier|*
name|retp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
name|u_char
modifier|*
name|blob
init|=
name|NULL
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|size_t
name|blob_len
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|retp
operator|!=
name|NULL
condition|)
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ssh_digest_bytes
argument_list|(
name|dgst_alg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|k
operator|->
name|type
operator|==
name|KEY_RSA1
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
name|int
name|nlen
init|=
name|BN_num_bytes
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|)
decl_stmt|;
name|int
name|elen
init|=
name|BN_num_bytes
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlen
operator|<
literal|0
operator|||
name|elen
operator|<
literal|0
operator|||
name|nlen
operator|>=
name|INT_MAX
operator|-
name|elen
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|blob_len
operator|=
name|nlen
operator|+
name|elen
expr_stmt|;
if|if
condition|(
operator|(
name|blob
operator|=
name|malloc
argument_list|(
name|blob_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|BN_bn2bin
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|e
argument_list|,
name|blob
operator|+
name|nlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|=
name|to_blob
argument_list|(
name|k
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|blob_len
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|SSH_DIGEST_MAX_LENGTH
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_digest_memory
argument_list|(
name|dgst_alg
argument_list|,
name|blob
argument_list|,
name|blob_len
argument_list|,
name|ret
argument_list|,
name|SSH_DIGEST_MAX_LENGTH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* success */
if|if
condition|(
name|retp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|retp
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|ssh_digest_bytes
argument_list|(
name|dgst_alg
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|blob
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|blob
argument_list|,
name|blob_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fingerprint_b64
parameter_list|(
specifier|const
name|char
modifier|*
name|alg
parameter_list|,
name|u_char
modifier|*
name|dgst_raw
parameter_list|,
name|size_t
name|dgst_raw_len
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|size_t
name|plen
init|=
name|strlen
argument_list|(
name|alg
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|rlen
init|=
operator|(
operator|(
name|dgst_raw_len
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|*
literal|4
operator|+
name|plen
operator|+
literal|1
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|dgst_raw_len
operator|>
literal|65536
operator|||
operator|(
name|ret
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|rlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|strlcpy
argument_list|(
name|ret
argument_list|,
name|alg
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|ret
argument_list|,
literal|":"
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dgst_raw_len
operator|==
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|b64_ntop
argument_list|(
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|,
name|ret
operator|+
name|plen
argument_list|,
name|rlen
operator|-
name|plen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|explicit_bzero
argument_list|(
name|ret
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Trim padding characters from end */
name|ret
index|[
name|strcspn
argument_list|(
name|ret
argument_list|,
literal|"="
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fingerprint_hex
parameter_list|(
specifier|const
name|char
modifier|*
name|alg
parameter_list|,
name|u_char
modifier|*
name|dgst_raw
parameter_list|,
name|size_t
name|dgst_raw_len
parameter_list|)
block|{
name|char
modifier|*
name|retval
decl_stmt|,
name|hex
index|[
literal|5
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|rlen
init|=
name|dgst_raw_len
operator|*
literal|3
operator|+
name|strlen
argument_list|(
name|alg
argument_list|)
operator|+
literal|2
decl_stmt|;
if|if
condition|(
name|dgst_raw_len
operator|>
literal|65536
operator|||
operator|(
name|retval
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|rlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|strlcpy
argument_list|(
name|retval
argument_list|,
name|alg
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|retval
argument_list|,
literal|":"
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dgst_raw_len
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|hex
argument_list|,
sizeof|sizeof
argument_list|(
name|hex
argument_list|)
argument_list|,
literal|"%s%02x"
argument_list|,
name|i
operator|>
literal|0
condition|?
literal|":"
else|:
literal|""
argument_list|,
name|dgst_raw
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|retval
argument_list|,
name|hex
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fingerprint_bubblebabble
parameter_list|(
name|u_char
modifier|*
name|dgst_raw
parameter_list|,
name|size_t
name|dgst_raw_len
parameter_list|)
block|{
name|char
name|vowels
index|[]
init|=
block|{
literal|'a'
block|,
literal|'e'
block|,
literal|'i'
block|,
literal|'o'
block|,
literal|'u'
block|,
literal|'y'
block|}
decl_stmt|;
name|char
name|consonants
index|[]
init|=
block|{
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'p'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'v'
block|,
literal|'z'
block|,
literal|'x'
block|}
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|rounds
decl_stmt|,
name|seed
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|rounds
operator|=
operator|(
name|dgst_raw_len
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|calloc
argument_list|(
name|rounds
argument_list|,
literal|6
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounds
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|idx0
decl_stmt|,
name|idx1
decl_stmt|,
name|idx2
decl_stmt|,
name|idx3
decl_stmt|,
name|idx4
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|rounds
operator|)
operator|||
operator|(
name|dgst_raw_len
operator|%
literal|2
operator|!=
literal|0
operator|)
condition|)
block|{
name|idx0
operator|=
operator|(
operator|(
operator|(
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|)
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
operator|+
name|seed
operator|)
operator|%
literal|6
expr_stmt|;
name|idx1
operator|=
operator|(
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|15
expr_stmt|;
name|idx2
operator|=
operator|(
operator|(
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
name|seed
operator|/
literal|6
operator|)
operator|)
operator|%
literal|6
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|vowels
index|[
name|idx0
index|]
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|consonants
index|[
name|idx1
index|]
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|vowels
index|[
name|idx2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|rounds
condition|)
block|{
name|idx3
operator|=
operator|(
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
operator|(
literal|2
operator|*
name|i
operator|)
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|15
expr_stmt|;
name|idx4
operator|=
operator|(
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
operator|(
literal|2
operator|*
name|i
operator|)
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|&
literal|15
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|consonants
index|[
name|idx3
index|]
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|consonants
index|[
name|idx4
index|]
expr_stmt|;
name|seed
operator|=
operator|(
operator|(
name|seed
operator|*
literal|5
operator|)
operator|+
operator|(
operator|(
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|)
operator|*
literal|7
operator|)
operator|+
operator|(
call|(
name|u_int
call|)
argument_list|(
name|dgst_raw
index|[
operator|(
literal|2
operator|*
name|i
operator|)
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|%
literal|36
expr_stmt|;
block|}
block|}
else|else
block|{
name|idx0
operator|=
name|seed
operator|%
literal|6
expr_stmt|;
name|idx1
operator|=
literal|16
expr_stmt|;
name|idx2
operator|=
name|seed
operator|/
literal|6
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|vowels
index|[
name|idx0
index|]
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|consonants
index|[
name|idx1
index|]
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
name|vowels
index|[
name|idx2
index|]
expr_stmt|;
block|}
block|}
name|retval
index|[
name|j
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|retval
index|[
name|j
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Draw an ASCII-Art representing the fingerprint so human brain can  * profit from its built-in pattern recognition ability.  * This technique is called "random art" and can be found in some  * scientific publications like this original paper:  *  * "Hash Visualization: a New Technique to improve Real-World Security",  * Perrig A. and Song D., 1999, International Workshop on Cryptographic  * Techniques and E-Commerce (CrypTEC '99)  * sparrow.ece.cmu.edu/~adrian/projects/validation/validation.pdf  *  * The subject came up in a talk by Dan Kaminsky, too.  *  * If you see the picture is different, the key is different.  * If the picture looks the same, you still know nothing.  *  * The algorithm used here is a worm crawling over a discrete plane,  * leaving a trace (augmenting the field) everywhere it goes.  * Movement is taken from dgst_raw 2bit-wise.  Bumping into walls  * makes the respective movement vector be ignored for this turn.  * Graphs are not unambiguous, because circles in graphs can be  * walked in either direction.  */
end_comment

begin_comment
comment|/*  * Field sizes for the random art.  Have to be odd, so the starting point  * can be in the exact middle of the picture, and FLDBASE should be>=8 .  * Else pictures would be too dense, and drawing the frame would  * fail, too, because the key type would not fit in anymore.  */
end_comment

begin_define
define|#
directive|define
name|FLDBASE
value|8
end_define

begin_define
define|#
directive|define
name|FLDSIZE_Y
value|(FLDBASE + 1)
end_define

begin_define
define|#
directive|define
name|FLDSIZE_X
value|(FLDBASE * 2 + 1)
end_define

begin_function
specifier|static
name|char
modifier|*
name|fingerprint_randomart
parameter_list|(
specifier|const
name|char
modifier|*
name|alg
parameter_list|,
name|u_char
modifier|*
name|dgst_raw
parameter_list|,
name|size_t
name|dgst_raw_len
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
comment|/* 	 * Chars to be used after each other every time the worm 	 * intersects with itself.  Matter of taste. 	 */
name|char
modifier|*
name|augmentation_string
init|=
literal|" .o+=*BOX@%&#/^SE"
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|title
index|[
name|FLDSIZE_X
index|]
decl_stmt|,
name|hash
index|[
name|FLDSIZE_X
index|]
decl_stmt|;
name|u_char
name|field
index|[
name|FLDSIZE_X
index|]
index|[
name|FLDSIZE_Y
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|tlen
decl_stmt|,
name|hlen
decl_stmt|;
name|u_int
name|b
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|augmentation_string
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|calloc
argument_list|(
operator|(
name|FLDSIZE_X
operator|+
literal|3
operator|)
argument_list|,
operator|(
name|FLDSIZE_Y
operator|+
literal|2
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* initialize field */
name|memset
argument_list|(
name|field
argument_list|,
literal|0
argument_list|,
name|FLDSIZE_X
operator|*
name|FLDSIZE_Y
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|FLDSIZE_X
operator|/
literal|2
expr_stmt|;
name|y
operator|=
name|FLDSIZE_Y
operator|/
literal|2
expr_stmt|;
comment|/* process raw key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dgst_raw_len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|input
decl_stmt|;
comment|/* each byte conveys four 2-bit move commands */
name|input
operator|=
name|dgst_raw
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
name|b
operator|++
control|)
block|{
comment|/* evaluate 2 bit, rest is shifted later */
name|x
operator|+=
operator|(
name|input
operator|&
literal|0x1
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
operator|(
name|input
operator|&
literal|0x2
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
comment|/* assure we are still in bounds */
name|x
operator|=
name|MAXIMUM
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|MAXIMUM
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|MINIMUM
argument_list|(
name|x
argument_list|,
name|FLDSIZE_X
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|MINIMUM
argument_list|(
name|y
argument_list|,
name|FLDSIZE_Y
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* augment the field */
if|if
condition|(
name|field
index|[
name|x
index|]
index|[
name|y
index|]
operator|<
name|len
operator|-
literal|2
condition|)
name|field
index|[
name|x
index|]
index|[
name|y
index|]
operator|++
expr_stmt|;
name|input
operator|=
name|input
operator|>>
literal|2
expr_stmt|;
block|}
block|}
comment|/* mark starting point and end point*/
name|field
index|[
name|FLDSIZE_X
operator|/
literal|2
index|]
index|[
name|FLDSIZE_Y
operator|/
literal|2
index|]
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|field
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|len
expr_stmt|;
comment|/* assemble title */
name|r
operator|=
name|snprintf
argument_list|(
name|title
argument_list|,
sizeof|sizeof
argument_list|(
name|title
argument_list|)
argument_list|,
literal|"[%s %u]"
argument_list|,
name|sshkey_type
argument_list|(
name|k
argument_list|)
argument_list|,
name|sshkey_size
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If [type size] won't fit, then try [type]; fits "[ED25519-CERT]" */
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|r
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|title
argument_list|)
condition|)
name|r
operator|=
name|snprintf
argument_list|(
name|title
argument_list|,
sizeof|sizeof
argument_list|(
name|title
argument_list|)
argument_list|,
literal|"[%s]"
argument_list|,
name|sshkey_type
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|tlen
operator|=
operator|(
name|r
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|title
argument_list|)
expr_stmt|;
comment|/* assemble hash ID. */
name|r
operator|=
name|snprintf
argument_list|(
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|,
literal|"[%s]"
argument_list|,
name|alg
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|r
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|hash
argument_list|)
expr_stmt|;
comment|/* output upper border */
name|p
operator|=
name|retval
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FLDSIZE_X
operator|-
name|tlen
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|title
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|tlen
expr_stmt|;
for|for
control|(
name|i
operator|+=
name|tlen
init|;
name|i
operator|<
name|FLDSIZE_X
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* output content */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|FLDSIZE_Y
condition|;
name|y
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'|'
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|FLDSIZE_X
condition|;
name|x
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|augmentation_string
index|[
name|MINIMUM
argument_list|(
name|field
index|[
name|x
index|]
index|[
name|y
index|]
argument_list|,
name|len
argument_list|)
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'|'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* output lower border */
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FLDSIZE_X
operator|-
name|hlen
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|hash
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hlen
expr_stmt|;
for|for
control|(
name|i
operator|+=
name|hlen
init|;
name|i
operator|<
name|FLDSIZE_X
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sshkey_fingerprint
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|,
name|int
name|dgst_alg
parameter_list|,
name|enum
name|sshkey_fp_rep
name|dgst_rep
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|dgst_raw
decl_stmt|;
name|size_t
name|dgst_raw_len
decl_stmt|;
if|if
condition|(
name|sshkey_fingerprint_raw
argument_list|(
name|k
argument_list|,
name|dgst_alg
argument_list|,
operator|&
name|dgst_raw
argument_list|,
operator|&
name|dgst_raw_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|dgst_rep
condition|)
block|{
case|case
name|SSH_FP_DEFAULT
case|:
if|if
condition|(
name|dgst_alg
operator|==
name|SSH_DIGEST_MD5
condition|)
block|{
name|retval
operator|=
name|fingerprint_hex
argument_list|(
name|ssh_digest_alg_name
argument_list|(
name|dgst_alg
argument_list|)
argument_list|,
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|fingerprint_b64
argument_list|(
name|ssh_digest_alg_name
argument_list|(
name|dgst_alg
argument_list|)
argument_list|,
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSH_FP_HEX
case|:
name|retval
operator|=
name|fingerprint_hex
argument_list|(
name|ssh_digest_alg_name
argument_list|(
name|dgst_alg
argument_list|)
argument_list|,
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_FP_BASE64
case|:
name|retval
operator|=
name|fingerprint_b64
argument_list|(
name|ssh_digest_alg_name
argument_list|(
name|dgst_alg
argument_list|)
argument_list|,
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_FP_BUBBLEBABBLE
case|:
name|retval
operator|=
name|fingerprint_bubblebabble
argument_list|(
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSH_FP_RANDOMART
case|:
name|retval
operator|=
name|fingerprint_randomart
argument_list|(
name|ssh_digest_alg_name
argument_list|(
name|dgst_alg
argument_list|)
argument_list|,
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
default|default:
name|explicit_bzero
argument_list|(
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dgst_raw
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|explicit_bzero
argument_list|(
name|dgst_raw
argument_list|,
name|dgst_raw_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dgst_raw
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_SSH1
end_ifdef

begin_comment
comment|/*  * Reads a multiple-precision integer in decimal from the buffer, and advances  * the pointer.  The integer must already be initialized.  This function is  * permitted to modify the buffer.  This leaves *cpp to point just beyond the  * last processed character.  */
end_comment

begin_function
specifier|static
name|int
name|read_decimal_bignum
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|BIGNUM
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|e
decl_stmt|;
name|int
name|skip
init|=
literal|1
decl_stmt|;
comment|/* skip white space */
name|cp
operator|=
operator|*
name|cpp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
name|e
operator|=
name|strspn
argument_list|(
name|cp
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
if|if
condition|(
name|e
operator|>
name|SSHBUF_MAX_BIGNUM
operator|*
literal|3
condition|)
return|return
name|SSH_ERR_BIGNUM_TOO_LARGE
return|;
if|if
condition|(
name|cp
index|[
name|e
index|]
operator|==
literal|'\0'
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|" \t\r\n"
argument_list|,
name|cp
index|[
name|e
index|]
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
name|cp
index|[
name|e
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|BN_dec2bn
argument_list|(
operator|&
name|v
argument_list|,
name|cp
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
operator|*
name|cpp
operator|=
name|cp
operator|+
name|e
operator|+
name|skip
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_SSH1 */
end_comment

begin_comment
comment|/* returns 0 ok, and< 0 error */
end_comment

begin_function
name|int
name|sshkey_read
parameter_list|(
name|struct
name|sshkey
modifier|*
name|ret
parameter_list|,
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|k
decl_stmt|;
name|int
name|retval
init|=
name|SSH_ERR_INVALID_FORMAT
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|space
decl_stmt|;
name|int
name|r
decl_stmt|,
name|type
decl_stmt|,
name|curve_nid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|blob
decl_stmt|;
ifdef|#
directive|ifdef
name|WITH_SSH1
name|u_long
name|bits
decl_stmt|;
endif|#
directive|endif
comment|/* WITH_SSH1 */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
name|cp
operator|=
operator|*
name|cpp
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|type
condition|)
block|{
case|case
name|KEY_RSA1
case|:
ifdef|#
directive|ifdef
name|WITH_SSH1
comment|/* Get number of bits. */
name|bits
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
literal|" \t\r\n"
argument_list|,
operator|*
name|ep
argument_list|)
operator|==
name|NULL
operator|||
name|bits
operator|==
literal|0
operator|||
name|bits
operator|>
name|SSHBUF_MAX_BIGNUM
operator|*
literal|8
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
comment|/* Bad bit count... */
comment|/* Get public exponent, public modulus. */
if|if
condition|(
operator|(
name|r
operator|=
name|read_decimal_bignum
argument_list|(
operator|&
name|ep
argument_list|,
name|ret
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|read_decimal_bignum
argument_list|(
operator|&
name|ep
argument_list|,
name|ret
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
comment|/* validate the claimed number of bits */
if|if
condition|(
name|BN_num_bits
argument_list|(
name|ret
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|bits
condition|)
return|return
name|SSH_ERR_KEY_BITS_MISMATCH
return|;
operator|*
name|cpp
operator|=
name|ep
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* WITH_SSH1 */
break|break;
case|case
name|KEY_UNSPEC
case|:
case|case
name|KEY_RSA
case|:
case|case
name|KEY_DSA
case|:
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_DSA_CERT
case|:
case|case
name|KEY_ECDSA_CERT
case|:
case|case
name|KEY_RSA_CERT
case|:
case|case
name|KEY_ED25519_CERT
case|:
name|space
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
operator|*
name|space
operator|=
literal|'\0'
expr_stmt|;
name|type
operator|=
name|sshkey_type_from_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshkey_type_plain
argument_list|(
name|type
argument_list|)
operator|==
name|KEY_ECDSA
operator|&&
operator|(
name|curve_nid
operator|=
name|sshkey_ecdsa_nid_from_name
argument_list|(
name|cp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SSH_ERR_EC_CURVE_INVALID
return|;
operator|*
name|space
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|KEY_UNSPEC
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
name|cp
operator|=
name|space
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
if|if
condition|(
name|ret
operator|->
name|type
operator|!=
name|KEY_UNSPEC
operator|&&
name|ret
operator|->
name|type
operator|!=
name|type
condition|)
return|return
name|SSH_ERR_KEY_TYPE_MISMATCH
return|;
if|if
condition|(
operator|(
name|blob
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
comment|/* trim comment */
name|space
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
comment|/* advance 'space': skip whitespace */
operator|*
name|space
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|space
operator|==
literal|' '
operator|||
operator|*
name|space
operator|==
literal|'\t'
condition|)
name|space
operator|++
expr_stmt|;
name|ep
operator|=
name|space
expr_stmt|;
block|}
else|else
name|ep
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_b64tod
argument_list|(
name|blob
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshbuf_free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_from_blob
argument_list|(
name|sshbuf_ptr
argument_list|(
name|blob
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshbuf_free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|sshbuf_free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|type
operator|!=
name|type
condition|)
block|{
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_KEY_TYPE_MISMATCH
return|;
block|}
if|if
condition|(
name|sshkey_type_plain
argument_list|(
name|type
argument_list|)
operator|==
name|KEY_ECDSA
operator|&&
name|curve_nid
operator|!=
name|k
operator|->
name|ecdsa_nid
condition|)
block|{
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_EC_CURVE_MISMATCH
return|;
block|}
name|ret
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sshkey_is_cert
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_EXPECTED_CERT
return|;
block|}
if|if
condition|(
name|ret
operator|->
name|cert
operator|!=
name|NULL
condition|)
name|cert_free
argument_list|(
name|ret
operator|->
name|cert
argument_list|)
expr_stmt|;
name|ret
operator|->
name|cert
operator|=
name|k
operator|->
name|cert
expr_stmt|;
name|k
operator|->
name|cert
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|sshkey_type_plain
argument_list|(
name|ret
operator|->
name|type
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA
case|:
if|if
condition|(
name|ret
operator|->
name|rsa
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|ret
operator|->
name|rsa
argument_list|)
expr_stmt|;
name|ret
operator|->
name|rsa
operator|=
name|k
operator|->
name|rsa
expr_stmt|;
name|k
operator|->
name|rsa
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PK
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|ret
operator|->
name|rsa
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|KEY_DSA
case|:
if|if
condition|(
name|ret
operator|->
name|dsa
operator|!=
name|NULL
condition|)
name|DSA_free
argument_list|(
name|ret
operator|->
name|dsa
argument_list|)
expr_stmt|;
name|ret
operator|->
name|dsa
operator|=
name|k
operator|->
name|dsa
expr_stmt|;
name|k
operator|->
name|dsa
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PK
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|ret
operator|->
name|dsa
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
if|if
condition|(
name|ret
operator|->
name|ecdsa
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|ret
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
name|ret
operator|->
name|ecdsa
operator|=
name|k
operator|->
name|ecdsa
expr_stmt|;
name|ret
operator|->
name|ecdsa_nid
operator|=
name|k
operator|->
name|ecdsa_nid
expr_stmt|;
name|k
operator|->
name|ecdsa
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|ecdsa_nid
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PK
name|sshkey_dump_ec_key
argument_list|(
name|ret
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
name|free
argument_list|(
name|ret
operator|->
name|ed25519_pk
argument_list|)
expr_stmt|;
name|ret
operator|->
name|ed25519_pk
operator|=
name|k
operator|->
name|ed25519_pk
expr_stmt|;
name|k
operator|->
name|ed25519_pk
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PK
comment|/* XXX */
endif|#
directive|endif
break|break;
block|}
operator|*
name|cpp
operator|=
name|ep
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
comment|/*XXXX*/
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
break|break;
default|default:
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|sshkey_to_base64
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|char
modifier|*
modifier|*
name|b64p
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|uu
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|b64p
operator|!=
name|NULL
condition|)
operator|*
name|b64p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_putb
argument_list|(
name|key
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|uu
operator|=
name|sshbuf_dtob64
argument_list|(
name|b
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Success */
if|if
condition|(
name|b64p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|b64p
operator|=
name|uu
expr_stmt|;
name|uu
operator|=
name|NULL
expr_stmt|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uu
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sshkey_format_rsa1
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
ifdef|#
directive|ifdef
name|WITH_SSH1
name|u_int
name|bits
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dec_e
init|=
name|NULL
decl_stmt|,
modifier|*
name|dec_n
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|rsa
operator|==
name|NULL
operator|||
name|key
operator|->
name|rsa
operator|->
name|e
operator|==
name|NULL
operator|||
name|key
operator|->
name|rsa
operator|->
name|n
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|dec_e
operator|=
name|BN_bn2dec
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dec_n
operator|=
name|BN_bn2dec
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* size of modulus 'n' */
if|if
condition|(
operator|(
name|bits
operator|=
name|BN_num_bits
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_putf
argument_list|(
name|b
argument_list|,
literal|"%u %s %s"
argument_list|,
name|bits
argument_list|,
name|dec_e
argument_list|,
name|dec_n
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Success */
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|dec_e
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|dec_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|dec_n
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|dec_n
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WITH_SSH1 */
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sshkey_format_text
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|char
modifier|*
name|uu
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|type
operator|==
name|KEY_RSA1
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_format_rsa1
argument_list|(
name|key
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Unsupported key types handled in sshkey_to_base64() */
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_to_base64
argument_list|(
name|key
argument_list|,
operator|&
name|uu
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_putf
argument_list|(
name|b
argument_list|,
literal|"%s %s"
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|,
name|uu
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|uu
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|sshkey_write
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_format_text
argument_list|(
name|key
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fwrite
argument_list|(
name|sshbuf_ptr
argument_list|(
name|b
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|b
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|errno
operator|=
name|EPIPE
expr_stmt|;
name|r
operator|=
name|SSH_ERR_SYSTEM_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Success */
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sshkey_cert_type
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
switch|switch
condition|(
name|k
operator|->
name|cert
operator|->
name|type
condition|)
block|{
case|case
name|SSH2_CERT_TYPE_USER
case|:
return|return
literal|"user"
return|;
case|case
name|SSH2_CERT_TYPE_HOST
case|:
return|return
literal|"host"
return|;
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_function
specifier|static
name|int
name|rsa_generate_private_key
parameter_list|(
name|u_int
name|bits
parameter_list|,
name|RSA
modifier|*
modifier|*
name|rsap
parameter_list|)
block|{
name|RSA
modifier|*
name|private
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|f4
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|rsap
operator|==
name|NULL
operator|||
name|bits
operator|<
name|SSH_RSA_MINIMUM_MODULUS_SIZE
operator|||
name|bits
operator|>
name|SSHBUF_MAX_BIGNUM
operator|*
literal|8
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
operator|*
name|rsap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|private
operator|=
name|RSA_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|f4
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|f4
argument_list|,
name|RSA_F4
argument_list|)
operator|||
operator|!
name|RSA_generate_key_ex
argument_list|(
name|private
argument_list|,
name|bits
argument_list|,
name|f4
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|rsap
operator|=
name|private
expr_stmt|;
name|private
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|private
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|private
argument_list|)
expr_stmt|;
if|if
condition|(
name|f4
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|f4
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsa_generate_private_key
parameter_list|(
name|u_int
name|bits
parameter_list|,
name|DSA
modifier|*
modifier|*
name|dsap
parameter_list|)
block|{
name|DSA
modifier|*
name|private
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|dsap
operator|==
name|NULL
operator|||
name|bits
operator|!=
literal|1024
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|private
operator|=
name|DSA_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|dsap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|DSA_generate_parameters_ex
argument_list|(
name|private
argument_list|,
name|bits
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|DSA_generate_key
argument_list|(
name|private
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|dsap
operator|=
name|private
expr_stmt|;
name|private
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|private
operator|!=
name|NULL
condition|)
name|DSA_free
argument_list|(
name|private
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
end_ifdef

begin_function
name|int
name|sshkey_ecdsa_key_to_nid
parameter_list|(
name|EC_KEY
modifier|*
name|k
parameter_list|)
block|{
name|EC_GROUP
modifier|*
name|eg
decl_stmt|;
name|int
name|nids
index|[]
init|=
block|{
name|NID_X9_62_prime256v1
block|,
name|NID_secp384r1
block|,
ifdef|#
directive|ifdef
name|OPENSSL_HAS_NISTP521
name|NID_secp521r1
block|,
endif|#
directive|endif
comment|/* OPENSSL_HAS_NISTP521 */
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|nid
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|BN_CTX
modifier|*
name|bnctx
decl_stmt|;
specifier|const
name|EC_GROUP
modifier|*
name|g
init|=
name|EC_KEY_get0_group
argument_list|(
name|k
argument_list|)
decl_stmt|;
comment|/* 	 * The group may be stored in a ASN.1 encoded private key in one of two 	 * ways: as a "named group", which is reconstituted by ASN.1 object ID 	 * or explicit group parameters encoded into the key blob. Only the 	 * "named group" case sets the group NID for us, but we can figure 	 * it out for the other case by comparing against all the groups that 	 * are supported. 	 */
if|if
condition|(
operator|(
name|nid
operator|=
name|EC_GROUP_get_curve_name
argument_list|(
name|g
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|nid
return|;
if|if
condition|(
operator|(
name|bnctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nids
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|eg
operator|=
name|EC_GROUP_new_by_curve_name
argument_list|(
name|nids
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|EC_GROUP_cmp
argument_list|(
name|g
argument_list|,
name|eg
argument_list|,
name|bnctx
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|EC_GROUP_free
argument_list|(
name|eg
argument_list|)
expr_stmt|;
block|}
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nids
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Use the group with the NID attached */
name|EC_GROUP_set_asn1_flag
argument_list|(
name|eg
argument_list|,
name|OPENSSL_EC_NAMED_CURVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|EC_KEY_set_group
argument_list|(
name|k
argument_list|,
name|eg
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|EC_GROUP_free
argument_list|(
name|eg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|nids
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecdsa_generate_private_key
parameter_list|(
name|u_int
name|bits
parameter_list|,
name|int
modifier|*
name|nid
parameter_list|,
name|EC_KEY
modifier|*
modifier|*
name|ecdsap
parameter_list|)
block|{
name|EC_KEY
modifier|*
name|private
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|nid
operator|==
name|NULL
operator|||
name|ecdsap
operator|==
name|NULL
operator|||
operator|(
operator|*
name|nid
operator|=
name|sshkey_ecdsa_bits_to_nid
argument_list|(
name|bits
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
operator|*
name|ecdsap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|private
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
operator|*
name|nid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|EC_KEY_generate_key
argument_list|(
name|private
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|EC_KEY_set_asn1_flag
argument_list|(
name|private
argument_list|,
name|OPENSSL_EC_NAMED_CURVE
argument_list|)
expr_stmt|;
operator|*
name|ecdsap
operator|=
name|private
expr_stmt|;
name|private
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|private
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|private
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_HAS_ECC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_OPENSSL */
end_comment

begin_function
name|int
name|sshkey_generate
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|k
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|keyp
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|sshkey_new
argument_list|(
name|KEY_UNSPEC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KEY_ED25519
case|:
if|if
condition|(
operator|(
name|k
operator|->
name|ed25519_pk
operator|=
name|malloc
argument_list|(
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|k
operator|->
name|ed25519_sk
operator|=
name|malloc
argument_list|(
name|ED25519_SK_SZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
break|break;
block|}
name|crypto_sign_ed25519_keypair
argument_list|(
name|k
operator|->
name|ed25519_pk
argument_list|,
name|k
operator|->
name|ed25519_sk
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA
case|:
name|ret
operator|=
name|dsa_generate_private_key
argument_list|(
name|bits
argument_list|,
operator|&
name|k
operator|->
name|dsa
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
name|ret
operator|=
name|ecdsa_generate_private_key
argument_list|(
name|bits
argument_list|,
operator|&
name|k
operator|->
name|ecdsa_nid
argument_list|,
operator|&
name|k
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA1
case|:
name|ret
operator|=
name|rsa_generate_private_key
argument_list|(
name|bits
argument_list|,
operator|&
name|k
operator|->
name|rsa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
default|default:
name|ret
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|k
operator|->
name|type
operator|=
name|type
expr_stmt|;
operator|*
name|keyp
operator|=
name|k
expr_stmt|;
block|}
else|else
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|sshkey_cert_copy
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|from_key
parameter_list|,
name|struct
name|sshkey
modifier|*
name|to_key
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
specifier|const
name|struct
name|sshkey_cert
modifier|*
name|from
decl_stmt|;
name|struct
name|sshkey_cert
modifier|*
name|to
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|to_key
operator|->
name|cert
operator|!=
name|NULL
condition|)
block|{
name|cert_free
argument_list|(
name|to_key
operator|->
name|cert
argument_list|)
expr_stmt|;
name|to_key
operator|->
name|cert
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|from
operator|=
name|from_key
operator|->
name|cert
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|to
operator|=
name|to_key
operator|->
name|cert
operator|=
name|cert_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|to
operator|->
name|certblob
argument_list|,
name|from
operator|->
name|certblob
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|to
operator|->
name|critical
argument_list|,
name|from
operator|->
name|critical
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|to
operator|->
name|extensions
argument_list|,
name|from
operator|->
name|extensions
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
name|to
operator|->
name|serial
operator|=
name|from
operator|->
name|serial
expr_stmt|;
name|to
operator|->
name|type
operator|=
name|from
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|key_id
operator|==
name|NULL
condition|)
name|to
operator|->
name|key_id
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|to
operator|->
name|key_id
operator|=
name|strdup
argument_list|(
name|from
operator|->
name|key_id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|to
operator|->
name|valid_after
operator|=
name|from
operator|->
name|valid_after
expr_stmt|;
name|to
operator|->
name|valid_before
operator|=
name|from
operator|->
name|valid_before
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|signature_key
operator|==
name|NULL
condition|)
name|to
operator|->
name|signature_key
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_from_private
argument_list|(
name|from
operator|->
name|signature_key
argument_list|,
operator|&
name|to
operator|->
name|signature_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|from
operator|->
name|nprincipals
operator|>
name|SSHKEY_CERT_MAX_PRINCIPALS
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
name|from
operator|->
name|nprincipals
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|to
operator|->
name|principals
operator|=
name|calloc
argument_list|(
name|from
operator|->
name|nprincipals
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|principals
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|from
operator|->
name|nprincipals
condition|;
name|i
operator|++
control|)
block|{
name|to
operator|->
name|principals
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|from
operator|->
name|principals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|principals
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|to
operator|->
name|nprincipals
operator|=
name|i
expr_stmt|;
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
block|}
block|}
block|}
name|to
operator|->
name|nprincipals
operator|=
name|from
operator|->
name|nprincipals
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sshkey_from_private
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|pkp
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
operator|*
name|pkp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA
case|:
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|sshkey_new
argument_list|(
name|k
operator|->
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|BN_copy
argument_list|(
name|n
operator|->
name|dsa
operator|->
name|p
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|BN_copy
argument_list|(
name|n
operator|->
name|dsa
operator|->
name|q
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|BN_copy
argument_list|(
name|n
operator|->
name|dsa
operator|->
name|g
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|BN_copy
argument_list|(
name|n
operator|->
name|dsa
operator|->
name|pub_key
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|sshkey_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_ECDSA_CERT
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|sshkey_new
argument_list|(
name|k
operator|->
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|n
operator|->
name|ecdsa_nid
operator|=
name|k
operator|->
name|ecdsa_nid
expr_stmt|;
name|n
operator|->
name|ecdsa
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|k
operator|->
name|ecdsa_nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|ecdsa
operator|==
name|NULL
condition|)
block|{
name|sshkey_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
block|}
if|if
condition|(
name|EC_KEY_set_public_key
argument_list|(
name|n
operator|->
name|ecdsa
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|sshkey_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_LIBCRYPTO_ERROR
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|sshkey_new
argument_list|(
name|k
operator|->
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|BN_copy
argument_list|(
name|n
operator|->
name|rsa
operator|->
name|n
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|BN_copy
argument_list|(
name|n
operator|->
name|rsa
operator|->
name|e
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|sshkey_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|sshkey_new
argument_list|(
name|k
operator|->
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
name|k
operator|->
name|ed25519_pk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|ed25519_pk
operator|=
name|malloc
argument_list|(
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sshkey_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
block|}
name|memcpy
argument_list|(
name|n
operator|->
name|ed25519_pk
argument_list|,
name|k
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
block|}
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|k
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_cert_copy
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshkey_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
operator|*
name|pkp
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cert_parse
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|,
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|certbuf
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|principals
init|=
name|NULL
decl_stmt|,
modifier|*
name|crit
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|exts
init|=
name|NULL
decl_stmt|,
modifier|*
name|ca
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|sig
init|=
name|NULL
decl_stmt|;
name|size_t
name|signed_len
init|=
literal|0
decl_stmt|,
name|slen
init|=
literal|0
decl_stmt|,
name|kidlen
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
comment|/* Copy the entire key blob for verification and later serialisation */
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|,
name|certbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Parse body of certificate up to signature */
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_get_u64
argument_list|(
name|b
argument_list|,
operator|&
name|key
operator|->
name|cert
operator|->
name|serial
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_u32
argument_list|(
name|b
argument_list|,
operator|&
name|key
operator|->
name|cert
operator|->
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_cstring
argument_list|(
name|b
argument_list|,
operator|&
name|key
operator|->
name|cert
operator|->
name|key_id
argument_list|,
operator|&
name|kidlen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_froms
argument_list|(
name|b
argument_list|,
operator|&
name|principals
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_u64
argument_list|(
name|b
argument_list|,
operator|&
name|key
operator|->
name|cert
operator|->
name|valid_after
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_u64
argument_list|(
name|b
argument_list|,
operator|&
name|key
operator|->
name|cert
operator|->
name|valid_before
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_froms
argument_list|(
name|b
argument_list|,
operator|&
name|crit
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_froms
argument_list|(
name|b
argument_list|,
operator|&
name|exts
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_froms
argument_list|(
name|b
argument_list|,
operator|&
name|ca
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX debug print error for ret */
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Signature is left in the buffer so we can calculate this length */
name|signed_len
operator|=
name|sshbuf_len
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|-
name|sshbuf_len
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_get_string
argument_list|(
name|b
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|slen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|key
operator|->
name|cert
operator|->
name|type
operator|!=
name|SSH2_CERT_TYPE_USER
operator|&&
name|key
operator|->
name|cert
operator|->
name|type
operator|!=
name|SSH2_CERT_TYPE_HOST
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_KEY_CERT_UNKNOWN_TYPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Parse principals section */
while|while
condition|(
name|sshbuf_len
argument_list|(
name|principals
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|principal
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|oprincipals
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|cert
operator|->
name|nprincipals
operator|>=
name|SSHKEY_CERT_MAX_PRINCIPALS
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_get_cstring
argument_list|(
name|principals
argument_list|,
operator|&
name|principal
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|oprincipals
operator|=
name|key
operator|->
name|cert
operator|->
name|principals
expr_stmt|;
name|key
operator|->
name|cert
operator|->
name|principals
operator|=
name|reallocarray
argument_list|(
name|key
operator|->
name|cert
operator|->
name|principals
argument_list|,
name|key
operator|->
name|cert
operator|->
name|nprincipals
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|key
operator|->
name|cert
operator|->
name|principals
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|cert
operator|->
name|principals
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|principal
argument_list|)
expr_stmt|;
name|key
operator|->
name|cert
operator|->
name|principals
operator|=
name|oprincipals
expr_stmt|;
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|key
operator|->
name|cert
operator|->
name|principals
index|[
name|key
operator|->
name|cert
operator|->
name|nprincipals
operator|++
index|]
operator|=
name|principal
expr_stmt|;
block|}
comment|/* 	 * Stash a copies of the critical options and extensions sections 	 * for later use. 	 */
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|key
operator|->
name|cert
operator|->
name|critical
argument_list|,
name|crit
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|exts
operator|!=
name|NULL
operator|&&
operator|(
name|ret
operator|=
name|sshbuf_putb
argument_list|(
name|key
operator|->
name|cert
operator|->
name|extensions
argument_list|,
name|exts
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Validate critical options and extensions sections format. 	 */
while|while
condition|(
name|sshbuf_len
argument_list|(
name|crit
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|crit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|crit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshbuf_reset
argument_list|(
name|key
operator|->
name|cert
operator|->
name|critical
argument_list|)
expr_stmt|;
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
while|while
condition|(
name|exts
operator|!=
name|NULL
operator|&&
name|sshbuf_len
argument_list|(
name|exts
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|exts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|exts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshbuf_reset
argument_list|(
name|key
operator|->
name|cert
operator|->
name|extensions
argument_list|)
expr_stmt|;
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Parse CA key and check signature */
if|if
condition|(
name|sshkey_from_blob_internal
argument_list|(
name|ca
argument_list|,
operator|&
name|key
operator|->
name|cert
operator|->
name|signature_key
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_KEY_CERT_INVALID_SIGN_KEY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|sshkey_type_is_valid_ca
argument_list|(
name|key
operator|->
name|cert
operator|->
name|signature_key
operator|->
name|type
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_KEY_CERT_INVALID_SIGN_KEY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_verify
argument_list|(
name|key
operator|->
name|cert
operator|->
name|signature_key
argument_list|,
name|sig
argument_list|,
name|slen
argument_list|,
name|sshbuf_ptr
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
argument_list|,
name|signed_len
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Success */
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|sshbuf_free
argument_list|(
name|ca
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|crit
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|exts
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|principals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sig
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sshkey_from_blob_internal
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|int
name|allow_cert
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|char
modifier|*
name|ktype
init|=
name|NULL
decl_stmt|,
modifier|*
name|curve
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|pk
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|copy
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WITH_OPENSSL
argument_list|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_HAS_ECC
argument_list|)
name|EC_POINT
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL&& OPENSSL_HAS_ECC */
ifdef|#
directive|ifdef
name|DEBUG_PK
comment|/* XXX */
name|sshbuf_dump
argument_list|(
name|b
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|copy
operator|=
name|sshbuf_fromb
argument_list|(
name|b
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_get_cstring
argument_list|(
name|b
argument_list|,
operator|&
name|ktype
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|type
operator|=
name|sshkey_type_from_name
argument_list|(
name|ktype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allow_cert
operator|&&
name|sshkey_type_is_cert
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_KEY_CERT_INVALID_SIGN_KEY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA_CERT
case|:
comment|/* Skip nonce */
if|if
condition|(
name|sshbuf_get_string_direct
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
name|KEY_RSA
case|:
if|if
condition|(
operator|(
name|key
operator|=
name|sshkey_new
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_get_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|!=
literal|0
operator|||
name|sshbuf_get_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_PK
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|key
operator|->
name|rsa
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|KEY_DSA_CERT
case|:
comment|/* Skip nonce */
if|if
condition|(
name|sshbuf_get_string_direct
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
name|KEY_DSA
case|:
if|if
condition|(
operator|(
name|key
operator|=
name|sshkey_new
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_get_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|!=
literal|0
operator|||
name|sshbuf_get_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|!=
literal|0
operator|||
name|sshbuf_get_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|!=
literal|0
operator|||
name|sshbuf_get_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_PK
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|key
operator|->
name|dsa
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|KEY_ECDSA_CERT
case|:
comment|/* Skip nonce */
if|if
condition|(
name|sshbuf_get_string_direct
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* FALLTHROUGH */
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
if|if
condition|(
operator|(
name|key
operator|=
name|sshkey_new
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|key
operator|->
name|ecdsa_nid
operator|=
name|sshkey_ecdsa_nid_from_name
argument_list|(
name|ktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshbuf_get_cstring
argument_list|(
name|b
argument_list|,
operator|&
name|curve
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|key
operator|->
name|ecdsa_nid
operator|!=
name|sshkey_curve_name_to_nid
argument_list|(
name|curve
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_EC_CURVE_MISMATCH
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|key
operator|->
name|ecdsa
operator|!=
name|NULL
condition|)
name|EC_KEY_free
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|->
name|ecdsa
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|key
operator|->
name|ecdsa_nid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_EC_CURVE_INVALID
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|EC_POINT_new
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_get_ec
argument_list|(
name|b
argument_list|,
name|q
argument_list|,
name|EC_KEY_get0_group
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshkey_ec_validate_public
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_KEY_INVALID_EC_VALUE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|EC_KEY_set_public_key
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|,
name|q
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* XXX assume it is a allocation error */
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_PK
name|sshkey_dump_ec_point
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519_CERT
case|:
comment|/* Skip nonce */
if|if
condition|(
name|sshbuf_get_string_direct
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
name|KEY_ED25519
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_get_string
argument_list|(
name|b
argument_list|,
operator|&
name|pk
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|len
operator|!=
name|ED25519_PK_SZ
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|key
operator|=
name|sshkey_new
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|key
operator|->
name|ed25519_pk
operator|=
name|pk
expr_stmt|;
name|pk
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|KEY_UNSPEC
case|:
if|if
condition|(
operator|(
name|key
operator|=
name|sshkey_new
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
name|ret
operator|=
name|SSH_ERR_KEY_TYPE_UNKNOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Parse certificate potion */
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
name|ret
operator|=
name|cert_parse
argument_list|(
name|b
argument_list|,
name|key
argument_list|,
name|copy
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|key
operator|!=
name|NULL
operator|&&
name|sshbuf_len
argument_list|(
name|b
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|sshbuf_free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ktype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WITH_OPENSSL
argument_list|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_HAS_ECC
argument_list|)
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL&& OPENSSL_HAS_ECC */
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|sshkey_from_blob
parameter_list|(
specifier|const
name|u_char
modifier|*
name|blob
parameter_list|,
name|size_t
name|blen
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|b
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|sshbuf_from
argument_list|(
name|blob
argument_list|,
name|blen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|r
operator|=
name|sshkey_from_blob_internal
argument_list|(
name|b
argument_list|,
name|keyp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|sshkey_fromb
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
return|return
name|sshkey_from_blob_internal
argument_list|(
name|b
argument_list|,
name|keyp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sshkey_froms
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|b
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_froms
argument_list|(
name|buf
argument_list|,
operator|&
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
name|r
operator|=
name|sshkey_from_blob_internal
argument_list|(
name|b
argument_list|,
name|keyp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|sshkey_sign
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
modifier|*
name|sigp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|size_t
name|datalen
parameter_list|,
specifier|const
name|char
modifier|*
name|alg
parameter_list|,
name|u_int
name|compat
parameter_list|)
block|{
if|if
condition|(
name|sigp
operator|!=
name|NULL
condition|)
operator|*
name|sigp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|SSH_KEY_MAX_SIGN_DATA_SIZE
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
switch|switch
condition|(
name|key
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA_CERT
case|:
case|case
name|KEY_DSA
case|:
return|return
name|ssh_dss_sign
argument_list|(
name|key
argument_list|,
name|sigp
argument_list|,
name|lenp
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|compat
argument_list|)
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA_CERT
case|:
case|case
name|KEY_ECDSA
case|:
return|return
name|ssh_ecdsa_sign
argument_list|(
name|key
argument_list|,
name|sigp
argument_list|,
name|lenp
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|compat
argument_list|)
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
case|case
name|KEY_RSA_CERT
case|:
case|case
name|KEY_RSA
case|:
return|return
name|ssh_rsa_sign
argument_list|(
name|key
argument_list|,
name|sigp
argument_list|,
name|lenp
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|alg
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
return|return
name|ssh_ed25519_sign
argument_list|(
name|key
argument_list|,
name|sigp
argument_list|,
name|lenp
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|,
name|compat
argument_list|)
return|;
default|default:
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * ssh_key_verify returns 0 for a correct signature  and< 0 on error.  */
end_comment

begin_function
name|int
name|sshkey_verify
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sig
parameter_list|,
name|size_t
name|siglen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|,
name|u_int
name|compat
parameter_list|)
block|{
if|if
condition|(
name|siglen
operator|==
literal|0
operator|||
name|dlen
operator|>
name|SSH_KEY_MAX_SIGN_DATA_SIZE
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
switch|switch
condition|(
name|key
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA_CERT
case|:
case|case
name|KEY_DSA
case|:
return|return
name|ssh_dss_verify
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|compat
argument_list|)
return|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA_CERT
case|:
case|case
name|KEY_ECDSA
case|:
return|return
name|ssh_ecdsa_verify
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|compat
argument_list|)
return|;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
case|case
name|KEY_RSA_CERT
case|:
case|case
name|KEY_RSA
case|:
return|return
name|ssh_rsa_verify
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
case|case
name|KEY_ED25519_CERT
case|:
return|return
name|ssh_ed25519_verify
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|compat
argument_list|)
return|;
default|default:
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Converts a private to a public key */
end_comment

begin_function
name|int
name|sshkey_demote
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|dkp
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|pk
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
operator|*
name|dkp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pk
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|pk
operator|->
name|type
operator|=
name|k
operator|->
name|type
expr_stmt|;
name|pk
operator|->
name|flags
operator|=
name|k
operator|->
name|flags
expr_stmt|;
name|pk
operator|->
name|ecdsa_nid
operator|=
name|k
operator|->
name|ecdsa_nid
expr_stmt|;
name|pk
operator|->
name|dsa
operator|=
name|NULL
expr_stmt|;
name|pk
operator|->
name|ecdsa
operator|=
name|NULL
expr_stmt|;
name|pk
operator|->
name|rsa
operator|=
name|NULL
expr_stmt|;
name|pk
operator|->
name|ed25519_pk
operator|=
name|NULL
expr_stmt|;
name|pk
operator|->
name|ed25519_sk
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_cert_copy
argument_list|(
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* FALLTHROUGH */
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA
case|:
if|if
condition|(
operator|(
name|pk
operator|->
name|rsa
operator|=
name|RSA_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pk
operator|->
name|rsa
operator|->
name|e
operator|=
name|BN_dup
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pk
operator|->
name|rsa
operator|->
name|n
operator|=
name|BN_dup
argument_list|(
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_cert_copy
argument_list|(
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* FALLTHROUGH */
case|case
name|KEY_DSA
case|:
if|if
condition|(
operator|(
name|pk
operator|->
name|dsa
operator|=
name|DSA_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pk
operator|->
name|dsa
operator|->
name|p
operator|=
name|BN_dup
argument_list|(
name|k
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pk
operator|->
name|dsa
operator|->
name|q
operator|=
name|BN_dup
argument_list|(
name|k
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pk
operator|->
name|dsa
operator|->
name|g
operator|=
name|BN_dup
argument_list|(
name|k
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pk
operator|->
name|dsa
operator|->
name|pub_key
operator|=
name|BN_dup
argument_list|(
name|k
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|KEY_ECDSA_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_cert_copy
argument_list|(
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* FALLTHROUGH */
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
name|pk
operator|->
name|ecdsa
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|pk
operator|->
name|ecdsa_nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|ecdsa
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|EC_KEY_set_public_key
argument_list|(
name|pk
operator|->
name|ecdsa
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_cert_copy
argument_list|(
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* FALLTHROUGH */
case|case
name|KEY_ED25519
case|:
if|if
condition|(
name|k
operator|->
name|ed25519_pk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pk
operator|->
name|ed25519_pk
operator|=
name|malloc
argument_list|(
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|memcpy
argument_list|(
name|pk
operator|->
name|ed25519_pk
argument_list|,
name|k
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
name|SSH_ERR_KEY_TYPE_UNKNOWN
expr_stmt|;
name|fail
label|:
name|sshkey_free
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
operator|*
name|dkp
operator|=
name|pk
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a plain key to their _CERT equivalent */
end_comment

begin_function
name|int
name|sshkey_to_certified
parameter_list|(
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
name|int
name|newtype
decl_stmt|;
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA
case|:
name|newtype
operator|=
name|KEY_RSA_CERT
expr_stmt|;
break|break;
case|case
name|KEY_DSA
case|:
name|newtype
operator|=
name|KEY_DSA_CERT
expr_stmt|;
break|break;
case|case
name|KEY_ECDSA
case|:
name|newtype
operator|=
name|KEY_ECDSA_CERT
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
name|newtype
operator|=
name|KEY_ED25519_CERT
expr_stmt|;
break|break;
default|default:
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
block|}
if|if
condition|(
operator|(
name|k
operator|->
name|cert
operator|=
name|cert_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|k
operator|->
name|type
operator|=
name|newtype
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a certificate to its raw key equivalent */
end_comment

begin_function
name|int
name|sshkey_drop_cert
parameter_list|(
name|struct
name|sshkey
modifier|*
name|k
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sshkey_type_is_cert
argument_list|(
name|k
operator|->
name|type
argument_list|)
condition|)
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
name|cert_free
argument_list|(
name|k
operator|->
name|cert
argument_list|)
expr_stmt|;
name|k
operator|->
name|cert
operator|=
name|NULL
expr_stmt|;
name|k
operator|->
name|type
operator|=
name|sshkey_type_plain
argument_list|(
name|k
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Sign a certified key, (re-)generating the signed certblob. */
end_comment

begin_function
name|int
name|sshkey_certify
parameter_list|(
name|struct
name|sshkey
modifier|*
name|k
parameter_list|,
name|struct
name|sshkey
modifier|*
name|ca
parameter_list|,
specifier|const
name|char
modifier|*
name|alg
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|principals
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|ca_blob
init|=
name|NULL
decl_stmt|,
modifier|*
name|sig_blob
init|=
name|NULL
decl_stmt|,
name|nonce
index|[
literal|32
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|ca_len
decl_stmt|,
name|sig_len
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|cert
decl_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
operator|||
name|k
operator|->
name|cert
operator|==
name|NULL
operator|||
name|k
operator|->
name|cert
operator|->
name|certblob
operator|==
name|NULL
operator|||
name|ca
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|!
name|sshkey_is_cert
argument_list|(
name|k
argument_list|)
condition|)
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
if|if
condition|(
operator|!
name|sshkey_type_is_valid_ca
argument_list|(
name|ca
operator|->
name|type
argument_list|)
condition|)
return|return
name|SSH_ERR_KEY_CERT_INVALID_SIGN_KEY
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_to_blob
argument_list|(
name|ca
argument_list|,
operator|&
name|ca_blob
argument_list|,
operator|&
name|ca_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|SSH_ERR_KEY_CERT_INVALID_SIGN_KEY
return|;
name|cert
operator|=
name|k
operator|->
name|cert
operator|->
name|certblob
expr_stmt|;
comment|/* for readability */
name|sshbuf_reset
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|cert
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|k
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* -v01 certs put nonce first */
name|arc4random_buf
argument_list|(
operator|&
name|nonce
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_string
argument_list|(
name|cert
argument_list|,
name|nonce
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* XXX this substantially duplicates to_blob(); refactor */
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|cert
argument_list|,
name|sshkey_curve_nid_to_name
argument_list|(
name|k
operator|->
name|ecdsa_nid
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_ec
argument_list|(
name|cert
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_group
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519_CERT
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_string
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|ret
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_u64
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|serial
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_u32
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|key_id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|principals
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
operator|->
name|cert
operator|->
name|nprincipals
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_cstring
argument_list|(
name|principals
argument_list|,
name|k
operator|->
name|cert
operator|->
name|principals
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_stringb
argument_list|(
name|cert
argument_list|,
name|principals
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_u64
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|valid_after
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_u64
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|valid_before
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_stringb
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|critical
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_stringb
argument_list|(
name|cert
argument_list|,
name|k
operator|->
name|cert
operator|->
name|extensions
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|sshbuf_put_string
argument_list|(
name|cert
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* Reserved */
operator|(
name|ret
operator|=
name|sshbuf_put_string
argument_list|(
name|cert
argument_list|,
name|ca_blob
argument_list|,
name|ca_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Sign the whole mess */
if|if
condition|(
operator|(
name|ret
operator|=
name|sshkey_sign
argument_list|(
name|ca
argument_list|,
operator|&
name|sig_blob
argument_list|,
operator|&
name|sig_len
argument_list|,
name|sshbuf_ptr
argument_list|(
name|cert
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|cert
argument_list|)
argument_list|,
name|alg
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Append signature and we are done */
if|if
condition|(
operator|(
name|ret
operator|=
name|sshbuf_put_string
argument_list|(
name|cert
argument_list|,
name|sig_blob
argument_list|,
name|sig_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|sshbuf_reset
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sig_blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ca_blob
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|principals
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|sshkey_cert_check_authority
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|k
parameter_list|,
name|int
name|want_host
parameter_list|,
name|int
name|require_principal
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|principal_matches
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
operator|*
name|reason
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|want_host
condition|)
block|{
if|if
condition|(
name|k
operator|->
name|cert
operator|->
name|type
operator|!=
name|SSH2_CERT_TYPE_HOST
condition|)
block|{
operator|*
name|reason
operator|=
literal|"Certificate invalid: not a host certificate"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|k
operator|->
name|cert
operator|->
name|type
operator|!=
name|SSH2_CERT_TYPE_USER
condition|)
block|{
operator|*
name|reason
operator|=
literal|"Certificate invalid: not a user certificate"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
block|}
if|if
condition|(
name|now
operator|<
literal|0
condition|)
block|{
comment|/* yikes - system clock before epoch! */
operator|*
name|reason
operator|=
literal|"Certificate invalid: not yet valid"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
if|if
condition|(
operator|(
name|u_int64_t
operator|)
name|now
operator|<
name|k
operator|->
name|cert
operator|->
name|valid_after
condition|)
block|{
operator|*
name|reason
operator|=
literal|"Certificate invalid: not yet valid"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
if|if
condition|(
operator|(
name|u_int64_t
operator|)
name|now
operator|>=
name|k
operator|->
name|cert
operator|->
name|valid_before
condition|)
block|{
operator|*
name|reason
operator|=
literal|"Certificate invalid: expired"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
if|if
condition|(
name|k
operator|->
name|cert
operator|->
name|nprincipals
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|require_principal
condition|)
block|{
operator|*
name|reason
operator|=
literal|"Certificate lacks principal list"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|principal_matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
operator|->
name|cert
operator|->
name|nprincipals
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|k
operator|->
name|cert
operator|->
name|principals
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|principal_matches
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|principal_matches
condition|)
block|{
operator|*
name|reason
operator|=
literal|"Certificate invalid: name is not a listed "
literal|"principal"
expr_stmt|;
return|return
name|SSH_ERR_KEY_CERT_INVALID
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|sshkey_format_cert_validity
parameter_list|(
specifier|const
name|struct
name|sshkey_cert
modifier|*
name|cert
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|char
name|from
index|[
literal|32
index|]
decl_stmt|,
name|to
index|[
literal|32
index|]
decl_stmt|,
name|ret
index|[
literal|64
index|]
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
operator|*
name|from
operator|=
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cert
operator|->
name|valid_after
operator|==
literal|0
operator|&&
name|cert
operator|->
name|valid_before
operator|==
literal|0xffffffffffffffffULL
condition|)
return|return
name|strlcpy
argument_list|(
name|s
argument_list|,
literal|"forever"
argument_list|,
name|l
argument_list|)
return|;
if|if
condition|(
name|cert
operator|->
name|valid_after
operator|!=
literal|0
condition|)
block|{
comment|/* XXX revisit INT_MAX in 2038 :) */
name|tt
operator|=
name|cert
operator|->
name|valid_after
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
name|cert
operator|->
name|valid_after
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|,
literal|"%Y-%m-%dT%H:%M:%S"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cert
operator|->
name|valid_before
operator|!=
literal|0xffffffffffffffffULL
condition|)
block|{
comment|/* XXX revisit INT_MAX in 2038 :) */
name|tt
operator|=
name|cert
operator|->
name|valid_before
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
name|cert
operator|->
name|valid_before
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|,
literal|"%Y-%m-%dT%H:%M:%S"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cert
operator|->
name|valid_after
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|,
literal|"before %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cert
operator|->
name|valid_before
operator|==
literal|0xffffffffffffffffULL
condition|)
name|snprintf
argument_list|(
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|,
literal|"after %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|,
literal|"from %s to %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|strlcpy
argument_list|(
name|s
argument_list|,
name|ret
argument_list|,
name|l
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sshkey_private_serialize
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|b
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|key
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_RSA
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
name|key
operator|->
name|cert
operator|==
name|NULL
operator|||
name|sshbuf_len
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_DSA
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|priv_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
name|key
operator|->
name|cert
operator|==
name|NULL
operator|||
name|sshbuf_len
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|dsa
operator|->
name|priv_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|b
argument_list|,
name|sshkey_curve_nid_to_name
argument_list|(
name|key
operator|->
name|ecdsa_nid
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_eckey
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ecdsa
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|EC_KEY_get0_private_key
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_ECDSA_CERT
case|:
if|if
condition|(
name|key
operator|->
name|cert
operator|==
name|NULL
operator|||
name|sshbuf_len
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum2
argument_list|(
name|b
argument_list|,
name|EC_KEY_get0_private_key
argument_list|(
name|key
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ed25519_sk
argument_list|,
name|ED25519_SK_SZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_ED25519_CERT
case|:
if|if
condition|(
name|key
operator|->
name|cert
operator|==
name|NULL
operator|||
name|sshbuf_len
argument_list|(
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|cert
operator|->
name|certblob
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ed25519_pk
argument_list|,
name|ED25519_PK_SZ
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|b
argument_list|,
name|key
operator|->
name|ed25519_sk
argument_list|,
name|ED25519_SK_SZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* success */
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|sshkey_private_deserialize
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|kp
parameter_list|)
block|{
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|,
modifier|*
name|curve
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|size_t
name|pklen
init|=
literal|0
decl_stmt|,
name|sklen
init|=
literal|0
decl_stmt|;
name|int
name|type
decl_stmt|,
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|u_char
modifier|*
name|ed25519_pk
init|=
name|NULL
decl_stmt|,
modifier|*
name|ed25519_sk
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|WITH_OPENSSL
name|BIGNUM
modifier|*
name|exponent
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
if|if
condition|(
name|kp
operator|!=
name|NULL
condition|)
operator|*
name|kp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|buf
argument_list|,
operator|&
name|tname
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|type
operator|=
name|sshkey_type_from_name
argument_list|(
name|tname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA
case|:
if|if
condition|(
operator|(
name|k
operator|=
name|sshkey_new_private
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|g
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|pub_key
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|priv_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_DSA_CERT
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_froms
argument_list|(
name|buf
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_add_private
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|priv_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
if|if
condition|(
operator|(
name|k
operator|=
name|sshkey_new_private
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|k
operator|->
name|ecdsa_nid
operator|=
name|sshkey_ecdsa_nid_from_name
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|buf
argument_list|,
operator|&
name|curve
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|k
operator|->
name|ecdsa_nid
operator|!=
name|sshkey_curve_name_to_nid
argument_list|(
name|curve
argument_list|)
condition|)
block|{
name|r
operator|=
name|SSH_ERR_EC_CURVE_MISMATCH
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|k
operator|->
name|ecdsa
operator|=
name|EC_KEY_new_by_curve_name
argument_list|(
name|k
operator|->
name|ecdsa_nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|ecdsa
operator|==
name|NULL
operator|||
operator|(
name|exponent
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_eckey
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|ecdsa
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|exponent
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|EC_KEY_set_private_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|,
name|exponent
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_ec_validate_public
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_ec_validate_private
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_ECDSA_CERT
case|:
if|if
condition|(
operator|(
name|exponent
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_froms
argument_list|(
name|buf
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_add_private
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|exponent
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|EC_KEY_set_private_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|,
name|exponent
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_ec_validate_public
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_ec_validate_private
argument_list|(
name|k
operator|->
name|ecdsa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
case|case
name|KEY_RSA
case|:
if|if
condition|(
operator|(
name|k
operator|=
name|sshkey_new_private
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|rsa_generate_additional_parameters
argument_list|(
name|k
operator|->
name|rsa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KEY_RSA_CERT
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_froms
argument_list|(
name|buf
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_add_private
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2
argument_list|(
name|buf
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|rsa_generate_additional_parameters
argument_list|(
name|k
operator|->
name|rsa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
if|if
condition|(
operator|(
name|k
operator|=
name|sshkey_new_private
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|buf
argument_list|,
operator|&
name|ed25519_pk
argument_list|,
operator|&
name|pklen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|buf
argument_list|,
operator|&
name|ed25519_sk
argument_list|,
operator|&
name|sklen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|pklen
operator|!=
name|ED25519_PK_SZ
operator|||
name|sklen
operator|!=
name|ED25519_SK_SZ
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|k
operator|->
name|ed25519_pk
operator|=
name|ed25519_pk
expr_stmt|;
name|k
operator|->
name|ed25519_sk
operator|=
name|ed25519_sk
expr_stmt|;
name|ed25519_pk
operator|=
name|ed25519_sk
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|KEY_ED25519_CERT
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_froms
argument_list|(
name|buf
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_add_private
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|buf
argument_list|,
operator|&
name|ed25519_pk
argument_list|,
operator|&
name|pklen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|buf
argument_list|,
operator|&
name|ed25519_sk
argument_list|,
operator|&
name|sklen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|pklen
operator|!=
name|ED25519_PK_SZ
operator|||
name|sklen
operator|!=
name|ED25519_SK_SZ
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|k
operator|->
name|ed25519_pk
operator|=
name|ed25519_pk
expr_stmt|;
name|k
operator|->
name|ed25519_sk
operator|=
name|ed25519_sk
expr_stmt|;
name|ed25519_pk
operator|=
name|ed25519_sk
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|SSH_ERR_KEY_TYPE_UNKNOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|WITH_OPENSSL
comment|/* enable blinding */
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
case|case
name|KEY_RSA
case|:
case|case
name|KEY_RSA_CERT
case|:
case|case
name|KEY_RSA1
case|:
if|if
condition|(
name|RSA_blinding_on
argument_list|(
name|k
operator|->
name|rsa
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* WITH_OPENSSL */
comment|/* success */
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|kp
operator|=
name|k
expr_stmt|;
name|k
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curve
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_OPENSSL
if|if
condition|(
name|exponent
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed25519_pk
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|ed25519_pk
argument_list|,
name|pklen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ed25519_pk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ed25519_sk
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|ed25519_sk
argument_list|,
name|sklen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ed25519_sk
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WITH_OPENSSL
argument_list|)
operator|&&
name|defined
argument_list|(
name|OPENSSL_HAS_ECC
argument_list|)
end_if

begin_function
name|int
name|sshkey_ec_validate_public
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|public
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|bnctx
decl_stmt|;
name|EC_POINT
modifier|*
name|nq
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|order
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_KEY_INVALID_EC_VALUE
decl_stmt|;
comment|/* 	 * NB. This assumes OpenSSL has already verified that the public 	 * point lies on the curve. This is done by EC_POINT_oct2point() 	 * implicitly calling EC_POINT_is_on_curve(). If this code is ever 	 * reachable with public points not unmarshalled using 	 * EC_POINT_oct2point then the caller will need to explicitly check. 	 */
if|if
condition|(
operator|(
name|bnctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|BN_CTX_start
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
comment|/* 	 * We shouldn't ever hit this case because bignum_get_ecpoint() 	 * refuses to load GF2m points. 	 */
if|if
condition|(
name|EC_METHOD_get_field_type
argument_list|(
name|EC_GROUP_method_of
argument_list|(
name|group
argument_list|)
argument_list|)
operator|!=
name|NID_X9_62_prime_field
condition|)
goto|goto
name|out
goto|;
comment|/* Q != infinity */
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|public
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|order
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tmp
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* log2(x)> log2(order)/2, log2(y)> log2(order)/2 */
if|if
condition|(
name|EC_GROUP_get_order
argument_list|(
name|group
argument_list|,
name|order
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|1
operator|||
name|EC_POINT_get_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|public
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_num_bits
argument_list|(
name|x
argument_list|)
operator|<=
name|BN_num_bits
argument_list|(
name|order
argument_list|)
operator|/
literal|2
operator|||
name|BN_num_bits
argument_list|(
name|y
argument_list|)
operator|<=
name|BN_num_bits
argument_list|(
name|order
argument_list|)
operator|/
literal|2
condition|)
goto|goto
name|out
goto|;
comment|/* nQ == infinity (n == order of subgroup) */
if|if
condition|(
operator|(
name|nq
operator|=
name|EC_POINT_new
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|EC_POINT_mul
argument_list|(
name|group
argument_list|,
name|nq
argument_list|,
name|NULL
argument_list|,
name|public
argument_list|,
name|order
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|EC_POINT_is_at_infinity
argument_list|(
name|group
argument_list|,
name|nq
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|out
goto|;
comment|/* x< order - 1, y< order - 1 */
if|if
condition|(
operator|!
name|BN_sub
argument_list|(
name|tmp
argument_list|,
name|order
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
name|x
argument_list|,
name|tmp
argument_list|)
operator|>=
literal|0
operator|||
name|BN_cmp
argument_list|(
name|y
argument_list|,
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nq
operator|!=
name|NULL
condition|)
name|EC_POINT_free
argument_list|(
name|nq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|sshkey_ec_validate_private
parameter_list|(
specifier|const
name|EC_KEY
modifier|*
name|key
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|bnctx
decl_stmt|;
name|BIGNUM
modifier|*
name|order
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|ret
init|=
name|SSH_ERR_KEY_INVALID_EC_VALUE
decl_stmt|;
if|if
condition|(
operator|(
name|bnctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|BN_CTX_start
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|order
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tmp
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* log2(private)> log2(order)/2 */
if|if
condition|(
name|EC_GROUP_get_order
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|key
argument_list|)
argument_list|,
name|order
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_num_bits
argument_list|(
name|EC_KEY_get0_private_key
argument_list|(
name|key
argument_list|)
argument_list|)
operator|<=
name|BN_num_bits
argument_list|(
name|order
argument_list|)
operator|/
literal|2
condition|)
goto|goto
name|out
goto|;
comment|/* private< order - 1 */
if|if
condition|(
operator|!
name|BN_sub
argument_list|(
name|tmp
argument_list|,
name|order
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
name|EC_KEY_get0_private_key
argument_list|(
name|key
argument_list|)
argument_list|,
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|sshkey_dump_ec_point
parameter_list|(
specifier|const
name|EC_GROUP
modifier|*
name|group
parameter_list|,
specifier|const
name|EC_POINT
modifier|*
name|point
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|BN_CTX
modifier|*
name|bnctx
decl_stmt|;
if|if
condition|(
name|point
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"point=(NULL)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|bnctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: BN_CTX_new failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|BN_CTX_start
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|y
operator|=
name|BN_CTX_get
argument_list|(
name|bnctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: BN_CTX_get failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EC_METHOD_get_field_type
argument_list|(
name|EC_GROUP_method_of
argument_list|(
name|group
argument_list|)
argument_list|)
operator|!=
name|NID_X9_62_prime_field
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: group is not a prime field\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EC_POINT_get_affine_coordinates_GFp
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|bnctx
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: EC_POINT_get_affine_coordinates_GFp\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
literal|"x="
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|BN_print_fp
argument_list|(
name|stderr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ny="
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|BN_print_fp
argument_list|(
name|stderr
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bnctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sshkey_dump_ec_key
parameter_list|(
specifier|const
name|EC_KEY
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|BIGNUM
modifier|*
name|exponent
decl_stmt|;
name|sshkey_dump_ec_point
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|key
argument_list|)
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"exponent="
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exponent
operator|=
name|EC_KEY_get0_private_key
argument_list|(
name|key
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|"(NULL)"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|BN_print_fp
argument_list|(
name|stderr
argument_list|,
name|EC_KEY_get0_private_key
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_OPENSSL&& OPENSSL_HAS_ECC */
end_comment

begin_function
specifier|static
name|int
name|sshkey_private_to_blob2
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|prv
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
specifier|const
name|char
modifier|*
name|ciphername
parameter_list|,
name|int
name|rounds
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
modifier|*
name|pubkeyblob
init|=
name|NULL
decl_stmt|;
name|u_char
name|salt
index|[
name|SALT_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|b64
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|pubkeylen
decl_stmt|,
name|keylen
decl_stmt|,
name|ivlen
decl_stmt|,
name|blocksize
decl_stmt|,
name|authlen
decl_stmt|;
name|u_int
name|check
decl_stmt|;
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|struct
name|sshcipher_ctx
modifier|*
name|ciphercontext
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|sshcipher
modifier|*
name|cipher
decl_stmt|;
specifier|const
name|char
modifier|*
name|kdfname
init|=
name|KDFNAME
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|encoded
init|=
name|NULL
decl_stmt|,
modifier|*
name|encrypted
init|=
name|NULL
decl_stmt|,
modifier|*
name|kdf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rounds
operator|<=
literal|0
condition|)
name|rounds
operator|=
name|DEFAULT_ROUNDS
expr_stmt|;
if|if
condition|(
name|passphrase
operator|==
name|NULL
operator|||
operator|!
name|strlen
argument_list|(
name|passphrase
argument_list|)
condition|)
block|{
name|ciphername
operator|=
literal|"none"
expr_stmt|;
name|kdfname
operator|=
literal|"none"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ciphername
operator|==
name|NULL
condition|)
name|ciphername
operator|=
name|DEFAULT_CIPHERNAME
expr_stmt|;
elseif|else
if|if
condition|(
name|cipher_number
argument_list|(
name|ciphername
argument_list|)
operator|!=
name|SSH_CIPHER_SSH2
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|cipher
operator|=
name|cipher_by_name
argument_list|(
name|ciphername
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|kdf
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|encoded
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|encrypted
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|blocksize
operator|=
name|cipher_blocksize
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
name|keylen
operator|=
name|cipher_keylen
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
name|ivlen
operator|=
name|cipher_ivlen
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|cipher_authlen
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|keylen
operator|+
name|ivlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|kdfname
argument_list|,
literal|"bcrypt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arc4random_buf
argument_list|(
name|salt
argument_list|,
name|SALT_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcrypt_pbkdf
argument_list|(
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|,
name|salt
argument_list|,
name|SALT_LEN
argument_list|,
name|key
argument_list|,
name|keylen
operator|+
name|ivlen
argument_list|,
name|rounds
argument_list|)
operator|<
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|kdf
argument_list|,
name|salt
argument_list|,
name|SALT_LEN
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|kdf
argument_list|,
name|rounds
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kdfname
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Unsupported KDF type */
name|r
operator|=
name|SSH_ERR_KEY_UNKNOWN_CIPHER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_init
argument_list|(
operator|&
name|ciphercontext
argument_list|,
name|cipher
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|key
operator|+
name|keylen
argument_list|,
name|ivlen
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|encoded
argument_list|,
name|AUTH_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|AUTH_MAGIC
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|encoded
argument_list|,
name|ciphername
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|encoded
argument_list|,
name|kdfname
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|encoded
argument_list|,
name|kdf
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|encoded
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* number of keys */
operator|(
name|r
operator|=
name|sshkey_to_blob
argument_list|(
name|prv
argument_list|,
operator|&
name|pubkeyblob
argument_list|,
operator|&
name|pubkeylen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|encoded
argument_list|,
name|pubkeyblob
argument_list|,
name|pubkeylen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* set up the buffer that will be encrypted */
comment|/* Random check bytes */
name|check
operator|=
name|arc4random
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|encrypted
argument_list|,
name|check
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|encrypted
argument_list|,
name|check
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* append private key and comment*/
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_private_serialize
argument_list|(
name|prv
argument_list|,
name|encrypted
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|encrypted
argument_list|,
name|comment
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* padding */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sshbuf_len
argument_list|(
name|encrypted
argument_list|)
operator|%
name|blocksize
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|encrypted
argument_list|,
operator|++
name|i
operator|&
literal|0xff
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* length in destination buffer */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|encoded
argument_list|,
name|sshbuf_len
argument_list|(
name|encrypted
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* encrypt */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_reserve
argument_list|(
name|encoded
argument_list|,
name|sshbuf_len
argument_list|(
name|encrypted
argument_list|)
operator|+
name|authlen
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_crypt
argument_list|(
name|ciphercontext
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|,
name|sshbuf_ptr
argument_list|(
name|encrypted
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|encrypted
argument_list|)
argument_list|,
literal|0
argument_list|,
name|authlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* uuencode */
if|if
condition|(
operator|(
name|b64
operator|=
name|sshbuf_dtob64
argument_list|(
name|encoded
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sshbuf_reset
argument_list|(
name|blob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|blob
argument_list|,
name|MARK_BEGIN
argument_list|,
name|MARK_BEGIN_LEN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|b64
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|blob
argument_list|,
name|b64
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* insert line breaks */
if|if
condition|(
name|i
operator|%
literal|70
operator|==
literal|69
operator|&&
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|blob
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|i
operator|%
literal|70
operator|!=
literal|69
operator|&&
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|blob
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|blob
argument_list|,
name|MARK_END
argument_list|,
name|MARK_END_LEN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* success */
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|sshbuf_free
argument_list|(
name|kdf
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|encoded
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|encrypted
argument_list|)
expr_stmt|;
name|cipher_free
argument_list|(
name|ciphercontext
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|salt
argument_list|,
sizeof|sizeof
argument_list|(
name|salt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|key
argument_list|,
name|keylen
operator|+
name|ivlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pubkeyblob
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|pubkeyblob
argument_list|,
name|pubkeylen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pubkeyblob
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b64
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|b64
argument_list|,
name|strlen
argument_list|(
name|b64
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b64
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sshkey_parse_private2
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|char
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
name|char
modifier|*
name|comment
init|=
name|NULL
decl_stmt|,
modifier|*
name|ciphername
init|=
name|NULL
decl_stmt|,
modifier|*
name|kdfname
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|sshcipher
modifier|*
name|cipher
init|=
name|NULL
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|size_t
name|encoded_len
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|keylen
init|=
literal|0
decl_stmt|,
name|ivlen
init|=
literal|0
decl_stmt|,
name|authlen
init|=
literal|0
decl_stmt|,
name|slen
init|=
literal|0
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|encoded
init|=
name|NULL
decl_stmt|,
modifier|*
name|decoded
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|kdf
init|=
name|NULL
decl_stmt|,
modifier|*
name|decrypted
init|=
name|NULL
decl_stmt|;
name|struct
name|sshcipher_ctx
modifier|*
name|ciphercontext
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
modifier|*
name|salt
init|=
name|NULL
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
name|pad
decl_stmt|,
name|last
decl_stmt|;
name|u_int
name|blocksize
decl_stmt|,
name|rounds
decl_stmt|,
name|nkeys
decl_stmt|,
name|encrypted_len
decl_stmt|,
name|check1
decl_stmt|,
name|check2
decl_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
operator|*
name|commentp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|encoded
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|decoded
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|decrypted
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check preamble */
name|cp
operator|=
name|sshbuf_ptr
argument_list|(
name|blob
argument_list|)
expr_stmt|;
name|encoded_len
operator|=
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_len
operator|<
operator|(
name|MARK_BEGIN_LEN
operator|+
name|MARK_END_LEN
operator|)
operator|||
name|memcmp
argument_list|(
name|cp
argument_list|,
name|MARK_BEGIN
argument_list|,
name|MARK_BEGIN_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cp
operator|+=
name|MARK_BEGIN_LEN
expr_stmt|;
name|encoded_len
operator|-=
name|MARK_BEGIN_LEN
expr_stmt|;
comment|/* Look for end marker, removing whitespace as we go */
while|while
condition|(
name|encoded_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\r'
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|encoded
argument_list|,
operator|*
name|cp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|last
operator|=
operator|*
name|cp
expr_stmt|;
name|encoded_len
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|encoded_len
operator|>=
name|MARK_END_LEN
operator|&&
name|memcmp
argument_list|(
name|cp
argument_list|,
name|MARK_END
argument_list|,
name|MARK_END_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* \0 terminate */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|encoded
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|encoded_len
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* decode base64 */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_b64tod
argument_list|(
name|decoded
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sshbuf_ptr
argument_list|(
name|encoded
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* check magic */
if|if
condition|(
name|sshbuf_len
argument_list|(
name|decoded
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|AUTH_MAGIC
argument_list|)
operator|||
name|memcmp
argument_list|(
name|sshbuf_ptr
argument_list|(
name|decoded
argument_list|)
argument_list|,
name|AUTH_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|AUTH_MAGIC
argument_list|)
argument_list|)
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* parse public portion of key */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_consume
argument_list|(
name|decoded
argument_list|,
sizeof|sizeof
argument_list|(
name|AUTH_MAGIC
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|decoded
argument_list|,
operator|&
name|ciphername
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|decoded
argument_list|,
operator|&
name|kdfname
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_froms
argument_list|(
name|decoded
argument_list|,
operator|&
name|kdf
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|decoded
argument_list|,
operator|&
name|nkeys
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_skip_string
argument_list|(
name|decoded
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* pubkey */
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|decoded
argument_list|,
operator|&
name|encrypted_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|cipher
operator|=
name|cipher_by_name
argument_list|(
name|ciphername
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_KEY_UNKNOWN_CIPHER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|passphrase
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|passphrase
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|ciphername
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* passphrase required */
name|r
operator|=
name|SSH_ERR_KEY_WRONG_PASSPHRASE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|kdfname
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|kdfname
argument_list|,
literal|"bcrypt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_KEY_UNKNOWN_CIPHER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|kdfname
argument_list|,
literal|"none"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ciphername
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nkeys
operator|!=
literal|1
condition|)
block|{
comment|/* XXX only one key supported */
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check size of encrypted key blob */
name|blocksize
operator|=
name|cipher_blocksize
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
if|if
condition|(
name|encrypted_len
operator|<
name|blocksize
operator|||
operator|(
name|encrypted_len
operator|%
name|blocksize
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* setup key */
name|keylen
operator|=
name|cipher_keylen
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
name|ivlen
operator|=
name|cipher_ivlen
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|cipher_authlen
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|keylen
operator|+
name|ivlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|kdfname
argument_list|,
literal|"bcrypt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|kdf
argument_list|,
operator|&
name|salt
argument_list|,
operator|&
name|slen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|kdf
argument_list|,
operator|&
name|rounds
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|bcrypt_pbkdf
argument_list|(
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|,
name|salt
argument_list|,
name|slen
argument_list|,
name|key
argument_list|,
name|keylen
operator|+
name|ivlen
argument_list|,
name|rounds
argument_list|)
operator|<
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* check that an appropriate amount of auth data is present */
if|if
condition|(
name|sshbuf_len
argument_list|(
name|decoded
argument_list|)
operator|<
name|encrypted_len
operator|+
name|authlen
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* decrypt private portion of key */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_reserve
argument_list|(
name|decrypted
argument_list|,
name|encrypted_len
argument_list|,
operator|&
name|dp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|cipher_init
argument_list|(
operator|&
name|ciphercontext
argument_list|,
name|cipher
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|key
operator|+
name|keylen
argument_list|,
name|ivlen
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_crypt
argument_list|(
name|ciphercontext
argument_list|,
literal|0
argument_list|,
name|dp
argument_list|,
name|sshbuf_ptr
argument_list|(
name|decoded
argument_list|)
argument_list|,
name|encrypted_len
argument_list|,
literal|0
argument_list|,
name|authlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* an integrity error here indicates an incorrect passphrase */
if|if
condition|(
name|r
operator|==
name|SSH_ERR_MAC_INVALID
condition|)
name|r
operator|=
name|SSH_ERR_KEY_WRONG_PASSPHRASE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_consume
argument_list|(
name|decoded
argument_list|,
name|encrypted_len
operator|+
name|authlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* there should be no trailing data */
if|if
condition|(
name|sshbuf_len
argument_list|(
name|decoded
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check check bytes */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|decrypted
argument_list|,
operator|&
name|check1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|decrypted
argument_list|,
operator|&
name|check2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|check1
operator|!=
name|check2
condition|)
block|{
name|r
operator|=
name|SSH_ERR_KEY_WRONG_PASSPHRASE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Load the private key and comment */
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_private_deserialize
argument_list|(
name|decrypted
argument_list|,
operator|&
name|k
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|decrypted
argument_list|,
operator|&
name|comment
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Check deterministic padding */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sshbuf_len
argument_list|(
name|decrypted
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|decrypted
argument_list|,
operator|&
name|pad
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|pad
operator|!=
operator|(
operator|++
name|i
operator|&
literal|0xff
operator|)
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* XXX decode pubkey and check against private */
comment|/* success */
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|keyp
operator|=
name|k
expr_stmt|;
name|k
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|commentp
operator|=
name|comment
expr_stmt|;
name|comment
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|pad
operator|=
literal|0
expr_stmt|;
name|cipher_free
argument_list|(
name|ciphercontext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ciphername
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kdfname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|salt
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|salt
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|salt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|explicit_bzero
argument_list|(
name|key
argument_list|,
name|keylen
operator|+
name|ivlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
name|sshbuf_free
argument_list|(
name|encoded
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|kdf
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|decrypted
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
name|WITH_SSH1
end_if

begin_comment
comment|/*  * Serialises the authentication (private) key to a blob, encrypting it with  * passphrase.  The identification of the blob (lowest 64 bits of n) will  * precede the key to provide identification of the key without needing a  * passphrase.  */
end_comment

begin_function
specifier|static
name|int
name|sshkey_private_rsa1_to_blob
parameter_list|(
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|,
modifier|*
name|encrypted
init|=
name|NULL
decl_stmt|;
name|u_char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|r
decl_stmt|,
name|cipher_num
decl_stmt|;
name|struct
name|sshcipher_ctx
modifier|*
name|ciphercontext
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|sshcipher
modifier|*
name|cipher
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * If the passphrase is empty, use SSH_CIPHER_NONE to ease converting 	 * to another cipher; otherwise use SSH_AUTHFILE_CIPHER. 	 */
name|cipher_num
operator|=
operator|(
name|strcmp
argument_list|(
name|passphrase
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|SSH_CIPHER_NONE
else|:
name|SSH_CIPHER_3DES
expr_stmt|;
if|if
condition|(
operator|(
name|cipher
operator|=
name|cipher_by_number
argument_list|(
name|cipher_num
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_INTERNAL_ERROR
return|;
comment|/* This buffer is used to build the secret part of the private key. */
if|if
condition|(
operator|(
name|buffer
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
comment|/* Put checkbytes for checking passphrase validity. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_reserve
argument_list|(
name|buffer
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|arc4random_buf
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Store the private key (n and e will not be stored because they 	 * will be stored in plain text, and storing them also in encrypted 	 * format would just give known plaintext). 	 * Note: q and p are stored in reverse order to SSL. 	 */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_bignum1
argument_list|(
name|buffer
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum1
argument_list|(
name|buffer
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum1
argument_list|(
name|buffer
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum1
argument_list|(
name|buffer
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Pad the part to be encrypted to a size that is a multiple of 8. */
name|explicit_bzero
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|buffer
argument_list|,
name|buf
argument_list|,
literal|8
operator|-
operator|(
name|sshbuf_len
argument_list|(
name|buffer
argument_list|)
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* This buffer will be used to contain the data in the file. */
if|if
condition|(
operator|(
name|encrypted
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* First store keyfile id string. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|encrypted
argument_list|,
name|LEGACY_BEGIN
argument_list|,
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Store cipher type and "reserved" field. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|encrypted
argument_list|,
name|cipher_num
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|encrypted
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Store public key.  This will be in plain text. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|encrypted
argument_list|,
name|BN_num_bits
argument_list|(
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum1
argument_list|(
name|encrypted
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_bignum1
argument_list|(
name|encrypted
argument_list|,
name|key
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|encrypted
argument_list|,
name|comment
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Allocate space for the private part of the key in the buffer. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_reserve
argument_list|(
name|encrypted
argument_list|,
name|sshbuf_len
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_set_key_string
argument_list|(
operator|&
name|ciphercontext
argument_list|,
name|cipher
argument_list|,
name|passphrase
argument_list|,
name|CIPHER_ENCRYPT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_crypt
argument_list|(
name|ciphercontext
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|,
name|sshbuf_ptr
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|r
operator|=
name|sshbuf_putb
argument_list|(
name|blob
argument_list|,
name|encrypted
argument_list|)
expr_stmt|;
name|out
label|:
name|cipher_free
argument_list|(
name|ciphercontext
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|encrypted
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_SSH1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_comment
comment|/* convert SSH v2 key in OpenSSL PEM format */
end_comment

begin_function
specifier|static
name|int
name|sshkey_private_pem_to_blob
parameter_list|(
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
specifier|const
name|char
modifier|*
name|_passphrase
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|int
name|success
decl_stmt|,
name|r
decl_stmt|;
name|int
name|blen
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|_passphrase
argument_list|)
decl_stmt|;
name|u_char
modifier|*
name|passphrase
init|=
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
operator|(
name|u_char
operator|*
operator|)
name|_passphrase
else|:
name|NULL
decl_stmt|;
if|#
directive|if
operator|(
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x00907000L
operator|)
specifier|const
name|EVP_CIPHER
modifier|*
name|cipher
init|=
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
name|EVP_des_ede3_cbc
argument_list|()
else|:
name|NULL
decl_stmt|;
else|#
directive|else
specifier|const
name|EVP_CIPHER
modifier|*
name|cipher
init|=
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
name|EVP_aes_128_cbc
argument_list|()
else|:
name|NULL
decl_stmt|;
endif|#
directive|endif
specifier|const
name|u_char
modifier|*
name|bptr
decl_stmt|;
name|BIO
modifier|*
name|bio
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
literal|4
condition|)
return|return
name|SSH_ERR_PASSPHRASE_TOO_SHORT
return|;
if|if
condition|(
operator|(
name|bio
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
switch|switch
condition|(
name|key
operator|->
name|type
condition|)
block|{
case|case
name|KEY_DSA
case|:
name|success
operator|=
name|PEM_write_bio_DSAPrivateKey
argument_list|(
name|bio
argument_list|,
name|key
operator|->
name|dsa
argument_list|,
name|cipher
argument_list|,
name|passphrase
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
case|case
name|KEY_ECDSA
case|:
name|success
operator|=
name|PEM_write_bio_ECPrivateKey
argument_list|(
name|bio
argument_list|,
name|key
operator|->
name|ecdsa
argument_list|,
name|cipher
argument_list|,
name|passphrase
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|KEY_RSA
case|:
name|success
operator|=
name|PEM_write_bio_RSAPrivateKey
argument_list|(
name|bio
argument_list|,
name|key
operator|->
name|rsa
argument_list|,
name|cipher
argument_list|,
name|passphrase
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|blen
operator|=
name|BIO_get_mem_data
argument_list|(
name|bio
argument_list|,
operator|&
name|bptr
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|blob
argument_list|,
name|bptr
argument_list|,
name|blen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_OPENSSL */
end_comment

begin_comment
comment|/* Serialise "key" to buffer "blob" */
end_comment

begin_function
name|int
name|sshkey_private_to_fileblob
parameter_list|(
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|int
name|force_new_format
parameter_list|,
specifier|const
name|char
modifier|*
name|new_format_cipher
parameter_list|,
name|int
name|new_format_rounds
parameter_list|)
block|{
switch|switch
condition|(
name|key
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_SSH1
case|case
name|KEY_RSA1
case|:
return|return
name|sshkey_private_rsa1_to_blob
argument_list|(
name|key
argument_list|,
name|blob
argument_list|,
name|passphrase
argument_list|,
name|comment
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_SSH1 */
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA
case|:
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_RSA
case|:
if|if
condition|(
name|force_new_format
condition|)
block|{
return|return
name|sshkey_private_to_blob2
argument_list|(
name|key
argument_list|,
name|blob
argument_list|,
name|passphrase
argument_list|,
name|comment
argument_list|,
name|new_format_cipher
argument_list|,
name|new_format_rounds
argument_list|)
return|;
block|}
return|return
name|sshkey_private_pem_to_blob
argument_list|(
name|key
argument_list|,
name|blob
argument_list|,
name|passphrase
argument_list|,
name|comment
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
return|return
name|sshkey_private_to_blob2
argument_list|(
name|key
argument_list|,
name|blob
argument_list|,
name|passphrase
argument_list|,
name|comment
argument_list|,
name|new_format_cipher
argument_list|,
name|new_format_rounds
argument_list|)
return|;
default|default:
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_SSH1
end_ifdef

begin_comment
comment|/*  * Parse the public, unencrypted portion of a RSA1 key.  */
end_comment

begin_function
name|int
name|sshkey_parse_public_rsa1_fileblob
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|char
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|pub
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|copy
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
operator|*
name|commentp
operator|=
name|NULL
expr_stmt|;
comment|/* Check that it is at least big enough to contain the ID string. */
if|if
condition|(
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
comment|/* 	 * Make sure it begins with the id string.  Consume the id string 	 * from the buffer. 	 */
if|if
condition|(
name|memcmp
argument_list|(
name|sshbuf_ptr
argument_list|(
name|blob
argument_list|)
argument_list|,
name|LEGACY_BEGIN
argument_list|,
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
comment|/* Make a working copy of the keyblob and skip past the magic */
if|if
condition|(
operator|(
name|copy
operator|=
name|sshbuf_fromb
argument_list|(
name|blob
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_consume
argument_list|(
name|copy
argument_list|,
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Skip cipher type, reserved data and key bits. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* cipher type */
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* reserved */
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* key bits */
goto|goto
name|out
goto|;
comment|/* Read the public key from the buffer. */
if|if
condition|(
operator|(
name|pub
operator|=
name|sshkey_new
argument_list|(
name|KEY_RSA1
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|copy
argument_list|,
name|pub
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|copy
argument_list|,
name|pub
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Finally, the comment */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|copy
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|commentp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* The encrypted private part is not parsed by this function. */
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|keyp
operator|=
name|pub
expr_stmt|;
name|pub
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|sshbuf_free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|pub
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sshkey_parse_private_rsa1
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|char
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|u_int16_t
name|check1
decl_stmt|,
name|check2
decl_stmt|;
name|u_int8_t
name|cipher_type
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|decrypted
init|=
name|NULL
decl_stmt|,
modifier|*
name|copy
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
name|struct
name|sshcipher_ctx
modifier|*
name|ciphercontext
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|sshcipher
modifier|*
name|cipher
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|prv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
operator|*
name|commentp
operator|=
name|NULL
expr_stmt|;
comment|/* Check that it is at least big enough to contain the ID string. */
if|if
condition|(
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
comment|/* 	 * Make sure it begins with the id string.  Consume the id string 	 * from the buffer. 	 */
if|if
condition|(
name|memcmp
argument_list|(
name|sshbuf_ptr
argument_list|(
name|blob
argument_list|)
argument_list|,
name|LEGACY_BEGIN
argument_list|,
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
if|if
condition|(
operator|(
name|prv
operator|=
name|sshkey_new_private
argument_list|(
name|KEY_RSA1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|copy
operator|=
name|sshbuf_fromb
argument_list|(
name|blob
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|decrypted
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_consume
argument_list|(
name|copy
argument_list|,
sizeof|sizeof
argument_list|(
name|LEGACY_BEGIN
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Read cipher type. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|copy
argument_list|,
operator|&
name|cipher_type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* reserved */
goto|goto
name|out
goto|;
comment|/* Read the public key and comment from the buffer. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* key bits */
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|copy
argument_list|,
name|prv
operator|->
name|rsa
operator|->
name|n
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|copy
argument_list|,
name|prv
operator|->
name|rsa
operator|->
name|e
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|copy
argument_list|,
operator|&
name|comment
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Check that it is a supported cipher. */
name|cipher
operator|=
name|cipher_by_number
argument_list|(
name|cipher_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cipher
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_KEY_UNKNOWN_CIPHER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Initialize space for decrypted data. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_reserve
argument_list|(
name|decrypted
argument_list|,
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Rest of the buffer is encrypted.  Decrypt it using the passphrase. */
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_set_key_string
argument_list|(
operator|&
name|ciphercontext
argument_list|,
name|cipher
argument_list|,
name|passphrase
argument_list|,
name|CIPHER_DECRYPT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|cipher_crypt
argument_list|(
name|ciphercontext
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|,
name|sshbuf_ptr
argument_list|(
name|copy
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u16
argument_list|(
name|decrypted
argument_list|,
operator|&
name|check1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u16
argument_list|(
name|decrypted
argument_list|,
operator|&
name|check2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|check1
operator|!=
name|check2
condition|)
block|{
name|r
operator|=
name|SSH_ERR_KEY_WRONG_PASSPHRASE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Read the rest of the private key. */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|decrypted
argument_list|,
name|prv
operator|->
name|rsa
operator|->
name|d
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|decrypted
argument_list|,
name|prv
operator|->
name|rsa
operator|->
name|iqmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|decrypted
argument_list|,
name|prv
operator|->
name|rsa
operator|->
name|q
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum1
argument_list|(
name|decrypted
argument_list|,
name|prv
operator|->
name|rsa
operator|->
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* calculate p-1 and q-1 */
if|if
condition|(
operator|(
name|r
operator|=
name|rsa_generate_additional_parameters
argument_list|(
name|prv
operator|->
name|rsa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* enable blinding */
if|if
condition|(
name|RSA_blinding_on
argument_list|(
name|prv
operator|->
name|rsa
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|keyp
operator|=
name|prv
expr_stmt|;
name|prv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|commentp
operator|=
name|comment
expr_stmt|;
name|comment
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|cipher_free
argument_list|(
name|ciphercontext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|prv
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|decrypted
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_SSH1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_function
specifier|static
name|int
name|sshkey_parse_private_pem_fileblob
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pk
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|prv
init|=
name|NULL
decl_stmt|;
name|BIO
modifier|*
name|bio
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bio
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
operator|>
name|INT_MAX
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
name|BIO_write
argument_list|(
name|bio
argument_list|,
name|sshbuf_ptr
argument_list|(
name|blob
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|sshbuf_len
argument_list|(
name|blob
argument_list|)
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|pk
operator|=
name|PEM_read_bio_PrivateKey
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|passphrase
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|pem_err
init|=
name|ERR_peek_last_error
argument_list|()
decl_stmt|;
name|int
name|pem_reason
init|=
name|ERR_GET_REASON
argument_list|(
name|pem_err
argument_list|)
decl_stmt|;
comment|/* 		 * Translate OpenSSL error codes to determine whether 		 * passphrase is required/incorrect. 		 */
switch|switch
condition|(
name|ERR_GET_LIB
argument_list|(
name|pem_err
argument_list|)
condition|)
block|{
case|case
name|ERR_LIB_PEM
case|:
switch|switch
condition|(
name|pem_reason
condition|)
block|{
case|case
name|PEM_R_BAD_PASSWORD_READ
case|:
case|case
name|PEM_R_PROBLEMS_GETTING_PASSWORD
case|:
case|case
name|PEM_R_BAD_DECRYPT
case|:
name|r
operator|=
name|SSH_ERR_KEY_WRONG_PASSPHRASE
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|ERR_LIB_EVP
case|:
switch|switch
condition|(
name|pem_reason
condition|)
block|{
case|case
name|EVP_R_BAD_DECRYPT
case|:
name|r
operator|=
name|SSH_ERR_KEY_WRONG_PASSPHRASE
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|EVP_R_BN_DECODE_ERROR
case|:
case|case
name|EVP_R_DECODE_ERROR
case|:
ifdef|#
directive|ifdef
name|EVP_R_PRIVATE_KEY_DECODE_ERROR
case|case
name|EVP_R_PRIVATE_KEY_DECODE_ERROR
case|:
endif|#
directive|endif
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|ERR_LIB_ASN1
case|:
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pk
operator|->
name|type
operator|==
name|EVP_PKEY_RSA
operator|&&
operator|(
name|type
operator|==
name|KEY_UNSPEC
operator|||
name|type
operator|==
name|KEY_RSA
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|prv
operator|=
name|sshkey_new
argument_list|(
name|KEY_UNSPEC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|prv
operator|->
name|rsa
operator|=
name|EVP_PKEY_get1_RSA
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|prv
operator|->
name|type
operator|=
name|KEY_RSA
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PK
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|prv
operator|->
name|rsa
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|RSA_blinding_on
argument_list|(
name|prv
operator|->
name|rsa
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_LIBCRYPTO_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|pk
operator|->
name|type
operator|==
name|EVP_PKEY_DSA
operator|&&
operator|(
name|type
operator|==
name|KEY_UNSPEC
operator|||
name|type
operator|==
name|KEY_DSA
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|prv
operator|=
name|sshkey_new
argument_list|(
name|KEY_UNSPEC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|prv
operator|->
name|dsa
operator|=
name|EVP_PKEY_get1_DSA
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|prv
operator|->
name|type
operator|=
name|KEY_DSA
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PK
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|prv
operator|->
name|dsa
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
block|}
elseif|else
if|if
condition|(
name|pk
operator|->
name|type
operator|==
name|EVP_PKEY_EC
operator|&&
operator|(
name|type
operator|==
name|KEY_UNSPEC
operator|||
name|type
operator|==
name|KEY_ECDSA
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|prv
operator|=
name|sshkey_new
argument_list|(
name|KEY_UNSPEC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|prv
operator|->
name|ecdsa
operator|=
name|EVP_PKEY_get1_EC_KEY
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|prv
operator|->
name|type
operator|=
name|KEY_ECDSA
expr_stmt|;
name|prv
operator|->
name|ecdsa_nid
operator|=
name|sshkey_ecdsa_key_to_nid
argument_list|(
name|prv
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|prv
operator|->
name|ecdsa_nid
operator|==
operator|-
literal|1
operator|||
name|sshkey_curve_nid_to_name
argument_list|(
name|prv
operator|->
name|ecdsa_nid
argument_list|)
operator|==
name|NULL
operator|||
name|sshkey_ec_validate_public
argument_list|(
name|EC_KEY_get0_group
argument_list|(
name|prv
operator|->
name|ecdsa
argument_list|)
argument_list|,
name|EC_KEY_get0_public_key
argument_list|(
name|prv
operator|->
name|ecdsa
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|sshkey_ec_validate_private
argument_list|(
name|prv
operator|->
name|ecdsa
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_PK
if|if
condition|(
name|prv
operator|!=
name|NULL
operator|&&
name|prv
operator|->
name|ecdsa
operator|!=
name|NULL
condition|)
name|sshkey_dump_ec_key
argument_list|(
name|prv
operator|->
name|ecdsa
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* OPENSSL_HAS_ECC */
block|}
else|else
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|keyp
operator|=
name|prv
expr_stmt|;
name|prv
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|prv
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_OPENSSL */
end_comment

begin_function
name|int
name|sshkey_parse_private_fileblob_type
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|blob
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|char
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
operator|*
name|commentp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|WITH_SSH1
case|case
name|KEY_RSA1
case|:
return|return
name|sshkey_parse_private_rsa1
argument_list|(
name|blob
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|,
name|commentp
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_SSH1 */
ifdef|#
directive|ifdef
name|WITH_OPENSSL
case|case
name|KEY_DSA
case|:
case|case
name|KEY_ECDSA
case|:
case|case
name|KEY_RSA
case|:
return|return
name|sshkey_parse_private_pem_fileblob
argument_list|(
name|blob
argument_list|,
name|type
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|)
return|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
case|case
name|KEY_ED25519
case|:
return|return
name|sshkey_parse_private2
argument_list|(
name|blob
argument_list|,
name|type
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|,
name|commentp
argument_list|)
return|;
case|case
name|KEY_UNSPEC
case|:
name|r
operator|=
name|sshkey_parse_private2
argument_list|(
name|blob
argument_list|,
name|type
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|,
name|commentp
argument_list|)
expr_stmt|;
comment|/* Do not fallback to PEM parser if only passphrase is wrong. */
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|r
operator|==
name|SSH_ERR_KEY_WRONG_PASSPHRASE
condition|)
return|return
name|r
return|;
ifdef|#
directive|ifdef
name|WITH_OPENSSL
return|return
name|sshkey_parse_private_pem_fileblob
argument_list|(
name|blob
argument_list|,
name|type
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|)
return|;
else|#
directive|else
return|return
name|SSH_ERR_INVALID_FORMAT
return|;
endif|#
directive|endif
comment|/* WITH_OPENSSL */
default|default:
return|return
name|SSH_ERR_KEY_TYPE_UNKNOWN
return|;
block|}
block|}
end_function

begin_function
name|int
name|sshkey_parse_private_fileblob
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|passphrase
parameter_list|,
name|struct
name|sshkey
modifier|*
modifier|*
name|keyp
parameter_list|,
name|char
modifier|*
modifier|*
name|commentp
parameter_list|)
block|{
if|if
condition|(
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|commentp
operator|!=
name|NULL
condition|)
operator|*
name|commentp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_SSH1
comment|/* it's a SSH v1 key if the public key part is readable */
if|if
condition|(
name|sshkey_parse_public_rsa1_fileblob
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|sshkey_parse_private_fileblob_type
argument_list|(
name|buffer
argument_list|,
name|KEY_RSA1
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|,
name|commentp
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* WITH_SSH1 */
return|return
name|sshkey_parse_private_fileblob_type
argument_list|(
name|buffer
argument_list|,
name|KEY_UNSPEC
argument_list|,
name|passphrase
argument_list|,
name|keyp
argument_list|,
name|commentp
argument_list|)
return|;
block|}
end_function

end_unit

