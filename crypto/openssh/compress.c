begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Interface to packet compression for ssh.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: compress.c,v 1.14 2001/04/05 10:39:01 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_include
include|#
directive|include
file|"compress.h"
end_include

begin_decl_stmt
specifier|static
name|z_stream
name|incoming_stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|z_stream
name|outgoing_stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_init_send_called
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_init_recv_called
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initializes compression; level is compression level from 1 to 9  * (as in gzip).  */
end_comment

begin_function
name|void
name|buffer_compress_init_send
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|compress_init_send_called
operator|==
literal|1
condition|)
name|deflateEnd
argument_list|(
operator|&
name|incoming_stream
argument_list|)
expr_stmt|;
name|compress_init_send_called
operator|=
literal|1
expr_stmt|;
name|debug
argument_list|(
literal|"Enabling compression at level %d."
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|1
operator|||
name|level
operator|>
literal|9
condition|)
name|fatal
argument_list|(
literal|"Bad compression level %d."
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|outgoing_stream
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffer_compress_init_recv
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|compress_init_recv_called
operator|==
literal|1
condition|)
name|inflateEnd
argument_list|(
operator|&
name|incoming_stream
argument_list|)
expr_stmt|;
name|compress_init_recv_called
operator|=
literal|1
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|incoming_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frees any data structures allocated for compression. */
end_comment

begin_function
name|void
name|buffer_compress_uninit
parameter_list|(
name|void
parameter_list|)
block|{
name|debug
argument_list|(
literal|"compress outgoing: raw data %lu, compressed %lu, factor %.2f"
argument_list|,
name|outgoing_stream
operator|.
name|total_in
argument_list|,
name|outgoing_stream
operator|.
name|total_out
argument_list|,
name|outgoing_stream
operator|.
name|total_in
operator|==
literal|0
condition|?
literal|0.0
else|:
operator|(
name|double
operator|)
name|outgoing_stream
operator|.
name|total_out
operator|/
name|outgoing_stream
operator|.
name|total_in
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"compress incoming: raw data %lu, compressed %lu, factor %.2f"
argument_list|,
name|incoming_stream
operator|.
name|total_out
argument_list|,
name|incoming_stream
operator|.
name|total_in
argument_list|,
name|incoming_stream
operator|.
name|total_out
operator|==
literal|0
condition|?
literal|0.0
else|:
operator|(
name|double
operator|)
name|incoming_stream
operator|.
name|total_in
operator|/
name|incoming_stream
operator|.
name|total_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|compress_init_recv_called
operator|==
literal|1
condition|)
name|inflateEnd
argument_list|(
operator|&
name|incoming_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|compress_init_send_called
operator|==
literal|1
condition|)
name|deflateEnd
argument_list|(
operator|&
name|outgoing_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compresses the contents of input_buffer into output_buffer.  All packets  * compressed using this function will form a single compressed data stream;  * however, data will be flushed at the end of every call so that each  * output_buffer can be decompressed independently (but in the appropriate  * order since they together form a single compression stream) by the  * receiver.  This appends the compressed data to the output buffer.  */
end_comment

begin_function
name|void
name|buffer_compress
parameter_list|(
name|Buffer
modifier|*
name|input_buffer
parameter_list|,
name|Buffer
modifier|*
name|output_buffer
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* This case is not handled below. */
if|if
condition|(
name|buffer_len
argument_list|(
name|input_buffer
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Input is the contents of the input buffer. */
name|outgoing_stream
operator|.
name|next_in
operator|=
operator|(
name|u_char
operator|*
operator|)
name|buffer_ptr
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
name|outgoing_stream
operator|.
name|avail_in
operator|=
name|buffer_len
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
comment|/* Loop compressing until deflate() returns with avail_out != 0. */
do|do
block|{
comment|/* Set up fixed-size output buffer. */
name|outgoing_stream
operator|.
name|next_out
operator|=
operator|(
name|u_char
operator|*
operator|)
name|buf
expr_stmt|;
name|outgoing_stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Compress as much data into the buffer as possible. */
name|status
operator|=
name|deflate
argument_list|(
operator|&
name|outgoing_stream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|Z_OK
case|:
comment|/* Append compressed data to output_buffer. */
name|buffer_append
argument_list|(
name|output_buffer
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|outgoing_stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"buffer_compress: deflate returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
do|while
condition|(
name|outgoing_stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Uncompresses the contents of input_buffer into output_buffer.  All packets  * uncompressed using this function will form a single compressed data  * stream; however, data will be flushed at the end of every call so that  * each output_buffer.  This must be called for the same size units that the  * buffer_compress was called, and in the same order that buffers compressed  * with that.  This appends the uncompressed data to the output buffer.  */
end_comment

begin_function
name|void
name|buffer_uncompress
parameter_list|(
name|Buffer
modifier|*
name|input_buffer
parameter_list|,
name|Buffer
modifier|*
name|output_buffer
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|incoming_stream
operator|.
name|next_in
operator|=
operator|(
name|u_char
operator|*
operator|)
name|buffer_ptr
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
name|incoming_stream
operator|.
name|avail_in
operator|=
name|buffer_len
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Set up fixed-size output buffer. */
name|incoming_stream
operator|.
name|next_out
operator|=
operator|(
name|u_char
operator|*
operator|)
name|buf
expr_stmt|;
name|incoming_stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|status
operator|=
name|inflate
argument_list|(
operator|&
name|incoming_stream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|Z_OK
case|:
name|buffer_append
argument_list|(
name|output_buffer
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|incoming_stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_BUF_ERROR
case|:
comment|/* 			 * Comments in zlib.h say that we should keep calling 			 * inflate() until we get an error.  This appears to 			 * be the error that we get. 			 */
return|return;
default|default:
name|fatal
argument_list|(
literal|"buffer_uncompress: inflate returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
end_function

end_unit

