begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   * compress.c  *   * Author: Tatu Ylonen<ylo@cs.hut.fi>  *   * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  *   * Created: Wed Oct 25 22:12:46 1995 ylo  *   * Interface to packet compression for ssh.  *   */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: compress.c,v 1.4 1999/11/24 19:53:46 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_decl_stmt
specifier|static
name|z_stream
name|incoming_stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|z_stream
name|outgoing_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initializes compression; level is compression level from 1 to 9  * (as in gzip).  */
end_comment

begin_function
name|void
name|buffer_compress_init
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|debug
argument_list|(
literal|"Enabling compression at level %d."
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|1
operator|||
name|level
operator|>
literal|9
condition|)
name|fatal
argument_list|(
literal|"Bad compression level %d."
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|incoming_stream
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|outgoing_stream
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frees any data structures allocated for compression. */
end_comment

begin_function
name|void
name|buffer_compress_uninit
parameter_list|()
block|{
name|debug
argument_list|(
literal|"compress outgoing: raw data %lu, compressed %lu, factor %.2f"
argument_list|,
name|outgoing_stream
operator|.
name|total_in
argument_list|,
name|outgoing_stream
operator|.
name|total_out
argument_list|,
name|outgoing_stream
operator|.
name|total_in
operator|==
literal|0
condition|?
literal|0.0
else|:
operator|(
name|double
operator|)
name|outgoing_stream
operator|.
name|total_out
operator|/
name|outgoing_stream
operator|.
name|total_in
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"compress incoming: raw data %lu, compressed %lu, factor %.2f"
argument_list|,
name|incoming_stream
operator|.
name|total_out
argument_list|,
name|incoming_stream
operator|.
name|total_in
argument_list|,
name|incoming_stream
operator|.
name|total_out
operator|==
literal|0
condition|?
literal|0.0
else|:
operator|(
name|double
operator|)
name|incoming_stream
operator|.
name|total_in
operator|/
name|incoming_stream
operator|.
name|total_out
argument_list|)
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|incoming_stream
argument_list|)
expr_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|outgoing_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compresses the contents of input_buffer into output_buffer.  All packets  * compressed using this function will form a single compressed data stream;  * however, data will be flushed at the end of every call so that each  * output_buffer can be decompressed independently (but in the appropriate  * order since they together form a single compression stream) by the  * receiver.  This appends the compressed data to the output buffer.  */
end_comment

begin_function
name|void
name|buffer_compress
parameter_list|(
name|Buffer
modifier|*
name|input_buffer
parameter_list|,
name|Buffer
modifier|*
name|output_buffer
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* This case is not handled below. */
if|if
condition|(
name|buffer_len
argument_list|(
name|input_buffer
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Input is the contents of the input buffer. */
name|outgoing_stream
operator|.
name|next_in
operator|=
name|buffer_ptr
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
name|outgoing_stream
operator|.
name|avail_in
operator|=
name|buffer_len
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
comment|/* Loop compressing until deflate() returns with avail_out != 0. */
do|do
block|{
comment|/* Set up fixed-size output buffer. */
name|outgoing_stream
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|outgoing_stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Compress as much data into the buffer as possible. */
name|status
operator|=
name|deflate
argument_list|(
operator|&
name|outgoing_stream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|Z_OK
case|:
comment|/* Append compressed data to output_buffer. */
name|buffer_append
argument_list|(
name|output_buffer
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|outgoing_stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_STREAM_END
case|:
name|fatal
argument_list|(
literal|"buffer_compress: deflate returned Z_STREAM_END"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|Z_STREAM_ERROR
case|:
name|fatal
argument_list|(
literal|"buffer_compress: deflate returned Z_STREAM_ERROR"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|Z_BUF_ERROR
case|:
name|fatal
argument_list|(
literal|"buffer_compress: deflate returned Z_BUF_ERROR"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|fatal
argument_list|(
literal|"buffer_compress: deflate returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
do|while
condition|(
name|outgoing_stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Uncompresses the contents of input_buffer into output_buffer.  All packets  * uncompressed using this function will form a single compressed data  * stream; however, data will be flushed at the end of every call so that  * each output_buffer.  This must be called for the same size units that the  * buffer_compress was called, and in the same order that buffers compressed  * with that.  This appends the uncompressed data to the output buffer.  */
end_comment

begin_function
name|void
name|buffer_uncompress
parameter_list|(
name|Buffer
modifier|*
name|input_buffer
parameter_list|,
name|Buffer
modifier|*
name|output_buffer
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|incoming_stream
operator|.
name|next_in
operator|=
name|buffer_ptr
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
name|incoming_stream
operator|.
name|avail_in
operator|=
name|buffer_len
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
name|incoming_stream
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|incoming_stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|inflate
argument_list|(
operator|&
name|incoming_stream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|Z_OK
case|:
name|buffer_append
argument_list|(
name|output_buffer
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|incoming_stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
name|incoming_stream
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|incoming_stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_STREAM_END
case|:
name|fatal
argument_list|(
literal|"buffer_uncompress: inflate returned Z_STREAM_END"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|Z_DATA_ERROR
case|:
name|fatal
argument_list|(
literal|"buffer_uncompress: inflate returned Z_DATA_ERROR"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|Z_STREAM_ERROR
case|:
name|fatal
argument_list|(
literal|"buffer_uncompress: inflate returned Z_STREAM_ERROR"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|Z_BUF_ERROR
case|:
comment|/* 			 * Comments in zlib.h say that we should keep calling 			 * inflate() until we get an error.  This appears to 			 * be the error that we get. 			 */
return|return;
case|case
name|Z_MEM_ERROR
case|:
name|fatal
argument_list|(
literal|"buffer_uncompress: inflate returned Z_MEM_ERROR"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|fatal
argument_list|(
literal|"buffer_uncompress: inflate returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

