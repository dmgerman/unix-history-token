begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: monitor.c,v 1.167 2017/02/03 23:05:57 djm Exp $ */
end_comment

begin_comment
comment|/*  * Copyright 2002 Niels Provos<provos@citi.umich.edu>  * Copyright 2002 Markus Friedl<markus@openbsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|"openbsd-compat/sys-tree.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PATHS_H
end_ifdef

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL_H
end_ifdef

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_POLL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SKEY
end_ifdef

begin_include
include|#
directive|include
file|<skey.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/dh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"openbsd-compat/sys-queue.h"
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"cipher.h"
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_include
include|#
directive|include
file|"dh.h"
end_include

begin_include
include|#
directive|include
file|"auth-pam.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OS_MAC
end_ifdef

begin_comment
comment|/* XXX Broken krb5 headers on Mac */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_OS_MAC
end_undef

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_define
define|#
directive|define
name|TARGET_OS_MAC
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_include
include|#
directive|include
file|"sshpty.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"session.h"
end_include

begin_include
include|#
directive|include
file|"sshlogin.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ssh-gss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"monitor_wrap.h"
end_include

begin_include
include|#
directive|include
file|"monitor_fdpass.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"authfd.h"
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_decl_stmt
specifier|static
name|Gssctxt
modifier|*
name|gsscontext
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Imports */
end_comment

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int
name|utmp_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|session_id
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Buffer
name|auth_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|auth_debug_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Buffer
name|loginmsg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* State exported from the child */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sshbuf
modifier|*
name|child_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions on the monitor that answer unprivileged requests */
end_comment

begin_function_decl
name|int
name|mm_answer_moduli
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_sign
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pwnamallow
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_auth2_read_banner
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_authserv
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_authpassword
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_bsdauthquery
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_bsdauthrespond
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_skeyquery
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_skeyrespond
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_keyallowed
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_keyverify
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pty
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pty_cleanup
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_term
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_rsa_keyallowed
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_rsa_challenge
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_rsa_response
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_sesskey
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_sessid
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PAM
end_ifdef

begin_function_decl
name|int
name|mm_answer_pam_start
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pam_account
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pam_init_ctx
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pam_query
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pam_respond
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_pam_free_ctx
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_function_decl
name|int
name|mm_answer_gss_setup_ctx
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_gss_accept_ctx
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_gss_userok
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_gss_checkmic
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
end_ifdef

begin_function_decl
name|int
name|mm_answer_audit_event
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mm_answer_audit_command
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|monitor_read_log
parameter_list|(
name|struct
name|monitor
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|Authctxt
modifier|*
name|authctxt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local state for key verify */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|key_blob
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_bloblen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_blobtype
init|=
name|MM_NOKEY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hostbased_cuser
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hostbased_chost
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auth_method
init|=
literal|"unknown"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auth_submethod
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|session_id2_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|session_id2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|monitor_child_pid
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mon_table
block|{
name|enum
name|monitor_reqtype
name|type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|Buffer
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MON_ISAUTH
value|0x0004
end_define

begin_comment
comment|/* Required for Authentication */
end_comment

begin_define
define|#
directive|define
name|MON_AUTHDECIDE
value|0x0008
end_define

begin_comment
comment|/* Decides Authentication */
end_comment

begin_define
define|#
directive|define
name|MON_ONCE
value|0x0010
end_define

begin_comment
comment|/* Disable after calling */
end_comment

begin_define
define|#
directive|define
name|MON_ALOG
value|0x0020
end_define

begin_comment
comment|/* Log auth attempt without authenticating */
end_comment

begin_define
define|#
directive|define
name|MON_AUTH
value|(MON_ISAUTH|MON_AUTHDECIDE)
end_define

begin_define
define|#
directive|define
name|MON_PERMIT
value|0x1000
end_define

begin_comment
comment|/* Request is permitted */
end_comment

begin_decl_stmt
name|struct
name|mon_table
name|mon_dispatch_proto20
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
block|{
name|MONITOR_REQ_MODULI
block|,
name|MON_ONCE
block|,
name|mm_answer_moduli
block|}
block|,
endif|#
directive|endif
block|{
name|MONITOR_REQ_SIGN
block|,
name|MON_ONCE
block|,
name|mm_answer_sign
block|}
block|,
block|{
name|MONITOR_REQ_PWNAM
block|,
name|MON_ONCE
block|,
name|mm_answer_pwnamallow
block|}
block|,
block|{
name|MONITOR_REQ_AUTHSERV
block|,
name|MON_ONCE
block|,
name|mm_answer_authserv
block|}
block|,
block|{
name|MONITOR_REQ_AUTH2_READ_BANNER
block|,
name|MON_ONCE
block|,
name|mm_answer_auth2_read_banner
block|}
block|,
block|{
name|MONITOR_REQ_AUTHPASSWORD
block|,
name|MON_AUTH
block|,
name|mm_answer_authpassword
block|}
block|,
ifdef|#
directive|ifdef
name|USE_PAM
block|{
name|MONITOR_REQ_PAM_START
block|,
name|MON_ONCE
block|,
name|mm_answer_pam_start
block|}
block|,
block|{
name|MONITOR_REQ_PAM_ACCOUNT
block|,
literal|0
block|,
name|mm_answer_pam_account
block|}
block|,
block|{
name|MONITOR_REQ_PAM_INIT_CTX
block|,
name|MON_ONCE
block|,
name|mm_answer_pam_init_ctx
block|}
block|,
block|{
name|MONITOR_REQ_PAM_QUERY
block|,
literal|0
block|,
name|mm_answer_pam_query
block|}
block|,
block|{
name|MONITOR_REQ_PAM_RESPOND
block|,
name|MON_ONCE
block|,
name|mm_answer_pam_respond
block|}
block|,
block|{
name|MONITOR_REQ_PAM_FREE_CTX
block|,
name|MON_ONCE
operator||
name|MON_AUTHDECIDE
block|,
name|mm_answer_pam_free_ctx
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
block|{
name|MONITOR_REQ_AUDIT_EVENT
block|,
name|MON_PERMIT
block|,
name|mm_answer_audit_event
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD_AUTH
block|{
name|MONITOR_REQ_BSDAUTHQUERY
block|,
name|MON_ISAUTH
block|,
name|mm_answer_bsdauthquery
block|}
block|,
block|{
name|MONITOR_REQ_BSDAUTHRESPOND
block|,
name|MON_AUTH
block|,
name|mm_answer_bsdauthrespond
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SKEY
block|{
name|MONITOR_REQ_SKEYQUERY
block|,
name|MON_ISAUTH
block|,
name|mm_answer_skeyquery
block|}
block|,
block|{
name|MONITOR_REQ_SKEYRESPOND
block|,
name|MON_AUTH
block|,
name|mm_answer_skeyrespond
block|}
block|,
endif|#
directive|endif
block|{
name|MONITOR_REQ_KEYALLOWED
block|,
name|MON_ISAUTH
block|,
name|mm_answer_keyallowed
block|}
block|,
block|{
name|MONITOR_REQ_KEYVERIFY
block|,
name|MON_AUTH
block|,
name|mm_answer_keyverify
block|}
block|,
ifdef|#
directive|ifdef
name|GSSAPI
block|{
name|MONITOR_REQ_GSSSETUP
block|,
name|MON_ISAUTH
block|,
name|mm_answer_gss_setup_ctx
block|}
block|,
block|{
name|MONITOR_REQ_GSSSTEP
block|,
literal|0
block|,
name|mm_answer_gss_accept_ctx
block|}
block|,
block|{
name|MONITOR_REQ_GSSUSEROK
block|,
name|MON_ONCE
operator||
name|MON_AUTHDECIDE
block|,
name|mm_answer_gss_userok
block|}
block|,
block|{
name|MONITOR_REQ_GSSCHECKMIC
block|,
name|MON_ONCE
block|,
name|mm_answer_gss_checkmic
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mon_table
name|mon_dispatch_postauth20
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|WITH_OPENSSL
block|{
name|MONITOR_REQ_MODULI
block|,
literal|0
block|,
name|mm_answer_moduli
block|}
block|,
endif|#
directive|endif
block|{
name|MONITOR_REQ_SIGN
block|,
literal|0
block|,
name|mm_answer_sign
block|}
block|,
block|{
name|MONITOR_REQ_PTY
block|,
literal|0
block|,
name|mm_answer_pty
block|}
block|,
block|{
name|MONITOR_REQ_PTYCLEANUP
block|,
literal|0
block|,
name|mm_answer_pty_cleanup
block|}
block|,
block|{
name|MONITOR_REQ_TERM
block|,
literal|0
block|,
name|mm_answer_term
block|}
block|,
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
block|{
name|MONITOR_REQ_AUDIT_EVENT
block|,
name|MON_PERMIT
block|,
name|mm_answer_audit_event
block|}
block|,
block|{
name|MONITOR_REQ_AUDIT_COMMAND
block|,
name|MON_PERMIT
block|,
name|mm_answer_audit_command
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mon_table
modifier|*
name|mon_dispatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specifies if a certain message is allowed at the moment */
end_comment

begin_function
specifier|static
name|void
name|monitor_permit
parameter_list|(
name|struct
name|mon_table
modifier|*
name|ent
parameter_list|,
name|enum
name|monitor_reqtype
name|type
parameter_list|,
name|int
name|permit
parameter_list|)
block|{
while|while
condition|(
name|ent
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|type
operator|==
name|type
condition|)
block|{
name|ent
operator|->
name|flags
operator|&=
operator|~
name|MON_PERMIT
expr_stmt|;
name|ent
operator|->
name|flags
operator||=
name|permit
condition|?
name|MON_PERMIT
else|:
literal|0
expr_stmt|;
return|return;
block|}
name|ent
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_permit_authentications
parameter_list|(
name|int
name|permit
parameter_list|)
block|{
name|struct
name|mon_table
modifier|*
name|ent
init|=
name|mon_dispatch
decl_stmt|;
while|while
condition|(
name|ent
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|MON_AUTH
condition|)
block|{
name|ent
operator|->
name|flags
operator|&=
operator|~
name|MON_PERMIT
expr_stmt|;
name|ent
operator|->
name|flags
operator||=
name|permit
condition|?
name|MON_PERMIT
else|:
literal|0
expr_stmt|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|monitor_child_preauth
parameter_list|(
name|Authctxt
modifier|*
name|_authctxt
parameter_list|,
name|struct
name|monitor
modifier|*
name|pmonitor
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|struct
name|mon_table
modifier|*
name|ent
decl_stmt|;
name|int
name|authenticated
init|=
literal|0
decl_stmt|,
name|partial
init|=
literal|0
decl_stmt|;
name|debug3
argument_list|(
literal|"preauth child monitor started"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pmonitor
operator|->
name|m_recvfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pmonitor
operator|->
name|m_log_sendfd
argument_list|)
expr_stmt|;
name|pmonitor
operator|->
name|m_log_sendfd
operator|=
name|pmonitor
operator|->
name|m_recvfd
operator|=
operator|-
literal|1
expr_stmt|;
name|authctxt
operator|=
name|_authctxt
expr_stmt|;
name|memset
argument_list|(
name|authctxt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|authctxt
argument_list|)
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|loginmsg
operator|=
operator|&
name|loginmsg
expr_stmt|;
name|mon_dispatch
operator|=
name|mon_dispatch_proto20
expr_stmt|;
comment|/* Permit requests for moduli and signatures */
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_MODULI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_SIGN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The first few requests do not require asynchronous access */
while|while
condition|(
operator|!
name|authenticated
condition|)
block|{
name|partial
operator|=
literal|0
expr_stmt|;
name|auth_method
operator|=
literal|"unknown"
expr_stmt|;
name|auth_submethod
operator|=
name|NULL
expr_stmt|;
name|authenticated
operator|=
operator|(
name|monitor_read
argument_list|(
name|pmonitor
argument_list|,
name|mon_dispatch
argument_list|,
operator|&
name|ent
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
comment|/* Special handling for multiple required authentications */
if|if
condition|(
name|options
operator|.
name|num_auth_methods
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|authenticated
operator|&&
operator|!
name|auth2_update_methods_lists
argument_list|(
name|authctxt
argument_list|,
name|auth_method
argument_list|,
name|auth_submethod
argument_list|)
condition|)
block|{
name|debug3
argument_list|(
literal|"%s: method %s: partial"
argument_list|,
name|__func__
argument_list|,
name|auth_method
argument_list|)
expr_stmt|;
name|authenticated
operator|=
literal|0
expr_stmt|;
name|partial
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|authenticated
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ent
operator|->
name|flags
operator|&
name|MON_AUTHDECIDE
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s: unexpected authentication from %d"
argument_list|,
name|__func__
argument_list|,
name|ent
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
operator|!
name|auth_root_allowed
argument_list|(
name|auth_method
argument_list|)
condition|)
name|authenticated
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
comment|/* PAM needs to perform account checks after auth */
if|if
condition|(
name|options
operator|.
name|use_pam
operator|&&
name|authenticated
condition|)
block|{
name|Buffer
name|m
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|mm_request_receive_expect
argument_list|(
name|pmonitor
operator|->
name|m_sendfd
argument_list|,
name|MONITOR_REQ_PAM_ACCOUNT
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|authenticated
operator|=
name|mm_answer_pam_account
argument_list|(
name|pmonitor
operator|->
name|m_sendfd
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
operator|(
name|MON_AUTHDECIDE
operator||
name|MON_ALOG
operator|)
condition|)
block|{
name|auth_log
argument_list|(
name|authctxt
argument_list|,
name|authenticated
argument_list|,
name|partial
argument_list|,
name|auth_method
argument_list|,
name|auth_submethod
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|partial
operator|&&
operator|!
name|authenticated
condition|)
name|authctxt
operator|->
name|failures
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|authctxt
operator|->
name|valid
condition|)
name|fatal
argument_list|(
literal|"%s: authenticated invalid user"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|auth_method
argument_list|,
literal|"unknown"
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: authentication method name unknown"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"%s: %s has been authenticated by privileged process"
argument_list|,
name|__func__
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
name|ssh_packet_set_log_preamble
argument_list|(
name|ssh
argument_list|,
literal|"user %s"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
name|mm_get_keystate
argument_list|(
name|pmonitor
argument_list|)
expr_stmt|;
comment|/* Drain any buffered messages from the child */
while|while
condition|(
name|pmonitor
operator|->
name|m_log_recvfd
operator|!=
operator|-
literal|1
operator|&&
name|monitor_read_log
argument_list|(
name|pmonitor
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|close
argument_list|(
name|pmonitor
operator|->
name|m_sendfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pmonitor
operator|->
name|m_log_recvfd
argument_list|)
expr_stmt|;
name|pmonitor
operator|->
name|m_sendfd
operator|=
name|pmonitor
operator|->
name|m_log_recvfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_set_child_handler
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|monitor_child_pid
operator|=
name|pid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_child_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|kill
argument_list|(
name|monitor_child_pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|monitor_child_postauth
parameter_list|(
name|struct
name|monitor
modifier|*
name|pmonitor
parameter_list|)
block|{
name|close
argument_list|(
name|pmonitor
operator|->
name|m_recvfd
argument_list|)
expr_stmt|;
name|pmonitor
operator|->
name|m_recvfd
operator|=
operator|-
literal|1
expr_stmt|;
name|monitor_set_child_handler
argument_list|(
name|pmonitor
operator|->
name|m_pid
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|monitor_child_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|monitor_child_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|monitor_child_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGXFSZ
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mon_dispatch
operator|=
name|mon_dispatch_postauth20
expr_stmt|;
comment|/* Permit requests for moduli and signatures */
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_MODULI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_SIGN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_TERM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_pty_flag
condition|)
block|{
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PTY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PTYCLEANUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
name|monitor_read
argument_list|(
name|pmonitor
argument_list|,
name|mon_dispatch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_read_log
parameter_list|(
name|struct
name|monitor
modifier|*
name|pmonitor
parameter_list|)
block|{
name|Buffer
name|logmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|level
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
comment|/* Read length */
name|buffer_append_space
argument_list|(
operator|&
name|logmsg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|pmonitor
operator|->
name|m_log_recvfd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|logmsg
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|logmsg
argument_list|)
argument_list|)
operator|!=
name|buffer_len
argument_list|(
operator|&
name|logmsg
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
block|{
name|buffer_free
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"%s: child log fd closed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pmonitor
operator|->
name|m_log_recvfd
argument_list|)
expr_stmt|;
name|pmonitor
operator|->
name|m_log_recvfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fatal
argument_list|(
literal|"%s: log fd read: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|buffer_get_int
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|4
operator|||
name|len
operator|>
literal|8192
condition|)
name|fatal
argument_list|(
literal|"%s: invalid log message length %u"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Read severity, message */
name|buffer_clear
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
name|buffer_append_space
argument_list|(
operator|&
name|logmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|pmonitor
operator|->
name|m_log_recvfd
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|logmsg
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|logmsg
argument_list|)
argument_list|)
operator|!=
name|buffer_len
argument_list|(
operator|&
name|logmsg
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: log fd read: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Log it */
name|level
operator|=
name|buffer_get_int
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|logmsg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_level_name
argument_list|(
name|level
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: invalid log level %u (corrupted message?)"
argument_list|,
name|__func__
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|do_log2
argument_list|(
name|level
argument_list|,
literal|"%s [preauth]"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|monitor_read
parameter_list|(
name|struct
name|monitor
modifier|*
name|pmonitor
parameter_list|,
name|struct
name|mon_table
modifier|*
name|ent
parameter_list|,
name|struct
name|mon_table
modifier|*
modifier|*
name|pent
parameter_list|)
block|{
name|Buffer
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|struct
name|pollfd
name|pfd
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|memset
argument_list|(
operator|&
name|pfd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pfd
argument_list|)
argument_list|)
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|pmonitor
operator|->
name|m_sendfd
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pfd
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|pmonitor
operator|->
name|m_log_recvfd
expr_stmt|;
name|pfd
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|pfd
index|[
literal|1
index|]
operator|.
name|fd
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|POLLIN
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|pfd
argument_list|,
name|pfd
index|[
literal|1
index|]
operator|.
name|fd
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
name|fatal
argument_list|(
literal|"%s: poll: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfd
index|[
literal|1
index|]
operator|.
name|revents
condition|)
block|{
comment|/* 			 * Drain all log messages before processing next 			 * monitor request. 			 */
name|monitor_read_log
argument_list|(
name|pmonitor
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pfd
index|[
literal|0
index|]
operator|.
name|revents
condition|)
break|break;
comment|/* Continues below */
block|}
name|buffer_init
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|mm_request_receive
argument_list|(
name|pmonitor
operator|->
name|m_sendfd
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|type
operator|=
name|buffer_get_char
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: checking request %d"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|type
operator|==
name|type
condition|)
break|break;
name|ent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ent
operator|->
name|flags
operator|&
name|MON_PERMIT
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s: unpermitted request %d"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|ent
operator|->
name|f
call|)
argument_list|(
name|pmonitor
operator|->
name|m_sendfd
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* The child may use this request only once, disable it */
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|MON_ONCE
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: %d used once, disabling now"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ent
operator|->
name|flags
operator|&=
operator|~
name|MON_PERMIT
expr_stmt|;
block|}
if|if
condition|(
name|pent
operator|!=
name|NULL
condition|)
operator|*
name|pent
operator|=
name|ent
expr_stmt|;
return|return
name|ret
return|;
block|}
name|fatal
argument_list|(
literal|"%s: unsupported request: %d"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* allowed key state */
end_comment

begin_function
specifier|static
name|int
name|monitor_allowed_key
parameter_list|(
name|u_char
modifier|*
name|blob
parameter_list|,
name|u_int
name|bloblen
parameter_list|)
block|{
comment|/* make sure key is allowed */
if|if
condition|(
name|key_blob
operator|==
name|NULL
operator|||
name|key_bloblen
operator|!=
name|bloblen
operator|||
name|timingsafe_bcmp
argument_list|(
name|key_blob
argument_list|,
name|blob
argument_list|,
name|key_bloblen
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_reset_key_state
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* reset state */
name|free
argument_list|(
name|key_blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostbased_cuser
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostbased_chost
argument_list|)
expr_stmt|;
name|key_blob
operator|=
name|NULL
expr_stmt|;
name|key_bloblen
operator|=
literal|0
expr_stmt|;
name|key_blobtype
operator|=
name|MM_NOKEY
expr_stmt|;
name|hostbased_cuser
operator|=
name|NULL
expr_stmt|;
name|hostbased_chost
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_OPENSSL
end_ifdef

begin_function
name|int
name|mm_answer_moduli
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|DH
modifier|*
name|dh
decl_stmt|;
name|int
name|min
decl_stmt|,
name|want
decl_stmt|,
name|max
decl_stmt|;
name|min
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|want
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|max
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: got parameters: %d %d %d"
argument_list|,
name|__func__
argument_list|,
name|min
argument_list|,
name|want
argument_list|,
name|max
argument_list|)
expr_stmt|;
comment|/* We need to check here, too, in case the child got corrupted */
if|if
condition|(
name|max
operator|<
name|min
operator|||
name|want
operator|<
name|min
operator|||
name|max
operator|<
name|want
condition|)
name|fatal
argument_list|(
literal|"%s: bad parameters: %d %d %d"
argument_list|,
name|__func__
argument_list|,
name|min
argument_list|,
name|want
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|dh
operator|=
name|choose_dh
argument_list|(
name|min
argument_list|,
name|want
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
block|{
name|buffer_put_char
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Send first bignum */
name|buffer_put_char
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
name|m
argument_list|,
name|dh
operator|->
name|p
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
name|m
argument_list|,
name|dh
operator|->
name|g
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_MODULI
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mm_answer_sign
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
specifier|extern
name|int
name|auth_sock
decl_stmt|;
comment|/* XXX move to state struct? */
name|struct
name|sshkey
modifier|*
name|key
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|sigbuf
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|p
init|=
name|NULL
decl_stmt|,
modifier|*
name|signature
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|alg
init|=
name|NULL
decl_stmt|;
name|size_t
name|datlen
decl_stmt|,
name|siglen
decl_stmt|,
name|alglen
decl_stmt|;
name|int
name|r
decl_stmt|,
name|is_proof
init|=
literal|0
decl_stmt|;
name|u_int
name|keyid
decl_stmt|;
specifier|const
name|char
name|proof_req
index|[]
init|=
literal|"hostkeys-prove-00@openssh.com"
decl_stmt|;
name|debug3
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|m
argument_list|,
operator|&
name|keyid
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|datlen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|m
argument_list|,
operator|&
name|alg
argument_list|,
operator|&
name|alglen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: buffer error: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyid
operator|>
name|INT_MAX
condition|)
name|fatal
argument_list|(
literal|"%s: invalid key ID"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Supported KEX types use SHA1 (20 bytes), SHA256 (32 bytes), 	 * SHA384 (48 bytes) and SHA512 (64 bytes). 	 * 	 * Otherwise, verify the signature request is for a hostkey 	 * proof. 	 * 	 * XXX perform similar check for KEX signature requests too? 	 * it's not trivial, since what is signed is the hash, rather 	 * than the full kex structure... 	 */
if|if
condition|(
name|datlen
operator|!=
literal|20
operator|&&
name|datlen
operator|!=
literal|32
operator|&&
name|datlen
operator|!=
literal|48
operator|&&
name|datlen
operator|!=
literal|64
condition|)
block|{
comment|/* 		 * Construct expected hostkey proof and compare it to what 		 * the client sent us. 		 */
if|if
condition|(
name|session_id2_len
operator|==
literal|0
condition|)
comment|/* hostkeys is never first */
name|fatal
argument_list|(
literal|"%s: bad data length: %zu"
argument_list|,
name|__func__
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|=
name|get_hostkey_public_by_index
argument_list|(
name|keyid
argument_list|,
name|ssh
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: no hostkey for index %d"
argument_list|,
name|__func__
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigbuf
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|sigbuf
argument_list|,
name|proof_req
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|sigbuf
argument_list|,
name|session_id2
argument_list|,
name|session_id2_len
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_puts
argument_list|(
name|key
argument_list|,
name|sigbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: couldn't prepare private key "
literal|"proof buffer: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datlen
operator|!=
name|sshbuf_len
argument_list|(
name|sigbuf
argument_list|)
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
name|sshbuf_ptr
argument_list|(
name|sigbuf
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|sigbuf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: bad data length: %zu, hostkey proof len %zu"
argument_list|,
name|__func__
argument_list|,
name|datlen
argument_list|,
name|sshbuf_len
argument_list|(
name|sigbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|sigbuf
argument_list|)
expr_stmt|;
name|is_proof
operator|=
literal|1
expr_stmt|;
block|}
comment|/* save session id, it will be passed on the first call */
if|if
condition|(
name|session_id2_len
operator|==
literal|0
condition|)
block|{
name|session_id2_len
operator|=
name|datlen
expr_stmt|;
name|session_id2
operator|=
name|xmalloc
argument_list|(
name|session_id2_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|session_id2
argument_list|,
name|p
argument_list|,
name|session_id2_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|key
operator|=
name|get_hostkey_by_index
argument_list|(
name|keyid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_sign
argument_list|(
name|key
argument_list|,
operator|&
name|signature
argument_list|,
operator|&
name|siglen
argument_list|,
name|p
argument_list|,
name|datlen
argument_list|,
name|alg
argument_list|,
name|datafellows
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: sshkey_sign failed: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|key
operator|=
name|get_hostkey_public_by_index
argument_list|(
name|keyid
argument_list|,
name|ssh
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|auth_sock
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_agent_sign
argument_list|(
name|auth_sock
argument_list|,
name|key
argument_list|,
operator|&
name|signature
argument_list|,
operator|&
name|siglen
argument_list|,
name|p
argument_list|,
name|datlen
argument_list|,
name|alg
argument_list|,
name|datafellows
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"%s: ssh_agent_sign failed: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fatal
argument_list|(
literal|"%s: no hostkey from index %d"
argument_list|,
name|__func__
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: %s signature %p(%zu)"
argument_list|,
name|__func__
argument_list|,
name|is_proof
condition|?
literal|"KEX"
else|:
literal|"hostkey proof"
argument_list|,
name|signature
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
name|sshbuf_reset
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|m
argument_list|,
name|signature
argument_list|,
name|siglen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: buffer error: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_SIGN
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Turn on permissions for getpwnam */
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PWNAM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieves the password entry and also checks if the user is permitted */
end_comment

begin_function
name|int
name|mm_answer_pwnamallow
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|char
modifier|*
name|username
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|int
name|allowed
init|=
literal|0
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|debug3
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|attempt
operator|++
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: multiple attempts for getpwnam"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|username
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pwent
operator|=
name|getpwnamallow
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|user
operator|=
name|xstrdup
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"%s [priv]"
argument_list|,
name|pwent
condition|?
name|username
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
operator|==
name|NULL
condition|)
block|{
name|buffer_put_char
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|pw
operator|=
name|fakepw
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|allowed
operator|=
literal|1
expr_stmt|;
name|authctxt
operator|->
name|pw
operator|=
name|pwent
expr_stmt|;
name|authctxt
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|buffer_put_char
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
name|m
argument_list|,
name|pwent
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|passwd
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_PASSWD_PW_GECOS
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|pwent
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_STRUCT_PASSWD_PW_CLASS
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|pwent
operator|->
name|pw_class
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|pwent
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|pwent
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|out
label|:
name|ssh_packet_set_log_preamble
argument_list|(
name|ssh
argument_list|,
literal|"%suser %s"
argument_list|,
name|authctxt
operator|->
name|valid
condition|?
literal|"authenticating"
else|:
literal|"invalid "
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
name|m
argument_list|,
operator|&
name|options
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|M_CP_STROPT
parameter_list|(
name|x
parameter_list|)
value|do { \ 		if (options.x != NULL) \ 			buffer_put_cstring(m, options.x); \ 	} while (0)
define|#
directive|define
name|M_CP_STRARRAYOPT
parameter_list|(
name|x
parameter_list|,
name|nx
parameter_list|)
value|do { \ 		for (i = 0; i< options.nx; i++) \ 			buffer_put_cstring(m, options.x[i]); \ 	} while (0)
comment|/* See comment in servconf.h */
name|COPY_MATCH_STRING_OPTS
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|M_CP_STROPT
undef|#
directive|undef
name|M_CP_STRARRAYOPT
comment|/* Create valid auth method lists */
if|if
condition|(
name|auth2_setup_methods_lists
argument_list|(
name|authctxt
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The monitor will continue long enough to let the child 		 * run to it's packet_disconnect(), but it must not allow any 		 * authentication to succeed. 		 */
name|debug
argument_list|(
literal|"%s: no valid authentication method lists"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|debug3
argument_list|(
literal|"%s: sending MONITOR_ANS_PWNAM: %d"
argument_list|,
name|__func__
argument_list|,
name|allowed
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PWNAM
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Allow service/style information on the auth context */
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_AUTHSERV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_AUTH2_READ_BANNER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
if|if
condition|(
name|options
operator|.
name|use_pam
condition|)
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_auth2_read_banner
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
name|banner
decl_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|banner
operator|=
name|auth2_read_banner
argument_list|()
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|banner
operator|!=
name|NULL
condition|?
name|banner
else|:
literal|""
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_AUTH2_READ_BANNER
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|banner
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_authserv
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|monitor_permit_authentications
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|service
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|style
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: service=%s, style=%s"
argument_list|,
name|__func__
argument_list|,
name|authctxt
operator|->
name|service
argument_list|,
name|authctxt
operator|->
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|authctxt
operator|->
name|style
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|authctxt
operator|->
name|style
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|style
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_authpassword
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
specifier|static
name|int
name|call_count
decl_stmt|;
name|char
modifier|*
name|passwd
decl_stmt|;
name|int
name|authenticated
decl_stmt|;
name|u_int
name|plen
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|password_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: password authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|passwd
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|plen
argument_list|)
expr_stmt|;
comment|/* Only authenticate if the context is valid */
name|authenticated
operator|=
name|options
operator|.
name|password_authentication
operator|&&
name|auth_password
argument_list|(
name|authctxt
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
name|explicit_bzero
argument_list|(
name|passwd
argument_list|,
name|strlen
argument_list|(
name|passwd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|authenticated
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|sshpam_get_maxtries_reached
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug3
argument_list|(
literal|"%s: sending result %d"
argument_list|,
name|__func__
argument_list|,
name|authenticated
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_AUTHPASSWORD
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|call_count
operator|++
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
operator|&&
name|call_count
operator|==
literal|1
condition|)
name|auth_method
operator|=
literal|"none"
expr_stmt|;
else|else
name|auth_method
operator|=
literal|"password"
expr_stmt|;
comment|/* Causes monitor loop to terminate if authenticated */
return|return
operator|(
name|authenticated
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_AUTH
end_ifdef

begin_function
name|int
name|mm_answer_bsdauthquery
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|infotxt
decl_stmt|;
name|u_int
name|numprompts
decl_stmt|;
name|u_int
modifier|*
name|echo_on
decl_stmt|;
name|char
modifier|*
modifier|*
name|prompts
decl_stmt|;
name|u_int
name|success
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|kbd_interactive_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: kbd-int authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|success
operator|=
name|bsdauth_query
argument_list|(
name|authctxt
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|infotxt
argument_list|,
operator|&
name|numprompts
argument_list|,
operator|&
name|prompts
argument_list|,
operator|&
name|echo_on
argument_list|)
operator|<
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|prompts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: sending challenge success: %u"
argument_list|,
name|__func__
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_BSDAUTHQUERY
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|infotxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|echo_on
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_bsdauthrespond
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
name|response
decl_stmt|;
name|int
name|authok
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|kbd_interactive_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: kbd-int authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|as
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: no bsd auth session"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|response
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|authok
operator|=
name|options
operator|.
name|challenge_response_authentication
operator|&&
name|auth_userresponse
argument_list|(
name|authctxt
operator|->
name|as
argument_list|,
name|response
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|as
operator|=
name|NULL
expr_stmt|;
name|debug3
argument_list|(
literal|"%s:<%s> =<%d>"
argument_list|,
name|__func__
argument_list|,
name|response
argument_list|,
name|authok
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|authok
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: sending authenticated: %d"
argument_list|,
name|__func__
argument_list|,
name|authok
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_BSDAUTHRESPOND
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"keyboard-interactive"
expr_stmt|;
name|auth_submethod
operator|=
literal|"bsdauth"
expr_stmt|;
return|return
operator|(
name|authok
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SKEY
end_ifdef

begin_function
name|int
name|mm_answer_skeyquery
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|skey
name|skey
decl_stmt|;
name|char
name|challenge
index|[
literal|1024
index|]
decl_stmt|;
name|u_int
name|success
decl_stmt|;
name|success
operator|=
name|_compat_skeychallenge
argument_list|(
operator|&
name|skey
argument_list|,
name|authctxt
operator|->
name|user
argument_list|,
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge
argument_list|)
argument_list|)
operator|<
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|challenge
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: sending challenge success: %u"
argument_list|,
name|__func__
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_SKEYQUERY
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_skeyrespond
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
name|response
decl_stmt|;
name|int
name|authok
decl_stmt|;
name|response
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|authok
operator|=
operator|(
name|options
operator|.
name|challenge_response_authentication
operator|&&
name|authctxt
operator|->
name|valid
operator|&&
name|skey_haskey
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
operator|&&
name|skey_passcheck
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|,
name|response
argument_list|)
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|authok
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: sending authenticated: %d"
argument_list|,
name|__func__
argument_list|,
name|authok
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_SKEYRESPOND
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"keyboard-interactive"
expr_stmt|;
name|auth_submethod
operator|=
literal|"skey"
expr_stmt|;
return|return
operator|(
name|authok
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PAM
end_ifdef

begin_function
name|int
name|mm_answer_pam_start
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
operator|!
name|options
operator|.
name|use_pam
condition|)
name|fatal
argument_list|(
literal|"UsePAM not set, but ended up in %s anyway"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|start_pam
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_ACCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|kbd_interactive_authentication
condition|)
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_INIT_CTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_pam_account
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|u_int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|use_pam
condition|)
name|fatal
argument_list|(
literal|"%s: PAM not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|do_pam_account
argument_list|()
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
name|m
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|loginmsg
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|loginmsg
argument_list|)
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PAM_ACCOUNT
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sshpam_ctxt
decl_stmt|,
modifier|*
name|sshpam_authok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|KbdintDevice
name|sshpam_device
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mm_answer_pam_init_ctx
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|kbd_interactive_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: kbd-int authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshpam_ctxt
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: already called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sshpam_ctxt
operator|=
call|(
name|sshpam_device
operator|.
name|init_ctx
call|)
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
name|sshpam_authok
operator|=
name|NULL
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshpam_ctxt
operator|!=
name|NULL
condition|)
block|{
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_FREE_CTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_QUERY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer_put_int
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PAM_INIT_CTX
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_pam_query
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|info
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|prompts
init|=
name|NULL
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|,
modifier|*
name|echo_on
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|debug3
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sshpam_authok
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sshpam_ctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: no context"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
name|sshpam_device
operator|.
name|query
call|)
argument_list|(
name|sshpam_ctxt
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|info
argument_list|,
operator|&
name|num
argument_list|,
operator|&
name|prompts
argument_list|,
operator|&
name|echo_on
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|num
operator|==
literal|0
condition|)
name|sshpam_authok
operator|=
name|sshpam_ctxt
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|1
operator|||
name|name
operator|==
name|NULL
operator|||
name|info
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"sshpam_device.query failed"
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_RESPOND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|sshpam_get_maxtries_reached
argument_list|()
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|prompts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|echo_on
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|prompts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|echo_on
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"keyboard-interactive"
expr_stmt|;
name|auth_submethod
operator|=
literal|"pam"
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PAM_QUERY
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_pam_respond
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|resp
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|debug3
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshpam_ctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: no context"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sshpam_authok
operator|=
name|NULL
expr_stmt|;
name|num
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|resp
operator|=
name|xcalloc
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|resp
index|[
name|i
index|]
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
name|sshpam_device
operator|.
name|respond
call|)
argument_list|(
name|sshpam_ctxt
argument_list|,
name|num
argument_list|,
name|resp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|resp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
call|(
name|sshpam_device
operator|.
name|respond
call|)
argument_list|(
name|sshpam_ctxt
argument_list|,
name|num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PAM_RESPOND
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"keyboard-interactive"
expr_stmt|;
name|auth_submethod
operator|=
literal|"pam"
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|sshpam_authok
operator|=
name|sshpam_ctxt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_pam_free_ctx
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|int
name|r
init|=
name|sshpam_authok
operator|!=
name|NULL
operator|&&
name|sshpam_authok
operator|==
name|sshpam_ctxt
decl_stmt|;
name|debug3
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshpam_ctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: no context"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
call|(
name|sshpam_device
operator|.
name|free_ctx
call|)
argument_list|(
name|sshpam_ctxt
argument_list|)
expr_stmt|;
name|sshpam_ctxt
operator|=
name|sshpam_authok
operator|=
name|NULL
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PAM_FREE_CTX
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Allow another attempt */
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_PAM_INIT_CTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"keyboard-interactive"
expr_stmt|;
name|auth_submethod
operator|=
literal|"pam"
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mm_answer_keyallowed
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|Key
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|cuser
decl_stmt|,
modifier|*
name|chost
decl_stmt|;
name|u_char
modifier|*
name|blob
decl_stmt|;
name|u_int
name|bloblen
decl_stmt|,
name|pubkey_auth_attempt
decl_stmt|;
name|enum
name|mm_keytype
name|type
init|=
literal|0
decl_stmt|;
name|int
name|allowed
init|=
literal|0
decl_stmt|;
name|debug3
argument_list|(
literal|"%s entering"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|type
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cuser
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|chost
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|blob
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|bloblen
argument_list|)
expr_stmt|;
name|pubkey_auth_attempt
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|key
operator|=
name|key_from_blob
argument_list|(
name|blob
argument_list|,
name|bloblen
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: key_from_blob: %p"
argument_list|,
name|__func__
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
operator|&&
name|authctxt
operator|->
name|valid
condition|)
block|{
comment|/* These should not make it past the privsep child */
if|if
condition|(
name|key_type_plain
argument_list|(
name|key
operator|->
name|type
argument_list|)
operator|==
name|KEY_RSA
operator|&&
operator|(
name|datafellows
operator|&
name|SSH_BUG_RSASIGMD5
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: passed a SSH_BUG_RSASIGMD5 key"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MM_USERKEY
case|:
name|allowed
operator|=
name|options
operator|.
name|pubkey_authentication
operator|&&
operator|!
name|auth2_userkey_already_used
argument_list|(
name|authctxt
argument_list|,
name|key
argument_list|)
operator|&&
name|match_pattern_list
argument_list|(
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|,
name|options
operator|.
name|pubkey_key_types
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|&&
name|user_key_allowed
argument_list|(
name|authctxt
operator|->
name|pw
argument_list|,
name|key
argument_list|,
name|pubkey_auth_attempt
argument_list|)
expr_stmt|;
name|pubkey_auth_info
argument_list|(
name|authctxt
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"publickey"
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|pubkey_authentication
operator|&&
operator|(
operator|!
name|pubkey_auth_attempt
operator|||
name|allowed
operator|!=
literal|1
operator|)
condition|)
name|auth_clear_options
argument_list|()
expr_stmt|;
break|break;
case|case
name|MM_HOSTKEY
case|:
name|allowed
operator|=
name|options
operator|.
name|hostbased_authentication
operator|&&
name|match_pattern_list
argument_list|(
name|sshkey_ssh_name
argument_list|(
name|key
argument_list|)
argument_list|,
name|options
operator|.
name|hostbased_key_types
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|&&
name|hostbased_key_allowed
argument_list|(
name|authctxt
operator|->
name|pw
argument_list|,
name|cuser
argument_list|,
name|chost
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|pubkey_auth_info
argument_list|(
name|authctxt
argument_list|,
name|key
argument_list|,
literal|"client user \"%.100s\", client host \"%.100s\""
argument_list|,
name|cuser
argument_list|,
name|chost
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"hostbased"
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"%s: unknown key type %d"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|debug3
argument_list|(
literal|"%s: key %p is %s"
argument_list|,
name|__func__
argument_list|,
name|key
argument_list|,
name|allowed
condition|?
literal|"allowed"
else|:
literal|"not allowed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|key_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* clear temporarily storage (used by verify) */
name|monitor_reset_key_state
argument_list|()
expr_stmt|;
if|if
condition|(
name|allowed
condition|)
block|{
comment|/* Save temporarily for comparison in verify */
name|key_blob
operator|=
name|blob
expr_stmt|;
name|key_bloblen
operator|=
name|bloblen
expr_stmt|;
name|key_blobtype
operator|=
name|type
expr_stmt|;
name|hostbased_cuser
operator|=
name|cuser
expr_stmt|;
name|hostbased_chost
operator|=
name|chost
expr_stmt|;
block|}
else|else
block|{
comment|/* Log failed attempt */
name|auth_log
argument_list|(
name|authctxt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|auth_method
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cuser
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chost
argument_list|)
expr_stmt|;
block|}
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|allowed
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|forced_command
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_KEYALLOWED
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_valid_userblob
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|u_int
name|datalen
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|userstyle
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_OLD_SESSIONID
condition|)
block|{
name|p
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|session_id2
operator|==
name|NULL
operator|)
operator|||
operator|(
name|len
operator|<
name|session_id2_len
operator|)
operator|||
operator|(
name|timingsafe_bcmp
argument_list|(
name|p
argument_list|,
name|session_id2
argument_list|,
name|session_id2_len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fail
operator|++
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|b
argument_list|,
name|session_id2_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|session_id2
operator|==
name|NULL
operator|)
operator|||
operator|(
name|len
operator|!=
name|session_id2_len
operator|)
operator|||
operator|(
name|timingsafe_bcmp
argument_list|(
name|p
argument_list|,
name|session_id2
argument_list|,
name|session_id2_len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fail
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buffer_get_char
argument_list|(
operator|&
name|b
argument_list|)
operator|!=
name|SSH2_MSG_USERAUTH_REQUEST
condition|)
name|fail
operator|++
expr_stmt|;
name|cp
operator|=
name|buffer_get_cstring
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|userstyle
argument_list|,
literal|"%s%s%s"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|,
name|authctxt
operator|->
name|style
condition|?
literal|":"
else|:
literal|""
argument_list|,
name|authctxt
operator|->
name|style
condition|?
name|authctxt
operator|->
name|style
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|userstyle
argument_list|,
name|cp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wrong user name passed to monitor: "
literal|"expected %s != %.100s"
argument_list|,
name|userstyle
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|userstyle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|buffer_skip_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_PKAUTH
condition|)
block|{
if|if
condition|(
operator|!
name|buffer_get_char
argument_list|(
operator|&
name|b
argument_list|)
condition|)
name|fail
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|buffer_get_cstring
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"publickey"
argument_list|,
name|cp
argument_list|)
operator|!=
literal|0
condition|)
name|fail
operator|++
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_get_char
argument_list|(
operator|&
name|b
argument_list|)
condition|)
name|fail
operator|++
expr_stmt|;
name|buffer_skip_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
name|buffer_skip_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|!=
literal|0
condition|)
name|fail
operator|++
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|fail
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_valid_hostbasedblob
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|u_int
name|datalen
parameter_list|,
name|char
modifier|*
name|cuser
parameter_list|,
name|char
modifier|*
name|chost
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|userstyle
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|session_id2
operator|==
name|NULL
operator|)
operator|||
operator|(
name|len
operator|!=
name|session_id2_len
operator|)
operator|||
operator|(
name|timingsafe_bcmp
argument_list|(
name|p
argument_list|,
name|session_id2
argument_list|,
name|session_id2_len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fail
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_get_char
argument_list|(
operator|&
name|b
argument_list|)
operator|!=
name|SSH2_MSG_USERAUTH_REQUEST
condition|)
name|fail
operator|++
expr_stmt|;
name|p
operator|=
name|buffer_get_cstring
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|userstyle
argument_list|,
literal|"%s%s%s"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|,
name|authctxt
operator|->
name|style
condition|?
literal|":"
else|:
literal|""
argument_list|,
name|authctxt
operator|->
name|style
condition|?
name|authctxt
operator|->
name|style
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|userstyle
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wrong user name passed to monitor: expected %s != %.100s"
argument_list|,
name|userstyle
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|userstyle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|buffer_skip_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* service */
name|p
operator|=
name|buffer_get_cstring
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"hostbased"
argument_list|)
operator|!=
literal|0
condition|)
name|fail
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|buffer_skip_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* pkalg */
name|buffer_skip_string
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* pkblob */
comment|/* verify client host, strip trailing dot if necessary */
name|p
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|chost
argument_list|)
operator|!=
literal|0
condition|)
name|fail
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* verify client user */
name|p
operator|=
name|buffer_get_string
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|cuser
argument_list|)
operator|!=
literal|0
condition|)
name|fail
operator|++
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|!=
literal|0
condition|)
name|fail
operator|++
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|fail
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_keyverify
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|Key
modifier|*
name|key
decl_stmt|;
name|u_char
modifier|*
name|signature
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|blob
decl_stmt|;
name|u_int
name|signaturelen
decl_stmt|,
name|datalen
decl_stmt|,
name|bloblen
decl_stmt|;
name|int
name|verified
init|=
literal|0
decl_stmt|;
name|int
name|valid_data
init|=
literal|0
decl_stmt|;
name|blob
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|bloblen
argument_list|)
expr_stmt|;
name|signature
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|signaturelen
argument_list|)
expr_stmt|;
name|data
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostbased_cuser
operator|==
name|NULL
operator|||
name|hostbased_chost
operator|==
name|NULL
operator|||
operator|!
name|monitor_allowed_key
argument_list|(
name|blob
argument_list|,
name|bloblen
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: bad key, not previously allowed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|key
operator|=
name|key_from_blob
argument_list|(
name|blob
argument_list|,
name|bloblen
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: bad public key blob"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key_blobtype
condition|)
block|{
case|case
name|MM_USERKEY
case|:
name|valid_data
operator|=
name|monitor_valid_userblob
argument_list|(
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
break|break;
case|case
name|MM_HOSTKEY
case|:
name|valid_data
operator|=
name|monitor_valid_hostbasedblob
argument_list|(
name|data
argument_list|,
name|datalen
argument_list|,
name|hostbased_cuser
argument_list|,
name|hostbased_chost
argument_list|)
expr_stmt|;
break|break;
default|default:
name|valid_data
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|valid_data
condition|)
name|fatal
argument_list|(
literal|"%s: bad signature data blob"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|verified
operator|=
name|key_verify
argument_list|(
name|key
argument_list|,
name|signature
argument_list|,
name|signaturelen
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: key %p signature %s"
argument_list|,
name|__func__
argument_list|,
name|key
argument_list|,
operator|(
name|verified
operator|==
literal|1
operator|)
condition|?
literal|"verified"
else|:
literal|"unverified"
argument_list|)
expr_stmt|;
comment|/* If auth was successful then record key to ensure it isn't reused */
if|if
condition|(
name|verified
operator|==
literal|1
operator|&&
name|key_blobtype
operator|==
name|MM_USERKEY
condition|)
name|auth2_record_userkey
argument_list|(
name|authctxt
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|key_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|auth_method
operator|=
name|key_blobtype
operator|==
name|MM_USERKEY
condition|?
literal|"publickey"
else|:
literal|"hostbased"
expr_stmt|;
name|monitor_reset_key_state
argument_list|()
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|verified
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_KEYVERIFY
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|verified
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mm_record_login
parameter_list|(
name|Session
modifier|*
name|s
parameter_list|,
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|socklen_t
name|fromlen
decl_stmt|;
name|struct
name|sockaddr_storage
name|from
decl_stmt|;
comment|/* 	 * Get IP address of client. If the connection is not a socket, let 	 * the address be 0.0.0.0. 	 */
name|memset
argument_list|(
operator|&
name|from
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_connection_is_on_socket
argument_list|()
condition|)
block|{
if|if
condition|(
name|getpeername
argument_list|(
name|packet_get_connection_in
argument_list|()
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"getpeername: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record that there was a login on that tty from the remote host. */
name|record_login
argument_list|(
name|s
operator|->
name|pid
argument_list|,
name|s
operator|->
name|tty
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|session_get_remote_name_or_ip
argument_list|(
name|ssh
argument_list|,
name|utmp_len
argument_list|,
name|options
operator|.
name|use_dns
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mm_session_close
parameter_list|(
name|Session
modifier|*
name|s
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"%s: session %d pid %ld"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|self
argument_list|,
operator|(
name|long
operator|)
name|s
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ttyfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|debug3
argument_list|(
literal|"%s: tty %s ptyfd %d"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|tty
argument_list|,
name|s
operator|->
name|ptyfd
argument_list|)
expr_stmt|;
name|session_pty_cleanup2
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|session_unused
argument_list|(
name|s
operator|->
name|self
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mm_answer_pty
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
specifier|extern
name|struct
name|monitor
modifier|*
name|pmonitor
decl_stmt|;
name|Session
modifier|*
name|s
decl_stmt|;
name|int
name|res
decl_stmt|,
name|fd0
decl_stmt|;
name|debug3
argument_list|(
literal|"%s entering"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|s
operator|=
name|session_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|s
operator|->
name|authctxt
operator|=
name|authctxt
expr_stmt|;
name|s
operator|->
name|pw
operator|=
name|authctxt
operator|->
name|pw
expr_stmt|;
name|s
operator|->
name|pid
operator|=
name|pmonitor
operator|->
name|m_pid
expr_stmt|;
name|res
operator|=
name|pty_allocate
argument_list|(
operator|&
name|s
operator|->
name|ptyfd
argument_list|,
operator|&
name|s
operator|->
name|ttyfd
argument_list|,
name|s
operator|->
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|tty
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
name|pty_setowner
argument_list|(
name|authctxt
operator|->
name|pw
argument_list|,
name|s
operator|->
name|tty
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
name|m
argument_list|,
name|s
operator|->
name|tty
argument_list|)
expr_stmt|;
comment|/* We need to trick ttyslot */
if|if
condition|(
name|dup2
argument_list|(
name|s
operator|->
name|ttyfd
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: dup2"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mm_record_login
argument_list|(
name|s
argument_list|,
name|authctxt
operator|->
name|pw
argument_list|)
expr_stmt|;
comment|/* Now we can close the file descriptor again */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* send messages generated by record_login */
name|buffer_put_string
argument_list|(
name|m
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|loginmsg
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|loginmsg
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
operator|&
name|loginmsg
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PTY
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm_send_fd
argument_list|(
name|sock
argument_list|,
name|s
operator|->
name|ptyfd
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|mm_send_fd
argument_list|(
name|sock
argument_list|,
name|s
operator|->
name|ttyfd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: send fds failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* make sure nothing uses fd 0 */
if|if
condition|(
operator|(
name|fd0
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: open(/dev/null): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd0
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"%s: fd0 %d != 0"
argument_list|,
name|__func__
argument_list|,
name|fd0
argument_list|)
expr_stmt|;
comment|/* slave is not needed */
name|close
argument_list|(
name|s
operator|->
name|ttyfd
argument_list|)
expr_stmt|;
name|s
operator|->
name|ttyfd
operator|=
name|s
operator|->
name|ptyfd
expr_stmt|;
comment|/* no need to dup() because nobody closes ptyfd */
name|s
operator|->
name|ptymaster
operator|=
name|s
operator|->
name|ptyfd
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: tty %s ptyfd %d"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|tty
argument_list|,
name|s
operator|->
name|ttyfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|mm_session_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_PTY
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_pty_cleanup
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|Session
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|;
name|debug3
argument_list|(
literal|"%s entering"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tty
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|session_by_tty
argument_list|(
name|tty
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|mm_session_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tty
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_term
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|req
parameter_list|)
block|{
specifier|extern
name|struct
name|monitor
modifier|*
name|pmonitor
decl_stmt|;
name|int
name|res
decl_stmt|,
name|status
decl_stmt|;
name|debug3
argument_list|(
literal|"%s: tearing down sessions"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* The child is terminating */
name|session_destroy_all
argument_list|(
operator|&
name|mm_session_close
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
if|if
condition|(
name|options
operator|.
name|use_pam
condition|)
name|sshpam_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|waitpid
argument_list|(
name|pmonitor
operator|->
name|m_pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
else|:
literal|1
expr_stmt|;
comment|/* Terminate process */
name|exit
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
end_ifdef

begin_comment
comment|/* Report that an audit event occurred */
end_comment

begin_function
name|int
name|mm_answer_audit_event
parameter_list|(
name|int
name|socket
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|ssh_audit_event_t
name|event
decl_stmt|;
name|debug3
argument_list|(
literal|"%s entering"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|event
operator|=
name|buffer_get_int
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|SSH_AUTH_FAIL_PUBKEY
case|:
case|case
name|SSH_AUTH_FAIL_HOSTBASED
case|:
case|case
name|SSH_AUTH_FAIL_GSSAPI
case|:
case|case
name|SSH_LOGIN_EXCEED_MAXTRIES
case|:
case|case
name|SSH_LOGIN_ROOT_DENIED
case|:
case|case
name|SSH_CONNECTION_CLOSE
case|:
case|case
name|SSH_INVALID_USER
case|:
name|audit_event
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"Audit event type %d not permitted"
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_audit_command
parameter_list|(
name|int
name|socket
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|debug3
argument_list|(
literal|"%s entering"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* sanity check command, if so how? */
name|audit_run_command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SSH_AUDIT_EVENTS */
end_comment

begin_function
name|void
name|monitor_apply_keystate
parameter_list|(
name|struct
name|monitor
modifier|*
name|pmonitor
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|ssh
init|=
name|active_state
decl_stmt|;
comment|/* XXX */
name|struct
name|kex
modifier|*
name|kex
decl_stmt|;
name|int
name|r
decl_stmt|;
name|debug3
argument_list|(
literal|"%s: packet_set_state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_packet_set_state
argument_list|(
name|ssh
argument_list|,
name|child_state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: packet_set_state: %s"
argument_list|,
name|__func__
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|child_state
argument_list|)
expr_stmt|;
name|child_state
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|kex
operator|=
name|ssh
operator|->
name|kex
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX set callbacks */
ifdef|#
directive|ifdef
name|WITH_OPENSSL
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP1_SHA1
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP14_SHA1
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP14_SHA256
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP16_SHA512
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP18_SHA512
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GEX_SHA1
index|]
operator|=
name|kexgex_server
expr_stmt|;
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GEX_SHA256
index|]
operator|=
name|kexgex_server
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
name|kex
operator|->
name|kex
index|[
name|KEX_ECDH_SHA2
index|]
operator|=
name|kexecdh_server
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* WITH_OPENSSL */
name|kex
operator|->
name|kex
index|[
name|KEX_C25519_SHA256
index|]
operator|=
name|kexc25519_server
expr_stmt|;
name|kex
operator|->
name|load_host_public_key
operator|=
operator|&
name|get_hostkey_public_by_type
expr_stmt|;
name|kex
operator|->
name|load_host_private_key
operator|=
operator|&
name|get_hostkey_private_by_type
expr_stmt|;
name|kex
operator|->
name|host_key_index
operator|=
operator|&
name|get_hostkey_index
expr_stmt|;
name|kex
operator|->
name|sign
operator|=
name|sshd_hostkey_sign
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function requries careful sanity checking */
end_comment

begin_function
name|void
name|mm_get_keystate
parameter_list|(
name|struct
name|monitor
modifier|*
name|pmonitor
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"%s: Waiting for new keys"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child_state
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: sshbuf_new failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mm_request_receive_expect
argument_list|(
name|pmonitor
operator|->
name|m_sendfd
argument_list|,
name|MONITOR_REQ_KEYEXPORT
argument_list|,
name|child_state
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: GOT new keys"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|FD_CLOSEONEXEC
parameter_list|(
name|x
parameter_list|)
value|do { \ 	if (fcntl(x, F_SETFD, FD_CLOEXEC) == -1) \ 		fatal("fcntl(%d, F_SETFD)", x); \ } while (0)
end_define

begin_function
specifier|static
name|void
name|monitor_openfds
parameter_list|(
name|struct
name|monitor
modifier|*
name|mon
parameter_list|,
name|int
name|do_logfds
parameter_list|)
block|{
name|int
name|pair
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pair
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: socketpair: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|FD_CLOSEONEXEC
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|FD_CLOSEONEXEC
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mon
operator|->
name|m_recvfd
operator|=
name|pair
index|[
literal|0
index|]
expr_stmt|;
name|mon
operator|->
name|m_sendfd
operator|=
name|pair
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|do_logfds
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pair
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: pipe: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|FD_CLOSEONEXEC
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|FD_CLOSEONEXEC
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mon
operator|->
name|m_log_recvfd
operator|=
name|pair
index|[
literal|0
index|]
expr_stmt|;
name|mon
operator|->
name|m_log_sendfd
operator|=
name|pair
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|mon
operator|->
name|m_log_recvfd
operator|=
name|mon
operator|->
name|m_log_sendfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MM_MEMSIZE
value|65536
end_define

begin_function
name|struct
name|monitor
modifier|*
name|monitor_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|monitor
modifier|*
name|mon
decl_stmt|;
name|mon
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mon
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_openfds
argument_list|(
name|mon
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|mon
return|;
block|}
end_function

begin_function
name|void
name|monitor_reinit
parameter_list|(
name|struct
name|monitor
modifier|*
name|mon
parameter_list|)
block|{
name|monitor_openfds
argument_list|(
name|mon
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_function
name|int
name|mm_answer_gss_setup_ctx
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|gss_OID_desc
name|goid
decl_stmt|;
name|OM_uint32
name|major
decl_stmt|;
name|u_int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|gss_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: GSSAPI authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|goid
operator|.
name|elements
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|goid
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|major
operator|=
name|ssh_gssapi_server_ctx
argument_list|(
operator|&
name|gsscontext
argument_list|,
operator|&
name|goid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|goid
operator|.
name|elements
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|major
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_GSSSETUP
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Now we have a context, enable the step */
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_GSSSTEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_gss_accept_ctx
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|gss_buffer_desc
name|in
decl_stmt|;
name|gss_buffer_desc
name|out
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|;
name|OM_uint32
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|OM_uint32
name|flags
init|=
literal|0
decl_stmt|;
comment|/* GSI needs this */
name|u_int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|gss_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: GSSAPI authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|in
operator|.
name|value
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|in
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|major
operator|=
name|ssh_gssapi_accept_ctx
argument_list|(
name|gsscontext
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
operator|.
name|value
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|major
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
name|m
argument_list|,
name|out
operator|.
name|value
argument_list|,
name|out
operator|.
name|length
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_GSSSTEP
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_GSSSTEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_GSSUSEROK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_GSSCHECKMIC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_gss_checkmic
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|gss_buffer_desc
name|gssbuf
decl_stmt|,
name|mic
decl_stmt|;
name|OM_uint32
name|ret
decl_stmt|;
name|u_int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|gss_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: GSSAPI authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|gssbuf
operator|.
name|value
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|gssbuf
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|mic
operator|.
name|value
operator|=
name|buffer_get_string
argument_list|(
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|mic
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|ret
operator|=
name|ssh_gssapi_checkmic
argument_list|(
name|gsscontext
argument_list|,
operator|&
name|gssbuf
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gssbuf
operator|.
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mic
operator|.
name|value
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_GSSCHECKMIC
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GSS_ERROR
argument_list|(
name|ret
argument_list|)
condition|)
name|monitor_permit
argument_list|(
name|mon_dispatch
argument_list|,
name|MONITOR_REQ_GSSUSEROK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mm_answer_gss_userok
parameter_list|(
name|int
name|sock
parameter_list|,
name|Buffer
modifier|*
name|m
parameter_list|)
block|{
name|int
name|authenticated
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|gss_authentication
condition|)
name|fatal
argument_list|(
literal|"%s: GSSAPI authentication not enabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|authenticated
operator|=
name|authctxt
operator|->
name|valid
operator|&&
name|ssh_gssapi_userok
argument_list|(
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
name|buffer_clear
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|buffer_put_int
argument_list|(
name|m
argument_list|,
name|authenticated
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: sending result %d"
argument_list|,
name|__func__
argument_list|,
name|authenticated
argument_list|)
expr_stmt|;
name|mm_request_send
argument_list|(
name|sock
argument_list|,
name|MONITOR_ANS_GSSUSEROK
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|auth_method
operator|=
literal|"gssapi-with-mic"
expr_stmt|;
comment|/* Monitor loop will terminate if authenticated */
return|return
operator|(
name|authenticated
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GSSAPI */
end_comment

end_unit

