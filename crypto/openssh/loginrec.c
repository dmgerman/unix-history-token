begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Andre Lucas.  All rights reserved.  * Portions copyright (c) 1998 Todd C. Miller  * Portions copyright (c) 1996 Jason Downs  * Portions copyright (c) 1996 Theo de Raadt  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  ** loginrec.c:  platform-independent login recording and lastlog retrieval  **/
end_comment

begin_comment
comment|/*   The new login code explained   ============================    This code attempts to provide a common interface to login recording   (utmp and friends) and last login time retrieval.    Its primary means of achieving this is to use 'struct logininfo', a   union of all the useful fields in the various different types of   system login record structures one finds on UNIX variants.    We depend on autoconf to define which recording methods are to be   used, and which fields are contained in the relevant data structures   on the local system. Many C preprocessor symbols affect which code   gets compiled here.    The code is designed to make it easy to modify a particular   recording method, without affecting other methods nor requiring so   many nested conditional compilation blocks as were commonplace in   the old code.    For login recording, we try to use the local system's libraries as   these are clearly most likely to work correctly. For utmp systems   this usually means login() and logout() or setutent() etc., probably   in libutil, along with logwtmp() etc. On these systems, we fall back   to writing the files directly if we have to, though this method   requires very thorough testing so we do not corrupt local auditing   information. These files and their access methods are very system   specific indeed.    For utmpx systems, the corresponding library functions are   setutxent() etc. To the author's knowledge, all utmpx systems have   these library functions and so no direct write is attempted. If such   a system exists and needs support, direct analogues of the [uw]tmp   code should suffice.    Retrieving the time of last login ('lastlog') is in some ways even   more problemmatic than login recording. Some systems provide a   simple table of all users which we seek based on uid and retrieve a   relatively standard structure. Others record the same information in   a directory with a separate file, and others don't record the   information separately at all. For systems in the latter category,   we look backwards in the wtmp or wtmpx file for the last login entry   for our user. Naturally this is slower and on busy systems could   incur a significant performance penalty.    Calling the new code   --------------------    In OpenSSH all login recording and retrieval is performed in   login.c. Here you'll find working examples. Also, in the logintest.c   program there are more examples.    Internal handler calling method   -------------------------------    When a call is made to login_login() or login_logout(), both   routines set a struct logininfo flag defining which action (log in,   or log out) is to be taken. They both then call login_write(), which   calls whichever of the many structure-specific handlers autoconf   selects for the local system.    The handlers themselves handle system data structure specifics. Both   struct utmp and struct utmpx have utility functions (see   construct_utmp*()) to try to make it simpler to add extra systems   that introduce new features to either structure.    While it may seem terribly wasteful to replicate so much similar   code for each method, experience has shown that maintaining code to   write both struct utmp and utmpx in one function, whilst maintaining   support for all systems whether they have library support or not, is   a difficult and time-consuming task.    Lastlog support proceeds similarly. Functions login_get_lastlog()   (and its OpenSSH-tuned friend login_get_lastlog_time()) call   getlast_entry(), which tries one of three methods to find the last   login time. It uses local system lastlog support if it can,   otherwise it tries wtmp or wtmpx before giving up and returning 0,   meaning "tilt".    Maintenance   -----------    In many cases it's possible to tweak autoconf to select the correct   methods for a particular platform, either by improving the detection   code (best), or by presetting DISABLE_<method> or CONF_<method>_FILE   symbols for the platform.    Use logintest to check which symbols are defined before modifying   configure.ac and loginrec.c. (You have to build logintest yourself   with 'make logintest' as it's not built by default.)    Otherwise, patches to the specific method(s) are very helpful!  */
end_comment

begin_comment
comment|/**  ** TODO:  **   homegrown ttyslot()  **   test, test, test  **  ** Platform status:  ** ----------------  **  ** Known good:  **   Linux (Redhat 6.2, Debian)  **   Solaris  **   HP-UX 10.20 (gcc only)  **   IRIX  **   NeXT - M68k/HPPA/Sparc (4.2/3.3)  **  ** Testing required: Please send reports!  **   NetBSD  **   HP-UX 11  **   AIX  **  ** Platforms with known problems:  **   Some variants of Slackware Linux  **  **/
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"loginrec.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: loginrec.c,v 1.52 2003/07/06 05:20:46 dtucker Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBUTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  ** prototypes for helper functions in this file  **/
end_comment

begin_if
if|#
directive|if
name|HAVE_UTMP_H
end_if

begin_function_decl
name|void
name|set_utmp_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|construct_utmp
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_function_decl
name|void
name|set_utmpx_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|construct_utmpx
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|utmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|utmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lastlog_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|syslogin_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|getlast_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lastlog_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmp_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmpx_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* pick the shortest string */
end_comment

begin_define
define|#
directive|define
name|MIN_SIZEOF
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|( sizeof(s1)< sizeof(s2) ? sizeof(s1) : sizeof(s2) )
end_define

begin_comment
comment|/**  ** platform-independent login functions  **/
end_comment

begin_comment
comment|/* login_login(struct logininfo *)     -Record a login  *  * Call with a pointer to a struct logininfo initialised with  * login_init_entry() or login_alloc_entry()  *  * Returns:  *>0 if successful  *  0  on failure (will use OpenSSH's logging facilities for diagnostics)  */
end_comment

begin_function
name|int
name|login_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|li
operator|->
name|type
operator|=
name|LTYPE_LOGIN
expr_stmt|;
return|return
name|login_write
argument_list|(
name|li
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* login_logout(struct logininfo *)     - Record a logout  *  * Call as with login_login()  *  * Returns:  *>0 if successful  *  0  on failure (will use OpenSSH's logging facilities for diagnostics)  */
end_comment

begin_function
name|int
name|login_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|li
operator|->
name|type
operator|=
name|LTYPE_LOGOUT
expr_stmt|;
return|return
name|login_write
argument_list|(
name|li
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* login_get_lastlog_time(int)           - Retrieve the last login time  *  * Retrieve the last login time for the given uid. Will try to use the  * system lastlog facilities if they are available, but will fall back  * to looking in wtmp/wtmpx if necessary  *  * Returns:  *   0 on failure, or if user has never logged in  *   Time in seconds from the epoch if successful  *  * Useful preprocessor symbols:  *   DISABLE_LASTLOG: If set, *never* even try to retrieve lastlog  *                    info  *   USE_LASTLOG: If set, indicates the presence of system lastlog  *                facilities. If this and DISABLE_LASTLOG are not set,  *                try to retrieve lastlog information from wtmp/wtmpx.  */
end_comment

begin_function
name|unsigned
name|int
name|login_get_lastlog_time
parameter_list|(
specifier|const
name|int
name|uid
parameter_list|)
block|{
name|struct
name|logininfo
name|li
decl_stmt|;
if|if
condition|(
name|login_get_lastlog
argument_list|(
operator|&
name|li
argument_list|,
name|uid
argument_list|)
condition|)
return|return
name|li
operator|.
name|tv_sec
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* login_get_lastlog(struct logininfo *, int)   - Retrieve a lastlog entry  *  * Retrieve a logininfo structure populated (only partially) with  * information from the system lastlog data, or from wtmp/wtmpx if no  * system lastlog information exists.  *  * Note this routine must be given a pre-allocated logininfo.  *  * Returns:  *>0: A pointer to your struct logininfo if successful  *  0  on failure (will use OpenSSH's logging facilities for diagnostics)  *  */
end_comment

begin_function
name|struct
name|logininfo
modifier|*
name|login_get_lastlog
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
specifier|const
name|int
name|uid
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|memset
argument_list|(
name|li
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
comment|/* 	 * If we don't have a 'real' lastlog, we need the username to 	 * reliably search wtmp(x) for the last login (see 	 * wtmp_get_entry().) 	 */
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"login_get_lastlog: Cannot find account for uid %i"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* No MIN_SIZEOF here - we absolutely *must not* truncate the 	 * username */
name|strlcpy
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getlast_entry
argument_list|(
name|li
argument_list|)
condition|)
return|return
name|li
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* login_alloc_entry(int, char*, char*, char*)    - Allocate and initialise  *                                                  a logininfo structure  *  * This function creates a new struct logininfo, a data structure  * meant to carry the information required to portably record login info.  *  * Returns a pointer to a newly created struct logininfo. If memory  * allocation fails, the program halts.  */
end_comment

begin_function
name|struct
name|logininfo
modifier|*
name|login_alloc_entry
parameter_list|(
name|int
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|logininfo
modifier|*
name|newli
decl_stmt|;
name|newli
operator|=
operator|(
expr|struct
name|logininfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newli
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|login_init_entry
argument_list|(
name|newli
argument_list|,
name|pid
argument_list|,
name|username
argument_list|,
name|hostname
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|newli
return|;
block|}
end_function

begin_comment
comment|/* login_free_entry(struct logininfo *)    - free struct memory */
end_comment

begin_function
name|void
name|login_free_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|xfree
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* login_init_entry(struct logininfo *, int, char*, char*, char*)  *                                        - initialise a struct logininfo  *  * Populates a new struct logininfo, a data structure meant to carry  * the information required to portably record login info.  *  * Returns: 1  */
end_comment

begin_function
name|int
name|login_init_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|int
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|memset
argument_list|(
name|li
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
comment|/* set the line information */
if|if
condition|(
name|line
condition|)
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|username
condition|)
block|{
name|strlcpy
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"login_init_entry: Cannot find user \"%s\""
argument_list|,
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
name|li
operator|->
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
if|if
condition|(
name|hostname
condition|)
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* login_set_current_time(struct logininfo *)    - set the current time  *  * Set the current time in a logininfo structure. This function is  * meant to eliminate the need to deal with system dependencies for  * time handling.  */
end_comment

begin_function
name|void
name|login_set_current_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|li
operator|->
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|li
operator|->
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy a sockaddr_* into our logininfo */
end_comment

begin_function
name|void
name|login_set_addr
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
specifier|const
name|unsigned
name|int
name|sa_size
parameter_list|)
block|{
name|unsigned
name|int
name|bufsize
init|=
name|sa_size
decl_stmt|;
comment|/* make sure we don't overrun our union */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|li
operator|->
name|hostaddr
argument_list|)
operator|<
name|sa_size
condition|)
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|li
operator|->
name|hostaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|)
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|sa
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** login_write: Call low-level recording functions based on autoconf  ** results  **/
end_comment

begin_function
name|int
name|login_write
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_CYGWIN
if|if
condition|(
operator|(
name|int
operator|)
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Attempt to write login records by non-root user (aborting)"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* set the timestamp */
name|login_set_current_time
argument_list|(
name|li
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOGIN
name|syslogin_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LASTLOG
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGIN
condition|)
block|{
name|lastlog_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_UTMP
name|utmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMP
name|wtmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_UTMPX
name|utmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMPX
name|wtmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOGIN_NEEDS_UTMPX
end_ifdef

begin_function
name|int
name|login_utmp_only
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|li
operator|->
name|type
operator|=
name|LTYPE_LOGIN
expr_stmt|;
name|login_set_current_time
argument_list|(
name|li
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_UTMP
name|utmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMP
name|wtmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_UTMPX
name|utmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMPX
name|wtmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  ** getlast_entry: Call low-level functions to retrieve the last login  **                time.  **/
end_comment

begin_comment
comment|/* take the uid in li and return the last login time */
end_comment

begin_function
name|int
name|getlast_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LASTLOG
return|return
operator|(
name|lastlog_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* !USE_LASTLOG */
ifdef|#
directive|ifdef
name|DISABLE_LASTLOG
comment|/* On some systems we shouldn't even try to obtain last login 	 * time, e.g. AIX */
return|return
literal|0
return|;
else|#
directive|else
comment|/* DISABLE_LASTLOG */
comment|/* Try to retrieve the last login time from wtmp */
if|#
directive|if
name|defined
argument_list|(
name|USE_WTMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TV_IN_UTMP
argument_list|)
operator|)
comment|/* retrieve last login time from utmp */
return|return
operator|(
name|wtmp_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* defined(USE_WTMP)&& (defined(HAVE_TIME_IN_UTMP) || defined(HAVE_TV_IN_UTMP)) */
comment|/* If wtmp isn't available, try wtmpx */
if|#
directive|if
name|defined
argument_list|(
name|USE_WTMPX
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMPX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TV_IN_UTMPX
argument_list|)
operator|)
comment|/* retrieve last login time from utmpx */
return|return
operator|(
name|wtmpx_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* Give up: No means of retrieving last login time */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* USE_WTMPX&& (HAVE_TIME_IN_UTMPX || HAVE_TV_IN_UTMPX) */
endif|#
directive|endif
comment|/* USE_WTMP&& (HAVE_TIME_IN_UTMP || HAVE_TV_IN_UTMP) */
endif|#
directive|endif
comment|/* DISABLE_LASTLOG */
endif|#
directive|endif
comment|/* USE_LASTLOG */
block|}
end_function

begin_comment
comment|/*  * 'line' string utility functions  *  * These functions process the 'line' string into one of three forms:  *  * 1. The full filename (including '/dev')  * 2. The stripped name (excluding '/dev')  * 3. The abbreviated name (e.g. /dev/ttyp00 -> yp00  *                               /dev/pts/1  -> ts/1 )  *  * Form 3 is used on some systems to identify a .tmp.? entry when  * attempting to remove it. Typically both addition and removal is  * performed by one application - say, sshd - so as long as the choice  * uniquely identifies a terminal it's ok.  */
end_comment

begin_comment
comment|/* line_fullname(): add the leading '/dev/' if it doesn't exist make  * sure dst has enough space, if not just copy src (ugh) */
end_comment

begin_function
name|char
modifier|*
name|line_fullname
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|dstsize
parameter_list|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|'\0'
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|dstsize
operator|<
operator|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|5
operator|)
operator|)
condition|)
block|{
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strlcpy
argument_list|(
name|dst
argument_list|,
literal|"/dev/"
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* line_stripname(): strip the leading '/dev' if it exists, return dst */
end_comment

begin_function
name|char
modifier|*
name|line_stripname
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|dstsize
parameter_list|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|'\0'
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|src
operator|+
literal|5
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* line_abbrevname(): Return the abbreviated (usually four-character)  * form of the line (Just use the last<dstsize> characters of the  * full name.)  *  * NOTE: use strncpy because we do NOT necessarily want zero  * termination */
end_comment

begin_function
name|char
modifier|*
name|line_abbrevname
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|dstsize
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|memset
argument_list|(
name|dst
argument_list|,
literal|'\0'
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
comment|/* Always skip prefix if present */
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|+=
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_ABBREV_NO_TTY
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|len
operator|-
name|dstsize
operator|)
operator|>
literal|0
condition|)
name|src
operator|+=
operator|(
operator|(
name|int
operator|)
name|len
operator|-
name|dstsize
operator|)
expr_stmt|;
comment|/* note: _don't_ change this to strlcpy */
name|strncpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
operator|(
name|size_t
operator|)
name|dstsize
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/**  ** utmp utility functions  **  ** These functions manipulate struct utmp, taking system differences  ** into account.  **/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_UTMP
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_WTMP
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_LOGIN
argument_list|)
end_if

begin_comment
comment|/* build the utmp structure */
end_comment

begin_function
name|void
name|set_utmp_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TV_IN_UTMP
name|ut
operator|->
name|ut_tv
operator|.
name|tv_sec
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
name|ut
operator|->
name|ut_tv
operator|.
name|tv_usec
operator|=
name|li
operator|->
name|tv_usec
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_TIME_IN_UTMP
name|ut
operator|->
name|ut_time
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|construct_utmp
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|ut
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First fill out fields used for both logins and logouts */
ifdef|#
directive|ifdef
name|HAVE_ID_IN_UTMP
name|line_abbrevname
argument_list|(
name|ut
operator|->
name|ut_id
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMP
comment|/* This is done here to keep utmp constants out of struct logininfo */
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
name|ut
operator|->
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
ifdef|#
directive|ifdef
name|_UNICOS
name|cray_set_tmpdir
argument_list|(
name|ut
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LTYPE_LOGOUT
case|:
name|ut
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
ifdef|#
directive|ifdef
name|_UNICOS
name|cray_retain_utmp
argument_list|(
name|ut
argument_list|,
name|li
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
endif|#
directive|endif
name|set_utmp_time
argument_list|(
name|li
argument_list|,
name|ut
argument_list|)
expr_stmt|;
name|line_stripname
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PID_IN_UTMP
name|ut
operator|->
name|ut_pid
operator|=
name|li
operator|->
name|pid
expr_stmt|;
endif|#
directive|endif
comment|/* If we're logging out, leave all other fields blank */
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGOUT
condition|)
return|return;
comment|/* 	 * These fields are only used when logging in, and are blank 	 * for logouts. 	 */
comment|/* Use strncpy because we don't necessarily want null termination */
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|,
name|li
operator|->
name|username
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|,
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMP
name|realhostname_sa
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
sizeof|sizeof
name|ut
operator|->
name|ut_host
argument_list|,
operator|&
name|li
operator|->
name|hostaddr
operator|.
name|sa
argument_list|,
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_IN_UTMP
comment|/* this is just a 32-bit IP address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
name|ut
operator|->
name|ut_addr
operator|=
name|li
operator|->
name|hostaddr
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
comment|/* this is just a 128-bit IPv6 address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ut
operator|->
name|ut_addr_v6
argument_list|,
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|ut
operator|->
name|ut_addr_v6
index|[
literal|0
index|]
operator|=
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMP || USE_WTMP || USE_LOGIN */
end_comment

begin_comment
comment|/**  ** utmpx utility functions  **  ** These functions manipulate struct utmpx, accounting for system  ** variations.  **/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_UTMPX
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_WTMPX
argument_list|)
end_if

begin_comment
comment|/* build the utmpx structure */
end_comment

begin_function
name|void
name|set_utmpx_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TV_IN_UTMPX
name|utx
operator|->
name|ut_tv
operator|.
name|tv_sec
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
name|utx
operator|->
name|ut_tv
operator|.
name|tv_usec
operator|=
name|li
operator|->
name|tv_usec
expr_stmt|;
else|#
directive|else
comment|/* HAVE_TV_IN_UTMPX */
ifdef|#
directive|ifdef
name|HAVE_TIME_IN_UTMPX
name|utx
operator|->
name|ut_time
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIME_IN_UTMPX */
endif|#
directive|endif
comment|/* HAVE_TV_IN_UTMPX */
block|}
end_function

begin_function
name|void
name|construct_utmpx
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|utx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|utx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ID_IN_UTMPX
name|line_abbrevname
argument_list|(
name|utx
operator|->
name|ut_id
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|->
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* this is done here to keep utmp constants out of loginrec.h */
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
name|utx
operator|->
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
break|break;
case|case
name|LTYPE_LOGOUT
case|:
name|utx
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
break|break;
block|}
name|line_stripname
argument_list|(
name|utx
operator|->
name|ut_line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|->
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|set_utmpx_time
argument_list|(
name|li
argument_list|,
name|utx
argument_list|)
expr_stmt|;
name|utx
operator|->
name|ut_pid
operator|=
name|li
operator|->
name|pid
expr_stmt|;
comment|/* strncpy(): Don't necessarily want null termination */
name|strncpy
argument_list|(
name|utx
operator|->
name|ut_name
argument_list|,
name|li
operator|->
name|username
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|utx
operator|->
name|ut_name
argument_list|,
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGOUT
condition|)
return|return;
comment|/* 	 * These fields are only used when logging in, and are blank 	 * for logouts. 	 */
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMPX
name|strncpy
argument_list|(
name|utx
operator|->
name|ut_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|utx
operator|->
name|ut_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_IN_UTMPX
comment|/* this is just a 32-bit IP address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
name|utx
operator|->
name|ut_addr
operator|=
name|li
operator|->
name|hostaddr
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
comment|/* this is just a 128-bit IPv6 address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ut
operator|->
name|ut_addr_v6
argument_list|,
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|ut
operator|->
name|ut_addr_v6
index|[
literal|0
index|]
operator|=
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSLEN_IN_UTMPX
comment|/* ut_syslen is the length of the utx_host string */
name|utx
operator|->
name|ut_syslen
operator|=
name|MIN
argument_list|(
name|strlen
argument_list|(
name|li
operator|->
name|hostname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|->
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMPX || USE_WTMPX */
end_comment

begin_comment
comment|/**  ** Low-level utmp functions  **/
end_comment

begin_comment
comment|/* FIXME: (ATL) utmp_write_direct needs testing */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_UTMP
end_ifdef

begin_comment
comment|/* if we can, use pututline() etc. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_PUTUTLINE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETUTENT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_PUTUTLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|UTMP_USE_LIBRARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* write a utmp entry with the system's help (pututline() and pals) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTMP_USE_LIBRARY
end_ifdef

begin_function
specifier|static
name|int
name|utmp_write_library
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|setutent
argument_list|()
expr_stmt|;
name|pututline
argument_list|(
name|ut
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ENDUTENT
name|endutent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UTMP_USE_LIBRARY */
end_comment

begin_comment
comment|/* write a utmp entry direct to the file */
end_comment

begin_comment
comment|/* This is a slightly modification of code in OpenBSD's login.c */
end_comment

begin_function
specifier|static
name|int
name|utmp_write_direct
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|struct
name|utmp
name|old_ut
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|tty
decl_stmt|;
comment|/* FIXME: (ATL) ttyslot() needs local implementation */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETTTYENT
argument_list|)
specifier|register
name|struct
name|ttyent
modifier|*
name|ty
decl_stmt|;
name|tty
operator|=
literal|0
expr_stmt|;
name|setttyent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
expr|struct
name|ttyent
operator|*
operator|)
literal|0
operator|!=
operator|(
name|ty
operator|=
name|getttyent
argument_list|()
operator|)
condition|)
block|{
name|tty
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ty
operator|->
name|ty_name
argument_list|,
name|ut
operator|->
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|endttyent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
expr|struct
name|ttyent
operator|*
operator|)
literal|0
operator|==
name|ty
condition|)
block|{
name|logit
argument_list|(
literal|"utmp_write_entry: tty not found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|#
directive|else
comment|/* FIXME */
name|tty
operator|=
name|ttyslot
argument_list|()
expr_stmt|;
comment|/* seems only to work for /dev/ttyp? style names */
endif|#
directive|endif
comment|/* HAVE_GETTTYENT */
if|if
condition|(
name|tty
operator|>
literal|0
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|UTMP_FILE
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|tty
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* 		 * Prevent luser from zero'ing out ut_host. 		 * If the new ut_line is empty but the old one is not 		 * and ut_line and ut_name match, preserve the old ut_line. 		 */
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|old_ut
argument_list|,
sizeof|sizeof
argument_list|(
name|old_ut
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|old_ut
argument_list|)
operator|&&
operator|(
name|ut
operator|->
name|ut_host
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|old_ut
operator|.
name|ut_host
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|old_ut
operator|.
name|ut_line
argument_list|,
name|ut
operator|->
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|old_ut
operator|.
name|ut_name
argument_list|,
name|ut
operator|->
name|ut_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
name|old_ut
operator|.
name|ut_host
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|tty
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
condition|)
name|logit
argument_list|(
literal|"utmp_write_direct: error writing %s: %s"
argument_list|,
name|UTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTMP_USE_LIBRARY */
end_comment

begin_function
specifier|static
name|int
name|utmp_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMP_USE_LIBRARY
if|if
condition|(
operator|!
name|utmp_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"utmp_perform_login: utmp_write_library() failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|utmp_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"utmp_perform_login: utmp_write_direct() failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utmp_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMP_USE_LIBRARY
if|if
condition|(
operator|!
name|utmp_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"utmp_perform_logout: utmp_write_library() failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|utmp_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"utmp_perform_logout: utmp_write_direct() failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|utmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
name|utmp_perform_login
argument_list|(
name|li
argument_list|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
name|utmp_perform_logout
argument_list|(
name|li
argument_list|)
return|;
default|default:
name|logit
argument_list|(
literal|"utmp_write_entry: invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMP */
end_comment

begin_comment
comment|/**  ** Low-level utmpx functions  **/
end_comment

begin_comment
comment|/* not much point if we don't want utmpx entries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_UTMPX
end_ifdef

begin_comment
comment|/* if we have the wherewithall, use pututxline etc. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_PUTUTXLINE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETUTXENT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_PUTUTXLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|UTMPX_USE_LIBRARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* write a utmpx entry with the system's help (pututxline() and pals) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTMPX_USE_LIBRARY
end_ifdef

begin_function
specifier|static
name|int
name|utmpx_write_library
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
name|setutxent
argument_list|()
expr_stmt|;
name|pututxline
argument_list|(
name|utx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ENDUTXENT
name|endutxent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UTMPX_USE_LIBRARY */
end_comment

begin_comment
comment|/* write a utmp entry direct to the file */
end_comment

begin_function
specifier|static
name|int
name|utmpx_write_direct
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
name|logit
argument_list|(
literal|"utmpx_write_direct: not implemented!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTMPX_USE_LIBRARY */
end_comment

begin_function
specifier|static
name|int
name|utmpx_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPX_USE_LIBRARY
if|if
condition|(
operator|!
name|utmpx_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"utmpx_perform_login: utmp_write_library() failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|utmpx_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"utmpx_perform_login: utmp_write_direct() failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utmpx_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ID_IN_UTMPX
name|line_abbrevname
argument_list|(
name|utx
operator|.
name|ut_id
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|.
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMPX
name|utx
operator|.
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UTMPX_USE_LIBRARY
name|utmpx_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
name|utmpx_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|utmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
name|utmpx_perform_login
argument_list|(
name|li
argument_list|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
name|utmpx_perform_logout
argument_list|(
name|li
argument_list|)
return|;
default|default:
name|logit
argument_list|(
literal|"utmpx_write_entry: invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMPX */
end_comment

begin_comment
comment|/**  ** Low-level wtmp functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WTMP
end_ifdef

begin_comment
comment|/* write a wtmp entry direct to the end of the file */
end_comment

begin_comment
comment|/* This is a slight modification of code in OpenBSD's logwtmp.c */
end_comment

begin_function
specifier|static
name|int
name|wtmp_write
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMP_FILE
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wtmp_write: problem writing %s: %s"
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
condition|)
block|{
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"wtmp_write: problem writing %s: %s"
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmp_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
return|return
name|wtmp_write
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmp_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
return|return
name|wtmp_write
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|wtmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
name|wtmp_perform_login
argument_list|(
name|li
argument_list|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
name|wtmp_perform_logout
argument_list|(
name|li
argument_list|)
return|;
default|default:
name|logit
argument_list|(
literal|"wtmp_write_entry: invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Notes on fetching login data from wtmp/wtmpx  *  * Logouts are usually recorded with (amongst other things) a blank  * username on a given tty line.  However, some systems (HP-UX is one)  * leave all fields set, but change the ut_type field to DEAD_PROCESS.  *  * Since we're only looking for logins here, we know that the username  * must be set correctly. On systems that leave it in, we check for  * ut_type==USER_PROCESS (indicating a login.)  *  * Portability: Some systems may set something other than USER_PROCESS  * to indicate a login process. I don't know of any as I write. Also,  * it's possible that some systems may both leave the username in  * place and not have ut_type.  */
end_comment

begin_comment
comment|/* return true if this wtmp entry indicates a login */
end_comment

begin_function
specifier|static
name|int
name|wtmp_islogin
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|ut
operator|->
name|ut_name
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|ut
operator|->
name|ut_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMP
if|if
condition|(
name|ut
operator|->
name|ut_type
operator|&
name|USER_PROCESS
condition|)
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|wtmp_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|utmp
name|ut
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
comment|/* Clear the time entries in our logininfo */
name|li
operator|->
name|tv_sec
operator|=
name|li
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMP_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wtmp_get_entry: problem opening %s: %s"
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wtmp_get_entry: couldn't stat %s: %s"
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Seek to the start of the last struct utmp */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Looks like we've got a fresh wtmp file */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"wtmp_get_entry: read of %s failed: %s"
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|wtmp_islogin
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
comment|/* We've already checked for a time in struct 			 * utmp, in login_getlast(). */
ifdef|#
directive|ifdef
name|HAVE_TIME_IN_UTMP
name|li
operator|->
name|tv_sec
operator|=
name|ut
operator|.
name|ut_time
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_TV_IN_UTMP
name|li
operator|->
name|tv_sec
operator|=
name|ut
operator|.
name|ut_tv
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|ut
operator|.
name|ut_line
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMP
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|ut
operator|.
name|ut_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|ut
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* Seek back 2 x struct utmp */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
call|(
name|off_t
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* We've found the start of the file, so quit */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* We found an entry. Tidy up and return */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WTMP */
end_comment

begin_comment
comment|/**  ** Low-level wtmpx functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WTMPX
end_ifdef

begin_comment
comment|/* write a wtmpx entry direct to the end of the file */
end_comment

begin_comment
comment|/* This is a slight modification of code in OpenBSD's logwtmp.c */
end_comment

begin_function
specifier|static
name|int
name|wtmpx_write
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMPX_FILE
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wtmpx_write: problem opening %s: %s"
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|utx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|utx
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|utx
argument_list|)
condition|)
block|{
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"wtmpx_write: problem writing %s: %s"
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmpx_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
return|return
name|wtmpx_write
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmpx_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
return|return
name|wtmpx_write
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|wtmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
name|wtmpx_perform_login
argument_list|(
name|li
argument_list|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
name|wtmpx_perform_logout
argument_list|(
name|li
argument_list|)
return|;
default|default:
name|logit
argument_list|(
literal|"wtmpx_write_entry: invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Please see the notes above wtmp_islogin() for information about the    next two functions */
end_comment

begin_comment
comment|/* Return true if this wtmpx entry indicates a login */
end_comment

begin_function
specifier|static
name|int
name|wtmpx_islogin
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|utx
operator|->
name|ut_name
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|utx
operator|->
name|ut_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMPX
if|if
condition|(
name|utx
operator|->
name|ut_type
operator|==
name|USER_PROCESS
condition|)
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|wtmpx_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|utmpx
name|utx
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
comment|/* Clear the time entries */
name|li
operator|->
name|tv_sec
operator|=
name|li
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMPX_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wtmpx_get_entry: problem opening %s: %s"
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"wtmpx_get_entry: couldn't stat %s: %s"
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Seek to the start of the last struct utmpx */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|utmpx
argument_list|)
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* probably a newly rotated wtmpx file */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|utx
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|utx
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"wtmpx_get_entry: read of %s failed: %s"
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Logouts are recorded as a blank username on a particular line. 		 * So, we just need to find the username in struct utmpx */
if|if
condition|(
name|wtmpx_islogin
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TV_IN_UTMPX
name|li
operator|->
name|tv_sec
operator|=
name|utx
operator|.
name|ut_tv
operator|.
name|tv_sec
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_TIME_IN_UTMPX
name|li
operator|->
name|tv_sec
operator|=
name|utx
operator|.
name|ut_time
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|utx
operator|.
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMPX
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|utx
operator|.
name|ut_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|utx
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
call|(
name|off_t
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmpx
argument_list|)
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WTMPX */
end_comment

begin_comment
comment|/**  ** Low-level libutil login() functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOGIN
end_ifdef

begin_function
specifier|static
name|int
name|syslogin_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
modifier|*
name|ut
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ut
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|logit
argument_list|(
literal|"syslogin_perform_login: couldn't malloc()"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|construct_utmp
argument_list|(
name|li
argument_list|,
name|ut
argument_list|)
expr_stmt|;
name|login
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ut
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|syslogin_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LOGOUT
name|char
name|line
index|[
literal|8
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|line_stripname
argument_list|(
name|line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|logout
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"syslogin_perform_logout: logout() returned an error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LOGWTMP
block|}
else|else
block|{
name|logwtmp
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* FIXME: (ATL - if the need arises) What to do if we have 	 * login, but no logout?  what if logout but no logwtmp? All 	 * routines are in libutil so they should all be there, 	 * but... */
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|syslogin_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
name|syslogin_perform_login
argument_list|(
name|li
argument_list|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
name|syslogin_perform_logout
argument_list|(
name|li
argument_list|)
return|;
default|default:
name|logit
argument_list|(
literal|"syslogin_write_entry: Invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LOGIN */
end_comment

begin_comment
comment|/* end of file log-syslogin.c */
end_comment

begin_comment
comment|/**  ** Low-level lastlog functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LASTLOG
end_ifdef

begin_define
define|#
directive|define
name|LL_FILE
value|1
end_define

begin_define
define|#
directive|define
name|LL_DIR
value|2
end_define

begin_define
define|#
directive|define
name|LL_OTHER
value|3
end_define

begin_function
specifier|static
name|void
name|lastlog_construct
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|lastlog
modifier|*
name|last
parameter_list|)
block|{
comment|/* clear the structure */
name|memset
argument_list|(
name|last
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|last
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|line_stripname
argument_list|(
name|last
operator|->
name|ll_line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|last
operator|->
name|ll_line
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|last
operator|->
name|ll_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|last
operator|->
name|ll_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|->
name|ll_time
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lastlog_filetype
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|LASTLOG_FILE
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"lastlog_perform_login: Couldn't stat %s: %s"
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|LL_DIR
return|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|LL_FILE
return|;
else|else
return|return
name|LL_OTHER
return|;
block|}
end_function

begin_comment
comment|/* open the file (using filemode) and seek to the login entry */
end_comment

begin_function
specifier|static
name|int
name|lastlog_openseek
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|,
name|int
name|filemode
parameter_list|)
block|{
name|off_t
name|offset
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
name|lastlog_file
index|[
literal|1024
index|]
decl_stmt|;
name|type
operator|=
name|lastlog_filetype
argument_list|(
name|LASTLOG_FILE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LL_FILE
case|:
name|strlcpy
argument_list|(
name|lastlog_file
argument_list|,
name|LASTLOG_FILE
argument_list|,
sizeof|sizeof
argument_list|(
name|lastlog_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LL_DIR
case|:
name|snprintf
argument_list|(
name|lastlog_file
argument_list|,
sizeof|sizeof
argument_list|(
name|lastlog_file
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
break|break;
default|default:
name|logit
argument_list|(
literal|"lastlog_openseek: %.100s is not a file or directory!"
argument_list|,
name|LASTLOG_FILE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|fd
operator|=
name|open
argument_list|(
name|lastlog_file
argument_list|,
name|filemode
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fd
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"lastlog_openseek: Couldn't open %s: %s"
argument_list|,
name|lastlog_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type
operator|==
name|LL_FILE
condition|)
block|{
comment|/* find this uid's offset in the lastlog file */
name|offset
operator|=
call|(
name|off_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|li
operator|->
name|uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lastlog
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
operator|*
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|offset
condition|)
block|{
name|logit
argument_list|(
literal|"lastlog_openseek: %s->lseek(): %s"
argument_list|,
name|lastlog_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lastlog_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|lastlog
name|last
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* create our struct lastlog */
name|lastlog_construct
argument_list|(
name|li
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lastlog_openseek
argument_list|(
name|li
argument_list|,
operator|&
name|fd
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* write the entry */
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
operator|&
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"lastlog_write_filemode: Error writing to %s: %s"
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|lastlog_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
name|lastlog_perform_login
argument_list|(
name|li
argument_list|)
return|;
default|default:
name|logit
argument_list|(
literal|"lastlog_write_entry: Invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lastlog_populate_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|lastlog
modifier|*
name|last
parameter_list|)
block|{
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|last
operator|->
name|ll_line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|last
operator|->
name|ll_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|last
operator|->
name|ll_host
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|tv_sec
operator|=
name|last
operator|->
name|ll_time
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lastlog_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|lastlog
name|last
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|lastlog_openseek
argument_list|(
name|li
argument_list|,
operator|&
name|fd
argument_list|,
name|O_RDONLY
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
name|memset
argument_list|(
operator|&
name|last
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
sizeof|sizeof
argument_list|(
name|last
argument_list|)
case|:
name|lastlog_populate_entry
argument_list|(
name|li
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"%s: Error reading from %s: %s"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"%s: Error reading from %s: Expecting %d, got %d"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LASTLOG */
end_comment

end_unit

