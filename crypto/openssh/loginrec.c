begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Andre Lucas.  All rights reserved.  * Portions copyright (c) 1998 Todd C. Miller  * Portions copyright (c) 1996 Jason Downs  * Portions copyright (c) 1996 Theo de Raadt  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * The btmp logging code is derived from login.c from util-linux and is under  * the the following license:  *  * Copyright (c) 1980, 1987, 1988 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/**  ** loginrec.c:  platform-independent login recording and lastlog retrieval  **/
end_comment

begin_comment
comment|/*  *  The new login code explained  *  ============================  *  *  This code attempts to provide a common interface to login recording  *  (utmp and friends) and last login time retrieval.  *  *  Its primary means of achieving this is to use 'struct logininfo', a  *  union of all the useful fields in the various different types of  *  system login record structures one finds on UNIX variants.  *  *  We depend on autoconf to define which recording methods are to be  *  used, and which fields are contained in the relevant data structures  *  on the local system. Many C preprocessor symbols affect which code  *  gets compiled here.  *  *  The code is designed to make it easy to modify a particular  *  recording method, without affecting other methods nor requiring so  *  many nested conditional compilation blocks as were commonplace in  *  the old code.  *  *  For login recording, we try to use the local system's libraries as  *  these are clearly most likely to work correctly. For utmp systems  *  this usually means login() and logout() or setutent() etc., probably  *  in libutil, along with logwtmp() etc. On these systems, we fall back  *  to writing the files directly if we have to, though this method  *  requires very thorough testing so we do not corrupt local auditing  *  information. These files and their access methods are very system  *  specific indeed.  *  *  For utmpx systems, the corresponding library functions are  *  setutxent() etc. To the author's knowledge, all utmpx systems have  *  these library functions and so no direct write is attempted. If such  *  a system exists and needs support, direct analogues of the [uw]tmp  *  code should suffice.  *  *  Retrieving the time of last login ('lastlog') is in some ways even  *  more problemmatic than login recording. Some systems provide a  *  simple table of all users which we seek based on uid and retrieve a  *  relatively standard structure. Others record the same information in  *  a directory with a separate file, and others don't record the  *  information separately at all. For systems in the latter category,  *  we look backwards in the wtmp or wtmpx file for the last login entry  *  for our user. Naturally this is slower and on busy systems could  *  incur a significant performance penalty.  *  *  Calling the new code  *  --------------------  *  *  In OpenSSH all login recording and retrieval is performed in  *  login.c. Here you'll find working examples. Also, in the logintest.c  *  program there are more examples.  *  *  Internal handler calling method  *  -------------------------------  *  *  When a call is made to login_login() or login_logout(), both  *  routines set a struct logininfo flag defining which action (log in,  *  or log out) is to be taken. They both then call login_write(), which  *  calls whichever of the many structure-specific handlers autoconf  *  selects for the local system.  *  *  The handlers themselves handle system data structure specifics. Both  *  struct utmp and struct utmpx have utility functions (see  *  construct_utmp*()) to try to make it simpler to add extra systems  *  that introduce new features to either structure.  *  *  While it may seem terribly wasteful to replicate so much similar  *  code for each method, experience has shown that maintaining code to  *  write both struct utmp and utmpx in one function, whilst maintaining  *  support for all systems whether they have library support or not, is  *  a difficult and time-consuming task.  *  *  Lastlog support proceeds similarly. Functions login_get_lastlog()  *  (and its OpenSSH-tuned friend login_get_lastlog_time()) call  *  getlast_entry(), which tries one of three methods to find the last  *  login time. It uses local system lastlog support if it can,  *  otherwise it tries wtmp or wtmpx before giving up and returning 0,  *  meaning "tilt".  *  *  Maintenance  *  -----------  *  *  In many cases it's possible to tweak autoconf to select the correct  *  methods for a particular platform, either by improving the detection  *  code (best), or by presetting DISABLE_<method> or CONF_<method>_FILE  *  symbols for the platform.  *  *  Use logintest to check which symbols are defined before modifying  *  configure.ac and loginrec.c. (You have to build logintest yourself  *  with 'make logintest' as it's not built by default.)  *  *  Otherwise, patches to the specific method(s) are very helpful!  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PATHS_H
end_ifdef

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"loginrec.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBUTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  ** prototypes for helper functions in this file  **/
end_comment

begin_if
if|#
directive|if
name|HAVE_UTMP_H
end_if

begin_function_decl
name|void
name|set_utmp_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|construct_utmp
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_function_decl
name|void
name|set_utmpx_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|construct_utmpx
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|ut
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|utmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|utmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lastlog_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|syslogin_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|getlast_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lastlog_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|utmpx_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmp_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wtmpx_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Buffer
name|loginmsg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pick the shortest string */
end_comment

begin_define
define|#
directive|define
name|MIN_SIZEOF
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(sizeof(s1)< sizeof(s2) ? sizeof(s1) : sizeof(s2))
end_define

begin_comment
comment|/**  ** platform-independent login functions  **/
end_comment

begin_comment
comment|/*  * login_login(struct logininfo *) - Record a login  *  * Call with a pointer to a struct logininfo initialised with  * login_init_entry() or login_alloc_entry()  *  * Returns:  *>0 if successful  *  0  on failure (will use OpenSSH's logging facilities for diagnostics)  */
end_comment

begin_function
name|int
name|login_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|li
operator|->
name|type
operator|=
name|LTYPE_LOGIN
expr_stmt|;
return|return
operator|(
name|login_write
argument_list|(
name|li
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * login_logout(struct logininfo *) - Record a logout  *  * Call as with login_login()  *  * Returns:  *>0 if successful  *  0  on failure (will use OpenSSH's logging facilities for diagnostics)  */
end_comment

begin_function
name|int
name|login_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|li
operator|->
name|type
operator|=
name|LTYPE_LOGOUT
expr_stmt|;
return|return
operator|(
name|login_write
argument_list|(
name|li
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * login_get_lastlog_time(int) - Retrieve the last login time  *  * Retrieve the last login time for the given uid. Will try to use the  * system lastlog facilities if they are available, but will fall back  * to looking in wtmp/wtmpx if necessary  *  * Returns:  *   0 on failure, or if user has never logged in  *   Time in seconds from the epoch if successful  *  * Useful preprocessor symbols:  *   DISABLE_LASTLOG: If set, *never* even try to retrieve lastlog  *                    info  *   USE_LASTLOG: If set, indicates the presence of system lastlog  *                facilities. If this and DISABLE_LASTLOG are not set,  *                try to retrieve lastlog information from wtmp/wtmpx.  */
end_comment

begin_function
name|unsigned
name|int
name|login_get_lastlog_time
parameter_list|(
specifier|const
name|int
name|uid
parameter_list|)
block|{
name|struct
name|logininfo
name|li
decl_stmt|;
if|if
condition|(
name|login_get_lastlog
argument_list|(
operator|&
name|li
argument_list|,
name|uid
argument_list|)
condition|)
return|return
operator|(
name|li
operator|.
name|tv_sec
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * login_get_lastlog(struct logininfo *, int)   - Retrieve a lastlog entry  *  * Retrieve a logininfo structure populated (only partially) with  * information from the system lastlog data, or from wtmp/wtmpx if no  * system lastlog information exists.  *  * Note this routine must be given a pre-allocated logininfo.  *  * Returns:  *>0: A pointer to your struct logininfo if successful  *  0  on failure (will use OpenSSH's logging facilities for diagnostics)  */
end_comment

begin_function
name|struct
name|logininfo
modifier|*
name|login_get_lastlog
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
specifier|const
name|int
name|uid
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|memset
argument_list|(
name|li
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
comment|/* 	 * If we don't have a 'real' lastlog, we need the username to 	 * reliably search wtmp(x) for the last login (see 	 * wtmp_get_entry().) 	 */
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: Cannot find account for uid %i"
argument_list|,
name|__func__
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* No MIN_SIZEOF here - we absolutely *must not* truncate the 	 * username (XXX - so check for trunc!) */
name|strlcpy
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getlast_entry
argument_list|(
name|li
argument_list|)
condition|)
return|return
operator|(
name|li
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * login_alloc_entry(int, char*, char*, char*)    - Allocate and initialise  *                                                  a logininfo structure  *  * This function creates a new struct logininfo, a data structure  * meant to carry the information required to portably record login info.  *  * Returns a pointer to a newly created struct logininfo. If memory  * allocation fails, the program halts.  */
end_comment

begin_function
name|struct
name|logininfo
modifier|*
name|login_alloc_entry
parameter_list|(
name|int
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|logininfo
modifier|*
name|newli
decl_stmt|;
name|newli
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newli
argument_list|)
argument_list|)
expr_stmt|;
name|login_init_entry
argument_list|(
name|newli
argument_list|,
name|pid
argument_list|,
name|username
argument_list|,
name|hostname
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|newli
operator|)
return|;
block|}
end_function

begin_comment
comment|/* login_free_entry(struct logininfo *)    - free struct memory */
end_comment

begin_function
name|void
name|login_free_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|xfree
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* login_init_entry(struct logininfo *, int, char*, char*, char*)  *                                        - initialise a struct logininfo  *  * Populates a new struct logininfo, a data structure meant to carry  * the information required to portably record login info.  *  * Returns: 1  */
end_comment

begin_function
name|int
name|login_init_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|int
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|memset
argument_list|(
name|li
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
comment|/* set the line information */
if|if
condition|(
name|line
condition|)
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|username
condition|)
block|{
name|strlcpy
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"%s: Cannot find user \"%s\""
argument_list|,
name|__func__
argument_list|,
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
block|}
name|li
operator|->
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
if|if
condition|(
name|hostname
condition|)
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * login_set_current_time(struct logininfo *)    - set the current time  *  * Set the current time in a logininfo structure. This function is  * meant to eliminate the need to deal with system dependencies for  * time handling.  */
end_comment

begin_function
name|void
name|login_set_current_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|li
operator|->
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|li
operator|->
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy a sockaddr_* into our logininfo */
end_comment

begin_function
name|void
name|login_set_addr
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
specifier|const
name|unsigned
name|int
name|sa_size
parameter_list|)
block|{
name|unsigned
name|int
name|bufsize
init|=
name|sa_size
decl_stmt|;
comment|/* make sure we don't overrun our union */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|li
operator|->
name|hostaddr
argument_list|)
operator|<
name|sa_size
condition|)
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|li
operator|->
name|hostaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|li
operator|->
name|hostaddr
operator|.
name|sa
argument_list|,
name|sa
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** login_write: Call low-level recording functions based on autoconf  ** results  **/
end_comment

begin_function
name|int
name|login_write
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_CYGWIN
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Attempt to write login records by non-root user (aborting)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* set the timestamp */
name|login_set_current_time
argument_list|(
name|li
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOGIN
name|syslogin_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LASTLOG
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGIN
condition|)
name|lastlog_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_UTMP
name|utmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMP
name|wtmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_UTMPX
name|utmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMPX
name|wtmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CUSTOM_SYS_AUTH_RECORD_LOGIN
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGIN
operator|&&
operator|!
name|sys_auth_record_login
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|li
operator|->
name|hostname
argument_list|,
name|li
operator|->
name|line
argument_list|,
operator|&
name|loginmsg
argument_list|)
condition|)
name|logit
argument_list|(
literal|"Writing login record failed for %s"
argument_list|,
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGIN
condition|)
name|audit_session_open
argument_list|(
name|li
operator|->
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGOUT
condition|)
name|audit_session_close
argument_list|(
name|li
operator|->
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOGIN_NEEDS_UTMPX
end_ifdef

begin_function
name|int
name|login_utmp_only
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|li
operator|->
name|type
operator|=
name|LTYPE_LOGIN
expr_stmt|;
name|login_set_current_time
argument_list|(
name|li
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_UTMP
name|utmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMP
name|wtmp_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_UTMPX
name|utmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_WTMPX
name|wtmpx_write_entry
argument_list|(
name|li
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  ** getlast_entry: Call low-level functions to retrieve the last login  **                time.  **/
end_comment

begin_comment
comment|/* take the uid in li and return the last login time */
end_comment

begin_function
name|int
name|getlast_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LASTLOG
return|return
operator|(
name|lastlog_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* !USE_LASTLOG */
if|#
directive|if
literal|1
return|return
operator|(
name|utmpx_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DISABLE_LASTLOG
argument_list|)
comment|/* On some systems we shouldn't even try to obtain last login 	 * time, e.g. AIX */
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_WTMP
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMP
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TV_IN_UTMP
argument_list|)
operator|)
comment|/* retrieve last login time from utmp */
return|return
operator|(
name|wtmp_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_WTMPX
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMPX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TV_IN_UTMPX
argument_list|)
operator|)
comment|/* If wtmp isn't available, try wtmpx */
return|return
operator|(
name|wtmpx_get_entry
argument_list|(
name|li
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* Give up: No means of retrieving last login time */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* DISABLE_LASTLOG */
endif|#
directive|endif
comment|/* USE_LASTLOG */
block|}
end_function

begin_comment
comment|/*  * 'line' string utility functions  *  * These functions process the 'line' string into one of three forms:  *  * 1. The full filename (including '/dev')  * 2. The stripped name (excluding '/dev')  * 3. The abbreviated name (e.g. /dev/ttyp00 -> yp00  *                               /dev/pts/1  -> ts/1 )  *  * Form 3 is used on some systems to identify a .tmp.? entry when  * attempting to remove it. Typically both addition and removal is  * performed by one application - say, sshd - so as long as the choice  * uniquely identifies a terminal it's ok.  */
end_comment

begin_comment
comment|/*  * line_fullname(): add the leading '/dev/' if it doesn't exist make  * sure dst has enough space, if not just copy src (ugh)  */
end_comment

begin_function
name|char
modifier|*
name|line_fullname
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|u_int
name|dstsize
parameter_list|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|'\0'
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|dstsize
operator|<
operator|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|5
operator|)
operator|)
condition|)
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
else|else
block|{
name|strlcpy
argument_list|(
name|dst
argument_list|,
literal|"/dev/"
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/* line_stripname(): strip the leading '/dev' if it exists, return dst */
end_comment

begin_function
name|char
modifier|*
name|line_stripname
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|dstsize
parameter_list|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|'\0'
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|src
operator|+
literal|5
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * line_abbrevname(): Return the abbreviated (usually four-character)  * form of the line (Just use the last<dstsize> characters of the  * full name.)  *  * NOTE: use strncpy because we do NOT necessarily want zero  * termination  */
end_comment

begin_function
name|char
modifier|*
name|line_abbrevname
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|dstsize
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|memset
argument_list|(
name|dst
argument_list|,
literal|'\0'
argument_list|,
name|dstsize
argument_list|)
expr_stmt|;
comment|/* Always skip prefix if present */
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|+=
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_ABBREV_NO_TTY
if|if
condition|(
name|strncmp
argument_list|(
name|src
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|len
operator|-
name|dstsize
operator|)
operator|>
literal|0
condition|)
name|src
operator|+=
operator|(
operator|(
name|int
operator|)
name|len
operator|-
name|dstsize
operator|)
expr_stmt|;
comment|/* note: _don't_ change this to strlcpy */
name|strncpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
operator|(
name|size_t
operator|)
name|dstsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  ** utmp utility functions  **  ** These functions manipulate struct utmp, taking system differences  ** into account.  **/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_UTMP
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_WTMP
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_LOGIN
argument_list|)
end_if

begin_comment
comment|/* build the utmp structure */
end_comment

begin_function
name|void
name|set_utmp_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TV_IN_UTMP
argument_list|)
name|ut
operator|->
name|ut_tv
operator|.
name|tv_sec
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
name|ut
operator|->
name|ut_tv
operator|.
name|tv_usec
operator|=
name|li
operator|->
name|tv_usec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMP
argument_list|)
name|ut
operator|->
name|ut_time
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|construct_utmp
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|ut
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First fill out fields used for both logins and logouts */
ifdef|#
directive|ifdef
name|HAVE_ID_IN_UTMP
name|line_abbrevname
argument_list|(
name|ut
operator|->
name|ut_id
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMP
comment|/* This is done here to keep utmp constants out of struct logininfo */
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
name|ut
operator|->
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
ifdef|#
directive|ifdef
name|_UNICOS
name|cray_set_tmpdir
argument_list|(
name|ut
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LTYPE_LOGOUT
case|:
name|ut
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
ifdef|#
directive|ifdef
name|_UNICOS
name|cray_retain_utmp
argument_list|(
name|ut
argument_list|,
name|li
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
endif|#
directive|endif
name|set_utmp_time
argument_list|(
name|li
argument_list|,
name|ut
argument_list|)
expr_stmt|;
name|line_stripname
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PID_IN_UTMP
name|ut
operator|->
name|ut_pid
operator|=
name|li
operator|->
name|pid
expr_stmt|;
endif|#
directive|endif
comment|/* If we're logging out, leave all other fields blank */
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGOUT
condition|)
return|return;
comment|/* 	 * These fields are only used when logging in, and are blank 	 * for logouts. 	 */
comment|/* Use strncpy because we don't necessarily want null termination */
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|,
name|li
operator|->
name|username
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|,
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMP
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_IN_UTMP
comment|/* this is just a 32-bit IP address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
name|ut
operator|->
name|ut_addr
operator|=
name|li
operator|->
name|hostaddr
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
comment|/* this is just a 128-bit IPv6 address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ut
operator|->
name|ut_addr_v6
argument_list|,
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|ut
operator|->
name|ut_addr_v6
index|[
literal|0
index|]
operator|=
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMP || USE_WTMP || USE_LOGIN */
end_comment

begin_comment
comment|/**  ** utmpx utility functions  **  ** These functions manipulate struct utmpx, accounting for system  ** variations.  **/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_UTMPX
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_WTMPX
argument_list|)
end_if

begin_comment
comment|/* build the utmpx structure */
end_comment

begin_function
name|void
name|set_utmpx_time
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TV_IN_UTMPX
argument_list|)
name|utx
operator|->
name|ut_tv
operator|.
name|tv_sec
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
name|utx
operator|->
name|ut_tv
operator|.
name|tv_usec
operator|=
name|li
operator|->
name|tv_usec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMPX
argument_list|)
name|utx
operator|->
name|ut_time
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|construct_utmpx
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|utx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|utx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ID_IN_UTMPX
name|line_abbrevname
argument_list|(
name|utx
operator|->
name|ut_id
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|->
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* this is done here to keep utmp constants out of loginrec.h */
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
name|utx
operator|->
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
break|break;
case|case
name|LTYPE_LOGOUT
case|:
name|utx
operator|->
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
break|break;
block|}
name|line_stripname
argument_list|(
name|utx
operator|->
name|ut_line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|->
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|set_utmpx_time
argument_list|(
name|li
argument_list|,
name|utx
argument_list|)
expr_stmt|;
name|utx
operator|->
name|ut_pid
operator|=
name|li
operator|->
name|pid
expr_stmt|;
comment|/* strncpy(): Don't necessarily want null termination */
name|strncpy
argument_list|(
name|utx
operator|->
name|ut_user
argument_list|,
name|li
operator|->
name|username
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|utx
operator|->
name|ut_user
argument_list|,
name|li
operator|->
name|username
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|LTYPE_LOGOUT
condition|)
return|return;
comment|/* 	 * These fields are only used when logging in, and are blank 	 * for logouts. 	 */
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMPX
name|strncpy
argument_list|(
name|utx
operator|->
name|ut_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|utx
operator|->
name|ut_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_IN_UTMPX
comment|/* this is just a 32-bit IP address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
name|utx
operator|->
name|ut_addr
operator|=
name|li
operator|->
name|hostaddr
operator|.
name|sa_in
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
comment|/* this is just a 128-bit IPv6 address */
if|if
condition|(
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|li
operator|->
name|hostaddr
operator|.
name|sa
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ut
operator|->
name|ut_addr_v6
argument_list|,
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|ut
operator|->
name|ut_addr_v6
index|[
literal|0
index|]
operator|=
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ut
operator|->
name|ut_addr_v6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSLEN_IN_UTMPX
comment|/* ut_syslen is the length of the utx_host string */
name|utx
operator|->
name|ut_syslen
operator|=
name|MIN
argument_list|(
name|strlen
argument_list|(
name|li
operator|->
name|hostname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|->
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMPX || USE_WTMPX */
end_comment

begin_comment
comment|/**  ** Low-level utmp functions  **/
end_comment

begin_comment
comment|/* FIXME: (ATL) utmp_write_direct needs testing */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_UTMP
end_ifdef

begin_comment
comment|/* if we can, use pututline() etc. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_PUTUTLINE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETUTENT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_PUTUTLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|UTMP_USE_LIBRARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* write a utmp entry with the system's help (pututline() and pals) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTMP_USE_LIBRARY
end_ifdef

begin_function
specifier|static
name|int
name|utmp_write_library
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|setutent
argument_list|()
expr_stmt|;
name|pututline
argument_list|(
name|ut
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ENDUTENT
name|endutent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UTMP_USE_LIBRARY */
end_comment

begin_comment
comment|/*  * Write a utmp entry direct to the file  * This is a slightly modification of code in OpenBSD's login.c  */
end_comment

begin_function
specifier|static
name|int
name|utmp_write_direct
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|struct
name|utmp
name|old_ut
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|tty
decl_stmt|;
comment|/* FIXME: (ATL) ttyslot() needs local implementation */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETTTYENT
argument_list|)
name|struct
name|ttyent
modifier|*
name|ty
decl_stmt|;
name|tty
operator|=
literal|0
expr_stmt|;
name|setttyent
argument_list|()
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|ty
operator|=
name|getttyent
argument_list|()
operator|)
condition|)
block|{
name|tty
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ty
operator|->
name|ty_name
argument_list|,
name|ut
operator|->
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|endttyent
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ty
condition|)
block|{
name|logit
argument_list|(
literal|"%s: tty not found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
comment|/* FIXME */
name|tty
operator|=
name|ttyslot
argument_list|()
expr_stmt|;
comment|/* seems only to work for /dev/ttyp? style names */
endif|#
directive|endif
comment|/* HAVE_GETTTYENT */
if|if
condition|(
name|tty
operator|>
literal|0
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|UTMP_FILE
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|off_t
name|pos
decl_stmt|,
name|ret
decl_stmt|;
name|pos
operator|=
operator|(
name|off_t
operator|)
name|tty
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logit
argument_list|(
literal|"%s: lseek: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
name|pos
condition|)
block|{
name|logit
argument_list|(
literal|"%s: Couldn't seek to tty %d slot in %s"
argument_list|,
name|__func__
argument_list|,
name|tty
argument_list|,
name|UTMP_FILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Prevent luser from zero'ing out ut_host. 		 * If the new ut_line is empty but the old one is not 		 * and ut_line and ut_name match, preserve the old ut_line. 		 */
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|old_ut
argument_list|,
sizeof|sizeof
argument_list|(
name|old_ut
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|old_ut
argument_list|)
operator|&&
operator|(
name|ut
operator|->
name|ut_host
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|old_ut
operator|.
name|ut_host
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|old_ut
operator|.
name|ut_line
argument_list|,
name|ut
operator|->
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_line
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|old_ut
operator|.
name|ut_name
argument_list|,
name|ut
operator|->
name|ut_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|memcpy
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
name|old_ut
operator|.
name|ut_host
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logit
argument_list|(
literal|"%s: lseek: %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
name|pos
condition|)
block|{
name|logit
argument_list|(
literal|"%s: Couldn't seek to tty %d slot in %s"
argument_list|,
name|__func__
argument_list|,
name|tty
argument_list|,
name|UTMP_FILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: error writing %s: %s"
argument_list|,
name|__func__
argument_list|,
name|UTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTMP_USE_LIBRARY */
end_comment

begin_function
specifier|static
name|int
name|utmp_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMP_USE_LIBRARY
if|if
condition|(
operator|!
name|utmp_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: utmp_write_library() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|utmp_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: utmp_write_direct() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utmp_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMP_USE_LIBRARY
if|if
condition|(
operator|!
name|utmp_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: utmp_write_library() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|utmp_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: utmp_write_direct() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|utmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
operator|(
name|utmp_perform_login
argument_list|(
name|li
argument_list|)
operator|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
operator|(
name|utmp_perform_logout
argument_list|(
name|li
argument_list|)
operator|)
return|;
default|default:
name|logit
argument_list|(
literal|"%s: invalid type field"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMP */
end_comment

begin_comment
comment|/**  ** Low-level utmpx functions  **/
end_comment

begin_comment
comment|/* not much point if we don't want utmpx entries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_UTMPX
end_ifdef

begin_comment
comment|/* if we have the wherewithall, use pututxline etc. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_PUTUTXLINE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETUTXENT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_PUTUTXLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|UTMPX_USE_LIBRARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* write a utmpx entry with the system's help (pututxline() and pals) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTMPX_USE_LIBRARY
end_ifdef

begin_function
specifier|static
name|int
name|utmpx_write_library
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
name|setutxent
argument_list|()
expr_stmt|;
name|pututxline
argument_list|(
name|utx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ENDUTXENT
name|endutxent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UTMPX_USE_LIBRARY */
end_comment

begin_comment
comment|/* write a utmp entry direct to the file */
end_comment

begin_function
specifier|static
name|int
name|utmpx_write_direct
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
name|logit
argument_list|(
literal|"%s: not implemented!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTMPX_USE_LIBRARY */
end_comment

begin_function
specifier|static
name|int
name|utmpx_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPX_USE_LIBRARY
if|if
condition|(
operator|!
name|utmpx_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: utmp_write_library() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|utmpx_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: utmp_write_direct() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utmpx_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ID_IN_UTMPX
name|line_abbrevname
argument_list|(
name|utx
operator|.
name|ut_id
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|.
name|ut_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMPX
name|utx
operator|.
name|ut_type
operator|=
name|DEAD_PROCESS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UTMPX_USE_LIBRARY
name|utmpx_write_library
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
name|utmpx_write_direct
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|utmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
operator|(
name|utmpx_perform_login
argument_list|(
name|li
argument_list|)
operator|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
operator|(
name|utmpx_perform_logout
argument_list|(
name|li
argument_list|)
operator|)
return|;
default|default:
name|logit
argument_list|(
literal|"%s: invalid type field"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_UTMPX */
end_comment

begin_comment
comment|/**  ** Low-level wtmp functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WTMP
end_ifdef

begin_comment
comment|/*  * Write a wtmp entry direct to the end of the file  * This is a slight modification of code in OpenBSD's logwtmp.c  */
end_comment

begin_function
specifier|static
name|int
name|wtmp_write
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMP_FILE
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: problem writing %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
condition|)
block|{
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"%s: problem writing %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmp_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
return|return
operator|(
name|wtmp_write
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmp_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
return|return
operator|(
name|wtmp_write
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtmp_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
operator|(
name|wtmp_perform_login
argument_list|(
name|li
argument_list|)
operator|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
operator|(
name|wtmp_perform_logout
argument_list|(
name|li
argument_list|)
operator|)
return|;
default|default:
name|logit
argument_list|(
literal|"%s: invalid type field"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notes on fetching login data from wtmp/wtmpx  *  * Logouts are usually recorded with (amongst other things) a blank  * username on a given tty line.  However, some systems (HP-UX is one)  * leave all fields set, but change the ut_type field to DEAD_PROCESS.  *  * Since we're only looking for logins here, we know that the username  * must be set correctly. On systems that leave it in, we check for  * ut_type==USER_PROCESS (indicating a login.)  *  * Portability: Some systems may set something other than USER_PROCESS  * to indicate a login process. I don't know of any as I write. Also,  * it's possible that some systems may both leave the username in  * place and not have ut_type.  */
end_comment

begin_comment
comment|/* return true if this wtmp entry indicates a login */
end_comment

begin_function
specifier|static
name|int
name|wtmp_islogin
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|ut
operator|->
name|ut_name
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|ut
operator|->
name|ut_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMP
if|if
condition|(
name|ut
operator|->
name|ut_type
operator|&
name|USER_PROCESS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtmp_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|utmp
name|ut
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
comment|/* Clear the time entries in our logininfo */
name|li
operator|->
name|tv_sec
operator|=
name|li
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMP_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: problem opening %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: couldn't stat %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Seek to the start of the last struct utmp */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Looks like we've got a fresh wtmp file */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: read of %s failed: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMP_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|wtmp_islogin
argument_list|(
name|li
argument_list|,
operator|&
name|ut
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
comment|/* 			 * We've already checked for a time in struct 			 * utmp, in login_getlast() 			 */
ifdef|#
directive|ifdef
name|HAVE_TIME_IN_UTMP
name|li
operator|->
name|tv_sec
operator|=
name|ut
operator|.
name|ut_time
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_TV_IN_UTMP
name|li
operator|->
name|tv_sec
operator|=
name|ut
operator|.
name|ut_tv
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|ut
operator|.
name|ut_line
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HOST_IN_UTMP
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|ut
operator|.
name|ut_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|ut
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* Seek back 2 x struct utmp */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
call|(
name|off_t
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* We've found the start of the file, so quit */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* We found an entry. Tidy up and return */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WTMP */
end_comment

begin_comment
comment|/**  ** Low-level wtmpx functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WTMPX
end_ifdef

begin_comment
comment|/*  * Write a wtmpx entry direct to the end of the file  * This is a slight modification of code in OpenBSD's logwtmp.c  */
end_comment

begin_function
specifier|static
name|int
name|wtmpx_write
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_UPDWTMPX
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMPX_FILE
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: problem opening %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|utx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|utx
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|utx
argument_list|)
condition|)
block|{
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"%s: problem writing %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
else|#
directive|else
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
name|utx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|wtmpx_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
return|return
operator|(
name|wtmpx_write
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wtmpx_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
name|utx
decl_stmt|;
name|construct_utmpx
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
return|return
operator|(
name|wtmpx_write
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtmpx_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
operator|(
name|wtmpx_perform_login
argument_list|(
name|li
argument_list|)
operator|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
operator|(
name|wtmpx_perform_logout
argument_list|(
name|li
argument_list|)
operator|)
return|;
default|default:
name|logit
argument_list|(
literal|"%s: invalid type field"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Please see the notes above wtmp_islogin() for information about the    next two functions */
end_comment

begin_comment
comment|/* Return true if this wtmpx entry indicates a login */
end_comment

begin_function
specifier|static
name|int
name|wtmpx_islogin
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|struct
name|utmpx
modifier|*
name|utx
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|utx
operator|->
name|ut_name
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|username
argument_list|,
name|utx
operator|->
name|ut_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TYPE_IN_UTMPX
if|if
condition|(
name|utx
operator|->
name|ut_type
operator|==
name|USER_PROCESS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtmpx_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|utmpx
name|utx
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
comment|/* Clear the time entries */
name|li
operator|->
name|tv_sec
operator|=
name|li
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|WTMPX_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: problem opening %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: couldn't stat %s: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Seek to the start of the last struct utmpx */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|utmpx
argument_list|)
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* probably a newly rotated wtmpx file */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|utx
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|utx
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"%s: read of %s failed: %s"
argument_list|,
name|__func__
argument_list|,
name|WTMPX_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Logouts are recorded as a blank username on a particular 		 * line. So, we just need to find the username in struct utmpx 		 */
if|if
condition|(
name|wtmpx_islogin
argument_list|(
name|li
argument_list|,
operator|&
name|utx
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TV_IN_UTMPX
argument_list|)
name|li
operator|->
name|tv_sec
operator|=
name|utx
operator|.
name|ut_tv
operator|.
name|tv_sec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_TIME_IN_UTMPX
argument_list|)
name|li
operator|->
name|tv_sec
operator|=
name|utx
operator|.
name|ut_time
expr_stmt|;
endif|#
directive|endif
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|utx
operator|.
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_HOST_IN_UTMPX
argument_list|)
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|utx
operator|.
name|ut_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|utx
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
call|(
name|off_t
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmpx
argument_list|)
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WTMPX */
end_comment

begin_comment
comment|/**  ** Low-level libutil login() functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOGIN
end_ifdef

begin_function
specifier|static
name|int
name|syslogin_perform_login
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmp
modifier|*
name|ut
decl_stmt|;
name|ut
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ut
argument_list|)
argument_list|)
expr_stmt|;
name|construct_utmp
argument_list|(
name|li
argument_list|,
name|ut
argument_list|)
expr_stmt|;
name|login
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ut
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|syslogin_perform_logout
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LOGOUT
name|char
name|line
index|[
name|UT_LINESIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|line_stripname
argument_list|(
name|line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|logout
argument_list|(
name|line
argument_list|)
condition|)
name|logit
argument_list|(
literal|"%s: logout() returned an error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LOGWTMP
else|else
name|logwtmp
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FIXME: (ATL - if the need arises) What to do if we have 	 * login, but no logout?  what if logout but no logwtmp? All 	 * routines are in libutil so they should all be there, 	 * but... */
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|syslogin_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
operator|(
name|syslogin_perform_login
argument_list|(
name|li
argument_list|)
operator|)
return|;
case|case
name|LTYPE_LOGOUT
case|:
return|return
operator|(
name|syslogin_perform_logout
argument_list|(
name|li
argument_list|)
operator|)
return|;
default|default:
name|logit
argument_list|(
literal|"%s: Invalid type field"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LOGIN */
end_comment

begin_comment
comment|/* end of file log-syslogin.c */
end_comment

begin_comment
comment|/**  ** Low-level lastlog functions  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LASTLOG
end_ifdef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LASTLOG_WRITE_PUTUTXLINE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_GETLASTLOGXBYNAME
argument_list|)
end_if

begin_comment
comment|/* open the file (using filemode) and seek to the login entry */
end_comment

begin_function
specifier|static
name|int
name|lastlog_openseek
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|,
name|int
name|filemode
parameter_list|)
block|{
name|off_t
name|offset
decl_stmt|;
name|char
name|lastlog_file
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|LASTLOG_FILE
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: Couldn't stat %s: %s"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|lastlog_file
argument_list|,
sizeof|sizeof
argument_list|(
name|lastlog_file
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|lastlog_file
argument_list|,
name|LASTLOG_FILE
argument_list|,
sizeof|sizeof
argument_list|(
name|lastlog_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logit
argument_list|(
literal|"%s: %.100s is not a file or directory!"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|fd
operator|=
name|open
argument_list|(
name|lastlog_file
argument_list|,
name|filemode
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fd
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"%s: Couldn't open %s: %s"
argument_list|,
name|__func__
argument_list|,
name|lastlog_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* find this uid's offset in the lastlog file */
name|offset
operator|=
call|(
name|off_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|li
operator|->
name|uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lastlog
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
operator|*
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|offset
condition|)
block|{
name|logit
argument_list|(
literal|"%s: %s->lseek(): %s"
argument_list|,
name|__func__
argument_list|,
name|lastlog_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !LASTLOG_WRITE_PUTUTXLINE || !HAVE_GETLASTLOGXBYNAME */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LASTLOG_WRITE_PUTUTXLINE
end_ifdef

begin_function
name|int
name|lastlog_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
return|return
literal|1
return|;
comment|/* lastlog written by pututxline */
default|default:
name|logit
argument_list|(
literal|"lastlog_write_entry: Invalid type field"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LASTLOG_WRITE_PUTUTXLINE */
end_comment

begin_function
name|int
name|lastlog_write_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|lastlog
name|last
decl_stmt|;
name|int
name|fd
decl_stmt|;
switch|switch
condition|(
name|li
operator|->
name|type
condition|)
block|{
case|case
name|LTYPE_LOGIN
case|:
comment|/* create our struct lastlog */
name|memset
argument_list|(
operator|&
name|last
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|line_stripname
argument_list|(
name|last
operator|.
name|ll_line
argument_list|,
name|li
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|last
operator|.
name|ll_line
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|last
operator|.
name|ll_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|last
operator|.
name|ll_host
argument_list|,
name|li
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|.
name|ll_time
operator|=
name|li
operator|->
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|!
name|lastlog_openseek
argument_list|(
name|li
argument_list|,
operator|&
name|fd
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* write the entry */
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
operator|&
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"%s: Error writing to %s: %s"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|logit
argument_list|(
literal|"%s: Invalid type field"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LASTLOG_WRITE_PUTUTXLINE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETLASTLOGXBYNAME
end_ifdef

begin_function
name|int
name|lastlog_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|lastlogx
name|l
decl_stmt|,
modifier|*
name|ll
decl_stmt|;
if|if
condition|(
operator|(
name|ll
operator|=
name|getlastlogxbyname
argument_list|(
name|li
operator|->
name|username
argument_list|,
operator|&
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|memset
argument_list|(
operator|&
name|l
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|&
name|l
expr_stmt|;
block|}
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|ll
operator|->
name|ll_line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|ll
operator|->
name|ll_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|ll
operator|->
name|ll_host
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|tv_sec
operator|=
name|ll
operator|->
name|ll_tv
operator|.
name|tv_sec
expr_stmt|;
name|li
operator|->
name|tv_usec
operator|=
name|ll
operator|->
name|ll_tv
operator|.
name|tv_usec
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_GETLASTLOGXBYNAME */
end_comment

begin_function
name|int
name|lastlog_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|lastlog
name|last
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|lastlog_openseek
argument_list|(
name|li
argument_list|,
operator|&
name|fd
argument_list|,
name|O_RDONLY
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
name|memset
argument_list|(
operator|&
name|last
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
sizeof|sizeof
argument_list|(
name|last
argument_list|)
case|:
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|last
operator|.
name|ll_line
argument_list|,
sizeof|sizeof
argument_list|(
name|li
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|last
operator|.
name|ll_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|last
operator|.
name|ll_host
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|tv_sec
operator|=
name|last
operator|.
name|ll_time
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"%s: Error reading from %s: %s"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"%s: Error reading from %s: Expecting %d, got %d"
argument_list|,
name|__func__
argument_list|,
name|LASTLOG_FILE
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETLASTLOGXBYNAME */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LASTLOG */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_function
name|int
name|utmpx_get_entry
parameter_list|(
name|struct
name|logininfo
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|utmpx
modifier|*
name|utx
decl_stmt|;
if|if
condition|(
name|setutxdb
argument_list|(
name|UTXDB_LASTLOGIN
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|utx
operator|=
name|getutxuser
argument_list|(
name|li
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|utx
operator|==
name|NULL
condition|)
block|{
name|endutxent
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|line_fullname
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|utx
operator|->
name|ut_line
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|line
argument_list|,
name|utx
operator|->
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|utx
operator|->
name|ut_host
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|li
operator|->
name|hostname
argument_list|,
name|utx
operator|->
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|tv_sec
operator|=
name|utx
operator|->
name|ut_tv
operator|.
name|tv_sec
expr_stmt|;
name|li
operator|->
name|tv_usec
operator|=
name|utx
operator|->
name|ut_tv
operator|.
name|tv_usec
expr_stmt|;
name|endutxent
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_BTMP
end_ifdef

begin_comment
comment|/*    * Logs failed login attempts in _PATH_BTMP if that exists.    * The most common login failure is to give password instead of username.    * So the _PATH_BTMP file checked for the correct permission, so that    * only root can read it.    */
end_comment

begin_function
name|void
name|record_failed_login
parameter_list|(
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|utmp
name|ut
decl_stmt|;
name|struct
name|sockaddr_storage
name|from
decl_stmt|;
name|socklen_t
name|fromlen
init|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|a4
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|a6
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|stat
name|fst
decl_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_BTMP
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"Unable to open the btmp file %s: %s"
argument_list|,
name|_PATH_BTMP
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|fst
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"%s: fstat of %s failed: %s"
argument_list|,
name|__func__
argument_list|,
name|_PATH_BTMP
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fst
operator|.
name|st_mode
operator|&
operator|(
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator|||
operator|(
name|fst
operator|.
name|st_uid
operator|!=
literal|0
operator|)
condition|)
block|{
name|logit
argument_list|(
literal|"Excess permission or bad ownership on file %s"
argument_list|,
name|_PATH_BTMP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|&
name|ut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
comment|/* strncpy because we don't necessarily want nul termination */
name|strncpy
argument_list|(
name|ut
operator|.
name|ut_user
argument_list|,
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_user
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
literal|"ssh:notty"
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|t
expr_stmt|;
comment|/* ut_time is not always a time_t */
name|ut
operator|.
name|ut_type
operator|=
name|LOGIN_PROCESS
expr_stmt|;
name|ut
operator|.
name|ut_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* strncpy because we don't necessarily want nul termination */
name|strncpy
argument_list|(
name|ut
operator|.
name|ut_host
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_connection_is_on_socket
argument_list|()
operator|&&
name|getpeername
argument_list|(
name|packet_get_connection_in
argument_list|()
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipv64_normalise_mapped
argument_list|(
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
name|a4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|from
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ut
operator|.
name|ut_addr
argument_list|,
operator|&
operator|(
name|a4
operator|->
name|sin_addr
operator|)
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|ut
operator|.
name|ut_addr
argument_list|,
name|a4
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ADDR_V6_IN_UTMP
if|if
condition|(
name|from
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
name|a6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|from
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ut
operator|.
name|ut_addr_v6
argument_list|,
operator|&
operator|(
name|a6
operator|->
name|sin6_addr
operator|)
argument_list|,
name|MIN_SIZEOF
argument_list|(
name|ut
operator|.
name|ut_addr_v6
argument_list|,
name|a6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
operator|&
name|ut
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
condition|)
name|error
argument_list|(
literal|"Failed to write to %s: %s"
argument_list|,
name|_PATH_BTMP
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_BTMP */
end_comment

end_unit

