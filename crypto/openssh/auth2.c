begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$OpenBSD: auth2.c,v 1.95 2002/08/22 21:33:58 markus Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"monitor_wrap.h"
end_include

begin_comment
comment|/* import */
end_comment

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
modifier|*
name|session_id2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|session_id2_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Authctxt
modifier|*
name|x_authctxt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* methods */
end_comment

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_none
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_pubkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_passwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_kbdint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_hostbased
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Authmethod
modifier|*
name|authmethods
index|[]
init|=
block|{
operator|&
name|method_none
block|,
operator|&
name|method_pubkey
block|,
operator|&
name|method_passwd
block|,
operator|&
name|method_kbdint
block|,
operator|&
name|method_hostbased
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protocol */
end_comment

begin_function_decl
specifier|static
name|void
name|input_service_request
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|input_userauth_request
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* helper */
end_comment

begin_function_decl
specifier|static
name|Authmethod
modifier|*
name|authmethod_lookup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|authmethods_get
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|user_key_allowed
parameter_list|(
name|struct
name|passwd
modifier|*
parameter_list|,
name|Key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hostbased_key_allowed
parameter_list|(
name|struct
name|passwd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * loop until authctxt->success == TRUE  */
end_comment

begin_function
name|Authctxt
modifier|*
name|do_authentication2
parameter_list|(
name|void
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|authctxt_new
argument_list|()
decl_stmt|;
name|x_authctxt
operator|=
name|authctxt
expr_stmt|;
comment|/*XXX*/
comment|/* challenge-response is implemented via keyboard interactive */
if|if
condition|(
name|options
operator|.
name|challenge_response_authentication
condition|)
name|options
operator|.
name|kbd_interactive_authentication
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|pam_authentication_via_kbd_int
condition|)
name|options
operator|.
name|kbd_interactive_authentication
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|use_privsep
condition|)
name|options
operator|.
name|pam_authentication_via_kbd_int
operator|=
literal|0
expr_stmt|;
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_SERVICE_REQUEST
argument_list|,
operator|&
name|input_service_request
argument_list|)
expr_stmt|;
name|dispatch_run
argument_list|(
name|DISPATCH_BLOCK
argument_list|,
operator|&
name|authctxt
operator|->
name|success
argument_list|,
name|authctxt
argument_list|)
expr_stmt|;
return|return
operator|(
name|authctxt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_service_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|acceptit
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|service
init|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|authctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"input_service_request: no authctxt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"ssh-userauth"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|authctxt
operator|->
name|success
condition|)
block|{
name|acceptit
operator|=
literal|1
expr_stmt|;
comment|/* now we can handle user-auth requests */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_REQUEST
argument_list|,
operator|&
name|input_userauth_request
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX all other service requests are denied */
if|if
condition|(
name|acceptit
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_SERVICE_ACCEPT
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"bad service request %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"bad service request %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_userauth_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|Authmethod
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|service
decl_stmt|,
modifier|*
name|method
decl_stmt|,
modifier|*
name|style
init|=
name|NULL
decl_stmt|;
name|int
name|authenticated
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LOGIN_CAP
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_host
decl_stmt|,
modifier|*
name|from_ip
decl_stmt|;
name|from_host
operator|=
name|get_canonical_hostname
argument_list|(
name|options
operator|.
name|verify_reverse_mapping
argument_list|)
expr_stmt|;
name|from_ip
operator|=
name|get_remote_ipaddr
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|authctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"input_userauth_request: no authctxt"
argument_list|)
expr_stmt|;
name|user
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|service
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|method
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"userauth-request for user %s service %s method %s"
argument_list|,
name|user
argument_list|,
name|service
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"attempt %d failures %d"
argument_list|,
name|authctxt
operator|->
name|attempt
argument_list|,
name|authctxt
operator|->
name|failures
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|style
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|style
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|attempt
operator|++
operator|==
literal|0
condition|)
block|{
comment|/* setup auth context */
name|authctxt
operator|->
name|pw
operator|=
name|PRIVSEP
argument_list|(
name|getpwnamallow
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|pw
operator|&&
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"ssh-connection"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|authctxt
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|debug2
argument_list|(
literal|"input_userauth_request: setting up authctxt for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
name|PRIVSEP
argument_list|(
name|start_pam
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|log
argument_list|(
literal|"input_userauth_request: illegal user %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
name|PRIVSEP
argument_list|(
name|start_pam
argument_list|(
literal|"NOUSER"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|setproctitle
argument_list|(
literal|"%s%s"
argument_list|,
name|authctxt
operator|->
name|pw
condition|?
name|user
else|:
literal|"unknown"
argument_list|,
name|use_privsep
condition|?
literal|" [net]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|user
operator|=
name|xstrdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|service
operator|=
name|xstrdup
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|style
operator|=
name|style
condition|?
name|xstrdup
argument_list|(
name|style
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|use_privsep
condition|)
name|mm_inform_authserv
argument_list|(
name|service
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|user
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|service
argument_list|,
name|authctxt
operator|->
name|service
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|packet_disconnect
argument_list|(
literal|"Change of username or service not allowed: "
literal|"(%s,%s) -> (%s,%s)"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|,
name|authctxt
operator|->
name|service
argument_list|,
name|user
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_LOGIN_CAP
if|if
condition|(
name|authctxt
operator|->
name|pw
operator|!=
name|NULL
condition|)
block|{
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|authctxt
operator|->
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
name|lc
operator|=
name|login_getclassbyname
argument_list|(
name|NULL
argument_list|,
name|authctxt
operator|->
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_hostok
argument_list|(
name|lc
argument_list|,
name|from_host
argument_list|,
name|from_ip
argument_list|)
condition|)
block|{
name|log
argument_list|(
literal|"Denied connection for %.200s from %.200s [%.200s]."
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|,
name|from_host
argument_list|,
name|from_ip
argument_list|)
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"Sorry, you are not allowed to connect."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|auth_timeok
argument_list|(
name|lc
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
literal|"LOGIN %.200s REFUSED (TIME) FROM %.200s"
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|,
name|from_host
argument_list|)
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"Logins not available right now."
argument_list|)
expr_stmt|;
block|}
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|lc
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_LOGIN_CAP */
comment|/* reset state */
name|auth2_challenge_stop
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|postponed
operator|=
literal|0
expr_stmt|;
comment|/* try to authenticate user */
name|m
operator|=
name|authmethod_lookup
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|debug2
argument_list|(
literal|"input_userauth_request: try method %s"
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|authenticated
operator|=
name|m
operator|->
name|userauth
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
block|}
name|userauth_finish
argument_list|(
name|authctxt
argument_list|,
name|authenticated
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|userauth_finish
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
name|int
name|authenticated
parameter_list|,
name|char
modifier|*
name|method
parameter_list|)
block|{
name|char
modifier|*
name|methods
decl_stmt|;
if|if
condition|(
operator|!
name|authctxt
operator|->
name|valid
operator|&&
name|authenticated
condition|)
name|fatal
argument_list|(
literal|"INTERNAL ERROR: authenticated invalid user %s"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
comment|/* Special handling for root */
if|if
condition|(
operator|!
name|use_privsep
operator|&&
name|authenticated
operator|&&
name|authctxt
operator|->
name|pw
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
operator|!
name|auth_root_allowed
argument_list|(
name|method
argument_list|)
condition|)
name|authenticated
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PAM
if|if
condition|(
operator|!
name|use_privsep
operator|&&
name|authenticated
operator|&&
name|authctxt
operator|->
name|user
operator|&&
operator|!
name|do_pam_account
argument_list|(
name|authctxt
operator|->
name|user
argument_list|,
name|NULL
argument_list|)
condition|)
name|authenticated
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_PAM */
ifdef|#
directive|ifdef
name|_UNICOS
if|if
condition|(
name|authenticated
operator|&&
name|cray_access_denied
argument_list|(
name|authctxt
operator|->
name|user
argument_list|)
condition|)
block|{
name|authenticated
operator|=
literal|0
expr_stmt|;
name|fatal
argument_list|(
literal|"Access denied for user %s."
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _UNICOS */
comment|/* Log before sending the reply */
name|auth_log
argument_list|(
name|authctxt
argument_list|,
name|authenticated
argument_list|,
name|method
argument_list|,
literal|" ssh2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|postponed
condition|)
return|return;
comment|/* XXX todo: check if multiple auth methods are needed */
if|if
condition|(
name|authenticated
operator|==
literal|1
condition|)
block|{
comment|/* turn off userauth */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_REQUEST
argument_list|,
operator|&
name|dispatch_protocol_ignore
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_SUCCESS
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* now we can break out */
name|authctxt
operator|->
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|authctxt
operator|->
name|failures
operator|++
operator|>
name|AUTH_FAIL_MAX
condition|)
block|{
name|packet_disconnect
argument_list|(
name|AUTH_FAIL_MSG
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_UNICOS
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"password"
argument_list|)
operator|==
literal|0
condition|)
name|cray_login_failure
argument_list|(
name|authctxt
operator|->
name|user
argument_list|,
name|IA_UDBERR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _UNICOS */
name|methods
operator|=
name|authmethods_get
argument_list|()
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX partial success, unused */
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get current user */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|auth_get_user
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|x_authctxt
operator|!=
name|NULL
operator|&&
name|x_authctxt
operator|->
name|valid
operator|)
condition|?
name|x_authctxt
operator|->
name|pw
else|:
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DELIM
value|","
end_define

begin_function
specifier|static
name|char
modifier|*
name|authmethods_get
parameter_list|(
name|void
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|authmethods
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|>
literal|0
condition|)
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|xstrdup
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|Authmethod
modifier|*
name|authmethod_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|authmethods
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|authmethods
index|[
name|i
index|]
return|;
name|debug2
argument_list|(
literal|"Unrecognized authentication method name: %s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

