begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: auth2.c,v 1.135 2015/01/19 20:07:45 markus Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"blacklist_client.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ssh-gss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"monitor_wrap.h"
end_include

begin_comment
comment|/* import */
end_comment

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
modifier|*
name|session_id2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int
name|session_id2_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Buffer
name|loginmsg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* methods */
end_comment

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_none
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_pubkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_passwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_kbdint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_hostbased
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_decl_stmt
specifier|extern
name|Authmethod
name|method_gssapi
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Authmethod
modifier|*
name|authmethods
index|[]
init|=
block|{
operator|&
name|method_none
block|,
operator|&
name|method_pubkey
block|,
ifdef|#
directive|ifdef
name|GSSAPI
operator|&
name|method_gssapi
block|,
endif|#
directive|endif
operator|&
name|method_passwd
block|,
operator|&
name|method_kbdint
block|,
operator|&
name|method_hostbased
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protocol */
end_comment

begin_function_decl
specifier|static
name|int
name|input_service_request
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|input_userauth_request
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* helper */
end_comment

begin_function_decl
specifier|static
name|Authmethod
modifier|*
name|authmethod_lookup
parameter_list|(
name|Authctxt
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|authmethods_get
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MATCH_NONE
value|0
end_define

begin_comment
comment|/* method or submethod mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_METHOD
value|1
end_define

begin_comment
comment|/* method matches (no submethod specified) */
end_comment

begin_define
define|#
directive|define
name|MATCH_BOTH
value|2
end_define

begin_comment
comment|/* method and submethod match */
end_comment

begin_define
define|#
directive|define
name|MATCH_PARTIAL
value|3
end_define

begin_comment
comment|/* method matches, submethod can't be checked */
end_comment

begin_function_decl
specifier|static
name|int
name|list_starts_with
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|auth2_read_banner
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|banner
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|n
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|options
operator|.
name|banner
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|<=
literal|0
operator|||
name|st
operator|.
name|st_size
operator|>
literal|1
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
comment|/* truncate */
name|banner
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
name|banner
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|len
condition|)
block|{
name|free
argument_list|(
name|banner
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|banner
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|banner
operator|)
return|;
block|}
end_function

begin_function
name|void
name|userauth_send_banner
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|datafellows
operator|&
name|SSH_BUG_BANNER
condition|)
return|return;
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_BANNER
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* language, unused */
name|packet_send
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"%s: sent"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|userauth_banner
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|banner
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|options
operator|.
name|banner
operator|==
name|NULL
operator|||
operator|(
name|datafellows
operator|&
name|SSH_BUG_BANNER
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|banner
operator|=
name|PRIVSEP
argument_list|(
name|auth2_read_banner
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|userauth_send_banner
argument_list|(
name|banner
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|banner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * loop until authctxt->success == TRUE  */
end_comment

begin_function
name|void
name|do_authentication2
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_SERVICE_REQUEST
argument_list|,
operator|&
name|input_service_request
argument_list|)
expr_stmt|;
name|dispatch_run
argument_list|(
name|DISPATCH_BLOCK
argument_list|,
operator|&
name|authctxt
operator|->
name|success
argument_list|,
name|authctxt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|input_service_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|acceptit
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|service
init|=
name|packet_get_cstring
argument_list|(
operator|&
name|len
argument_list|)
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|authctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"input_service_request: no authctxt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"ssh-userauth"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|authctxt
operator|->
name|success
condition|)
block|{
name|acceptit
operator|=
literal|1
expr_stmt|;
comment|/* now we can handle user-auth requests */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_REQUEST
argument_list|,
operator|&
name|input_userauth_request
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX all other service requests are denied */
if|if
condition|(
name|acceptit
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_SERVICE_ACCEPT
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"bad service request %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"bad service request %s"
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|service
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|input_userauth_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|Authmethod
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|service
decl_stmt|,
modifier|*
name|method
decl_stmt|,
modifier|*
name|style
init|=
name|NULL
decl_stmt|;
name|int
name|authenticated
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LOGIN_CAP
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_host
decl_stmt|,
modifier|*
name|from_ip
decl_stmt|;
name|from_host
operator|=
name|get_canonical_hostname
argument_list|(
name|options
operator|.
name|use_dns
argument_list|)
expr_stmt|;
name|from_ip
operator|=
name|get_remote_ipaddr
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|authctxt
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"input_userauth_request: no authctxt"
argument_list|)
expr_stmt|;
name|user
operator|=
name|packet_get_cstring
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|service
operator|=
name|packet_get_cstring
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|method
operator|=
name|packet_get_cstring
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"userauth-request for user %s service %s method %s"
argument_list|,
name|user
argument_list|,
name|service
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"attempt %d failures %d"
argument_list|,
name|authctxt
operator|->
name|attempt
argument_list|,
name|authctxt
operator|->
name|failures
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|style
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|style
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|attempt
operator|++
operator|==
literal|0
condition|)
block|{
comment|/* setup auth context */
name|authctxt
operator|->
name|pw
operator|=
name|PRIVSEP
argument_list|(
name|getpwnamallow
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|user
operator|=
name|xstrdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|pw
operator|&&
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"ssh-connection"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|authctxt
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|debug2
argument_list|(
literal|"input_userauth_request: setting up authctxt for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logit
argument_list|(
literal|"input_userauth_request: invalid user %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|pw
operator|=
name|fakepw
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
name|PRIVSEP
argument_list|(
name|audit_event
argument_list|(
name|SSH_INVALID_USER
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|USE_PAM
if|if
condition|(
name|options
operator|.
name|use_pam
condition|)
name|PRIVSEP
argument_list|(
name|start_pam
argument_list|(
name|authctxt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setproctitle
argument_list|(
literal|"%s%s"
argument_list|,
name|authctxt
operator|->
name|valid
condition|?
name|user
else|:
literal|"unknown"
argument_list|,
name|use_privsep
condition|?
literal|" [net]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|service
operator|=
name|xstrdup
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|style
operator|=
name|style
condition|?
name|xstrdup
argument_list|(
name|style
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|use_privsep
condition|)
name|mm_inform_authserv
argument_list|(
name|service
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|userauth_banner
argument_list|()
expr_stmt|;
if|if
condition|(
name|auth2_setup_methods_lists
argument_list|(
name|authctxt
argument_list|)
operator|!=
literal|0
condition|)
name|packet_disconnect
argument_list|(
literal|"no authentication methods enabled"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|user
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|service
argument_list|,
name|authctxt
operator|->
name|service
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|packet_disconnect
argument_list|(
literal|"Change of username or service not allowed: "
literal|"(%s,%s) -> (%s,%s)"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|,
name|authctxt
operator|->
name|service
argument_list|,
name|user
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_LOGIN_CAP
if|if
condition|(
name|authctxt
operator|->
name|pw
operator|!=
name|NULL
condition|)
block|{
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|authctxt
operator|->
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
name|lc
operator|=
name|login_getclassbyname
argument_list|(
name|NULL
argument_list|,
name|authctxt
operator|->
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_hostok
argument_list|(
name|lc
argument_list|,
name|from_host
argument_list|,
name|from_ip
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"Denied connection for %.200s from %.200s [%.200s]."
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|,
name|from_host
argument_list|,
name|from_ip
argument_list|)
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"Sorry, you are not allowed to connect."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|auth_timeok
argument_list|(
name|lc
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
condition|)
block|{
name|logit
argument_list|(
literal|"LOGIN %.200s REFUSED (TIME) FROM %.200s"
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|,
name|from_host
argument_list|)
expr_stmt|;
name|packet_disconnect
argument_list|(
literal|"Logins not available right now."
argument_list|)
expr_stmt|;
block|}
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|lc
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_LOGIN_CAP */
comment|/* reset state */
name|auth2_challenge_stop
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GSSAPI
comment|/* XXX move to auth2_gssapi_stop() */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_GSSAPI_TOKEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|authctxt
operator|->
name|postponed
operator|=
literal|0
expr_stmt|;
name|authctxt
operator|->
name|server_caused_failure
operator|=
literal|0
expr_stmt|;
comment|/* try to authenticate user */
name|m
operator|=
name|authmethod_lookup
argument_list|(
name|authctxt
argument_list|,
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|authctxt
operator|->
name|failures
operator|<
name|options
operator|.
name|max_authtries
condition|)
block|{
name|debug2
argument_list|(
literal|"input_userauth_request: try method %s"
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|authenticated
operator|=
name|m
operator|->
name|userauth
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
block|}
name|userauth_finish
argument_list|(
name|authctxt
argument_list|,
name|authenticated
argument_list|,
name|method
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|method
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|userauth_finish
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
name|int
name|authenticated
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|submethod
parameter_list|)
block|{
name|char
modifier|*
name|methods
decl_stmt|;
name|int
name|partial
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|authctxt
operator|->
name|valid
operator|&&
name|authenticated
condition|)
name|fatal
argument_list|(
literal|"INTERNAL ERROR: authenticated invalid user %s"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|authenticated
operator|&&
name|authctxt
operator|->
name|postponed
condition|)
name|fatal
argument_list|(
literal|"INTERNAL ERROR: authenticated and postponed"
argument_list|)
expr_stmt|;
comment|/* Special handling for root */
if|if
condition|(
name|authenticated
operator|&&
name|authctxt
operator|->
name|pw
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
operator|!
name|auth_root_allowed
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|authenticated
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
name|PRIVSEP
argument_list|(
name|audit_event
argument_list|(
name|SSH_LOGIN_ROOT_DENIED
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|authenticated
operator|&&
name|options
operator|.
name|num_auth_methods
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|auth2_update_methods_lists
argument_list|(
name|authctxt
argument_list|,
name|method
argument_list|,
name|submethod
argument_list|)
condition|)
block|{
name|authenticated
operator|=
literal|0
expr_stmt|;
name|partial
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Log before sending the reply */
name|auth_log
argument_list|(
name|authctxt
argument_list|,
name|authenticated
argument_list|,
name|partial
argument_list|,
name|method
argument_list|,
name|submethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|postponed
condition|)
return|return;
ifdef|#
directive|ifdef
name|USE_PAM
if|if
condition|(
name|options
operator|.
name|use_pam
operator|&&
name|authenticated
condition|)
block|{
if|if
condition|(
operator|!
name|PRIVSEP
argument_list|(
name|do_pam_account
argument_list|()
argument_list|)
condition|)
block|{
comment|/* if PAM returned a message, send it to the user */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|loginmsg
argument_list|)
operator|>
literal|0
condition|)
block|{
name|buffer_append
argument_list|(
operator|&
name|loginmsg
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|userauth_send_banner
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|loginmsg
argument_list|)
argument_list|)
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
name|fatal
argument_list|(
literal|"Access denied for user %s by PAM account "
literal|"configuration"
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_UNICOS
if|if
condition|(
name|authenticated
operator|&&
name|cray_access_denied
argument_list|(
name|authctxt
operator|->
name|user
argument_list|)
condition|)
block|{
name|authenticated
operator|=
literal|0
expr_stmt|;
name|fatal
argument_list|(
literal|"Access denied for user %s."
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _UNICOS */
if|if
condition|(
name|authenticated
operator|==
literal|1
condition|)
block|{
comment|/* turn off userauth */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_REQUEST
argument_list|,
operator|&
name|dispatch_protocol_ignore
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_SUCCESS
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* now we can break out */
name|authctxt
operator|->
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Allow initial try of "none" auth without failure penalty */
if|if
condition|(
operator|!
name|partial
operator|&&
operator|!
name|authctxt
operator|->
name|server_caused_failure
operator|&&
operator|(
name|authctxt
operator|->
name|attempt
operator|>
literal|1
operator|||
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|authctxt
operator|->
name|failures
operator|++
expr_stmt|;
name|BLACKLIST_NOTIFY
argument_list|(
name|BLACKLIST_AUTH_FAIL
argument_list|,
literal|"ssh"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|authctxt
operator|->
name|failures
operator|>=
name|options
operator|.
name|max_authtries
condition|)
block|{
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
name|PRIVSEP
argument_list|(
name|audit_event
argument_list|(
name|SSH_LOGIN_EXCEED_MAXTRIES
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|auth_maxtries_exceeded
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
block|}
name|methods
operator|=
name|authmethods_get
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: failure partial=%d next methods=\"%s\""
argument_list|,
name|__func__
argument_list|,
name|partial
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
name|partial
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks whether method is allowed by at least one AuthenticationMethods  * methods list. Returns 1 if allowed, or no methods lists configured.  * 0 otherwise.  */
end_comment

begin_function
name|int
name|auth2_method_allowed
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|submethod
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
comment|/* 	 * NB. authctxt->num_auth_methods might be zero as a result of 	 * auth2_setup_methods_lists(), so check the configuration. 	 */
if|if
condition|(
name|options
operator|.
name|num_auth_methods
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|authctxt
operator|->
name|num_auth_methods
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list_starts_with
argument_list|(
name|authctxt
operator|->
name|auth_methods
index|[
name|i
index|]
argument_list|,
name|method
argument_list|,
name|submethod
argument_list|)
operator|!=
name|MATCH_NONE
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|authmethods_get
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|authmethods
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|==
name|NULL
operator|||
operator|*
operator|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|auth2_method_allowed
argument_list|(
name|authctxt
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|>
literal|0
condition|)
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|xstrdup
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|Authmethod
modifier|*
name|authmethod_lookup
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|authmethods
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|auth2_method_allowed
argument_list|(
name|authctxt
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|authmethods
index|[
name|i
index|]
return|;
name|debug2
argument_list|(
literal|"Unrecognized authentication method name: %s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Check a comma-separated list of methods for validity. Is need_enable is  * non-zero, then also require that the methods are enabled.  * Returns 0 on success or -1 if the methods list is invalid.  */
end_comment

begin_function
name|int
name|auth2_methods_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|_methods
parameter_list|,
name|int
name|need_enable
parameter_list|)
block|{
name|char
modifier|*
name|methods
decl_stmt|,
modifier|*
name|omethods
decl_stmt|,
modifier|*
name|method
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|_methods
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"empty authentication method list"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|omethods
operator|=
name|methods
operator|=
name|xstrdup
argument_list|(
name|_methods
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|method
operator|=
name|strsep
argument_list|(
operator|&
name|methods
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|found
operator|=
name|i
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|authmethods
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|method
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
name|authmethods
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|need_enable
condition|)
block|{
if|if
condition|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|==
name|NULL
operator|||
operator|*
operator|(
name|authmethods
index|[
name|i
index|]
operator|->
name|enabled
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Disabled method \"%s\" in "
literal|"AuthenticationMethods list \"%s\""
argument_list|,
name|method
argument_list|,
name|_methods
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|error
argument_list|(
literal|"Unknown authentication method \"%s\" in list"
argument_list|,
name|method
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|omethods
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Prune the AuthenticationMethods supplied in the configuration, removing  * any methods lists that include disabled methods. Note that this might  * leave authctxt->num_auth_methods == 0, even when multiple required auth  * has been requested. For this reason, all tests for whether multiple is  * enabled should consult options.num_auth_methods directly.  */
end_comment

begin_function
name|int
name|auth2_setup_methods_lists
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|options
operator|.
name|num_auth_methods
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|debug3
argument_list|(
literal|"%s: checking methods"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|auth_methods
operator|=
name|xcalloc
argument_list|(
name|options
operator|.
name|num_auth_methods
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|authctxt
operator|->
name|auth_methods
argument_list|)
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|num_auth_methods
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|num_auth_methods
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|auth2_methods_valid
argument_list|(
name|options
operator|.
name|auth_methods
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logit
argument_list|(
literal|"Authentication methods list \"%s\" contains "
literal|"disabled method, skipping"
argument_list|,
name|options
operator|.
name|auth_methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|debug
argument_list|(
literal|"authentication methods list %d: %s"
argument_list|,
name|authctxt
operator|->
name|num_auth_methods
argument_list|,
name|options
operator|.
name|auth_methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|auth_methods
index|[
name|authctxt
operator|->
name|num_auth_methods
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|options
operator|.
name|auth_methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|authctxt
operator|->
name|num_auth_methods
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No AuthenticationMethods left after eliminating "
literal|"disabled methods"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_starts_with
parameter_list|(
specifier|const
name|char
modifier|*
name|methods
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|submethod
parameter_list|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|int
name|match
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|methods
argument_list|,
name|method
argument_list|,
name|l
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|MATCH_NONE
return|;
name|p
operator|=
name|methods
operator|+
name|l
expr_stmt|;
name|match
operator|=
name|MATCH_METHOD
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
name|submethod
condition|)
return|return
name|MATCH_PARTIAL
return|;
name|l
operator|=
name|strlen
argument_list|(
name|submethod
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|submethod
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
condition|)
return|return
name|MATCH_NONE
return|;
name|p
operator|+=
name|l
expr_stmt|;
name|match
operator|=
name|MATCH_BOTH
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
return|return
name|MATCH_NONE
return|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/*  * Remove method from the start of a comma-separated list of methods.  * Returns 0 if the list of methods did not start with that method or 1  * if it did.  */
end_comment

begin_function
specifier|static
name|int
name|remove_method
parameter_list|(
name|char
modifier|*
modifier|*
name|methods
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|submethod
parameter_list|)
block|{
name|char
modifier|*
name|omethods
init|=
operator|*
name|methods
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
name|list_starts_with
argument_list|(
name|omethods
argument_list|,
name|method
argument_list|,
name|submethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|MATCH_METHOD
operator|&&
name|match
operator|!=
name|MATCH_BOTH
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|omethods
operator|+
name|l
expr_stmt|;
if|if
condition|(
name|submethod
operator|&&
name|match
operator|==
name|MATCH_BOTH
condition|)
name|p
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|submethod
argument_list|)
expr_stmt|;
comment|/* include colon */
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|methods
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|omethods
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Called after successful authentication. Will remove the successful method  * from the start of each list in which it occurs. If it was the last method  * in any list, then authentication is deemed successful.  * Returns 1 if the method completed any authentication list or 0 otherwise.  */
end_comment

begin_function
name|int
name|auth2_update_methods_lists
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|submethod
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|debug3
argument_list|(
literal|"%s: updating methods list after \"%s\""
argument_list|,
name|__func__
argument_list|,
name|method
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|authctxt
operator|->
name|num_auth_methods
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|remove_method
argument_list|(
operator|&
operator|(
name|authctxt
operator|->
name|auth_methods
index|[
name|i
index|]
operator|)
argument_list|,
name|method
argument_list|,
name|submethod
argument_list|)
condition|)
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|authctxt
operator|->
name|auth_methods
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|debug2
argument_list|(
literal|"authentication methods list %d complete"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|debug3
argument_list|(
literal|"authentication methods list %d remaining: \"%s\""
argument_list|,
name|i
argument_list|,
name|authctxt
operator|->
name|auth_methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* This should not happen, but would be bad if it did */
if|if
condition|(
operator|!
name|found
condition|)
name|fatal
argument_list|(
literal|"%s: method not in AuthenticationMethods"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

