begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2002 Damien Miller.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/sha.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_comment
comment|/* SunOS 4.4.4 needs this */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FLOATINGPOINT_H
end_ifdef

begin_include
include|#
directive|include
file|<floatingpoint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FLOATINGPOINT_H */
end_comment

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"atomicio.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: ssh-rand-helper.c,v 1.26 2005/07/17 07:26:44 djm Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes we write out */
end_comment

begin_define
define|#
directive|define
name|OUTPUT_SEED_SIZE
value|48
end_define

begin_comment
comment|/* Length of on-disk seedfiles */
end_comment

begin_define
define|#
directive|define
name|SEED_FILE_SIZE
value|1024
end_define

begin_comment
comment|/* Maximum number of command-line arguments to read from file */
end_comment

begin_define
define|#
directive|define
name|NUM_ARGS
value|10
end_define

begin_comment
comment|/* Minimum number of usable commands to be considered sufficient */
end_comment

begin_define
define|#
directive|define
name|MIN_ENTROPY_SOURCES
value|16
end_define

begin_comment
comment|/* Path to on-disk seed file (relative to user's home directory */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SSH_PRNG_SEED_FILE
end_ifndef

begin_define
define|#
directive|define
name|SSH_PRNG_SEED_FILE
value|_PATH_SSH_USER_DIR"/prng_seed"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Path to PRNG commands list */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SSH_PRNG_COMMAND_FILE
end_ifndef

begin_define
define|#
directive|define
name|SSH_PRNG_COMMAND_FILE
value|SSHDIR "/ssh_prng_cmds"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WHITESPACE
value|" \t\n"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RUSAGE_SELF
end_ifndef

begin_define
define|#
directive|define
name|RUSAGE_SELF
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RUSAGE_CHILDREN
end_ifndef

begin_define
define|#
directive|define
name|RUSAGE_CHILDREN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PRNGD_SOCKET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRNGD_PORT
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_SEED_FILES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Proportion of data that is entropy */
name|double
name|rate
decl_stmt|;
comment|/* Counter goes positive if this command times out */
name|unsigned
name|int
name|badness
decl_stmt|;
comment|/* Increases by factor of two each timeout */
name|unsigned
name|int
name|sticky_badness
decl_stmt|;
comment|/* Path to executable */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* argv to pass to executable */
name|char
modifier|*
name|args
index|[
name|NUM_ARGS
index|]
decl_stmt|;
comment|/* XXX: arbitrary limit */
comment|/* full command string (debug) */
name|char
modifier|*
name|cmdstring
decl_stmt|;
block|}
name|entropy_cmd_t
typedef|;
end_typedef

begin_comment
comment|/* slow command timeouts (all in milliseconds) */
end_comment

begin_comment
comment|/* static int entropy_timeout_default = ENTROPY_TIMEOUT_MSEC; */
end_comment

begin_decl_stmt
specifier|static
name|int
name|entropy_timeout_current
init|=
name|ENTROPY_TIMEOUT_MSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is initialised from a file, by prng_read_commands() */
end_comment

begin_decl_stmt
specifier|static
name|entropy_cmd_t
modifier|*
name|entropy_cmds
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
name|double
name|stir_from_system
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|stir_from_programs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|stir_gettimeofday
parameter_list|(
name|double
name|entropy_estimate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|stir_clock
parameter_list|(
name|double
name|entropy_estimate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|stir_rusage
parameter_list|(
name|int
name|who
parameter_list|,
name|double
name|entropy_estimate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|hash_command_output
parameter_list|(
name|entropy_cmd_t
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_random_bytes_prngd
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|short
name|tcp_port
parameter_list|,
name|char
modifier|*
name|socket_path
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Collect 'len' bytes of entropy into 'buf' from PRNGD/EGD daemon  * listening either on 'tcp_port', or via Unix domain socket at *  * 'socket_path'.  * Either a non-zero tcp_port or a non-null socket_path must be  * supplied.  * Returns 0 on success, -1 on error  */
end_comment

begin_function
name|int
name|get_random_bytes_prngd
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|short
name|tcp_port
parameter_list|,
name|char
modifier|*
name|socket_path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|addr_len
decl_stmt|,
name|rval
decl_stmt|,
name|errors
decl_stmt|;
name|u_char
name|msg
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr_in
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|addr_un
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
operator|&
name|addr
decl_stmt|;
name|mysig_t
name|old_sigpipe
decl_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|socket_path
operator|==
name|NULL
operator|&&
name|tcp_port
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"You must specify a port or a socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket_path
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|socket_path
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|addr_un
operator|->
name|sun_path
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Random pool path is too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"Too many bytes (%d) to read from PRNGD"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp_port
operator|!=
literal|0
condition|)
block|{
name|addr_in
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr_in
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|addr_in
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|tcp_port
argument_list|)
expr_stmt|;
name|addr_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|addr_in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_un
operator|->
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strlcpy
argument_list|(
name|addr_un
operator|->
name|sun_path
argument_list|,
name|socket_path
argument_list|,
sizeof|sizeof
argument_list|(
name|addr_un
operator|->
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
name|addr_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|socket_path
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|old_sigpipe
operator|=
name|mysignal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
name|reopen
label|:
name|fd
operator|=
name|socket
argument_list|(
name|addr
operator|.
name|ss_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Couldn't create socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addr_len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tcp_port
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Couldn't connect to PRNGD port %d: %s"
argument_list|,
name|tcp_port
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Couldn't connect to PRNGD socket \"%s\": %s"
argument_list|,
name|addr_un
operator|->
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* Send blocking read request to PRNGD */
name|msg
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPIPE
operator|&&
name|errors
operator|<
literal|10
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
goto|goto
name|reopen
goto|;
block|}
name|error
argument_list|(
literal|"Couldn't write to PRNGD socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
name|len
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPIPE
operator|&&
name|errors
operator|<
literal|10
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
goto|goto
name|reopen
goto|;
block|}
name|error
argument_list|(
literal|"Couldn't read from PRNGD socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rval
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|mysignal
argument_list|(
name|SIGPIPE
argument_list|,
name|old_sigpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seed_from_prngd
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PRNGD_PORT
name|debug
argument_list|(
literal|"trying egd/prngd port %d"
argument_list|,
name|PRNGD_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_random_bytes_prngd
argument_list|(
name|buf
argument_list|,
name|bytes
argument_list|,
name|PRNGD_PORT
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRNGD_SOCKET
name|debug
argument_list|(
literal|"trying egd/prngd socket %s"
argument_list|,
name|PRNGD_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_random_bytes_prngd
argument_list|(
name|buf
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|PRNGD_SOCKET
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|double
name|stir_gettimeofday
parameter_list|(
name|double
name|entropy_estimate
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Couldn't gettimeofday: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
name|entropy_estimate
argument_list|)
expr_stmt|;
return|return
name|entropy_estimate
return|;
block|}
end_function

begin_function
name|double
name|stir_clock
parameter_list|(
name|double
name|entropy_estimate
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_CLOCK
name|clock_t
name|c
decl_stmt|;
name|c
operator|=
name|clock
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
name|entropy_estimate
argument_list|)
expr_stmt|;
return|return
name|entropy_estimate
return|;
else|#
directive|else
comment|/* _HAVE_CLOCK */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* _HAVE_CLOCK */
block|}
end_function

begin_function
name|double
name|stir_rusage
parameter_list|(
name|int
name|who
parameter_list|,
name|double
name|entropy_estimate
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|struct
name|rusage
name|ru
decl_stmt|;
if|if
condition|(
name|getrusage
argument_list|(
name|who
argument_list|,
operator|&
name|ru
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|RAND_add
argument_list|(
operator|&
name|ru
argument_list|,
sizeof|sizeof
argument_list|(
name|ru
argument_list|)
argument_list|,
name|entropy_estimate
argument_list|)
expr_stmt|;
return|return
name|entropy_estimate
return|;
else|#
directive|else
comment|/* _HAVE_GETRUSAGE */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* _HAVE_GETRUSAGE */
block|}
end_function

begin_function
specifier|static
name|int
name|timeval_diff
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2
parameter_list|)
block|{
name|int
name|secdiff
decl_stmt|,
name|usecdiff
decl_stmt|;
name|secdiff
operator|=
name|t2
operator|->
name|tv_sec
operator|-
name|t1
operator|->
name|tv_sec
expr_stmt|;
name|usecdiff
operator|=
operator|(
name|secdiff
operator|*
literal|1000000
operator|)
operator|+
operator|(
name|t2
operator|->
name|tv_usec
operator|-
name|t1
operator|->
name|tv_usec
operator|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|usecdiff
operator|/
literal|1000
argument_list|)
return|;
block|}
end_function

begin_function
name|double
name|hash_command_output
parameter_list|(
name|entropy_cmd_t
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
name|hash
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|fd_set
name|rdset
decl_stmt|;
name|int
name|bytes_read
decl_stmt|,
name|cmd_eof
decl_stmt|,
name|error_abort
decl_stmt|,
name|msec_elapsed
decl_stmt|,
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|status
decl_stmt|,
name|total_bytes_read
decl_stmt|;
specifier|static
name|int
name|devnull
init|=
operator|-
literal|1
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|SHA_CTX
name|sha
decl_stmt|;
name|struct
name|timeval
name|tv_start
decl_stmt|,
name|tv_current
decl_stmt|;
name|debug3
argument_list|(
literal|"Reading output from \'%s\'"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|devnull
operator|==
operator|-
literal|1
condition|)
block|{
name|devnull
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|devnull
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Couldn't open /dev/null: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Couldn't open pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* record start time */
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error */
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Couldn't fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
comment|/* Child */
name|dup2
argument_list|(
name|devnull
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|devnull
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|src
operator|->
name|path
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|src
operator|->
name|args
operator|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"(child) Couldn't exec '%s': %s"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* Parent */
break|break;
block|}
name|RAND_add
argument_list|(
operator|&
name|pid
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|pid
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Hash output from child */
name|SHA1_Init
argument_list|(
operator|&
name|sha
argument_list|)
expr_stmt|;
name|cmd_eof
operator|=
name|error_abort
operator|=
name|msec_elapsed
operator|=
name|total_bytes_read
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|error_abort
operator|&&
operator|!
name|cmd_eof
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|msec_remaining
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv_current
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msec_elapsed
operator|=
name|timeval_diff
argument_list|(
operator|&
name|tv_start
argument_list|,
operator|&
name|tv_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec_elapsed
operator|>=
name|entropy_timeout_current
condition|)
block|{
name|error_abort
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|msec_remaining
operator|=
name|entropy_timeout_current
operator|-
name|msec_elapsed
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
operator|&
name|rdset
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|msec_remaining
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|msec_remaining
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|ret
operator|=
name|select
argument_list|(
name|p
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|rdset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
comment|/* timer expired */
name|error_abort
operator|=
literal|1
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* command input */
do|do
block|{
name|bytes_read
operator|=
name|read
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|bytes_read
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
name|RAND_add
argument_list|(
operator|&
name|bytes_read
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|bytes_read
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|error_abort
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|bytes_read
condition|)
block|{
name|SHA1_Update
argument_list|(
operator|&
name|sha
argument_list|,
name|buf
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|total_bytes_read
operator|+=
name|bytes_read
expr_stmt|;
block|}
else|else
block|{
name|cmd_eof
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
default|default:
comment|/* error */
name|debug
argument_list|(
literal|"Command '%s': select() failed: %s"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_abort
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|SHA1_Final
argument_list|(
name|hash
argument_list|,
operator|&
name|sha
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"Time elapsed: %d msec"
argument_list|,
name|msec_elapsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Couldn't wait for child '%s' completion: %s"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
name|RAND_add
argument_list|(
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|status
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_abort
condition|)
block|{
comment|/* 		 * Closing p[0] on timeout causes the entropy command to 		 * SIGPIPE. Take whatever output we got, and mark this 		 * command as slow 		 */
name|debug2
argument_list|(
literal|"Command '%s' timed out"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|)
expr_stmt|;
name|src
operator|->
name|sticky_badness
operator|*=
literal|2
expr_stmt|;
name|src
operator|->
name|badness
operator|=
name|src
operator|->
name|sticky_badness
expr_stmt|;
return|return
name|total_bytes_read
return|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|total_bytes_read
return|;
block|}
else|else
block|{
name|debug2
argument_list|(
literal|"Command '%s' exit status was %d"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|badness
operator|=
name|src
operator|->
name|sticky_badness
operator|=
literal|128
expr_stmt|;
return|return
literal|0.0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|debug2
argument_list|(
literal|"Command '%s' returned on uncaught signal %d !"
argument_list|,
name|src
operator|->
name|cmdstring
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|src
operator|->
name|badness
operator|=
name|src
operator|->
name|sticky_badness
operator|=
literal|128
expr_stmt|;
return|return
literal|0.0
return|;
block|}
else|else
return|return
literal|0.0
return|;
block|}
end_function

begin_function
name|double
name|stir_from_system
parameter_list|(
name|void
parameter_list|)
block|{
name|double
name|total_entropy_estimate
decl_stmt|;
name|long
name|int
name|i
decl_stmt|;
name|total_entropy_estimate
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|total_entropy_estimate
operator|+=
literal|0.1
expr_stmt|;
name|i
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|total_entropy_estimate
operator|+=
literal|0.1
expr_stmt|;
name|i
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|i
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|total_entropy_estimate
operator|+=
name|stir_gettimeofday
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|total_entropy_estimate
operator|+=
name|stir_clock
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|total_entropy_estimate
operator|+=
name|stir_rusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
literal|2.0
argument_list|)
expr_stmt|;
return|return
name|total_entropy_estimate
return|;
block|}
end_function

begin_function
name|double
name|stir_from_programs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|double
name|entropy
decl_stmt|,
name|total_entropy
decl_stmt|;
name|unsigned
name|char
name|hash
index|[
name|SHA_DIGEST_LENGTH
index|]
decl_stmt|;
name|total_entropy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|path
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|badness
condition|)
block|{
comment|/* Hash output from command */
name|entropy
operator|=
name|hash_command_output
argument_list|(
operator|&
name|entropy_cmds
index|[
name|c
index|]
argument_list|,
name|hash
argument_list|)
expr_stmt|;
comment|/* Scale back estimate by command's rate */
name|entropy
operator|*=
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|rate
expr_stmt|;
comment|/* Upper bound of entropy is SHA_DIGEST_LENGTH */
if|if
condition|(
name|entropy
operator|>
name|SHA_DIGEST_LENGTH
condition|)
name|entropy
operator|=
name|SHA_DIGEST_LENGTH
expr_stmt|;
comment|/* Stir it in */
name|RAND_add
argument_list|(
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"Got %0.2f bytes of entropy from '%s'"
argument_list|,
name|entropy
argument_list|,
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|cmdstring
argument_list|)
expr_stmt|;
name|total_entropy
operator|+=
name|entropy
expr_stmt|;
comment|/* Execution time should be a bit unpredictable */
name|total_entropy
operator|+=
name|stir_gettimeofday
argument_list|(
literal|0.05
argument_list|)
expr_stmt|;
name|total_entropy
operator|+=
name|stir_clock
argument_list|(
literal|0.05
argument_list|)
expr_stmt|;
name|total_entropy
operator|+=
name|stir_rusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
name|total_entropy
operator|+=
name|stir_rusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug2
argument_list|(
literal|"Command '%s' disabled (badness %d)"
argument_list|,
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|cmdstring
argument_list|,
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|badness
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|badness
operator|>
literal|0
condition|)
name|entropy_cmds
index|[
name|c
index|]
operator|.
name|badness
operator|--
expr_stmt|;
block|}
block|}
return|return
name|total_entropy
return|;
block|}
end_function

begin_comment
comment|/*  * prng seedfile functions  */
end_comment

begin_function
name|int
name|prng_check_seedfile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* 	 * XXX raceable: eg replace seed between this stat and subsequent 	 * open. Not such a problem because we don't really trust the 	 * seed file anyway. 	 * XXX: use secure path checking as elsewhere in OpenSSH 	 */
if|if
condition|(
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Give up on hard errors */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|debug
argument_list|(
literal|"WARNING: Couldn't stat random seed file "
literal|"\"%.100s\": %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* regular file? */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"PRNG seedfile %.100s is not a regular file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* mode 0600, owned by root or the current user? */
if|if
condition|(
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0177
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|!
operator|(
name|st
operator|.
name|st_uid
operator|==
name|getuid
argument_list|()
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|"WARNING: PRNG seedfile %.100s must be mode 0600, "
literal|"owned by uid %li"
argument_list|,
name|filename
argument_list|,
operator|(
name|long
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|prng_write_seedfile
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|save_errno
decl_stmt|;
name|unsigned
name|char
name|seed
index|[
name|SEED_FILE_SIZE
index|]
decl_stmt|;
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|tmpseed
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|mode_t
name|old_umask
decl_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Couldn't get password entry for current user "
literal|"(%li): %s"
argument_list|,
operator|(
name|long
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to ensure that the parent directory is there */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%.512s/%s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|_PATH_SSH_USER_DIR
argument_list|)
expr_stmt|;
name|mkdir
argument_list|(
name|filename
argument_list|,
literal|0700
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%.512s/%s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|SSH_PRNG_SEED_FILE
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tmpseed
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpseed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcat
argument_list|(
name|tmpseed
argument_list|,
literal|".XXXXXXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpseed
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|tmpseed
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"PRNG seed filename too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"PRNG seed extraction failed"
argument_list|)
expr_stmt|;
comment|/* Don't care if the seed doesn't exist */
name|prng_check_seedfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|old_umask
operator|=
name|umask
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmpseed
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"WARNING: couldn't make temporary PRNG seedfile %.100s "
literal|"(%.100s)"
argument_list|,
name|tmpseed
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"writing PRNG seed to file %.100s"
argument_list|,
name|tmpseed
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|fd
argument_list|,
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpseed
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"problem writing PRNG seedfile %.100s "
literal|"(%.100s)"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"moving temporary PRNG seed to file %.100s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tmpseed
argument_list|,
name|filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|unlink
argument_list|(
name|tmpseed
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"problem renaming PRNG seedfile from %.100s "
literal|"to %.100s (%.100s)"
argument_list|,
name|tmpseed
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|umask
argument_list|(
name|old_umask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prng_read_seedfile
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
name|seed
index|[
name|SEED_FILE_SIZE
index|]
decl_stmt|,
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Couldn't get password entry for current user "
literal|"(%li): %s"
argument_list|,
operator|(
name|long
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%.512s/%s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|SSH_PRNG_SEED_FILE
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"loading PRNG seed from file %.100s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prng_check_seedfile
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
literal|"Random seed file not found or invalid, ignoring."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* open the file and read in the seed */
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"could not open PRNG seedfile %.100s (%.100s)"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomicio
argument_list|(
name|read
argument_list|,
name|fd
argument_list|,
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
literal|"invalid or short read from PRNG seedfile "
literal|"%.100s - ignoring"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seed
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* stir in the seed, with estimated entropy zero */
name|RAND_add
argument_list|(
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * entropy command initialisation functions  */
end_comment

begin_function
name|int
name|prng_read_commands
parameter_list|(
name|char
modifier|*
name|cmdfilename
parameter_list|)
block|{
name|char
name|cmd
index|[
name|SEED_FILE_SIZE
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
name|line
index|[
literal|1024
index|]
decl_stmt|,
name|path
index|[
name|SEED_FILE_SIZE
index|]
decl_stmt|;
name|double
name|est
decl_stmt|;
name|entropy_cmd_t
modifier|*
name|entcmd
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|cur_cmd
decl_stmt|,
name|linenum
decl_stmt|,
name|num_cmds
decl_stmt|,
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|cmdfilename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"couldn't read entropy commands file %.100s: %.100s"
argument_list|,
name|cmdfilename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|num_cmds
operator|=
literal|64
expr_stmt|;
name|entcmd
operator|=
name|xmalloc
argument_list|(
name|num_cmds
operator|*
sizeof|sizeof
argument_list|(
name|entropy_cmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|entcmd
argument_list|,
literal|'\0'
argument_list|,
name|num_cmds
operator|*
sizeof|sizeof
argument_list|(
name|entropy_cmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in file */
name|cur_cmd
operator|=
name|linenum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|linenum
operator|++
expr_stmt|;
comment|/* Skip leading whitespace, blank lines and comments */
name|cp
operator|=
name|line
operator|+
name|strspn
argument_list|(
name|line
argument_list|,
name|WHITESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'#'
operator|)
condition|)
continue|continue;
comment|/* done with this line */
comment|/* 		 * The first non-whitespace char should be a double quote 		 * delimiting the commandline 		 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'"'
condition|)
block|{
name|error
argument_list|(
literal|"bad entropy command, %.100s line %d"
argument_list|,
name|cmdfilename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * First token, command args (incl. argv[0]) in double 		 * quotes 		 */
name|cp
operator|=
name|strtok
argument_list|(
name|cp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"missing or bad command string, %.100s "
literal|"line %d -- ignored"
argument_list|,
name|cmdfilename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|strlcpy
argument_list|(
name|cmd
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Second token, full command path */
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|WHITESPACE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"missing command path, %.100s "
literal|"line %d -- ignored"
argument_list|,
name|cmdfilename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Did configure mark this as dead? */
if|if
condition|(
name|strncmp
argument_list|(
literal|"undef"
argument_list|,
name|cp
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|strlcpy
argument_list|(
name|path
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Third token, entropy rate estimate for this command */
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|WHITESPACE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"missing entropy estimate, %.100s "
literal|"line %d -- ignored"
argument_list|,
name|cmdfilename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|est
operator|=
name|strtod
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* end of line */
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|WHITESPACE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"garbage at end of line %d in %.100s "
literal|"-- ignored"
argument_list|,
name|linenum
argument_list|,
name|cmdfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* save the command for debug messages */
name|entcmd
index|[
name|cur_cmd
index|]
operator|.
name|cmdstring
operator|=
name|xstrdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* split the command args */
name|cp
operator|=
name|strtok
argument_list|(
name|cmd
argument_list|,
name|WHITESPACE
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|entcmd
index|[
name|cur_cmd
index|]
operator|.
name|args
index|[
name|arg
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|arg
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|arg
operator|<
name|NUM_ARGS
operator|&&
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|WHITESPACE
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|strtok
argument_list|(
name|NULL
argument_list|,
name|WHITESPACE
argument_list|)
condition|)
name|error
argument_list|(
literal|"ignored extra commands (max %d), %.100s "
literal|"line %d"
argument_list|,
name|NUM_ARGS
argument_list|,
name|cmdfilename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
comment|/* Copy the command path and rate estimate */
name|entcmd
index|[
name|cur_cmd
index|]
operator|.
name|path
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|entcmd
index|[
name|cur_cmd
index|]
operator|.
name|rate
operator|=
name|est
expr_stmt|;
comment|/* Initialise other values */
name|entcmd
index|[
name|cur_cmd
index|]
operator|.
name|sticky_badness
operator|=
literal|1
expr_stmt|;
name|cur_cmd
operator|++
expr_stmt|;
comment|/* 		 * If we've filled the array, reallocate it twice the size 		 * Do this now because even if this we're on the last 		 * command we need another slot to mark the last entry 		 */
if|if
condition|(
name|cur_cmd
operator|==
name|num_cmds
condition|)
block|{
name|num_cmds
operator|*=
literal|2
expr_stmt|;
name|entcmd
operator|=
name|xrealloc
argument_list|(
name|entcmd
argument_list|,
name|num_cmds
operator|*
sizeof|sizeof
argument_list|(
name|entropy_cmd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* zero the last entry */
name|memset
argument_list|(
operator|&
name|entcmd
index|[
name|cur_cmd
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy_cmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* trim to size */
name|entropy_cmds
operator|=
name|xrealloc
argument_list|(
name|entcmd
argument_list|,
operator|(
name|cur_cmd
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|entropy_cmd_t
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Loaded %d entropy commands from %.100s"
argument_list|,
name|cur_cmd
argument_list|,
name|cmdfilename
argument_list|)
expr_stmt|;
return|return
name|cur_cmd
operator|<
name|MIN_ENTROPY_SOURCES
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options]\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -v          Verbose; display verbose debugging messages.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"              Multiple -v increases verbosity.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -x          Force output in hexadecimal (for debugging)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -X          Force output in binary\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -b bytes    Number of bytes to output (default %d)\n"
argument_list|,
name|OUTPUT_SEED_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|ch
decl_stmt|,
name|debug_level
decl_stmt|,
name|output_hex
decl_stmt|,
name|bytes
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|LogLevel
name|ll
decl_stmt|;
name|__progname
operator|=
name|ssh_get_progname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|log_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|SYSLOG_LEVEL_INFO
argument_list|,
name|SYSLOG_FACILITY_USER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ll
operator|=
name|SYSLOG_LEVEL_INFO
expr_stmt|;
name|debug_level
operator|=
name|output_hex
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
name|OUTPUT_SEED_SIZE
expr_stmt|;
comment|/* Don't write binary data to a tty, unless we are forced to */
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|output_hex
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vxXhb:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'v'
case|:
if|if
condition|(
name|debug_level
operator|<
literal|3
condition|)
name|ll
operator|=
name|SYSLOG_LEVEL_DEBUG1
operator|+
name|debug_level
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|output_hex
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|output_hex
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|(
name|bytes
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid number of output bytes"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Invalid commandline option"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|log_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|ll
argument_list|,
name|SYSLOG_FACILITY_USER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SEED_FILES
name|prng_read_seedfile
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|buf
operator|=
name|xmalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
comment|/* 	 * Seed the RNG from wherever we can 	 */
comment|/* Take whatever is on the stack, but don't credit it */
name|RAND_add
argument_list|(
name|buf
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Seeded RNG with %i bytes from system calls"
argument_list|,
operator|(
name|int
operator|)
name|stir_from_system
argument_list|()
argument_list|)
expr_stmt|;
comment|/* try prngd, fall back to commands if prngd fails or not configured */
if|if
condition|(
name|seed_from_prngd
argument_list|(
name|buf
argument_list|,
name|bytes
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RAND_add
argument_list|(
name|buf
argument_list|,
name|bytes
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read in collection commands */
if|if
condition|(
name|prng_read_commands
argument_list|(
name|SSH_PRNG_COMMAND_FILE
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"PRNG initialisation failed -- exiting."
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Seeded RNG with %i bytes from programs"
argument_list|,
operator|(
name|int
operator|)
name|stir_from_programs
argument_list|()
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_SEED_FILES
name|prng_write_seedfile
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Write the seed to stdout 	 */
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"Not enough entropy in RNG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
name|buf
argument_list|,
name|bytes
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Couldn't extract entropy from PRNG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_hex
condition|)
block|{
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|ret
operator|<
name|bytes
condition|;
name|ret
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|buf
index|[
name|ret
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|atomicio
argument_list|(
name|vwrite
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
name|bytes
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * We may attempt to re-seed during mkstemp if we are using the one in the  * compat library (via mkstemp -> _gettemp -> arc4random -> seed_rng) so we  * need our own seed_rng().  We must also check that we have enough entropy.  */
end_comment

begin_function
name|void
name|seed_rng
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"Not enough entropy in RNG"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

