begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: audit.c,v 1.3 2005/07/17 07:26:44 djm Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004, 2005 Darren Tucker.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SSH_AUDIT_EVENTS
end_ifdef

begin_include
include|#
directive|include
file|"audit.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_comment
comment|/*  * Care must be taken when using this since it WILL NOT be initialized when  * audit_connection_from() is called and MAY NOT be initialized when  * audit_event(CONNECTION_ABANDON) is called.  Test for NULL before using.  */
end_comment

begin_decl_stmt
specifier|extern
name|Authctxt
modifier|*
name|the_authctxt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maybe add the audit class to struct Authmethod? */
end_comment

begin_function
name|ssh_audit_event_t
name|audit_classify_auth
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_AUTH_FAIL_NONE
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"password"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_AUTH_FAIL_PASSWD
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"publickey"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"rsa"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_AUTH_FAIL_PUBKEY
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|method
argument_list|,
literal|"keyboard-interactive"
argument_list|,
literal|20
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"challenge-response"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_AUTH_FAIL_KBDINT
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"hostbased"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"rhosts-rsa"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_AUTH_FAIL_HOSTBASED
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"gssapi-with-mic"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SSH_AUTH_FAIL_GSSAPI
return|;
else|else
return|return
name|SSH_AUDIT_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* helper to return supplied username */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|audit_username
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|unknownuser
index|[]
init|=
literal|"(unknown user)"
decl_stmt|;
specifier|static
specifier|const
name|char
name|invaliduser
index|[]
init|=
literal|"(invalid user)"
decl_stmt|;
if|if
condition|(
name|the_authctxt
operator|==
name|NULL
operator|||
name|the_authctxt
operator|->
name|user
operator|==
name|NULL
condition|)
return|return
operator|(
name|unknownuser
operator|)
return|;
if|if
condition|(
operator|!
name|the_authctxt
operator|->
name|valid
condition|)
return|return
operator|(
name|invaliduser
operator|)
return|;
return|return
operator|(
name|the_authctxt
operator|->
name|user
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|audit_event_lookup
parameter_list|(
name|ssh_audit_event_t
name|ev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
name|event_lookup_struct
block|{
name|ssh_audit_event_t
name|event
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|event_lookup
index|[]
init|=
block|{
block|{
name|SSH_LOGIN_EXCEED_MAXTRIES
block|,
literal|"LOGIN_EXCEED_MAXTRIES"
block|}
block|,
block|{
name|SSH_LOGIN_ROOT_DENIED
block|,
literal|"LOGIN_ROOT_DENIED"
block|}
block|,
block|{
name|SSH_AUTH_SUCCESS
block|,
literal|"AUTH_SUCCESS"
block|}
block|,
block|{
name|SSH_AUTH_FAIL_NONE
block|,
literal|"AUTH_FAIL_NONE"
block|}
block|,
block|{
name|SSH_AUTH_FAIL_PASSWD
block|,
literal|"AUTH_FAIL_PASSWD"
block|}
block|,
block|{
name|SSH_AUTH_FAIL_KBDINT
block|,
literal|"AUTH_FAIL_KBDINT"
block|}
block|,
block|{
name|SSH_AUTH_FAIL_PUBKEY
block|,
literal|"AUTH_FAIL_PUBKEY"
block|}
block|,
block|{
name|SSH_AUTH_FAIL_HOSTBASED
block|,
literal|"AUTH_FAIL_HOSTBASED"
block|}
block|,
block|{
name|SSH_AUTH_FAIL_GSSAPI
block|,
literal|"AUTH_FAIL_GSSAPI"
block|}
block|,
block|{
name|SSH_INVALID_USER
block|,
literal|"INVALID_USER"
block|}
block|,
block|{
name|SSH_NOLOGIN
block|,
literal|"NOLOGIN"
block|}
block|,
block|{
name|SSH_CONNECTION_CLOSE
block|,
literal|"CONNECTION_CLOSE"
block|}
block|,
block|{
name|SSH_CONNECTION_ABANDON
block|,
literal|"CONNECTION_ABANDON"
block|}
block|,
block|{
name|SSH_AUDIT_UNKNOWN
block|,
literal|"AUDIT_UNKNOWN"
block|}
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|event_lookup
index|[
name|i
index|]
operator|.
name|event
operator|!=
name|SSH_AUDIT_UNKNOWN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|event_lookup
index|[
name|i
index|]
operator|.
name|event
operator|==
name|ev
condition|)
break|break;
return|return
operator|(
name|event_lookup
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CUSTOM_SSH_AUDIT_EVENTS
end_ifndef

begin_comment
comment|/*  * Null implementations of audit functions.  * These get used if SSH_AUDIT_EVENTS is defined but no audit module is enabled.  */
end_comment

begin_comment
comment|/*  * Called after a connection has been accepted but before any authentication  * has been attempted.  */
end_comment

begin_function
name|void
name|audit_connection_from
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|debug
argument_list|(
literal|"audit connection from %s port %d euid %d"
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when various events occur (see audit.h for a list of possible  * events and what they mean).  */
end_comment

begin_function
name|void
name|audit_event
parameter_list|(
name|ssh_audit_event_t
name|event
parameter_list|)
block|{
name|debug
argument_list|(
literal|"audit event euid %d user %s event %d (%s)"
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|audit_username
argument_list|()
argument_list|,
name|event
argument_list|,
name|audit_event_lookup
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a user session is started.  Argument is the tty allocated to  * the session, or NULL if no tty was allocated.  *  * Note that this may be called multiple times if multiple sessions are used  * within a single connection.  */
end_comment

begin_function
name|void
name|audit_session_open
parameter_list|(
specifier|const
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|ttyn
condition|?
name|ttyn
else|:
literal|"(no tty)"
decl_stmt|;
name|debug
argument_list|(
literal|"audit session open euid %d user %s tty name %s"
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|audit_username
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a user session is closed.  Argument is the tty allocated to  * the session, or NULL if no tty was allocated.  *  * Note that this may be called multiple times if multiple sessions are used  * within a single connection.  */
end_comment

begin_function
name|void
name|audit_session_close
parameter_list|(
specifier|const
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|ttyn
condition|?
name|ttyn
else|:
literal|"(no tty)"
decl_stmt|;
name|debug
argument_list|(
literal|"audit session close euid %d user %s tty name %s"
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|audit_username
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This will be called when a user runs a non-interactive command.  Note that  * it may be called multiple times for a single connection since SSH2 allows  * multiple sessions within a single connection.  */
end_comment

begin_function
name|void
name|audit_run_command
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|)
block|{
name|debug
argument_list|(
literal|"audit run command euid %d user %s command '%.200s'"
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|audit_username
argument_list|()
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined CUSTOM_SSH_AUDIT_EVENTS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SSH_AUDIT_EVENTS */
end_comment

end_unit

