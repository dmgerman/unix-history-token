begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: jpake.c,v 1.2 2009/03/05 07:18:19 djm Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 Damien Miller.  All rights reserved.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Shared components of zero-knowledge password auth using J-PAKE protocol  * as described in:  *  * F. Hao, P. Ryan, "Password Authenticated Key Exchange by Juggling",  * 16th Workshop on Security Protocols, Cambridge, April 2008  *  * http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"jpake.h"
end_include

begin_include
include|#
directive|include
file|"schnorr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JPAKE
end_ifdef

begin_comment
comment|/* RFC3526 group 5, 1536 bits */
end_comment

begin_define
define|#
directive|define
name|JPAKE_GROUP_G
value|"2"
end_define

begin_define
define|#
directive|define
name|JPAKE_GROUP_P
define|\
value|"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74" \ 	"020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437" \ 	"4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED" \ 	"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF05" \ 	"98DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB" \ 	"9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF"
end_define

begin_function
name|struct
name|modp_group
modifier|*
name|jpake_default_group
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|modp_group_from_g_and_safe_p
argument_list|(
name|JPAKE_GROUP_G
argument_list|,
name|JPAKE_GROUP_P
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|jpake_ctx
modifier|*
name|jpake_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|jpake_ctx
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|grp
operator|=
name|jpake_default_group
argument_list|()
expr_stmt|;
name|ret
operator|->
name|s
operator|=
name|ret
operator|->
name|k
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|x1
operator|=
name|ret
operator|->
name|x2
operator|=
name|ret
operator|->
name|x3
operator|=
name|ret
operator|->
name|x4
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|g_x1
operator|=
name|ret
operator|->
name|g_x2
operator|=
name|ret
operator|->
name|g_x3
operator|=
name|ret
operator|->
name|g_x4
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|a
operator|=
name|ret
operator|->
name|b
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|client_id
operator|=
name|ret
operator|->
name|server_id
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|h_k_cid_sessid
operator|=
name|ret
operator|->
name|h_k_sid_sessid
operator|=
name|NULL
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: alloc %p"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|jpake_free
parameter_list|(
name|struct
name|jpake_ctx
modifier|*
name|pctx
parameter_list|)
block|{
name|debug3
argument_list|(
literal|"%s: free %p"
argument_list|,
name|__func__
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
define|#
directive|define
name|JPAKE_BN_CLEAR_FREE
parameter_list|(
name|v
parameter_list|)
define|\
value|do {					\ 		if ((v) != NULL) {		\ 			BN_clear_free(v);	\ 			(v) = NULL;		\ 		}				\ 	} while (0)
define|#
directive|define
name|JPAKE_BUF_CLEAR_FREE
parameter_list|(
name|v
parameter_list|,
name|l
parameter_list|)
define|\
value|do {					\ 		if ((v) != NULL) {		\ 			bzero((v), (l));	\ 			xfree(v);		\ 			(v) = NULL;		\ 			(l) = 0;		\ 		}				\ 	} while (0)
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|s
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|k
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|x1
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|x2
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|x3
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|x4
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|g_x1
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|g_x2
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|g_x3
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|g_x4
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|a
argument_list|)
expr_stmt|;
name|JPAKE_BN_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|b
argument_list|)
expr_stmt|;
name|JPAKE_BUF_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|client_id
argument_list|,
name|pctx
operator|->
name|client_id_len
argument_list|)
expr_stmt|;
name|JPAKE_BUF_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|server_id
argument_list|,
name|pctx
operator|->
name|server_id_len
argument_list|)
expr_stmt|;
name|JPAKE_BUF_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|h_k_cid_sessid
argument_list|,
name|pctx
operator|->
name|h_k_cid_sessid_len
argument_list|)
expr_stmt|;
name|JPAKE_BUF_CLEAR_FREE
argument_list|(
name|pctx
operator|->
name|h_k_sid_sessid
argument_list|,
name|pctx
operator|->
name|h_k_sid_sessid_len
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|JPAKE_BN_CLEAR_FREE
undef|#
directive|undef
name|JPAKE_BUF_CLEAR_FREE
name|bzero
argument_list|(
name|pctx
argument_list|,
sizeof|sizeof
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dump entire jpake_ctx. NB. includes private values! */
end_comment

begin_function
name|void
name|jpake_dump
parameter_list|(
name|struct
name|jpake_ctx
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|out
operator|=
name|NULL
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|out
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: vasprintf failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: %s (ctx at %p)"
argument_list|,
name|__func__
argument_list|,
name|out
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|JPAKE_DUMP_BN
parameter_list|(
name|a
parameter_list|)
value|do { \ 		if ((a) != NULL) \ 			JPAKE_DEBUG_BN(((a), "%s = ", #a)); \ 	} while (0)
define|#
directive|define
name|JPAKE_DUMP_BUF
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 		if ((a) != NULL) \ 			JPAKE_DEBUG_BUF((a, b, "%s", #a)); \ 	} while (0)
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|s
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|k
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|x1
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|x2
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|x3
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|x4
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|g_x1
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|g_x2
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|g_x3
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|g_x4
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|a
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BN
argument_list|(
name|pctx
operator|->
name|b
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BUF
argument_list|(
name|pctx
operator|->
name|client_id
argument_list|,
name|pctx
operator|->
name|client_id_len
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BUF
argument_list|(
name|pctx
operator|->
name|server_id
argument_list|,
name|pctx
operator|->
name|server_id_len
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BUF
argument_list|(
name|pctx
operator|->
name|h_k_cid_sessid
argument_list|,
name|pctx
operator|->
name|h_k_cid_sessid_len
argument_list|)
expr_stmt|;
name|JPAKE_DUMP_BUF
argument_list|(
name|pctx
operator|->
name|h_k_sid_sessid
argument_list|,
name|pctx
operator|->
name|h_k_sid_sessid_len
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: %s done"
argument_list|,
name|__func__
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shared parts of step 1 exchange calculation */
end_comment

begin_function
name|void
name|jpake_step1
parameter_list|(
name|struct
name|modp_group
modifier|*
name|grp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|id
parameter_list|,
name|u_int
modifier|*
name|id_len
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|priv1
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|priv2
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|g_priv1
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|g_priv2
parameter_list|,
name|u_char
modifier|*
modifier|*
name|priv1_proof
parameter_list|,
name|u_int
modifier|*
name|priv1_proof_len
parameter_list|,
name|u_char
modifier|*
modifier|*
name|priv2_proof
parameter_list|,
name|u_int
modifier|*
name|priv2_proof_len
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Random nonce to prevent replay */
operator|*
name|id
operator|=
name|xmalloc
argument_list|(
name|KZP_ID_LEN
argument_list|)
expr_stmt|;
operator|*
name|id_len
operator|=
name|KZP_ID_LEN
expr_stmt|;
name|arc4random_buf
argument_list|(
operator|*
name|id
argument_list|,
operator|*
name|id_len
argument_list|)
expr_stmt|;
comment|/* 	 * x1/x3 is a random element of Zq 	 * x2/x4 is a random element of Z*q 	 * We also exclude [1] from x1/x3 candidates and [0, 1] from 	 * x2/x4 candiates to avoid possible degeneracy (i.e. g^0, g^1). 	 */
if|if
condition|(
operator|(
operator|*
name|priv1
operator|=
name|bn_rand_range_gt_one
argument_list|(
name|grp
operator|->
name|q
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|priv2
operator|=
name|bn_rand_range_gt_one
argument_list|(
name|grp
operator|->
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: bn_rand_range_gt_one"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * client: g_x1 = g^x1 mod p / server: g_x3 = g^x3 mod p 	 * client: g_x2 = g^x2 mod p / server: g_x4 = g^x4 mod p 	 */
if|if
condition|(
operator|(
operator|*
name|g_priv1
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|g_priv2
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_exp
argument_list|(
operator|*
name|g_priv1
argument_list|,
name|grp
operator|->
name|g
argument_list|,
operator|*
name|priv1
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_exp"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_exp
argument_list|(
operator|*
name|g_priv2
argument_list|,
name|grp
operator|->
name|g
argument_list|,
operator|*
name|priv2
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_exp"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Generate proofs for holding x1/x3 and x2/x4 */
if|if
condition|(
name|schnorr_sign_buf
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
operator|*
name|priv1
argument_list|,
operator|*
name|g_priv1
argument_list|,
operator|*
name|id
argument_list|,
operator|*
name|id_len
argument_list|,
name|priv1_proof
argument_list|,
name|priv1_proof_len
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_sign"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_sign_buf
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
operator|*
name|priv2
argument_list|,
operator|*
name|g_priv2
argument_list|,
operator|*
name|id
argument_list|,
operator|*
name|id_len
argument_list|,
name|priv2_proof
argument_list|,
name|priv2_proof_len
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_sign"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shared parts of step 2 exchange calculation */
end_comment

begin_function
name|void
name|jpake_step2
parameter_list|(
name|struct
name|modp_group
modifier|*
name|grp
parameter_list|,
name|BIGNUM
modifier|*
name|s
parameter_list|,
name|BIGNUM
modifier|*
name|mypub1
parameter_list|,
name|BIGNUM
modifier|*
name|theirpub1
parameter_list|,
name|BIGNUM
modifier|*
name|theirpub2
parameter_list|,
name|BIGNUM
modifier|*
name|mypriv2
parameter_list|,
specifier|const
name|u_char
modifier|*
name|theirid
parameter_list|,
name|u_int
name|theirid_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|myid
parameter_list|,
name|u_int
name|myid_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|theirpub1_proof
parameter_list|,
name|u_int
name|theirpub1_proof_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|theirpub2_proof
parameter_list|,
name|u_int
name|theirpub2_proof_len
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|newpub
parameter_list|,
name|u_char
modifier|*
modifier|*
name|newpub_exponent_proof
parameter_list|,
name|u_int
modifier|*
name|newpub_exponent_proof_len
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|exponent
decl_stmt|;
comment|/* Validate peer's step 1 values */
if|if
condition|(
name|BN_cmp
argument_list|(
name|theirpub1
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: theirpub1<= 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|theirpub2
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: theirpub2<= 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify_buf
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|theirpub1
argument_list|,
name|theirid
argument_list|,
name|theirid_len
argument_list|,
name|theirpub1_proof
argument_list|,
name|theirpub1_proof_len
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_verify theirpub1 failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify_buf
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|theirpub2
argument_list|,
name|theirid
argument_list|,
name|theirid_len
argument_list|,
name|theirpub2_proof
argument_list|,
name|theirpub2_proof_len
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_verify theirpub2 failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|newpub
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tmp
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|exponent
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * client: exponent = x2 * s mod p 	 * server: exponent = x4 * s mod p 	 */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|exponent
argument_list|,
name|mypriv2
argument_list|,
name|s
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (exponent = mypriv2 * s mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * client: tmp = g^(x1 + x3 + x4) mod p 	 * server: tmp = g^(x1 + x2 + x3) mod p 	 */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|mypub1
argument_list|,
name|theirpub1
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (tmp = mypub1 * theirpub1 mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|theirpub2
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (tmp = tmp * theirpub2 mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * client: a = tmp^exponent = g^((x1+x3+x4) * x2 * s) mod p 	 * server: b = tmp^exponent = g^((x1+x2+x3) * x4 * s) mod p 	 */
if|if
condition|(
name|BN_mod_exp
argument_list|(
operator|*
name|newpub
argument_list|,
name|tmp
argument_list|,
name|exponent
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (newpub = tmp^exponent mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|JPAKE_DEBUG_BN
argument_list|(
operator|(
name|tmp
operator|,
literal|"%s: tmp = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|JPAKE_DEBUG_BN
argument_list|(
operator|(
name|exponent
operator|,
literal|"%s: exponent = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Note the generator here is 'tmp', not g */
if|if
condition|(
name|schnorr_sign_buf
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|tmp
argument_list|,
name|exponent
argument_list|,
operator|*
name|newpub
argument_list|,
name|myid
argument_list|,
name|myid_len
argument_list|,
name|newpub_exponent_proof
argument_list|,
name|newpub_exponent_proof_len
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_sign newpub"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* XXX stash for later use? */
name|BN_clear_free
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
comment|/* XXX stash for later use? (yes, in conf) */
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Confirmation hash calculation */
end_comment

begin_function
name|void
name|jpake_confirm_hash
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|k
parameter_list|,
specifier|const
name|u_char
modifier|*
name|endpoint_id
parameter_list|,
name|u_int
name|endpoint_id_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sess_id
parameter_list|,
name|u_int
name|sess_id_len
parameter_list|,
name|u_char
modifier|*
modifier|*
name|confirm_hash
parameter_list|,
name|u_int
modifier|*
name|confirm_hash_len
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
comment|/* 	 * Calculate confirmation proof: 	 *     client: H(k || client_id || session_id) 	 *     server: H(k || server_id || session_id) 	 */
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|endpoint_id
argument_list|,
name|endpoint_id_len
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|sess_id
argument_list|,
name|sess_id_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_buffer
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|,
name|confirm_hash
argument_list|,
name|confirm_hash_len
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: hash_buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shared parts of key derivation and confirmation calculation */
end_comment

begin_function
name|void
name|jpake_key_confirm
parameter_list|(
name|struct
name|modp_group
modifier|*
name|grp
parameter_list|,
name|BIGNUM
modifier|*
name|s
parameter_list|,
name|BIGNUM
modifier|*
name|step2_val
parameter_list|,
name|BIGNUM
modifier|*
name|mypriv2
parameter_list|,
name|BIGNUM
modifier|*
name|mypub1
parameter_list|,
name|BIGNUM
modifier|*
name|mypub2
parameter_list|,
name|BIGNUM
modifier|*
name|theirpub1
parameter_list|,
name|BIGNUM
modifier|*
name|theirpub2
parameter_list|,
specifier|const
name|u_char
modifier|*
name|my_id
parameter_list|,
name|u_int
name|my_id_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|their_id
parameter_list|,
name|u_int
name|their_id_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sess_id
parameter_list|,
name|u_int
name|sess_id_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|theirpriv2_s_proof
parameter_list|,
name|u_int
name|theirpriv2_s_proof_len
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|k
parameter_list|,
name|u_char
modifier|*
modifier|*
name|confirm_hash
parameter_list|,
name|u_int
modifier|*
name|confirm_hash_len
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
name|BIGNUM
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|k
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Validate step 2 values */
if|if
condition|(
name|BN_cmp
argument_list|(
name|step2_val
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: step2_val<= 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * theirpriv2_s_proof is calculated with a different generator: 	 * tmp = g^(mypriv1+mypriv2+theirpub1) = g^mypub1*g^mypub2*g^theirpub1 	 * Calculate it here so we can check the signature. 	 */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|mypub1
argument_list|,
name|mypub2
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (tmp = mypub1 * mypub2 mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|theirpub1
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (tmp = tmp * theirpub1 mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|JPAKE_DEBUG_BN
argument_list|(
operator|(
name|tmp
operator|,
literal|"%s: tmp = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify_buf
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|tmp
argument_list|,
name|step2_val
argument_list|,
name|their_id
argument_list|,
name|their_id_len
argument_list|,
name|theirpriv2_s_proof
argument_list|,
name|theirpriv2_s_proof_len
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_verify theirpriv2_s_proof failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Derive shared key: 	 *     client: k = (b / g^(x2*x4*s))^x2 = g^((x1+x3)*x2*x4*s) 	 *     server: k = (a / g^(x2*x4*s))^x4 = g^((x1+x3)*x2*x4*s) 	 * 	 * Computed as: 	 *     client: k = (g_x4^(q - (x2 * s)) * b)^x2 mod p 	 *     server: k = (g_x2^(q - (x4 * s)) * b)^x4 mod p 	 */
if|if
condition|(
name|BN_mul
argument_list|(
name|tmp
argument_list|,
name|mypriv2
argument_list|,
name|s
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mul (tmp = mypriv2 * s)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_sub
argument_list|(
name|tmp
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|tmp
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_sub (tmp = q - tmp mod q)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|tmp
argument_list|,
name|theirpub2
argument_list|,
name|tmp
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_exp (tmp = theirpub2^tmp) mod p"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|step2_val
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_mul (tmp = tmp * step2_val) mod p"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_exp
argument_list|(
operator|*
name|k
argument_list|,
name|tmp
argument_list|,
name|mypriv2
argument_list|,
name|grp
operator|->
name|p
argument_list|,
name|bn_ctx
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_mod_exp (k = tmp^mypriv2) mod p"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|jpake_confirm_hash
argument_list|(
operator|*
name|k
argument_list|,
name|my_id
argument_list|,
name|my_id_len
argument_list|,
name|sess_id
argument_list|,
name|sess_id_len
argument_list|,
name|confirm_hash
argument_list|,
name|confirm_hash_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate and check confirmation hash from peer. Returns 1 on success  * 0 on failure/mismatch.  */
end_comment

begin_function
name|int
name|jpake_check_confirm
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|k
parameter_list|,
specifier|const
name|u_char
modifier|*
name|peer_id
parameter_list|,
name|u_int
name|peer_id_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sess_id
parameter_list|,
name|u_int
name|sess_id_len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|peer_confirm_hash
parameter_list|,
name|u_int
name|peer_confirm_hash_len
parameter_list|)
block|{
name|u_char
modifier|*
name|expected_confirm_hash
decl_stmt|;
name|u_int
name|expected_confirm_hash_len
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
comment|/* Calculate and verify expected confirmation hash */
name|jpake_confirm_hash
argument_list|(
name|k
argument_list|,
name|peer_id
argument_list|,
name|peer_id_len
argument_list|,
name|sess_id
argument_list|,
name|sess_id_len
argument_list|,
operator|&
name|expected_confirm_hash
argument_list|,
operator|&
name|expected_confirm_hash_len
argument_list|)
expr_stmt|;
name|JPAKE_DEBUG_BUF
argument_list|(
operator|(
name|expected_confirm_hash
operator|,
name|expected_confirm_hash_len
operator|,
literal|"%s: expected confirm hash"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|JPAKE_DEBUG_BUF
argument_list|(
operator|(
name|peer_confirm_hash
operator|,
name|peer_confirm_hash_len
operator|,
literal|"%s: received confirm hash"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_confirm_hash_len
operator|!=
name|expected_confirm_hash_len
condition|)
name|error
argument_list|(
literal|"%s: confirmation length mismatch (my %u them %u)"
argument_list|,
name|__func__
argument_list|,
name|expected_confirm_hash_len
argument_list|,
name|peer_confirm_hash_len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|peer_confirm_hash
argument_list|,
name|expected_confirm_hash
argument_list|,
name|expected_confirm_hash_len
argument_list|)
operator|==
literal|0
condition|)
name|success
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|expected_confirm_hash
argument_list|,
name|expected_confirm_hash_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|expected_confirm_hash
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: success = %d"
argument_list|,
name|__func__
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* XXX main() function with tests */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JPAKE */
end_comment

end_unit

