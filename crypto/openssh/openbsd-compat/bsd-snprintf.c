begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Patrick Powell 1995  * This code is based on code written by Patrick Powell (papowell@astart.com)  * It may be used for any purpose as long as this notice remains intact  * on all source code distributions  */
end_comment

begin_comment
comment|/**************************************************************  * Original:  * Patrick Powell Tue Apr 11 09:48:21 PDT 1995  * A bombproof version of doprnt (dopr) included.  * Sigh.  This sort of thing is always nasty do deal with.  Note that  * the version here does not include floating point...  *  * snprintf() is used instead of sprintf() as it does limit checks  * for string length.  This covers a nasty loophole.  *  * The other functions are there to prevent NULL pointers from  * causing nast effects.  *  * More Recently:  *  Brandon Long<blong@fiction.net> 9/15/96 for mutt 0.43  *  This was ugly.  It is still ugly.  I opted out of floating point  *  numbers, but the formatter understands just about everything  *  from the normal C string format, at least as far as I can tell from  *  the Solaris 2.5 printf(3S) man page.  *  *  Brandon Long<blong@fiction.net> 10/22/97 for mutt 0.87.1  *    Ok, added some minimal floating point support, which means this  *    probably requires libm on most operating systems.  Don't yet  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()  *    was pretty badly broken, it just wasn't being exercised in ways  *    which showed it, so that's been fixed.  Also, formated the code  *    to mutt conventions, and removed dead code left over from the  *    original.  Also, there is now a builtin-test, just compile with:  *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm  *    and run snprintf for results.  *   *  Thomas Roessler<roessler@guug.de> 01/27/98 for mutt 0.89i  *    The PGP code was using unsigned hexadecimal formats.   *    Unfortunately, unsigned formats simply didn't work.  *  *  Michael Elkins<me@cs.hmc.edu> 03/05/98 for mutt 0.90.8  *    The original code assumed that both snprintf() and vsnprintf() were  *    missing.  Some systems only have snprintf() but not vsnprintf(), so  *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.  *  *  Ben Lindstrom<mouring@eviladmin.org> 09/27/00 for OpenSSH  *    Welcome to the world of %lld and %qd support.  With other  *    long long support.  This is needed for sftp-server to work  *    right.  *  *  Ben Lindstrom<mouring@eviladmin.org> 02/12/01 for OpenSSH  *    Removed all hint of VARARGS stuff and banished it to the void,  *    and did a bit of KNF style work to make things a bit more  *    acceptable.  Consider stealing from mutt or enlightenment.  **************************************************************/
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: bsd-snprintf.c,v 1.9 2004/09/23 11:35:09 dtucker Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BROKEN_SNPRINTF
argument_list|)
end_if

begin_comment
comment|/* For those with broken snprintf() */
end_comment

begin_undef
undef|#
directive|undef
name|HAVE_SNPRINTF
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_VSNPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SNPRINTF
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_VSNPRINTF
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|double
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopr_outch
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * dopr(): poor man's version of doprintf  */
end_comment

begin_comment
comment|/* format read states */
end_comment

begin_define
define|#
directive|define
name|DP_S_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|DP_S_FLAGS
value|1
end_define

begin_define
define|#
directive|define
name|DP_S_MIN
value|2
end_define

begin_define
define|#
directive|define
name|DP_S_DOT
value|3
end_define

begin_define
define|#
directive|define
name|DP_S_MAX
value|4
end_define

begin_define
define|#
directive|define
name|DP_S_MOD
value|5
end_define

begin_define
define|#
directive|define
name|DP_S_CONV
value|6
end_define

begin_define
define|#
directive|define
name|DP_S_DONE
value|7
end_define

begin_comment
comment|/* format flags - Bits */
end_comment

begin_define
define|#
directive|define
name|DP_F_MINUS
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DP_F_PLUS
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DP_F_SPACE
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|DP_F_NUM
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|DP_F_ZERO
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|DP_F_UP
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|DP_F_UNSIGNED
value|(1<< 6)
end_define

begin_comment
comment|/* Conversion Flags */
end_comment

begin_define
define|#
directive|define
name|DP_C_SHORT
value|1
end_define

begin_define
define|#
directive|define
name|DP_C_LONG
value|2
end_define

begin_define
define|#
directive|define
name|DP_C_LDOUBLE
value|3
end_define

begin_define
define|#
directive|define
name|DP_C_LONG_LONG
value|4
end_define

begin_define
define|#
directive|define
name|char_to_int
parameter_list|(
name|p
parameter_list|)
value|(p - '0')
end_define

begin_define
define|#
directive|define
name|abs_val
parameter_list|(
name|p
parameter_list|)
value|(p< 0 ? -p : p)
end_define

begin_function
specifier|static
name|void
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
modifier|*
name|strvalue
decl_stmt|,
name|ch
decl_stmt|;
name|long
name|value
decl_stmt|;
name|long
name|double
name|fvalue
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|,
name|max
init|=
operator|-
literal|1
decl_stmt|,
name|state
init|=
name|DP_S_DEFAULT
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|,
name|cflags
init|=
literal|0
decl_stmt|;
name|size_t
name|currlen
init|=
literal|0
decl_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|DP_S_DONE
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|currlen
operator|>=
name|maxlen
operator|)
condition|)
name|state
operator|=
name|DP_S_DONE
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DP_S_DEFAULT
case|:
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
name|state
operator|=
name|DP_S_FLAGS
expr_stmt|;
else|else
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
name|DP_S_FLAGS
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|flags
operator||=
name|DP_F_MINUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|flags
operator||=
name|DP_F_PLUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flags
operator||=
name|DP_F_SPACE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|flags
operator||=
name|DP_F_NUM
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|flags
operator||=
name|DP_F_ZERO
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|DP_S_MIN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DP_S_MIN
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
name|min
operator|=
literal|10
operator|*
name|min
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|min
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
break|break;
case|case
name|DP_S_DOT
case|:
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|state
operator|=
name|DP_S_MAX
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
break|break;
case|case
name|DP_S_MAX
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|10
operator|*
name|max
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|max
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
break|break;
case|case
name|DP_S_MOD
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|cflags
operator|=
name|DP_C_SHORT
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|cflags
operator|=
name|DP_C_LONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
block|{
name|cflags
operator|=
name|DP_C_LONG_LONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|cflags
operator|=
name|DP_C_LONG_LONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cflags
operator|=
name|DP_C_LDOUBLE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|state
operator|=
name|DP_S_CONV
expr_stmt|;
break|break;
case|case
name|DP_S_CONV
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long long
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long long
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|8
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long long
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'x'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long long
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/* um, floating point? */
name|fmtfp
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'e'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'g'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
name|maxlen
expr_stmt|;
comment|/* ie, no max */
name|fmtstr
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|strvalue
argument_list|,
name|flags
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|(
name|long
operator|)
name|strvalue
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
block|{
name|short
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|short int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
block|{
name|long
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG_LONG
condition|)
block|{
name|long
name|long
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long long *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
else|else
block|{
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* not supported yet, treat as next char */
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Unknown, skip */
break|break;
block|}
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|flags
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|DP_S_DONE
case|:
break|break;
default|default:
comment|/* hmm? */
break|break;
comment|/* some picky compilers need this */
block|}
block|}
if|if
condition|(
name|currlen
operator|<
name|maxlen
operator|-
literal|1
condition|)
name|buffer
index|[
name|currlen
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|buffer
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|padlen
decl_stmt|,
name|strln
decl_stmt|;
comment|/* amount to pad */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
literal|"<NULL>"
expr_stmt|;
for|for
control|(
name|strln
operator|=
literal|0
init|;
name|strln
operator|<
name|max
operator|&&
name|value
index|[
name|strln
index|]
condition|;
operator|++
name|strln
control|)
empty_stmt|;
comment|/* strlen */
name|padlen
operator|=
name|min
operator|-
name|strln
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justify */
while|while
condition|(
operator|(
name|padlen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|*
name|value
operator|++
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|padlen
operator|<
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
end_comment

begin_function
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|long
name|uvalue
decl_stmt|;
name|char
name|convert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|signvalue
init|=
literal|0
decl_stmt|,
name|place
init|=
literal|0
decl_stmt|,
name|caps
init|=
literal|0
decl_stmt|;
name|int
name|spadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to space pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to zero pad */
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|uvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DP_F_UNSIGNED
operator|)
condition|)
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|signvalue
operator|=
literal|'-'
expr_stmt|;
name|uvalue
operator|=
operator|-
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_UP
condition|)
name|caps
operator|=
literal|1
expr_stmt|;
comment|/* Should characters be upper case? */
do|do
block|{
name|convert
index|[
name|place
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|uvalue
operator|%
operator|(
name|unsigned
operator|)
name|base
index|]
expr_stmt|;
name|uvalue
operator|=
operator|(
name|uvalue
operator|/
operator|(
name|unsigned
operator|)
name|base
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|uvalue
operator|&&
operator|(
name|place
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|place
operator|==
literal|20
condition|)
name|place
operator|--
expr_stmt|;
name|convert
index|[
name|place
index|]
operator|=
literal|0
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|place
expr_stmt|;
name|spadlen
operator|=
name|min
operator|-
name|MAX
argument_list|(
name|max
argument_list|,
name|place
argument_list|)
operator|-
operator|(
name|signvalue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spadlen
operator|<
literal|0
condition|)
name|spadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_ZERO
condition|)
block|{
name|zpadlen
operator|=
name|MAX
argument_list|(
name|zpadlen
argument_list|,
name|spadlen
argument_list|)
expr_stmt|;
name|spadlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|spadlen
operator|=
operator|-
name|spadlen
expr_stmt|;
comment|/* Left Justifty */
comment|/* Spaces */
while|while
condition|(
name|spadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|spadlen
expr_stmt|;
block|}
comment|/* Sign */
if|if
condition|(
name|signvalue
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
comment|/* Zeros */
if|if
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
block|}
comment|/* Digits */
while|while
condition|(
name|place
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|convert
index|[
operator|--
name|place
index|]
argument_list|)
expr_stmt|;
comment|/* Left Justified spaces */
while|while
condition|(
name|spadlen
operator|<
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|spadlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|pow10
parameter_list|(
name|int
name|exp
parameter_list|)
block|{
name|long
name|double
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|exp
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|round
parameter_list|(
name|long
name|double
name|value
parameter_list|)
block|{
name|long
name|intpart
init|=
name|value
decl_stmt|;
name|value
operator|-=
name|intpart
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.5
condition|)
name|intpart
operator|++
expr_stmt|;
return|return
name|intpart
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|long
name|double
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
name|iconvert
index|[
literal|20
index|]
decl_stmt|,
name|fconvert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|signvalue
init|=
literal|0
decl_stmt|,
name|iplace
init|=
literal|0
decl_stmt|,
name|fplace
init|=
literal|0
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
comment|/* amount to pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|,
name|caps
init|=
literal|0
decl_stmt|;
name|long
name|intpart
decl_stmt|,
name|fracpart
decl_stmt|;
name|long
name|double
name|ufvalue
decl_stmt|;
comment|/*  	 * AIX manpage says the default is 0, but Solaris says the default 	 * is 6, and sprintf on AIX defaults to 6 	 */
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|6
expr_stmt|;
name|ufvalue
operator|=
name|abs_val
argument_list|(
name|fvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvalue
operator|<
literal|0
condition|)
name|signvalue
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
name|intpart
operator|=
name|ufvalue
expr_stmt|;
comment|/*  	 * Sorry, we only support 9 digits past the decimal because of our  	 * conversion method 	 */
if|if
condition|(
name|max
operator|>
literal|9
condition|)
name|max
operator|=
literal|9
expr_stmt|;
comment|/* We "cheat" by converting the fractional part to integer by 	 * multiplying by a factor of 10 	 */
name|fracpart
operator|=
name|round
argument_list|(
operator|(
name|pow10
argument_list|(
name|max
argument_list|)
operator|)
operator|*
operator|(
name|ufvalue
operator|-
name|intpart
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracpart
operator|>=
name|pow10
argument_list|(
name|max
argument_list|)
condition|)
block|{
name|intpart
operator|++
expr_stmt|;
name|fracpart
operator|-=
name|pow10
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
comment|/* Convert integer part */
do|do
block|{
name|iconvert
index|[
name|iplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|intpart
operator|%
literal|10
index|]
expr_stmt|;
name|intpart
operator|=
operator|(
name|intpart
operator|/
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|intpart
operator|&&
operator|(
name|iplace
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|iplace
operator|==
literal|20
condition|)
name|iplace
operator|--
expr_stmt|;
name|iconvert
index|[
name|iplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Convert fractional part */
do|do
block|{
name|fconvert
index|[
name|fplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|fracpart
operator|%
literal|10
index|]
expr_stmt|;
name|fracpart
operator|=
operator|(
name|fracpart
operator|/
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|fracpart
operator|&&
operator|(
name|fplace
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|fplace
operator|==
literal|20
condition|)
name|fplace
operator|--
expr_stmt|;
name|fconvert
index|[
name|fplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* -1 for decimal point, another -1 if we are printing a sign */
name|padlen
operator|=
name|min
operator|-
name|iplace
operator|-
name|max
operator|-
literal|1
operator|-
operator|(
operator|(
name|signvalue
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|fplace
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justifty */
if|if
condition|(
operator|(
name|flags
operator|&
name|DP_F_ZERO
operator|)
operator|&&
operator|(
name|padlen
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|signvalue
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
name|signvalue
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
if|if
condition|(
name|signvalue
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
while|while
condition|(
name|iplace
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|iconvert
index|[
operator|--
name|iplace
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Decimal point.  This should probably use locale to find the  	 * correct char to print out. 	 */
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|fplace
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fconvert
index|[
operator|--
name|fplace
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dopr_outch
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|*
name|currlen
operator|<
name|maxlen
condition|)
name|buffer
index|[
operator|(
operator|*
name|currlen
operator|)
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_SNPRINTF) || !defined(HAVE_VSNPRINTF) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_VSNPRINTF
end_ifndef

begin_function
name|int
name|vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dopr
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VSNPRINTF */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SNPRINTF
end_ifndef

begin_function
name|int
name|snprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SNPRINTF */
end_comment

end_unit

