begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: getrrsetbyname.c,v 1.10 2005/03/30 02:58:28 tedu Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Jakob Schlyter. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1999-2001 Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL  * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* OPENBSD ORIGINAL: lib/libc/net/getrrsetbyname.c */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETRRSETBYNAME
end_ifndef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"getrrsetbyname.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DECL_H_ERRNO
argument_list|)
operator|&&
operator|!
name|HAVE_DECL_H_ERRNO
end_if

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We don't need multithread support here */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_THREAD_PRIVATE
end_ifdef

begin_undef
undef|#
directive|undef
name|_THREAD_PRIVATE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_THREAD_PRIVATE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(c)
end_define

begin_comment
comment|/* to avoid conflicts where a platform already has _res */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_res
end_ifdef

begin_undef
undef|#
directive|undef
name|_res
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_res
value|_compat_res
end_define

begin_decl_stmt
name|struct
name|__res_state
name|_res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Necessary functions and macros */
end_comment

begin_comment
comment|/*  * Inline versions of get/put short/long.  Pointer is advanced.  *  * These macros demonstrate the property of C whereby it can be  * portable or it can be elegant but rarely both.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INT32SZ
end_ifndef

begin_define
define|#
directive|define
name|INT32SZ
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT16SZ
end_ifndef

begin_define
define|#
directive|define
name|INT16SZ
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GETSHORT
end_ifndef

begin_define
define|#
directive|define
name|GETSHORT
parameter_list|(
name|s
parameter_list|,
name|cp
parameter_list|)
value|{ \ 	register u_char *t_cp = (u_char *)(cp); \ 	(s) = ((u_int16_t)t_cp[0]<< 8) \ 	    | ((u_int16_t)t_cp[1]) \ 	    ; \ 	(cp) += INT16SZ; \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GETLONG
end_ifndef

begin_define
define|#
directive|define
name|GETLONG
parameter_list|(
name|l
parameter_list|,
name|cp
parameter_list|)
value|{ \ 	register u_char *t_cp = (u_char *)(cp); \ 	(l) = ((u_int32_t)t_cp[0]<< 24) \ 	    | ((u_int32_t)t_cp[1]<< 16) \ 	    | ((u_int32_t)t_cp[2]<< 8) \ 	    | ((u_int32_t)t_cp[3]) \ 	    ; \ 	(cp) += INT32SZ; \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Routines to insert/extract short/long's.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE__GETSHORT
end_ifndef

begin_function
specifier|static
name|u_int16_t
name|_getshort
parameter_list|(
name|msgp
parameter_list|)
specifier|register
specifier|const
name|u_char
modifier|*
name|msgp
decl_stmt|;
block|{
specifier|register
name|u_int16_t
name|u
decl_stmt|;
name|GETSHORT
argument_list|(
name|u
argument_list|,
name|msgp
argument_list|)
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_DECL__GETSHORT
argument_list|)
operator|&&
operator|(
name|HAVE_DECL__GETSHORT
operator|==
literal|0
operator|)
end_elif

begin_function_decl
name|u_int16_t
name|_getshort
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE__GETLONG
end_ifndef

begin_function
specifier|static
name|u_int32_t
name|_getlong
parameter_list|(
name|msgp
parameter_list|)
specifier|register
specifier|const
name|u_char
modifier|*
name|msgp
decl_stmt|;
block|{
specifier|register
name|u_int32_t
name|u
decl_stmt|;
name|GETLONG
argument_list|(
name|u
argument_list|,
name|msgp
argument_list|)
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_DECL__GETLONG
argument_list|)
operator|&&
operator|(
name|HAVE_DECL__GETLONG
operator|==
literal|0
operator|)
end_elif

begin_function_decl
name|u_int32_t
name|_getlong
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************** */
end_comment

begin_define
define|#
directive|define
name|ANSWER_BUFFER_SIZE
value|1024*64
end_define

begin_struct
struct|struct
name|dns_query
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
name|u_int16_t
name|class
decl_stmt|;
name|struct
name|dns_query
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_rr
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|;
name|u_int16_t
name|class
decl_stmt|;
name|u_int16_t
name|ttl
decl_stmt|;
name|u_int16_t
name|size
decl_stmt|;
name|void
modifier|*
name|rdata
decl_stmt|;
name|struct
name|dns_rr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_response
block|{
name|HEADER
name|header
decl_stmt|;
name|struct
name|dns_query
modifier|*
name|query
decl_stmt|;
name|struct
name|dns_rr
modifier|*
name|answer
decl_stmt|;
name|struct
name|dns_rr
modifier|*
name|authority
decl_stmt|;
name|struct
name|dns_rr
modifier|*
name|additional
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|dns_response
modifier|*
name|parse_dns_response
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dns_query
modifier|*
name|parse_dns_qsection
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dns_rr
modifier|*
name|parse_dns_rrsection
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_dns_query
parameter_list|(
name|struct
name|dns_query
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_dns_rr
parameter_list|(
name|struct
name|dns_rr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_dns_response
parameter_list|(
name|struct
name|dns_response
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_dns_rr
parameter_list|(
name|struct
name|dns_rr
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|getrrsetbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|unsigned
name|int
name|rdclass
parameter_list|,
name|unsigned
name|int
name|rdtype
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|struct
name|rrsetinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|__res_state
modifier|*
name|_resp
init|=
name|_THREAD_PRIVATE
argument_list|(
name|_res
argument_list|,
name|_res
argument_list|,
operator|&
name|_res
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|rrsetinfo
modifier|*
name|rrset
init|=
name|NULL
decl_stmt|;
name|struct
name|dns_response
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|struct
name|dns_rr
modifier|*
name|rr
decl_stmt|;
name|struct
name|rdatainfo
modifier|*
name|rdata
decl_stmt|;
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|index_ans
decl_stmt|,
name|index_sig
decl_stmt|;
name|u_char
name|answer
index|[
name|ANSWER_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* check for invalid class and type */
if|if
condition|(
name|rdclass
operator|>
literal|0xffff
operator|||
name|rdtype
operator|>
literal|0xffff
condition|)
block|{
name|result
operator|=
name|ERRSET_INVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* don't allow queries of class or type ANY */
if|if
condition|(
name|rdclass
operator|==
literal|0xff
operator|||
name|rdtype
operator|==
literal|0xff
condition|)
block|{
name|result
operator|=
name|ERRSET_INVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* don't allow flags yet, unimplemented */
if|if
condition|(
name|flags
condition|)
block|{
name|result
operator|=
name|ERRSET_INVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* initialize resolver */
if|if
condition|(
operator|(
name|_resp
operator|->
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|ERRSET_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|_resp
operator|->
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|RES_USE_DNSSEC
comment|/* turn on DNSSEC if EDNS0 is configured */
if|if
condition|(
name|_resp
operator|->
name|options
operator|&
name|RES_USE_EDNS0
condition|)
name|_resp
operator|->
name|options
operator||=
name|RES_USE_DNSSEC
expr_stmt|;
endif|#
directive|endif
comment|/* RES_USE_DNSEC */
comment|/* make query */
name|length
operator|=
name|res_query
argument_list|(
name|hostname
argument_list|,
operator|(
name|signed
name|int
operator|)
name|rdclass
argument_list|,
operator|(
name|signed
name|int
operator|)
name|rdtype
argument_list|,
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|answer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
name|result
operator|=
name|ERRSET_NONAME
expr_stmt|;
goto|goto
name|fail
goto|;
case|case
name|NO_DATA
case|:
name|result
operator|=
name|ERRSET_NODATA
expr_stmt|;
goto|goto
name|fail
goto|;
default|default:
name|result
operator|=
name|ERRSET_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* parse result */
name|response
operator|=
name|parse_dns_response
argument_list|(
name|answer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ERRSET_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|response
operator|->
name|header
operator|.
name|qdcount
operator|!=
literal|1
condition|)
block|{
name|result
operator|=
name|ERRSET_FAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* initialize rrset */
name|rrset
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rrsetinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ERRSET_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rrset
operator|->
name|rri_rdclass
operator|=
name|response
operator|->
name|query
operator|->
name|class
expr_stmt|;
name|rrset
operator|->
name|rri_rdtype
operator|=
name|response
operator|->
name|query
operator|->
name|type
expr_stmt|;
name|rrset
operator|->
name|rri_ttl
operator|=
name|response
operator|->
name|answer
operator|->
name|ttl
expr_stmt|;
name|rrset
operator|->
name|rri_nrdatas
operator|=
name|response
operator|->
name|header
operator|.
name|ancount
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_HEADER_AD
comment|/* check for authenticated data */
if|if
condition|(
name|response
operator|->
name|header
operator|.
name|ad
operator|==
literal|1
condition|)
name|rrset
operator|->
name|rri_flags
operator||=
name|RRSET_VALIDATED
expr_stmt|;
endif|#
directive|endif
comment|/* copy name from answer section */
name|rrset
operator|->
name|rri_name
operator|=
name|strdup
argument_list|(
name|response
operator|->
name|answer
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
operator|->
name|rri_name
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ERRSET_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* count answers */
name|rrset
operator|->
name|rri_nrdatas
operator|=
name|count_dns_rr
argument_list|(
name|response
operator|->
name|answer
argument_list|,
name|rrset
operator|->
name|rri_rdclass
argument_list|,
name|rrset
operator|->
name|rri_rdtype
argument_list|)
expr_stmt|;
name|rrset
operator|->
name|rri_nsigs
operator|=
name|count_dns_rr
argument_list|(
name|response
operator|->
name|answer
argument_list|,
name|rrset
operator|->
name|rri_rdclass
argument_list|,
name|T_SIG
argument_list|)
expr_stmt|;
comment|/* allocate memory for answers */
name|rrset
operator|->
name|rri_rdatas
operator|=
name|calloc
argument_list|(
name|rrset
operator|->
name|rri_nrdatas
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rdatainfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
operator|->
name|rri_rdatas
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ERRSET_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* allocate memory for signatures */
name|rrset
operator|->
name|rri_sigs
operator|=
name|calloc
argument_list|(
name|rrset
operator|->
name|rri_nsigs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rdatainfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
operator|->
name|rri_sigs
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ERRSET_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* copy answers& signatures */
for|for
control|(
name|rr
operator|=
name|response
operator|->
name|answer
operator|,
name|index_ans
operator|=
literal|0
operator|,
name|index_sig
operator|=
literal|0
init|;
name|rr
condition|;
name|rr
operator|=
name|rr
operator|->
name|next
control|)
block|{
name|rdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rr
operator|->
name|class
operator|==
name|rrset
operator|->
name|rri_rdclass
operator|&&
name|rr
operator|->
name|type
operator|==
name|rrset
operator|->
name|rri_rdtype
condition|)
name|rdata
operator|=
operator|&
name|rrset
operator|->
name|rri_rdatas
index|[
name|index_ans
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|rr
operator|->
name|class
operator|==
name|rrset
operator|->
name|rri_rdclass
operator|&&
name|rr
operator|->
name|type
operator|==
name|T_SIG
condition|)
name|rdata
operator|=
operator|&
name|rrset
operator|->
name|rri_sigs
index|[
name|index_sig
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|rdata
condition|)
block|{
name|rdata
operator|->
name|rdi_length
operator|=
name|rr
operator|->
name|size
expr_stmt|;
name|rdata
operator|->
name|rdi_data
operator|=
name|malloc
argument_list|(
name|rr
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|rdi_data
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ERRSET_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|memcpy
argument_list|(
name|rdata
operator|->
name|rdi_data
argument_list|,
name|rr
operator|->
name|rdata
argument_list|,
name|rr
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|free_dns_response
argument_list|(
name|response
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|rrset
expr_stmt|;
return|return
operator|(
name|ERRSET_SUCCESS
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|rrset
operator|!=
name|NULL
condition|)
name|freerrset
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|free_dns_response
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|freerrset
parameter_list|(
name|struct
name|rrsetinfo
modifier|*
name|rrset
parameter_list|)
block|{
name|u_int16_t
name|i
decl_stmt|;
if|if
condition|(
name|rrset
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|rrset
operator|->
name|rri_rdatas
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rrset
operator|->
name|rri_nrdatas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rri_rdatas
index|[
name|i
index|]
operator|.
name|rdi_data
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|rrset
operator|->
name|rri_rdatas
index|[
name|i
index|]
operator|.
name|rdi_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rrset
operator|->
name|rri_rdatas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rrset
operator|->
name|rri_sigs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rrset
operator|->
name|rri_nsigs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rri_sigs
index|[
name|i
index|]
operator|.
name|rdi_data
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|rrset
operator|->
name|rri_sigs
index|[
name|i
index|]
operator|.
name|rdi_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rrset
operator|->
name|rri_sigs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rrset
operator|->
name|rri_name
condition|)
name|free
argument_list|(
name|rrset
operator|->
name|rri_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DNS response parsing routines  */
end_comment

begin_function
specifier|static
name|struct
name|dns_response
modifier|*
name|parse_dns_response
parameter_list|(
specifier|const
name|u_char
modifier|*
name|answer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|dns_response
modifier|*
name|resp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* allocate memory for the response */
name|resp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* initialize current pointer */
name|cp
operator|=
name|answer
expr_stmt|;
comment|/* copy header */
name|memcpy
argument_list|(
operator|&
name|resp
operator|->
name|header
argument_list|,
name|cp
argument_list|,
name|HFIXEDSZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|HFIXEDSZ
expr_stmt|;
comment|/* fix header byte order */
name|resp
operator|->
name|header
operator|.
name|qdcount
operator|=
name|ntohs
argument_list|(
name|resp
operator|->
name|header
operator|.
name|qdcount
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|ancount
operator|=
name|ntohs
argument_list|(
name|resp
operator|->
name|header
operator|.
name|ancount
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|nscount
operator|=
name|ntohs
argument_list|(
name|resp
operator|->
name|header
operator|.
name|nscount
argument_list|)
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arcount
operator|=
name|ntohs
argument_list|(
name|resp
operator|->
name|header
operator|.
name|arcount
argument_list|)
expr_stmt|;
comment|/* there must be at least one query */
if|if
condition|(
name|resp
operator|->
name|header
operator|.
name|qdcount
operator|<
literal|1
condition|)
block|{
name|free_dns_response
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* parse query section */
name|resp
operator|->
name|query
operator|=
name|parse_dns_qsection
argument_list|(
name|answer
argument_list|,
name|size
argument_list|,
operator|&
name|cp
argument_list|,
name|resp
operator|->
name|header
operator|.
name|qdcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|header
operator|.
name|qdcount
operator|&&
name|resp
operator|->
name|query
operator|==
name|NULL
condition|)
block|{
name|free_dns_response
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* parse answer section */
name|resp
operator|->
name|answer
operator|=
name|parse_dns_rrsection
argument_list|(
name|answer
argument_list|,
name|size
argument_list|,
operator|&
name|cp
argument_list|,
name|resp
operator|->
name|header
operator|.
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|header
operator|.
name|ancount
operator|&&
name|resp
operator|->
name|answer
operator|==
name|NULL
condition|)
block|{
name|free_dns_response
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* parse authority section */
name|resp
operator|->
name|authority
operator|=
name|parse_dns_rrsection
argument_list|(
name|answer
argument_list|,
name|size
argument_list|,
operator|&
name|cp
argument_list|,
name|resp
operator|->
name|header
operator|.
name|nscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|header
operator|.
name|nscount
operator|&&
name|resp
operator|->
name|authority
operator|==
name|NULL
condition|)
block|{
name|free_dns_response
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* parse additional section */
name|resp
operator|->
name|additional
operator|=
name|parse_dns_rrsection
argument_list|(
name|answer
argument_list|,
name|size
argument_list|,
operator|&
name|cp
argument_list|,
name|resp
operator|->
name|header
operator|.
name|arcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|header
operator|.
name|arcount
operator|&&
name|resp
operator|->
name|additional
operator|==
name|NULL
condition|)
block|{
name|free_dns_response
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|resp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dns_query
modifier|*
name|parse_dns_qsection
parameter_list|(
specifier|const
name|u_char
modifier|*
name|answer
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|cp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|dns_query
modifier|*
name|head
decl_stmt|,
modifier|*
name|curr
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|head
operator|=
name|NULL
operator|,
name|prev
operator|=
name|NULL
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
operator|,
name|prev
operator|=
name|curr
control|)
block|{
comment|/* allocate and initialize struct */
name|curr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_query
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|NULL
condition|)
block|{
name|free_dns_query
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|curr
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|curr
expr_stmt|;
comment|/* name */
name|length
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|answer
operator|+
name|size
argument_list|,
operator|*
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|free_dns_query
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|curr
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|free_dns_query
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|cp
operator|+=
name|length
expr_stmt|;
comment|/* type */
name|curr
operator|->
name|type
operator|=
name|_getshort
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* class */
name|curr
operator|->
name|class
operator|=
name|_getshort
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dns_rr
modifier|*
name|parse_dns_rrsection
parameter_list|(
specifier|const
name|u_char
modifier|*
name|answer
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|cp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|dns_rr
modifier|*
name|head
decl_stmt|,
modifier|*
name|curr
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|head
operator|=
name|NULL
operator|,
name|prev
operator|=
name|NULL
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
operator|,
name|prev
operator|=
name|curr
control|)
block|{
comment|/* allocate and initialize struct */
name|curr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_rr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|NULL
condition|)
block|{
name|free_dns_rr
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|curr
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|curr
expr_stmt|;
comment|/* name */
name|length
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|answer
operator|+
name|size
argument_list|,
operator|*
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|free_dns_rr
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|curr
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|free_dns_rr
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|cp
operator|+=
name|length
expr_stmt|;
comment|/* type */
name|curr
operator|->
name|type
operator|=
name|_getshort
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* class */
name|curr
operator|->
name|class
operator|=
name|_getshort
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* ttl */
name|curr
operator|->
name|ttl
operator|=
name|_getlong
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* rdata size */
name|curr
operator|->
name|size
operator|=
name|_getshort
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* rdata itself */
name|curr
operator|->
name|rdata
operator|=
name|malloc
argument_list|(
name|curr
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|rdata
operator|==
name|NULL
condition|)
block|{
name|free_dns_rr
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|curr
operator|->
name|rdata
argument_list|,
operator|*
name|cp
argument_list|,
name|curr
operator|->
name|size
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|+=
name|curr
operator|->
name|size
expr_stmt|;
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_dns_query
parameter_list|(
name|struct
name|dns_query
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|name
condition|)
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_dns_query
argument_list|(
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_dns_rr
parameter_list|(
name|struct
name|dns_rr
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|name
condition|)
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rdata
condition|)
name|free
argument_list|(
name|p
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|free_dns_rr
argument_list|(
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_dns_response
parameter_list|(
name|struct
name|dns_response
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|free_dns_query
argument_list|(
name|p
operator|->
name|query
argument_list|)
expr_stmt|;
name|free_dns_rr
argument_list|(
name|p
operator|->
name|answer
argument_list|)
expr_stmt|;
name|free_dns_rr
argument_list|(
name|p
operator|->
name|authority
argument_list|)
expr_stmt|;
name|free_dns_rr
argument_list|(
name|p
operator|->
name|additional
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_dns_rr
parameter_list|(
name|struct
name|dns_rr
modifier|*
name|p
parameter_list|,
name|u_int16_t
name|class
parameter_list|,
name|u_int16_t
name|type
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|class
operator|&&
name|p
operator|->
name|type
operator|==
name|type
condition|)
name|n
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_GETRRSETBYNAME) */
end_comment

end_unit

