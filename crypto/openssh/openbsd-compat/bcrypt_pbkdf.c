begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: bcrypt_pbkdf.c,v 1.4 2013/07/29 00:55:53 tedu Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 Ted Unangst<tedu@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_BCRYPT_PBKDF
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BLF_H
end_ifdef

begin_include
include|#
directive|include
file|<blf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"crypto_api.h"
end_include

begin_define
define|#
directive|define
name|SHA512_DIGEST_LENGTH
value|crypto_hash_sha512_BYTES
end_define

begin_comment
comment|/*  * pkcs #5 pbkdf2 implementation using the "bcrypt" hash  *  * The bcrypt hash function is derived from the bcrypt password hashing  * function with the following modifications:  * 1. The input password and salt are preprocessed with SHA512.  * 2. The output length is expanded to 256 bits.  * 3. Subsequently the magic string to be encrypted is lengthened and modifed  *    to "OxychromaticBlowfishSwatDynamite"  * 4. The hash function is defined to perform 64 rounds of initial state  *    expansion. (More rounds are performed by iterating the hash.)  *  * Note that this implementation pulls the SHA512 operations into the caller  * as a performance optimization.  *  * One modification from official pbkdf2. Instead of outputting key material  * linearly, we mix it. pbkdf2 has a known weakness where if one uses it to  * generate (i.e.) 512 bits of key material for use as two 256 bit keys, an  * attacker can merely run once through the outer loop below, but the user  * always runs it twice. Shuffling output bytes requires computing the  * entirety of the key material to assemble any subkey. This is something a  * wise caller could do; we just do it for you.  */
end_comment

begin_define
define|#
directive|define
name|BCRYPT_BLOCKS
value|8
end_define

begin_define
define|#
directive|define
name|BCRYPT_HASHSIZE
value|(BCRYPT_BLOCKS * 4)
end_define

begin_function
specifier|static
name|void
name|bcrypt_hash
parameter_list|(
name|u_int8_t
modifier|*
name|sha2pass
parameter_list|,
name|u_int8_t
modifier|*
name|sha2salt
parameter_list|,
name|u_int8_t
modifier|*
name|out
parameter_list|)
block|{
name|blf_ctx
name|state
decl_stmt|;
name|u_int8_t
name|ciphertext
index|[
name|BCRYPT_HASHSIZE
index|]
init|=
literal|"OxychromaticBlowfishSwatDynamite"
decl_stmt|;
name|uint32_t
name|cdata
index|[
name|BCRYPT_BLOCKS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|j
decl_stmt|;
name|size_t
name|shalen
init|=
name|SHA512_DIGEST_LENGTH
decl_stmt|;
comment|/* key expansion */
name|Blowfish_initstate
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|Blowfish_expandstate
argument_list|(
operator|&
name|state
argument_list|,
name|sha2salt
argument_list|,
name|shalen
argument_list|,
name|sha2pass
argument_list|,
name|shalen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|Blowfish_expand0state
argument_list|(
operator|&
name|state
argument_list|,
name|sha2salt
argument_list|,
name|shalen
argument_list|)
expr_stmt|;
name|Blowfish_expand0state
argument_list|(
operator|&
name|state
argument_list|,
name|sha2pass
argument_list|,
name|shalen
argument_list|)
expr_stmt|;
block|}
comment|/* encryption */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCRYPT_BLOCKS
condition|;
name|i
operator|++
control|)
name|cdata
index|[
name|i
index|]
operator|=
name|Blowfish_stream2word
argument_list|(
name|ciphertext
argument_list|,
sizeof|sizeof
argument_list|(
name|ciphertext
argument_list|)
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|blf_enc
argument_list|(
operator|&
name|state
argument_list|,
name|cdata
argument_list|,
sizeof|sizeof
argument_list|(
name|cdata
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCRYPT_BLOCKS
condition|;
name|i
operator|++
control|)
block|{
name|out
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|=
operator|(
name|cdata
index|[
name|i
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|out
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|cdata
index|[
name|i
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|out
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|cdata
index|[
name|i
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|out
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* zap */
name|memset
argument_list|(
name|ciphertext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ciphertext
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cdata
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bcrypt_pbkdf
parameter_list|(
specifier|const
name|char
modifier|*
name|pass
parameter_list|,
name|size_t
name|passlen
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|salt
parameter_list|,
name|size_t
name|saltlen
parameter_list|,
name|u_int8_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|,
name|unsigned
name|int
name|rounds
parameter_list|)
block|{
name|u_int8_t
name|sha2pass
index|[
name|SHA512_DIGEST_LENGTH
index|]
decl_stmt|;
name|u_int8_t
name|sha2salt
index|[
name|SHA512_DIGEST_LENGTH
index|]
decl_stmt|;
name|u_int8_t
name|out
index|[
name|BCRYPT_HASHSIZE
index|]
decl_stmt|;
name|u_int8_t
name|tmpout
index|[
name|BCRYPT_HASHSIZE
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|countsalt
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|amt
decl_stmt|,
name|stride
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
comment|/* nothing crazy */
if|if
condition|(
name|rounds
operator|<
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|passlen
operator|==
literal|0
operator|||
name|saltlen
operator|==
literal|0
operator|||
name|keylen
operator|==
literal|0
operator|||
name|keylen
operator|>
sizeof|sizeof
argument_list|(
name|out
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|out
argument_list|)
operator|||
name|saltlen
operator|>
literal|1
operator|<<
literal|20
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|countsalt
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|saltlen
operator|+
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|stride
operator|=
operator|(
name|keylen
operator|+
sizeof|sizeof
argument_list|(
name|out
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|(
name|keylen
operator|+
name|stride
operator|-
literal|1
operator|)
operator|/
name|stride
expr_stmt|;
name|memcpy
argument_list|(
name|countsalt
argument_list|,
name|salt
argument_list|,
name|saltlen
argument_list|)
expr_stmt|;
comment|/* collapse password */
name|crypto_hash_sha512
argument_list|(
name|sha2pass
argument_list|,
name|pass
argument_list|,
name|passlen
argument_list|)
expr_stmt|;
comment|/* generate key, sizeof(out) at a time */
for|for
control|(
name|count
operator|=
literal|1
init|;
name|keylen
operator|>
literal|0
condition|;
name|count
operator|++
control|)
block|{
name|countsalt
index|[
name|saltlen
operator|+
literal|0
index|]
operator|=
operator|(
name|count
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|countsalt
index|[
name|saltlen
operator|+
literal|1
index|]
operator|=
operator|(
name|count
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|countsalt
index|[
name|saltlen
operator|+
literal|2
index|]
operator|=
operator|(
name|count
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|countsalt
index|[
name|saltlen
operator|+
literal|3
index|]
operator|=
name|count
operator|&
literal|0xff
expr_stmt|;
comment|/* first round, salt is salt */
name|crypto_hash_sha512
argument_list|(
name|sha2salt
argument_list|,
name|countsalt
argument_list|,
name|saltlen
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bcrypt_hash
argument_list|(
name|sha2pass
argument_list|,
name|sha2salt
argument_list|,
name|tmpout
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|tmpout
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rounds
condition|;
name|i
operator|++
control|)
block|{
comment|/* subsequent rounds, salt is previous output */
name|crypto_hash_sha512
argument_list|(
name|sha2salt
argument_list|,
name|tmpout
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpout
argument_list|)
argument_list|)
expr_stmt|;
name|bcrypt_hash
argument_list|(
name|sha2pass
argument_list|,
name|sha2salt
argument_list|,
name|tmpout
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|out
argument_list|)
condition|;
name|j
operator|++
control|)
name|out
index|[
name|j
index|]
operator|^=
name|tmpout
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* 		 * pbkdf2 deviation: ouput the key material non-linearly. 		 */
name|amt
operator|=
name|MIN
argument_list|(
name|amt
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|++
control|)
name|key
index|[
name|i
operator|*
name|stride
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
index|]
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
name|keylen
operator|-=
name|amt
expr_stmt|;
block|}
comment|/* zap */
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|countsalt
argument_list|,
literal|0
argument_list|,
name|saltlen
operator|+
literal|4
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|countsalt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BCRYPT_PBKDF */
end_comment

end_unit

