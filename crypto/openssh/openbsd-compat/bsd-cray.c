begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * $Id: bsd-cray.c,v 1.16 2006/09/01 05:38:41 djm Exp $  *  * bsd-cray.c  *  * Copyright (c) 2002, Cray Inc.  (Wendy Palm<wendyp@cray.com>)  * Significant portions provided by   *          Wayne Schroeder, SDSC<schroeder@sdsc.edu>  *          William Jones, UTexas<jones@tacc.utexas.edu>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Created: Apr 22 16.34:00 2002 wp  *  * This file contains functions required for proper execution  * on UNICOS systems.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_UNICOS
end_ifdef

begin_include
include|#
directive|include
file|<udb.h>
end_include

begin_include
include|#
directive|include
file|<tmpdir.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/category.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/jtab.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/secparm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tfm.h>
end_include

begin_include
include|#
directive|include
file|<sys/usrv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sectab.h>
end_include

begin_include
include|#
directive|include
file|<sys/secstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/session.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ia.h>
end_include

begin_include
include|#
directive|include
file|<urm.h>
end_include

begin_include
include|#
directive|include
file|"ssh.h"
end_include

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRUCT_SOCKADDR_STORAGE
end_ifndef

begin_define
define|#
directive|define
name|_SS_MAXSIZE
value|128
end_define

begin_comment
comment|/* Implementation specific max size */
end_comment

begin_define
define|#
directive|define
name|_SS_PADSIZE
value|(_SS_MAXSIZE - sizeof (struct sockaddr))
end_define

begin_define
define|#
directive|define
name|ss_family
value|ss_sa.sa_family
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRUCT_SOCKADDR_STORAGE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN6_IS_ADDR_LOOPBACK
end_ifndef

begin_define
define|#
directive|define
name|IN6_IS_ADDR_LOOPBACK
parameter_list|(
name|a
parameter_list|)
define|\
value|(((u_int32_t *) (a))[0] == 0&& ((u_int32_t *) (a))[1] == 0&& \ 	 ((u_int32_t *) (a))[2] == 0&& ((u_int32_t *) (a))[3] == htonl (1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !IN6_IS_ADDR_LOOPBACK */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AF_INET6
end_ifndef

begin_comment
comment|/* Define it to something that should never appear */
end_comment

begin_define
define|#
directive|define
name|AF_INET6
value|AF_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"bsd-cray.h"
end_include

begin_define
define|#
directive|define
name|MAXACID
value|80
end_define

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cray_tmpdir
index|[
name|TPATHSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* job TMPDIR path */
end_comment

begin_decl_stmt
name|struct
name|sysv
name|sysv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system security structure */
end_comment

begin_decl_stmt
name|struct
name|usrv
name|usrv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user security structure */
end_comment

begin_comment
comment|/*  * Functions.  */
end_comment

begin_function_decl
name|void
name|cray_retain_utmp
parameter_list|(
name|struct
name|utmp
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_delete_tmpdir
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_init_job
parameter_list|(
name|struct
name|passwd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_set_tmpdir
parameter_list|(
name|struct
name|utmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_login_failure
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cray_setup
parameter_list|(
name|uid_t
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cray_access_denied
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|cray_login_failure
parameter_list|(
name|char
modifier|*
name|username
parameter_list|,
name|int
name|errcode
parameter_list|)
block|{
name|struct
name|udb
modifier|*
name|ueptr
decl_stmt|;
comment|/* UDB pointer for username */
name|ia_failure_t
name|fsent
decl_stmt|;
comment|/* ia_failure structure */
name|ia_failure_ret_t
name|fret
decl_stmt|;
comment|/* ia_failure return stuff */
name|struct
name|jtab
name|jtab
decl_stmt|;
comment|/* job table structure */
name|int
name|jid
init|=
literal|0
decl_stmt|;
comment|/* job id */
if|if
condition|(
operator|(
name|jid
operator|=
name|getjtab
argument_list|(
operator|&
name|jtab
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|debug
argument_list|(
literal|"cray_login_failure(): getjtab error"
argument_list|)
expr_stmt|;
name|getsysudb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ueptr
operator|=
name|getudbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|UDB_NULL
condition|)
name|debug
argument_list|(
literal|"cray_login_failure(): getudbname() returned NULL"
argument_list|)
expr_stmt|;
name|endudb
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fsent
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|fsent
argument_list|)
argument_list|)
expr_stmt|;
name|fsent
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|fsent
operator|.
name|uname
operator|=
name|username
expr_stmt|;
name|fsent
operator|.
name|host
operator|=
operator|(
name|char
operator|*
operator|)
name|get_canonical_hostname
argument_list|(
name|options
operator|.
name|use_dns
argument_list|)
expr_stmt|;
name|fsent
operator|.
name|ttyn
operator|=
literal|"sshd"
expr_stmt|;
name|fsent
operator|.
name|caller
operator|=
name|IA_SSHD
expr_stmt|;
name|fsent
operator|.
name|flags
operator|=
name|IA_INTERACTIVE
expr_stmt|;
name|fsent
operator|.
name|ueptr
operator|=
name|ueptr
expr_stmt|;
name|fsent
operator|.
name|jid
operator|=
name|jid
expr_stmt|;
name|fsent
operator|.
name|errcode
operator|=
name|errcode
expr_stmt|;
name|fsent
operator|.
name|pwdp
operator|=
name|NULL
expr_stmt|;
name|fsent
operator|.
name|exitcode
operator|=
literal|0
expr_stmt|;
comment|/* dont exit in ia_failure() */
name|fret
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|fret
operator|.
name|normal
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Call ia_failure because of an login failure. 	 */
name|ia_failure
argument_list|(
operator|&
name|fsent
argument_list|,
operator|&
name|fret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Cray access denied  */
end_comment

begin_function
name|int
name|cray_access_denied
parameter_list|(
name|char
modifier|*
name|username
parameter_list|)
block|{
name|struct
name|udb
modifier|*
name|ueptr
decl_stmt|;
comment|/* UDB pointer for username */
name|int
name|errcode
decl_stmt|;
comment|/* IA errorcode */
name|errcode
operator|=
literal|0
expr_stmt|;
name|getsysudb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ueptr
operator|=
name|getudbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|UDB_NULL
condition|)
name|debug
argument_list|(
literal|"cray_login_failure(): getudbname() returned NULL"
argument_list|)
expr_stmt|;
name|endudb
argument_list|()
expr_stmt|;
if|if
condition|(
name|ueptr
operator|!=
name|NULL
operator|&&
name|ueptr
operator|->
name|ue_disabled
condition|)
name|errcode
operator|=
name|IA_DISABLED
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
name|cray_login_failure
argument_list|(
name|username
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|errcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * record_failed_login: generic "login failed" interface function  */
end_comment

begin_function
name|void
name|record_failed_login
parameter_list|(
specifier|const
name|char
modifier|*
name|user
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|ttyname
parameter_list|)
block|{
name|cray_login_failure
argument_list|(
operator|(
name|char
operator|*
operator|)
name|user
argument_list|,
name|IA_UDBERR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cray_setup
parameter_list|(
name|uid_t
name|uid
parameter_list|,
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|command
parameter_list|)
block|{
specifier|extern
name|struct
name|udb
modifier|*
name|getudb
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|setlimits
parameter_list|()
function_decl|;
name|int
name|err
decl_stmt|;
comment|/* error return */
name|time_t
name|system_time
decl_stmt|;
comment|/* current system clock */
name|time_t
name|expiration_time
decl_stmt|;
comment|/* password expiration time */
name|int
name|maxattempts
decl_stmt|;
comment|/* maximum no. of failed login attempts */
name|int
name|SecureSys
decl_stmt|;
comment|/* unicos security flag */
name|int
name|minslevel
init|=
literal|0
decl_stmt|;
comment|/* system minimum security level */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|valid_acct
init|=
operator|-
literal|1
decl_stmt|;
comment|/* flag for reading valid acct */
name|char
name|acct_name
index|[
name|MAXACID
index|]
init|=
block|{
literal|""
block|}
decl_stmt|;
comment|/* used to read acct name */
name|struct
name|jtab
name|jtab
decl_stmt|;
comment|/* Job table struct */
name|struct
name|udb
name|ue
decl_stmt|;
comment|/* udb entry for logging-in user */
name|struct
name|udb
modifier|*
name|up
decl_stmt|;
comment|/* pointer to UDB entry */
name|struct
name|secstat
name|secinfo
decl_stmt|;
comment|/* file  security attributes */
name|struct
name|servprov
name|init_info
decl_stmt|;
comment|/* used for sesscntl() call */
name|int
name|jid
decl_stmt|;
comment|/* job ID */
name|int
name|pid
decl_stmt|;
comment|/* process ID */
name|char
modifier|*
name|sr
decl_stmt|;
comment|/* status return from setlimits() */
name|char
modifier|*
name|ttyn
init|=
name|NULL
decl_stmt|;
comment|/* ttyname or command name*/
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* passwd stuff for ia_user */
name|passwd_t
name|pwdacm
decl_stmt|,
name|pwddialup
decl_stmt|,
name|pwdudb
decl_stmt|,
name|pwdwal
decl_stmt|,
name|pwddce
decl_stmt|;
name|ia_user_ret_t
name|uret
decl_stmt|;
comment|/* stuff returned from ia_user */
name|ia_user_t
name|usent
decl_stmt|;
comment|/* ia_user main structure */
name|int
name|ia_rcode
decl_stmt|;
comment|/* ia_user return code */
name|ia_failure_t
name|fsent
decl_stmt|;
comment|/* ia_failure structure */
name|ia_failure_ret_t
name|fret
decl_stmt|;
comment|/* ia_failure return stuff */
name|ia_success_t
name|ssent
decl_stmt|;
comment|/* ia_success structure */
name|ia_success_ret_t
name|sret
decl_stmt|;
comment|/* ia_success return stuff */
name|int
name|ia_mlsrcode
decl_stmt|;
comment|/* ia_mlsuser return code */
name|int
name|secstatrc
decl_stmt|;
comment|/* [f]secstat return code */
if|if
condition|(
name|SecureSys
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_CRAY_SECURE_SYS
argument_list|)
condition|)
block|{
name|getsysv
argument_list|(
operator|&
name|sysv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysv
argument_list|)
argument_list|)
expr_stmt|;
name|minslevel
operator|=
name|sysv
operator|.
name|sy_minlvl
expr_stmt|;
if|if
condition|(
name|getusrv
argument_list|(
operator|&
name|usrv
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"getusrv() failed, errno = %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|hostname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strlcpy
argument_list|(
name|hostname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|get_canonical_hostname
argument_list|(
name|options
operator|.
name|use_dns
argument_list|)
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
comment|/* 	 *  Fetch user's UDB entry. 	 */
name|getsysudb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|=
name|getudbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|UDB_NULL
condition|)
name|fatal
argument_list|(
literal|"cannot fetch user's UDB entry"
argument_list|)
expr_stmt|;
comment|/* 	 *  Prevent any possible fudging so perform a data 	 *  safety check and compare the supplied uid against 	 *  the udb's uid. 	 */
if|if
condition|(
name|up
operator|->
name|ue_uid
operator|!=
name|uid
condition|)
name|fatal
argument_list|(
literal|"IA uid missmatch"
argument_list|)
expr_stmt|;
name|endudb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|jid
operator|=
name|getjtab
argument_list|(
operator|&
name|jtab
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"getjtab"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ttyn
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SecureSys
condition|)
block|{
if|if
condition|(
name|ttyn
operator|!=
name|NULL
condition|)
name|secstatrc
operator|=
name|secstat
argument_list|(
name|ttyn
argument_list|,
operator|&
name|secinfo
argument_list|)
expr_stmt|;
else|else
name|secstatrc
operator|=
name|fsecstat
argument_list|(
literal|1
argument_list|,
operator|&
name|secinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|secstatrc
operator|==
literal|0
condition|)
name|debug
argument_list|(
literal|"[f]secstat() successful"
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"[f]secstat() error, rc = %d"
argument_list|,
name|secstatrc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ttyn
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|command
operator|!=
name|NULL
operator|)
condition|)
name|ttyn
operator|=
operator|(
name|char
operator|*
operator|)
name|command
expr_stmt|;
comment|/* 	 *  Initialize all structures to call ia_user 	 */
name|usent
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|usent
operator|.
name|uname
operator|=
name|username
expr_stmt|;
name|usent
operator|.
name|host
operator|=
name|hostname
expr_stmt|;
name|usent
operator|.
name|ttyn
operator|=
name|ttyn
expr_stmt|;
name|usent
operator|.
name|caller
operator|=
name|IA_SSHD
expr_stmt|;
name|usent
operator|.
name|pswdlist
operator|=
operator|&
name|pwdacm
expr_stmt|;
name|usent
operator|.
name|ueptr
operator|=
operator|&
name|ue
expr_stmt|;
name|usent
operator|.
name|flags
operator|=
name|IA_INTERACTIVE
operator||
name|IA_FFLAG
expr_stmt|;
name|pwdacm
operator|.
name|atype
operator|=
name|IA_SECURID
expr_stmt|;
name|pwdacm
operator|.
name|pwdp
operator|=
name|NULL
expr_stmt|;
name|pwdacm
operator|.
name|next
operator|=
operator|&
name|pwdudb
expr_stmt|;
name|pwdudb
operator|.
name|atype
operator|=
name|IA_UDB
expr_stmt|;
name|pwdudb
operator|.
name|pwdp
operator|=
name|NULL
expr_stmt|;
name|pwdudb
operator|.
name|next
operator|=
operator|&
name|pwddce
expr_stmt|;
name|pwddce
operator|.
name|atype
operator|=
name|IA_DCE
expr_stmt|;
name|pwddce
operator|.
name|pwdp
operator|=
name|NULL
expr_stmt|;
name|pwddce
operator|.
name|next
operator|=
operator|&
name|pwddialup
expr_stmt|;
name|pwddialup
operator|.
name|atype
operator|=
name|IA_DIALUP
expr_stmt|;
name|pwddialup
operator|.
name|pwdp
operator|=
name|NULL
expr_stmt|;
comment|/* pwddialup.next =&pwdwal; */
name|pwddialup
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|pwdwal
operator|.
name|atype
operator|=
name|IA_WAL
expr_stmt|;
name|pwdwal
operator|.
name|pwdp
operator|=
name|NULL
expr_stmt|;
name|pwdwal
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|uret
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|uret
operator|.
name|pswd
operator|=
name|NULL
expr_stmt|;
name|uret
operator|.
name|normal
operator|=
literal|0
expr_stmt|;
name|ia_rcode
operator|=
name|ia_user
argument_list|(
operator|&
name|usent
argument_list|,
operator|&
name|uret
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ia_rcode
condition|)
block|{
comment|/* 	 *  These are acceptable return codes from ia_user() 	 */
case|case
name|IA_UDBWEEK
case|:
comment|/* Password Expires in 1 week */
name|expiration_time
operator|=
name|ue
operator|.
name|ue_pwage
operator|.
name|time
operator|+
name|ue
operator|.
name|ue_pwage
operator|.
name|maxage
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING - your current password will expire %s\n"
argument_list|,
name|ctime
argument_list|(
operator|(
specifier|const
name|time_t
operator|*
operator|)
operator|&
name|expiration_time
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA_UDBEXPIRED
case|:
if|if
condition|(
name|ttyname
argument_list|(
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Force a password change */
name|printf
argument_list|(
literal|"Your password has expired; Choose a new one.\n"
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/passwd"
argument_list|,
literal|"passwd"
argument_list|,
name|username
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IA_NORMAL
case|:
comment|/* Normal Return Code */
break|break;
case|case
name|IA_BACKDOOR
case|:
comment|/* XXX: can we memset it to zero here so save some of this */
name|strlcpy
argument_list|(
name|ue
operator|.
name|ue_name
argument_list|,
literal|"root"
argument_list|,
sizeof|sizeof
argument_list|(
name|ue
operator|.
name|ue_name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ue
operator|.
name|ue_dir
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|ue
operator|.
name|ue_dir
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ue
operator|.
name|ue_shell
argument_list|,
literal|"/bin/sh"
argument_list|,
sizeof|sizeof
argument_list|(
name|ue
operator|.
name|ue_shell
argument_list|)
argument_list|)
expr_stmt|;
name|ue
operator|.
name|ue_passwd
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ue
operator|.
name|ue_age
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ue
operator|.
name|ue_comment
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ue
operator|.
name|ue_loghost
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ue
operator|.
name|ue_logline
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ue
operator|.
name|ue_uid
operator|=
operator|-
literal|1
expr_stmt|;
name|ue
operator|.
name|ue_nice
index|[
name|UDBRC_INTER
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVIDS
condition|;
name|i
operator|++
control|)
name|ue
operator|.
name|ue_gids
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_logfails
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_minlvl
operator|=
name|ue
operator|.
name|ue_maxlvl
operator|=
name|ue
operator|.
name|ue_deflvl
operator|=
name|minslevel
expr_stmt|;
name|ue
operator|.
name|ue_defcomps
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_comparts
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_permits
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_trap
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_disabled
operator|=
literal|0
expr_stmt|;
name|ue
operator|.
name|ue_logtime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IA_CONSOLE
case|:
comment|/* Superuser not from Console */
case|case
name|IA_TRUSTED
case|:
comment|/* Trusted user */
if|if
condition|(
name|options
operator|.
name|permit_root_login
operator|>
name|PERMIT_NO
condition|)
break|break;
comment|/* Accept root login */
default|default:
comment|/* 	 *  These are failed return codes from ia_user() 	 */
switch|switch
condition|(
name|ia_rcode
condition|)
block|{
case|case
name|IA_BADAUTH
case|:
name|printf
argument_list|(
literal|"Bad authorization, access denied.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA_DISABLED
case|:
name|printf
argument_list|(
literal|"Your login has been disabled. Contact the system "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"administrator for assistance.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA_GETSYSV
case|:
name|printf
argument_list|(
literal|"getsysv() failed - errno = %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA_MAXLOGS
case|:
name|printf
argument_list|(
literal|"Maximum number of failed login attempts exceeded.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Access denied.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA_UDBPWDNULL
case|:
if|if
condition|(
name|SecureSys
condition|)
name|printf
argument_list|(
literal|"NULL Password not allowed on MLS systems.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 		 *  Authentication failed. 		 */
name|printf
argument_list|(
literal|"sshd: Login incorrect, (0%o)\n"
argument_list|,
name|ia_rcode
operator|-
name|IA_ERRORCODE
argument_list|)
expr_stmt|;
comment|/* 		 *  Initialize structure for ia_failure 		 *  which will exit. 		 */
name|fsent
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|fsent
operator|.
name|uname
operator|=
name|username
expr_stmt|;
name|fsent
operator|.
name|host
operator|=
name|hostname
expr_stmt|;
name|fsent
operator|.
name|ttyn
operator|=
name|ttyn
expr_stmt|;
name|fsent
operator|.
name|caller
operator|=
name|IA_SSHD
expr_stmt|;
name|fsent
operator|.
name|flags
operator|=
name|IA_INTERACTIVE
expr_stmt|;
name|fsent
operator|.
name|ueptr
operator|=
operator|&
name|ue
expr_stmt|;
name|fsent
operator|.
name|jid
operator|=
name|jid
expr_stmt|;
name|fsent
operator|.
name|errcode
operator|=
name|ia_rcode
expr_stmt|;
name|fsent
operator|.
name|pwdp
operator|=
name|uret
operator|.
name|pswd
expr_stmt|;
name|fsent
operator|.
name|exitcode
operator|=
literal|1
expr_stmt|;
name|fret
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|fret
operator|.
name|normal
operator|=
literal|0
expr_stmt|;
comment|/* 		*  Call ia_failure because of an IA failure. 		*  There is no return because ia_failure exits. 		*/
name|ia_failure
argument_list|(
operator|&
name|fsent
argument_list|,
operator|&
name|fret
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ia_mlsrcode
operator|=
name|IA_NORMAL
expr_stmt|;
if|if
condition|(
name|SecureSys
condition|)
block|{
name|debug
argument_list|(
literal|"calling ia_mlsuser()"
argument_list|)
expr_stmt|;
name|ia_mlsrcode
operator|=
name|ia_mlsuser
argument_list|(
operator|&
name|ue
argument_list|,
operator|&
name|secinfo
argument_list|,
operator|&
name|usrv
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ia_mlsrcode
operator|!=
name|IA_NORMAL
condition|)
block|{
name|printf
argument_list|(
literal|"sshd: Login incorrect, (0%o)\n"
argument_list|,
name|ia_mlsrcode
operator|-
name|IA_ERRORCODE
argument_list|)
expr_stmt|;
comment|/* 		 *  Initialize structure for ia_failure 		 *  which will exit. 		 */
name|fsent
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|fsent
operator|.
name|uname
operator|=
name|username
expr_stmt|;
name|fsent
operator|.
name|host
operator|=
name|hostname
expr_stmt|;
name|fsent
operator|.
name|ttyn
operator|=
name|ttyn
expr_stmt|;
name|fsent
operator|.
name|caller
operator|=
name|IA_SSHD
expr_stmt|;
name|fsent
operator|.
name|flags
operator|=
name|IA_INTERACTIVE
expr_stmt|;
name|fsent
operator|.
name|ueptr
operator|=
operator|&
name|ue
expr_stmt|;
name|fsent
operator|.
name|jid
operator|=
name|jid
expr_stmt|;
name|fsent
operator|.
name|errcode
operator|=
name|ia_mlsrcode
expr_stmt|;
name|fsent
operator|.
name|pwdp
operator|=
name|uret
operator|.
name|pswd
expr_stmt|;
name|fsent
operator|.
name|exitcode
operator|=
literal|1
expr_stmt|;
name|fret
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|fret
operator|.
name|normal
operator|=
literal|0
expr_stmt|;
comment|/* 		 *  Call ia_failure because of an IA failure. 		 *  There is no return because ia_failure exits. 		 */
name|ia_failure
argument_list|(
operator|&
name|fsent
argument_list|,
operator|&
name|fret
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Provide login status information */
if|if
condition|(
name|options
operator|.
name|print_lastlog
operator|&&
name|ue
operator|.
name|ue_logtime
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Last successful login was : %.*s "
argument_list|,
literal|19
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|ue
operator|.
name|ue_logtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ue
operator|.
name|ue_loghost
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"from %.*s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ue
operator|.
name|ue_loghost
argument_list|)
argument_list|,
name|ue
operator|.
name|ue_loghost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"on %.*s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ue
operator|.
name|ue_logline
argument_list|)
argument_list|,
name|ue
operator|.
name|ue_logline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SecureSys
operator|&&
operator|(
name|ue
operator|.
name|ue_logfails
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"  followed by %d failed attempts\n"
argument_list|,
name|ue
operator|.
name|ue_logfails
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Call ia_success to process successful I/A. 	 */
name|ssent
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|ssent
operator|.
name|uname
operator|=
name|username
expr_stmt|;
name|ssent
operator|.
name|host
operator|=
name|hostname
expr_stmt|;
name|ssent
operator|.
name|ttyn
operator|=
name|ttyn
expr_stmt|;
name|ssent
operator|.
name|caller
operator|=
name|IA_SSHD
expr_stmt|;
name|ssent
operator|.
name|flags
operator|=
name|IA_INTERACTIVE
expr_stmt|;
name|ssent
operator|.
name|ueptr
operator|=
operator|&
name|ue
expr_stmt|;
name|ssent
operator|.
name|jid
operator|=
name|jid
expr_stmt|;
name|ssent
operator|.
name|errcode
operator|=
name|ia_rcode
expr_stmt|;
name|ssent
operator|.
name|us
operator|=
name|NULL
expr_stmt|;
name|ssent
operator|.
name|time
operator|=
literal|1
expr_stmt|;
comment|/* Set ue_logtime */
name|sret
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|sret
operator|.
name|normal
operator|=
literal|0
expr_stmt|;
name|ia_success
argument_list|(
operator|&
name|ssent
argument_list|,
operator|&
name|sret
argument_list|)
expr_stmt|;
comment|/* 	 * Query for account, iff> 1 valid acid& askacid permbit 	 */
if|if
condition|(
operator|(
operator|(
name|ue
operator|.
name|ue_permbits
operator|&
name|PERMBITS_ACCTID
operator|)
operator|||
operator|(
name|ue
operator|.
name|ue_acids
index|[
literal|0
index|]
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ue
operator|.
name|ue_acids
index|[
literal|1
index|]
operator|>=
literal|0
operator|)
operator|)
operator|&&
name|ue
operator|.
name|ue_permbits
operator|&
name|PERMBITS_ASKACID
condition|)
block|{
if|if
condition|(
name|ttyname
argument_list|(
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"cray_setup: ttyname true case, %.100s"
argument_list|,
name|ttyname
argument_list|)
expr_stmt|;
while|while
condition|(
name|valid_acct
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Account (? for available accounts)"
literal|" [%s]: "
argument_list|,
name|acid2nam
argument_list|(
name|ue
operator|.
name|ue_acids
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|acct_name
argument_list|,
name|MAXACID
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|acct_name
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EOF
case|:
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|valid_acct
operator|=
name|ue
operator|.
name|ue_acids
index|[
literal|0
index|]
expr_stmt|;
name|strlcpy
argument_list|(
name|acct_name
argument_list|,
name|acid2nam
argument_list|(
name|valid_acct
argument_list|)
argument_list|,
name|MAXACID
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Print the list 3 wide */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVIDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ue
operator|.
name|ue_acids
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|j
operator|==
literal|4
condition|)
block|{
name|j
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|acid2nam
argument_list|(
name|ue
operator|.
name|ue_acids
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ue
operator|.
name|ue_permbits
operator|&
name|PERMBITS_ACCTID
condition|)
block|{
name|printf
argument_list|(
literal|"\"acctid\" permbit also allows"
literal|" you to select any valid "
literal|"account name.\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|valid_acct
operator|=
name|nam2acid
argument_list|(
name|acct_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_acct
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Account id not found for"
literal|" account name \"%s\"\n\n"
argument_list|,
name|acct_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * If an account was given, search the user's 				 * acids array to verify they can use this account. 				 */
if|if
condition|(
operator|(
name|valid_acct
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|!
operator|(
name|ue
operator|.
name|ue_permbits
operator|&
name|PERMBITS_ACCTID
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVIDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ue
operator|.
name|ue_acids
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|valid_acct
operator|==
name|ue
operator|.
name|ue_acids
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MAXVIDS
operator|||
name|ue
operator|.
name|ue_acids
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot set"
literal|" account name to "
literal|"\"%s\", permission "
literal|"denied\n\n"
argument_list|,
name|acct_name
argument_list|)
expr_stmt|;
name|valid_acct
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * The client isn't connected to a terminal and can't 			 * respond to an acid prompt.  Use default acid. 			 */
name|debug
argument_list|(
literal|"cray_setup: ttyname false case, %.100s"
argument_list|,
name|ttyname
argument_list|)
expr_stmt|;
name|valid_acct
operator|=
name|ue
operator|.
name|ue_acids
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * The user doesn't have the askacid permbit set or 		 * only has one valid account to use. 		 */
name|valid_acct
operator|=
name|ue
operator|.
name|ue_acids
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|acctid
argument_list|(
literal|0
argument_list|,
name|valid_acct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Bad account id: %d\n"
argument_list|,
name|valid_acct
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Now set shares, quotas, limits, including CPU time for the  	 * (interactive) job and process, and set up permissions  	 * (for chown etc), etc. 	 */
if|if
condition|(
name|setshares
argument_list|(
name|ue
operator|.
name|ue_uid
argument_list|,
name|valid_acct
argument_list|,
name|printf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to give %d shares to<%s>(%d/%d)\n"
argument_list|,
name|ue
operator|.
name|ue_shares
argument_list|,
name|ue
operator|.
name|ue_name
argument_list|,
name|ue
operator|.
name|ue_uid
argument_list|,
name|valid_acct
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sr
operator|=
name|setlimits
argument_list|(
name|username
argument_list|,
name|C_PROC
argument_list|,
name|pid
argument_list|,
name|UDBRC_INTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"%.200s"
argument_list|,
name|sr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sr
operator|=
name|setlimits
argument_list|(
name|username
argument_list|,
name|C_JOB
argument_list|,
name|jid
argument_list|,
name|UDBRC_INTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"%.200s"
argument_list|,
name|sr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Place the service provider information into 	 * the session table (Unicos) or job table (Unicos/mk). 	 * There exist double defines for the job/session table in 	 * unicos/mk (jtab.h) so no need for a compile time switch. 	 */
name|memset
argument_list|(
operator|&
name|init_info
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|init_info
argument_list|)
argument_list|)
expr_stmt|;
name|init_info
operator|.
name|s_sessinit
operator|.
name|si_id
operator|=
name|URM_SPT_LOGIN
expr_stmt|;
name|init_info
operator|.
name|s_sessinit
operator|.
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|init_info
operator|.
name|s_sessinit
operator|.
name|si_sid
operator|=
name|jid
expr_stmt|;
name|sesscntl
argument_list|(
literal|0
argument_list|,
name|S_SETSERVPO
argument_list|,
operator|(
name|int
operator|)
operator|&
name|init_info
argument_list|)
expr_stmt|;
comment|/* 	 * Set user and controlling tty security attributes. 	 */
if|if
condition|(
name|SecureSys
condition|)
block|{
if|if
condition|(
name|setusrv
argument_list|(
operator|&
name|usrv
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"setusrv() failed, errno = %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The rc.* and /etc/sdaemon methods of starting a program on unicos/unicosmk  * can have pal privileges that sshd can inherit which  * could allow a user to su to root with out a password.  * This subroutine clears all privileges.  */
end_comment

begin_function
name|void
name|drop_cray_privs
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|_SC_CRAY_PRIV_SU
argument_list|)
name|priv_proc_t
modifier|*
name|privstate
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|extern
name|int
name|priv_set_proc
parameter_list|()
function_decl|;
specifier|extern
name|priv_proc_t
modifier|*
name|priv_init_proc
parameter_list|()
function_decl|;
comment|/* 	 * If ether of theses two flags are not set 	 * then don't allow this version of ssh to run. 	 */
if|if
condition|(
operator|!
name|sysconf
argument_list|(
name|_SC_CRAY_PRIV_SU
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Not PRIV_SU system."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sysconf
argument_list|(
name|_SC_CRAY_POSIX_PRIV
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Not POSIX_PRIV."
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Setting MLS labels."
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|sysconf
argument_list|(
name|_SC_CRAY_SECURE_MAC
argument_list|)
condition|)
block|{
name|usrv
operator|.
name|sv_minlvl
operator|=
name|SYSLOW
expr_stmt|;
name|usrv
operator|.
name|sv_actlvl
operator|=
name|SYSHIGH
expr_stmt|;
name|usrv
operator|.
name|sv_maxlvl
operator|=
name|SYSHIGH
expr_stmt|;
block|}
else|else
block|{
name|usrv
operator|.
name|sv_minlvl
operator|=
name|sysv
operator|.
name|sy_minlvl
expr_stmt|;
name|usrv
operator|.
name|sv_actlvl
operator|=
name|sysv
operator|.
name|sy_minlvl
expr_stmt|;
name|usrv
operator|.
name|sv_maxlvl
operator|=
name|sysv
operator|.
name|sy_maxlvl
expr_stmt|;
block|}
name|usrv
operator|.
name|sv_actcmp
operator|=
literal|0
expr_stmt|;
name|usrv
operator|.
name|sv_valcmp
operator|=
name|sysv
operator|.
name|sy_valcmp
expr_stmt|;
name|usrv
operator|.
name|sv_intcat
operator|=
name|TFM_SYSTEM
expr_stmt|;
name|usrv
operator|.
name|sv_valcat
operator||=
operator|(
name|TFM_SYSTEM
operator||
name|TFM_SYSFILE
operator|)
expr_stmt|;
if|if
condition|(
name|setusrv
argument_list|(
operator|&
name|usrv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"%s(%d): setusrv(): %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|privstate
operator|=
name|priv_init_proc
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|priv_set_proc
argument_list|(
name|privstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"%s(%d): priv_set_proc(): %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|priv_free_proc
argument_list|(
name|privstate
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"Privileges should be cleared..."
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX: do this differently */
error|#
directive|error
error|Cray systems must be run with _SC_CRAY_PRIV_SU on!
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *  Retain utmp/wtmp information - used by cray accounting.  */
end_comment

begin_function
name|void
name|cray_retain_utmp
parameter_list|(
name|struct
name|utmp
modifier|*
name|ut
parameter_list|,
name|int
name|pid
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|utmp
name|utmp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|UTMP_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* XXX use atomicio */
while|while
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|pid
operator|==
name|utmp
operator|.
name|ut_pid
condition|)
block|{
name|ut
operator|->
name|ut_jid
operator|=
name|utmp
operator|.
name|ut_jid
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_tpath
argument_list|,
name|utmp
operator|.
name|ut_tpath
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_tpath
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"Unable to open utmp file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tmpdir support.  */
end_comment

begin_comment
comment|/*  * find and delete jobs tmpdir.  */
end_comment

begin_function
name|void
name|cray_delete_tmpdir
parameter_list|(
name|char
modifier|*
name|login
parameter_list|,
name|int
name|jid
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
specifier|static
name|char
name|jtmp
index|[
name|TPATHSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|child
decl_stmt|,
name|c
decl_stmt|,
name|wstat
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|jtmp
argument_list|,
name|TPATHSIZ
argument_list|,
literal|"%s/jtmp.%06d%c"
argument_list|,
name|JTMPDIR
argument_list|,
name|jid
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|jtmp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
operator|&&
name|statbuf
operator|.
name|st_uid
operator|==
name|uid
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|>
literal|'z'
condition|)
return|return;
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|execl
argument_list|(
name|CLEANTMPCMD
argument_list|,
name|CLEANTMPCMD
argument_list|,
name|login
argument_list|,
name|jtmp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"cray_delete_tmpdir: execl of CLEANTMPCMD failed"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|wstat
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove tmpdir on job termination.  */
end_comment

begin_function
name|void
name|cray_job_termination_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|jid
decl_stmt|;
name|char
modifier|*
name|login
init|=
name|NULL
decl_stmt|;
name|struct
name|jtab
name|jtab
decl_stmt|;
name|debug
argument_list|(
literal|"received signal %d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jid
operator|=
name|waitjob
argument_list|(
operator|&
name|jtab
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|login
operator|=
name|uid2nam
argument_list|(
name|jtab
operator|.
name|j_uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|cray_delete_tmpdir
argument_list|(
name|login
argument_list|,
name|jid
argument_list|,
name|jtab
operator|.
name|j_uid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set job id and create tmpdir directory.  */
end_comment

begin_function
name|void
name|cray_init_job
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|int
name|jid
decl_stmt|;
name|int
name|c
decl_stmt|;
name|jid
operator|=
name|setjob
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|,
name|WJSIGNAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|jid
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"System call setjob failure"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|cray_tmpdir
argument_list|,
name|TPATHSIZ
argument_list|,
literal|"%s/jtmp.%06d%c"
argument_list|,
name|JTMPDIR
argument_list|,
name|jid
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|cray_tmpdir
argument_list|,
name|JTMPMODE
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|chown
argument_list|(
name|cray_tmpdir
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rmdir
argument_list|(
name|cray_tmpdir
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|>
literal|'z'
condition|)
name|cray_tmpdir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cray_set_tmpdir
parameter_list|(
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|int
name|jid
decl_stmt|;
name|struct
name|jtab
name|jbuf
decl_stmt|;
if|if
condition|(
operator|(
name|jid
operator|=
name|getjtab
argument_list|(
operator|&
name|jbuf
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * Set jid and tmpdir in utmp record. 	 */
name|ut
operator|->
name|ut_jid
operator|=
name|jid
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_tpath
argument_list|,
name|cray_tmpdir
argument_list|,
name|TPATHSIZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNICOS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_UNICOSMP
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/*  * Set job id and create tmpdir directory.  */
end_comment

begin_function
name|void
name|cray_init_job
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|initrm_silent
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _UNICOSMP */
end_comment

end_unit

