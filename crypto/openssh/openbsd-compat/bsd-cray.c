begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * $Id: bsd-cray.c,v 1.6 2002/05/15 16:39:51 mouring Exp $  *  * bsd-cray.c  *  * Copyright (c) 2002, Cray Inc.  (Wendy Palm<wendyp@cray.com>)  * Significant portions provided by   *          Wayne Schroeder, SDSC<schroeder@sdsc.edu>  *          William Jones, UTexas<jones@tacc.utexas.edu>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Created: Apr 22 16.34:00 2002 wp  *  * This file contains functions required for proper execution  * on UNICOS systems.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_CRAY
end_ifdef

begin_include
include|#
directive|include
file|<udb.h>
end_include

begin_include
include|#
directive|include
file|<tmpdir.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/category.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/jtab.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/secparm.h>
end_include

begin_include
include|#
directive|include
file|<sys/usrv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sectab.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"bsd-cray.h"
end_include

begin_decl_stmt
name|char
name|cray_tmpdir
index|[
name|TPATHSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* job TMPDIR path */
end_comment

begin_comment
comment|/*  * Functions.  */
end_comment

begin_function_decl
name|void
name|cray_retain_utmp
parameter_list|(
name|struct
name|utmp
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_delete_tmpdir
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_init_job
parameter_list|(
name|struct
name|passwd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cray_set_tmpdir
parameter_list|(
name|struct
name|utmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Orignal written by:  *     Wayne Schroeder  *     San Diego Supercomputer Center  *     schroeder@sdsc.edu */
end_comment

begin_function
name|void
name|cray_setup
parameter_list|(
name|uid_t
name|uid
parameter_list|,
name|char
modifier|*
name|username
parameter_list|)
block|{
name|struct
name|udb
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|setlimits
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|accts
index|[
name|MAXVIDS
index|]
decl_stmt|;
name|int
name|naccts
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|sr
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|struct
name|jtab
name|jbuf
decl_stmt|;
name|int
name|jid
decl_stmt|;
if|if
condition|(
operator|(
name|jid
operator|=
name|getjtab
argument_list|(
operator|&
name|jbuf
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"getjtab: no jid"
argument_list|)
expr_stmt|;
name|err
operator|=
name|setudb
argument_list|()
expr_stmt|;
comment|/* open and rewind the Cray User DataBase */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"UDB open failure"
argument_list|)
expr_stmt|;
name|naccts
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|getudbnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"No UDB entry for %.100s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|p
operator|->
name|ue_uid
condition|)
name|fatal
argument_list|(
literal|"UDB entry %.100s uid(%d) does not match uid %d"
argument_list|,
name|username
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|ue_uid
argument_list|,
operator|(
name|int
operator|)
name|uid
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|p
operator|->
name|ue_acids
index|[
name|j
index|]
operator|!=
operator|-
literal|1
operator|&&
name|j
operator|<
name|MAXVIDS
condition|;
name|j
operator|++
control|)
block|{
name|accts
index|[
name|naccts
index|]
operator|=
name|p
operator|->
name|ue_acids
index|[
name|j
index|]
expr_stmt|;
name|naccts
operator|++
expr_stmt|;
block|}
name|endudb
argument_list|()
expr_stmt|;
comment|/* close the udb */
if|if
condition|(
name|naccts
operator|!=
literal|0
condition|)
block|{
comment|/* Perhaps someday we'll prompt users who have multiple accounts 		   to let them pick one (like CRI's login does), but for now just set 		   the account to the first entry. */
if|if
condition|(
name|acctid
argument_list|(
literal|0
argument_list|,
name|accts
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"System call acctid failed, accts[0]=%d"
argument_list|,
name|accts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now set limits, including CPU time for the (interactive) job and process, 	   and set up permissions (for chown etc), etc.	 This is via an internal CRI 	   routine, setlimits, used by CRI's login. */
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sr
operator|=
name|setlimits
argument_list|(
name|username
argument_list|,
name|C_PROC
argument_list|,
name|pid
argument_list|,
name|UDBRC_INTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%.200s"
argument_list|,
name|sr
argument_list|)
expr_stmt|;
name|sr
operator|=
name|setlimits
argument_list|(
name|username
argument_list|,
name|C_JOB
argument_list|,
name|jid
argument_list|,
name|UDBRC_INTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%.200s"
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The rc.* and /etc/sdaemon methods of starting a program on unicos/unicosmk  * can have pal privileges that sshd can inherit which  * could allow a user to su to root with out a password.  * This subroutine clears all privileges.  */
end_comment

begin_function
name|void
name|drop_cray_privs
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|_SC_CRAY_PRIV_SU
argument_list|)
name|priv_proc_t
modifier|*
name|privstate
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|extern
name|int
name|priv_set_proc
parameter_list|()
function_decl|;
specifier|extern
name|priv_proc_t
modifier|*
name|priv_init_proc
parameter_list|()
function_decl|;
name|struct
name|usrv
name|usrv
decl_stmt|;
comment|/* 	 * If ether of theses two flags are not set 	 * then don't allow this version of ssh to run. 	 */
if|if
condition|(
operator|!
name|sysconf
argument_list|(
name|_SC_CRAY_PRIV_SU
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Not PRIV_SU system."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sysconf
argument_list|(
name|_SC_CRAY_POSIX_PRIV
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Not POSIX_PRIV."
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Dropping privileges."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|usrv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|usrv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setusrv
argument_list|(
operator|&
name|usrv
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s(%d): setusrv(): %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|privstate
operator|=
name|priv_init_proc
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|priv_set_proc
argument_list|(
name|privstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s(%d): priv_set_proc(): %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|priv_free_proc
argument_list|(
name|privstate
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"Privileges should be cleared..."
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX: do this differently */
error|#
directive|error
error|Cray systems must be run with _SC_CRAY_PRIV_SU on!
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *  Retain utmp/wtmp information - used by cray accounting.  */
end_comment

begin_function
name|void
name|cray_retain_utmp
parameter_list|(
name|struct
name|utmp
modifier|*
name|ut
parameter_list|,
name|int
name|pid
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|utmp
name|utmp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|UTMP_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|pid
operator|==
name|utmp
operator|.
name|ut_pid
condition|)
block|{
name|ut
operator|->
name|ut_jid
operator|=
name|utmp
operator|.
name|ut_jid
expr_stmt|;
comment|/* XXX: MIN_SIZEOF here? can this go in loginrec? */
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_tpath
argument_list|,
name|utmp
operator|.
name|ut_tpath
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_tpath
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_host
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_name
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: error message? */
block|}
end_function

begin_comment
comment|/*  * tmpdir support.  */
end_comment

begin_comment
comment|/*  * find and delete jobs tmpdir.  */
end_comment

begin_function
name|void
name|cray_delete_tmpdir
parameter_list|(
name|char
modifier|*
name|login
parameter_list|,
name|int
name|jid
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
name|int
name|child
decl_stmt|;
specifier|static
name|char
name|jtmp
index|[
name|TPATHSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|wstat
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|jtmp
argument_list|,
name|TPATHSIZ
argument_list|,
literal|"%s/jtmp.%06d%c"
argument_list|,
name|JTMPDIR
argument_list|,
name|jid
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|jtmp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
operator|&&
name|statbuf
operator|.
name|st_uid
operator|==
name|uid
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|>
literal|'z'
condition|)
return|return;
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|execl
argument_list|(
name|CLEANTMPCMD
argument_list|,
name|CLEANTMPCMD
argument_list|,
name|login
argument_list|,
name|jtmp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"cray_delete_tmpdir: execl of CLEANTMPCMD failed"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|wstat
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove tmpdir on job termination.  */
end_comment

begin_function
name|void
name|cray_job_termination_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|jid
decl_stmt|;
name|char
modifier|*
name|login
init|=
name|NULL
decl_stmt|;
name|struct
name|jtab
name|jtab
decl_stmt|;
name|debug
argument_list|(
literal|"Received SIG JOB."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jid
operator|=
name|waitjob
argument_list|(
operator|&
name|jtab
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|login
operator|=
name|uid2nam
argument_list|(
name|jtab
operator|.
name|j_uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|cray_delete_tmpdir
argument_list|(
name|login
argument_list|,
name|jid
argument_list|,
name|jtab
operator|.
name|j_uid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set job id and create tmpdir directory.  */
end_comment

begin_function
name|void
name|cray_init_job
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|)
block|{
name|int
name|jid
decl_stmt|;
name|int
name|c
decl_stmt|;
name|jid
operator|=
name|setjob
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|,
name|WJSIGNAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|jid
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"System call setjob failure"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|cray_tmpdir
argument_list|,
name|TPATHSIZ
argument_list|,
literal|"%s/jtmp.%06d%c"
argument_list|,
name|JTMPDIR
argument_list|,
name|jid
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|cray_tmpdir
argument_list|,
name|JTMPMODE
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|chown
argument_list|(
name|cray_tmpdir
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rmdir
argument_list|(
name|cray_tmpdir
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|>
literal|'z'
condition|)
name|cray_tmpdir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cray_set_tmpdir
parameter_list|(
name|struct
name|utmp
modifier|*
name|ut
parameter_list|)
block|{
name|int
name|jid
decl_stmt|;
name|struct
name|jtab
name|jbuf
decl_stmt|;
if|if
condition|(
operator|(
name|jid
operator|=
name|getjtab
argument_list|(
operator|&
name|jbuf
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * Set jid and tmpdir in utmp record. 	 */
name|ut
operator|->
name|ut_jid
operator|=
name|jid
expr_stmt|;
name|strncpy
argument_list|(
name|ut
operator|->
name|ut_tpath
argument_list|,
name|cray_tmpdir
argument_list|,
name|TPATHSIZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

