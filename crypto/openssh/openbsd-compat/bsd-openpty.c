begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Please note: this implementation of openpty() is far from complete.  * it is just enough for portable OpenSSH's needs.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 Damien Miller<djm@mindrot.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Allocating a pseudo-terminal, and making it the controlling tty.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_OPENPTY
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTIL_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTY_H
end_ifdef

begin_include
include|#
directive|include
file|<pty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DEV_PTMX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_STROPTS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|openpty
parameter_list|(
name|int
modifier|*
name|amaster
parameter_list|,
name|int
modifier|*
name|aslave
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|termios
modifier|*
name|termp
parameter_list|,
name|struct
name|winsize
modifier|*
name|winp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE__GETPTY
argument_list|)
comment|/* 	 * _getpty(3) exists in SGI Irix 4.x, 5.x& 6.x -- it generates more 	 * pty's automagically when needed 	 */
name|char
modifier|*
name|slave
decl_stmt|;
if|if
condition|(
operator|(
name|slave
operator|=
name|_getpty
argument_list|(
name|amaster
argument_list|,
name|O_RDWR
argument_list|,
literal|0622
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Open the slave side. */
if|if
condition|(
operator|(
operator|*
name|aslave
operator|=
name|open
argument_list|(
name|slave
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
operator|*
name|amaster
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_DEV_PTMX
argument_list|)
comment|/* 	 * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3 	 * also has bsd-style ptys, but they simply do not work.) 	 */
name|int
name|ptm
decl_stmt|;
name|char
modifier|*
name|pts
decl_stmt|;
name|mysig_t
name|old_signal
decl_stmt|;
if|if
condition|(
operator|(
name|ptm
operator|=
name|open
argument_list|(
literal|"/dev/ptmx"
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* XXX: need to close ptm on error? */
name|old_signal
operator|=
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|grantpt
argument_list|(
name|ptm
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|old_signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlockpt
argument_list|(
name|ptm
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|pts
operator|=
name|ptsname
argument_list|(
name|ptm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|amaster
operator|=
name|ptm
expr_stmt|;
comment|/* Open the slave side. */
if|if
condition|(
operator|(
operator|*
name|aslave
operator|=
name|open
argument_list|(
name|pts
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
operator|*
name|amaster
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|HAVE_CYGWIN
comment|/* 	 * Try to push the appropriate streams modules, as described  	 * in Solaris pts(7). 	 */
name|ioctl
argument_list|(
operator|*
name|aslave
argument_list|,
name|I_PUSH
argument_list|,
literal|"ptem"
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
operator|*
name|aslave
argument_list|,
name|I_PUSH
argument_list|,
literal|"ldterm"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__hpux
name|ioctl
argument_list|(
operator|*
name|aslave
argument_list|,
name|I_PUSH
argument_list|,
literal|"ttcompat"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hpux */
endif|#
directive|endif
comment|/* HAVE_CYGWIN */
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_DEV_PTS_AND_PTC
argument_list|)
comment|/* AIX-style pty code. */
specifier|const
name|char
modifier|*
name|ttname
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|amaster
operator|=
name|open
argument_list|(
literal|"/dev/ptc"
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ttname
operator|=
name|ttyname
argument_list|(
operator|*
name|amaster
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|aslave
operator|=
name|open
argument_list|(
name|ttname
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
operator|*
name|amaster
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_UNICOS
argument_list|)
name|char
name|ptbuf
index|[
literal|64
index|]
decl_stmt|,
name|ttbuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|highpty
decl_stmt|;
name|highpty
operator|=
literal|128
expr_stmt|;
ifdef|#
directive|ifdef
name|_SC_CRAY_NPTY
if|if
condition|(
operator|(
name|highpty
operator|=
name|sysconf
argument_list|(
name|_SC_CRAY_NPTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|highpty
operator|=
literal|128
expr_stmt|;
endif|#
directive|endif
comment|/* _SC_CRAY_NPTY */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|highpty
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|ptbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ptbuf
argument_list|)
argument_list|,
literal|"/dev/pty/%03d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ttbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ttbuf
argument_list|)
argument_list|,
literal|"/dev/ttyp%03d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|amaster
operator|=
name|open
argument_list|(
name|ptbuf
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Open the slave side. */
if|if
condition|(
operator|(
operator|*
name|aslave
operator|=
name|open
argument_list|(
name|ttbuf
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
operator|*
name|amaster
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
comment|/* BSD-style pty code. */
name|char
name|ptbuf
index|[
literal|64
index|]
decl_stmt|,
name|ttbuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptymajors
init|=
literal|"pqrstuvwxyzabcdefghijklmno"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptyminors
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|int
name|num_minors
init|=
name|strlen
argument_list|(
name|ptyminors
argument_list|)
decl_stmt|;
name|int
name|num_ptys
init|=
name|strlen
argument_list|(
name|ptymajors
argument_list|)
operator|*
name|num_minors
decl_stmt|;
name|struct
name|termios
name|tio
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ptys
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|ptbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ptbuf
argument_list|)
argument_list|,
literal|"/dev/pty%c%c"
argument_list|,
name|ptymajors
index|[
name|i
operator|/
name|num_minors
index|]
argument_list|,
name|ptyminors
index|[
name|i
operator|%
name|num_minors
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ttbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ttbuf
argument_list|)
argument_list|,
literal|"/dev/tty%c%c"
argument_list|,
name|ptymajors
index|[
name|i
operator|/
name|num_minors
index|]
argument_list|,
name|ptyminors
index|[
name|i
operator|%
name|num_minors
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|amaster
operator|=
name|open
argument_list|(
name|ptbuf
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Try SCO style naming */
name|snprintf
argument_list|(
name|ptbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ptbuf
argument_list|)
argument_list|,
literal|"/dev/ptyp%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ttbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ttbuf
argument_list|)
argument_list|,
literal|"/dev/ttyp%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|amaster
operator|=
name|open
argument_list|(
name|ptbuf
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
comment|/* Open the slave side. */
if|if
condition|(
operator|(
operator|*
name|aslave
operator|=
name|open
argument_list|(
name|ttbuf
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
operator|*
name|amaster
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* set tty modes to a sane state for broken clients */
if|if
condition|(
name|tcgetattr
argument_list|(
operator|*
name|amaster
argument_list|,
operator|&
name|tio
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tio
operator|.
name|c_lflag
operator||=
operator|(
name|ECHO
operator||
name|ISIG
operator||
name|ICANON
operator|)
expr_stmt|;
name|tio
operator|.
name|c_oflag
operator||=
operator|(
name|OPOST
operator||
name|ONLCR
operator|)
expr_stmt|;
name|tio
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|tcsetattr
argument_list|(
operator|*
name|amaster
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|tio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_OPENPTY) */
end_comment

end_unit

