begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2012 Damien Miller<djm@mindrot.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $OpenBSD: krl.c,v 1.39 2017/03/10 07:18:32 dtucker Exp $ */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<openbsd-compat/sys-tree.h>
end_include

begin_include
include|#
directive|include
file|<openbsd-compat/sys-queue.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"sshbuf.h"
end_include

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_include
include|#
directive|include
file|"sshkey.h"
end_include

begin_include
include|#
directive|include
file|"authfile.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"digest.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"krl.h"
end_include

begin_comment
comment|/* #define DEBUG_KRL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_KRL
end_ifdef

begin_define
define|#
directive|define
name|KRL_DBG
parameter_list|(
name|x
parameter_list|)
value|debug3 x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KRL_DBG
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Trees of revoked serial numbers, key IDs and keys. This allows  * quick searching, querying and producing lists in canonical order.  */
end_comment

begin_comment
comment|/* Tree of serial numbers. XXX make smarter: really need a real sparse bitmap */
end_comment

begin_struct
struct|struct
name|revoked_serial
block|{
name|u_int64_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|revoked_serial
argument_list|)
name|tree_entry
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|serial_cmp
parameter_list|(
name|struct
name|revoked_serial
modifier|*
name|a
parameter_list|,
name|struct
name|revoked_serial
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|revoked_serial_tree
argument_list|,
name|revoked_serial
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|revoked_serial_tree
argument_list|,
name|revoked_serial
argument_list|,
name|tree_entry
argument_list|,
name|serial_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tree of key IDs */
end_comment

begin_struct
struct|struct
name|revoked_key_id
block|{
name|char
modifier|*
name|key_id
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|revoked_key_id
argument_list|)
name|tree_entry
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|key_id_cmp
parameter_list|(
name|struct
name|revoked_key_id
modifier|*
name|a
parameter_list|,
name|struct
name|revoked_key_id
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|revoked_key_id_tree
argument_list|,
name|revoked_key_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|revoked_key_id_tree
argument_list|,
name|revoked_key_id
argument_list|,
name|tree_entry
argument_list|,
name|key_id_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tree of blobs (used for keys and fingerprints) */
end_comment

begin_struct
struct|struct
name|revoked_blob
block|{
name|u_char
modifier|*
name|blob
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|revoked_blob
argument_list|)
name|tree_entry
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|blob_cmp
parameter_list|(
name|struct
name|revoked_blob
modifier|*
name|a
parameter_list|,
name|struct
name|revoked_blob
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|revoked_blob_tree
argument_list|,
name|revoked_blob
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|revoked_blob_tree
argument_list|,
name|revoked_blob
argument_list|,
name|tree_entry
argument_list|,
name|blob_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tracks revoked certs for a single CA */
end_comment

begin_struct
struct|struct
name|revoked_certs
block|{
name|struct
name|sshkey
modifier|*
name|ca_key
decl_stmt|;
name|struct
name|revoked_serial_tree
name|revoked_serials
decl_stmt|;
name|struct
name|revoked_key_id_tree
name|revoked_key_ids
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|revoked_certs
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|revoked_certs_list
argument_list|,
name|revoked_certs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ssh_krl
block|{
name|u_int64_t
name|krl_version
decl_stmt|;
name|u_int64_t
name|generated_date
decl_stmt|;
name|u_int64_t
name|flags
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
name|struct
name|revoked_blob_tree
name|revoked_keys
decl_stmt|;
name|struct
name|revoked_blob_tree
name|revoked_sha1s
decl_stmt|;
name|struct
name|revoked_certs_list
name|revoked_certs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return equal if a and b overlap */
end_comment

begin_function
specifier|static
name|int
name|serial_cmp
parameter_list|(
name|struct
name|revoked_serial
modifier|*
name|a
parameter_list|,
name|struct
name|revoked_serial
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|hi
operator|>=
name|b
operator|->
name|lo
operator|&&
name|a
operator|->
name|lo
operator|<=
name|b
operator|->
name|hi
condition|)
return|return
literal|0
return|;
return|return
name|a
operator|->
name|lo
operator|<
name|b
operator|->
name|lo
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_id_cmp
parameter_list|(
name|struct
name|revoked_key_id
modifier|*
name|a
parameter_list|,
name|struct
name|revoked_key_id
modifier|*
name|b
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|key_id
argument_list|,
name|b
operator|->
name|key_id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|blob_cmp
parameter_list|(
name|struct
name|revoked_blob
modifier|*
name|a
parameter_list|,
name|struct
name|revoked_blob
modifier|*
name|b
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|len
operator|!=
name|b
operator|->
name|len
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|memcmp
argument_list|(
name|a
operator|->
name|blob
argument_list|,
name|b
operator|->
name|blob
argument_list|,
name|MINIMUM
argument_list|(
name|a
operator|->
name|len
argument_list|,
name|b
operator|->
name|len
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
return|return
name|a
operator|->
name|len
operator|>
name|b
operator|->
name|len
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
else|else
return|return
name|memcmp
argument_list|(
name|a
operator|->
name|blob
argument_list|,
name|b
operator|->
name|blob
argument_list|,
name|a
operator|->
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ssh_krl
modifier|*
name|ssh_krl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ssh_krl
modifier|*
name|krl
decl_stmt|;
if|if
condition|(
operator|(
name|krl
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|krl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|RB_INIT
argument_list|(
operator|&
name|krl
operator|->
name|revoked_keys
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|krl
operator|->
name|revoked_sha1s
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|krl
operator|->
name|revoked_certs
argument_list|)
expr_stmt|;
return|return
name|krl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|revoked_certs_free
parameter_list|(
name|struct
name|revoked_certs
modifier|*
name|rc
parameter_list|)
block|{
name|struct
name|revoked_serial
modifier|*
name|rs
decl_stmt|,
modifier|*
name|trs
decl_stmt|;
name|struct
name|revoked_key_id
modifier|*
name|rki
decl_stmt|,
modifier|*
name|trki
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|rs
argument_list|,
argument|revoked_serial_tree
argument_list|,
argument|&rc->revoked_serials
argument_list|,
argument|trs
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|revoked_serial_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
name|RB_FOREACH_SAFE
argument_list|(
argument|rki
argument_list|,
argument|revoked_key_id_tree
argument_list|,
argument|&rc->revoked_key_ids
argument_list|,
argument|trki
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|revoked_key_id_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_key_ids
argument_list|,
name|rki
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rki
operator|->
name|key_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rki
argument_list|)
expr_stmt|;
block|}
name|sshkey_free
argument_list|(
name|rc
operator|->
name|ca_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ssh_krl_free
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|)
block|{
name|struct
name|revoked_blob
modifier|*
name|rb
decl_stmt|,
modifier|*
name|trb
decl_stmt|;
name|struct
name|revoked_certs
modifier|*
name|rc
decl_stmt|,
modifier|*
name|trc
decl_stmt|;
if|if
condition|(
name|krl
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|krl
operator|->
name|comment
argument_list|)
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|rb
argument_list|,
argument|revoked_blob_tree
argument_list|,
argument|&krl->revoked_keys
argument_list|,
argument|trb
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|revoked_blob_tree
argument_list|,
operator|&
name|krl
operator|->
name|revoked_keys
argument_list|,
name|rb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
operator|->
name|blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
argument_list|)
expr_stmt|;
block|}
name|RB_FOREACH_SAFE
argument_list|(
argument|rb
argument_list|,
argument|revoked_blob_tree
argument_list|,
argument|&krl->revoked_sha1s
argument_list|,
argument|trb
argument_list|)
block|{
name|RB_REMOVE
argument_list|(
name|revoked_blob_tree
argument_list|,
operator|&
name|krl
operator|->
name|revoked_sha1s
argument_list|,
name|rb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
operator|->
name|blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rc
argument_list|,
argument|&krl->revoked_certs
argument_list|,
argument|entry
argument_list|,
argument|trc
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|krl
operator|->
name|revoked_certs
argument_list|,
name|rc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|revoked_certs_free
argument_list|(
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ssh_krl_set_version
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
name|u_int64_t
name|version
parameter_list|)
block|{
name|krl
operator|->
name|krl_version
operator|=
name|version
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ssh_krl_set_comment
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|free
argument_list|(
name|krl
operator|->
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|krl
operator|->
name|comment
operator|=
name|strdup
argument_list|(
name|comment
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the revoked_certs struct for a CA key. If allow_create is set then  * create a new one in the tree if one did not exist already.  */
end_comment

begin_function
specifier|static
name|int
name|revoked_certs_for_ca_key
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|ca_key
parameter_list|,
name|struct
name|revoked_certs
modifier|*
modifier|*
name|rcp
parameter_list|,
name|int
name|allow_create
parameter_list|)
block|{
name|struct
name|revoked_certs
modifier|*
name|rc
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|*
name|rcp
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rc
argument_list|,
argument|&krl->revoked_certs
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
operator|(
name|ca_key
operator|==
name|NULL
operator|&&
name|rc
operator|->
name|ca_key
operator|==
name|NULL
operator|)
operator|||
name|sshkey_equal
argument_list|(
name|rc
operator|->
name|ca_key
argument_list|,
name|ca_key
argument_list|)
condition|)
block|{
operator|*
name|rcp
operator|=
name|rc
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|allow_create
condition|)
return|return
literal|0
return|;
comment|/* If this CA doesn't exist in the list then add it now */
if|if
condition|(
operator|(
name|rc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
name|ca_key
operator|==
name|NULL
condition|)
name|rc
operator|->
name|ca_key
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_from_private
argument_list|(
name|ca_key
argument_list|,
operator|&
name|rc
operator|->
name|ca_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|RB_INIT
argument_list|(
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|rc
operator|->
name|revoked_key_ids
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|krl
operator|->
name|revoked_certs
argument_list|,
name|rc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: new CA %s"
operator|,
name|__func__
operator|,
name|ca_key
operator|==
name|NULL
condition|?
literal|"*"
else|:
name|sshkey_type
argument_list|(
name|ca_key
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|rcp
operator|=
name|rc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|insert_serial_range
parameter_list|(
name|struct
name|revoked_serial_tree
modifier|*
name|rt
parameter_list|,
name|u_int64_t
name|lo
parameter_list|,
name|u_int64_t
name|hi
parameter_list|)
block|{
name|struct
name|revoked_serial
name|rs
decl_stmt|,
modifier|*
name|ers
decl_stmt|,
modifier|*
name|crs
decl_stmt|,
modifier|*
name|irs
decl_stmt|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: insert %llu:%llu"
operator|,
name|__func__
operator|,
name|lo
operator|,
name|hi
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|.
name|lo
operator|=
name|lo
expr_stmt|;
name|rs
operator|.
name|hi
operator|=
name|hi
expr_stmt|;
name|ers
operator|=
name|RB_NFIND
argument_list|(
name|revoked_serial_tree
argument_list|,
name|rt
argument_list|,
operator|&
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ers
operator|==
name|NULL
operator|||
name|serial_cmp
argument_list|(
name|ers
argument_list|,
operator|&
name|rs
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* No entry matches. Just insert */
if|if
condition|(
operator|(
name|irs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rs
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|memcpy
argument_list|(
name|irs
argument_list|,
operator|&
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|irs
argument_list|)
argument_list|)
expr_stmt|;
name|ers
operator|=
name|RB_INSERT
argument_list|(
name|revoked_serial_tree
argument_list|,
name|rt
argument_list|,
name|irs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ers
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: bad: ers != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Shouldn't happen */
name|free
argument_list|(
name|irs
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_INTERNAL_ERROR
return|;
block|}
name|ers
operator|=
name|irs
expr_stmt|;
block|}
else|else
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: overlap found %llu:%llu"
operator|,
name|__func__
operator|,
name|ers
operator|->
name|lo
operator|,
name|ers
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The inserted entry overlaps an existing one. Grow the 		 * existing entry. 		 */
if|if
condition|(
name|ers
operator|->
name|lo
operator|>
name|lo
condition|)
name|ers
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|ers
operator|->
name|hi
operator|<
name|hi
condition|)
name|ers
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
block|}
comment|/* 	 * The inserted or revised range might overlap or abut adjacent ones; 	 * coalesce as necessary. 	 */
comment|/* Check predecessors */
while|while
condition|(
operator|(
name|crs
operator|=
name|RB_PREV
argument_list|(
name|revoked_serial_tree
argument_list|,
name|rt
argument_list|,
name|ers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: pred %llu:%llu"
operator|,
name|__func__
operator|,
name|crs
operator|->
name|lo
operator|,
name|crs
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ers
operator|->
name|lo
operator|!=
literal|0
operator|&&
name|crs
operator|->
name|hi
operator|<
name|ers
operator|->
name|lo
operator|-
literal|1
condition|)
break|break;
comment|/* This entry overlaps. */
if|if
condition|(
name|crs
operator|->
name|lo
operator|<
name|ers
operator|->
name|lo
condition|)
block|{
name|ers
operator|->
name|lo
operator|=
name|crs
operator|->
name|lo
expr_stmt|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: pred extend %llu:%llu"
operator|,
name|__func__
operator|,
name|ers
operator|->
name|lo
operator|,
name|ers
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
block|}
name|RB_REMOVE
argument_list|(
name|revoked_serial_tree
argument_list|,
name|rt
argument_list|,
name|crs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|crs
argument_list|)
expr_stmt|;
block|}
comment|/* Check successors */
while|while
condition|(
operator|(
name|crs
operator|=
name|RB_NEXT
argument_list|(
name|revoked_serial_tree
argument_list|,
name|rt
argument_list|,
name|ers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: succ %llu:%llu"
operator|,
name|__func__
operator|,
name|crs
operator|->
name|lo
operator|,
name|crs
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ers
operator|->
name|hi
operator|!=
operator|(
name|u_int64_t
operator|)
operator|-
literal|1
operator|&&
name|crs
operator|->
name|lo
operator|>
name|ers
operator|->
name|hi
operator|+
literal|1
condition|)
break|break;
comment|/* This entry overlaps. */
if|if
condition|(
name|crs
operator|->
name|hi
operator|>
name|ers
operator|->
name|hi
condition|)
block|{
name|ers
operator|->
name|hi
operator|=
name|crs
operator|->
name|hi
expr_stmt|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: succ extend %llu:%llu"
operator|,
name|__func__
operator|,
name|ers
operator|->
name|lo
operator|,
name|ers
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
block|}
name|RB_REMOVE
argument_list|(
name|revoked_serial_tree
argument_list|,
name|rt
argument_list|,
name|crs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|crs
argument_list|)
expr_stmt|;
block|}
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: done, final %llu:%llu"
operator|,
name|__func__
operator|,
name|ers
operator|->
name|lo
operator|,
name|ers
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_revoke_cert_by_serial
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|ca_key
parameter_list|,
name|u_int64_t
name|serial
parameter_list|)
block|{
return|return
name|ssh_krl_revoke_cert_by_serial_range
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
name|serial
argument_list|,
name|serial
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_revoke_cert_by_serial_range
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|ca_key
parameter_list|,
name|u_int64_t
name|lo
parameter_list|,
name|u_int64_t
name|hi
parameter_list|)
block|{
name|struct
name|revoked_certs
modifier|*
name|rc
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|lo
operator|>
name|hi
operator|||
name|lo
operator|==
literal|0
condition|)
return|return
name|SSH_ERR_INVALID_ARGUMENT
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|revoked_certs_for_ca_key
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
operator|&
name|rc
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
return|return
name|insert_serial_range
argument_list|(
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_revoke_cert_by_key_id
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|ca_key
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|)
block|{
name|struct
name|revoked_key_id
modifier|*
name|rki
decl_stmt|,
modifier|*
name|erki
decl_stmt|;
name|struct
name|revoked_certs
modifier|*
name|rc
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|revoked_certs_for_ca_key
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
operator|&
name|rc
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: revoke %s"
operator|,
name|__func__
operator|,
name|key_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rki
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rki
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rki
operator|->
name|key_id
operator|=
name|strdup
argument_list|(
name|key_id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rki
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
block|}
name|erki
operator|=
name|RB_INSERT
argument_list|(
name|revoked_key_id_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_key_ids
argument_list|,
name|rki
argument_list|)
expr_stmt|;
if|if
condition|(
name|erki
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rki
operator|->
name|key_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rki
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert "key" to a public key blob without any certificate information */
end_comment

begin_function
specifier|static
name|int
name|plain_key_blob
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
modifier|*
name|blob
parameter_list|,
name|size_t
modifier|*
name|blen
parameter_list|)
block|{
name|struct
name|sshkey
modifier|*
name|kcopy
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_from_private
argument_list|(
name|key
argument_list|,
operator|&
name|kcopy
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|kcopy
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_drop_cert
argument_list|(
name|kcopy
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshkey_free
argument_list|(
name|kcopy
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
name|r
operator|=
name|sshkey_to_blob
argument_list|(
name|kcopy
argument_list|,
name|blob
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|kcopy
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Revoke a key blob. Ownership of blob is transferred to the tree */
end_comment

begin_function
specifier|static
name|int
name|revoke_blob
parameter_list|(
name|struct
name|revoked_blob_tree
modifier|*
name|rbt
parameter_list|,
name|u_char
modifier|*
name|blob
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|revoked_blob
modifier|*
name|rb
decl_stmt|,
modifier|*
name|erb
decl_stmt|;
if|if
condition|(
operator|(
name|rb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
name|rb
operator|->
name|blob
operator|=
name|blob
expr_stmt|;
name|rb
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|erb
operator|=
name|RB_INSERT
argument_list|(
name|revoked_blob_tree
argument_list|,
name|rbt
argument_list|,
name|rb
argument_list|)
expr_stmt|;
if|if
condition|(
name|erb
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rb
operator|->
name|blob
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_revoke_key_explicit
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
name|u_char
modifier|*
name|blob
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
name|debug3
argument_list|(
literal|"%s: revoke type %s"
argument_list|,
name|__func__
argument_list|,
name|sshkey_type
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|plain_key_blob
argument_list|(
name|key
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
return|return
name|revoke_blob
argument_list|(
operator|&
name|krl
operator|->
name|revoked_keys
argument_list|,
name|blob
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_revoke_key_sha1
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
name|u_char
modifier|*
name|blob
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
name|debug3
argument_list|(
literal|"%s: revoke type %s by sha1"
argument_list|,
name|__func__
argument_list|,
name|sshkey_type
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_fingerprint_raw
argument_list|(
name|key
argument_list|,
name|SSH_DIGEST_SHA1
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
return|return
name|revoke_blob
argument_list|(
operator|&
name|krl
operator|->
name|revoked_sha1s
argument_list|,
name|blob
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_revoke_key
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sshkey_is_cert
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|ssh_krl_revoke_key_sha1
argument_list|(
name|krl
argument_list|,
name|key
argument_list|)
return|;
if|if
condition|(
name|key
operator|->
name|cert
operator|->
name|serial
operator|==
literal|0
condition|)
block|{
return|return
name|ssh_krl_revoke_cert_by_key_id
argument_list|(
name|krl
argument_list|,
name|key
operator|->
name|cert
operator|->
name|signature_key
argument_list|,
name|key
operator|->
name|cert
operator|->
name|key_id
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ssh_krl_revoke_cert_by_serial
argument_list|(
name|krl
argument_list|,
name|key
operator|->
name|cert
operator|->
name|signature_key
argument_list|,
name|key
operator|->
name|cert
operator|->
name|serial
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Select the most compact section type to emit next in a KRL based on  * the current section type, the run length of contiguous revoked serial  * numbers and the gaps from the last and to the next revoked serial.  * Applies a mostly-accurate bit cost model to select the section type  * that will minimise the size of the resultant KRL.  */
end_comment

begin_function
specifier|static
name|int
name|choose_next_state
parameter_list|(
name|int
name|current_state
parameter_list|,
name|u_int64_t
name|contig
parameter_list|,
name|int
name|final
parameter_list|,
name|u_int64_t
name|last_gap
parameter_list|,
name|u_int64_t
name|next_gap
parameter_list|,
name|int
modifier|*
name|force_new_section
parameter_list|)
block|{
name|int
name|new_state
decl_stmt|;
name|u_int64_t
name|cost
decl_stmt|,
name|cost_list
decl_stmt|,
name|cost_range
decl_stmt|,
name|cost_bitmap
decl_stmt|,
name|cost_bitmap_restart
decl_stmt|;
comment|/* 	 * Avoid unsigned overflows. 	 * The limits are high enough to avoid confusing the calculations. 	 */
name|contig
operator|=
name|MINIMUM
argument_list|(
name|contig
argument_list|,
literal|1ULL
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|last_gap
operator|=
name|MINIMUM
argument_list|(
name|last_gap
argument_list|,
literal|1ULL
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|next_gap
operator|=
name|MINIMUM
argument_list|(
name|next_gap
argument_list|,
literal|1ULL
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the cost to switch from the current state to candidates. 	 * NB. range sections only ever contain a single range, so their 	 * switching cost is independent of the current_state. 	 */
name|cost_list
operator|=
name|cost_bitmap
operator|=
name|cost_bitmap_restart
operator|=
literal|0
expr_stmt|;
name|cost_range
operator|=
literal|8
expr_stmt|;
switch|switch
condition|(
name|current_state
condition|)
block|{
case|case
name|KRL_SECTION_CERT_SERIAL_LIST
case|:
name|cost_bitmap_restart
operator|=
name|cost_bitmap
operator|=
literal|8
operator|+
literal|64
expr_stmt|;
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_BITMAP
case|:
name|cost_list
operator|=
literal|8
expr_stmt|;
name|cost_bitmap_restart
operator|=
literal|8
operator|+
literal|64
expr_stmt|;
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_RANGE
case|:
case|case
literal|0
case|:
name|cost_bitmap_restart
operator|=
name|cost_bitmap
operator|=
literal|8
operator|+
literal|64
expr_stmt|;
name|cost_list
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Estimate base cost in bits of each section type */
name|cost_list
operator|+=
literal|64
operator|*
name|contig
operator|+
operator|(
name|final
condition|?
literal|0
else|:
literal|8
operator|+
literal|64
operator|)
expr_stmt|;
name|cost_range
operator|+=
operator|(
literal|2
operator|*
literal|64
operator|)
operator|+
operator|(
name|final
condition|?
literal|0
else|:
literal|8
operator|+
literal|64
operator|)
expr_stmt|;
name|cost_bitmap
operator|+=
name|last_gap
operator|+
name|contig
operator|+
operator|(
name|final
condition|?
literal|0
else|:
name|MINIMUM
argument_list|(
name|next_gap
argument_list|,
literal|8
operator|+
literal|64
argument_list|)
operator|)
expr_stmt|;
name|cost_bitmap_restart
operator|+=
name|contig
operator|+
operator|(
name|final
condition|?
literal|0
else|:
name|MINIMUM
argument_list|(
name|next_gap
argument_list|,
literal|8
operator|+
literal|64
argument_list|)
operator|)
expr_stmt|;
comment|/* Convert to byte costs for actual comparison */
name|cost_list
operator|=
operator|(
name|cost_list
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cost_bitmap
operator|=
operator|(
name|cost_bitmap
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cost_bitmap_restart
operator|=
operator|(
name|cost_bitmap_restart
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|cost_range
operator|=
operator|(
name|cost_range
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* Now pick the best choice */
operator|*
name|force_new_section
operator|=
literal|0
expr_stmt|;
name|new_state
operator|=
name|KRL_SECTION_CERT_SERIAL_BITMAP
expr_stmt|;
name|cost
operator|=
name|cost_bitmap
expr_stmt|;
if|if
condition|(
name|cost_range
operator|<
name|cost
condition|)
block|{
name|new_state
operator|=
name|KRL_SECTION_CERT_SERIAL_RANGE
expr_stmt|;
name|cost
operator|=
name|cost_range
expr_stmt|;
block|}
if|if
condition|(
name|cost_list
operator|<
name|cost
condition|)
block|{
name|new_state
operator|=
name|KRL_SECTION_CERT_SERIAL_LIST
expr_stmt|;
name|cost
operator|=
name|cost_list
expr_stmt|;
block|}
if|if
condition|(
name|cost_bitmap_restart
operator|<
name|cost
condition|)
block|{
name|new_state
operator|=
name|KRL_SECTION_CERT_SERIAL_BITMAP
expr_stmt|;
operator|*
name|force_new_section
operator|=
literal|1
expr_stmt|;
name|cost
operator|=
name|cost_bitmap_restart
expr_stmt|;
block|}
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: contig %llu last_gap %llu next_gap %llu final %d, costs:"
literal|"list %llu range %llu bitmap %llu new bitmap %llu, "
literal|"selected 0x%02x%s"
operator|,
name|__func__
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|contig
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|last_gap
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|next_gap
operator|,
name|final
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|cost_list
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|cost_range
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|cost_bitmap
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|cost_bitmap_restart
operator|,
name|new_state
operator|,
operator|*
name|force_new_section
condition|?
literal|" restart"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
name|new_state
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|put_bitmap
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|bitmap
modifier|*
name|bitmap
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|blob
decl_stmt|;
name|int
name|r
decl_stmt|;
name|len
operator|=
name|bitmap_nbytes
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|blob
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
name|bitmap_to_string
argument_list|(
name|bitmap
argument_list|,
name|blob
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_INTERNAL_ERROR
return|;
block|}
name|r
operator|=
name|sshbuf_put_bignum2_bytes
argument_list|(
name|buf
argument_list|,
name|blob
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Generate a KRL_SECTION_CERTIFICATES KRL section */
end_comment

begin_function
specifier|static
name|int
name|revoked_certs_generate
parameter_list|(
name|struct
name|revoked_certs
modifier|*
name|rc
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|final
decl_stmt|,
name|force_new_sect
decl_stmt|,
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|u_int64_t
name|i
decl_stmt|,
name|contig
decl_stmt|,
name|gap
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|,
name|bitmap_start
init|=
literal|0
decl_stmt|;
name|struct
name|revoked_serial
modifier|*
name|rs
decl_stmt|,
modifier|*
name|nrs
decl_stmt|;
name|struct
name|revoked_key_id
modifier|*
name|rki
decl_stmt|;
name|int
name|next_state
decl_stmt|,
name|state
init|=
literal|0
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|sect
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|bitmap
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|sect
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
comment|/* Store the header: optional CA scope key, reserved */
if|if
condition|(
name|rc
operator|->
name|ca_key
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_puts
argument_list|(
name|rc
operator|->
name|ca_key
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Store the revoked serials.  */
for|for
control|(
name|rs
operator|=
name|RB_MIN
argument_list|(
name|revoked_serial_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|)
init|;
name|rs
operator|!=
name|NULL
condition|;
name|rs
operator|=
name|RB_NEXT
argument_list|(
name|revoked_serial_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|,
name|rs
argument_list|)
control|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: serial %llu:%llu state 0x%02x"
operator|,
name|__func__
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|rs
operator|->
name|lo
operator|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|rs
operator|->
name|hi
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
comment|/* Check contiguous length and gap to next section (if any) */
name|nrs
operator|=
name|RB_NEXT
argument_list|(
name|revoked_serial_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|final
operator|=
name|nrs
operator|==
name|NULL
expr_stmt|;
name|gap
operator|=
name|nrs
operator|==
name|NULL
condition|?
literal|0
else|:
name|nrs
operator|->
name|lo
operator|-
name|rs
operator|->
name|hi
expr_stmt|;
name|contig
operator|=
literal|1
operator|+
operator|(
name|rs
operator|->
name|hi
operator|-
name|rs
operator|->
name|lo
operator|)
expr_stmt|;
comment|/* Choose next state based on these */
name|next_state
operator|=
name|choose_next_state
argument_list|(
name|state
argument_list|,
name|contig
argument_list|,
name|final
argument_list|,
name|state
operator|==
literal|0
condition|?
literal|0
else|:
name|rs
operator|->
name|lo
operator|-
name|last
argument_list|,
name|gap
argument_list|,
operator|&
name|force_new_sect
argument_list|)
expr_stmt|;
comment|/* 		 * If the current section is a range section or has a different 		 * type to the next section, then finish it off now. 		 */
if|if
condition|(
name|state
operator|!=
literal|0
operator|&&
operator|(
name|force_new_sect
operator|||
name|next_state
operator|!=
name|state
operator|||
name|state
operator|==
name|KRL_SECTION_CERT_SERIAL_RANGE
operator|)
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: finish state 0x%02x"
operator|,
name|__func__
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|KRL_SECTION_CERT_SERIAL_LIST
case|:
case|case
name|KRL_SECTION_CERT_SERIAL_RANGE
case|:
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_BITMAP
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|put_bitmap
argument_list|(
name|sect
argument_list|,
name|bitmap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bitmap_free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|state
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|buf
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|sshbuf_reset
argument_list|(
name|sect
argument_list|)
expr_stmt|;
block|}
comment|/* If we are starting a new section then prepare it now */
if|if
condition|(
name|next_state
operator|!=
name|state
operator|||
name|force_new_sect
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: start state 0x%02x"
operator|,
name|__func__
operator|,
name|next_state
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|next_state
expr_stmt|;
name|sshbuf_reset
argument_list|(
name|sect
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|KRL_SECTION_CERT_SERIAL_LIST
case|:
case|case
name|KRL_SECTION_CERT_SERIAL_RANGE
case|:
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_BITMAP
case|:
if|if
condition|(
operator|(
name|bitmap
operator|=
name|bitmap_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bitmap_start
operator|=
name|rs
operator|->
name|lo
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|sect
argument_list|,
name|bitmap_start
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
block|}
comment|/* Perform section-specific processing */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|KRL_SECTION_CERT_SERIAL_LIST
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|contig
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|sect
argument_list|,
name|rs
operator|->
name|lo
operator|+
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_RANGE
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|sect
argument_list|,
name|rs
operator|->
name|lo
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|sect
argument_list|,
name|rs
operator|->
name|hi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_BITMAP
case|:
if|if
condition|(
name|rs
operator|->
name|lo
operator|-
name|bitmap_start
operator|>
name|INT_MAX
condition|)
block|{
name|error
argument_list|(
literal|"%s: insane bitmap gap"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|contig
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bitmap_set_bit
argument_list|(
name|bitmap
argument_list|,
name|rs
operator|->
name|lo
operator|+
name|i
operator|-
name|bitmap_start
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
break|break;
block|}
name|last
operator|=
name|rs
operator|->
name|hi
expr_stmt|;
block|}
comment|/* Flush the remaining section, if any */
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: serial final flush for state 0x%02x"
operator|,
name|__func__
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|KRL_SECTION_CERT_SERIAL_LIST
case|:
case|case
name|KRL_SECTION_CERT_SERIAL_RANGE
case|:
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_BITMAP
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|put_bitmap
argument_list|(
name|sect
argument_list|,
name|bitmap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bitmap_free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|state
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|buf
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: serial done "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Now output a section for any revocations by key ID */
name|sshbuf_reset
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|rki
argument_list|,
argument|revoked_key_id_tree
argument_list|,
argument|&rc->revoked_key_ids
argument_list|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: key ID %s"
operator|,
name|__func__
operator|,
name|rki
operator|->
name|key_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|sect
argument_list|,
name|rki
operator|->
name|key_id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_len
argument_list|(
name|sect
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|KRL_SECTION_CERT_KEY_ID
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|buf
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|bitmap_free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|sect
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_to_blob
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
modifier|*
name|sign_keys
parameter_list|,
name|u_int
name|nsign_keys
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|struct
name|revoked_certs
modifier|*
name|rc
decl_stmt|;
name|struct
name|revoked_blob
modifier|*
name|rb
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|sect
decl_stmt|;
name|u_char
modifier|*
name|sblob
init|=
name|NULL
decl_stmt|;
name|size_t
name|slen
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|krl
operator|->
name|generated_date
operator|==
literal|0
condition|)
name|krl
operator|->
name|generated_date
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sect
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
comment|/* Store the header */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put
argument_list|(
name|buf
argument_list|,
name|KRL_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|KRL_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u32
argument_list|(
name|buf
argument_list|,
name|KRL_FORMAT_VERSION
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|buf
argument_list|,
name|krl
operator|->
name|krl_version
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|buf
argument_list|,
name|krl
operator|->
name|generated_date
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_u64
argument_list|(
name|buf
argument_list|,
name|krl
operator|->
name|flags
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_cstring
argument_list|(
name|buf
argument_list|,
name|krl
operator|->
name|comment
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Store sections for revoked certificates */
name|TAILQ_FOREACH
argument_list|(
argument|rc
argument_list|,
argument|&krl->revoked_certs
argument_list|,
argument|entry
argument_list|)
block|{
name|sshbuf_reset
argument_list|(
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|revoked_certs_generate
argument_list|(
name|rc
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|KRL_SECTION_CERTIFICATES
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|buf
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Finally, output sections for revocations by public key/hash */
name|sshbuf_reset
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|rb
argument_list|,
argument|revoked_blob_tree
argument_list|,
argument|&krl->revoked_keys
argument_list|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: key len %zu "
operator|,
name|__func__
operator|,
name|rb
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|sect
argument_list|,
name|rb
operator|->
name|blob
argument_list|,
name|rb
operator|->
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_len
argument_list|(
name|sect
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|KRL_SECTION_EXPLICIT_KEY
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|buf
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|sshbuf_reset
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|rb
argument_list|,
argument|revoked_blob_tree
argument_list|,
argument|&krl->revoked_sha1s
argument_list|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: hash len %zu "
operator|,
name|__func__
operator|,
name|rb
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|sect
argument_list|,
name|rb
operator|->
name|blob
argument_list|,
name|rb
operator|->
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_len
argument_list|(
name|sect
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|KRL_SECTION_FINGERPRINT_SHA1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_put_stringb
argument_list|(
name|buf
argument_list|,
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsign_keys
condition|;
name|i
operator|++
control|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: signature key %s"
operator|,
name|__func__
operator|,
name|sshkey_ssh_name
argument_list|(
name|sign_keys
index|[
name|i
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_u8
argument_list|(
name|buf
argument_list|,
name|KRL_SECTION_SIGNATURE
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshkey_puts
argument_list|(
name|sign_keys
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_sign
argument_list|(
name|sign_keys
index|[
name|i
index|]
argument_list|,
operator|&
name|sblob
argument_list|,
operator|&
name|slen
argument_list|,
name|sshbuf_ptr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: signature sig len %zu"
operator|,
name|__func__
operator|,
name|slen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_put_string
argument_list|(
name|buf
argument_list|,
name|sblob
argument_list|,
name|slen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|sblob
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|sect
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|format_timestamp
parameter_list|(
name|u_int64_t
name|timestamp
parameter_list|,
name|char
modifier|*
name|ts
parameter_list|,
name|size_t
name|nts
parameter_list|)
block|{
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|t
operator|=
name|timestamp
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|ts
argument_list|,
literal|"<INVALID>"
argument_list|,
name|nts
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|ts
operator|=
literal|'\0'
expr_stmt|;
name|strftime
argument_list|(
name|ts
argument_list|,
name|nts
argument_list|,
literal|"%Y%m%dT%H%M%S"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|parse_revoked_certs
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|)
block|{
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|;
name|u_char
name|type
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|blob
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|nbits
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|subsect
init|=
name|NULL
decl_stmt|;
name|u_int64_t
name|serial
decl_stmt|,
name|serial_lo
decl_stmt|,
name|serial_hi
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|bitmap
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|key_id
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|ca_key
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|subsect
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
comment|/* Header: key, reserved */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|buf
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|blen
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_skip_string
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|blen
operator|!=
literal|0
operator|&&
operator|(
name|r
operator|=
name|sshkey_from_blob
argument_list|(
name|blob
argument_list|,
name|blen
argument_list|,
operator|&
name|ca_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sshbuf_free
argument_list|(
name|subsect
argument_list|)
expr_stmt|;
name|subsect
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|buf
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_froms
argument_list|(
name|buf
argument_list|,
operator|&
name|subsect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: subsection type 0x%02x"
operator|,
name|__func__
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
comment|/* sshbuf_dump(subsect, stderr); */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KRL_SECTION_CERT_SERIAL_LIST
case|:
while|while
condition|(
name|sshbuf_len
argument_list|(
name|subsect
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|subsect
argument_list|,
operator|&
name|serial
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_krl_revoke_cert_by_serial
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
name|serial
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_RANGE
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|subsect
argument_list|,
operator|&
name|serial_lo
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|subsect
argument_list|,
operator|&
name|serial_hi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_krl_revoke_cert_by_serial_range
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
name|serial_lo
argument_list|,
name|serial_hi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KRL_SECTION_CERT_SERIAL_BITMAP
case|:
if|if
condition|(
operator|(
name|bitmap
operator|=
name|bitmap_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|subsect
argument_list|,
operator|&
name|serial_lo
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_bignum2_bytes_direct
argument_list|(
name|subsect
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|blen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|bitmap_from_string
argument_list|(
name|bitmap
argument_list|,
name|blob
argument_list|,
name|blen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nbits
operator|=
name|bitmap_nbits
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
for|for
control|(
name|serial
operator|=
literal|0
init|;
name|serial
operator|<
operator|(
name|u_int64_t
operator|)
name|nbits
condition|;
name|serial
operator|++
control|)
block|{
if|if
condition|(
name|serial
operator|>
literal|0
operator|&&
name|serial_lo
operator|+
name|serial
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: bitmap wraps u64"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|bitmap_test_bit
argument_list|(
name|bitmap
argument_list|,
name|serial
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_krl_revoke_cert_by_serial
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
name|serial_lo
operator|+
name|serial
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|bitmap_free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|KRL_SECTION_CERT_KEY_ID
case|:
while|while
condition|(
name|sshbuf_len
argument_list|(
name|subsect
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|subsect
argument_list|,
operator|&
name|key_id
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_krl_revoke_cert_by_key_id
argument_list|(
name|krl
argument_list|,
name|ca_key
argument_list|,
name|key_id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|free
argument_list|(
name|key_id
argument_list|)
expr_stmt|;
name|key_id
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Unsupported KRL certificate section %u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_len
argument_list|(
name|subsect
argument_list|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"KRL certificate section contains unparsed data"
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|bitmap
operator|!=
name|NULL
condition|)
name|bitmap_free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key_id
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|ca_key
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|subsect
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Attempt to parse a KRL, checking its signature (if any) with sign_ca_keys. */
end_comment

begin_function
name|int
name|ssh_krl_from_blob
parameter_list|(
name|struct
name|sshbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|ssh_krl
modifier|*
modifier|*
name|krlp
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
modifier|*
name|sign_ca_keys
parameter_list|,
name|size_t
name|nsign_ca_keys
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|copy
init|=
name|NULL
decl_stmt|,
modifier|*
name|sect
init|=
name|NULL
decl_stmt|;
name|struct
name|ssh_krl
modifier|*
name|krl
init|=
name|NULL
decl_stmt|;
name|char
name|timestamp
index|[
literal|64
index|]
decl_stmt|;
name|int
name|r
init|=
name|SSH_ERR_INTERNAL_ERROR
decl_stmt|,
name|sig_seen
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|ca_used
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tmp_ca_used
decl_stmt|;
name|u_char
name|type
decl_stmt|,
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|blob
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sig_off
decl_stmt|,
name|sects_off
decl_stmt|,
name|rlen
decl_stmt|,
name|blen
decl_stmt|,
name|nca_used
decl_stmt|;
name|u_int
name|format_version
decl_stmt|;
name|nca_used
operator|=
literal|0
expr_stmt|;
operator|*
name|krlp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|KRL_MAGIC
argument_list|)
operator|-
literal|1
operator|||
name|memcmp
argument_list|(
name|sshbuf_ptr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|KRL_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|KRL_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug3
argument_list|(
literal|"%s: not a KRL"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_KRL_BAD_MAGIC
return|;
block|}
comment|/* Take a copy of the KRL buffer so we can verify its signature later */
if|if
condition|(
operator|(
name|copy
operator|=
name|sshbuf_fromb
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_consume
argument_list|(
name|copy
argument_list|,
sizeof|sizeof
argument_list|(
name|KRL_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|krl
operator|=
name|ssh_krl_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: alloc failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u32
argument_list|(
name|copy
argument_list|,
operator|&
name|format_version
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|format_version
operator|!=
name|KRL_FORMAT_VERSION
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|copy
argument_list|,
operator|&
name|krl
operator|->
name|krl_version
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|copy
argument_list|,
operator|&
name|krl
operator|->
name|generated_date
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_u64
argument_list|(
name|copy
argument_list|,
operator|&
name|krl
operator|->
name|flags
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_skip_string
argument_list|(
name|copy
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_cstring
argument_list|(
name|copy
argument_list|,
operator|&
name|krl
operator|->
name|comment
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|format_timestamp
argument_list|(
name|krl
operator|->
name|generated_date
argument_list|,
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"KRL version %llu generated at %s%s%s"
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|krl
operator|->
name|krl_version
argument_list|,
name|timestamp
argument_list|,
operator|*
name|krl
operator|->
name|comment
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|krl
operator|->
name|comment
argument_list|)
expr_stmt|;
comment|/* 	 * 1st pass: verify signatures, if any. This is done to avoid 	 * detailed parsing of data whose provenance is unverified. 	 */
name|sig_seen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
operator|<
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
condition|)
block|{
comment|/* Shouldn't happen */
name|r
operator|=
name|SSH_ERR_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sects_off
operator|=
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
operator|-
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
expr_stmt|;
while|while
condition|(
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|copy
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|copy
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|blen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: first pass, section 0x%02x"
operator|,
name|__func__
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|KRL_SECTION_SIGNATURE
condition|)
block|{
if|if
condition|(
name|sig_seen
condition|)
block|{
name|error
argument_list|(
literal|"KRL contains non-signature section "
literal|"after signature"
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Not interested for now. */
continue|continue;
block|}
name|sig_seen
operator|=
literal|1
expr_stmt|;
comment|/* First string component is the signing key */
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_from_blob
argument_list|(
name|blob
argument_list|,
name|blen
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
operator|<
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
condition|)
block|{
comment|/* Shouldn't happen */
name|r
operator|=
name|SSH_ERR_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sig_off
operator|=
name|sshbuf_len
argument_list|(
name|buf
argument_list|)
operator|-
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
expr_stmt|;
comment|/* Second string component is the signature itself */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string_direct
argument_list|(
name|copy
argument_list|,
operator|&
name|blob
argument_list|,
operator|&
name|blen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check signature over entire KRL up to this point */
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_verify
argument_list|(
name|key
argument_list|,
name|blob
argument_list|,
name|blen
argument_list|,
name|sshbuf_ptr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sig_off
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Check if this key has already signed this KRL */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nca_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sshkey_equal
argument_list|(
name|ca_used
index|[
name|i
index|]
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"KRL signed more than once with "
literal|"the same key"
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Record keys used to sign the KRL */
name|tmp_ca_used
operator|=
name|reallocarray
argument_list|(
name|ca_used
argument_list|,
name|nca_used
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ca_used
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_ca_used
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ca_used
operator|=
name|tmp_ca_used
expr_stmt|;
name|ca_used
index|[
name|nca_used
operator|++
index|]
operator|=
name|key
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Shouldn't happen */
name|r
operator|=
name|SSH_ERR_INTERNAL_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * 2nd pass: parse and load the KRL, skipping the header to the point 	 * where the section start. 	 */
name|sshbuf_free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|copy
operator|=
name|sshbuf_fromb
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|SSH_ERR_ALLOC_FAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_consume
argument_list|(
name|copy
argument_list|,
name|sects_off
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|sshbuf_len
argument_list|(
name|copy
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sshbuf_free
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|sect
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|copy
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_froms
argument_list|(
name|copy
argument_list|,
operator|&
name|sect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: second pass, section 0x%02x"
operator|,
name|__func__
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KRL_SECTION_CERTIFICATES
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|parse_revoked_certs
argument_list|(
name|sect
argument_list|,
name|krl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|KRL_SECTION_EXPLICIT_KEY
case|:
case|case
name|KRL_SECTION_FINGERPRINT_SHA1
case|:
while|while
condition|(
name|sshbuf_len
argument_list|(
name|sect
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_string
argument_list|(
name|sect
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|rlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|type
operator|==
name|KRL_SECTION_FINGERPRINT_SHA1
operator|&&
name|rlen
operator|!=
literal|20
condition|)
block|{
name|error
argument_list|(
literal|"%s: bad SHA1 length"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|revoke_blob
argument_list|(
name|type
operator|==
name|KRL_SECTION_EXPLICIT_KEY
condition|?
operator|&
name|krl
operator|->
name|revoked_keys
else|:
operator|&
name|krl
operator|->
name|revoked_sha1s
argument_list|,
name|rdata
argument_list|,
name|rlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|rdata
operator|=
name|NULL
expr_stmt|;
comment|/* revoke_blob frees rdata */
block|}
break|break;
case|case
name|KRL_SECTION_SIGNATURE
case|:
comment|/* Handled above, but still need to stay in synch */
name|sshbuf_free
argument_list|(
name|sect
argument_list|)
expr_stmt|;
name|sect
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_skip_string
argument_list|(
name|copy
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unsupported KRL section %u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sect
operator|!=
name|NULL
operator|&&
name|sshbuf_len
argument_list|(
name|sect
argument_list|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"KRL section contains unparsed data"
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_INVALID_FORMAT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Check that the key(s) used to sign the KRL weren't revoked */
name|sig_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nca_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ssh_krl_check_key
argument_list|(
name|krl
argument_list|,
name|ca_used
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|sig_seen
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sshkey_free
argument_list|(
name|ca_used
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ca_used
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nca_used
operator|&&
operator|!
name|sig_seen
condition|)
block|{
name|error
argument_list|(
literal|"All keys used to sign KRL were revoked"
argument_list|)
expr_stmt|;
name|r
operator|=
name|SSH_ERR_KEY_REVOKED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If we have CA keys, then verify that one was used to sign the KRL */
if|if
condition|(
name|sig_seen
operator|&&
name|nsign_ca_keys
operator|!=
literal|0
condition|)
block|{
name|sig_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|sig_seen
operator|&&
name|i
operator|<
name|nsign_ca_keys
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nca_used
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ca_used
index|[
name|j
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sshkey_equal
argument_list|(
name|ca_used
index|[
name|j
index|]
argument_list|,
name|sign_ca_keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sig_seen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sig_seen
condition|)
block|{
name|r
operator|=
name|SSH_ERR_SIGNATURE_INVALID
expr_stmt|;
name|error
argument_list|(
literal|"KRL not signed with any trusted key"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
operator|*
name|krlp
operator|=
name|krl
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|ssh_krl_free
argument_list|(
name|krl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nca_used
condition|;
name|i
operator|++
control|)
name|sshkey_free
argument_list|(
name|ca_used
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ca_used
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rdata
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|sect
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Checks certificate serial number and key ID revocation */
end_comment

begin_function
specifier|static
name|int
name|is_cert_revoked
parameter_list|(
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|,
name|struct
name|revoked_certs
modifier|*
name|rc
parameter_list|)
block|{
name|struct
name|revoked_serial
name|rs
decl_stmt|,
modifier|*
name|ers
decl_stmt|;
name|struct
name|revoked_key_id
name|rki
decl_stmt|,
modifier|*
name|erki
decl_stmt|;
comment|/* Check revocation by cert key ID */
name|memset
argument_list|(
operator|&
name|rki
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rki
argument_list|)
argument_list|)
expr_stmt|;
name|rki
operator|.
name|key_id
operator|=
name|key
operator|->
name|cert
operator|->
name|key_id
expr_stmt|;
name|erki
operator|=
name|RB_FIND
argument_list|(
name|revoked_key_id_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_key_ids
argument_list|,
operator|&
name|rki
argument_list|)
expr_stmt|;
if|if
condition|(
name|erki
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: revoked by key ID"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_KEY_REVOKED
return|;
block|}
comment|/* 	 * Zero serials numbers are ignored (it's the default when the 	 * CA doesn't specify one). 	 */
if|if
condition|(
name|key
operator|->
name|cert
operator|->
name|serial
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|rs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|.
name|lo
operator|=
name|rs
operator|.
name|hi
operator|=
name|key
operator|->
name|cert
operator|->
name|serial
expr_stmt|;
name|ers
operator|=
name|RB_FIND
argument_list|(
name|revoked_serial_tree
argument_list|,
operator|&
name|rc
operator|->
name|revoked_serials
argument_list|,
operator|&
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ers
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: revoked serial %llu matched %llu:%llu"
operator|,
name|__func__
operator|,
name|key
operator|->
name|cert
operator|->
name|serial
operator|,
name|ers
operator|->
name|lo
operator|,
name|ers
operator|->
name|hi
operator|)
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_KEY_REVOKED
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Checks whether a given key/cert is revoked. Does not check its CA */
end_comment

begin_function
specifier|static
name|int
name|is_key_revoked
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|revoked_blob
name|rb
decl_stmt|,
modifier|*
name|erb
decl_stmt|;
name|struct
name|revoked_certs
modifier|*
name|rc
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Check explicitly revoked hashes first */
name|memset
argument_list|(
operator|&
name|rb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_fingerprint_raw
argument_list|(
name|key
argument_list|,
name|SSH_DIGEST_SHA1
argument_list|,
operator|&
name|rb
operator|.
name|blob
argument_list|,
operator|&
name|rb
operator|.
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
name|erb
operator|=
name|RB_FIND
argument_list|(
name|revoked_blob_tree
argument_list|,
operator|&
name|krl
operator|->
name|revoked_sha1s
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
operator|.
name|blob
argument_list|)
expr_stmt|;
if|if
condition|(
name|erb
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: revoked by key SHA1"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_KEY_REVOKED
return|;
block|}
comment|/* Next, explicit keys */
name|memset
argument_list|(
operator|&
name|rb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|plain_key_blob
argument_list|(
name|key
argument_list|,
operator|&
name|rb
operator|.
name|blob
argument_list|,
operator|&
name|rb
operator|.
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
name|erb
operator|=
name|RB_FIND
argument_list|(
name|revoked_blob_tree
argument_list|,
operator|&
name|krl
operator|->
name|revoked_keys
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rb
operator|.
name|blob
argument_list|)
expr_stmt|;
if|if
condition|(
name|erb
operator|!=
name|NULL
condition|)
block|{
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: revoked by explicit key"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
name|SSH_ERR_KEY_REVOKED
return|;
block|}
if|if
condition|(
operator|!
name|sshkey_is_cert
argument_list|(
name|key
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check cert revocation for the specified CA */
if|if
condition|(
operator|(
name|r
operator|=
name|revoked_certs_for_ca_key
argument_list|(
name|krl
argument_list|,
name|key
operator|->
name|cert
operator|->
name|signature_key
argument_list|,
operator|&
name|rc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|rc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|is_cert_revoked
argument_list|(
name|key
argument_list|,
name|rc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
block|}
comment|/* Check cert revocation for the wildcard CA */
if|if
condition|(
operator|(
name|r
operator|=
name|revoked_certs_for_ca_key
argument_list|(
name|krl
argument_list|,
name|NULL
argument_list|,
operator|&
name|rc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|rc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|is_cert_revoked
argument_list|(
name|key
argument_list|,
name|rc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
block|}
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: %llu no match"
operator|,
name|__func__
operator|,
name|key
operator|->
name|cert
operator|->
name|serial
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_check_key
parameter_list|(
name|struct
name|ssh_krl
modifier|*
name|krl
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: checking key"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|is_key_revoked
argument_list|(
name|krl
argument_list|,
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|sshkey_is_cert
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: checking CA key"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|is_key_revoked
argument_list|(
name|krl
argument_list|,
name|key
operator|->
name|cert
operator|->
name|signature_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
block|}
name|KRL_DBG
argument_list|(
operator|(
literal|"%s: key okay"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ssh_krl_file_contains_key
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|struct
name|sshkey
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|sshbuf
modifier|*
name|krlbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|ssh_krl
modifier|*
name|krl
init|=
name|NULL
decl_stmt|;
name|int
name|oerrno
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|krlbuf
operator|=
name|sshbuf_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|SSH_ERR_ALLOC_FAIL
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|r
operator|=
name|SSH_ERR_SYSTEM_ERROR
expr_stmt|;
name|oerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_load_file
argument_list|(
name|fd
argument_list|,
name|krlbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_krl_from_blob
argument_list|(
name|krlbuf
argument_list|,
operator|&
name|krl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|debug2
argument_list|(
literal|"%s: checking KRL %s"
argument_list|,
name|__func__
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|r
operator|=
name|ssh_krl_check_key
argument_list|(
name|krl
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|krlbuf
argument_list|)
expr_stmt|;
name|ssh_krl_free
argument_list|(
name|krl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|errno
operator|=
name|oerrno
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

end_unit

