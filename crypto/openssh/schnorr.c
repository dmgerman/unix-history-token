begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: schnorr.c,v 1.8 2013/11/08 00:39:15 djm Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 Damien Miller.  All rights reserved.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Implementation of Schnorr signatures / zero-knowledge proofs, based on  * description in:  * 	  * F. Hao, P. Ryan, "Password Authenticated Key Exchange by Juggling",  * 16th Workshop on Security Protocols, Cambridge, April 2008  *  * http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"schnorr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JPAKE
end_ifdef

begin_include
include|#
directive|include
file|"openbsd-compat/openssl-compat.h"
end_include

begin_comment
comment|/* #define SCHNORR_DEBUG */
end_comment

begin_comment
comment|/* Privacy-violating debugging */
end_comment

begin_comment
comment|/* #define SCHNORR_MAIN */
end_comment

begin_comment
comment|/* Include main() selftest */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCHNORR_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BN
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BUF
parameter_list|(
name|a
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BN
parameter_list|(
name|a
parameter_list|)
value|debug3_bn a
end_define

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BUF
parameter_list|(
name|a
parameter_list|)
value|debug3_buf a
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCHNORR_DEBUG */
end_comment

begin_comment
comment|/*  * Calculate hash component of Schnorr signature H(g || g^v || g^x || id)  * using the hash function defined by "evp_md". Returns signature as  * bignum or NULL on error.  */
end_comment

begin_function
specifier|static
name|BIGNUM
modifier|*
name|schnorr_hash
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|evp_md
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_v
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|)
block|{
name|u_char
modifier|*
name|digest
decl_stmt|;
name|u_int
name|digest_len
decl_stmt|;
name|BIGNUM
modifier|*
name|h
decl_stmt|;
name|Buffer
name|b
decl_stmt|;
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* h = H(g || p || q || g^v || g^x || id) */
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g_v
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g_x
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BUF
argument_list|(
operator|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
operator|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|,
literal|"%s: hashblob"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_buffer
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|evp_md
argument_list|,
operator|&
name|digest
argument_list|,
operator|&
name|digest_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: hash_buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_bin2bn
argument_list|(
name|digest
argument_list|,
operator|(
name|int
operator|)
name|digest_len
argument_list|,
name|h
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_bin2bn"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|success
operator|=
literal|0
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|h
operator|,
literal|"%s: h = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|digest
argument_list|,
name|digest_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|digest
argument_list|)
expr_stmt|;
name|digest_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|0
condition|)
return|return
name|h
return|;
name|BN_clear_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Schnorr signature to prove knowledge of private value 'x' used  * in public exponent g^x, under group defined by 'grp_p', 'grp_q' and 'grp_g'  * using the hash function "evp_md".  * 'idlen' bytes from 'id' will be included in the signature hash as an anti-  * replay salt.  *   * On success, 0 is returned. The signature values are returned as *e_p  * (g^v mod p) and *r_p (v - xh mod q). The caller must free these values.  * On failure, -1 is returned.  */
end_comment

begin_function
name|int
name|schnorr_sign
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|evp_md
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|r_p
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|e_p
parameter_list|)
block|{
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
name|BIGNUM
modifier|*
name|h
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|g_v
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|x
operator|,
literal|"%s: x = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_x
operator|,
literal|"%s: g_x = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Avoid degenerate cases: g^0 yields a spoofable signature */
if|if
condition|(
name|BN_cmp
argument_list|(
name|g_x
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: g_x< 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
name|g_x
argument_list|,
name|grp_p
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: g_x> g"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|h
operator|=
name|g_v
operator|=
name|r
operator|=
name|tmp
operator|=
name|v
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|g_v
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tmp
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * v must be a random element of Zq, so 1<= v< q 	 * we also exclude v = 1, since g^1 looks dangerous 	 */
if|if
condition|(
operator|(
name|v
operator|=
name|bn_rand_range_gt_one
argument_list|(
name|grp_p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: bn_rand_range2"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|v
operator|,
literal|"%s: v = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* g_v = g^v mod p */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_v
argument_list|,
name|grp_g
argument_list|,
name|v
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g^v mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_v
operator|,
literal|"%s: g_v = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* h = H(g || g^v || g^x || id) */
if|if
condition|(
operator|(
name|h
operator|=
name|schnorr_hash
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|evp_md
argument_list|,
name|g_v
argument_list|,
name|g_x
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: schnorr_hash failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* r = v - xh mod q */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|x
argument_list|,
name|h
argument_list|,
name|grp_q
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_mul (tmp = xv mod q)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_mod_sub
argument_list|(
name|r
argument_list|,
name|v
argument_list|,
name|tmp
argument_list|,
name|grp_q
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_mul (r = v - tmp)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_v
operator|,
literal|"%s: e = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|r
operator|,
literal|"%s: r = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|e_p
operator|=
name|g_v
expr_stmt|;
operator|*
name|r_p
operator|=
name|r
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Schnorr signature to prove knowledge of private value 'x' used  * in public exponent g^x, under group defined by 'grp_p', 'grp_q' and 'grp_g'  * using a SHA256 hash.  * 'idlen' bytes from 'id' will be included in the signature hash as an anti-  * replay salt.  * On success, 0 is returned and *siglen bytes of signature are returned in  * *sig (caller to free). Returns -1 on failure.  */
end_comment

begin_function
name|int
name|schnorr_sign_buf
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|,
name|u_char
modifier|*
modifier|*
name|sig
parameter_list|,
name|u_int
modifier|*
name|siglen
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|schnorr_sign
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|,
name|x
argument_list|,
name|g_x
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Signature is (e, r) */
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* XXX sigtype-hash as string? */
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|siglen
operator|=
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
operator|*
name|sig
operator|=
name|xmalloc
argument_list|(
operator|*
name|siglen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|sig
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
operator|*
name|siglen
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BUF
argument_list|(
operator|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
operator|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|,
literal|"%s: sigblob"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Verify Schnorr signature { r (v - xh mod q), e (g^v mod p) } against  * public exponent g_x (g^x) under group defined by 'grp_p', 'grp_q' and  * 'grp_g' using hash "evp_md".  * Signature hash will be salted with 'idlen' bytes from 'id'.  * Returns -1 on failure, 0 on incorrect signature or 1 on matching signature.  */
end_comment

begin_function
name|int
name|schnorr_verify
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|evp_md
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|r
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|e
parameter_list|)
block|{
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
name|BIGNUM
modifier|*
name|h
init|=
name|NULL
decl_stmt|,
modifier|*
name|g_xh
init|=
name|NULL
decl_stmt|,
modifier|*
name|g_r
init|=
name|NULL
decl_stmt|,
modifier|*
name|gx_q
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|expected
init|=
name|NULL
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_x
operator|,
literal|"%s: g_x = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Avoid degenerate cases: g^0 yields a spoofable signature */
if|if
condition|(
name|BN_cmp
argument_list|(
name|g_x
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: g_x<= 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
name|g_x
argument_list|,
name|grp_p
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: g_x>= p"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|h
operator|=
name|g_xh
operator|=
name|g_r
operator|=
name|expected
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|g_xh
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|g_r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|gx_q
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|expected
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|e
operator|,
literal|"%s: e = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|r
operator|,
literal|"%s: r = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* gx_q = (g^x)^q must === 1 mod p */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|gx_q
argument_list|,
name|g_x
argument_list|,
name|grp_q
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g_x^q mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_cmp
argument_list|(
name|gx_q
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: Invalid signature (g^x)^q != 1 mod p"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_xh
operator|,
literal|"%s: g_xh = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* h = H(g || g^v || g^x || id) */
if|if
condition|(
operator|(
name|h
operator|=
name|schnorr_hash
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|evp_md
argument_list|,
name|e
argument_list|,
name|g_x
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: schnorr_hash failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* g_xh = (g^x)^h */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_xh
argument_list|,
name|g_x
argument_list|,
name|h
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g_x^h mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_xh
operator|,
literal|"%s: g_xh = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* g_r = g^r */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_r
argument_list|,
name|grp_g
argument_list|,
name|r
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g_x^h mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_r
operator|,
literal|"%s: g_r = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* expected = g^r * g_xh */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|expected
argument_list|,
name|g_r
argument_list|,
name|g_xh
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_mul (expected = g_r mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|expected
operator|,
literal|"%s: expected = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Check e == expected */
name|success
operator|=
name|BN_cmp
argument_list|(
name|expected
argument_list|,
name|e
argument_list|)
operator|==
literal|0
expr_stmt|;
name|out
label|:
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx_q
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|gx_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_xh
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|g_xh
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_r
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|g_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Verify Schnorr signature 'sig' of length 'siglen' against public exponent  * g_x (g^x) under group defined by 'grp_p', 'grp_q' and 'grp_g' using a  * SHA256 hash.  * Signature hash will be salted with 'idlen' bytes from 'id'.  * Returns -1 on failure, 0 on incorrect signature or 1 on matching signature.  */
end_comment

begin_function
name|int
name|schnorr_verify_buf
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sig
parameter_list|,
name|u_int
name|siglen
parameter_list|)
block|{
name|Buffer
name|b
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|r
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Extract g^v and r from signature blob */
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BUF
argument_list|(
operator|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
operator|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|,
literal|"%s: sigblob"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|buffer_get_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|buffer_get_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: remaining bytes in signature %d"
argument_list|,
name|__func__
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|schnorr_verify
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|,
name|g_x
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|,
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|out
label|:
name|BN_clear_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Helper functions */
end_comment

begin_comment
comment|/*  * Generate uniformly distributed random number in range (1, high).  * Return number on success, NULL on failure.  */
end_comment

begin_function
name|BIGNUM
modifier|*
name|bn_rand_range_gt_one
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|high
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_set_word
argument_list|(
name|tmp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_set_word(tmp, 2)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_sub
argument_list|(
name|tmp
argument_list|,
name|high
argument_list|,
name|tmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_sub failed (tmp = high - 2)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_rand_range
argument_list|(
name|r
argument_list|,
name|tmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_rand_range failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_set_word
argument_list|(
name|tmp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_set_word(tmp, 2)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|tmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_add failed (r = r + 2)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|success
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|BN_clear_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|0
condition|)
return|return
name|r
return|;
name|BN_clear_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Hash contents of buffer 'b' with hash 'md'. Returns 0 on success,  * with digest via 'digestp' (caller to free) and length via 'lenp'.  * Returns -1 on failure.  */
end_comment

begin_function
name|int
name|hash_buffer
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|,
name|u_char
modifier|*
modifier|*
name|digestp
parameter_list|,
name|u_int
modifier|*
name|lenp
parameter_list|)
block|{
name|u_char
name|digest
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|u_int
name|digest_len
decl_stmt|;
name|EVP_MD_CTX
name|evp_md_ctx
decl_stmt|;
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|evp_md_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_DigestInit_ex
argument_list|(
operator|&
name|evp_md_ctx
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: EVP_DigestInit_ex"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|EVP_DigestUpdate
argument_list|(
operator|&
name|evp_md_ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: EVP_DigestUpdate"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|EVP_DigestFinal_ex
argument_list|(
operator|&
name|evp_md_ctx
argument_list|,
name|digest
argument_list|,
operator|&
name|digest_len
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: EVP_DigestFinal_ex"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|digestp
operator|=
name|xmalloc
argument_list|(
name|digest_len
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|=
name|digest_len
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|digestp
argument_list|,
name|digest
argument_list|,
operator|*
name|lenp
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|evp_md_ctx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|digest
argument_list|,
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
argument_list|)
expr_stmt|;
name|digest_len
operator|=
literal|0
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* print formatted string followed by bignum */
end_comment

begin_function
name|void
name|debug3_bn
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|h
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|out
operator|=
name|NULL
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vasprintf
argument_list|(
operator|&
name|out
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|||
name|out
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: vasprintf failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|debug3
argument_list|(
literal|"%s(null)"
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
block|{
name|h
operator|=
name|BN_bn2hex
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s0x%s"
argument_list|,
name|out
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print formatted string followed by buffer contents in hex */
end_comment

begin_function
name|void
name|debug3_buf
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|,
name|h
index|[
literal|65
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|out
operator|=
name|NULL
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vasprintf
argument_list|(
operator|&
name|out
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|||
name|out
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: vasprintf failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s length %u%s"
argument_list|,
name|out
argument_list|,
name|len
argument_list|,
name|buf
operator|==
name|NULL
condition|?
literal|" (null)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|h
operator|+
name|j
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
operator|-
name|j
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|j
operator|>=
sizeof|sizeof
argument_list|(
name|h
argument_list|)
operator|-
literal|1
operator|||
name|i
operator|==
name|len
operator|-
literal|1
condition|)
block|{
name|debug3
argument_list|(
literal|"    %s"
argument_list|,
name|h
argument_list|)
expr_stmt|;
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Construct a MODP group from hex strings p (which must be a safe  * prime) and g, automatically calculating subgroup q as (p / 2)  */
end_comment

begin_function
name|struct
name|modp_group
modifier|*
name|modp_group_from_g_and_safe_p
parameter_list|(
specifier|const
name|char
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|char
modifier|*
name|grp_p
parameter_list|)
block|{
name|struct
name|modp_group
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|p
operator|=
name|ret
operator|->
name|q
operator|=
name|ret
operator|->
name|g
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|BN_hex2bn
argument_list|(
operator|&
name|ret
operator|->
name|p
argument_list|,
name|grp_p
argument_list|)
operator|==
literal|0
operator|||
name|BN_hex2bn
argument_list|(
operator|&
name|ret
operator|->
name|g
argument_list|,
name|grp_g
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: BN_hex2bn"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Subgroup order is p/2 (p is a safe prime) */
if|if
condition|(
operator|(
name|ret
operator|->
name|q
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_rshift1
argument_list|(
name|ret
operator|->
name|q
argument_list|,
name|ret
operator|->
name|p
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_rshift1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|modp_group_free
parameter_list|(
name|struct
name|modp_group
modifier|*
name|grp
parameter_list|)
block|{
if|if
condition|(
name|grp
operator|->
name|g
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|grp
operator|->
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|->
name|p
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|grp
operator|->
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|->
name|q
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|grp
operator|->
name|q
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|grp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|grp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* main() function for self-test */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCHNORR_MAIN
end_ifdef

begin_function
specifier|static
name|void
name|schnorr_selftest_one
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|g_x
decl_stmt|;
name|u_char
modifier|*
name|sig
decl_stmt|;
name|u_int
name|siglen
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g_x
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_x
argument_list|,
name|grp_g
argument_list|,
name|x
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: g_x"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_sign_buf
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|x
argument_list|,
name|g_x
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|siglen
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_sign"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify_buf
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_x
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: verify fail"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify_buf
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_x
argument_list|,
literal|"JUNK"
argument_list|,
literal|4
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: verify should have failed (bad ID)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sig
index|[
literal|4
index|]
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|schnorr_verify_buf
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_x
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: verify should have failed (bit error)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g_x
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|schnorr_selftest
parameter_list|(
name|void
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|x
decl_stmt|;
name|struct
name|modp_group
modifier|*
name|grp
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
modifier|*
name|hh
decl_stmt|;
name|grp
operator|=
name|jpake_default_group
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|grp
operator|->
name|p
operator|,
literal|"%s: grp->p = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|grp
operator|->
name|q
operator|,
literal|"%s: grp->q = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|grp
operator|->
name|g
operator|,
literal|"%s: grp->g = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* [1, 20) */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"x = %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_set_word
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: set x word"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|schnorr_selftest_one
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* 100 x random [0, p) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_rand_range
argument_list|(
name|x
argument_list|,
name|grp
operator|->
name|p
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_rand_range"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|hh
operator|=
name|BN_bn2hex
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x = (random) 0x%s\n"
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hh
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|schnorr_selftest_one
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* [q-20, q) */
if|if
condition|(
name|BN_set_word
argument_list|(
name|x
argument_list|,
literal|20
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_set_word (x = 20)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_sub
argument_list|(
name|x
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|x
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_sub (q - x)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|19
condition|;
name|i
operator|++
control|)
block|{
name|hh
operator|=
name|BN_bn2hex
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x = (q - %d) 0x%s\n"
argument_list|,
literal|20
operator|-
name|i
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hh
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|schnorr_selftest_one
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_add
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_add (x + 1)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|BN_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|log_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|SYSLOG_LEVEL_DEBUG3
argument_list|,
name|SYSLOG_FACILITY_USER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|schnorr_selftest
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

