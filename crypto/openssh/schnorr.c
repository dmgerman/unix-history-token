begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: schnorr.c,v 1.2 2009/02/18 04:31:21 djm Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 Damien Miller.  All rights reserved.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Implementation of Schnorr signatures / zero-knowledge proofs, based on  * description in:  * 	  * F. Hao, P. Ryan, "Password Authenticated Key Exchange by Juggling",  * 16th Workshop on Security Protocols, Cambridge, April 2008  *  * http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"jpake.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JPAKE
end_ifdef

begin_comment
comment|/* #define SCHNORR_DEBUG */
end_comment

begin_comment
comment|/* Privacy-violating debugging */
end_comment

begin_comment
comment|/* #define SCHNORR_MAIN */
end_comment

begin_comment
comment|/* Include main() selftest */
end_comment

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* Parametise signature hash? (sha256, sha1, etc.) */
end_comment

begin_comment
comment|/* Signature format - include type name, hash type, group params? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCHNORR_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BN
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BUF
parameter_list|(
name|a
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BN
parameter_list|(
name|a
parameter_list|)
value|jpake_debug3_bn a
end_define

begin_define
define|#
directive|define
name|SCHNORR_DEBUG_BUF
parameter_list|(
name|a
parameter_list|)
value|jpake_debug3_buf a
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCHNORR_DEBUG */
end_comment

begin_comment
comment|/*  * Calculate hash component of Schnorr signature H(g || g^v || g^x || id)  * using SHA1. Returns signature as bignum or NULL on error.  */
end_comment

begin_function
specifier|static
name|BIGNUM
modifier|*
name|schnorr_hash
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_v
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|)
block|{
name|u_char
modifier|*
name|digest
decl_stmt|;
name|u_int
name|digest_len
decl_stmt|;
name|BIGNUM
modifier|*
name|h
decl_stmt|;
name|EVP_MD_CTX
name|evp_md_ctx
decl_stmt|;
name|Buffer
name|b
decl_stmt|;
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|evp_md_ctx
argument_list|)
expr_stmt|;
comment|/* h = H(g || p || q || g^v || g^x || id) */
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g_v
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g_x
argument_list|)
expr_stmt|;
name|buffer_put_string
argument_list|(
operator|&
name|b
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BUF
argument_list|(
operator|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
operator|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|,
literal|"%s: hashblob"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_buffer
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|,
operator|&
name|digest
argument_list|,
operator|&
name|digest_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: hash_buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_bin2bn
argument_list|(
name|digest
argument_list|,
operator|(
name|int
operator|)
name|digest_len
argument_list|,
name|h
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_bin2bn"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|success
operator|=
literal|0
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|h
operator|,
literal|"%s: h = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|evp_md_ctx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|digest
argument_list|,
name|digest_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|digest
argument_list|)
expr_stmt|;
name|digest_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|0
condition|)
return|return
name|h
return|;
name|BN_clear_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Schnorr signature to prove knowledge of private value 'x' used  * in public exponent g^x, under group defined by 'grp_p', 'grp_q' and 'grp_g'  * 'idlen' bytes from 'id' will be included in the signature hash as an anti-  * replay salt.  * On success, 0 is returned and *siglen bytes of signature are returned in  * *sig (caller to free). Returns -1 on failure.  */
end_comment

begin_function
name|int
name|schnorr_sign
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|,
name|u_char
modifier|*
modifier|*
name|sig
parameter_list|,
name|u_int
modifier|*
name|siglen
parameter_list|)
block|{
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
name|Buffer
name|b
decl_stmt|;
name|BIGNUM
modifier|*
name|h
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|g_v
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|x
operator|,
literal|"%s: x = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_x
operator|,
literal|"%s: g_x = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Avoid degenerate cases: g^0 yields a spoofable signature */
if|if
condition|(
name|BN_cmp
argument_list|(
name|g_x
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: g_x< 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|h
operator|=
name|g_v
operator|=
name|r
operator|=
name|tmp
operator|=
name|v
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|g_v
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tmp
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * v must be a random element of Zq, so 1<= v< q 	 * we also exclude v = 1, since g^1 looks dangerous 	 */
if|if
condition|(
operator|(
name|v
operator|=
name|bn_rand_range_gt_one
argument_list|(
name|grp_p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: bn_rand_range2"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|v
operator|,
literal|"%s: v = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* g_v = g^v mod p */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_v
argument_list|,
name|grp_g
argument_list|,
name|v
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g^v mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_v
operator|,
literal|"%s: g_v = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* h = H(g || g^v || g^x || id) */
if|if
condition|(
operator|(
name|h
operator|=
name|schnorr_hash
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_v
argument_list|,
name|g_x
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: schnorr_hash failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* r = v - xh mod q */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|tmp
argument_list|,
name|x
argument_list|,
name|h
argument_list|,
name|grp_q
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_mul (tmp = xv mod q)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BN_mod_sub
argument_list|(
name|r
argument_list|,
name|v
argument_list|,
name|tmp
argument_list|,
name|grp_q
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_mul (r = v - tmp)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|r
operator|,
literal|"%s: r = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Signature is (g_v, r) */
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* XXX sigtype-hash as string? */
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g_v
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|siglen
operator|=
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
operator|*
name|sig
operator|=
name|xmalloc
argument_list|(
operator|*
name|siglen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|sig
argument_list|,
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
operator|*
name|siglen
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BUF
argument_list|(
operator|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
operator|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|,
literal|"%s: sigblob"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|g_v
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Verify Schnorr signature 'sig' of length 'siglen' against public exponent  * g_x (g^x) under group defined by 'grp_p', 'grp_q' and 'grp_g'.  * Signature hash will be salted with 'idlen' bytes from 'id'.  * Returns -1 on failure, 0 on incorrect signature or 1 on matching signature.  */
end_comment

begin_function
name|int
name|schnorr_verify
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|g_x
parameter_list|,
specifier|const
name|u_char
modifier|*
name|id
parameter_list|,
name|u_int
name|idlen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sig
parameter_list|,
name|u_int
name|siglen
parameter_list|)
block|{
name|int
name|success
init|=
operator|-
literal|1
decl_stmt|;
name|Buffer
name|b
decl_stmt|;
name|BIGNUM
modifier|*
name|g_v
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|g_xh
decl_stmt|,
modifier|*
name|g_r
decl_stmt|,
modifier|*
name|expected
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_x
operator|,
literal|"%s: g_x = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Avoid degenerate cases: g^0 yields a spoofable signature */
if|if
condition|(
name|BN_cmp
argument_list|(
name|g_x
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: g_x< 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|g_v
operator|=
name|h
operator|=
name|r
operator|=
name|g_xh
operator|=
name|g_r
operator|=
name|expected
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|g_v
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|g_xh
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|g_r
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|expected
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Extract g^v and r from signature blob */
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|b
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BUF
argument_list|(
operator|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
operator|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
operator|,
literal|"%s: sigblob"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|buffer_get_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|g_v
argument_list|)
expr_stmt|;
name|buffer_get_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: remaining bytes in signature %d"
argument_list|,
name|__func__
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_v
operator|,
literal|"%s: g_v = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|r
operator|,
literal|"%s: r = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* h = H(g || g^v || g^x || id) */
if|if
condition|(
operator|(
name|h
operator|=
name|schnorr_hash
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_v
argument_list|,
name|g_x
argument_list|,
name|id
argument_list|,
name|idlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: schnorr_hash failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* g_xh = (g^x)^h */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_xh
argument_list|,
name|g_x
argument_list|,
name|h
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g_x^h mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_xh
operator|,
literal|"%s: g_xh = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* g_r = g^r */
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_r
argument_list|,
name|grp_g
argument_list|,
name|r
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_exp (g_x^h mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|g_r
operator|,
literal|"%s: g_r = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* expected = g^r * g_xh */
if|if
condition|(
name|BN_mod_mul
argument_list|(
name|expected
argument_list|,
name|g_r
argument_list|,
name|g_xh
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%s: BN_mod_mul (expected = g_r mod p)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|expected
operator|,
literal|"%s: expected = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Check g_v == expected */
name|success
operator|=
name|BN_cmp
argument_list|(
name|expected
argument_list|,
name|g_v
argument_list|)
operator|==
literal|0
expr_stmt|;
name|out
label|:
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|BN_clear_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|g_v
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|g_xh
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|g_r
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCHNORR_MAIN
end_ifdef

begin_function
specifier|static
name|void
name|schnorr_selftest_one
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|grp_p
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_q
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|grp_g
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|g_x
decl_stmt|;
name|u_char
modifier|*
name|sig
decl_stmt|;
name|u_int
name|siglen
decl_stmt|;
name|BN_CTX
modifier|*
name|bn_ctx
decl_stmt|;
if|if
condition|(
operator|(
name|bn_ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_CTX_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g_x
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_mod_exp
argument_list|(
name|g_x
argument_list|,
name|grp_g
argument_list|,
name|x
argument_list|,
name|grp_p
argument_list|,
name|bn_ctx
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: g_x"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_sign
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|x
argument_list|,
name|g_x
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|siglen
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: schnorr_sign"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_x
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: verify fail"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|schnorr_verify
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_x
argument_list|,
literal|"JUNK"
argument_list|,
literal|4
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: verify should have failed (bad ID)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sig
index|[
literal|4
index|]
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|schnorr_verify
argument_list|(
name|grp_p
argument_list|,
name|grp_q
argument_list|,
name|grp_g
argument_list|,
name|g_x
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: verify should have failed (bit error)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g_x
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bn_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|schnorr_selftest
parameter_list|(
name|void
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|x
decl_stmt|;
name|struct
name|jpake_group
modifier|*
name|grp
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
modifier|*
name|hh
decl_stmt|;
name|grp
operator|=
name|jpake_default_group
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|grp
operator|->
name|p
operator|,
literal|"%s: grp->p = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|grp
operator|->
name|q
operator|,
literal|"%s: grp->q = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SCHNORR_DEBUG_BN
argument_list|(
operator|(
name|grp
operator|->
name|g
operator|,
literal|"%s: grp->g = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* [1, 20) */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"x = %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_set_word
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: set x word"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|schnorr_selftest_one
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* 100 x random [0, p) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_rand_range
argument_list|(
name|x
argument_list|,
name|grp
operator|->
name|p
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_rand_range"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|hh
operator|=
name|BN_bn2hex
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x = (random) 0x%s\n"
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hh
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|schnorr_selftest_one
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* [q-20, q) */
if|if
condition|(
name|BN_set_word
argument_list|(
name|x
argument_list|,
literal|20
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_set_word (x = 20)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_sub
argument_list|(
name|x
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|x
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_sub (q - x)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|19
condition|;
name|i
operator|++
control|)
block|{
name|hh
operator|=
name|BN_bn2hex
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x = (q - %d) 0x%s\n"
argument_list|,
literal|20
operator|-
name|i
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hh
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|schnorr_selftest_one
argument_list|(
name|grp
operator|->
name|p
argument_list|,
name|grp
operator|->
name|q
argument_list|,
name|grp
operator|->
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_add
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: BN_add (x + 1)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|BN_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|log_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|SYSLOG_LEVEL_DEBUG3
argument_list|,
name|SYSLOG_FACILITY_USER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|schnorr_selftest
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

