begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: rsa.c,v 1.28 2006/08/03 03:34:42 deraadt Exp $ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  *  * Copyright (c) 1999 Niels Provos.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * Description of the RSA algorithm can be found e.g. from the following  * sources:  *  *   Bruce Schneier: Applied Cryptography.  John Wiley& Sons, 1994.  *  *   Jennifer Seberry and Josed Pieprzyk: Cryptography: An Introduction to  *   Computer Security.  Prentice-Hall, 1989.  *  *   Man Young Rhee: Cryptography and Secure Data Communications.  McGraw-Hill,  *   1994.  *  *   R. Rivest, A. Shamir, and L. M. Adleman: Cryptographic Communications  *   System and Method.  US Patent 4,405,829, 1983.  *  *   Hans Riesel: Prime Numbers and Computer Methods for Factorization.  *   Birkhauser, 1994.  *  *   The RSA Frequently Asked Questions document by RSA Data Security,  *   Inc., 1995.  *  *   RSA in 3 lines of perl by Adam Back<aba@atlax.ex.ac.uk>, 1995, as  * included below:  *  *     [gone - had to be deleted - what a pity]  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_function
name|void
name|rsa_public_encrypt
parameter_list|(
name|BIGNUM
modifier|*
name|out
parameter_list|,
name|BIGNUM
modifier|*
name|in
parameter_list|,
name|RSA
modifier|*
name|key
parameter_list|)
block|{
name|u_char
modifier|*
name|inbuf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ilen
decl_stmt|,
name|olen
decl_stmt|;
if|if
condition|(
name|BN_num_bits
argument_list|(
name|key
operator|->
name|e
argument_list|)
operator|<
literal|2
operator|||
operator|!
name|BN_is_odd
argument_list|(
name|key
operator|->
name|e
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"rsa_public_encrypt() exponent too small or not odd"
argument_list|)
expr_stmt|;
name|olen
operator|=
name|BN_num_bytes
argument_list|(
name|key
operator|->
name|n
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|xmalloc
argument_list|(
name|olen
argument_list|)
expr_stmt|;
name|ilen
operator|=
name|BN_num_bytes
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|inbuf
operator|=
name|xmalloc
argument_list|(
name|ilen
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|in
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|RSA_public_encrypt
argument_list|(
name|ilen
argument_list|,
name|inbuf
argument_list|,
name|outbuf
argument_list|,
name|key
argument_list|,
name|RSA_PKCS1_PADDING
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"rsa_public_encrypt() failed"
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|outbuf
argument_list|,
name|len
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|outbuf
argument_list|,
literal|0
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|inbuf
argument_list|,
literal|0
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rsa_private_decrypt
parameter_list|(
name|BIGNUM
modifier|*
name|out
parameter_list|,
name|BIGNUM
modifier|*
name|in
parameter_list|,
name|RSA
modifier|*
name|key
parameter_list|)
block|{
name|u_char
modifier|*
name|inbuf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ilen
decl_stmt|,
name|olen
decl_stmt|;
name|olen
operator|=
name|BN_num_bytes
argument_list|(
name|key
operator|->
name|n
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|xmalloc
argument_list|(
name|olen
argument_list|)
expr_stmt|;
name|ilen
operator|=
name|BN_num_bytes
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|inbuf
operator|=
name|xmalloc
argument_list|(
name|ilen
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|in
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|RSA_private_decrypt
argument_list|(
name|ilen
argument_list|,
name|inbuf
argument_list|,
name|outbuf
argument_list|,
name|key
argument_list|,
name|RSA_PKCS1_PADDING
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"rsa_private_decrypt() failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BN_bin2bn
argument_list|(
name|outbuf
argument_list|,
name|len
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|outbuf
argument_list|,
literal|0
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|inbuf
argument_list|,
literal|0
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* calculate p-1 and q-1 */
end_comment

begin_function
name|void
name|rsa_generate_additional_parameters
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|aux
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
operator|(
name|aux
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"rsa_generate_additional_parameters: BN_new failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"rsa_generate_additional_parameters: BN_CTX_new failed"
argument_list|)
expr_stmt|;
name|BN_sub
argument_list|(
name|aux
argument_list|,
name|rsa
operator|->
name|q
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|rsa
operator|->
name|dmq1
argument_list|,
name|rsa
operator|->
name|d
argument_list|,
name|aux
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_sub
argument_list|(
name|aux
argument_list|,
name|rsa
operator|->
name|p
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|rsa
operator|->
name|dmp1
argument_list|,
name|rsa
operator|->
name|d
argument_list|,
name|aux
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
name|aux
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

